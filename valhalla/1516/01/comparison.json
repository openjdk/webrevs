{"files":[{"patch":"@@ -8,0 +8,4 @@\n+\n+[src\/hotspot\/**.{cpp,hpp,h}]\n+indent_style = space\n+indent_size = 2\n","filename":".editorconfig","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -597,1 +597,1 @@\n-<td>Microsoft Visual Studio 2022 version 17.6.5<\/td>\n+<td>Microsoft Visual Studio 2022 version 17.13.2<\/td>\n","filename":"doc\/building.html","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -393,5 +393,5 @@\n-| Operating system   | Toolchain version                           |\n-| ------------------ | ------------------------------------------- |\n-| Linux              | gcc 14.2.0                                  |\n-| macOS              | Apple Xcode 14.3.1 (using clang 14.0.3)     |\n-| Windows            | Microsoft Visual Studio 2022 version 17.6.5 |\n+| Operating system   | Toolchain version                            |\n+| ------------------ | -------------------------------------------- |\n+| Linux              | gcc 14.2.0                                   |\n+| macOS              | Apple Xcode 14.3.1 (using clang 14.0.3)      |\n+| Windows            | Microsoft Visual Studio 2022 version 17.13.2 |\n","filename":"doc\/building.md","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  STATIC_JDK_BUNDLE_SUBDIR := static-jdk-$(VERSION_NUMBER)\n@@ -180,0 +181,1 @@\n+    STATIC_JDK_BUNDLE_SUBDIR := $(STATIC_JDK_BUNDLE_SUBDIR)\/$(DEBUG_LEVEL)\n@@ -503,0 +505,15 @@\n+#################################################################################\n+\n+ifneq ($(filter static-jdk-bundles, $(MAKECMDGOALS)), )\n+  STATIC_JDK_BUNDLE_FILES := $(call FindFiles, $(STATIC_JDK_IMAGE_DIR))\n+\n+  $(eval $(call SetupBundleFile, BUILD_STATIC_JDK_BUNDLE, \\\n+      BUNDLE_NAME := $(STATIC_JDK_BUNDLE_NAME), \\\n+      FILES := $(STATIC_JDK_BUNDLE_FILES), \\\n+      BASE_DIRS := $(STATIC_JDK_IMAGE_DIR), \\\n+      SUBDIR := $(STATIC_JDK_BUNDLE_SUBDIR), \\\n+  ))\n+\n+  STATIC_JDK_TARGETS += $(BUILD_STATIC_JDK_BUNDLE)\n+endif\n+\n@@ -513,0 +530,1 @@\n+static-jdk-bundles: $(STATIC_JDK_TARGETS)\n@@ -517,1 +535,1 @@\n-    static-libs-bundles static-libs-graal-bundles jcov-bundles\n+    static-libs-bundles static-libs-graal-bundles static-jdk-bundles jcov-bundles\n","filename":"make\/Bundles.gmk","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    --override-methods=summary\n+    --override-methods=summary --syntax-highlight\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    -Duser.language=en -Duser.country=US\n+    -Duser.language=en -Duser.country=US --enable-native-access=ALL-UNNAMED\n","filename":"make\/GenerateLinkOptData.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -878,0 +878,6 @@\n+$(eval $(call SetupTarget, static-jdk-bundles, \\\n+    MAKEFILE := Bundles, \\\n+    TARGET := static-jdk-bundles, \\\n+    DEPS := static-jdk-image, \\\n+))\n+\n","filename":"make\/Main.gmk","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -523,1 +523,4 @@\n-  UBSAN_CFLAGS=\"$UBSAN_CHECKS -Wno-stringop-truncation -Wno-format-overflow -Wno-array-bounds -Wno-stringop-overflow -fno-omit-frame-pointer -DUNDEFINED_BEHAVIOR_SANITIZER\"\n+  UBSAN_CFLAGS=\"$UBSAN_CHECKS -Wno-array-bounds -fno-omit-frame-pointer -DUNDEFINED_BEHAVIOR_SANITIZER\"\n+  if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\"; then\n+    UBSAN_CFLAGS=\"$UBSAN_CFLAGS -Wno-format-overflow -Wno-stringop-overflow -Wno-stringop-truncation\"\n+  fi\n@@ -525,0 +528,10 @@\n+  # On AIX, the llvm_symbolizer is not found out of the box, so we have to provide the\n+  # full qualified llvm_symbolizer path in the __ubsan_default_options() function in\n+  # make\/data\/ubsan\/ubsan_default_options.c. To get it there we compile our sources\n+  # with an additional define LLVM_SYMBOLIZER, which we set here.\n+  # To calculate the correct llvm_symbolizer path we can use the location of the compiler, because\n+  # their relation is fixed.\n+  if test \"x$TOOLCHAIN_TYPE\" = \"xclang\" && test \"x$OPENJDK_TARGET_OS\" = \"xaix\"; then\n+      UBSAN_CFLAGS=\"$UBSAN_CFLAGS -fno-sanitize=function,vptr -DLLVM_SYMBOLIZER=$(dirname $(dirname $CC))\/tools\/ibm-llvm-symbolizer\"\n+      UBSAN_LDFLAGS=\"$UBSAN_LDFLAGS -fno-sanitize=function,vptr -Wl,-bbigtoc\"\n+  fi\n","filename":"make\/autoconf\/jdk-options.m4","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -849,0 +849,1 @@\n+STATIC_JDK_IMAGE_SUBDIR := static-jdk\n@@ -853,0 +854,1 @@\n+STATIC_JDK_IMAGE_DIR = $(IMAGES_OUTPUTDIR)\/$(STATIC_JDK_IMAGE_SUBDIR)\n@@ -932,0 +934,1 @@\n+STATIC_JDK_BUNDLE_NAME := static-jdk-$(BASE_NAME)_bin$(DEBUG_PART).$(JDK_BUNDLE_EXTENSION)\n@@ -942,0 +945,1 @@\n+STATIC_JDK_BUNDLE := $(BUNDLES_OUTPUTDIR)\/$(STATIC_JDK_BUNDLE_NAME)\n","filename":"make\/autoconf\/spec.gmk.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1093,1 +1093,1 @@\n-        windows_x64: \"VS2022-17.6.5+1.0\",\n+        windows_x64: \"VS2022-17.13.2+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,12 @@\n+\/\/ On AIX, the llvm_symbolizer is not found out of the box, so we have to provide the\n+\/\/ full qualified llvm_symbolizer path in the __ubsan_default_options() function.\n+\/\/ To get it here we compile our sources with an additional define LLVM_SYMBOLIZER\n+\/\/ containing the path, which we set in make\/autoconf\/jdk-options.m4.\n+#ifdef LLVM_SYMBOLIZER\n+#define _LLVM_SYMBOLIZER(X) \",external_symbolizer_path=\" X_LLVM_SYMBOLIZER(X)\n+#define X_LLVM_SYMBOLIZER(X) #X\n+#else\n+#define LLVM_SYMBOLIZER\n+#define _LLVM_SYMBOLIZER(X)\n+#endif\n+\n@@ -53,1 +65,1 @@\n-  return \"halt_on_error=1,print_stacktrace=1\";\n+  return \"halt_on_error=1,print_stacktrace=1\" _LLVM_SYMBOLIZER(LLVM_SYMBOLIZER);\n","filename":"make\/data\/ubsan\/ubsan_default_options.c","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+uppercase = $(shell echo $1 | tr a-z A-Z)\n+\n@@ -94,92 +96,10 @@\n-# Latest that could be made to work.\n-GCC_VER := 14.2.0\n-ifeq ($(GCC_VER), 14.2.0)\n-  gcc_ver := gcc-14.2.0\n-  binutils_ver := binutils-2.43\n-  ccache_ver := ccache-4.10.2\n-  CCACHE_CMAKE_BASED := 1\n-  mpfr_ver := mpfr-4.2.1\n-  gmp_ver := gmp-6.3.0\n-  mpc_ver := mpc-1.3.1\n-  gdb_ver := gdb-15.2\n-  REQUIRED_MIN_MAKE_MAJOR_VERSION := 4\n-else ifeq ($(GCC_VER), 13.2.0)\n-  gcc_ver := gcc-13.2.0\n-  binutils_ver := binutils-2.41\n-  ccache_ver := ccache-3.7.12\n-  mpfr_ver := mpfr-4.2.0\n-  gmp_ver := gmp-6.3.0\n-  mpc_ver := mpc-1.3.1\n-  gdb_ver := gdb-13.2\n-  REQUIRED_MIN_MAKE_MAJOR_VERSION := 4\n-else ifeq ($(GCC_VER), 11.3.0)\n-  gcc_ver := gcc-11.3.0\n-  binutils_ver := binutils-2.39\n-  ccache_ver := ccache-3.7.12\n-  mpfr_ver := mpfr-4.1.1\n-  gmp_ver := gmp-6.2.1\n-  mpc_ver := mpc-1.2.1\n-  gdb_ver := gdb-11.2\n-  REQUIRED_MIN_MAKE_MAJOR_VERSION := 4\n-else ifeq ($(GCC_VER), 11.2.0)\n-  gcc_ver := gcc-11.2.0\n-  binutils_ver := binutils-2.37\n-  ccache_ver := ccache-3.7.12\n-  mpfr_ver := mpfr-4.1.0\n-  gmp_ver := gmp-6.2.1\n-  mpc_ver := mpc-1.2.1\n-  gdb_ver := gdb-11.1\n-  REQUIRED_MIN_MAKE_MAJOR_VERSION := 4\n-else ifeq ($(GCC_VER), 10.3.0)\n-  gcc_ver := gcc-10.3.0\n-  binutils_ver := binutils-2.36.1\n-  ccache_ver := ccache-3.7.11\n-  mpfr_ver := mpfr-4.1.0\n-  gmp_ver := gmp-6.2.0\n-  mpc_ver := mpc-1.1.0\n-  gdb_ver := gdb-10.1\n-  REQUIRED_MIN_MAKE_MAJOR_VERSION := 4\n-else ifeq ($(GCC_VER), 10.2.0)\n-  gcc_ver := gcc-10.2.0\n-  binutils_ver := binutils-2.35\n-  ccache_ver := ccache-3.7.11\n-  mpfr_ver := mpfr-4.1.0\n-  gmp_ver := gmp-6.2.0\n-  mpc_ver := mpc-1.1.0\n-  gdb_ver := gdb-9.2\n-  REQUIRED_MIN_MAKE_MAJOR_VERSION := 4\n-else ifeq ($(GCC_VER), 9.2.0)\n-  gcc_ver := gcc-9.2.0\n-  binutils_ver := binutils-2.34\n-  ccache_ver := ccache-3.7.3\n-  mpfr_ver := mpfr-3.1.5\n-  gmp_ver := gmp-6.1.2\n-  mpc_ver := mpc-1.0.3\n-  gdb_ver := gdb-8.3\n-else ifeq ($(GCC_VER), 8.3.0)\n-  gcc_ver := gcc-8.3.0\n-  binutils_ver := binutils-2.32\n-  ccache_ver := ccache-3.7.3\n-  mpfr_ver := mpfr-3.1.5\n-  gmp_ver := gmp-6.1.2\n-  mpc_ver := mpc-1.0.3\n-  gdb_ver := gdb-8.3\n-else ifeq ($(GCC_VER), 7.3.0)\n-  gcc_ver := gcc-7.3.0\n-  binutils_ver := binutils-2.30\n-  ccache_ver := ccache-3.3.6\n-  mpfr_ver := mpfr-3.1.5\n-  gmp_ver := gmp-6.1.2\n-  mpc_ver := mpc-1.0.3\n-  gdb_ver := gdb-8.1\n-else ifeq ($(GCC_VER), 4.9.2)\n-  gcc_ver := gcc-4.9.2\n-  binutils_ver := binutils-2.25\n-  ccache_ver := ccache-3.2.1\n-  mpfr_ver := mpfr-3.0.1\n-  gmp_ver := gmp-4.3.2\n-  mpc_ver := mpc-1.0.1\n-  gdb_ver := gdb-7.12.1\n-else\n-  $(error Unsupported GCC version)\n-endif\n+gcc_ver_only := 14.2.0\n+binutils_ver_only := 2.43\n+ccache_ver_only := 4.10.2\n+CCACHE_CMAKE_BASED := 1\n+mpfr_ver_only := 4.2.1\n+gmp_ver_only := 6.3.0\n+mpc_ver_only := 1.3.1\n+gdb_ver_only := 15.2\n+\n+dependencies := gcc binutils ccache mpfr gmp mpc gdb\n@@ -187,0 +107,11 @@\n+$(foreach dep,$(dependencies),$(eval $(dep)_ver := $(dep)-$($(dep)_ver_only)))\n+\n+GCC := http:\/\/ftp.gnu.org\/pub\/gnu\/gcc\/$(gcc_ver)\/$(gcc_ver).tar.xz\n+BINUTILS := http:\/\/ftp.gnu.org\/pub\/gnu\/binutils\/$(binutils_ver).tar.gz\n+CCACHE := https:\/\/github.com\/ccache\/ccache\/releases\/download\/v$(ccache_ver_only)\/$(ccache_ver).tar.xz\n+MPFR := https:\/\/www.mpfr.org\/$(mpfr_ver)\/$(mpfr_ver).tar.bz2\n+GMP := http:\/\/ftp.gnu.org\/pub\/gnu\/gmp\/$(gmp_ver).tar.bz2\n+MPC := http:\/\/ftp.gnu.org\/pub\/gnu\/mpc\/$(mpc_ver).tar.gz\n+GDB := http:\/\/ftp.gnu.org\/gnu\/gdb\/$(gdb_ver).tar.xz\n+\n+REQUIRED_MIN_MAKE_MAJOR_VERSION := 4\n@@ -195,11 +126,0 @@\n-ccache_ver_only := $(patsubst ccache-%,%,$(ccache_ver))\n-\n-\n-GCC := http:\/\/ftp.gnu.org\/pub\/gnu\/gcc\/$(gcc_ver)\/$(gcc_ver).tar.xz\n-BINUTILS := http:\/\/ftp.gnu.org\/pub\/gnu\/binutils\/$(binutils_ver).tar.gz\n-CCACHE := https:\/\/github.com\/ccache\/ccache\/releases\/download\/v$(ccache_ver_only)\/$(ccache_ver).tar.xz\n-MPFR := https:\/\/www.mpfr.org\/${mpfr_ver}\/${mpfr_ver}.tar.bz2\n-GMP := http:\/\/ftp.gnu.org\/pub\/gnu\/gmp\/${gmp_ver}.tar.bz2\n-MPC := http:\/\/ftp.gnu.org\/pub\/gnu\/mpc\/${mpc_ver}.tar.gz\n-GDB := http:\/\/ftp.gnu.org\/gnu\/gdb\/${gdb_ver}.tar.xz\n-\n@@ -300,1 +220,1 @@\n-$(foreach p,GCC BINUTILS CCACHE MPFR GMP MPC GDB,$(eval $(call Download,$(p))))\n+$(foreach dep,$(dependencies),$(eval $(call Download,$(call uppercase,$(dep)))))\n@@ -377,1 +297,1 @@\n-$(foreach t,binutils mpfr gmp mpc gcc ccache gdb,$(eval $(t) = $(TARGETDIR)\/$($(t)_ver).done))\n+$(foreach dep,$(dependencies),$(eval $(dep) = $(TARGETDIR)\/$($(dep)_ver).done))\n@@ -724,1 +644,1 @@\n-      addr2line ar as c++ c++filt dwp elfedit g++ gcc gcc-$(GCC_VER) gprof ld ld.bfd \\\n+      addr2line ar as c++ c++filt dwp elfedit g++ gcc gcc-$(gcc_ver_only) gprof ld ld.bfd \\\n@@ -729,1 +649,1 @@\n-$(PREFIX)\/lib\/bfd-plugins\/liblto_plugin.so: $(PREFIX)\/libexec\/gcc\/$(TARGET)\/$(GCC_VER)\/liblto_plugin.so\n+$(PREFIX)\/lib\/bfd-plugins\/liblto_plugin.so: $(PREFIX)\/libexec\/gcc\/$(TARGET)\/$(gcc_ver_only)\/liblto_plugin.so\n","filename":"make\/devkit\/Tools.gmk","additions":27,"deletions":107,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+UNAME_OS=`uname -o`\n@@ -63,0 +64,3 @@\n+IS_MSYS=`echo $UNAME_OS | grep -i Msys`\n+MSYS2_ARG_CONV_EXCL=\"*\"          # make \"cmd.exe \/c\" work for msys2\n+CMD_EXE=\"cmd.exe \/c\"\n@@ -65,0 +69,2 @@\n+elif test \"x$IS_MSYS\" != \"x\"; then\n+    BUILD_ENV=\"cygwin\"\n@@ -68,1 +74,1 @@\n-    echo \"Unknown environment; only Cygwin and WSL are supported.\"\n+    echo \"Unknown environment; only Cygwin\/MSYS2\/WSL are supported.\"\n@@ -79,1 +85,1 @@\n-PROGRAMFILES_X86=\"$($WINDOWS_PATH_TO_UNIX_PATH \"$(cmd.exe \/c set | sed -n 's\/^ProgramFiles(x86)=\/\/p' | tr -d '\\r')\")\"\n+PROGRAMFILES_X86=\"$($WINDOWS_PATH_TO_UNIX_PATH \"$(${CMD_EXE} set | sed -n 's\/^ProgramFiles(x86)=\/\/p' | tr -d '\\r')\")\"\n@@ -102,1 +108,2 @@\n-VSNNNCOMNTOOLS=`cmd.exe \/c echo %VS${VS_VERSION_NUM_NODOT}COMNTOOLS% | tr -d '\\r'`\n+VSNNNCOMNTOOLS=`${CMD_EXE} echo %VS${VS_VERSION_NUM_NODOT}COMNTOOLS% | tr -d '\\r'`\n+VSNNNCOMNTOOLS=\"$($WINDOWS_PATH_TO_UNIX_PATH \"$VSNNNCOMNTOOLS\")\"\n@@ -104,1 +111,1 @@\n-    VS_INSTALL_DIR=\"$($WINDOWS_PATH_TO_UNIX_PATH \"$VSNNNCOMNTOOLS\/..\/..\")\"\n+    VS_INSTALL_DIR=\"$VSNNNCOMNTOOLS\/..\/..\"\n@@ -109,0 +116,1 @@\n+echo \"VSNNNCOMNTOOLS: $VSNNNCOMNTOOLS\"\n@@ -183,1 +191,5 @@\n-SDK_INSTALL_DIR=\"$PROGRAMFILES_X86\/Windows Kits\/$SDK_VERSION\"\n+SDK_INSTALL_DIR=`${CMD_EXE} echo %WindowsSdkDir% | tr -d '\\r'`\n+SDK_INSTALL_DIR=\"$($WINDOWS_PATH_TO_UNIX_PATH \"$SDK_INSTALL_DIR\")\"\n+if [ ! -d \"$SDK_INSTALL_DIR\" ]; then\n+    SDK_INSTALL_DIR=\"$PROGRAMFILES_X86\/Windows Kits\/$SDK_VERSION\"\n+fi\n","filename":"make\/devkit\/createWindowsDevkit.sh","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n@@ -62,0 +64,1 @@\n+    @SuppressWarnings(\"restricted\")\n@@ -144,0 +147,1 @@\n+        MethodHandles.Lookup.ClassOption.class.getEnumConstants();\n@@ -163,0 +167,3 @@\n+        \/\/ record run-time methods\n+        o.equals(new B(5));\n+        o.hashCode();\n@@ -170,0 +177,4 @@\n+\n+        \/\/ Initialize FFM linkers\n+        var signature = FunctionDescriptor.ofVoid();\n+        Linker.nativeLinker().downcallHandle(signature);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/classlist\/HelloClasslist.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -161,0 +161,1 @@\n+    EXTRA_HEADER_DIRS := java.base:libjava, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-# Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,4 +44,0 @@\n-# Get an absolute path to this script, since that determines the top-level directory.\n-this_script_dir=`dirname $0`\n-this_script_dir=`cd $this_script_dir > \/dev\/null && pwd`\n-\n@@ -101,0 +97,6 @@\n+git_installed=false\n+which git > \/dev\/null && git_installed=true\n+if [ \"$git_installed\" != \"true\" ]; then\n+  echo \"Error: This script requires git. Please install it.\"\n+  exit 1\n+fi\n@@ -102,1 +104,1 @@\n-[ -d \"${this_script_dir}\/..\/..\/.git\" ] && git_found=true\n+git status &> \/dev\/null && git_found=true\n@@ -104,1 +106,1 @@\n-  echo \"Error: Please execute script from within make\/scripts.\"\n+  echo \"Error: Please execute script from within a JDK git repository.\"\n","filename":"make\/scripts\/update_copyright_year.sh","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,3 +0,0 @@\n-[*.{cpp,hpp,c,h}]\n-indent_style = space\n-indent_size = 2\n","filename":"src\/hotspot\/.editorconfig","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2293,0 +2293,20 @@\n+    case Op_FmaHF:\n+      \/\/ UseFMA flag also needs to be checked along with FEAT_FP16\n+      if (!UseFMA || !is_feat_fp16_supported()) {\n+        return false;\n+      }\n+      break;\n+    case Op_AddHF:\n+    case Op_SubHF:\n+    case Op_MulHF:\n+    case Op_DivHF:\n+    case Op_MinHF:\n+    case Op_MaxHF:\n+    case Op_SqrtHF:\n+      \/\/ Half-precision floating point scalar operations require FEAT_FP16\n+      \/\/ to be available. FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\"\n+      \/\/ features are supported.\n+      if (!is_feat_fp16_supported()) {\n+        return false;\n+      }\n+      break;\n@@ -2303,1 +2323,1 @@\n-  return EnableVectorSupport && UseVectorStubs;\n+  return EnableVectorSupport;\n@@ -2307,1 +2327,1 @@\n-  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(EnableVectorSupport, \"sanity\");\n@@ -4627,0 +4647,9 @@\n+\/\/ Half Float (FP16) Immediate\n+operand immH()\n+%{\n+  match(ConH);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -6970,0 +6999,15 @@\n+\/\/ Load Half Float Constant\n+\/\/ The \"ldr\" instruction loads a 32-bit word from the constant pool into a\n+\/\/ 32-bit register but only the bottom half will be populated and the top\n+\/\/ 16 bits are zero.\n+instruct loadConH(vRegF dst, immH con) %{\n+  match(Set dst con);\n+  format %{\n+    \"ldrs $dst, [$constantaddress]\\t# load from constant table: half float=$con\\n\\t\"\n+  %}\n+  ins_encode %{\n+    __ ldrs(as_FloatRegister($dst$$reg), $constantaddress($con));\n+  %}\n+  ins_pipe(fp_load_constant_s);\n+%}\n+\n@@ -8202,0 +8246,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -8211,0 +8256,13 @@\n+instruct castII_checked(iRegI dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastII dst));\n+  effect(KILL cr);\n+\n+  format %{ \"# castII_checked of $dst\" %}\n+  ins_encode %{\n+    __ verify_int_in_range(_idx, bottom_type()->is_int(), $dst$$Register, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -8213,0 +8271,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -8222,0 +8281,13 @@\n+instruct castLL_checked(iRegL dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastLL dst));\n+  effect(KILL cr);\n+\n+  format %{ \"# castLL_checked of $dst\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -13664,0 +13736,11 @@\n+instruct addHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (AddHF src1 src2));\n+  format %{ \"faddh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ faddh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13694,0 +13777,11 @@\n+instruct subHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (SubHF src1 src2));\n+  format %{ \"fsubh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fsubh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13724,0 +13818,11 @@\n+instruct mulHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MulHF src1 src2));\n+  format %{ \"fmulh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fmulh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13754,0 +13859,14 @@\n+\/\/ src1 * src2 + src3 (half-precision float)\n+instruct maddHF_reg_reg(vRegF dst, vRegF src1, vRegF src2, vRegF src3) %{\n+  match(Set dst (FmaHF src3 (Binary src1 src2)));\n+  format %{ \"fmaddh $dst, $src1, $src2, $src3\" %}\n+  ins_encode %{\n+    assert(UseFMA, \"Needs FMA instructions support.\");\n+    __ fmaddh($dst$$FloatRegister,\n+              $src1$$FloatRegister,\n+              $src2$$FloatRegister,\n+              $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -13895,0 +14014,23 @@\n+\/\/ Math.max(HH)H (half-precision float)\n+instruct maxHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MaxHF src1 src2));\n+  format %{ \"fmaxh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fmaxh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+\/\/ Math.min(HH)H (half-precision float)\n+instruct minHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MinHF src1 src2));\n+  format %{ \"fminh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fminh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n@@ -13952,0 +14094,10 @@\n+instruct divHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (DivHF src1  src2));\n+  format %{ \"fdivh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fdivh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_div_s);\n+%}\n@@ -14125,0 +14277,10 @@\n+instruct sqrtHF_reg(vRegF dst, vRegF src) %{\n+  match(Set dst (SqrtHF src));\n+  format %{ \"fsqrth $dst, $src\" %}\n+  ins_encode %{\n+    __ fsqrth($dst$$FloatRegister,\n+              $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_div_s);\n+%}\n+\n@@ -17211,0 +17373,58 @@\n+\/\/----------------------------- Reinterpret ----------------------------------\n+\/\/ Reinterpret a half-precision float value in a floating point register to a general purpose register\n+instruct reinterpretHF2S(iRegINoSp dst, vRegF src) %{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"reinterpretHF2S $dst, $src\" %}\n+  ins_encode %{\n+    __ smov($dst$$Register, $src$$FloatRegister, __ H, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Reinterpret a half-precision float value in a general purpose register to a floating point register\n+instruct reinterpretS2HF(vRegF dst, iRegINoSp src) %{\n+  match(Set dst (ReinterpretS2HF src));\n+  format %{ \"reinterpretS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ mov($dst$$FloatRegister, __ H, 0, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Without this optimization, ReinterpretS2HF (ConvF2HF src) would result in the following\n+\/\/ instructions (the first two are for ConvF2HF and the last instruction is for ReinterpretS2HF) -\n+\/\/ fcvt $tmp1_fpr, $src_fpr    \/\/ Convert float to half-precision float\n+\/\/ mov  $tmp2_gpr, $tmp1_fpr   \/\/ Move half-precision float in FPR to a GPR\n+\/\/ mov  $dst_fpr,  $tmp2_gpr   \/\/ Move the result from a GPR to an FPR\n+\/\/ The move from FPR to GPR in ConvF2HF and the move from GPR to FPR in ReinterpretS2HF\n+\/\/ can be omitted in this pattern, resulting in -\n+\/\/ fcvt $dst, $src  \/\/ Convert float to half-precision float\n+instruct convF2HFAndS2HF(vRegF dst, vRegF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvtsh($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Without this optimization, ConvHF2F (ReinterpretHF2S src) would result in the following\n+\/\/ instructions (the first one is for ReinterpretHF2S and the last two are for ConvHF2F) -\n+\/\/ mov  $tmp1_gpr, $src_fpr  \/\/ Move the half-precision float from an FPR to a GPR\n+\/\/ mov  $tmp2_fpr, $tmp1_gpr \/\/ Move the same value from GPR to an FPR\n+\/\/ fcvt $dst_fpr,  $tmp2_fpr \/\/ Convert the half-precision float to 32-bit float\n+\/\/ The move from FPR to GPR in ReinterpretHF2S and the move from GPR to FPR in ConvHF2F\n+\/\/ can be omitted as the input (src) is already in an FPR required for the fcvths instruction\n+\/\/ resulting in -\n+\/\/ fcvt $dst, $src  \/\/ Convert half-precision float to a 32-bit float\n+instruct convHF2SAndHF2F(vRegF dst, vRegF src)\n+%{\n+  match(Set dst (ConvHF2F (ReinterpretHF2S src)));\n+  format %{ \"convHF2SAndHF2F $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvths($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":223,"deletions":3,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2035,0 +2035,2 @@\n+  INSN(fsqrth, 0b11, 0b000011);   \/\/ Half-precision sqrt\n+\n@@ -2062,1 +2064,1 @@\n-  void data_processing(unsigned op31, unsigned type, unsigned opcode,\n+  void data_processing(unsigned op31, unsigned type, unsigned opcode, unsigned op21,\n@@ -2067,1 +2069,1 @@\n-    f(type, 23, 22), f(1, 21), f(opcode, 15, 10);\n+    f(type, 23, 22), f(op21, 21), f(opcode, 15, 10);\n@@ -2071,1 +2073,1 @@\n-#define INSN(NAME, op31, type, opcode)                  \\\n+#define INSN(NAME, op31, type, opcode, op21)                            \\\n@@ -2073,20 +2075,51 @@\n-    data_processing(op31, type, opcode, Vd, Vn, Vm);    \\\n-  }\n-\n-  INSN(fabds,  0b011, 0b10, 0b110101);\n-  INSN(fmuls,  0b000, 0b00, 0b000010);\n-  INSN(fdivs,  0b000, 0b00, 0b000110);\n-  INSN(fadds,  0b000, 0b00, 0b001010);\n-  INSN(fsubs,  0b000, 0b00, 0b001110);\n-  INSN(fmaxs,  0b000, 0b00, 0b010010);\n-  INSN(fmins,  0b000, 0b00, 0b010110);\n-  INSN(fnmuls, 0b000, 0b00, 0b100010);\n-\n-  INSN(fabdd,  0b011, 0b11, 0b110101);\n-  INSN(fmuld,  0b000, 0b01, 0b000010);\n-  INSN(fdivd,  0b000, 0b01, 0b000110);\n-  INSN(faddd,  0b000, 0b01, 0b001010);\n-  INSN(fsubd,  0b000, 0b01, 0b001110);\n-  INSN(fmaxd,  0b000, 0b01, 0b010010);\n-  INSN(fmind,  0b000, 0b01, 0b010110);\n-  INSN(fnmuld, 0b000, 0b01, 0b100010);\n+    data_processing(op31, type, opcode, op21, Vd, Vn, Vm);              \\\n+  }\n+\n+  INSN(fmuls,  0b000, 0b00, 0b000010, 0b1);\n+  INSN(fdivs,  0b000, 0b00, 0b000110, 0b1);\n+  INSN(fadds,  0b000, 0b00, 0b001010, 0b1);\n+  INSN(fsubs,  0b000, 0b00, 0b001110, 0b1);\n+  INSN(fmaxs,  0b000, 0b00, 0b010010, 0b1);\n+  INSN(fmins,  0b000, 0b00, 0b010110, 0b1);\n+  INSN(fnmuls, 0b000, 0b00, 0b100010, 0b1);\n+\n+  INSN(fmuld,  0b000, 0b01, 0b000010, 0b1);\n+  INSN(fdivd,  0b000, 0b01, 0b000110, 0b1);\n+  INSN(faddd,  0b000, 0b01, 0b001010, 0b1);\n+  INSN(fsubd,  0b000, 0b01, 0b001110, 0b1);\n+  INSN(fmaxd,  0b000, 0b01, 0b010010, 0b1);\n+  INSN(fmind,  0b000, 0b01, 0b010110, 0b1);\n+  INSN(fnmuld, 0b000, 0b01, 0b100010, 0b1);\n+\n+  \/\/ Half-precision floating-point instructions\n+  INSN(fmulh,  0b000, 0b11, 0b000010, 0b1);\n+  INSN(fdivh,  0b000, 0b11, 0b000110, 0b1);\n+  INSN(faddh,  0b000, 0b11, 0b001010, 0b1);\n+  INSN(fsubh,  0b000, 0b11, 0b001110, 0b1);\n+  INSN(fmaxh,  0b000, 0b11, 0b010010, 0b1);\n+  INSN(fminh,  0b000, 0b11, 0b010110, 0b1);\n+  INSN(fnmulh, 0b000, 0b11, 0b100010, 0b1);\n+#undef INSN\n+\n+\/\/ Advanced SIMD scalar three same\n+#define INSN(NAME, U, size, opcode)                                                     \\\n+  void NAME(FloatRegister Vd, FloatRegister Vn, FloatRegister Vm) {                     \\\n+    starti;                                                                             \\\n+    f(0b01, 31, 30), f(U, 29), f(0b11110, 28, 24), f(size, 23, 22), f(1, 21);           \\\n+    rf(Vm, 16), f(opcode, 15, 11), f(1, 10), rf(Vn, 5), rf(Vd, 0);                      \\\n+  }\n+\n+  INSN(fabds, 0b1, 0b10, 0b11010); \/\/ Floating-point Absolute Difference (single-precision)\n+  INSN(fabdd, 0b1, 0b11, 0b11010); \/\/ Floating-point Absolute Difference (double-precision)\n+\n+#undef INSN\n+\n+\/\/ Advanced SIMD scalar three same FP16\n+#define INSN(NAME, U, a, opcode)                                                       \\\n+  void NAME(FloatRegister Vd, FloatRegister Vn, FloatRegister Vm) {                    \\\n+    starti;                                                                            \\\n+    f(0b01, 31, 30), f(U, 29), f(0b11110, 28, 24), f(a, 23), f(0b10, 22, 21);          \\\n+    rf(Vm, 16), f(0b00, 15, 14), f(opcode, 13, 11), f(1, 10), rf(Vn, 5), rf(Vd, 0);    \\\n+  }\n+\n+  INSN(fabdh, 0b1, 0b1, 0b010); \/\/ Floating-point Absolute Difference (half-precision float)\n@@ -2123,0 +2156,1 @@\n+  INSN(fmaddh,  0b000, 0b11, 0, 0);  \/\/ half-precision fused multiply-add (scalar)\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":57,"deletions":23,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    debug_only(__ should_not_reach_here());\n+    DEBUG_ONLY(__ should_not_reach_here());\n@@ -93,1 +93,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -106,1 +106,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -359,1 +359,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -374,1 +374,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2772,0 +2772,104 @@\n+\n+static void abort_verify_int_in_range(uint idx, jint val, jint lo, jint hi) {\n+  fatal(\"Invalid CastII, idx: %u, val: %d, lo: %d, hi: %d\", idx, val, lo, hi);\n+}\n+\n+void C2_MacroAssembler::verify_int_in_range(uint idx, const TypeInt* t, Register rval, Register rtmp) {\n+  assert(!t->empty() && !t->singleton(), \"%s\", Type::str(t));\n+  if (t == TypeInt::INT) {\n+    return;\n+  }\n+  BLOCK_COMMENT(\"verify_int_in_range {\");\n+  Label L_success, L_failure;\n+\n+  jint lo = t->_lo;\n+  jint hi = t->_hi;\n+\n+  if (lo != min_jint && hi != max_jint) {\n+    subsw(rtmp, rval, lo);\n+    br(Assembler::LT, L_failure);\n+    subsw(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else if (lo != min_jint) {\n+    subsw(rtmp, rval, lo);\n+    br(Assembler::GE, L_success);\n+  } else if (hi != max_jint) {\n+    subsw(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+\n+  bind(L_failure);\n+  movw(c_rarg0, idx);\n+  mov(c_rarg1, rval);\n+  movw(c_rarg2, lo);\n+  movw(c_rarg3, hi);\n+  reconstruct_frame_pointer(rtmp);\n+  rt_call(CAST_FROM_FN_PTR(address, abort_verify_int_in_range), rtmp);\n+  hlt(0);\n+\n+  bind(L_success);\n+  BLOCK_COMMENT(\"} verify_int_in_range\");\n+}\n+\n+static void abort_verify_long_in_range(uint idx, jlong val, jlong lo, jlong hi) {\n+  fatal(\"Invalid CastLL, idx: %u, val: \" JLONG_FORMAT \", lo: \" JLONG_FORMAT \", hi: \" JLONG_FORMAT, idx, val, lo, hi);\n+}\n+\n+void C2_MacroAssembler::verify_long_in_range(uint idx, const TypeLong* t, Register rval, Register rtmp) {\n+  assert(!t->empty() && !t->singleton(), \"%s\", Type::str(t));\n+  if (t == TypeLong::LONG) {\n+    return;\n+  }\n+  BLOCK_COMMENT(\"verify_long_in_range {\");\n+  Label L_success, L_failure;\n+\n+  jlong lo = t->_lo;\n+  jlong hi = t->_hi;\n+\n+  if (lo != min_jlong && hi != max_jlong) {\n+    subs(rtmp, rval, lo);\n+    br(Assembler::LT, L_failure);\n+    subs(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else if (lo != min_jlong) {\n+    subs(rtmp, rval, lo);\n+    br(Assembler::GE, L_success);\n+  } else if (hi != max_jlong) {\n+    subs(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+\n+  bind(L_failure);\n+  movw(c_rarg0, idx);\n+  mov(c_rarg1, rval);\n+  mov(c_rarg2, lo);\n+  mov(c_rarg3, hi);\n+  reconstruct_frame_pointer(rtmp);\n+  rt_call(CAST_FROM_FN_PTR(address, abort_verify_long_in_range), rtmp);\n+  hlt(0);\n+\n+  bind(L_success);\n+  BLOCK_COMMENT(\"} verify_long_in_range\");\n+}\n+\n+void C2_MacroAssembler::reconstruct_frame_pointer(Register rtmp) {\n+  const int framesize = Compile::current()->output()->frame_size_in_bytes();\n+  if (PreserveFramePointer) {\n+    \/\/ frame pointer is valid\n+#ifdef ASSERT\n+    \/\/ Verify frame pointer value in rfp.\n+    add(rtmp, sp, framesize - 2 * wordSize);\n+    Label L_success;\n+    cmp(rfp, rtmp);\n+    br(Assembler::EQ, L_success);\n+    stop(\"frame pointer mismatch\");\n+    bind(L_success);\n+#endif \/\/ ASSERT\n+  } else {\n+    add(rfp, sp, framesize - 2 * wordSize);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -193,0 +193,5 @@\n+  void verify_int_in_range(uint idx, const TypeInt* t, Register val, Register tmp);\n+  void verify_long_in_range(uint idx, const TypeLong* t, Register val, Register tmp);\n+\n+  void reconstruct_frame_pointer(Register rtmp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    result = os::attempt_reserve_memory_at((char*)immediate, size, false);\n+    result = os::attempt_reserve_memory_at((char*)immediate, size, mtNone);\n@@ -117,1 +117,1 @@\n-    result = os::reserve_memory_aligned(size, alignment, false);\n+    result = os::reserve_memory_aligned(size, alignment, mtNone);\n","filename":"src\/hotspot\/cpu\/aarch64\/compressedKlass_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-    debug_only(cmp2.verify());\n+    DEBUG_ONLY(cmp2.verify());\n@@ -205,1 +205,1 @@\n-      debug_only(cmp3.verify());\n+      DEBUG_ONLY(cmp3.verify());\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1011,3 +1011,0 @@\n-  \/\/ address const_ptr = long_constant((jlong)Universe::non_oop_word());\n-  \/\/ uintptr_t offset;\n-  \/\/ ldr_constant(rscratch2, const_ptr);\n@@ -5687,1 +5684,1 @@\n-    ldr_constant(dst, Address(dummy, rspec));\n+    ldr(dst, Address(dummy, rspec));\n@@ -5689,1 +5686,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1548,10 +1548,0 @@\n-  void ldr_constant(Register dest, const Address &const_addr) {\n-    if (NearCpool) {\n-      ldr(dest, const_addr);\n-    } else {\n-      uint64_t offset;\n-      adrp(dest, InternalAddress(const_addr.target()), offset);\n-      ldr(dest, Address(dest, offset));\n-    }\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,4 @@\n+  \/\/ Is FEAT_FP16 supported for this CPU?\n+  static bool is_feat_fp16_supported() {\n+    return (VM_Version::supports_fphp() && VM_Version::supports_asimdhp());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n@@ -288,0 +291,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -11191,73 +11191,0 @@\n-  void generate_vector_math_stubs() {\n-    \/\/ Get native vector math stub routine addresses\n-    void* libsleef = nullptr;\n-    char ebuf[1024];\n-    char dll_name[JVM_MAXPATHLEN];\n-    if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"sleef\")) {\n-      libsleef = os::dll_load(dll_name, ebuf, sizeof ebuf);\n-    }\n-    if (libsleef == nullptr) {\n-      log_info(library)(\"Failed to load native vector math library, %s!\", ebuf);\n-      return;\n-    }\n-    \/\/ Method naming convention\n-    \/\/   All the methods are named as <OP><T><N>_<U><suffix>\n-    \/\/   Where:\n-    \/\/     <OP>     is the operation name, e.g. sin\n-    \/\/     <T>      is optional to indicate float\/double\n-    \/\/              \"f\/d\" for vector float\/double operation\n-    \/\/     <N>      is the number of elements in the vector\n-    \/\/              \"2\/4\" for neon, and \"x\" for sve\n-    \/\/     <U>      is the precision level\n-    \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n-    \/\/               We use \"u10\" for all operations by default\n-    \/\/               But for those functions do not have u10 support, we use \"u05\" instead\n-    \/\/     <suffix> indicates neon\/sve\n-    \/\/              \"sve\/advsimd\" for sve\/neon implementations\n-    \/\/     e.g. sinfx_u10sve is the method for computing vector float sin using SVE instructions\n-    \/\/          cosd2_u10advsimd is the method for computing 2 elements vector double cos using NEON instructions\n-    \/\/\n-    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"sleef\" JNI_LIB_SUFFIX, p2i(libsleef));\n-\n-    \/\/ Math vector stubs implemented with SVE for scalable vector size.\n-    if (UseSVE > 0) {\n-      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-        \/\/ Skip \"tanh\" because there is performance regression\n-        if (vop == VectorSupport::VECTOR_OP_TANH) {\n-          continue;\n-        }\n-\n-        \/\/ The native library does not support u10 level of \"hypot\".\n-        const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n-\n-        snprintf(ebuf, sizeof(ebuf), \"%sfx_%ssve\", VectorSupport::mathname[op], ulf);\n-        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-        snprintf(ebuf, sizeof(ebuf), \"%sdx_%ssve\", VectorSupport::mathname[op], ulf);\n-        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-      }\n-    }\n-\n-    \/\/ Math vector stubs implemented with NEON for 64\/128 bits vector size.\n-    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-      \/\/ Skip \"tanh\" because there is performance regression\n-      if (vop == VectorSupport::VECTOR_OP_TANH) {\n-        continue;\n-      }\n-\n-      \/\/ The native library does not support u10 level of \"hypot\".\n-      const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sd2_%sadvsimd\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libsleef, ebuf);\n-    }\n-  }\n-\n@@ -11553,2 +11480,0 @@\n-    generate_vector_math_stubs();\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -645,0 +645,1 @@\n+  size_t features_offset = strnlen(buf, sizeof(buf));\n@@ -652,1 +653,5 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n+\n+  _features_string = extract_features_string(_cpu_info_string,\n+                                             strnlen(_cpu_info_string, sizeof(buf)),\n+                                             features_offset);\n@@ -719,1 +724,1 @@\n-  snprintf(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _features_string);\n+  snprintf(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,0 +128,2 @@\n+    decl(FPHP,          fphp,          9)     \\\n+    decl(ASIMDHP,       asimdhp,       10)    \\\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1241,1 +1241,1 @@\n-    debug_only(int off0 = __ offset());\n+    DEBUG_ONLY(int off0 = __ offset());\n@@ -1245,1 +1245,1 @@\n-    debug_only(int off1 = __ offset());\n+    DEBUG_ONLY(int off1 = __ offset());\n@@ -1254,1 +1254,1 @@\n-    debug_only(int off0 = __ offset());\n+    DEBUG_ONLY(int off0 = __ offset());\n@@ -1258,1 +1258,1 @@\n-    debug_only(int off1 = __ offset());\n+    DEBUG_ONLY(int off1 = __ offset());\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    debug_only(__ should_not_reach_here());\n+    DEBUG_ONLY(__ should_not_reach_here());\n@@ -94,1 +94,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n","filename":"src\/hotspot\/cpu\/arm\/c1_CodeStubs_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  debug_only(barrier->verify());\n+  DEBUG_ONLY(barrier->verify());\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetNMethod_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n@@ -212,0 +215,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n@@ -366,1 +366,1 @@\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    debug_only(__ illtrap());\n+    DEBUG_ONLY(__ illtrap());\n@@ -101,1 +101,1 @@\n-  debug_only(__ illtrap());\n+  DEBUG_ONLY(__ illtrap());\n@@ -118,1 +118,1 @@\n-  debug_only(__ illtrap());\n+  DEBUG_ONLY(__ illtrap());\n@@ -159,1 +159,1 @@\n-  debug_only(__ illtrap());\n+  DEBUG_ONLY(__ illtrap());\n@@ -182,1 +182,1 @@\n-  debug_only(__ illtrap());\n+  DEBUG_ONLY(__ illtrap());\n@@ -196,1 +196,1 @@\n-  debug_only( __ illtrap(); )\n+  DEBUG_ONLY( __ illtrap(); )\n@@ -444,1 +444,1 @@\n-  debug_only(__ illtrap());\n+  DEBUG_ONLY(__ illtrap());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-  debug_only(fpu_range_check(rnr);)\n+  DEBUG_ONLY(fpu_range_check(rnr);)\n","filename":"src\/hotspot\/cpu\/ppc\/c1_FrameMap_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  debug_only(barrier->verify());\n+  DEBUG_ONLY(barrier->verify());\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetNMethod_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3109,0 +3109,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n@@ -522,1 +522,1 @@\n-  tty->print_cr(\"Version: %s L1_data_cache_line_size=%d\", features_string(), L1_data_cache_line_size());\n+  tty->print_cr(\"Version: %s L1_data_cache_line_size=%d\", cpu_info_string(), L1_data_cache_line_size());\n@@ -729,1 +729,1 @@\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", features_string());\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2326,0 +2326,1 @@\n+  INSN(vandn_vx,   0b1010111, 0b100, 0b000001);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    debug_only(__ should_not_reach_here());\n+    DEBUG_ONLY(__ should_not_reach_here());\n@@ -95,1 +95,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -108,1 +108,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -261,1 +261,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -275,1 +275,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1809,1 +1809,1 @@\n-        zext_w(tmp2, tmp2);\n+        zext(tmp2, tmp2, 32);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-  debug_only(jump->verify();)\n+  DEBUG_ONLY(jump->verify();)\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1599,1 +1599,2 @@\n-        __ vmv1r_v(as_VectorRegister(Matcher::_regEncode[dst_lo]), as_VectorRegister(Matcher::_regEncode[src_lo]));\n+        __ vsetvli_helper(T_BYTE, MaxVectorSize);\n+        __ vmv_v_v(as_VectorRegister(Matcher::_regEncode[dst_lo]), as_VectorRegister(Matcher::_regEncode[src_lo]));\n@@ -1617,1 +1618,2 @@\n-        __ vmv1r_v(as_VectorRegister(Matcher::_regEncode[dst_lo]), as_VectorRegister(Matcher::_regEncode[src_lo]));\n+        __ vsetvli_helper(T_BYTE, MaxVectorSize >> 3);\n+        __ vmv_v_v(as_VectorRegister(Matcher::_regEncode[dst_lo]), as_VectorRegister(Matcher::_regEncode[src_lo]));\n@@ -1953,1 +1955,1 @@\n-  return EnableVectorSupport && UseVectorStubs;\n+  return EnableVectorSupport;\n@@ -1957,1 +1959,1 @@\n-  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(EnableVectorSupport, \"sanity\");\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-instruct vadd_immI(vReg dst, vReg src1, immI5 con) %{\n+instruct vadd_vi(vReg dst, vReg src1, immI5 con) %{\n@@ -422,1 +422,1 @@\n-  format %{ \"vadd_immI $dst, $src1, $con\" %}\n+  format %{ \"vadd_vi $dst, $src1, $con\" %}\n@@ -433,1 +433,1 @@\n-instruct vadd_immL(vReg dst, vReg src1, immL5 con) %{\n+instruct vaddL_vi(vReg dst, vReg src1, immL5 con) %{\n@@ -435,1 +435,1 @@\n-  format %{ \"vadd_immL $dst, $src1, $con\" %}\n+  format %{ \"vaddL_vi $dst, $src1, $con\" %}\n@@ -447,1 +447,1 @@\n-instruct vadd_regI(vReg dst, vReg src1, iRegIorL2I src2) %{\n+instruct vadd_vx(vReg dst, vReg src1, iRegIorL2I src2) %{\n@@ -451,1 +451,1 @@\n-  format %{ \"vadd_regI $dst, $src1, $src2\" %}\n+  format %{ \"vadd_vx $dst, $src1, $src2\" %}\n@@ -462,1 +462,1 @@\n-instruct vadd_regL(vReg dst, vReg src1, iRegL src2) %{\n+instruct vaddL_vx(vReg dst, vReg src1, iRegL src2) %{\n@@ -464,1 +464,1 @@\n-  format %{ \"vadd_regL $dst, $src1, $src2\" %}\n+  format %{ \"vaddL_vx $dst, $src1, $src2\" %}\n@@ -476,1 +476,1 @@\n-instruct vadd_immI_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n+instruct vadd_vi_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n@@ -480,1 +480,1 @@\n-  format %{ \"vadd_immI_masked $dst_src, $dst_src, $con\" %}\n+  format %{ \"vadd_vi_masked $dst_src, $dst_src, $con, $v0\" %}\n@@ -491,1 +491,1 @@\n-instruct vadd_immL_masked(vReg dst_src, immL5 con, vRegMask_V0 v0) %{\n+instruct vaddL_vi_masked(vReg dst_src, immL5 con, vRegMask_V0 v0) %{\n@@ -493,1 +493,1 @@\n-  format %{ \"vadd_immL_masked $dst_src, $dst_src, $con\" %}\n+  format %{ \"vaddL_vi_masked $dst_src, $dst_src, $con, $v0\" %}\n@@ -505,1 +505,1 @@\n-instruct vadd_regI_masked(vReg dst_src, iRegIorL2I src2, vRegMask_V0 v0) %{\n+instruct vadd_vx_masked(vReg dst_src, iRegIorL2I src2, vRegMask_V0 v0) %{\n@@ -509,1 +509,1 @@\n-  format %{ \"vadd_regI_masked $dst_src, $dst_src, $src2\" %}\n+  format %{ \"vadd_vx_masked $dst_src, $dst_src, $src2, $v0\" %}\n@@ -520,1 +520,1 @@\n-instruct vadd_regL_masked(vReg dst_src, iRegL src2, vRegMask_V0 v0) %{\n+instruct vaddL_vx_masked(vReg dst_src, iRegL src2, vRegMask_V0 v0) %{\n@@ -522,1 +522,1 @@\n-  format %{ \"vadd_regL_masked $dst_src, $dst_src, $src2\" %}\n+  format %{ \"vaddL_vx_masked $dst_src, $dst_src, $src2, $v0\" %}\n@@ -598,1 +598,1 @@\n-instruct vsub_regI(vReg dst, vReg src1, iRegIorL2I src2) %{\n+instruct vsub_vx(vReg dst, vReg src1, iRegIorL2I src2) %{\n@@ -602,1 +602,1 @@\n-  format %{ \"vsub_regI $dst, $src1, $src2\" %}\n+  format %{ \"vsub_vx $dst, $src1, $src2\" %}\n@@ -613,1 +613,1 @@\n-instruct vsub_regL(vReg dst, vReg src1, iRegL src2) %{\n+instruct vsubL_vx(vReg dst, vReg src1, iRegL src2) %{\n@@ -615,1 +615,1 @@\n-  format %{ \"vsub_regL $dst, $src1, $src2\" %}\n+  format %{ \"vsubL_vx $dst, $src1, $src2\" %}\n@@ -627,1 +627,1 @@\n-instruct vsub_regI_masked(vReg dst_src, iRegIorL2I src2, vRegMask_V0 v0) %{\n+instruct vsub_vx_masked(vReg dst_src, iRegIorL2I src2, vRegMask_V0 v0) %{\n@@ -631,1 +631,1 @@\n-  format %{ \"vsub_regI_masked $dst_src, $dst_src, $src2\" %}\n+  format %{ \"vsub_vx_masked $dst_src, $dst_src, $src2, $v0\" %}\n@@ -642,1 +642,1 @@\n-instruct vsub_regL_masked(vReg dst_src, iRegL src2, vRegMask_V0 v0) %{\n+instruct vsubL_vx_masked(vReg dst_src, iRegL src2, vRegMask_V0 v0) %{\n@@ -644,1 +644,1 @@\n-  format %{ \"vsub_regL_masked $dst_src, $dst_src, $src2\" %}\n+  format %{ \"vsubL_vx_masked $dst_src, $dst_src, $src2, $v0\" %}\n@@ -688,6 +688,6 @@\n-instruct vand_immI(vReg dst_src, immI5 con) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n-  match(Set dst_src (AndV dst_src (Replicate con)));\n-  format %{ \"vand_immI $dst_src, $dst_src, $con\" %}\n+instruct vand_vi(vReg dst, vReg src1, immI5 con) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (AndV src1 (Replicate con)));\n+  format %{ \"vand_vi $dst, $src1, $con\" %}\n@@ -697,2 +697,2 @@\n-    __ vand_vi(as_VectorRegister($dst_src$$reg),\n-               as_VectorRegister($dst_src$$reg),\n+    __ vand_vi(as_VectorRegister($dst$$reg),\n+               as_VectorRegister($src1$$reg),\n@@ -704,1 +704,1 @@\n-instruct vand_immL(vReg dst_src, immL5 con) %{\n+instruct vandL_vi(vReg dst, vReg src1, immL5 con) %{\n@@ -706,2 +706,2 @@\n-  match(Set dst_src (AndV dst_src (Replicate con)));\n-  format %{ \"vand_immL $dst_src, $dst_src, $con\" %}\n+  match(Set dst (AndV src1 (Replicate con)));\n+  format %{ \"vandL_vi $dst, $src1, $con\" %}\n@@ -710,2 +710,2 @@\n-    __ vand_vi(as_VectorRegister($dst_src$$reg),\n-               as_VectorRegister($dst_src$$reg),\n+    __ vand_vi(as_VectorRegister($dst$$reg),\n+               as_VectorRegister($src1$$reg),\n@@ -719,6 +719,6 @@\n-instruct vand_regI(vReg dst_src, iRegIorL2I src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n-  match(Set dst_src (AndV dst_src (Replicate src)));\n-  format %{ \"vand_regI $dst_src, $dst_src, $src\" %}\n+instruct vand_vx(vReg dst, vReg src1, iRegIorL2I src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (AndV src1 (Replicate src2)));\n+  format %{ \"vand_vx $dst, $src1, $src2\" %}\n@@ -728,3 +728,3 @@\n-    __ vand_vx(as_VectorRegister($dst_src$$reg),\n-               as_VectorRegister($dst_src$$reg),\n-               as_Register($src$$reg));\n+    __ vand_vx(as_VectorRegister($dst$$reg),\n+               as_VectorRegister($src1$$reg),\n+               as_Register($src2$$reg));\n@@ -735,1 +735,1 @@\n-instruct vand_regL(vReg dst_src, iRegL src) %{\n+instruct vandL_vx(vReg dst, vReg src1, iRegL src2) %{\n@@ -737,2 +737,2 @@\n-  match(Set dst_src (AndV dst_src (Replicate src)));\n-  format %{ \"vand_regL $dst_src, $dst_src, $src\" %}\n+  match(Set dst (AndV src1 (Replicate src2)));\n+  format %{ \"vandL_vx $dst, $src1, $src2\" %}\n@@ -741,3 +741,3 @@\n-    __ vand_vx(as_VectorRegister($dst_src$$reg),\n-               as_VectorRegister($dst_src$$reg),\n-               as_Register($src$$reg));\n+    __ vand_vx(as_VectorRegister($dst$$reg),\n+               as_VectorRegister($src1$$reg),\n+               as_Register($src2$$reg));\n@@ -750,4 +750,4 @@\n-instruct vand_immI_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+instruct vand_vi_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -755,1 +755,1 @@\n-  format %{ \"vand_immI_masked $dst_src, $dst_src, $con\" %}\n+  format %{ \"vand_vi_masked $dst_src, $dst_src, $con, $v0\" %}\n@@ -766,1 +766,1 @@\n-instruct vand_immL_masked(vReg dst_src, immL5 con, vRegMask_V0 v0) %{\n+instruct vandL_vi_masked(vReg dst_src, immL5 con, vRegMask_V0 v0) %{\n@@ -769,1 +769,1 @@\n-  format %{ \"vand_immL_masked $dst_src, $dst_src, $con\" %}\n+  format %{ \"vandL_vi_masked $dst_src, $dst_src, $con, $v0\" %}\n@@ -781,4 +781,4 @@\n-instruct vand_regI_masked(vReg dst_src, iRegIorL2I src, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+instruct vand_vx_masked(vReg dst_src, iRegIorL2I src, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -786,1 +786,1 @@\n-  format %{ \"vand_regI_masked $dst_src, $dst_src, $src\" %}\n+  format %{ \"vand_vx_masked $dst_src, $dst_src, $src, $v0\" %}\n@@ -797,1 +797,1 @@\n-instruct vand_regL_masked(vReg dst_src, iRegL src, vRegMask_V0 v0) %{\n+instruct vandL_vx_masked(vReg dst_src, iRegL src, vRegMask_V0 v0) %{\n@@ -800,1 +800,1 @@\n-  format %{ \"vand_regL_masked $dst_src, $dst_src, $src\" %}\n+  format %{ \"vandL_vx_masked $dst_src, $dst_src, $src, $v0\" %}\n@@ -844,6 +844,6 @@\n-instruct vor_immI(vReg dst_src, immI5 con) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n-  match(Set dst_src (OrV dst_src (Replicate con)));\n-  format %{ \"vor_immI $dst_src, $dst_src, $con\" %}\n+instruct vor_vi(vReg dst, vReg src1, immI5 con) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (OrV src1 (Replicate con)));\n+  format %{ \"vor_vi $dst, $src1, $con\" %}\n@@ -853,2 +853,2 @@\n-    __ vor_vi(as_VectorRegister($dst_src$$reg),\n-              as_VectorRegister($dst_src$$reg),\n+    __ vor_vi(as_VectorRegister($dst$$reg),\n+              as_VectorRegister($src1$$reg),\n@@ -860,1 +860,1 @@\n-instruct vor_immL(vReg dst_src, immL5 con) %{\n+instruct vorL_vi(vReg dst, vReg src1, immL5 con) %{\n@@ -862,2 +862,2 @@\n-  match(Set dst_src (OrV dst_src (Replicate con)));\n-  format %{ \"vor_immL $dst_src, $dst_src, $con\" %}\n+  match(Set dst (OrV src1 (Replicate con)));\n+  format %{ \"vorL_vi $dst, $src1, $con\" %}\n@@ -866,2 +866,2 @@\n-    __ vor_vi(as_VectorRegister($dst_src$$reg),\n-              as_VectorRegister($dst_src$$reg),\n+    __ vor_vi(as_VectorRegister($dst$$reg),\n+              as_VectorRegister($src1$$reg),\n@@ -875,6 +875,6 @@\n-instruct vor_regI(vReg dst_src, iRegIorL2I src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n-  match(Set dst_src (OrV dst_src (Replicate src)));\n-  format %{ \"vor_regI $dst_src, $dst_src, $src\" %}\n+instruct vor_vx(vReg dst, vReg src1, iRegIorL2I src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (OrV src1 (Replicate src2)));\n+  format %{ \"vor_vx $dst, $src1, $src2\" %}\n@@ -884,3 +884,3 @@\n-    __ vor_vx(as_VectorRegister($dst_src$$reg),\n-              as_VectorRegister($dst_src$$reg),\n-              as_Register($src$$reg));\n+    __ vor_vx(as_VectorRegister($dst$$reg),\n+              as_VectorRegister($src1$$reg),\n+              as_Register($src2$$reg));\n@@ -891,1 +891,1 @@\n-instruct vor_regL(vReg dst_src, iRegL src) %{\n+instruct vorL_vx(vReg dst, vReg src1, iRegL src2) %{\n@@ -893,2 +893,2 @@\n-  match(Set dst_src (OrV dst_src (Replicate src)));\n-  format %{ \"vor_regL $dst_src, $dst_src, $src\" %}\n+  match(Set dst (OrV src1 (Replicate src2)));\n+  format %{ \"vorL_vx $dst, $src1, $src2\" %}\n@@ -897,3 +897,3 @@\n-    __ vor_vx(as_VectorRegister($dst_src$$reg),\n-              as_VectorRegister($dst_src$$reg),\n-              as_Register($src$$reg));\n+    __ vor_vx(as_VectorRegister($dst$$reg),\n+              as_VectorRegister($src1$$reg),\n+              as_Register($src2$$reg));\n@@ -906,4 +906,4 @@\n-instruct vor_immI_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+instruct vor_vi_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -911,1 +911,1 @@\n-  format %{ \"vor_immI_masked $dst_src, $dst_src, $con\" %}\n+  format %{ \"vor_vi_masked $dst_src, $dst_src, $con, $v0\" %}\n@@ -922,1 +922,1 @@\n-instruct vor_immL_masked(vReg dst_src, immL5 con, vRegMask_V0 v0) %{\n+instruct vorL_vi_masked(vReg dst_src, immL5 con, vRegMask_V0 v0) %{\n@@ -925,1 +925,1 @@\n-  format %{ \"vor_immL_masked $dst_src, $dst_src, $con\" %}\n+  format %{ \"vorL_vi_masked $dst_src, $dst_src, $con, $v0\" %}\n@@ -937,4 +937,4 @@\n-instruct vor_regI_masked(vReg dst_src, iRegIorL2I src, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+instruct vor_vx_masked(vReg dst_src, iRegIorL2I src, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -942,1 +942,1 @@\n-  format %{ \"vor_regI_masked $dst_src, $dst_src, $src\" %}\n+  format %{ \"vor_vx_masked $dst_src, $dst_src, $src, $v0\" %}\n@@ -953,1 +953,1 @@\n-instruct vor_regL_masked(vReg dst_src, iRegL src, vRegMask_V0 v0) %{\n+instruct vorL_vx_masked(vReg dst_src, iRegL src, vRegMask_V0 v0) %{\n@@ -956,1 +956,1 @@\n-  format %{ \"vor_regL_masked $dst_src, $dst_src, $src\" %}\n+  format %{ \"vorL_vx_masked $dst_src, $dst_src, $src, $v0\" %}\n@@ -1000,6 +1000,6 @@\n-instruct vxor_immI(vReg dst_src, immI5 con) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n-  match(Set dst_src (XorV dst_src (Replicate con)));\n-  format %{ \"vxor_immI $dst_src, $dst_src, $con\" %}\n+instruct vxor_vi(vReg dst, vReg src1, immI5 con) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (XorV src1 (Replicate con)));\n+  format %{ \"vxor_vi $dst, $src1, $con\" %}\n@@ -1009,2 +1009,2 @@\n-    __ vxor_vi(as_VectorRegister($dst_src$$reg),\n-               as_VectorRegister($dst_src$$reg),\n+    __ vxor_vi(as_VectorRegister($dst$$reg),\n+               as_VectorRegister($src1$$reg),\n@@ -1016,1 +1016,1 @@\n-instruct vxor_immL(vReg dst_src, immL5 con) %{\n+instruct vxorL_vi(vReg dst, vReg src1, immL5 con) %{\n@@ -1018,2 +1018,2 @@\n-  match(Set dst_src (XorV dst_src (Replicate con)));\n-  format %{ \"vxor_immL $dst_src, $dst_src, $con\" %}\n+  match(Set dst (XorV src1 (Replicate con)));\n+  format %{ \"vxorL_vi $dst, $src1, $con\" %}\n@@ -1022,2 +1022,2 @@\n-    __ vxor_vi(as_VectorRegister($dst_src$$reg),\n-               as_VectorRegister($dst_src$$reg),\n+    __ vxor_vi(as_VectorRegister($dst$$reg),\n+               as_VectorRegister($src1$$reg),\n@@ -1031,6 +1031,6 @@\n-instruct vxor_regI(vReg dst_src, iRegIorL2I src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n-  match(Set dst_src (XorV dst_src (Replicate src)));\n-  format %{ \"vxor_regI $dst_src, $dst_src, $src\" %}\n+instruct vxor_vx(vReg dst, vReg src1, iRegIorL2I src2) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (XorV src1 (Replicate src2)));\n+  format %{ \"vxor_vx $dst, $src1, $src2\" %}\n@@ -1040,3 +1040,3 @@\n-    __ vxor_vx(as_VectorRegister($dst_src$$reg),\n-               as_VectorRegister($dst_src$$reg),\n-               as_Register($src$$reg));\n+    __ vxor_vx(as_VectorRegister($dst$$reg),\n+               as_VectorRegister($src1$$reg),\n+               as_Register($src2$$reg));\n@@ -1047,1 +1047,1 @@\n-instruct vxor_regL(vReg dst_src, iRegL src) %{\n+instruct vxorL_vx(vReg dst, vReg src1, iRegL src2) %{\n@@ -1049,2 +1049,2 @@\n-  match(Set dst_src (XorV dst_src (Replicate src)));\n-  format %{ \"vxor_regL $dst_src, $dst_src, $src\" %}\n+  match(Set dst (XorV src1 (Replicate src2)));\n+  format %{ \"vxorL_vx $dst, $src1, $src2\" %}\n@@ -1053,3 +1053,3 @@\n-    __ vxor_vx(as_VectorRegister($dst_src$$reg),\n-               as_VectorRegister($dst_src$$reg),\n-               as_Register($src$$reg));\n+    __ vxor_vx(as_VectorRegister($dst$$reg),\n+               as_VectorRegister($src1$$reg),\n+               as_Register($src2$$reg));\n@@ -1062,4 +1062,4 @@\n-instruct vxor_immI_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+instruct vxor_vi_masked(vReg dst_src, immI5 con, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -1067,1 +1067,1 @@\n-  format %{ \"vxor_immI_masked $dst_src, $dst_src, $con\" %}\n+  format %{ \"vxor_vi_masked $dst_src, $dst_src, $con, $v0\" %}\n@@ -1078,1 +1078,1 @@\n-instruct vxor_immL_masked(vReg dst_src, immL5 con, vRegMask_V0 v0) %{\n+instruct vxorL_vi_masked(vReg dst_src, immL5 con, vRegMask_V0 v0) %{\n@@ -1081,1 +1081,1 @@\n-  format %{ \"vxor_immL_masked $dst_src, $dst_src, $con\" %}\n+  format %{ \"vxorL_vi_masked $dst_src, $dst_src, $con, $v0\" %}\n@@ -1093,4 +1093,4 @@\n-instruct vxor_regI_masked(vReg dst_src, iRegIorL2I src, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+instruct vxor_vx_masked(vReg dst_src, iRegIorL2I src, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -1098,1 +1098,1 @@\n-  format %{ \"vxor_regI_masked $dst_src, $dst_src, $src\" %}\n+  format %{ \"vxor_vx_masked $dst_src, $dst_src, $src, $v0\" %}\n@@ -1109,1 +1109,1 @@\n-instruct vxor_regL_masked(vReg dst_src, iRegL src, vRegMask_V0 v0) %{\n+instruct vxorL_vx_masked(vReg dst_src, iRegL src, vRegMask_V0 v0) %{\n@@ -1112,1 +1112,1 @@\n-  format %{ \"vxor_regL_masked $dst_src, $dst_src, $src\" %}\n+  format %{ \"vxorL_vx_masked $dst_src, $dst_src, $src, $v0\" %}\n@@ -1126,0 +1126,26 @@\n+instruct vand_notB(vReg dst, vReg src1, vReg src2, immI_M1 m1) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (AndV src1 (XorV src2 (Replicate m1))));\n+  format %{ \"vand_notB $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n+    __ vandn_vv(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src1$$reg),\n+                as_VectorRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notS(vReg dst, vReg src1, vReg src2, immI_M1 m1) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (AndV src1 (XorV src2 (Replicate m1))));\n+  format %{ \"vand_notS $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n+    __ vandn_vv(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src1$$reg),\n+                as_VectorRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1127,4 +1153,1 @@\n-  predicate(UseZvbb);\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_INT);\n@@ -1134,2 +1157,1 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n@@ -1144,2 +1166,1 @@\n-  predicate(UseZvbb);\n-  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -1157,0 +1178,28 @@\n+instruct vand_notB_masked(vReg dst_src1, vReg src2, immI_M1 m1, vRegMask_V0 v0) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (Replicate m1))) v0));\n+  format %{ \"vand_notB_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n+    __ vandn_vv(as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($src2$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notS_masked(vReg dst_src1, vReg src2, immI_M1 m1, vRegMask_V0 v0) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (XorV src2 (Replicate m1))) v0));\n+  format %{ \"vand_notS_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n+    __ vandn_vv(as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($src2$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1158,4 +1207,1 @@\n-  predicate(UseZvbb);\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_INT);\n@@ -1165,2 +1211,1 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n@@ -1176,2 +1221,1 @@\n-  predicate(UseZvbb);\n-  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -1190,0 +1234,108 @@\n+instruct vand_notB_vx(vReg dst, vReg src1, iRegIorL2I src2, immI_M1 m1) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (AndV src1 (Replicate (XorI src2 m1))));\n+  format %{ \"vand_notB_vx $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src1$$reg),\n+                as_Register($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notS_vx(vReg dst, vReg src1, iRegIorL2I src2, immI_M1 m1) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (AndV src1 (Replicate (XorI src2 m1))));\n+  format %{ \"vand_notS_vx $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src1$$reg),\n+                as_Register($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notI_vx(vReg dst, vReg src1, iRegIorL2I src2, immI_M1 m1) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (AndV src1 (Replicate (XorI src2 m1))));\n+  format %{ \"vand_notI_vx $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src1$$reg),\n+                as_Register($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL_vx(vReg dst, vReg src1, iRegL src2, immL_M1 m1) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (AndV src1 (Replicate (XorL src2 m1))));\n+  format %{ \"vand_notL_vx $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src1$$reg),\n+                as_Register($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notB_vx_masked(vReg dst_src1, iRegIorL2I src2, immI_M1 m1, vRegMask_V0 v0) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (Replicate (XorI src2 m1))) v0));\n+  format %{ \"vand_notB_vx_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_BYTE, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($dst_src1$$reg),\n+                as_Register($src2$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notS_vx_masked(vReg dst_src1, iRegIorL2I src2, immI_M1 m1, vRegMask_V0 v0) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (Replicate (XorI src2 m1))) v0));\n+  format %{ \"vand_notS_vx_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_SHORT, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($dst_src1$$reg),\n+                as_Register($src2$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notI_vx_masked(vReg dst_src1, iRegIorL2I src2, immI_M1 m1, vRegMask_V0 v0) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (Replicate (XorI src2 m1))) v0));\n+  format %{ \"vand_notI_vx_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_INT, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($dst_src1$$reg),\n+                as_Register($src2$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL_vx_masked(vReg dst_src1, iRegL src2, immL_M1 m1, vRegMask_V0 v0) %{\n+  predicate(UseZvbb && Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (Replicate (XorL src2 m1))) v0));\n+  format %{ \"vand_notL_vx_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($dst_src1$$reg),\n+                as_Register($src2$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1194,4 +1346,4 @@\n-instruct vnotI(vReg dst, vReg src, immI_M1 m1) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+instruct vnot(vReg dst, vReg src, immI_M1 m1) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -1199,1 +1351,1 @@\n-  format %{ \"vnotI $dst, $src\" %}\n+  format %{ \"vnot $dst, $src\" %}\n@@ -1225,4 +1377,4 @@\n-instruct vnotI_masked(vReg dst_src, immI_M1 m1, vRegMask_V0 v0) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+instruct vnot_masked(vReg dst_src, immI_M1 m1, vRegMask_V0 v0) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -1230,1 +1382,1 @@\n-  format %{ \"vnotI_masked $dst_src, $dst_src, $v0\" %}\n+  format %{ \"vnot_masked $dst_src, $dst_src, $v0\" %}\n@@ -1352,0 +1504,60 @@\n+\/\/ vector unsigned integer max\/min\n+\n+instruct vmaxu(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (UMaxV src1 src2));\n+  ins_cost(VEC_COST);\n+  format %{ \"vmaxu $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(bt), \"unsupported type\");\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmaxu_vv(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminu(vReg dst, vReg src1, vReg src2) %{\n+  match(Set dst (UMinV src1 src2));\n+  ins_cost(VEC_COST);\n+  format %{ \"vminu $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(bt), \"unsupported type\");\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vminu_vv(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src1$$reg), as_VectorRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector unsigned integer max\/min - predicated\n+\n+instruct vmaxu_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (UMaxV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vmaxu_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(bt), \"unsupported type\");\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vmaxu_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vminu_masked(vReg dst_src1, vReg src2, vRegMask_V0 v0) %{\n+  match(Set dst_src1 (UMinV (Binary dst_src1 src2) v0));\n+  ins_cost(VEC_COST);\n+  format %{ \"vminu_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(is_integral_type(bt), \"unsupported type\");\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vminu_vv(as_VectorRegister($dst_src1$$reg), as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($src2$$reg), Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1740,1 +1952,1 @@\n-instruct vmul_regI(vReg dst, vReg src1, iRegIorL2I src2) %{\n+instruct vmul_vx(vReg dst, vReg src1, iRegIorL2I src2) %{\n@@ -1744,1 +1956,1 @@\n-  format %{ \"vmul_regI $dst, $src1, $src2\" %}\n+  format %{ \"vmul_vx $dst, $src1, $src2\" %}\n@@ -1755,1 +1967,1 @@\n-instruct vmul_regL(vReg dst, vReg src1, iRegL src2) %{\n+instruct vmulL_vx(vReg dst, vReg src1, iRegL src2) %{\n@@ -1757,1 +1969,1 @@\n-  format %{ \"vmul_regL $dst, $src1, $src2\" %}\n+  format %{ \"vmulL_vx $dst, $src1, $src2\" %}\n@@ -1769,1 +1981,1 @@\n-instruct vmul_regI_masked(vReg dst_src, iRegIorL2I src2, vRegMask_V0 v0) %{\n+instruct vmul_vx_masked(vReg dst_src, iRegIorL2I src2, vRegMask_V0 v0) %{\n@@ -1773,1 +1985,1 @@\n-  format %{ \"vmul_regI_masked $dst_src, $dst_src, $src2\" %}\n+  format %{ \"vmul_vx_masked $dst_src, $dst_src, $src2, $v0\" %}\n@@ -1784,1 +1996,1 @@\n-instruct vmul_regL_masked(vReg dst_src, iRegL src2, vRegMask_V0 v0) %{\n+instruct vmulL_vx_masked(vReg dst_src, iRegL src2, vRegMask_V0 v0) %{\n@@ -1786,1 +1998,1 @@\n-  format %{ \"vmul_regL_masked $dst_src, $dst_src, $src2\" %}\n+  format %{ \"vmulL_vx_masked $dst_src, $dst_src, $src2, $v0\" %}\n@@ -1860,1 +2072,1 @@\n-instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+instruct reduce_and(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n@@ -1867,1 +2079,1 @@\n-  format %{ \"reduce_andI $dst, $src1, $src2\\t# KILL $tmp\" %}\n+  format %{ \"reduce_and $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1894,1 +2106,1 @@\n-instruct reduce_andI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+instruct reduce_and_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n@@ -1901,1 +2113,1 @@\n-  format %{ \"reduce_andI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  format %{ \"reduce_and_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -1930,1 +2142,1 @@\n-instruct reduce_orI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+instruct reduce_or(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n@@ -1937,1 +2149,1 @@\n-  format %{ \"reduce_orI $dst, $src1, $src2\\t# KILL $tmp\" %}\n+  format %{ \"reduce_or $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -1964,1 +2176,1 @@\n-instruct reduce_orI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+instruct reduce_or_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n@@ -1971,1 +2183,1 @@\n-  format %{ \"reduce_orI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  format %{ \"reduce_or_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -2000,1 +2212,1 @@\n-instruct reduce_xorI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+instruct reduce_xor(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n@@ -2007,1 +2219,1 @@\n-  format %{ \"reduce_xorI $dst, $src1, $src2\\t# KILL $tmp\" %}\n+  format %{ \"reduce_xor $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -2034,1 +2246,1 @@\n-instruct reduce_xorI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+instruct reduce_xor_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n@@ -2041,1 +2253,1 @@\n-  format %{ \"reduce_xorI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  format %{ \"reduce_xor_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -2070,1 +2282,1 @@\n-instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+instruct reduce_add(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n@@ -2077,1 +2289,1 @@\n-  format %{ \"reduce_addI $dst, $src1, $src2\\t# KILL $tmp\" %}\n+  format %{ \"reduce_add $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -2176,1 +2388,1 @@\n-instruct reduce_addI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+instruct reduce_add_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n@@ -2183,1 +2395,1 @@\n-  format %{ \"reduce_addI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  format %{ \"reduce_add_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -2242,1 +2454,1 @@\n-instruct vreduce_maxI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+instruct vreduce_max(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n@@ -2249,1 +2461,1 @@\n-  format %{ \"vreduce_maxI $dst, $src1, $src2\\t# KILL $tmp\" %}\n+  format %{ \"vreduce_max $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -2276,1 +2488,1 @@\n-instruct vreduce_maxI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+instruct vreduce_max_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n@@ -2283,1 +2495,1 @@\n-  format %{ \"vreduce_maxI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  format %{ \"vreduce_max_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -2312,1 +2524,1 @@\n-instruct vreduce_minI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n+instruct vreduce_min(iRegINoSp dst, iRegIorL2I src1, vReg src2, vReg tmp) %{\n@@ -2319,1 +2531,1 @@\n-  format %{ \"vreduce_minI $dst, $src1, $src2\\t# KILL $tmp\" %}\n+  format %{ \"vreduce_min $dst, $src1, $src2\\t# KILL $tmp\" %}\n@@ -2346,1 +2558,1 @@\n-instruct vreduce_minI_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n+instruct vreduce_min_masked(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegMask_V0 v0, vReg tmp) %{\n@@ -2353,1 +2565,1 @@\n-  format %{ \"vreduce_minI_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n+  format %{ \"vreduce_min_masked $dst, $src1, $src2, $v0\\t# KILL $tmp\" %}\n@@ -3061,1 +3273,1 @@\n-instruct vasrB_imm(vReg dst, vReg src, immI shift) %{\n+instruct vasrB_vi(vReg dst, vReg src, immI shift) %{\n@@ -3064,1 +3276,1 @@\n-  format %{ \"vasrB_imm $dst, $src, $shift\" %}\n+  format %{ \"vasrB_vi $dst, $src, $shift\" %}\n@@ -3079,1 +3291,1 @@\n-instruct vasrS_imm(vReg dst, vReg src, immI shift) %{\n+instruct vasrS_vi(vReg dst, vReg src, immI shift) %{\n@@ -3082,1 +3294,1 @@\n-  format %{ \"vasrS_imm $dst, $src, $shift\" %}\n+  format %{ \"vasrS_vi $dst, $src, $shift\" %}\n@@ -3097,1 +3309,1 @@\n-instruct vasrI_imm(vReg dst, vReg src, immI shift) %{\n+instruct vasrI_vi(vReg dst, vReg src, immI shift) %{\n@@ -3100,1 +3312,1 @@\n-  format %{ \"vasrI_imm $dst, $src, $shift\" %}\n+  format %{ \"vasrI_vi $dst, $src, $shift\" %}\n@@ -3114,1 +3326,1 @@\n-instruct vasrL_imm(vReg dst, vReg src, immI shift) %{\n+instruct vasrL_vi(vReg dst, vReg src, immI shift) %{\n@@ -3118,1 +3330,1 @@\n-  format %{ \"vasrL_imm $dst, $src, $shift\" %}\n+  format %{ \"vasrL_vi $dst, $src, $shift\" %}\n@@ -3132,1 +3344,1 @@\n-instruct vasrB_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vasrB_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3135,1 +3347,1 @@\n-  format %{ \"vasrB_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vasrB_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3149,1 +3361,1 @@\n-instruct vasrS_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vasrS_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3152,1 +3364,1 @@\n-  format %{ \"vasrS_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vasrS_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3166,1 +3378,1 @@\n-instruct vasrI_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vasrI_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3169,1 +3381,1 @@\n-  format %{ \"vasrI_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vasrI_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3182,1 +3394,1 @@\n-instruct vasrL_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vasrL_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3186,1 +3398,1 @@\n-  format %{ \"vasrL_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vasrL_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3199,1 +3411,1 @@\n-instruct vlsrB_imm(vReg dst, vReg src, immI shift) %{\n+instruct vlsrB_vi(vReg dst, vReg src, immI shift) %{\n@@ -3202,1 +3414,1 @@\n-  format %{ \"vlsrB_imm $dst, $src, $shift\" %}\n+  format %{ \"vlsrB_vi $dst, $src, $shift\" %}\n@@ -3221,1 +3433,1 @@\n-instruct vlsrS_imm(vReg dst, vReg src, immI shift) %{\n+instruct vlsrS_vi(vReg dst, vReg src, immI shift) %{\n@@ -3224,1 +3436,1 @@\n-  format %{ \"vlsrS_imm $dst, $src, $shift\" %}\n+  format %{ \"vlsrS_vi $dst, $src, $shift\" %}\n@@ -3243,1 +3455,1 @@\n-instruct vlsrI_imm(vReg dst, vReg src, immI shift) %{\n+instruct vlsrI_vi(vReg dst, vReg src, immI shift) %{\n@@ -3246,1 +3458,1 @@\n-  format %{ \"vlsrI_imm $dst, $src, $shift\" %}\n+  format %{ \"vlsrI_vi $dst, $src, $shift\" %}\n@@ -3260,1 +3472,1 @@\n-instruct vlsrL_imm(vReg dst, vReg src, immI shift) %{\n+instruct vlsrL_vi(vReg dst, vReg src, immI shift) %{\n@@ -3264,1 +3476,1 @@\n-  format %{ \"vlsrL_imm $dst, $src, $shift\" %}\n+  format %{ \"vlsrL_vi $dst, $src, $shift\" %}\n@@ -3278,1 +3490,1 @@\n-instruct vlsrB_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vlsrB_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3281,1 +3493,1 @@\n-  format %{ \"vlsrB_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vlsrB_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3299,1 +3511,1 @@\n-instruct vlsrS_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vlsrS_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3302,1 +3514,1 @@\n-  format %{ \"vlsrS_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vlsrS_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3320,1 +3532,1 @@\n-instruct vlsrI_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vlsrI_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3323,1 +3535,1 @@\n-  format %{ \"vlsrI_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vlsrI_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3336,1 +3548,1 @@\n-instruct vlsrL_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vlsrL_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3340,1 +3552,1 @@\n-  format %{ \"vlsrL_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vlsrL_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3353,1 +3565,1 @@\n-instruct vlslB_imm(vReg dst, vReg src, immI shift) %{\n+instruct vlslB_vi(vReg dst, vReg src, immI shift) %{\n@@ -3356,1 +3568,1 @@\n-  format %{ \"vlslB_imm $dst, $src, $shift\" %}\n+  format %{ \"vlslB_vi $dst, $src, $shift\" %}\n@@ -3370,1 +3582,1 @@\n-instruct vlslS_imm(vReg dst, vReg src, immI shift) %{\n+instruct vlslS_vi(vReg dst, vReg src, immI shift) %{\n@@ -3373,1 +3585,1 @@\n-  format %{ \"vlslS_imm $dst, $src, $shift\" %}\n+  format %{ \"vlslS_vi $dst, $src, $shift\" %}\n@@ -3387,1 +3599,1 @@\n-instruct vlslI_imm(vReg dst, vReg src, immI shift) %{\n+instruct vlslI_vi(vReg dst, vReg src, immI shift) %{\n@@ -3390,1 +3602,1 @@\n-  format %{ \"vlslI_imm $dst, $src, $shift\" %}\n+  format %{ \"vlslI_vi $dst, $src, $shift\" %}\n@@ -3399,1 +3611,1 @@\n-instruct vlslL_imm(vReg dst, vReg src, immI shift) %{\n+instruct vlslL_vi(vReg dst, vReg src, immI shift) %{\n@@ -3403,1 +3615,1 @@\n-  format %{ \"vlslL_imm $dst, $src, $shift\" %}\n+  format %{ \"vlslL_vi $dst, $src, $shift\" %}\n@@ -3412,1 +3624,1 @@\n-instruct vlslB_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vlslB_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3415,1 +3627,1 @@\n-  format %{ \"vlslB_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vlslB_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3430,1 +3642,1 @@\n-instruct vlslS_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vlslS_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3433,1 +3645,1 @@\n-  format %{ \"vlslS_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vlslS_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3448,1 +3660,1 @@\n-instruct vlslI_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vlslI_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3451,1 +3663,1 @@\n-  format %{ \"vlslI_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vlslI_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3461,1 +3673,1 @@\n-instruct vlslL_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vlslL_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3465,1 +3677,1 @@\n-  format %{ \"vlslL_imm_masked $dst_src, $dst_src, $shift, $v0\" %}\n+  format %{ \"vlslL_vi_masked $dst_src, $dst_src, $shift, $v0\" %}\n@@ -3505,1 +3717,1 @@\n-instruct vrotate_right_reg(vReg dst, vReg src, iRegIorL2I shift) %{\n+instruct vrotate_right_vx(vReg dst, vReg src, iRegIorL2I shift) %{\n@@ -3507,1 +3719,1 @@\n-  format %{ \"vrotate_right_reg $dst, $src, $shift\\t\" %}\n+  format %{ \"vrotate_right_vx $dst, $src, $shift\\t\" %}\n@@ -3517,1 +3729,1 @@\n-instruct vrotate_right_imm(vReg dst, vReg src, immI shift) %{\n+instruct vrotate_right_vi(vReg dst, vReg src, immI shift) %{\n@@ -3519,1 +3731,1 @@\n-  format %{ \"vrotate_right_imm $dst, $src, $shift\\t\" %}\n+  format %{ \"vrotate_right_vi $dst, $src, $shift\\t\" %}\n@@ -3537,1 +3749,1 @@\n-  format %{ \"vrotate_right_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  format %{ \"vrotate_right_masked $dst_src, $dst_src, $shift, $v0\\t\" %}\n@@ -3548,1 +3760,1 @@\n-instruct vrotate_right_reg_masked(vReg dst_src, iRegIorL2I shift, vRegMask_V0 v0) %{\n+instruct vrotate_right_vx_masked(vReg dst_src, iRegIorL2I shift, vRegMask_V0 v0) %{\n@@ -3550,1 +3762,1 @@\n-  format %{ \"vrotate_right_reg_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  format %{ \"vrotate_right_vx_masked $dst_src, $dst_src, $shift, $v0\\t\" %}\n@@ -3560,1 +3772,1 @@\n-instruct vrotate_right_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vrotate_right_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3562,1 +3774,1 @@\n-  format %{ \"vrotate_right_imm_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  format %{ \"vrotate_right_vi_masked $dst_src, $dst_src, $shift, $v0\\t\" %}\n@@ -3592,1 +3804,1 @@\n-instruct vrotate_left_reg(vReg dst, vReg src, iRegIorL2I shift) %{\n+instruct vrotate_left_vx(vReg dst, vReg src, iRegIorL2I shift) %{\n@@ -3594,1 +3806,1 @@\n-  format %{ \"vrotate_left_reg $dst, $src, $shift\\t\" %}\n+  format %{ \"vrotate_left_vx $dst, $src, $shift\\t\" %}\n@@ -3604,1 +3816,1 @@\n-instruct vrotate_left_imm(vReg dst, vReg src, immI shift) %{\n+instruct vrotate_left_vi(vReg dst, vReg src, immI shift) %{\n@@ -3606,1 +3818,1 @@\n-  format %{ \"vrotate_left_imm $dst, $src, $shift\\t\" %}\n+  format %{ \"vrotate_left_vi $dst, $src, $shift\\t\" %}\n@@ -3625,1 +3837,1 @@\n-  format %{ \"vrotate_left_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  format %{ \"vrotate_left_masked $dst_src, $dst_src, $shift, $v0\\t\" %}\n@@ -3636,1 +3848,1 @@\n-instruct vrotate_left_reg_masked(vReg dst_src, iRegIorL2I shift, vRegMask_V0 v0) %{\n+instruct vrotate_left_vx_masked(vReg dst_src, iRegIorL2I shift, vRegMask_V0 v0) %{\n@@ -3638,1 +3850,1 @@\n-  format %{ \"vrotate_left_reg_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  format %{ \"vrotate_left_vx_masked $dst_src, $dst_src, $shift, $v0\\t\" %}\n@@ -3648,1 +3860,1 @@\n-instruct vrotate_left_imm_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n+instruct vrotate_left_vi_masked(vReg dst_src, immI shift, vRegMask_V0 v0) %{\n@@ -3650,1 +3862,1 @@\n-  format %{ \"vrotate_left_imm_masked $dst_src, $dst_src, $shift, v0.t\\t\" %}\n+  format %{ \"vrotate_left_vi_masked $dst_src, $dst_src, $shift, $v0\\t\" %}\n@@ -4246,2 +4458,2 @@\n-  predicate((Matcher::vector_element_basic_type(n) == T_INT ||\n-             Matcher::vector_element_basic_type(n) == T_LONG));\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -4260,2 +4472,2 @@\n-  predicate((Matcher::vector_element_basic_type(n) == T_FLOAT ||\n-             Matcher::vector_element_basic_type(n) == T_DOUBLE));\n+  predicate(Matcher::vector_element_basic_type(n) == T_FLOAT ||\n+            Matcher::vector_element_basic_type(n) == T_DOUBLE);\n@@ -4358,3 +4570,3 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT ||\n+            Matcher::vector_element_basic_type(n) == T_INT);\n@@ -5096,1 +5308,1 @@\n-instruct insertI_index_lt32(vReg dst, vReg src, iRegIorL2I val, immI idx, vRegMask_V0 v0) %{\n+instruct insert_index_lt32(vReg dst, vReg src, iRegIorL2I val, immI idx, vRegMask_V0 v0) %{\n@@ -5103,1 +5315,1 @@\n-  format %{ \"insertI_index_lt32 $dst, $src, $val, $idx\" %}\n+  format %{ \"insert_index_lt32 $dst, $src, $val, $idx\" %}\n@@ -5115,1 +5327,1 @@\n-instruct insertI_index(vReg dst, vReg src, iRegIorL2I val, iRegIorL2I idx, vReg tmp, vRegMask_V0 v0) %{\n+instruct insert_index(vReg dst, vReg src, iRegIorL2I val, iRegIorL2I idx, vReg tmp, vRegMask_V0 v0) %{\n@@ -5122,1 +5334,1 @@\n-  format %{ \"insertI_index $dst, $src, $val, $idx\\t# KILL $tmp\" %}\n+  format %{ \"insert_index $dst, $src, $val, $idx\\t# KILL $tmp\" %}\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":497,"deletions":285,"binary":false,"changes":782,"status":"modified"},{"patch":"@@ -66,0 +66,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n@@ -285,0 +288,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -6461,52 +6461,0 @@\n-  void generate_vector_math_stubs() {\n-    if (!UseRVV) {\n-      log_info(library)(\"vector is not supported, skip loading vector math (sleef) library!\");\n-      return;\n-    }\n-\n-    \/\/ Get native vector math stub routine addresses\n-    void* libsleef = nullptr;\n-    char ebuf[1024];\n-    char dll_name[JVM_MAXPATHLEN];\n-    if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"sleef\")) {\n-      libsleef = os::dll_load(dll_name, ebuf, sizeof ebuf);\n-    }\n-    if (libsleef == nullptr) {\n-      log_info(library)(\"Failed to load native vector math (sleef) library, %s!\", ebuf);\n-      return;\n-    }\n-\n-    \/\/ Method naming convention\n-    \/\/   All the methods are named as <OP><T>_<U><suffix>\n-    \/\/\n-    \/\/   Where:\n-    \/\/     <OP>     is the operation name, e.g. sin, cos\n-    \/\/     <T>      is to indicate float\/double\n-    \/\/              \"fx\/dx\" for vector float\/double operation\n-    \/\/     <U>      is the precision level\n-    \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n-    \/\/               We use \"u10\" for all operations by default\n-    \/\/               But for those functions do not have u10 support, we use \"u05\" instead\n-    \/\/     <suffix> rvv, indicates riscv vector extension\n-    \/\/\n-    \/\/   e.g. sinfx_u10rvv is the method for computing vector float sin using rvv instructions\n-    \/\/\n-    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"sleef\" JNI_LIB_SUFFIX, p2i(libsleef));\n-\n-    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-      if (vop == VectorSupport::VECTOR_OP_TANH) { \/\/ skip tanh because of performance regression\n-        continue;\n-      }\n-\n-      \/\/ The native library does not support u10 level of \"hypot\".\n-      const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sfx_%srvv\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sdx_%srvv\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-    }\n-  }\n-\n@@ -6744,2 +6692,0 @@\n-    generate_vector_math_stubs();\n-\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -471,1 +471,1 @@\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", features_string());\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    debug_only(__ should_not_reach_here());\n+    DEBUG_ONLY(__ should_not_reach_here());\n@@ -77,1 +77,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -91,1 +91,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -119,1 +119,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -137,1 +137,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -150,1 +150,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  debug_only(fpu_range_check(rnr);)\n+  DEBUG_ONLY(fpu_range_check(rnr);)\n@@ -152,2 +152,2 @@\n-  debug_only(fpu_range_check(rnr);)\n-  debug_only(fpu_range_check(reg->encoding());)\n+  DEBUG_ONLY(fpu_range_check(rnr);)\n+  DEBUG_ONLY(fpu_range_check(reg->encoding());)\n","filename":"src\/hotspot\/cpu\/s390\/c1_FrameMap_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-    debug_only(fpu_range_check(c1rnr);)\n+    DEBUG_ONLY(fpu_range_check(c1rnr);)\n","filename":"src\/hotspot\/cpu\/s390\/c1_FrameMap_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-      debug_only(Assembler::is_z_cfi(*((long*)inst_addr)));\n+      DEBUG_ONLY(Assembler::is_z_cfi(*((long*)inst_addr)));\n@@ -94,1 +94,1 @@\n-  debug_only(barrier->verify());\n+  DEBUG_ONLY(barrier->verify());\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetNMethod_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -461,1 +461,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -468,1 +468,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -475,1 +475,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -481,1 +481,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -487,1 +487,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -492,1 +492,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -504,1 +504,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -512,1 +512,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -518,1 +518,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -75,0 +75,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2771,0 +2771,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  set_features_string();     \/\/ Set a descriptive feature indication.\n+  set_cpu_info_string();     \/\/ Set a descriptive feature indication.\n@@ -391,3 +391,3 @@\n-void VM_Version::set_features_string() {\n-  \/\/ A note on the _features_string format:\n-  \/\/   There are jtreg tests checking the _features_string for various properties.\n+void VM_Version::set_cpu_info_string() {\n+  \/\/ A note on the _cpu_info_string format:\n+  \/\/   There are jtreg tests checking the _cpu_info_string for various properties.\n@@ -415,1 +415,1 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n@@ -418,1 +418,1 @@\n-    assert(strlen(_features_string) + 3*8 < sizeof(buf), \"increase buffer size\");\n+    assert(strlen(_cpu_info_string) + 3*8 < sizeof(buf), \"increase buffer size\");\n@@ -420,1 +420,1 @@\n-                 _features_string,\n+                 _cpu_info_string,\n@@ -424,2 +424,2 @@\n-    os::free((void *)_features_string);\n-    _features_string = os::strdup(buf);\n+    os::free((void *)_cpu_info_string);\n+    _cpu_info_string = os::strdup(buf);\n@@ -429,1 +429,1 @@\n-    assert(strlen(_features_string) + 6 + 2*8 + 7 < sizeof(buf), \"increase buffer size\");\n+    assert(strlen(_cpu_info_string) + 6 + 2*8 + 7 < sizeof(buf), \"increase buffer size\");\n@@ -431,1 +431,1 @@\n-                 _features_string,\n+                 _cpu_info_string,\n@@ -436,2 +436,2 @@\n-    os::free((void *)_features_string);\n-    _features_string = os::strdup(buf);\n+    os::free((void *)_cpu_info_string);\n+    _cpu_info_string = os::strdup(buf);\n@@ -467,1 +467,1 @@\n-  tty->print_cr(\"%s %s\", text, features_string());\n+  tty->print_cr(\"%s %s\", text, cpu_info_string());\n@@ -909,1 +909,1 @@\n-      set_features_string();\n+      set_cpu_info_string();\n@@ -1545,1 +1545,1 @@\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", features_string());\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  static void set_features_string();\n+  static void set_cpu_info_string();\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -804,1 +804,1 @@\n-  debug_only(bool has_disp32 = false);\n+  DEBUG_ONLY(bool has_disp32 = false);\n@@ -862,1 +862,1 @@\n-    debug_only(has_disp32 = true);\n+    DEBUG_ONLY(has_disp32 = true);\n@@ -901,1 +901,1 @@\n-      debug_only(has_disp32 = true);\n+      DEBUG_ONLY(has_disp32 = true);\n@@ -904,1 +904,1 @@\n-      debug_only(has_disp32 = true);\n+      DEBUG_ONLY(has_disp32 = true);\n@@ -926,1 +926,1 @@\n-    debug_only(has_disp32 = true); \/\/ has both kinds of operands!\n+    DEBUG_ONLY(has_disp32 = true); \/\/ has both kinds of operands!\n@@ -935,1 +935,1 @@\n-      debug_only(has_disp32 = true); \/\/ has both kinds of operands!\n+      DEBUG_ONLY(has_disp32 = true); \/\/ has both kinds of operands!\n@@ -939,1 +939,1 @@\n-      debug_only(has_disp32 = true); \/\/ has both kinds of operands!\n+      DEBUG_ONLY(has_disp32 = true); \/\/ has both kinds of operands!\n@@ -964,1 +964,1 @@\n-      debug_only(has_disp32 = true);\n+      DEBUG_ONLY(has_disp32 = true);\n@@ -979,1 +979,1 @@\n-      debug_only(has_disp32 = true);\n+      DEBUG_ONLY(has_disp32 = true);\n@@ -984,1 +984,1 @@\n-      debug_only(has_disp32 = true);\n+      DEBUG_ONLY(has_disp32 = true);\n@@ -990,1 +990,1 @@\n-      debug_only(has_disp32 = true);\n+      DEBUG_ONLY(has_disp32 = true);\n@@ -1007,1 +1007,1 @@\n-    debug_only(has_disp32 = true); \/\/ has both kinds of operands!\n+    DEBUG_ONLY(has_disp32 = true); \/\/ has both kinds of operands!\n@@ -1012,1 +1012,1 @@\n-    debug_only(has_disp32 = true); \/\/ has both kinds of operands!\n+    DEBUG_ONLY(has_disp32 = true); \/\/ has both kinds of operands!\n@@ -1029,1 +1029,1 @@\n-      debug_only(has_disp32 = true);\n+      DEBUG_ONLY(has_disp32 = true);\n@@ -1048,1 +1048,1 @@\n-    debug_only(has_disp32 = true); \/\/ has both kinds of operands!\n+    DEBUG_ONLY(has_disp32 = true); \/\/ has both kinds of operands!\n@@ -1060,1 +1060,1 @@\n-    debug_only(has_disp32 = true); \/\/ has both kinds of operands!\n+    DEBUG_ONLY(has_disp32 = true); \/\/ has both kinds of operands!\n@@ -1112,1 +1112,1 @@\n-    debug_only(has_disp32 = true); \/\/ has both kinds of operands!\n+    DEBUG_ONLY(has_disp32 = true); \/\/ has both kinds of operands!\n@@ -1138,1 +1138,1 @@\n-    debug_only(has_disp32 = true); \/\/ has both kinds of operands!\n+    DEBUG_ONLY(has_disp32 = true); \/\/ has both kinds of operands!\n@@ -1150,1 +1150,1 @@\n-    debug_only(has_disp32 = true);\n+    DEBUG_ONLY(has_disp32 = true);\n@@ -1187,1 +1187,1 @@\n-    debug_only(has_disp32 = true); \/\/ has both kinds of operands!\n+    DEBUG_ONLY(has_disp32 = true); \/\/ has both kinds of operands!\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    debug_only(__ should_not_reach_here());\n+    DEBUG_ONLY(__ should_not_reach_here());\n@@ -92,1 +92,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -105,1 +105,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -115,1 +115,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -491,1 +491,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -505,1 +505,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -819,0 +819,113 @@\n+static void abort_verify_int_in_range(uint idx, jint val, jint lo, jint hi) {\n+  fatal(\"Invalid CastII, idx: %u, val: %d, lo: %d, hi: %d\", idx, val, lo, hi);\n+}\n+\n+static void reconstruct_frame_pointer_helper(MacroAssembler* masm, Register dst) {\n+  const int framesize = Compile::current()->output()->frame_size_in_bytes();\n+  masm->movptr(dst, rsp);\n+  if (framesize > 2 * wordSize) {\n+    masm->addptr(dst, framesize - 2 * wordSize);\n+  }\n+}\n+\n+void C2_MacroAssembler::reconstruct_frame_pointer(Register rtmp) {\n+  if (PreserveFramePointer) {\n+    \/\/ frame pointer is valid\n+#ifdef ASSERT\n+    \/\/ Verify frame pointer value in rbp.\n+    reconstruct_frame_pointer_helper(this, rtmp);\n+    Label L_success;\n+    cmpq(rbp, rtmp);\n+    jccb(Assembler::equal, L_success);\n+    STOP(\"frame pointer mismatch\");\n+    bind(L_success);\n+#endif \/\/ ASSERT\n+  } else {\n+    reconstruct_frame_pointer_helper(this, rbp);\n+  }\n+}\n+\n+void C2_MacroAssembler::verify_int_in_range(uint idx, const TypeInt* t, Register val) {\n+  jint lo = t->_lo;\n+  jint hi = t->_hi;\n+  assert(lo < hi, \"type should not be empty or constant, idx: %u, lo: %d, hi: %d\", idx, lo, hi);\n+  if (t == TypeInt::INT) {\n+    return;\n+  }\n+\n+  BLOCK_COMMENT(\"CastII {\");\n+  Label fail;\n+  Label succeed;\n+  if (hi == max_jint) {\n+    cmpl(val, lo);\n+    jccb(Assembler::greaterEqual, succeed);\n+  } else {\n+    if (lo != min_jint) {\n+      cmpl(val, lo);\n+      jccb(Assembler::less, fail);\n+    }\n+    cmpl(val, hi);\n+    jccb(Assembler::lessEqual, succeed);\n+  }\n+\n+  bind(fail);\n+  movl(c_rarg0, idx);\n+  movl(c_rarg1, val);\n+  movl(c_rarg2, lo);\n+  movl(c_rarg3, hi);\n+  reconstruct_frame_pointer(rscratch1);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, abort_verify_int_in_range)));\n+  hlt();\n+  bind(succeed);\n+  BLOCK_COMMENT(\"} \/\/ CastII\");\n+}\n+\n+static void abort_verify_long_in_range(uint idx, jlong val, jlong lo, jlong hi) {\n+  fatal(\"Invalid CastLL, idx: %u, val: \" JLONG_FORMAT \", lo: \" JLONG_FORMAT \", hi: \" JLONG_FORMAT, idx, val, lo, hi);\n+}\n+\n+void C2_MacroAssembler::verify_long_in_range(uint idx, const TypeLong* t, Register val, Register tmp) {\n+  jlong lo = t->_lo;\n+  jlong hi = t->_hi;\n+  assert(lo < hi, \"type should not be empty or constant, idx: %u, lo: \" JLONG_FORMAT \", hi: \" JLONG_FORMAT, idx, lo, hi);\n+  if (t == TypeLong::LONG) {\n+    return;\n+  }\n+\n+  BLOCK_COMMENT(\"CastLL {\");\n+  Label fail;\n+  Label succeed;\n+\n+  auto cmp_val = [&](jlong bound) {\n+    if (is_simm32(bound)) {\n+      cmpq(val, checked_cast<int>(bound));\n+    } else {\n+      mov64(tmp, bound);\n+      cmpq(val, tmp);\n+    }\n+  };\n+\n+  if (hi == max_jlong) {\n+    cmp_val(lo);\n+    jccb(Assembler::greaterEqual, succeed);\n+  } else {\n+    if (lo != min_jlong) {\n+      cmp_val(lo);\n+      jccb(Assembler::less, fail);\n+    }\n+    cmp_val(hi);\n+    jccb(Assembler::lessEqual, succeed);\n+  }\n+\n+  bind(fail);\n+  movl(c_rarg0, idx);\n+  movq(c_rarg1, val);\n+  mov64(c_rarg2, lo);\n+  mov64(c_rarg3, hi);\n+  reconstruct_frame_pointer(rscratch1);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, abort_verify_long_in_range)));\n+  hlt();\n+  bind(succeed);\n+  BLOCK_COMMENT(\"} \/\/ CastLL\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+  void verify_int_in_range(uint idx, const TypeInt* t, Register val);\n+  void verify_long_in_range(uint idx, const TypeLong* t, Register val, Register tmp);\n+\n@@ -578,0 +581,3 @@\n+\n+  void reconstruct_frame_pointer(Register rtmp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    debug_only(cmp2->verify());\n+    DEBUG_ONLY(cmp2->verify());\n@@ -181,1 +181,1 @@\n-      debug_only(cmp3->verify());\n+      DEBUG_ONLY(cmp3->verify());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#ifdef _LP64\n@@ -39,1 +38,0 @@\n-#endif\n@@ -47,1 +45,0 @@\n-#ifdef _LP64\n@@ -53,3 +50,0 @@\n-#else\n-#define DEFAULT_PADDING_SIZE DEFAULT_CACHE_LINE_SIZE\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-#ifdef _LP64\n@@ -66,2 +65,1 @@\n-\/\/ stack if compiled for unix and LP64. To pass stack overflow tests we need\n-\/\/ 20 shadow pages.\n+\/\/ stack if compiled for unix. To pass stack overflow tests we need 20 shadow pages.\n@@ -72,4 +70,0 @@\n-#else\n-#define DEFAULT_STACK_SHADOW_PAGES (4 DEBUG_ONLY(+5))\n-#define MIN_STACK_SHADOW_PAGES DEFAULT_STACK_SHADOW_PAGES\n-#endif \/\/ _LP64\n@@ -82,1 +76,0 @@\n-#ifdef _LP64\n@@ -84,3 +77,0 @@\n-#else\n-define_pd_global(bool, VMContinuations, false);\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-#ifdef AMD64\n@@ -72,1 +71,0 @@\n-#endif \/\/ AMD64\n@@ -143,1 +141,1 @@\n-  debug_only(verify());\n+  DEBUG_ONLY(verify());\n@@ -160,1 +158,0 @@\n-#ifdef AMD64\n@@ -172,6 +169,0 @@\n-#else\n-  \/\/ make sure code pattern is actually a mov reg, imm32 instruction\n-  u_char test_byte = *(u_char*)instruction_address();\n-  u_char test_byte_2 = test_byte & ( 0xff ^ register_mask);\n-  if (test_byte_2 != instruction_code) fatal(\"not a mov reg, imm32\");\n-#endif \/\/ AMD64\n@@ -195,1 +186,0 @@\n-    NOT_LP64(assert((0xC0 & ubyte_at(1)) == 0xC0, \"shouldn't have LDS and LES instructions\"));\n@@ -200,1 +190,0 @@\n-    NOT_LP64(assert((0xC0 & ubyte_at(1)) == 0xC0, \"shouldn't have LDS and LES instructions\"));\n@@ -316,2 +305,1 @@\n-  if ( ! ((test_byte == lea_instruction_code)\n-          LP64_ONLY(|| (test_byte == mov64_instruction_code) ))) {\n+  if ((test_byte != lea_instruction_code) && (test_byte != mov64_instruction_code)) {\n@@ -343,1 +331,0 @@\n-#ifdef AMD64\n@@ -345,1 +332,0 @@\n-#endif \/\/ AMD64\n@@ -358,1 +344,0 @@\n-#ifdef AMD64\n@@ -360,3 +345,0 @@\n-#else\n-  const int linesize = 32;\n-#endif \/\/ AMD64\n@@ -389,1 +371,0 @@\n-#ifdef _LP64\n@@ -405,37 +386,0 @@\n-\n-#else\n-  unsigned char code_buffer[5];\n-  code_buffer[0] = instruction_code;\n-  intptr_t disp = (intptr_t)dest - ((intptr_t)verified_entry + 1 + 4);\n-  *(int32_t*)(code_buffer + 1) = (int32_t)disp;\n-\n-  check_verified_entry_alignment(entry, verified_entry);\n-\n-  \/\/ Can't call nativeJump_at() because it's asserts jump exists\n-  NativeJump* n_jump = (NativeJump*) verified_entry;\n-\n-  \/\/First patch dummy jmp in place\n-\n-  unsigned char patch[4];\n-  assert(sizeof(patch)==sizeof(int32_t), \"sanity check\");\n-  patch[0] = 0xEB;       \/\/ jmp rel8\n-  patch[1] = 0xFE;       \/\/ jmp to self\n-  patch[2] = 0xEB;\n-  patch[3] = 0xFE;\n-\n-  \/\/ First patch dummy jmp in place\n-  *(int32_t*)verified_entry = *(int32_t *)patch;\n-\n-  n_jump->wrote(0);\n-\n-  \/\/ Patch 5th byte (from jump instruction)\n-  verified_entry[4] = code_buffer[4];\n-\n-  n_jump->wrote(4);\n-\n-  \/\/ Patch bytes 0-3 (from jump instruction)\n-  *(int32_t*)verified_entry = *(int32_t *)code_buffer;\n-  \/\/ Invalidate.  Opteron requires a flush after every write.\n-  n_jump->wrote(0);\n-#endif \/\/ _LP64\n-\n@@ -458,1 +402,0 @@\n-#ifdef AMD64\n@@ -460,1 +403,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":2,"deletions":60,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -129,1 +129,0 @@\n-#ifdef AMD64\n@@ -132,1 +131,0 @@\n-#endif \/\/ AMD64\n@@ -214,1 +212,0 @@\n-#ifdef AMD64\n@@ -218,5 +215,0 @@\n-#else\n-  static const bool has_rex = false;\n-  static const int rex_size = 0;\n-  static const int rex2_size = 0;\n-#endif \/\/ AMD64\n@@ -393,1 +385,0 @@\n-#ifdef AMD64\n@@ -396,4 +387,0 @@\n-#else\n-  static const bool has_rex = false;\n-  static const int rex_size = 0;\n-#endif \/\/ AMD64\n@@ -450,1 +437,0 @@\n-#ifdef AMD64\n@@ -452,1 +438,0 @@\n-#endif \/\/ AMD64\n@@ -506,1 +491,1 @@\n-  debug_only(jump->verify();)\n+  DEBUG_ONLY(jump->verify();)\n@@ -575,1 +560,0 @@\n-#ifdef AMD64\n@@ -578,3 +562,0 @@\n-#else\n-  const int test_offset = 0;\n-#endif\n@@ -587,1 +568,0 @@\n-#ifdef AMD64\n@@ -596,3 +576,0 @@\n-#else\n-  return false;\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -64,0 +64,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n@@ -270,0 +273,3 @@\n+  if (buffer.blob() == nullptr) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4506,64 +4506,0 @@\n-  \/\/ Get svml stub routine addresses\n-  void *libjsvml = nullptr;\n-  char ebuf[1024];\n-  char dll_name[JVM_MAXPATHLEN];\n-  if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"jsvml\")) {\n-    libjsvml = os::dll_load(dll_name, ebuf, sizeof ebuf);\n-  }\n-  if (libjsvml != nullptr) {\n-    \/\/ SVML method naming convention\n-    \/\/   All the methods are named as __jsvml_op<T><N>_ha_<VV>\n-    \/\/   Where:\n-    \/\/      ha stands for high accuracy\n-    \/\/      <T> is optional to indicate float\/double\n-    \/\/              Set to f for vector float operation\n-    \/\/              Omitted for vector double operation\n-    \/\/      <N> is the number of elements in the vector\n-    \/\/              1, 2, 4, 8, 16\n-    \/\/              e.g. 128 bit float vector has 4 float elements\n-    \/\/      <VV> indicates the avx\/sse level:\n-    \/\/              z0 is AVX512, l9 is AVX2, e9 is AVX1 and ex is for SSE2\n-    \/\/      e.g. __jsvml_expf16_ha_z0 is the method for computing 16 element vector float exp using AVX 512 insns\n-    \/\/           __jsvml_exp8_ha_z0 is the method for computing 8 element vector double exp using AVX 512 insns\n-\n-    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"jsvml\" JNI_LIB_SUFFIX, p2i(libjsvml));\n-    if (UseAVX > 2) {\n-      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-        if ((!VM_Version::supports_avx512dq()) &&\n-            (vop == VectorSupport::VECTOR_OP_LOG || vop == VectorSupport::VECTOR_OP_LOG10 || vop == VectorSupport::VECTOR_OP_POW)) {\n-          continue;\n-        }\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::mathname[op]);\n-        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_512][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::mathname[op]);\n-        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_512][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-      }\n-    }\n-    const char* avx_sse_str = (UseAVX >= 2) ? \"l9\" : ((UseAVX == 1) ? \"e9\" : \"ex\");\n-    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-      if (vop == VectorSupport::VECTOR_OP_POW) {\n-        continue;\n-      }\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_256][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_256][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":64,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -75,2 +75,0 @@\n-#ifdef _LP64\n-\n@@ -90,1 +88,0 @@\n-#endif\n@@ -110,1 +107,0 @@\n-#if defined(_LP64)\n@@ -129,1 +125,0 @@\n-#endif\n@@ -154,1 +149,1 @@\n-    \/\/ LP64: rcx and rdx are first and second argument registers on windows\n+    \/\/ rcx and rdx are first and second argument registers on windows\n@@ -157,1 +152,0 @@\n-#ifdef _LP64\n@@ -159,3 +153,0 @@\n-#else\n-    __ movptr(rbp, Address(rsp, 8)); \/\/ cpuid_info address\n-#endif\n@@ -421,1 +412,0 @@\n-#if defined(_LP64)\n@@ -456,1 +446,0 @@\n-#endif\n@@ -530,1 +519,0 @@\n-#ifdef _LP64\n@@ -533,1 +521,0 @@\n-#endif\n@@ -559,1 +546,0 @@\n-#ifdef _LP64\n@@ -562,1 +548,0 @@\n-#endif\n@@ -603,1 +588,0 @@\n-#ifdef _LP64\n@@ -606,1 +590,0 @@\n-#endif\n@@ -631,1 +614,0 @@\n-#ifdef _LP64\n@@ -634,1 +616,0 @@\n-#endif\n@@ -690,1 +671,0 @@\n-#ifdef _LP64\n@@ -693,4 +673,0 @@\n-#else\n-    __ movptr(rax, Address(rsp, 16)); \/\/ CPUID leaf\n-    __ movptr(rsi, Address(rsp, 20)); \/\/ register array address\n-#endif\n@@ -737,1 +713,1 @@\n-    \/\/ LP64: rcx and rdx are first and second argument registers on windows\n+    \/\/ rcx and rdx are first and second argument registers on windows\n@@ -740,1 +716,0 @@\n-#ifdef _LP64\n@@ -742,3 +717,0 @@\n-#else\n-    __ movptr(rbp, Address(rsp, 8)); \/\/ cpuid_info address\n-#endif\n@@ -892,2 +864,2 @@\n-  LP64_ONLY(_supports_atomic_getset8 = true);\n-  LP64_ONLY(_supports_atomic_getadd8 = true);\n+  _supports_atomic_getset8 = true;\n+  _supports_atomic_getadd8 = true;\n@@ -895,1 +867,0 @@\n-#ifdef _LP64\n@@ -902,1 +873,0 @@\n-#endif\n@@ -904,1 +874,0 @@\n-#ifdef AMD64\n@@ -916,1 +885,0 @@\n-#endif\n@@ -918,1 +886,0 @@\n-#ifdef _LP64\n@@ -927,1 +894,0 @@\n-#endif\n@@ -1117,1 +1083,1 @@\n-  int res = jio_snprintf(\n+  int cpu_info_size = jio_snprintf(\n@@ -1122,2 +1088,2 @@\n-  assert(res > 0, \"not enough temporary space allocated\");\n-  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n+  assert(cpu_info_size > 0, \"not enough temporary space allocated\");\n+  insert_features_names(buf + cpu_info_size, sizeof(buf) - cpu_info_size, _features_names);\n@@ -1125,1 +1091,5 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n+\n+  _features_string = extract_features_string(_cpu_info_string,\n+                                             strnlen(_cpu_info_string, sizeof(buf)),\n+                                             cpu_info_size);\n@@ -1209,1 +1179,0 @@\n-#ifdef _LP64\n@@ -1220,6 +1189,0 @@\n-#else\n-  if (UseAdler32Intrinsics) {\n-    warning(\"Adler32Intrinsics not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);\n-  }\n-#endif\n@@ -1249,1 +1212,0 @@\n-#ifdef _LP64\n@@ -1265,7 +1227,0 @@\n-#else\n-  \/\/ No support currently for ChaCha20 intrinsics on 32-bit platforms\n-  if (UseChaCha20Intrinsics) {\n-      warning(\"ChaCha20 intrinsics are not available on this CPU.\");\n-      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n-  }\n-#endif \/\/ _LP64\n@@ -1275,1 +1230,0 @@\n-#ifdef _LP64\n@@ -1280,3 +1234,1 @@\n-  } else\n-#endif\n-   if (UseDilithiumIntrinsics) {\n+  } else if (UseDilithiumIntrinsics) {\n@@ -1311,1 +1263,1 @@\n-  if (supports_sha() LP64_ONLY(|| (supports_avx2() && supports_bmi2()))) {\n+  if (supports_sha() || (supports_avx2() && supports_bmi2())) {\n@@ -1338,2 +1290,0 @@\n-#ifdef _LP64\n-  \/\/ These are only supported on 64-bit\n@@ -1344,3 +1294,1 @@\n-  } else\n-#endif\n-  if (UseSHA512Intrinsics) {\n+  } else if (UseSHA512Intrinsics) {\n@@ -1351,1 +1299,0 @@\n-#ifdef _LP64\n@@ -1356,3 +1303,1 @@\n-  } else\n-#endif\n-   if (UseSHA3Intrinsics) {\n+  } else if (UseSHA3Intrinsics) {\n@@ -1380,1 +1325,0 @@\n-#ifdef _LP64\n@@ -1382,3 +1326,0 @@\n-#else\n-  int min_vector_size = 0;\n-#endif\n@@ -1408,1 +1349,1 @@\n-      int nreg = 2 LP64_ONLY(+2);\n+      int nreg = 4;\n@@ -1421,1 +1362,0 @@\n-#ifdef _LP64\n@@ -1426,3 +1366,1 @@\n-  } else\n-#endif\n-  if (UsePoly1305Intrinsics) {\n+  } else if (UsePoly1305Intrinsics) {\n@@ -1433,1 +1371,0 @@\n-#ifdef _LP64\n@@ -1438,3 +1375,1 @@\n-  } else\n-#endif\n-  if (UseIntPolyIntrinsics) {\n+  } else if (UseIntPolyIntrinsics) {\n@@ -1445,1 +1380,0 @@\n-#ifdef _LP64\n@@ -1461,32 +1395,0 @@\n-#else\n-  if (UseMultiplyToLenIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {\n-      warning(\"multiplyToLen intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, false);\n-  }\n-  if (UseMontgomeryMultiplyIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {\n-      warning(\"montgomeryMultiply intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, false);\n-  }\n-  if (UseMontgomerySquareIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {\n-      warning(\"montgomerySquare intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, false);\n-  }\n-  if (UseSquareToLenIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {\n-      warning(\"squareToLen intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, false);\n-  }\n-  if (UseMulAddIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {\n-      warning(\"mulAdd intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMulAddIntrinsic, false);\n-  }\n-#endif \/\/ _LP64\n@@ -1769,1 +1671,0 @@\n-#ifdef _LP64\n@@ -1786,14 +1687,0 @@\n-#else\n-  if (UseVectorizedMismatchIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic)) {\n-      warning(\"vectorizedMismatch intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);\n-  }\n-  if (UseVectorizedHashCodeIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseVectorizedHashCodeIntrinsic)) {\n-      warning(\"vectorizedHashCode intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, false);\n-  }\n-#endif \/\/ _LP64\n@@ -1948,1 +1835,0 @@\n-#ifdef _LP64\n@@ -1967,1 +1853,0 @@\n-#endif\n@@ -2198,1 +2083,0 @@\n-#if defined(_LP64)\n@@ -2202,1 +2086,0 @@\n-#endif\n@@ -2220,2 +2103,0 @@\n-\n-#if defined(_LP64)\n@@ -2224,1 +2105,0 @@\n-#endif\n@@ -2227,1 +2107,1 @@\n-  LP64_ONLY(Assembler::precompute_instructions();)\n+  Assembler::precompute_instructions();\n@@ -2994,1 +2874,0 @@\n-#ifdef _LP64\n@@ -2999,1 +2878,0 @@\n-#endif\n@@ -3171,1 +3049,1 @@\n-  int nreg = 2 LP64_ONLY(+2);\n+  int nreg = 4;\n@@ -3327,1 +3205,0 @@\n-#ifdef _LP64\n@@ -3329,3 +3206,0 @@\n-#else\n-        return 320;\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":21,"deletions":147,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-  LP64_ONLY(static void clear_apx_test_state());\n+  static void clear_apx_test_state();\n@@ -842,1 +842,1 @@\n-    return LP64_ONLY(true) NOT_LP64(false); \/\/ not implemented on x86_32\n+    return true;\n@@ -847,1 +847,1 @@\n-    return LP64_ONLY(true) NOT_LP64(false); \/\/ not implemented on x86_32\n+    return true;\n@@ -882,1 +882,0 @@\n-#ifdef _LP64\n@@ -884,3 +883,0 @@\n-#else\n-  static bool supports_clflush() { return  ((_features & CPU_FLUSH) != 0); }\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -425,0 +425,12 @@\n+bool castLL_is_imm32(const Node* n);\n+\n+%}\n+\n+source %{\n+\n+bool castLL_is_imm32(const Node* n) {\n+  assert(n->is_CastLL(), \"must be a CastLL\");\n+  const TypeLong* t = n->bottom_type()->is_long();\n+  return (t->_lo == min_jlong || Assembler::is_simm32(t->_lo)) && (t->_hi == max_jlong || Assembler::is_simm32(t->_hi));\n+}\n+\n@@ -1596,4 +1608,1 @@\n-  if (EnableVectorSupport && UseVectorStubs) {\n-    return true;\n-  }\n-  return false;\n+  return EnableVectorSupport;\n@@ -1603,1 +1612,1 @@\n-  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(EnableVectorSupport, \"sanity\");\n@@ -1850,1 +1859,1 @@\n-    debug_only(int off0 = __ offset());\n+    DEBUG_ONLY(int off0 = __ offset());\n@@ -1857,1 +1866,1 @@\n-    debug_only(int off1 = __ offset());\n+    DEBUG_ONLY(int off1 = __ offset());\n@@ -7659,0 +7668,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -7668,0 +7678,13 @@\n+instruct castII_checked(rRegI dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastII dst));\n+\n+  effect(KILL cr);\n+  format %{ \"# cast_checked_II $dst\" %}\n+  ins_encode %{\n+    __ verify_int_in_range(_idx, bottom_type()->is_int(), $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -7670,0 +7693,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -7679,0 +7703,26 @@\n+instruct castLL_checked_L32(rRegL dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0 && castLL_is_imm32(n));\n+  match(Set dst (CastLL dst));\n+\n+  effect(KILL cr);\n+  format %{ \"# cast_checked_LL $dst\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, noreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct castLL_checked(rRegL dst, rRegL tmp, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0 && !castLL_is_imm32(n));\n+  match(Set dst (CastLL dst));\n+\n+  effect(KILL cr, TEMP tmp);\n+  format %{ \"# cast_checked_LL $dst\\tusing $tmp as TEMP\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":57,"deletions":7,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -62,1 +63,1 @@\n-void odmWrapper::clean_data() { if (_data) { free(_data); _data = nullptr; } }\n+void odmWrapper::clean_data() { if (_data) { permit_forbidden_function::free(_data); _data = nullptr; } }\n","filename":"src\/hotspot\/os\/aix\/libodm_aix.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -61,1 +62,1 @@\n-    char** l2 = (char**) ::realloc(_list, sizeof(char*) * cap2);\n+    char** l2 = (char**) permit_forbidden_function::realloc(_list, sizeof(char*) * cap2);\n@@ -79,1 +80,1 @@\n-    char* s2 = ::strdup(s);\n+    char* s2 = permit_forbidden_function::strdup(s);\n@@ -173,1 +174,1 @@\n-    ::free(lm);\n+    permit_forbidden_function::free(lm);\n@@ -196,1 +197,1 @@\n-    buffer = (uint8_t*) ::realloc(buffer, buflen);\n+    buffer = (uint8_t*) permit_forbidden_function::realloc(buffer, buflen);\n@@ -232,1 +233,1 @@\n-    loaded_module_t* lm = (loaded_module_t*) ::malloc(sizeof(loaded_module_t));\n+    loaded_module_t* lm = (loaded_module_t*) permit_forbidden_function::malloc(sizeof(loaded_module_t));\n@@ -253,1 +254,1 @@\n-      free(lm);\n+      permit_forbidden_function::free(lm);\n@@ -275,1 +276,1 @@\n-        free(lm);\n+        permit_forbidden_function::free(lm);\n@@ -323,1 +324,1 @@\n-  ::free(buffer);\n+  permit_forbidden_function::free(buffer);\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -134,2 +135,0 @@\n-\/\/ for timer info max values which include all bits\n-#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n@@ -372,1 +371,1 @@\n-    void* p = ::malloc(16*M);\n+    void* p = permit_forbidden_function::malloc(16*M);\n@@ -374,1 +373,1 @@\n-    ::free(p);\n+    permit_forbidden_function::free(p);\n@@ -908,1 +907,1 @@\n-  info_ptr->max_value = ALL_64_BITS;\n+  info_ptr->max_value = all_bits_jlong;\n@@ -1401,1 +1400,1 @@\n-  vmembk_t* p = (vmembk_t*) ::malloc(sizeof(vmembk_t));\n+  vmembk_t* p = (vmembk_t*) permit_forbidden_function::malloc(sizeof(vmembk_t));\n@@ -1430,1 +1429,1 @@\n-      ::free(p0);\n+      permit_forbidden_function::free(p0);\n@@ -2573,1 +2572,1 @@\n-  info_ptr->max_value = ALL_64_BITS;       \/\/ will not wrap in less than 64 bits\n+  info_ptr->max_value = all_bits_jlong;    \/\/ will not wrap in less than 64 bits\n@@ -2580,1 +2579,1 @@\n-  info_ptr->max_value = ALL_64_BITS;       \/\/ will not wrap in less than 64 bits\n+  info_ptr->max_value = all_bits_jlong;    \/\/ will not wrap in less than 64 bits\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  static size_t BUF_LENGTH = 32 + sizeof(u_longlong_t);\n+  const size_t BUF_LENGTH = 32 + sizeof(u_longlong_t);\n@@ -121,1 +121,0 @@\n-  static clock_t ticks_per_sec = sysconf(_SC_CLK_TCK);\n@@ -207,2 +206,0 @@\n-  static clock_t ticks_per_sec = sysconf(_SC_CLK_TCK);\n-\n@@ -217,1 +214,1 @@\n-   *rate = (cpu_stats.pswitch \/ ticks) * ticks_per_sec;\n+   *rate = (cpu_stats.pswitch \/ ticks) * os::Posix::clock_tics_per_second();\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -253,1 +254,1 @@\n-          ALLOW_C_FUNCTION(::free, ::free(demangled_name));\n+          permit_forbidden_function::free(demangled_name);\n@@ -1084,1 +1085,1 @@\n-        struct handletableentry* new_tab = (struct handletableentry*)::realloc(p_handletable, new_max * sizeof(struct handletableentry));\n+        struct handletableentry* new_tab = (struct handletableentry*) permit_forbidden_function::realloc(p_handletable, new_max * sizeof(struct handletableentry));\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -45,3 +47,3 @@\n-      \/\/ call c library's free\n-      ::free(result);\n-      return true;\n+    \/\/ call c library's free\n+    permit_forbidden_function::free(result);\n+    return true;\n","filename":"src\/hotspot\/os\/bsd\/decoder_machO.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  _base = (uintptr_t)os::reserve_memory(max_capacity, false, mtJavaHeap);\n+  _base = (uintptr_t)os::reserve_memory(max_capacity, mtJavaHeap);\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zPhysicalMemoryBacking_bsd.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,3 +117,0 @@\n-\/\/ for timer info max values which include all bits\n-#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n-\n@@ -818,1 +815,1 @@\n-  info_ptr->max_value = ALL_64_BITS;\n+  info_ptr->max_value = all_bits_jlong;\n@@ -2426,1 +2423,1 @@\n-  info_ptr->max_value = ALL_64_BITS;       \/\/ will not wrap in less than 64 bits\n+  info_ptr->max_value = all_bits_jlong;    \/\/ will not wrap in less than 64 bits\n@@ -2433,1 +2430,1 @@\n-  info_ptr->max_value = ALL_64_BITS;       \/\/ will not wrap in less than 64 bits\n+  info_ptr->max_value = all_bits_jlong;    \/\/ will not wrap in less than 64 bits\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -49,3 +50,3 @@\n-      \/\/ call c library's free\n-      ALLOW_C_FUNCTION(::free, ::free(result);)\n-      return true;\n+    \/\/ call c library's free\n+    permit_forbidden_function::free(result);\n+    return true;\n","filename":"src\/hotspot\/os\/linux\/decoder_linux.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -65,1 +66,1 @@\n-    ALLOW_C_FUNCTION(::free, ::free(line_mountpoint);)\n+    permit_forbidden_function::free(line_mountpoint);\n@@ -69,1 +70,1 @@\n-  ALLOW_C_FUNCTION(::free, ::free(line_filesystem);)\n+  permit_forbidden_function::free(line_filesystem);\n@@ -93,1 +94,1 @@\n-  ALLOW_C_FUNCTION(::free, ::free(line);)\n+  permit_forbidden_function::free(line);\n@@ -100,1 +101,1 @@\n-    ALLOW_C_FUNCTION(::free, ::free(mountpoint);) \/\/ *not* os::free\n+    permit_forbidden_function::free(mountpoint); \/\/ *not* os::free\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zMountPoint_linux.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -38,1 +39,1 @@\n-  ALLOW_C_FUNCTION(::open_memstream, FILE* stream = ::open_memstream(&buf, &size);)\n+  FILE* stream = ::open_memstream(&buf, &size);\n@@ -46,1 +47,1 @@\n-    ALLOW_C_FUNCTION(::fflush, fflush(stream);)\n+    fflush(stream);\n@@ -56,2 +57,2 @@\n-  ALLOW_C_FUNCTION(::fclose, ::fclose(stream);)\n-  ALLOW_C_FUNCTION(::free, ::free(buf);)\n+  ::fclose(stream);\n+  permit_forbidden_function::free(buf);\n","filename":"src\/hotspot\/os\/linux\/mallocInfoDcmd.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -142,3 +142,0 @@\n-\/\/ for timer info max values which include all bits\n-#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n-\n@@ -216,2 +213,0 @@\n-static int clock_tics_per_sec = 100;\n-\n@@ -1670,1 +1665,1 @@\n-          debug_only(VMNativeEntryWrapper vew;)\n+          DEBUG_ONLY(VMNativeEntryWrapper vew;)\n@@ -4384,2 +4379,0 @@\n-\n-  clock_tics_per_sec = checked_cast<int>(sysconf(_SC_CLK_TCK));\n@@ -4578,1 +4571,1 @@\n-  char* codebuf = os::attempt_reserve_memory_at(hint, page_size, false, mtThread);\n+  char* codebuf = os::attempt_reserve_memory_at(hint, page_size, mtThread);\n@@ -4586,1 +4579,1 @@\n-    codebuf = os::attempt_reserve_memory_at(hint, page_size, false, mtThread);\n+    codebuf = os::attempt_reserve_memory_at(hint, page_size, mtThread);\n@@ -5138,1 +5131,1 @@\n-    return ((jlong)sys_time + (jlong)user_time) * (1000000000 \/ clock_tics_per_sec);\n+    return ((jlong)sys_time + (jlong)user_time) * (1000000000 \/ os::Posix::clock_tics_per_second());\n@@ -5140,1 +5133,1 @@\n-    return (jlong)user_time * (1000000000 \/ clock_tics_per_sec);\n+    return (jlong)user_time * (1000000000 \/ os::Posix::clock_tics_per_second());\n@@ -5145,1 +5138,1 @@\n-  info_ptr->max_value = ALL_64_BITS;       \/\/ will not wrap in less than 64 bits\n+  info_ptr->max_value = all_bits_jlong;    \/\/ will not wrap in less than 64 bits\n@@ -5152,1 +5145,1 @@\n-  info_ptr->max_value = ALL_64_BITS;       \/\/ will not wrap in less than 64 bits\n+  info_ptr->max_value = all_bits_jlong;    \/\/ will not wrap in less than 64 bits\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_FORBIDDENFUNCTIONS_POSIX_HPP\n+#define OS_POSIX_FORBIDDENFUNCTIONS_POSIX_HPP\n+\n+#include \"utilities\/compilerWarnings.hpp\"\n+\n+\/\/ For types used in the signatures.\n+#include <stddef.h>\n+\n+\/\/ Workaround for noreturn functions: _exit - see the clang\n+\/\/ definition of FORBIDDEN_FUNCTION_NORETURN_ATTRIBUTE.\n+#ifdef __clang__\n+#include <unistd.h>\n+#endif\n+\n+\/\/ If needed, add os::strndup and use that instead.\n+FORBID_C_FUNCTION(char* strndup(const char*, size_t), \"don't use\");\n+\n+\/\/ These are unimplementable for Windows, and they aren't useful for a\n+\/\/ POSIX implementation of NMT either.\n+\/\/ https:\/\/stackoverflow.com\/questions\/62962839\/stdaligned-alloc-missing-from-visual-studio-2019\n+FORBID_C_FUNCTION(int posix_memalign(void**, size_t, size_t), \"don't use\");\n+FORBID_C_FUNCTION(void* aligned_alloc(size_t, size_t), \"don't use\");\n+\n+\/\/ realpath with a null second argument mallocs a string for the result.\n+\/\/ With a non-null second argument, there is a risk of buffer overrun.\n+PRAGMA_DIAG_PUSH\n+FORBIDDEN_FUNCTION_IGNORE_CLANG_FORTIFY_WARNING\n+FORBID_C_FUNCTION(char* realpath(const char*, char*), \"use os::realpath\");\n+PRAGMA_DIAG_POP\n+\n+\/\/ Returns a malloc'ed string.\n+FORBID_C_FUNCTION(char* get_current_dir_name(), \"use os::get_current_directory\");\n+\n+\/\/ Problematic API that should never be used.\n+FORBID_C_FUNCTION(char* getwd(char*), \"use os::get_current_directory\");\n+\n+\/\/ BSD utility that is subtly different from realloc.\n+FORBID_C_FUNCTION(void* reallocf(void*, size_t), \"use os::realloc\");\n+\n+#endif \/\/ OS_POSIX_FORBIDDENFUNCTIONS_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/forbiddenFunctions_posix.hpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -494,1 +495,1 @@\n-char* os::reserve_memory_aligned(size_t size, size_t alignment, bool exec) {\n+char* os::reserve_memory_aligned(size_t size, size_t alignment, MemTag mem_tag, bool exec) {\n@@ -496,1 +497,1 @@\n-  char* extra_base = os::reserve_memory(extra_size, exec);\n+  char* extra_base = os::reserve_memory(extra_size, mem_tag, exec);\n@@ -933,1 +934,1 @@\n-  ALLOW_C_FUNCTION(::exit, ::exit(num);)\n+  permit_forbidden_function::exit(num);\n@@ -937,1 +938,1 @@\n-  ALLOW_C_FUNCTION(::_exit, ::_exit(num);)\n+  permit_forbidden_function::_exit(num);\n@@ -994,1 +995,1 @@\n-  ALLOW_C_FUNCTION(::realpath, char* p = ::realpath(filename, nullptr);)\n+  char* p = permit_forbidden_function::realpath(filename, nullptr);\n@@ -1002,1 +1003,1 @@\n-    ALLOW_C_FUNCTION(::free, ::free(p);) \/\/ *not* os::free\n+    permit_forbidden_function::free(p); \/\/ *not* os::free\n@@ -1011,1 +1012,1 @@\n-      ALLOW_C_FUNCTION(::realpath, p = ::realpath(filename, outbuf);)\n+      p = permit_forbidden_function::realpath(filename, outbuf);\n@@ -1328,0 +1329,4 @@\n+int os::Posix::clock_tics_per_second() {\n+  return clock_tics_per_sec;\n+}\n+\n@@ -1475,3 +1480,0 @@\n-\/\/ for timer info max values which include all bits\n-#define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)\n-\n@@ -1480,1 +1482,1 @@\n-  info_ptr->max_value = ALL_64_BITS;\n+  info_ptr->max_value = all_bits_jlong;\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,0 +94,3 @@\n+  \/\/ clock ticks per second of the system\n+  static int clock_tics_per_second();\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  char* mapAddress = os::reserve_memory(size);\n+  char* mapAddress = os::reserve_memory(size, mtInternal);\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_PERMITFORBIDDENFUNCTIONS_POSIX_HPP\n+#define OS_POSIX_PERMITFORBIDDENFUNCTIONS_POSIX_HPP\n+\n+#include \"utilities\/compilerWarnings.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Provide wrappers for some functions otherwise forbidden from use in HotSpot.\n+\/\/ See forbiddenFunctions.hpp for details.\n+\n+namespace permit_forbidden_function {\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n+\n+\/\/ Used by the POSIX implementation of os::realpath.\n+inline char* realpath(const char* path, char* resolved_path) {\n+  return ::realpath(path, resolved_path);\n+}\n+\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n+} \/\/ namespace permit_forbidden_function\n+\n+#endif \/\/ OS_POSIX_PERMITFORBIDDENFUNCTIONS_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/permitForbiddenFunctions_posix.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -150,1 +150,1 @@\n-debug_only(static bool signal_sets_initialized = false);\n+DEBUG_ONLY(static bool signal_sets_initialized = false);\n@@ -1550,1 +1550,1 @@\n-  debug_only(signal_sets_initialized = true);\n+  DEBUG_ONLY(signal_sets_initialized = true);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_WINDOWS_FORBIDDENFUNCTIONS_WINDOWS_HPP\n+#define OS_WINDOWS_FORBIDDENFUNCTIONS_WINDOWS_HPP\n+\n+#include \"utilities\/compilerWarnings.hpp\"\n+\n+#include <stddef.h> \/\/ for size_t\n+\n+\/\/ _fullpath with a null first argument mallocs a string for the result.\n+FORBID_IMPORTED_C_FUNCTION(char* _fullpath(char*, const char*, size_t), \"use os::realpath\");\n+\n+\/\/ _snprintf does NOT null terminate if the output would exceed the buffer size.\n+FORBID_C_FUNCTION(int _snprintf(char*, size_t, const char*, ...), \"use os::snprintf\");\n+\n+#endif \/\/ OS_WINDOWS_FORBIDDENFUNCTIONS_WINDOWS_HPP\n","filename":"src\/hotspot\/os\/windows\/forbiddenFunctions_windows.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -79,0 +79,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -114,3 +115,0 @@\n-\/\/ for timer info max values which include all bits\n-#define ALL_64_BITS CONST64(-1)\n-\n@@ -1227,1 +1225,1 @@\n-    info_ptr->max_value = ALL_64_BITS;\n+    info_ptr->max_value = all_bits_jlong;\n@@ -1231,1 +1229,1 @@\n-    julong max_counter = (julong)ALL_64_BITS;\n+    julong max_counter = (julong)all_bits_jlong;\n@@ -1236,1 +1234,1 @@\n-    info_ptr->max_value = ALL_64_BITS;\n+    info_ptr->max_value = all_bits_jlong;\n@@ -3022,1 +3020,1 @@\n-  MemTracker::record_virtual_memory_reserve((address)p_buf, size_of_reserve, CALLER_PC);\n+  MemTracker::record_virtual_memory_reserve((address)p_buf, size_of_reserve, CALLER_PC, mtNone);\n@@ -3083,1 +3081,1 @@\n-                                                  bytes_to_release, CALLER_PC);\n+                                                  bytes_to_release, CALLER_PC, mtNone);\n@@ -3101,1 +3099,1 @@\n-    MemTracker::record_virtual_memory_reserve_and_commit((address)p_buf, bytes, CALLER_PC);\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)p_buf, bytes, CALLER_PC, mtNone);\n@@ -3103,1 +3101,1 @@\n-    MemTracker::record_virtual_memory_reserve((address)p_buf, bytes, CALLER_PC);\n+    MemTracker::record_virtual_memory_reserve((address)p_buf, bytes, CALLER_PC, mtNone);\n@@ -3243,1 +3241,1 @@\n-static char* map_or_reserve_memory_aligned(size_t size, size_t alignment, int file_desc, MemTag mem_tag = mtNone) {\n+static char* map_or_reserve_memory_aligned(size_t size, size_t alignment, int file_desc, MemTag mem_tag) {\n@@ -3257,1 +3255,1 @@\n-                                         os::reserve_memory(extra_size, false, mem_tag);\n+                                         os::reserve_memory(extra_size, mem_tag);\n@@ -3274,1 +3272,1 @@\n-                                     os::attempt_reserve_memory_at(aligned_base, size, false, mem_tag);\n+                                     os::attempt_reserve_memory_at(aligned_base, size, mem_tag);\n@@ -3283,1 +3281,1 @@\n-char* os::reserve_memory_aligned(size_t size, size_t alignment, bool exec) {\n+char* os::reserve_memory_aligned(size_t size, size_t alignment, MemTag mem_tag, bool exec) {\n@@ -3285,1 +3283,1 @@\n-  return map_or_reserve_memory_aligned(size, alignment, -1 \/* file_desc *\/);\n+  return map_or_reserve_memory_aligned(size, alignment, -1\/* file_desc *\/, mem_tag);\n@@ -4361,1 +4359,1 @@\n-    ALLOW_C_FUNCTION(::exit, ::exit(exit_code);)\n+    permit_forbidden_function::exit(exit_code);\n@@ -4363,1 +4361,1 @@\n-    ALLOW_C_FUNCTION(::_exit, ::_exit(exit_code);)\n+    permit_forbidden_function::_exit(exit_code);\n@@ -4815,1 +4813,1 @@\n-  info_ptr->max_value = ALL_64_BITS;        \/\/ the max value -- all 64 bits\n+  info_ptr->max_value = all_bits_jlong;     \/\/ the max value -- all 64 bits\n@@ -4822,1 +4820,1 @@\n-  info_ptr->max_value = ALL_64_BITS;        \/\/ the max value -- all 64 bits\n+  info_ptr->max_value = all_bits_jlong;     \/\/ the max value -- all 64 bits\n@@ -5134,1 +5132,1 @@\n-  ALLOW_C_FUNCTION(::_fullpath, char* p = ::_fullpath(nullptr, filename, 0);)\n+  char* p = permit_forbidden_function::_fullpath(nullptr, filename, 0);\n@@ -5142,1 +5140,1 @@\n-    ALLOW_C_FUNCTION(::free, ::free(p);) \/\/ *not* os::free\n+    permit_forbidden_function::free(p); \/\/ *not* os::free\n@@ -5190,1 +5188,1 @@\n-    MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC, mtNone);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  char* mapAddress = os::reserve_memory(size);\n+  char* mapAddress = os::reserve_memory(size, mtInternal);\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_WINDOWS_PERMITFORBIDDENFUNCTIONS_WINDOWS_HPP\n+#define OS_WINDOWS_PERMITFORBIDDENFUNCTIONS_WINDOWS_HPP\n+\n+#include \"utilities\/compilerWarnings.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Provide wrappers for some functions otherwise forbidden from use in HotSpot.\n+\/\/ See forbiddenFunctions.hpp for details.\n+\n+namespace permit_forbidden_function {\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n+\n+\/\/ Used by the Windows implementation of os::realpath.\n+inline char* _fullpath(char* absPath, const char* relPath, size_t maxLength) {\n+  return ::_fullpath(absPath, relPath, maxLength);\n+}\n+\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n+} \/\/ namespace permit_forbidden_function\n+\n+#endif \/\/ OS_WINDOWS_PERMITFORBIDDENFUNCTIONS_WINDOWS_HPP\n","filename":"src\/hotspot\/os\/windows\/permitForbiddenFunctions_windows.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -105,1 +106,1 @@\n-    T* q = (T*) ::malloc(bytes);\n+    T* q = (T*) permit_forbidden_function::malloc(bytes);\n@@ -121,1 +122,1 @@\n-      ::free(_p);\n+      permit_forbidden_function::free(_p);\n","filename":"src\/hotspot\/os\/windows\/symbolengine.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -78,0 +78,8 @@\n+#ifndef HWCAP_FPHP\n+#define HWCAP_FPHP (1<<9)\n+#endif\n+\n+#ifndef HWCAP_ASIMDHP\n+#define HWCAP_ASIMDHP (1<<10)\n+#endif\n+\n@@ -122,0 +130,2 @@\n+  static_assert(CPU_FPHP    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n+  static_assert(CPU_ASIMDHP == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n@@ -136,1 +146,3 @@\n-      HWCAP_PACA);\n+      HWCAP_PACA    |\n+      HWCAP_FPHP    |\n+      HWCAP_ASIMDHP);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+\n+  int features_offset = strnlen(buf, sizeof(buf));\n+\n@@ -194,1 +197,3 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n+\n+  _features_string = _cpu_info_string + features_offset;\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  enum { PatchCacheSize = 4 debug_only( +4 ) };\n+  enum { PatchCacheSize = 4 DEBUG_ONLY( +4 ) };\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  debug_only(verify_section_allocation();)\n+  DEBUG_ONLY(verify_section_allocation();)\n@@ -123,1 +123,1 @@\n-  debug_only(verify_section_allocation();)\n+  DEBUG_ONLY(verify_section_allocation();)\n@@ -497,1 +497,1 @@\n-    debug_only(dest_cs->_start = nullptr);  \/\/ defeat double-initialization assert\n+    DEBUG_ONLY(dest_cs->_start = nullptr);  \/\/ defeat double-initialization assert\n@@ -508,1 +508,1 @@\n-  debug_only(dest->verify_section_allocation();)\n+  DEBUG_ONLY(dest->verify_section_allocation();)\n@@ -942,1 +942,1 @@\n-  debug_only(Copy::fill_to_bytes(bxp->_total_start, bxp->_total_size,\n+  DEBUG_ONLY(Copy::fill_to_bytes(bxp->_total_start, bxp->_total_size,\n@@ -946,1 +946,1 @@\n-  debug_only(verify_section_allocation();)\n+  DEBUG_ONLY(verify_section_allocation();)\n@@ -1045,0 +1045,3 @@\n+  if (insts()->scratch_emit()) {\n+    return;\n+  }\n@@ -1052,0 +1055,3 @@\n+  if (insts()->scratch_emit()) {\n+    return str;\n+  }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -131,2 +131,2 @@\n-    debug_only(_index = -1);\n-    debug_only(_outer = (CodeBuffer*)badAddress);\n+    DEBUG_ONLY(_index = -1);\n+    DEBUG_ONLY(_outer = (CodeBuffer*)badAddress);\n@@ -545,1 +545,1 @@\n-    debug_only(verify_section_allocation();)\n+    DEBUG_ONLY(verify_section_allocation();)\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-    debug_only(cpu_range_check(rnr);)\n+    DEBUG_ONLY(cpu_range_check(rnr);)\n@@ -118,1 +118,1 @@\n-    debug_only(cpu_range_check(reg->encoding());)\n+    DEBUG_ONLY(cpu_range_check(reg->encoding());)\n@@ -123,2 +123,2 @@\n-    debug_only(cpu_range_check(rnr);)\n-    debug_only(cpu_range_check(reg->encoding());)\n+    DEBUG_ONLY(cpu_range_check(rnr);)\n+    DEBUG_ONLY(cpu_range_check(reg->encoding());)\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1545,1 +1545,1 @@\n-  debug_only(NoHandleMark nhm;)\n+  DEBUG_ONLY(NoHandleMark nhm;)\n@@ -1562,1 +1562,1 @@\n-  debug_only(NoHandleMark nhm;)\n+  DEBUG_ONLY(NoHandleMark nhm;)\n@@ -1579,1 +1579,1 @@\n-  debug_only(NoHandleMark nhm;)\n+  DEBUG_ONLY(NoHandleMark nhm;)\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -76,0 +77,1 @@\n+  AOTReferenceObjSupport::init_keep_alive_objs_table();\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -341,1 +341,2 @@\n-         ik == vmClasses::ConcurrentHashMap_klass();\n+         ik == vmClasses::ConcurrentHashMap_klass() ||\n+         ik == vmClasses::Reference_klass();\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+\/\/ Handling of java.lang.ref.Reference objects in the AOT cache\n+\/\/ ============================================================\n+\/\/\n+\/\/ When AOTArtifactFinder finds an oop which is a instance of java.lang.ref.Reference:\n+\/\/\n+\/\/ - We check if the oop is eligible to be stored in the AOT cache. If not, the AOT cache\n+\/\/   creation fails -- see AOTReferenceObjSupport::check_if_ref_obj()\n+\/\/\n+\/\/ - Otherwise, we store the oop into the AOT cache, but we unconditionally reset its\n+\/\/   \"next\" and \"discovered\" fields to null. Otherwise, if AOTArtifactFinder follows these\n+\/\/   fields, it may found unrelated objects that we don't intend to cache.\n+\/\/\n+\/\/ Eligibility\n+\/\/ ===========\n+\/\/\n+\/\/ [1] A reference that does not require special clean up (i.e., Reference::queue == ReferenceQueue.NULL_QUEUE)\n+\/\/     is eligible.\n+\/\/\n+\/\/ [2] A reference that REQUIRE specials clean up (i.e., Reference::queue != ReferenceQueue.NULL_QUEUE)\n+\/\/     is eligible ONLY if its referent is not null.\n+\/\/\n+\/\/ As of this version, the only oops in group [2] that can be found by AOTArtifactFinder are\n+\/\/ the keys used by ReferencedKeyMap in the implementation of MethodType::internTable.\n+\/\/ stabilize_cached_reference_objects() ensures that all keys found by AOTArtifactFinder are eligible.\n+\/\/\n+\/\/ The purpose of the error check in check_if_ref_obj() is to guard against changes in the JDK core\n+\/\/ libs that might introduce new types of oops in group [2] into the AOT cache.\n+\/\/\n+\/\/ Reasons for the eligibility restrictions\n+\/\/ ========================================\n+\/\/\n+\/\/ Reference handling is complex. In this version, we implement only enough functionality to support\n+\/\/ the use of Weak\/Soft references used by java.lang.invoke.\n+\/\/\n+\/\/ We intend to evolve the implementation in the future by\n+\/\/ -- implementing more assemblySetup() operations for other use cases, and\/or\n+\/\/ -- relaxing the eligibility restrictions.\n+\/\/\n+\/\/\n+\/\/ null referents for group [1]\n+\/\/ ============================\n+\/\/\n+\/\/ Any cached reference R1 of group [1] is allowed to have a null referent.\n+\/\/ This can happen in the following situations:\n+\/\/    (a) R1.clear() was called by Java code during the assembly phase.\n+\/\/    (b) The referent has been collected, and R1 is in the \"pending\" state.\n+\/\/ In case (b), the \"next\" and \"discovered\" fields of the cached copy of R1 will\n+\/\/ be set to null. During the production run:\n+\/\/    - It would appear to the Java program as if immediately during VM start-up, the referent\n+\/\/      was collected and ReferenceThread completed processing of R1.\n+\/\/    - It would appear to the GC as if immediately during VM start-up, the Java program called\n+\/\/      R1.clear().\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+class KeepAliveObjectsTable : public ResourceHashtable<oop, bool,\n+    36137, \/\/ prime number\n+    AnyObj::C_HEAP,\n+    mtClassShared,\n+    HeapShared::oop_hash> {};\n+\n+static KeepAliveObjectsTable* _keep_alive_objs_table;\n+static OopHandle _keep_alive_objs_array;\n+static OopHandle _null_queue;\n+\n+bool AOTReferenceObjSupport::is_enabled() {\n+  \/\/ For simplicity, AOTReferenceObjSupport is enabled only when dumping method handles.\n+  \/\/ Otherwise we won't see Reference objects in the AOT cache. Let's be conservative now.\n+  return CDSConfig::is_dumping_method_handles();\n+}\n+\n+void AOTReferenceObjSupport::initialize(TRAPS) {\n+  if (!AOTReferenceObjSupport::is_enabled()) {\n+    return;\n+  }\n+\n+  TempNewSymbol class_name = SymbolTable::new_symbol(\"java\/lang\/ref\/ReferenceQueue\");\n+  Klass* k = SystemDictionary::resolve_or_fail(class_name, true, CHECK);\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  ik->initialize(CHECK);\n+\n+  TempNewSymbol field_name = SymbolTable::new_symbol(\"NULL_QUEUE\");\n+  fieldDescriptor fd;\n+  bool found = ik->find_local_field(field_name, vmSymbols::referencequeue_signature(), &fd);\n+  precond(found);\n+  precond(fd.is_static());\n+\n+  _null_queue = OopHandle(Universe::vm_global(), ik->java_mirror()->obj_field(fd.offset()));\n+}\n+\n+\/\/ Ensure that all group [2] references found by AOTArtifactFinder are eligible.\n+void AOTReferenceObjSupport::stabilize_cached_reference_objects(TRAPS) {\n+  if (AOTReferenceObjSupport::is_enabled()) {\n+    \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n+    \/\/ updated concurrently, so we can remove GC'ed entries ...\n+    assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n+\n+    {\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"assemblySetup\");\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n+                           method_name,\n+                           vmSymbols::void_method_signature(),\n+                           CHECK);\n+    }\n+\n+    {\n+      Symbol* cds_name  = vmSymbols::jdk_internal_misc_CDS();\n+      Klass* cds_klass = SystemDictionary::resolve_or_fail(cds_name, true \/*throw error*\/,  CHECK);\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"getKeepAliveObjects\");\n+      TempNewSymbol method_sig = SymbolTable::new_symbol(\"()[Ljava\/lang\/Object;\");\n+      JavaValue result(T_OBJECT);\n+      JavaCalls::call_static(&result, cds_klass, method_name, method_sig, CHECK);\n+\n+      _keep_alive_objs_array = OopHandle(Universe::vm_global(), result.get_oop());\n+    }\n+  }\n+}\n+\n+void AOTReferenceObjSupport::init_keep_alive_objs_table() {\n+  assert_at_safepoint(); \/\/ _keep_alive_objs_table uses raw oops\n+  oop a = _keep_alive_objs_array.resolve();\n+  if (a != nullptr) {\n+    precond(a->is_objArray());\n+    precond(AOTReferenceObjSupport::is_enabled());\n+    objArrayOop array = objArrayOop(a);\n+\n+    _keep_alive_objs_table = new (mtClass)KeepAliveObjectsTable();\n+    for (int i = 0; i < array->length(); i++) {\n+      oop obj = array->obj_at(i);\n+      _keep_alive_objs_table->put(obj, true); \/\/ The array may have duplicated entries but that's OK.\n+    }\n+  }\n+}\n+\n+\/\/ Returns true IFF obj is an instance of java.lang.ref.Reference. If so, perform extra eligibility checks.\n+bool AOTReferenceObjSupport::check_if_ref_obj(oop obj) {\n+  \/\/ We have a single Java thread. This means java.lang.ref.Reference$ReferenceHandler thread\n+  \/\/ is not running. Otherwise the checks for next\/discovered may not work.\n+  precond(CDSConfig::allow_only_single_java_thread());\n+  assert_at_safepoint(); \/\/ _keep_alive_objs_table uses raw oops\n+\n+  if (obj->klass()->is_subclass_of(vmClasses::Reference_klass())) {\n+    precond(AOTReferenceObjSupport::is_enabled());\n+    precond(JavaClasses::is_supported_for_archiving(obj));\n+    precond(_keep_alive_objs_table != nullptr);\n+\n+    \/\/ GC needs to know about this load, It will keep referent alive until the current safepoint ends.\n+    oop referent = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(obj, java_lang_ref_Reference::referent_offset());\n+\n+    oop queue = obj->obj_field(java_lang_ref_Reference::queue_offset());\n+    oop next = java_lang_ref_Reference::next(obj);\n+    oop discovered = java_lang_ref_Reference::discovered(obj);\n+    bool needs_special_cleanup = (queue != _null_queue.resolve());\n+\n+    \/\/ If you see the errors below, you probably modified the implementation of java.lang.invoke.\n+    \/\/ Please check the comments at the top of this file.\n+    if (needs_special_cleanup && (referent == nullptr || !_keep_alive_objs_table->contains(referent))) {\n+      ResourceMark rm;\n+\n+      log_error(cds, heap)(\"Cannot archive reference object \" PTR_FORMAT \" of class %s\",\n+                           p2i(obj), obj->klass()->external_name());\n+      log_error(cds, heap)(\"referent = \" PTR_FORMAT\n+                           \", queue = \" PTR_FORMAT\n+                           \", next = \" PTR_FORMAT\n+                           \", discovered = \" PTR_FORMAT,\n+                           p2i(referent), p2i(queue), p2i(next), p2i(discovered));\n+      log_error(cds, heap)(\"This object requires special clean up as its queue is not ReferenceQueue::N\" \"ULL (\"\n+                           PTR_FORMAT \")\", p2i(_null_queue.resolve()));\n+      log_error(cds, heap)(\"%s\", (referent == nullptr) ?\n+                           \"referent cannot be null\" : \"referent is not registered with CDS.keepAlive()\");\n+      HeapShared::debug_trace();\n+      MetaspaceShared::unrecoverable_writing_error();\n+    }\n+\n+    if (log_is_enabled(Info, cds, ref)) {\n+      ResourceMark rm;\n+      log_info(cds, ref)(\"Reference obj:\"\n+                         \" r=\" PTR_FORMAT\n+                         \" q=\" PTR_FORMAT\n+                         \" n=\" PTR_FORMAT\n+                         \" d=\" PTR_FORMAT\n+                         \" %s\",\n+                         p2i(referent),\n+                         p2i(queue),\n+                         p2i(next),\n+                         p2i(discovered),\n+                         obj->klass()->external_name());\n+    }\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool AOTReferenceObjSupport::skip_field(int field_offset) {\n+  return (field_offset == java_lang_ref_Reference::next_offset() ||\n+          field_offset == java_lang_ref_Reference::discovered_offset());\n+}\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.cpp","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTREFERENCEOBJSUPPORT_HPP\n+#define SHARE_CDS_AOTREFERENCEOBJSUPPORT_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+\/\/ Support for ahead-of-time allocated instances of java.lang.ref.Reference\n+\n+class AOTReferenceObjSupport : AllStatic {\n+\n+public:\n+  static void initialize(TRAPS);\n+  static void stabilize_cached_reference_objects(TRAPS);\n+  static void init_keep_alive_objs_table() NOT_CDS_JAVA_HEAP_RETURN;\n+  static bool check_if_ref_obj(oop obj);\n+  static bool skip_field(int field_offset);\n+  static bool is_enabled();\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTREFERENCEOBJSUPPORT_HPP\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -312,1 +312,2 @@\n-                                             os::vm_page_size());\n+                                             os::vm_page_size(),\n+                                             mtClassShared);\n@@ -1204,1 +1205,1 @@\n-  \/\/ runtime, this region will be mapped to requested_base. requested_base is 0 if this\n+  \/\/ runtime, this region will be mapped to requested_base. requested_base is nullptr if this\n@@ -1213,1 +1214,5 @@\n-    top = requested_base + size;\n+    if (requested_base == nullptr) {\n+      top = (address)size;\n+    } else {\n+      top = requested_base + size;\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -612,1 +613,1 @@\n-\n+  bool _is_java_lang_ref;\n@@ -615,1 +616,4 @@\n-    _src_obj(src_obj), _buffered_obj(buffered_obj), _oopmap(oopmap) {}\n+    _src_obj(src_obj), _buffered_obj(buffered_obj), _oopmap(oopmap)\n+  {\n+    _is_java_lang_ref = AOTReferenceObjSupport::check_if_ref_obj(src_obj);\n+  }\n@@ -622,2 +626,8 @@\n-    size_t field_offset = pointer_delta(p, _src_obj, sizeof(char));\n-    ArchiveHeapWriter::relocate_field_in_buffer<T>((T*)(_buffered_obj + field_offset), _oopmap);\n+    int field_offset = pointer_delta_as_int((char*)p, cast_from_oop<char*>(_src_obj));\n+    T* field_addr = (T*)(_buffered_obj + field_offset);\n+    if (_is_java_lang_ref && AOTReferenceObjSupport::skip_field(field_offset)) {\n+      \/\/ Do not copy these fields. Set them to null\n+      *field_addr = (T)0x0;\n+    } else {\n+      ArchiveHeapWriter::relocate_field_in_buffer<T>(field_addr, _oopmap);\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -560,3 +560,0 @@\n-\n-    \/\/ Don't use SoftReferences so that objects used by java.lang.invoke tables can be archived.\n-    Arguments::PropertyList_add(new SystemProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"false\", false));\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1142,1 +1142,1 @@\n-                        bool allow_exec, MemTag mem_tag = mtNone) {\n+                        bool allow_exec, MemTag mem_tag) {\n@@ -1144,2 +1144,2 @@\n-                             AlwaysPreTouch ? false : read_only,\n-                             allow_exec, mem_tag);\n+                             mem_tag, AlwaysPreTouch ? false : read_only,\n+                             allow_exec);\n@@ -1170,1 +1170,1 @@\n-                              addr, size, false \/* !read_only *\/,\n+                              addr, size, mtNone, false \/* !read_only *\/,\n@@ -1696,1 +1696,1 @@\n-                      r->allow_exec());\n+                      r->allow_exec(), mtJavaHeap);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -1366,2 +1367,3 @@\n-\/\/ Push all oops that are referenced by _referencing_obj onto the _stack.\n-class HeapShared::ReferentPusher: public BasicOopIterateClosure {\n+\/\/ Push all oop fields (or oop array elemenets in case of an objArray) in\n+\/\/ _referencing_obj onto the _stack.\n+class HeapShared::OopFieldPusher: public BasicOopIterateClosure {\n@@ -1374,0 +1376,1 @@\n+  bool _is_java_lang_ref;\n@@ -1375,5 +1378,5 @@\n-  ReferentPusher(PendingOopStack* stack,\n-                           int level,\n-                           bool record_klasses_only,\n-                           KlassSubGraphInfo* subgraph_info,\n-                           oop orig) :\n+  OopFieldPusher(PendingOopStack* stack,\n+                 int level,\n+                 bool record_klasses_only,\n+                 KlassSubGraphInfo* subgraph_info,\n+                 oop orig) :\n@@ -1386,0 +1389,1 @@\n+    _is_java_lang_ref = AOTReferenceObjSupport::check_if_ref_obj(orig);\n@@ -1387,2 +1391,2 @@\n-  void do_oop(narrowOop *p) { ReferentPusher::do_oop_work(p); }\n-  void do_oop(      oop *p) { ReferentPusher::do_oop_work(p); }\n+  void do_oop(narrowOop *p) { OopFieldPusher::do_oop_work(p); }\n+  void do_oop(      oop *p) { OopFieldPusher::do_oop_work(p); }\n@@ -1390,1 +1394,1 @@\n-  ~ReferentPusher() {\n+  ~OopFieldPusher() {\n@@ -1393,1 +1397,1 @@\n-      \/\/ of ReferentPusher that recurses on the C stack -- a depth-first search,\n+      \/\/ of OopFieldPusher that recurses on the C stack -- a depth-first search,\n@@ -1402,1 +1406,2 @@\n-    oop obj = RawAccess<>::oop_load(p);\n+    int field_offset = pointer_delta_as_int((char*)p, cast_from_oop<char*>(_referencing_obj));\n+    oop obj = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(_referencing_obj, field_offset);\n@@ -1404,1 +1409,4 @@\n-      size_t field_delta = pointer_delta(p, _referencing_obj, sizeof(char));\n+      if (_is_java_lang_ref && AOTReferenceObjSupport::skip_field(field_offset)) {\n+        \/\/ Do not follow these fields. They will be cleared to null.\n+        return;\n+      }\n@@ -1408,2 +1416,2 @@\n-        log_debug(cds, heap)(\"(%d) %s[%zu] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n-                             _referencing_obj->klass()->external_name(), field_delta,\n+        log_debug(cds, heap)(\"(%d) %s[%d] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n+                             _referencing_obj->klass()->external_name(), field_offset,\n@@ -1589,1 +1597,1 @@\n-    ReferentPusher pusher(stack, level, record_klasses_only, subgraph_info, orig_obj);\n+    OopFieldPusher pusher(stack, level, record_klasses_only, subgraph_info, orig_obj);\n@@ -1616,1 +1624,1 @@\n-\/\/ The Java heap object sub-graph archiving process (see ReferentPusher):\n+\/\/ The Java heap object sub-graph archiving process (see OopFieldPusher):\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-  static void debug_trace();\n@@ -169,0 +168,1 @@\n+  static void debug_trace();\n@@ -360,1 +360,1 @@\n-  class ReferentPusher;\n+  class OopFieldPusher;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -967,0 +968,1 @@\n+\n@@ -972,11 +974,2 @@\n-    if (CDSConfig::is_dumping_method_handles()) {\n-      \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n-      \/\/ updated concurrently when we are saving their contents into a side table.\n-      assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n-\n-      JavaValue result(T_VOID);\n-      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n-                             vmSymbols::createArchivedObjects(),\n-                             vmSymbols::void_method_signature(),\n-                             CHECK);\n-    }\n+    AOTReferenceObjSupport::initialize(CHECK);\n+    AOTReferenceObjSupport::stabilize_cached_reference_objects(CHECK);\n@@ -1355,1 +1348,1 @@\n-                                                  false, MemTag::mtClassShared);\n+                                                  mtClassShared);\n@@ -1547,1 +1540,2 @@\n-                                               os::vm_page_size());\n+                                               os::vm_page_size(),\n+                                               mtNone);\n@@ -1615,1 +1609,2 @@\n-                                                 os::vm_page_size());\n+                                                 os::vm_page_size(),\n+                                                 mtNone);\n@@ -1619,1 +1614,2 @@\n-                                                 os::vm_page_size());\n+                                                 os::vm_page_size(),\n+                                                 mtNone);\n@@ -1632,1 +1628,2 @@\n-                                               os::vm_page_size());\n+                                               os::vm_page_size(),\n+                                               mtNone);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -146,0 +146,6 @@\n+\n+char* ciInstance::java_lang_String_str(char* buf, size_t buflen) {\n+  VM_ENTRY_MARK;\n+  assert(get_oop()->is_a(vmClasses::String_klass()), \"not a String\");\n+  return java_lang_String::as_utf8_string(get_oop(), buf, buflen);\n+}\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+  char* java_lang_String_str(char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -972,2 +972,8 @@\n-      count = (int)((double)count * prof_factor * method_life \/ counter_life + 0.5);\n-      count = (count > 0) ? count : 1;\n+      double count_d = (double)count * prof_factor * method_life \/ counter_life + 0.5;\n+      if (count_d >= static_cast<double>(INT_MAX)) {\n+        \/\/ Clamp in case of overflowing int range.\n+        count = INT_MAX;\n+      } else {\n+        count = int(count_d);\n+        count = (count > 0) ? count : 1;\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2986,1 +2986,1 @@\n-  debug_only(int max_block = _next_pre_order;)\n+  DEBUG_ONLY(int max_block = _next_pre_order;)\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-      debug_only(set_type_at_tos(bottom_type()));\n+      DEBUG_ONLY(set_type_at_tos(bottom_type()));\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  debug_only(VMNativeEntryWrapper __vew;)\n+  DEBUG_ONLY(VMNativeEntryWrapper __vew;)\n@@ -52,1 +52,1 @@\n- * debug_only(NoHandleMark __hm();)         \\\n+ * DEBUG_ONLY(NoHandleMark __hm();)         \\\n@@ -55,1 +55,1 @@\n-  debug_only(VMNativeEntryWrapper __vew;)\n+  DEBUG_ONLY(VMNativeEntryWrapper __vew;)\n","filename":"src\/hotspot\/share\/ci\/ciUtilities.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  debug_only(const u1* const old_current = stream->current();)\n+  DEBUG_ONLY(const u1* const old_current = stream->current();)\n@@ -5529,1 +5529,1 @@\n-  debug_only(ik->verify();)\n+  DEBUG_ONLY(ik->verify();)\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-  _base = os::map_memory(_fd, filename, 0, nullptr, _size, true, false);\n+  _base = os::map_memory(_fd, filename, 0, nullptr, _size, mtNone, true, false);\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -4850,1 +4851,1 @@\n-  debug_only(jint loop_count = 0);\n+  DEBUG_ONLY(jint loop_count = 0);\n@@ -5489,3 +5490,1 @@\n-  if (klass->is_subclass_of(vmClasses::Reference_klass())) {\n-    \/\/ It's problematic to archive Reference objects. One of the reasons is that\n-    \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n+  if (!AOTReferenceObjSupport::is_enabled() && klass->is_subclass_of(vmClasses::Reference_klass())) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -469,3 +469,0 @@\n-    if (EnableVectorSupport && FLAG_IS_DEFAULT(UseVectorStubs)) {\n-      FLAG_SET_DEFAULT(UseVectorStubs, true);\n-    }\n@@ -475,1 +472,0 @@\n-    log_info(compilation)(\"UseVectorStubs=%s\",                 (UseVectorStubs                 ? \"true\" : \"false\"));\n@@ -583,1 +579,1 @@\n-  \/\/ numbered\n+  \/\/ non-numbered\n@@ -586,1 +582,1 @@\n-  \/\/ non-numbered\n+  \/\/ numbered\n@@ -590,0 +586,1 @@\n+  {\"jdk.module.addopens\", true},               \/\/ --add-opens\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1024,1 +1024,2 @@\n-                                      \"Ljava\/lang\/Class;Ljava\/lang\/Class;\"                                                                     \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n@@ -1045,0 +1046,23 @@\n+  do_intrinsic(_VectorUnaryLibOp, jdk_internal_vm_vector_VectorSupport, vector_unary_lib_op_name, vector_unary_lib_op_sig, F_S)                \\\n+   do_signature(vector_unary_lib_op_sig,\"(J\"                                                                                                   \\\n+                                         \"Ljava\/lang\/Class;\"                                                                                   \\\n+                                         \"Ljava\/lang\/Class;\"                                                                                   \\\n+                                         \"I\"                                                                                                   \\\n+                                         \"Ljava\/lang\/String;\"                                                                                  \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                       \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$UnaryOperation;)\"                                              \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                      \\\n+   do_name(vector_unary_lib_op_name, \"libraryUnaryOp\")                                                                                         \\\n+                                                                                                                                               \\\n+  do_intrinsic(_VectorBinaryLibOp, jdk_internal_vm_vector_VectorSupport, vector_binary_lib_op_name, vector_binary_lib_op_sig, F_S)             \\\n+   do_signature(vector_binary_lib_op_sig,\"(J\"                                                                                                  \\\n+                                          \"Ljava\/lang\/Class;\"                                                                                  \\\n+                                          \"Ljava\/lang\/Class;\"                                                                                  \\\n+                                          \"I\"                                                                                                  \\\n+                                          \"Ljava\/lang\/String;\"                                                                                 \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                               \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                               \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$BinaryOperation;)\"                                            \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\")                                              \\\n+   do_name(vector_binary_lib_op_name, \"libraryBinaryOp\")                                                                                       \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -731,1 +731,0 @@\n-  template(createArchivedObjects,                           \"createArchivedObjects\")                              \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  debug_only(_recording_state = rs_null);\n+  DEBUG_ONLY(_recording_state = rs_null);\n@@ -162,1 +162,1 @@\n-  debug_only(_recording_state = rs_safepoint);\n+  DEBUG_ONLY(_recording_state = rs_safepoint);\n@@ -172,1 +172,1 @@\n-  debug_only(_recording_state = rs_non_safepoint);\n+  DEBUG_ONLY(_recording_state = rs_non_safepoint);\n@@ -365,1 +365,1 @@\n-  debug_only(_recording_state = rs_null);\n+  DEBUG_ONLY(_recording_state = rs_null);\n@@ -418,1 +418,1 @@\n-  debug_only(mark_recorders_frozen());  \/\/ mark it \"frozen\" for asserts\n+  DEBUG_ONLY(mark_recorders_frozen());  \/\/ mark it \"frozen\" for asserts\n@@ -424,1 +424,1 @@\n-  debug_only(mark_recorders_frozen());  \/\/ mark it \"frozen\" for asserts\n+  DEBUG_ONLY(mark_recorders_frozen());  \/\/ mark it \"frozen\" for asserts\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1136,1 +1136,1 @@\n-    debug_only(nm->verify();) \/\/ might block\n+    DEBUG_ONLY(nm->verify();) \/\/ might block\n@@ -1287,1 +1287,1 @@\n-  debug_only(Universe::heap()->verify_nmethod(this));\n+  DEBUG_ONLY(Universe::heap()->verify_nmethod(this));\n@@ -1314,1 +1314,1 @@\n-    debug_only(NoSafepointVerifier nsv;)\n+    DEBUG_ONLY(NoSafepointVerifier nsv;)\n@@ -1455,1 +1455,1 @@\n-    debug_only(NoSafepointVerifier nsv;)\n+    DEBUG_ONLY(NoSafepointVerifier nsv;)\n@@ -2823,1 +2823,1 @@\n-  const int LOG2_RADIX = 4 \/*smaller steps in debug mode:*\/ debug_only(-1);\n+  const int LOG2_RADIX = 4 \/*smaller steps in debug mode:*\/ DEBUG_ONLY(-1);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  PcDescCache() { debug_only(_pc_descs[0] = nullptr); }\n+  PcDescCache() { DEBUG_ONLY(_pc_descs[0] = nullptr); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  debug_only(_find_index_calls++);\n+  DEBUG_ONLY(_find_index_calls++);\n@@ -137,1 +137,1 @@\n-      debug_only(_hit_indexes++);\n+      DEBUG_ONLY(_hit_indexes++);\n@@ -154,1 +154,1 @@\n-      debug_only(_missed_indexes++);\n+      DEBUG_ONLY(_missed_indexes++);\n","filename":"src\/hotspot\/share\/code\/oopRecorder.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    debug_only(_value = 0xFFFF);\n+    DEBUG_ONLY(_value = 0xFFFF);\n@@ -345,1 +345,1 @@\n-  debug_only(const CodeBuffer* src0 = src);\n+  DEBUG_ONLY(const CodeBuffer* src0 = src);\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -577,1 +577,1 @@\n-    debug_only(_data = nullptr);\n+    DEBUG_ONLY(_data = nullptr);\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-  debug_only(stub_verify(s);)\n+  DEBUG_ONLY(stub_verify(s);)\n@@ -186,1 +186,1 @@\n-  debug_only(stub_verify(s);)\n+  DEBUG_ONLY(stub_verify(s);)\n@@ -213,1 +213,1 @@\n-  debug_only(verify();)\n+  DEBUG_ONLY(verify();)\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-#ifdef COMPILER2\n+#ifdef COMPILER1\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-  debug_only( _locs_used[reg->value()] = x; )\n+  DEBUG_ONLY( _locs_used[reg->value()] = x; )\n@@ -515,1 +515,1 @@\n-  debug_only(reg_map->_update_for_id = fr->id());\n+  DEBUG_ONLY(reg_map->_update_for_id = fr->id());\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  debug_only( OopMapValue::oop_types* _locs_used; int _locs_length;)\n+  DEBUG_ONLY( OopMapValue::oop_types* _locs_used; int _locs_length;)\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -300,1 +301,1 @@\n-void EpsilonHeap::print_on(outputStream *st) const {\n+void EpsilonHeap::print_heap_on(outputStream *st) const {\n@@ -303,0 +304,2 @@\n+  StreamAutoIndentor indentor(st, 1);\n+\n@@ -307,9 +310,0 @@\n-    _space->print_on(st);\n-  }\n-\n-  MetaspaceUtils::print_on(st);\n-}\n-\n-void EpsilonHeap::print_on_error(outputStream *st) const {\n-  print_on(st);\n-  st->cr();\n@@ -317,3 +311,2 @@\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  if (bs != nullptr) {\n-    bs->print_on(st);\n+    StreamAutoIndentor indentor(st, 1);\n+    _space->print_on(st, \"\");\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -134,2 +134,2 @@\n-  void print_on(outputStream* st) const override;\n-  void print_on_error(outputStream* st) const override;\n+  void print_heap_on(outputStream* st) const override;\n+  void print_gc_on(outputStream* st) const override {}\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+  if (FLAG_IS_DEFAULT(G1HeapRegionSize)) {\n+    return G1HeapRegion::max_ergonomics_size();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1233,1 +1233,2 @@\n-                                             preferred_page_size);\n+                                             preferred_page_size,\n+                                             mtGC);\n@@ -2115,1 +2116,1 @@\n-void G1CollectedHeap::print_on(outputStream* st) const {\n+void G1CollectedHeap::print_heap_on(outputStream* st) const {\n@@ -2117,1 +2118,1 @@\n-  st->print(\" %-20s\", \"garbage-first heap\");\n+  st->print(\"%-20s\", \"garbage-first heap\");\n@@ -2124,1 +2125,3 @@\n-  st->print(\"  region size %zuK, \", G1HeapRegion::GrainBytes \/ K);\n+\n+  StreamAutoIndentor indentor(st, 1);\n+  st->print(\"region size %zuK, \", G1HeapRegion::GrainBytes \/ K);\n@@ -2134,1 +2137,1 @@\n-    st->print(\"  remaining free region(s) on each NUMA node: \");\n+    st->print(\"remaining free region(s) on each NUMA node: \");\n@@ -2142,1 +2145,0 @@\n-  MetaspaceUtils::print_on(st);\n@@ -2156,1 +2158,1 @@\n-  print_on(st);\n+  print_heap_on(st);\n@@ -2163,2 +2165,3 @@\n-void G1CollectedHeap::print_on_error(outputStream* st) const {\n-  print_extended_on(st);\n+void G1CollectedHeap::print_gc_on(outputStream* st) const {\n+  \/\/ Print the per-region information.\n+  print_regions_on(st);\n@@ -2174,1 +2177,1 @@\n-    _cm->print_on_error(st);\n+    _cm->print_on(st);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1315,1 +1315,1 @@\n-  void print_on(outputStream* st) const override;\n+  void print_heap_on(outputStream* st) const override;\n@@ -1317,1 +1317,1 @@\n-  void print_on_error(outputStream* st) const override;\n+  void print_gc_on(outputStream* st) const override;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2129,1 +2129,1 @@\n-void G1ConcurrentMark::print_on_error(outputStream* st) const {\n+void G1ConcurrentMark::print_on(outputStream* st) const {\n@@ -2131,1 +2131,1 @@\n-  _mark_bitmap.print_on_error(st, \" Bits: \");\n+  _mark_bitmap.print_on(st, \" Bits: \");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -710,1 +710,1 @@\n-  void print_on_error(outputStream* st) const;\n+  void print_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,0 +60,4 @@\n+size_t G1HeapRegion::max_ergonomics_size() {\n+  return G1HeapRegionBounds::max_ergonomics_size();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -319,0 +319,1 @@\n+  static size_t max_ergonomics_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -611,2 +611,4 @@\n-void MutableNUMASpace::print_on(outputStream* st) const {\n-  MutableSpace::print_on(st);\n+void MutableNUMASpace::print_on(outputStream* st, const char* prefix) const {\n+  MutableSpace::print_on(st, prefix);\n+\n+  StreamAutoIndentor indentor(st, 1);\n@@ -615,2 +617,2 @@\n-    st->print(\"    lgrp %u\", ls->lgrp_id());\n-    ls->space()->print_on(st);\n+    FormatBuffer<128> lgrp_message(\"lgrp %u \", ls->lgrp_id());\n+    ls->space()->print_on(st, lgrp_message);\n@@ -618,0 +620,1 @@\n+      StreamAutoIndentor indentor_numa(st, 1);\n@@ -621,1 +624,1 @@\n-      st->print(\"    local\/remote\/unbiased\/uncommitted: %zuK\/\"\n+      st->print(\"local\/remote\/unbiased\/uncommitted: %zuK\/\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,1 +189,1 @@\n-  virtual void print_on(outputStream* st) const;\n+  virtual void print_on(outputStream* st, const char* prefix) const;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-  st->print(\" space %zuK, %d%% used\", capacity_in_bytes() \/ K,\n+  st->print(\"space %zuK, %d%% used\", capacity_in_bytes() \/ K,\n@@ -239,2 +239,3 @@\n-void MutableSpace::print() const { print_on(tty); }\n-void MutableSpace::print_on(outputStream* st) const {\n+void MutableSpace::print() const { print_on(tty, \"\"); }\n+void MutableSpace::print_on(outputStream* st, const char* prefix) const {\n+  st->print(\"%s\", prefix);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-  virtual void print_on(outputStream* st) const;\n+  virtual void print_on(outputStream* st, const char* prefix) const;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  debug_only(verify_for_block(blk_start, blk_end);)\n+  DEBUG_ONLY(verify_for_block(blk_start, blk_end);)\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,2 @@\n-                                             page_sz);\n+                                             page_sz,\n+                                             mtGC);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-  void print_on_error(outputStream* st) const {\n+  void print_on(outputStream* st) const {\n@@ -63,1 +63,3 @@\n-    _beg_bits.print_on_error(st, \" Begin Bits: \");\n+\n+    StreamAutoIndentor indentor(st, 1);\n+    _beg_bits.print_range_on(st, \"Begin Bits: \");\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -665,1 +665,1 @@\n-void ParallelScavengeHeap::print_on(outputStream* st) const {\n+void ParallelScavengeHeap::print_heap_on(outputStream* st) const {\n@@ -672,1 +672,0 @@\n-  MetaspaceUtils::print_on(st);\n@@ -675,4 +674,1 @@\n-void ParallelScavengeHeap::print_on_error(outputStream* st) const {\n-  print_on(st);\n-  st->cr();\n-\n+void ParallelScavengeHeap::print_gc_on(outputStream* st) const {\n@@ -683,1 +679,0 @@\n-\n@@ -685,1 +680,2 @@\n-  PSParallelCompact::print_on_error(st);\n+\n+  PSParallelCompact::print_on(st);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,2 +217,2 @@\n-  void print_on(outputStream* st) const override;\n-  void print_on_error(outputStream* st) const override;\n+  void print_heap_on(outputStream* st) const override;\n+  void print_gc_on(outputStream* st) const override;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -361,9 +361,6 @@\n-  st->print(\" %-15s\", name());\n-  st->print(\" total %zuK, used %zuK\",\n-              capacity_in_bytes()\/K, used_in_bytes()\/K);\n-  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-                p2i(virtual_space()->low_boundary()),\n-                p2i(virtual_space()->high()),\n-                p2i(virtual_space()->high_boundary()));\n-\n-  st->print(\"  object\"); object_space()->print_on(st);\n+  st->print(\"%-15s\", name());\n+  st->print(\" total %zuK, used %zuK \", capacity_in_bytes() \/ K, used_in_bytes() \/ K);\n+  virtual_space()->print_space_boundaries_on(st);\n+\n+  StreamAutoIndentor indentor(st, 1);\n+  object_space()->print_on(st, \"object \");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -214,2 +214,2 @@\n-void PSParallelCompact::print_on_error(outputStream* st) {\n-  _mark_bitmap.print_on_error(st);\n+void PSParallelCompact::print_on(outputStream* st) {\n+  _mark_bitmap.print_on(st);\n@@ -250,1 +250,2 @@\n-                                             page_sz);\n+                                             page_sz,\n+                                             mtGC);\n@@ -1633,1 +1634,1 @@\n-  debug_only(verify_forward();)\n+  DEBUG_ONLY(verify_forward();)\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -849,1 +849,1 @@\n-  static void print_on_error(outputStream* st);\n+  static void print_on(outputStream* st);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-      debug_only(Copy::fill_to_words(top(), free()\/HeapWordSize, badHeapWord));\n+      DEBUG_ONLY(Copy::fill_to_words(top(), free()\/HeapWordSize, badHeapWord));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  debug_only(virtual bool lab_is_valid(MemRegion lab) { return false; });\n+  DEBUG_ONLY(virtual bool lab_is_valid(MemRegion lab) { return false; });\n@@ -98,1 +98,1 @@\n-  debug_only(virtual bool lab_is_valid(MemRegion lab);)\n+  DEBUG_ONLY(virtual bool lab_is_valid(MemRegion lab);)\n@@ -130,1 +130,1 @@\n-  debug_only(virtual bool lab_is_valid(MemRegion lab));\n+  DEBUG_ONLY(virtual bool lab_is_valid(MemRegion lab));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+  st->print_cr(\"[\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -703,3 +703,2 @@\n-  st->print(\" %-15s\", \"PSYoungGen\");\n-  st->print(\" total %zuK, used %zuK\",\n-             capacity_in_bytes()\/K, used_in_bytes()\/K);\n+  st->print(\"%-15s\", name());\n+  st->print(\" total %zuK, used %zuK \", capacity_in_bytes() \/ K, used_in_bytes() \/ K);\n@@ -707,3 +706,5 @@\n-  st->print(\"  eden\"); eden_space()->print_on(st);\n-  st->print(\"  from\"); from_space()->print_on(st);\n-  st->print(\"  to  \"); to_space()->print_on(st);\n+\n+  StreamAutoIndentor indentor(st, 1);\n+  eden_space()->print_on(st, \"eden \");\n+  from_space()->print_on(st, \"from \");\n+  to_space()->print_on(st, \"to   \");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -828,15 +828,9 @@\n-  st->print(\" %-10s\", name());\n-\n-  st->print(\" total %zuK, used %zuK\",\n-            capacity()\/K, used()\/K);\n-  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-               p2i(_virtual_space.low_boundary()),\n-               p2i(_virtual_space.high()),\n-               p2i(_virtual_space.high_boundary()));\n-\n-  st->print(\"  eden\");\n-  eden()->print_on(st);\n-  st->print(\"  from\");\n-  from()->print_on(st);\n-  st->print(\"  to  \");\n-  to()->print_on(st);\n+  st->print(\"%-10s\", name());\n+\n+  st->print(\" total %zuK, used %zuK \", capacity() \/ K, used() \/ K);\n+  _virtual_space.print_space_boundaries_on(st);\n+\n+  StreamAutoIndentor indentor(st, 1);\n+  eden()->print_on(st, \"eden \");\n+  from()->print_on(st, \"from \");\n+  to()->print_on(st, \"to   \");\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-  debug_only(verify_for_block(blk_start, blk_end);)\n+  DEBUG_ONLY(verify_for_block(blk_start, blk_end);)\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -803,1 +803,1 @@\n-void SerialHeap::print_on(outputStream* st) const {\n+void SerialHeap::print_heap_on(outputStream* st) const {\n@@ -809,2 +809,0 @@\n-\n-  MetaspaceUtils::print_on(st);\n@@ -813,4 +811,1 @@\n-void SerialHeap::print_on_error(outputStream* st) const {\n-  print_on(st);\n-  st->cr();\n-\n+void SerialHeap::print_gc_on(outputStream* st) const {\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -209,2 +209,2 @@\n-  void print_on(outputStream* st) const override;\n-  void print_on_error(outputStream* st) const override;\n+  void print_heap_on(outputStream* st) const override;\n+  void print_gc_on(outputStream* st) const override;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-  st->print(\" %-10s\", name());\n+  st->print(\"%-10s\", name());\n@@ -444,1 +444,1 @@\n-  st->print(\" total %zuK, used %zuK\",\n+  st->print(\" total %zuK, used %zuK \",\n@@ -446,4 +446,1 @@\n-  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-               p2i(_virtual_space.low_boundary()),\n-               p2i(_virtual_space.high()),\n-               p2i(_virtual_space.high_boundary()));\n+  _virtual_space.print_space_boundaries_on(st);\n@@ -451,2 +448,2 @@\n-  st->print(\"   the\");\n-  _the_space->print_on(st);\n+  StreamAutoIndentor indentor(st, 1);\n+  _the_space->print_on(st, \"the  \");\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  ReservedSpace rs = MemoryReserver::reserve(_byte_map_size, rs_align, _page_size);\n+  ReservedSpace rs = MemoryReserver::reserve(_byte_map_size, rs_align, _page_size, mtGC);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"memory\/resourceArea.hpp\"\n@@ -62,0 +61,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -114,1 +114,6 @@\n-  heap->print_on(&st);\n+  {\n+    StreamAutoIndentor indentor(&st, 1);\n+    heap->print_heap_on(&st);\n+    MetaspaceUtils::print_on(&st);\n+  }\n+\n@@ -166,2 +171,4 @@\n-    ResourceMark rm;\n-    print_on(&ls);\n+\n+    StreamAutoIndentor indentor(&ls, 1);\n+    print_heap_on(&ls);\n+    MetaspaceUtils::print_on(&ls);\n@@ -180,2 +187,4 @@\n-    ResourceMark rm;\n-    print_on(&ls);\n+\n+    StreamAutoIndentor indentor(&ls, 1);\n+    print_heap_on(&ls);\n+    MetaspaceUtils::print_on(&ls);\n@@ -189,1 +198,4 @@\n-void CollectedHeap::print() const { print_on(tty); }\n+void CollectedHeap::print() const {\n+  print_heap_on(tty);\n+  print_gc_on(tty);\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-  debug_only(static void check_for_valid_allocation_state();)\n+  DEBUG_ONLY(static void check_for_valid_allocation_state();)\n@@ -439,4 +439,5 @@\n-  \/\/ Print heap information on the given outputStream.\n-  virtual void print_on(outputStream* st) const = 0;\n-  \/\/ The default behavior is to call print_on() on tty.\n-  virtual void print() const;\n+  \/\/ Print heap information.\n+  virtual void print_heap_on(outputStream* st) const = 0;\n+\n+  \/\/ Print additional information about the GC that is not included in print_heap_on().\n+  virtual void print_gc_on(outputStream* st) const = 0;\n@@ -444,1 +445,2 @@\n-  virtual void print_on_error(outputStream* st) const = 0;\n+  \/\/ The default behavior is to call print_heap_on() and print_gc_on() on tty.\n+  virtual void print() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-debug_only(\n+DEBUG_ONLY(\n","filename":"src\/hotspot\/share\/gc\/shared\/hSpaceCounters.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  debug_only(\n+  DEBUG_ONLY(\n","filename":"src\/hotspot\/share\/gc\/shared\/hSpaceCounters.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-void MarkBitMap::print_on_error(outputStream* st, const char* prefix) const {\n-  _bm.print_on_error(st, prefix);\n+void MarkBitMap::print_on(outputStream* st, const char* prefix) const {\n+  _bm.print_range_on(st, prefix);\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  void print_on_error(outputStream* st, const char* prefix) const;\n+  void print_on(outputStream* st, const char* prefix) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,0 +129,4 @@\n+#ifdef CHECK_UNHANDLED_OOPS\n+      \/\/ obj is null, no need to handle, but CheckUnhandledOops is not aware about null\n+      THREAD->allow_unhandled_oop(_obj_ptr);\n+#endif \/\/ CHECK_UNHANDLED_OOPS\n@@ -148,1 +152,1 @@\n-  debug_only(check_for_valid_allocation_state());\n+  DEBUG_ONLY(check_for_valid_allocation_state());\n@@ -330,1 +334,1 @@\n-  debug_only(allocation._thread->check_for_valid_safepoint_state());\n+  DEBUG_ONLY(allocation._thread->check_for_valid_safepoint_state());\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  debug_only(mark_on_list_nmethods());\n+  DEBUG_ONLY(mark_on_list_nmethods());\n@@ -140,1 +140,1 @@\n-    debug_only(data.clear_marked());\n+    DEBUG_ONLY(data.clear_marked());\n@@ -159,1 +159,1 @@\n-  debug_only(verify_nmethods());\n+  DEBUG_ONLY(verify_nmethods());\n@@ -169,1 +169,1 @@\n-  debug_only(mark_on_list_nmethods());\n+  DEBUG_ONLY(mark_on_list_nmethods());\n@@ -175,1 +175,1 @@\n-    debug_only(data.clear_marked());\n+    DEBUG_ONLY(data.clear_marked());\n@@ -190,1 +190,1 @@\n-  debug_only(verify_nmethods());\n+  DEBUG_ONLY(verify_nmethods());\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-void ContiguousSpace::print() const { print_on(tty); }\n+void ContiguousSpace::print() const { print_on(tty, \"\"); }\n@@ -81,2 +81,3 @@\n-void ContiguousSpace::print_on(outputStream* st) const {\n-  st->print_cr(\" space %zuK, %3d%% used [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+void ContiguousSpace::print_on(outputStream* st, const char* prefix) const {\n+  st->print_cr(\"%sspace %zuK, %3d%% used [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+               prefix,\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-  void print_on(outputStream* st) const;\n+  void print_on(outputStream* st, const char* prefix) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -899,1 +899,1 @@\n-    debug_only(gc_state_adr_type = phase->C->get_adr_type(gc_state_idx));\n+    DEBUG_ONLY(gc_state_adr_type = phase->C->get_adr_type(gc_state_idx));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -642,6 +642,3 @@\n-  if (_old_generation->is_doing_mixed_evacuations()) {\n-    \/\/ Do not try to start an old cycle if we are waiting for old regions to be evacuated (we need\n-    \/\/ a young cycle for this). Note that the young heuristic has a feature to expedite old evacuations.\n-    \/\/ Future refinement: under certain circumstances, we might be more sophisticated about this choice.\n-    \/\/ For example, we could choose to abandon the previous old collection before it has completed evacuations.\n-    log_debug(gc)(\"Not starting an old cycle because we are waiting for mixed evacuations\");\n+  if (!_old_generation->is_idle()) {\n+    \/\/ Do not try to start an old cycle if old-gen is marking, doing mixed evacuations, or coalescing and filling.\n+    log_debug(gc)(\"Not starting an old cycle because old gen is busy\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+        log_debug(gc)(\"Young heuristics declines to trigger because old_time_elapsed < ShenandoahMinimumOldTimeMs\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  ReservedSpace write_space = MemoryReserver::reserve(_byte_map_size, rs_align, _page_size);\n+  ReservedSpace write_space = MemoryReserver::reserve(_byte_map_size, rs_align, _page_size, mtGC);\n@@ -63,1 +63,1 @@\n-  ReservedSpace read_space = MemoryReserver::reserve(_byte_map_size, rs_align, _page_size);\n+  ReservedSpace read_space = MemoryReserver::reserve(_byte_map_size, rs_align, _page_size, mtGC);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-  debug_only(size_t regions = 0;)\n+  DEBUG_ONLY(size_t regions = 0;)\n@@ -197,1 +197,1 @@\n-      debug_only(regions ++;)\n+      DEBUG_ONLY(regions ++;)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -302,1 +302,4 @@\n-  if (check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle)) return;\n+  if (check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle)) {\n+    log_info(gc)(\"Cancelled\");\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -485,11 +485,8 @@\n-    \/\/ It's possible the gc cycle was cancelled after the last time\n-    \/\/ the collection checked for cancellation. In which case, the\n-    \/\/ old gc cycle is still completed, and we have to deal with this\n-    \/\/ cancellation. We set the degeneration point to be outside\n-    \/\/ the cycle because if this is an allocation failure, that is\n-    \/\/ what must be done (there is no degenerated old cycle). If the\n-    \/\/ cancellation was due to a heuristic wanting to start a young\n-    \/\/ cycle, then we are not actually going to a degenerated cycle,\n-    \/\/ so the degenerated point doesn't matter here.\n-    check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle);\n-    if (cause == GCCause::_shenandoah_concurrent_gc) {\n+    \/\/ It's possible the gc cycle was cancelled after the last time the collection checked for cancellation. In which\n+    \/\/ case, the old gc cycle is still completed, and we have to deal with this cancellation. We set the degeneration\n+    \/\/ point to be outside the cycle because if this is an allocation failure, that is what must be done (there is no\n+    \/\/ degenerated old cycle). If the cancellation was due to a heuristic wanting to start a young cycle, then we are\n+    \/\/ not actually going to a degenerated cycle, so don't set the degeneration point here.\n+    if (ShenandoahCollectorPolicy::is_allocation_failure(cause)) {\n+      check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle);\n+    } else if (cause == GCCause::_shenandoah_concurrent_gc) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-  const ReservedSpace reserved = MemoryReserver::reserve(size, alignment, preferred_page_size);\n+  const ReservedSpace reserved = MemoryReserver::reserve(size, alignment, preferred_page_size, mtGC);\n@@ -378,1 +378,1 @@\n-      cset_rs = MemoryReserver::reserve(req_addr, cset_size, cset_align, cset_page_size);\n+      cset_rs = MemoryReserver::reserve(req_addr, cset_size, cset_align, cset_page_size, mtGC);\n@@ -387,1 +387,1 @@\n-      cset_rs = MemoryReserver::reserve(cset_size, cset_align, os::vm_page_size());\n+      cset_rs = MemoryReserver::reserve(cset_size, cset_align, os::vm_page_size(), mtGC);\n@@ -586,1 +586,1 @@\n-void ShenandoahHeap::print_on(outputStream* st) const {\n+void ShenandoahHeap::print_heap_on(outputStream* st) const {\n@@ -637,1 +637,0 @@\n-  MetaspaceUtils::print_on(st);\n@@ -645,3 +644,1 @@\n-void ShenandoahHeap::print_on_error(outputStream* st) const {\n-  print_on(st);\n-  st->cr();\n+void ShenandoahHeap::print_gc_on(outputStream* st) const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -205,2 +205,2 @@\n-  void print_on(outputStream* st)              const override;\n-  void print_on_error(outputStream *st)        const override;\n+  void print_heap_on(outputStream* st)         const override;\n+  void print_gc_on(outputStream *st)           const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,12 +70,1 @@\n-        if (_young_heuristics->should_start_gc()) {\n-          \/\/ Give the old generation a chance to run. The old generation cycle\n-          \/\/ begins with a 'bootstrap' cycle that will also collect young.\n-          if (start_old_cycle()) {\n-            log_debug(gc)(\"Heuristics request for old collection accepted\");\n-            _young_heuristics->cancel_trigger_request();\n-            _old_heuristics->cancel_trigger_request();\n-          } else if (request_concurrent_gc(_heap->young_generation())) {\n-            log_debug(gc)(\"Heuristics request for young collection accepted\");\n-            _young_heuristics->cancel_trigger_request();\n-          }\n-        } else if (_old_heuristics->should_resume_old_cycle() || _old_heuristics->should_start_gc()) {\n+        if (_old_heuristics->should_resume_old_cycle()) {\n@@ -86,0 +75,7 @@\n+        } else if (start_old_cycle()) {\n+          log_debug(gc)(\"Heuristics request for old collection accepted\");\n+          _young_heuristics->cancel_trigger_request();\n+          _old_heuristics->cancel_trigger_request();\n+        } else if (start_young_cycle()) {\n+          log_debug(gc)(\"Heuristics request for young collection accepted\");\n+          _young_heuristics->cancel_trigger_request();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-  debug_only(uint   _reserved;  )\n+  DEBUG_ONLY(uint   _reserved;  )\n@@ -319,1 +319,1 @@\n-    debug_only(_reserved = 0; )\n+    DEBUG_ONLY(_reserved = 0; )\n@@ -329,1 +329,1 @@\n-    debug_only(_reserved = n;)\n+    DEBUG_ONLY(_reserved = n;)\n@@ -332,1 +332,1 @@\n-  debug_only(uint get_reserved() const { return (uint)_reserved; })\n+  DEBUG_ONLY(uint get_reserved() const { return (uint)_reserved; })\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -358,4 +358,2 @@\n-void ZCollectedHeap::print_on(outputStream* st) const {\n-  StreamAutoIndentor auto_indentor(st);\n-\n-  _heap.print_on(st);\n+void ZCollectedHeap::print_heap_on(outputStream* st) const {\n+  _heap.print_usage_on(st);\n@@ -364,4 +362,2 @@\n-void ZCollectedHeap::print_on_error(outputStream* st) const {\n-  StreamAutoIndentor auto_indentor(st);\n-\n-  _heap.print_on_error(st);\n+void ZCollectedHeap::print_gc_on(outputStream* st) const {\n+  _heap.print_gc_on(st);\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-  void print_on(outputStream* st) const override;\n-  void print_on_error(outputStream* st) const override;\n+  void print_heap_on(outputStream* st) const override;\n+  void print_gc_on(outputStream* st) const override;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -317,7 +317,2 @@\n-void ZHeap::print_on(outputStream* st) const {\n-  streamIndentor indentor(st, 1);\n-  _page_allocator.print_on(st);\n-\n-  \/\/ Metaspace printing prepends spaces instead of using outputStream indentation\n-  streamIndentor indentor_back(st, -1);\n-  MetaspaceUtils::print_on(st);\n+void ZHeap::print_usage_on(outputStream* st) const {\n+  _page_allocator.print_usage_on(st);\n@@ -326,11 +321,1 @@\n-void ZHeap::print_on_error(outputStream* st) const {\n-  {\n-    streamIndentor indentor(st, 1);\n-    _page_allocator.print_on_error(st);\n-\n-    \/\/ Metaspace printing prepends spaces instead of using outputStream indentation\n-    streamIndentor indentor_back(st, -1);\n-    MetaspaceUtils::print_on(st);\n-  }\n-  st->cr();\n-\n+void ZHeap::print_gc_on(outputStream* st) const {\n@@ -343,1 +328,1 @@\n-  _page_allocator.print_extended_on_error(st);\n+  _page_allocator.print_cache_extended_on(st);\n@@ -376,6 +361,6 @@\n-  {\n-    streamIndentor indentor(st, 1);\n-    ZPageTableIterator iter(&_page_table);\n-    for (ZPage* page; iter.next(&page);) {\n-      page->print_on(st);\n-    }\n+\n+  StreamAutoIndentor indentor(st, 1);\n+\n+  ZPageTableIterator iter(&_page_table);\n+  for (ZPage* page; iter.next(&page);) {\n+    page->print_on(st);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -133,2 +133,2 @@\n-  void print_on(outputStream* st) const;\n-  void print_on_error(outputStream* st) const;\n+  void print_usage_on(outputStream* st) const;\n+  void print_gc_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -578,1 +579,1 @@\n-  st->print(\"Cache\");\n+  st->print(\"Cache \");\n@@ -594,1 +595,1 @@\n-  streamIndentor indentor(st, 1);\n+  StreamAutoIndentor indentor(st, 1);\n@@ -596,1 +597,1 @@\n-  st->print(\"size classes\");\n+  st->print(\"size classes \");\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1158,1 +1158,1 @@\n-  st->print(\"Partition %u\", _numa_id);\n+  st->print(\"Partition %u \", _numa_id);\n@@ -1163,1 +1163,1 @@\n-  streamIndentor indentor(st, 1);\n+  StreamAutoIndentor indentor(st, 1);\n@@ -1171,1 +1171,1 @@\n-void ZPartition::print_extended_on_error(outputStream* st) const {\n+void ZPartition::print_cache_extended_on(outputStream* st) const {\n@@ -1174,2 +1174,1 @@\n-  streamIndentor indentor(st, 1);\n-\n+  StreamAutoIndentor indentor(st, 1);\n@@ -2397,5 +2396,0 @@\n-void ZPageAllocator::print_on(outputStream* st) const {\n-  ZLocker<ZLock> lock(&_lock);\n-  print_on_inner(st);\n-}\n-\n@@ -2412,24 +2406,1 @@\n-void ZPageAllocator::print_extended_on_error(outputStream* st) const {\n-  st->print_cr(\"ZMappedCache:\");\n-\n-  streamIndentor indentor(st, 1);\n-\n-  if (!try_lock_on_error(&_lock)) {\n-    \/\/ We can't print without taking the lock since printing the contents of\n-    \/\/ the cache requires iterating over the nodes in the cache's tree, which\n-    \/\/ is not thread-safe.\n-    st->print_cr(\"<Skipped>\");\n-\n-    return;\n-  }\n-\n-  \/\/ Print each partition's cache content\n-  ZPartitionConstIterator iter = partition_iterator();\n-  for (const ZPartition* partition; iter.next(&partition);) {\n-    partition->print_extended_on_error(st);\n-  }\n-\n-  _lock.unlock();\n-}\n-\n-void ZPageAllocator::print_on_error(outputStream* st) const {\n+void ZPageAllocator::print_usage_on(outputStream* st) const {\n@@ -2442,1 +2413,1 @@\n-  \/\/ Print information even though we have not successfully taken the lock.\n+  \/\/ Print information even though we may not have successfully taken the lock.\n@@ -2444,1 +2415,5 @@\n-  print_on_inner(st);\n+\n+  print_total_usage_on(st);\n+\n+  StreamAutoIndentor indentor(st, 1);\n+  print_partition_usage_on(st);\n@@ -2451,3 +2426,2 @@\n-void ZPageAllocator::print_on_inner(outputStream* st) const {\n-  \/\/ Print total usage\n-  st->print(\"ZHeap\");\n+void ZPageAllocator::print_total_usage_on(outputStream* st) const {\n+  st->print(\"ZHeap \");\n@@ -2457,0 +2431,1 @@\n+}\n@@ -2458,4 +2433,1 @@\n-  \/\/ Print per-partition\n-\n-  streamIndentor indentor(st, 1);\n-\n+void ZPageAllocator::print_partition_usage_on(outputStream* st) const {\n@@ -2463,1 +2435,2 @@\n-    \/\/ The summary printing is redundant if we only have one partition\n+    \/\/ Partition usage is redundant if we only have one partition. Only\n+    \/\/ print the cache.\n@@ -2468,0 +2441,1 @@\n+  \/\/ Print all partitions\n@@ -2473,0 +2447,23 @@\n+\n+void ZPageAllocator::print_cache_extended_on(outputStream* st) const {\n+  st->print_cr(\"ZMappedCache:\");\n+\n+  StreamAutoIndentor indentor(st, 1);\n+\n+  if (!try_lock_on_error(&_lock)) {\n+    \/\/ We can't print without taking the lock since printing the contents of\n+    \/\/ the cache requires iterating over the nodes in the cache's tree, which\n+    \/\/ is not thread-safe.\n+    st->print_cr(\"<Skipped>\");\n+\n+    return;\n+  }\n+\n+  \/\/ Print each partition's cache content\n+  ZPartitionConstIterator iter = partition_iterator();\n+  for (const ZPartition* partition; iter.next(&partition);) {\n+    partition->print_cache_extended_on(st);\n+  }\n+\n+  _lock.unlock();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":41,"deletions":44,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  void print_extended_on_error(outputStream* st) const;\n+  void print_cache_extended_on(outputStream* st) const;\n@@ -241,2 +241,0 @@\n-  void print_on_inner(outputStream* st) const;\n-\n@@ -288,3 +286,4 @@\n-  void print_on(outputStream* st) const;\n-  void print_extended_on_error(outputStream* st) const;\n-  void print_on_error(outputStream* st) const;\n+  void print_usage_on(outputStream* st) const;\n+  void print_total_usage_on(outputStream* st) const;\n+  void print_partition_usage_on(outputStream* st) const;\n+  void print_cache_extended_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-    debug_only(_bit_mask[0] = 0;)\n+    DEBUG_ONLY(_bit_mask[0] = 0;)\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-  debug_only(const u1 current_epoch = JfrTraceIdEpoch::current();)\n+  DEBUG_ONLY(const u1 current_epoch = JfrTraceIdEpoch::current();)\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -401,1 +401,1 @@\n-  debug_only(assert_flush_precondition(cur, used, native, t);)\n+  DEBUG_ONLY(assert_flush_precondition(cur, used, native, t);)\n@@ -410,1 +410,1 @@\n-  debug_only(assert_flush_regular_precondition(cur, cur_pos, used, req, t);)\n+  DEBUG_ONLY(assert_flush_regular_precondition(cur, cur_pos, used, req, t);)\n@@ -453,1 +453,1 @@\n-  debug_only(assert_flush_large_precondition(cur, cur_pos, used, req, native, t);)\n+  DEBUG_ONLY(assert_flush_large_precondition(cur, cur_pos, used, req, native, t);)\n@@ -483,1 +483,1 @@\n-  debug_only(assert_provision_large_precondition(cur, used, req, t);)\n+  DEBUG_ONLY(assert_provision_large_precondition(cur, used, req, t);)\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorage.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -109,1 +109,2 @@\n-                                os::vm_page_size());\n+                                os::vm_page_size(),\n+                                mtTracing);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrVirtualMemory.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  debug_only(add(alloc_size));\n+  DEBUG_ONLY(add(alloc_size));\n@@ -114,1 +114,1 @@\n-  debug_only(hook_memory_deallocation(size);)\n+  DEBUG_ONLY(hook_memory_deallocation(size);)\n@@ -119,1 +119,1 @@\n-  debug_only(hook_memory_deallocation(size);)\n+  DEBUG_ONLY(hook_memory_deallocation(size);)\n@@ -130,1 +130,1 @@\n-  debug_only(hook_memory_deallocation(size);)\n+  DEBUG_ONLY(hook_memory_deallocation(size);)\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrAllocation.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  debug_only(validate_count_param(node, count);)\n+  DEBUG_ONLY(validate_count_param(node, count);)\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrDoublyLinkedList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,5 +36,1 @@\n-    Thread::SpinAcquire(_lock, nullptr);\n-  }\n-\n-  JfrSpinlockHelper(volatile int* const lock, const char* name) : _lock(lock) {\n-    Thread::SpinAcquire(_lock, name);\n+    Thread::SpinAcquire(_lock);\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSpinlockHelper.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  debug_only(AccessAssert _access;)\n+  DEBUG_ONLY(AccessAssert _access;)\n@@ -56,1 +56,1 @@\n-  debug_only(bool is_acquired() const;)\n+  DEBUG_ONLY(bool is_acquired() const;)\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrMemoryWriterHost.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  debug_only(_access.acquire();)\n+  DEBUG_ONLY(_access.acquire();)\n@@ -59,1 +59,1 @@\n-  debug_only(is_acquired();)\n+  DEBUG_ONLY(is_acquired();)\n@@ -64,1 +64,1 @@\n-  debug_only(is_acquired();)\n+  DEBUG_ONLY(is_acquired();)\n@@ -66,1 +66,1 @@\n-  debug_only(_access.release();)\n+  DEBUG_ONLY(_access.release();)\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrMemoryWriterHost.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  debug_only(VMNativeEntryWrapper __vew;)\n+  DEBUG_ONLY(VMNativeEntryWrapper __vew;)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -615,1 +616,1 @@\n-    ALLOW_C_FUNCTION(::free, ::free((void*) _init_error_msg);)\n+    permit_forbidden_function::free((void*)_init_error_msg);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -147,1 +147,0 @@\n-  JVMCI_FLAG_CHECKED(UseVectorStubs)\n@@ -149,0 +148,2 @@\n+       \/\/\n+  JVMCI_FLAG_CHECKED(UseVectorStubs)\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -187,2 +187,2 @@\n-  NOT_COMPILER2(product(bool, UseVectorStubs, false, EXPERIMENTAL,          \\\n-          \"Use stubs for vector transcendental operations\"))                \\\n+  product(bool, UseVectorStubs, false, EXPERIMENTAL,                        \\\n+          \"Use stubs for vector transcendental operations\")                 \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  debug_only(static intx _locking_thread_id;)\n+  DEBUG_ONLY(static intx _locking_thread_id;)\n@@ -66,1 +66,1 @@\n-    debug_only(_locking_thread_id = os::current_thread_id());\n+    DEBUG_ONLY(_locking_thread_id = os::current_thread_id());\n@@ -69,1 +69,1 @@\n-    debug_only(_locking_thread_id = -1);\n+    DEBUG_ONLY(_locking_thread_id = -1);\n@@ -72,1 +72,1 @@\n-  debug_only(static bool current_thread_has_lock();)\n+  DEBUG_ONLY(static bool current_thread_has_lock();)\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -152,1 +153,1 @@\n-    ALLOW_C_FUNCTION(::malloc, char* newbuf = (char*)::malloc(newbuf_len * sizeof(char));)\n+    char* newbuf = (char*)permit_forbidden_function::malloc(newbuf_len * sizeof(char));\n@@ -162,1 +163,1 @@\n-      ALLOW_C_FUNCTION(::free, ::free(newbuf);)\n+      permit_forbidden_function::free(newbuf);\n","filename":"src\/hotspot\/share\/logging\/logTagSet.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  char* addr = os::reserve_memory(size, !ExecMem, mem_tag);\n+  char* addr = os::reserve_memory(size, mem_tag);\n@@ -78,1 +78,1 @@\n-  char* addr = os::reserve_memory(size, !ExecMem, mem_tag);\n+  char* addr = os::reserve_memory(size, mem_tag);\n","filename":"src\/hotspot\/share\/memory\/allocation.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    return os::attempt_reserve_memory_at(requested_address, size, exec, mem_tag);\n+    return os::attempt_reserve_memory_at(requested_address, size, mem_tag, exec);\n@@ -99,1 +99,1 @@\n-  char* base = os::reserve_memory(size, exec, mem_tag);\n+  char* base = os::reserve_memory(size, mem_tag, exec);\n@@ -110,1 +110,1 @@\n-  return os::reserve_memory_aligned(size, alignment, exec);\n+  return os::reserve_memory_aligned(size, alignment, mem_tag, exec);\n@@ -264,1 +264,1 @@\n-  char* base = os::map_memory_to_file(size, fd);\n+  char* base = os::map_memory_to_file(size, fd, mem_tag);\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                               MemTag mem_tag = mtNone);\n+                               MemTag mem_tag);\n@@ -66,1 +66,1 @@\n-                               MemTag mem_tag = mtNone);\n+                               MemTag mem_tag);\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -217,1 +218,1 @@\n-  \/\/ Used from all GCs. It first prints out totals, then, separately, the class space portion.\n+  \/\/ First prints out totals, then, separately, the class space portion.\n@@ -219,2 +220,3 @@\n-  out->print_cr(\" Metaspace       \"\n-                \"used %zuK, \"\n+  out->print(\"Metaspace \");\n+  out->fill_to(17);\n+  out->print_cr(\"used %zuK, \"\n@@ -228,2 +230,4 @@\n-    out->print_cr(\"  class space    \"\n-                  \"used %zuK, \"\n+    StreamAutoIndentor indentor(out, 1);\n+    out->print(\"class space \");\n+    out->fill_to(17);\n+    out->print_cr(\"used %zuK, \"\n@@ -597,1 +601,1 @@\n-    result = os::reserve_memory_aligned(size, Metaspace::reserve_alignment(), false);\n+    result = os::reserve_memory_aligned(size, Metaspace::reserve_alignment(), mtClass);\n@@ -770,1 +774,2 @@\n-                                   os::vm_page_size());\n+                                   os::vm_page_size(),\n+                                   mtClass);\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    _rs = MemoryReserver::reserve(reserve_limit * BytesPerWord, Metaspace::reserve_alignment(), os::vm_page_size());\n+    _rs = MemoryReserver::reserve(reserve_limit * BytesPerWord, Metaspace::reserve_alignment(), os::vm_page_size(), mtTest);\n@@ -145,1 +145,0 @@\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/testHelpers.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-                                             os::vm_page_size());\n+                                             os::vm_page_size(), mtMetaspace);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,2 +170,2 @@\n-debug_only(OopHandle Universe::_fullgc_alot_dummy_array;)\n-debug_only(int Universe::_fullgc_alot_dummy_next = 0;)\n+DEBUG_ONLY(OopHandle Universe::_fullgc_alot_dummy_array;)\n+DEBUG_ONLY(int Universe::_fullgc_alot_dummy_next = 0;)\n@@ -1177,1 +1177,4 @@\n-  heap()->print_on(st);\n+\n+  StreamAutoIndentor indentor(st, 1);\n+  heap()->print_heap_on(st);\n+  MetaspaceUtils::print_on(st);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -121,2 +121,2 @@\n-  debug_only(static OopHandle   _fullgc_alot_dummy_array;)\n-  debug_only(static int         _fullgc_alot_dummy_next;)\n+  DEBUG_ONLY(static OopHandle   _fullgc_alot_dummy_array;)\n+  DEBUG_ONLY(static int         _fullgc_alot_dummy_next;)\n@@ -364,1 +364,1 @@\n-  debug_only(static bool release_fullgc_alot_dummy();)\n+  DEBUG_ONLY(static bool release_fullgc_alot_dummy();)\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-  debug_only(warning(\n+  DEBUG_ONLY(warning(\n@@ -374,1 +374,1 @@\n-      debug_only(warning(\"os::uncommit_memory failed\"));\n+      DEBUG_ONLY(warning(\"os::uncommit_memory failed\"));\n@@ -385,1 +385,1 @@\n-      debug_only(warning(\"os::uncommit_memory failed\"));\n+      DEBUG_ONLY(warning(\"os::uncommit_memory failed\"));\n@@ -396,1 +396,1 @@\n-      debug_only(warning(\"os::uncommit_memory failed\"));\n+      DEBUG_ONLY(warning(\"os::uncommit_memory failed\"));\n@@ -425,7 +425,7 @@\n-  out->print   (\"Virtual space:\");\n-  if (special()) out->print(\" (pinned in memory)\");\n-  out->cr();\n-  out->print_cr(\" - committed: %zu\", committed_size());\n-  out->print_cr(\" - reserved:  %zu\", reserved_size());\n-  out->print_cr(\" - [low, high]:     [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",  p2i(low()), p2i(high()));\n-  out->print_cr(\" - [low_b, high_b]: [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",  p2i(low_boundary()), p2i(high_boundary()));\n+  out->print_cr(\"Virtual space:%s\", special() ? \" (pinned in memory)\" : \"\");\n+\n+  StreamAutoIndentor indentor(out, 1);\n+  out->print_cr(\"- committed: %zu\", committed_size());\n+  out->print_cr(\"- reserved:  %zu\", reserved_size());\n+  out->print_cr(\"- [low, high]:     [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",  p2i(low()), p2i(high()));\n+  out->print_cr(\"- [low_b, high_b]: [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",  p2i(low_boundary()), p2i(high_boundary()));\n@@ -439,0 +439,5 @@\n+\n+void VirtualSpace::print_space_boundaries_on(outputStream* out) const {\n+  out->print_cr(\"[\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+                p2i(low_boundary()), p2i(high()), p2i(high_boundary()));\n+}\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,2 @@\n+\n+  void print_space_boundaries_on(outputStream* out) const;\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -43,3 +45,1 @@\n-\n-  ALLOW_C_FUNCTION(::calloc,\n-                   _table = (MallocSiteHashtableEntry**)::calloc(table_size, sizeof(MallocSiteHashtableEntry*));)\n+  _table = (MallocSiteHashtableEntry**)permit_forbidden_function::calloc(table_size, sizeof(MallocSiteHashtableEntry*));\n","filename":"src\/hotspot\/share\/nmt\/mallocSiteTable.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -98,2 +99,2 @@\n-    ALLOW_C_FUNCTION(free, ::free(_ranges);)\n-    ALLOW_C_FUNCTION(free, ::free(_mem_tags);)\n+    permit_forbidden_function::free(_ranges);\n+    permit_forbidden_function::free(_mem_tags);\n@@ -114,2 +115,2 @@\n-      ALLOW_C_FUNCTION(realloc, _ranges = (Range*)::realloc(_ranges, new_capacity * sizeof(Range));)\n-      ALLOW_C_FUNCTION(realloc, _mem_tags = (MemTag*)::realloc(_mem_tags, new_capacity * sizeof(MemTag));)\n+      _ranges = (Range*)permit_forbidden_function::realloc(_ranges, new_capacity * sizeof(Range));\n+      _mem_tags = (MemTag*)permit_forbidden_function::realloc(_mem_tags, new_capacity * sizeof(MemTag));\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-    print_malloc(malloc_memory->malloc_counter());\n+    print_malloc(malloc_memory->malloc_counter(), mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  void print_malloc(const MemoryCounter* c, MemTag mem_tag = mtNone) const;\n+  void print_malloc(const MemoryCounter* c, MemTag mem_tag) const;\n","filename":"src\/hotspot\/share\/nmt\/memReporter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-    MemTag mem_tag = mtNone) {\n+    MemTag mem_tag) {\n@@ -156,1 +156,1 @@\n-    const NativeCallStack& stack, MemTag mem_tag = mtNone) {\n+    const NativeCallStack& stack, MemTag mem_tag) {\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -35,3 +36,3 @@\n-static void* raw_malloc(size_t s)               { ALLOW_C_FUNCTION(::malloc, return ::malloc(s);) }\n-static void* raw_realloc(void* old, size_t s)   { ALLOW_C_FUNCTION(::realloc, return ::realloc(old, s);) }\n-static void  raw_free(void* p)                  { ALLOW_C_FUNCTION(::free, ::free(p);) }\n+static void* raw_malloc(size_t s)               { return permit_forbidden_function::malloc(s); }\n+static void* raw_realloc(void* old, size_t s)   { return permit_forbidden_function::realloc(old, s); }\n+static void  raw_free(void* p)                  { permit_forbidden_function::free(p); }\n","filename":"src\/hotspot\/share\/nmt\/nmtPreInit.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-    MemTag mem_tag = mtNone) :\n+    MemTag mem_tag) :\n@@ -383,1 +383,1 @@\n-  static bool add_reserved_region (address base_addr, size_t size, const NativeCallStack& stack, MemTag mem_tag = mtNone);\n+  static bool add_reserved_region (address base_addr, size_t size, const NativeCallStack& stack, MemTag mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  debug_only(friend class ClassVerifier;)\n+  DEBUG_ONLY(friend class ClassVerifier;)\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2034,1 +2034,1 @@\n-    debug_only(BasicBlock* target_bb = &jsr_bb[1];)\n+    DEBUG_ONLY(BasicBlock* target_bb = &jsr_bb[1];)\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1546,1 +1546,1 @@\n-    debug_only(vtable().verify(tty, true);)\n+    DEBUG_ONLY(vtable().verify(tty, true);)\n@@ -4544,1 +4544,1 @@\n-  debug_only(_is_static_field_id = false;)\n+  DEBUG_ONLY(_is_static_field_id = false;)\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  debug_only(static bool first_time = true);\n+  DEBUG_ONLY(static bool first_time = true);\n@@ -77,1 +77,1 @@\n-  debug_only(first_time = false);\n+  DEBUG_ONLY(first_time = false);\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -664,1 +664,1 @@\n-  debug_only(verify();)\n+  DEBUG_ONLY(verify();)\n@@ -689,1 +689,1 @@\n-  debug_only(verify();)\n+  DEBUG_ONLY(verify();)\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1308,1 +1308,1 @@\n-  debug_only(NoSafepointVerifier nsv;)\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n@@ -1314,1 +1314,1 @@\n-  debug_only(NoSafepointVerifier nsv;)\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n@@ -1320,1 +1320,1 @@\n-  debug_only(NoSafepointVerifier nsv;)\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  debug_only(_limit = i+1);\n+  DEBUG_ONLY(_limit = i+1);\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  debug_only(uint _limit;)      \/\/ limit to formal domain\n+  DEBUG_ONLY(uint _limit;)      \/\/ limit to formal domain\n@@ -60,1 +60,1 @@\n-    debug_only(_limit=0);\n+    DEBUG_ONLY(_limit=0);\n@@ -72,1 +72,1 @@\n-  uint Max() const { debug_only(return _limit); return _size; }\n+  uint Max() const { DEBUG_ONLY(return _limit); return _size; }\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-  debug_only( memset(defs,0,(max_size+1)*sizeof(Node*)) );\n+  DEBUG_ONLY( memset(defs,0,(max_size+1)*sizeof(Node*)) );\n@@ -212,1 +212,1 @@\n-  debug_only( char *dup_check = NEW_RESOURCE_ARRAY(char,OptoReg::stack0());\n+  DEBUG_ONLY( char *dup_check = NEW_RESOURCE_ARRAY(char,OptoReg::stack0());\n@@ -354,1 +354,1 @@\n-      debug_only( dup_check[_callees[reg]]=1; )\n+      DEBUG_ONLY( dup_check[_callees[reg]]=1; )\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+class TypeInt;\n+class TypeLong;\n","filename":"src\/hotspot\/share\/opto\/c2_MacroAssembler.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -672,0 +672,10 @@\n+  product(uint, VerifyConstraintCasts, 0, DIAGNOSTIC,                       \\\n+          \"Perform runtime checks to verify the value of a \"                \\\n+          \"ConstraintCast lies inside its type\"                             \\\n+          \"0 = does not perform any verification, \"                         \\\n+          \"1 = perform verification on ConstraintCastNodes that are \"       \\\n+              \"present during code emission, \"                              \\\n+          \"2 = Do not do widening of ConstraintCastNodes so that we can \"   \\\n+              \"have more verification coverage\")                            \\\n+          range(0, 2)                                                       \\\n+                                                                            \\\n@@ -753,3 +763,0 @@\n-  product(bool, UseVectorStubs, false, EXPERIMENTAL,                        \\\n-          \"Use stubs for vector transcendental operations\")                 \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -860,0 +860,3 @@\n+  case vmIntrinsics::_VectorUnaryLibOp:\n+  case vmIntrinsics::_VectorBinaryLibOp:\n+    return EnableVectorSupport && Matcher::supports_vector_calling_convention();\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -261,2 +261,2 @@\n-  debug_only(_bci = -99);  \/\/ random garbage value\n-  debug_only(_map = (SafePointNode*)-1);\n+  DEBUG_ONLY(_bci = -99);  \/\/ random garbage value\n+  DEBUG_ONLY(_map = (SafePointNode*)-1);\n@@ -276,1 +276,1 @@\n-  debug_only(_map = (SafePointNode*)-1);\n+  DEBUG_ONLY(_map = (SafePointNode*)-1);\n@@ -318,1 +318,1 @@\n-  debug_only(JVMState* jvmroot = of_depth(1));\n+  DEBUG_ONLY(JVMState* jvmroot = of_depth(1));\n@@ -325,1 +325,1 @@\n-  debug_only(JVMState* jvmroot = of_depth(1));\n+  DEBUG_ONLY(JVMState* jvmroot = of_depth(1));\n@@ -1669,1 +1669,1 @@\n-  debug_only(int num_before_pop = jvms()->nof_monitors());\n+  DEBUG_ONLY(int num_before_pop = jvms()->nof_monitors());\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -588,0 +588,12 @@\n+\n+  \/\/ At VerifyConstraintCasts == 1, we verify the ConstraintCastNodes that are present during code\n+  \/\/ emission. This allows us detecting possible mis-scheduling due to these nodes being pinned at\n+  \/\/ the wrong control nodes.\n+  \/\/ At VerifyConstraintCasts == 2, we do not perform widening so that we can verify the\n+  \/\/ correctness of more ConstraintCastNodes. This further helps us detect possible\n+  \/\/ mis-transformations that may happen due to these nodes being pinned at the wrong control\n+  \/\/ nodes.\n+  if (VerifyConstraintCasts > 1) {\n+    return res;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2331,1 +2331,1 @@\n-    debug_only(Node* ident = Identity(phase));\n+    DEBUG_ONLY(Node* ident = Identity(phase));\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1326,1 +1326,1 @@\n-    debug_only( int lo_no_simplify=0; );\n+    DEBUG_ONLY( int lo_no_simplify=0; );\n@@ -1338,1 +1338,1 @@\n-      debug_only( if( lrgs(i)._was_lo ) lo_no_simplify=i; );\n+      DEBUG_ONLY( if( lrgs(i)._was_lo ) lo_no_simplify=i; );\n@@ -1580,1 +1580,1 @@\n-    debug_only(RegMask orig_mask = lrg->mask();)\n+    DEBUG_ONLY(RegMask orig_mask = lrg->mask();)\n@@ -1709,2 +1709,2 @@\n-        debug_only(tty->print(\" original mask: \"));\n-        debug_only(orig_mask.dump());\n+        DEBUG_ONLY(tty->print(\" original mask: \"));\n+        DEBUG_ONLY(orig_mask.dump());\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    debug_only(_degree_valid = 1;)\n+    DEBUG_ONLY(_degree_valid = 1;)\n@@ -89,1 +89,1 @@\n-  void invalid_degree() { debug_only(_degree_valid=0;) }\n+  void invalid_degree() { DEBUG_ONLY(_degree_valid=0;) }\n@@ -131,5 +131,5 @@\n-  void set_mask( const RegMask &rm ) { _mask = rm; debug_only(_msize_valid=0;)}\n-  void AND( const RegMask &rm ) { _mask.AND(rm); debug_only(_msize_valid=0;)}\n-  void SUBTRACT( const RegMask &rm ) { _mask.SUBTRACT(rm); debug_only(_msize_valid=0;)}\n-  void Clear()   { _mask.Clear()  ; debug_only(_msize_valid=1); _mask_size = 0; }\n-  void Set_All() { _mask.Set_All(); debug_only(_msize_valid=1); _mask_size = RegMask::CHUNK_SIZE; }\n+  void set_mask( const RegMask &rm ) { _mask = rm; DEBUG_ONLY(_msize_valid=0;)}\n+  void AND( const RegMask &rm ) { _mask.AND(rm); DEBUG_ONLY(_msize_valid=0;)}\n+  void SUBTRACT( const RegMask &rm ) { _mask.SUBTRACT(rm); DEBUG_ONLY(_msize_valid=0;)}\n+  void Clear()   { _mask.Clear()  ; DEBUG_ONLY(_msize_valid=1); _mask_size = 0; }\n+  void Set_All() { _mask.Set_All(); DEBUG_ONLY(_msize_valid=1); _mask_size = RegMask::CHUNK_SIZE; }\n@@ -137,3 +137,3 @@\n-  void Insert( OptoReg::Name reg ) { _mask.Insert(reg);  debug_only(_msize_valid=0;) }\n-  void Remove( OptoReg::Name reg ) { _mask.Remove(reg);  debug_only(_msize_valid=0;) }\n-  void clear_to_sets()  { _mask.clear_to_sets(_num_regs); debug_only(_msize_valid=0;) }\n+  void Insert( OptoReg::Name reg ) { _mask.Insert(reg);  DEBUG_ONLY(_msize_valid=0;) }\n+  void Remove( OptoReg::Name reg ) { _mask.Remove(reg);  DEBUG_ONLY(_msize_valid=0;) }\n+  void clear_to_sets()  { _mask.clear_to_sets(_num_regs); DEBUG_ONLY(_msize_valid=0;) }\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-  debug_only(verify_graph_edges(true \/*check for no_dead_code*\/, root_and_safepoints);)\n+  DEBUG_ONLY(verify_graph_edges(true \/*check for no_dead_code*\/, root_and_safepoints);)\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2891,1 +2891,1 @@\n-          \/\/ StoreP::memory_type() == T_ADDRESS\n+          \/\/ StoreP::value_basic_type() == T_ADDRESS\n@@ -2898,1 +2898,1 @@\n-              store->as_Store()->memory_type() == ft) {\n+              store->as_Store()->value_basic_type() == ft) {\n@@ -4674,1 +4674,1 @@\n-      debug_only(n->dump();)\n+      DEBUG_ONLY(n->dump();)\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,2 +88,2 @@\n-  debug_only(_sp = -99);\n-  debug_only(set_bci(-99));\n+  DEBUG_ONLY(_sp = -99);\n+  DEBUG_ONLY(set_bci(-99));\n@@ -212,1 +212,1 @@\n-  debug_only(verify_exception_state(ex_map));\n+  DEBUG_ONLY(verify_exception_state(ex_map));\n@@ -312,1 +312,1 @@\n-      debug_only(verify_map());\n+      DEBUG_ONLY(verify_map());\n@@ -689,1 +689,1 @@\n-  debug_only(kit->verify_map());\n+  DEBUG_ONLY(kit->verify_map());\n@@ -797,1 +797,1 @@\n-  debug_only(verify_map());\n+  DEBUG_ONLY(verify_map());\n@@ -1602,1 +1602,1 @@\n-  debug_only( map()->set_memory((Node*)nullptr) );\n+  DEBUG_ONLY( map()->set_memory((Node*)nullptr) );\n@@ -1639,1 +1639,1 @@\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n+  DEBUG_ONLY(adr_type = C->get_adr_type(adr_idx));\n@@ -1668,1 +1668,1 @@\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n+  DEBUG_ONLY(adr_type = C->get_adr_type(adr_idx));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  void set_map(SafePointNode* m)      { _map = m; debug_only(verify_map()); }\n+  void set_map(SafePointNode* m)      { _map = m; DEBUG_ONLY(verify_map()); }\n@@ -240,1 +240,1 @@\n-      debug_only(verify_exception_state(ex_map));\n+      DEBUG_ONLY(verify_exception_state(ex_map));\n@@ -247,1 +247,1 @@\n-    debug_only(verify_exception_state(ex_map));\n+    DEBUG_ONLY(verify_exception_state(ex_map));\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n+  DEBUG_ONLY(adr_type = C->get_adr_type(adr_idx));\n@@ -371,1 +371,1 @@\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n+  DEBUG_ONLY(adr_type = C->get_adr_type(adr_idx));\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2239,1 +2239,1 @@\n-      st->print(\"Profiled Loop \");\n+      st->print(\"Profiled_Loop \");\n@@ -2245,1 +2245,1 @@\n-      st->print(\"Loop Limit Check \");\n+      st->print(\"Loop_Limit_Check \");\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  debug_only(check_watch(\"free block\", i));\n+  DEBUG_ONLY(check_watch(\"free block\", i));\n","filename":"src\/hotspot\/share\/opto\/indexSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -734,0 +734,4 @@\n+  case vmIntrinsics::_VectorUnaryLibOp:\n+    return inline_vector_call(1);\n+  case vmIntrinsics::_VectorBinaryLibOp:\n+    return inline_vector_call(2);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -397,0 +397,1 @@\n+  bool inline_vector_call(int arity);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1302,0 +1302,16 @@\n+\/\/ When a counted loop is created, the loop phi type may be narrowed down. As a consequence, the control input of some\n+\/\/ nodes may be cleared: in particular in the case of a division by the loop iv, the Div node would lose its control\n+\/\/ dependency if the loop phi is never zero. After pre\/main\/post loops are created (and possibly unrolling), the\n+\/\/ loop phi type is only correct if the loop is indeed reachable: there's an implicit dependency between the loop phi\n+\/\/ type and the zero trip guard for the main or post loop and as a consequence a dependency between the Div node and the\n+\/\/ zero trip guard. This makes the dependency explicit by adding a CastII for the loop entry input of the loop phi. If\n+\/\/ the backedge of the main or post loop is removed, a Div node won't be able to float above the zero trip guard of the\n+\/\/ loop and can't execute even if the loop is not reached.\n+void PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop) {\n+  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n+  register_new_node(castii, ctrl);\n+  Node* phi = loop->phi();\n+  assert(phi->in(LoopNode::EntryControl) == incr, \"replacing wrong input?\");\n+  _igvn.replace_input_of(phi, LoopNode::EntryControl, castii);\n+}\n+\n@@ -1456,0 +1472,2 @@\n+  \/\/ CastII for the main loop:\n+  cast_incr_before_loop(pre_incr, min_taken, main_head);\n@@ -1596,1 +1614,1 @@\n-                                       Node*& incr, Node* limit, CountedLoopNode*& post_head) {\n+                                       Node* incr, Node* limit, CountedLoopNode*& post_head) {\n@@ -1685,0 +1703,1 @@\n+  cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n@@ -1780,2 +1799,2 @@\n-    LoopNode* target_loop_head, const Node* old_target_loop_entry,\n-    const uint node_index_before_new_assertion_predicate_nodes) {\n+  CountedLoopNode* target_loop_head, const Node* old_target_loop_entry,\n+  const uint node_index_before_new_assertion_predicate_nodes) {\n@@ -1791,0 +1810,1 @@\n+      assert(out != target_loop_head->init_trip(), \"CastII on loop entry?\");\n@@ -2680,1 +2700,2 @@\n-          Node* init = cl->init_trip();\n+          Node* init = cl->uncasted_init_trip(true);\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-    debug_only( bol->dump(2); )\n+    DEBUG_ONLY( bol->dump(2); )\n@@ -6061,0 +6061,18 @@\n+Node* CountedLoopNode::uncasted_init_trip(bool uncast) {\n+  Node* init = init_trip();\n+  if (uncast && init->is_CastII()) {\n+    \/\/ skip over the cast added by PhaseIdealLoop::cast_incr_before_loop() when pre\/post\/main loops are created because\n+    \/\/ it can get in the way of type propagation. For instance, the index tested by an Assertion Predicate, if the cast\n+    \/\/ is not skipped over, could be (1):\n+    \/\/ (AddI (CastII (AddI pre_loop_iv -2) int) 1)\n+    \/\/ while without the cast, it is (2):\n+    \/\/ (AddI (AddI pre_loop_iv -2) 1)\n+    \/\/ which is be transformed to (3):\n+    \/\/ (AddI pre_loop_iv -1)\n+    \/\/ The compiler may be able to constant fold the Assertion Predicate condition for (3) but not (1)\n+    assert(init->as_CastII()->carry_dependency() && skip_assertion_predicates_with_halt() == init->in(0), \"casted iv phi from pre loop expected\");\n+    init = init->in(1);\n+  }\n+  return init;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -371,0 +371,2 @@\n+  Node* uncasted_init_trip(bool uncasted);\n+\n@@ -980,0 +982,2 @@\n+  void cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop);\n+\n@@ -1005,1 +1009,1 @@\n-  void rewire_old_target_loop_entry_dependency_to_new_entry(LoopNode* target_loop_head,\n+  void rewire_old_target_loop_entry_dependency_to_new_entry(CountedLoopNode* target_loop_head,\n@@ -1359,1 +1363,1 @@\n-                         Node*& incr, Node* limit, CountedLoopNode*& post_head);\n+                         Node* incr, Node* limit, CountedLoopNode*& post_head);\n@@ -1589,2 +1593,0 @@\n-  bool split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk);\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1151,19 +1151,0 @@\n-\/\/ Split some nodes that take a counted loop phi as input at a counted\n-\/\/ loop can cause vectorization of some expressions to fail\n-bool PhaseIdealLoop::split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk) {\n-  if (!n_blk->is_CountedLoop()) {\n-    return false;\n-  }\n-\n-  int opcode = n->Opcode();\n-\n-  if (opcode != Op_AndI &&\n-      opcode != Op_MulI &&\n-      opcode != Op_RotateRight &&\n-      opcode != Op_RShiftI) {\n-    return false;\n-  }\n-\n-  return n->in(1) == n_blk->as_BaseCountedLoop()->phi();\n-}\n-\n@@ -1262,4 +1243,0 @@\n-  if (split_thru_phi_could_prevent_vectorization(n, n_blk)) {\n-    return n;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-        debug_only(intptr_t offset;)\n+        DEBUG_ONLY(intptr_t offset;)\n@@ -1599,1 +1599,1 @@\n-    debug_only(slow_region = NodeSentinel);\n+    DEBUG_ONLY(slow_region = NodeSentinel);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  debug_only(_mem_node = nullptr;)   \/\/ Ideal memory node consumed by mach node\n+  DEBUG_ONLY(_mem_node = nullptr;)   \/\/ Ideal memory node consumed by mach node\n@@ -1223,1 +1223,1 @@\n-          debug_only(match_alias_type(C, n, m));\n+          DEBUG_ONLY(match_alias_type(C, n, m));\n@@ -1635,1 +1635,1 @@\n-  debug_only( _mem_node = save_mem_node; )\n+  DEBUG_ONLY( _mem_node = save_mem_node; )\n@@ -2009,1 +2009,1 @@\n-    debug_only(Node *save_mem_node = _mem_node;)\n+    DEBUG_ONLY(Node *save_mem_node = _mem_node;)\n@@ -2011,1 +2011,1 @@\n-    debug_only(_mem_node = save_mem_node;)\n+    DEBUG_ONLY(_mem_node = save_mem_node;)\n@@ -2023,1 +2023,1 @@\n-    debug_only( if( mem == (Node*)1 ) _mem_node = s->_leaf;)\n+    DEBUG_ONLY( if( mem == (Node*)1 ) _mem_node = s->_leaf;)\n@@ -2067,1 +2067,1 @@\n-        debug_only(Node *save_mem_node = _mem_node;)\n+        DEBUG_ONLY(Node *save_mem_node = _mem_node;)\n@@ -2069,1 +2069,1 @@\n-        debug_only(_mem_node = save_mem_node;)\n+        DEBUG_ONLY(_mem_node = save_mem_node;)\n@@ -2100,1 +2100,1 @@\n-    debug_only(_mem_node = s->_leaf;)\n+    DEBUG_ONLY(_mem_node = s->_leaf;)\n@@ -2129,1 +2129,1 @@\n-      debug_only(Node *save_mem_node = _mem_node;)\n+      DEBUG_ONLY(Node *save_mem_node = _mem_node;)\n@@ -2131,1 +2131,1 @@\n-      debug_only(_mem_node = save_mem_node;)\n+      DEBUG_ONLY(_mem_node = save_mem_node;)\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1357,1 +1357,1 @@\n-      if (memory_type() != T_VOID) {\n+      if (value_basic_type() != T_VOID) {\n@@ -1362,1 +1362,1 @@\n-          return phase->zerocon(memory_type());\n+          return phase->zerocon(value_basic_type());\n@@ -2199,1 +2199,1 @@\n-                                                                      memory_type(), is_unsigned());\n+                                                                      value_basic_type(), is_unsigned());\n@@ -2267,1 +2267,1 @@\n-    BasicType bt = memory_type();\n+    BasicType bt = value_basic_type();\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    debug_only(_adr_type=at; adr_type();)\n+    DEBUG_ONLY(_adr_type=at; adr_type();)\n@@ -83,1 +83,1 @@\n-    debug_only(_adr_type=at; adr_type();)\n+    DEBUG_ONLY(_adr_type=at; adr_type();)\n@@ -92,1 +92,1 @@\n-    debug_only(_adr_type=at; adr_type();)\n+    DEBUG_ONLY(_adr_type=at; adr_type();)\n@@ -141,1 +141,5 @@\n-  virtual BasicType memory_type() const = 0;\n+  \/\/ The returned type is a property of the value that is loaded\/stored and\n+  \/\/ not the memory that is accessed. For mismatched memory accesses\n+  \/\/ they might differ. For instance, a value of type 'short' may be stored\n+  \/\/ into an array of elements of type 'long'.\n+  virtual BasicType value_basic_type() const = 0;\n@@ -144,1 +148,1 @@\n-    return type2aelembytes(memory_type(), true);\n+    return type2aelembytes(value_basic_type(), true);\n@@ -146,1 +150,1 @@\n-    return type2aelembytes(memory_type());\n+    return type2aelembytes(value_basic_type());\n@@ -276,1 +280,1 @@\n-    debug_only(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n+    DEBUG_ONLY(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n@@ -344,1 +348,1 @@\n-  virtual BasicType memory_type() const { return T_BYTE; }\n+  virtual BasicType value_basic_type() const { return T_BYTE; }\n@@ -358,1 +362,1 @@\n-  virtual BasicType memory_type() const { return T_BYTE; }\n+  virtual BasicType value_basic_type() const { return T_BYTE; }\n@@ -372,1 +376,1 @@\n-  virtual BasicType memory_type() const { return T_CHAR; }\n+  virtual BasicType value_basic_type() const { return T_CHAR; }\n@@ -386,1 +390,1 @@\n-  virtual BasicType memory_type() const { return T_SHORT; }\n+  virtual BasicType value_basic_type() const { return T_SHORT; }\n@@ -398,1 +402,1 @@\n-  virtual BasicType memory_type() const { return T_INT; }\n+  virtual BasicType value_basic_type() const { return T_INT; }\n@@ -431,1 +435,1 @@\n-  virtual BasicType memory_type() const { return T_LONG; }\n+  virtual BasicType value_basic_type() const { return T_LONG; }\n@@ -460,1 +464,1 @@\n-  virtual BasicType memory_type() const { return T_FLOAT; }\n+  virtual BasicType value_basic_type() const { return T_FLOAT; }\n@@ -481,1 +485,1 @@\n-  virtual BasicType memory_type() const { return T_DOUBLE; }\n+  virtual BasicType value_basic_type() const { return T_DOUBLE; }\n@@ -510,1 +514,1 @@\n-  virtual BasicType memory_type() const { return T_ADDRESS; }\n+  virtual BasicType value_basic_type() const { return T_ADDRESS; }\n@@ -524,1 +528,1 @@\n-  virtual BasicType memory_type() const { return T_NARROWOOP; }\n+  virtual BasicType value_basic_type() const { return T_NARROWOOP; }\n@@ -579,1 +583,1 @@\n-  virtual BasicType memory_type() const { return T_NARROWKLASS; }\n+  virtual BasicType value_basic_type() const { return T_NARROWKLASS; }\n@@ -689,1 +693,1 @@\n-  virtual BasicType memory_type() const { return T_BYTE; }\n+  virtual BasicType value_basic_type() const { return T_BYTE; }\n@@ -700,1 +704,1 @@\n-  virtual BasicType memory_type() const { return T_CHAR; }\n+  virtual BasicType value_basic_type() const { return T_CHAR; }\n@@ -710,1 +714,1 @@\n-  virtual BasicType memory_type() const { return T_INT; }\n+  virtual BasicType value_basic_type() const { return T_INT; }\n@@ -728,1 +732,1 @@\n-  virtual BasicType memory_type() const { return T_LONG; }\n+  virtual BasicType value_basic_type() const { return T_LONG; }\n@@ -751,1 +755,1 @@\n-  virtual BasicType memory_type() const { return T_LONG; }\n+  virtual BasicType value_basic_type() const { return T_LONG; }\n@@ -765,1 +769,1 @@\n-  virtual BasicType memory_type() const { return T_FLOAT; }\n+  virtual BasicType value_basic_type() const { return T_FLOAT; }\n@@ -783,1 +787,1 @@\n-  virtual BasicType memory_type() const { return T_DOUBLE; }\n+  virtual BasicType value_basic_type() const { return T_DOUBLE; }\n@@ -802,1 +806,1 @@\n-  virtual BasicType memory_type() const { return T_ADDRESS; }\n+  virtual BasicType value_basic_type() const { return T_ADDRESS; }\n@@ -812,1 +816,1 @@\n-  virtual BasicType memory_type() const { return T_NARROWOOP; }\n+  virtual BasicType value_basic_type() const { return T_NARROWOOP; }\n@@ -822,1 +826,1 @@\n-  virtual BasicType memory_type() const { return T_NARROWKLASS; }\n+  virtual BasicType value_basic_type() const { return T_NARROWKLASS; }\n@@ -1543,1 +1547,1 @@\n-    debug_only(_cnt2 = 999);\n+    DEBUG_ONLY(_cnt2 = 999);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":33,"deletions":29,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -939,7 +939,9 @@\n-      const julong sign_bits_mask = ~(((julong)CONST64(1) << (julong)(BitsPerJavaLong - shift)) -1);\n-      \/\/ If the AND'ing of the 2 masks has no bits, then only original shifted\n-      \/\/ bits survive.  NO sign-extension bits survive the maskings.\n-      if( (sign_bits_mask & mask) == 0 ) {\n-        \/\/ Use zero-fill shift instead\n-        Node *zshift = phase->transform(new URShiftLNode(in1->in(1), in1->in(2)));\n-        return new AndLNode(zshift, in(2));\n+      if (shift != 0) {\n+        const julong sign_bits_mask = ~(((julong)CONST64(1) << (julong)(BitsPerJavaLong - shift)) -1);\n+        \/\/ If the AND'ing of the 2 masks has no bits, then only original shifted\n+        \/\/ bits survive.  NO sign-extension bits survive the maskings.\n+        if( (sign_bits_mask & mask) == 0 ) {\n+          \/\/ Use zero-fill shift instead\n+          Node *zshift = phase->transform(new URShiftLNode(in1->in(1), in1->in(2)));\n+          return new AndLNode(zshift, in(2));\n+        }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    debug_only(check_con());\n+    DEBUG_ONLY(check_con());\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -345,1 +345,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -358,1 +358,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -373,1 +373,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -390,1 +390,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -409,1 +409,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -431,1 +431,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -455,1 +455,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -493,1 +493,1 @@\n-  debug_only(n->_hash_lock = 0);\n+  DEBUG_ONLY(n->_hash_lock = 0);\n@@ -529,1 +529,1 @@\n-  debug_only( n->verify_construction() );\n+  DEBUG_ONLY( n->verify_construction() );\n@@ -533,1 +533,1 @@\n-  \/\/debug_only( n->set_debug_idx( debug_idx() ) );\n+  \/\/DEBUG_ONLY( n->set_debug_idx( debug_idx() ) );\n@@ -952,1 +952,1 @@\n-  \/\/ debug_only(destruct();)   \/\/ no reuse benefit expected\n+  \/\/ DEBUG_ONLY(destruct();)   \/\/ no reuse benefit expected\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-    debug_only(_last_del = _out[i]; ++_del_tick);\n+    DEBUG_ONLY(_last_del = _out[i]; ++_del_tick);\n@@ -438,1 +438,1 @@\n-    debug_only(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);\n+    DEBUG_ONLY(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);\n@@ -540,1 +540,1 @@\n-    debug_only(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);\n+    DEBUG_ONLY(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);\n@@ -543,1 +543,1 @@\n-    debug_only(_last_del = n; ++_del_tick);\n+    DEBUG_ONLY(_last_del = n; ++_del_tick);\n@@ -600,1 +600,1 @@\n-    debug_only(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n+    DEBUG_ONLY(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n@@ -1448,1 +1448,1 @@\n-    { _idx = 0;                         debug_only(sample(node)); }\n+    { _idx = 0;                         DEBUG_ONLY(sample(node)); }\n@@ -1453,1 +1453,1 @@\n-    { \/*initialize to garbage*\/         debug_only(_vdui = false); }\n+    { \/*initialize to garbage*\/         DEBUG_ONLY(_vdui = false); }\n@@ -1456,1 +1456,1 @@\n-    { _idx = that._idx;                 debug_only(_vdui = false; reset(that)); }\n+    { _idx = that._idx;                 DEBUG_ONLY(_vdui = false; reset(that)); }\n@@ -1468,1 +1468,1 @@\n-    { _idx = that._idx;                 debug_only(reset(that)); }\n+    { _idx = that._idx;                 DEBUG_ONLY(reset(that)); }\n@@ -1478,1 +1478,1 @@\n-  { I_VDUI_ONLY(i, i.verify(this));     return debug_only(i._last=) _out[i._idx]; }\n+  { I_VDUI_ONLY(i, i.verify(this));     return DEBUG_ONLY(i._last=) _out[i._idx]; }\n@@ -1513,1 +1513,1 @@\n-    { _outp = node->_out + offset;      debug_only(sample(node)); }\n+    { _outp = node->_out + offset;      DEBUG_ONLY(sample(node)); }\n@@ -1518,1 +1518,1 @@\n-    { \/*initialize to garbage*\/         debug_only(_vdui = false); }\n+    { \/*initialize to garbage*\/         DEBUG_ONLY(_vdui = false); }\n@@ -1521,1 +1521,1 @@\n-    { _outp = that._outp;               debug_only(_vdui = false; reset(that)); }\n+    { _outp = that._outp;               DEBUG_ONLY(_vdui = false; reset(that)); }\n@@ -1539,1 +1539,1 @@\n-    { _outp = that._outp;               debug_only(reset(that)); }\n+    { _outp = that._outp;               DEBUG_ONLY(reset(that)); }\n@@ -1550,1 +1550,1 @@\n-  return debug_only(i._last=) *i._outp;\n+  return DEBUG_ONLY(i._last=) *i._outp;\n@@ -1608,1 +1608,1 @@\n-  return debug_only(i._last=) *i._outp;\n+  return DEBUG_ONLY(i._last=) *i._outp;\n@@ -2052,1 +2052,1 @@\n-    debug_only(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n+    DEBUG_ONLY(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -3042,1 +3042,1 @@\n-  debug_only( def = (Node*)((intptr_t)0xdeadbeef); )\n+  DEBUG_ONLY( def = (Node*)((intptr_t)0xdeadbeef); )\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2019,1 +2019,1 @@\n-          debug_only(const Type* bt1 = phi->bottom_type());\n+          DEBUG_ONLY(const Type* bt1 = phi->bottom_type());\n@@ -2022,1 +2022,1 @@\n-          debug_only(const Type* bt2 = phi->bottom_type());\n+          DEBUG_ONLY(const Type* bt2 = phi->bottom_type());\n@@ -2119,1 +2119,1 @@\n-    debug_only(mms.set_memory());  \/\/ keep the iterator happy\n+    DEBUG_ONLY(mms.set_memory());  \/\/ keep the iterator happy\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    debug_only(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n+    DEBUG_ONLY(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n@@ -155,1 +155,1 @@\n-      debug_only(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n+      DEBUG_ONLY(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n@@ -191,1 +191,1 @@\n-  debug_only(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n+  DEBUG_ONLY(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n@@ -206,1 +206,1 @@\n-  debug_only( uint counter = 0; );\n+  DEBUG_ONLY( uint counter = 0; );\n@@ -208,1 +208,1 @@\n-    debug_only( counter++ );\n+    DEBUG_ONLY( counter++ );\n@@ -218,1 +218,1 @@\n-      debug_only(((Node*)n)->exit_hash_lock()); \/\/ Unlock the node upon removal from table.\n+      DEBUG_ONLY(((Node*)n)->exit_hash_lock()); \/\/ Unlock the node upon removal from table.\n@@ -260,1 +260,1 @@\n-    debug_only(m->exit_hash_lock()); \/\/ Unlock the node upon removal from old table.\n+    DEBUG_ONLY(m->exit_hash_lock()); \/\/ Unlock the node upon removal from old table.\n@@ -292,1 +292,1 @@\n-      debug_only(n->exit_hash_lock()); \/\/ Unlock the node when removed\n+      DEBUG_ONLY(n->exit_hash_lock()); \/\/ Unlock the node when removed\n@@ -1781,0 +1781,28 @@\n+\n+  \/* AndNode has a special handling when one of the operands is a LShiftNode:\n+   * (LHS << s) & RHS\n+   * if RHS fits in less than s bits, the value of this expression is 0.\n+   * The difficulty is that there might be a conversion node (ConvI2L) between\n+   * the LShiftINode and the AndLNode, like so:\n+   * AndLNode(ConvI2L(LShiftI(LHS, s)), RHS)\n+   * This case is handled by And[IL]Node::Value(PhaseGVN*)\n+   * (see `AndIL_min_trailing_zeros`).\n+   *\n+   * But, when the shift is updated during IGVN, pushing the user (ConvI2L)\n+   * is not enough: there might be no update happening there. We need to\n+   * directly push the And[IL]Node on the worklist, jumping over ConvI2L.\n+   *\n+   * Moreover we can have ConstraintCasts in between. It may look like\n+   * ConstraintCast+ -> ConvI2L -> ConstraintCast+ -> And\n+   * and And[IL]Node::Value(PhaseGVN*) still handles that by looking through casts.\n+   * So we must deal with that as well.\n+   *\/\n+  if (use->is_ConstraintCast() || use_op == Op_ConvI2L) {\n+    auto is_boundary = [](Node* n){ return !n->is_ConstraintCast() && n->Opcode() != Op_ConvI2L; };\n+    auto push_and_to_worklist = [&worklist](Node* n){\n+      if (n->Opcode() == Op_AndL || n->Opcode() == Op_AndI) {\n+        worklist.push(n);\n+      }\n+    };\n+    use->visit_uses(push_and_to_worklist, is_boundary);\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":36,"deletions":8,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -760,1 +761,1 @@\n-  OpaqueLoopInitNode* opaque_init = new OpaqueLoopInitNode(_phase->C, _loop_head->init_trip());\n+  OpaqueLoopInitNode* opaque_init = new OpaqueLoopInitNode(_phase->C, _loop_head->uncasted_init_trip(_loop_head->is_main_loop()));\n@@ -1096,1 +1097,2 @@\n-      _phase(phase) {}\n+      _phase(phase),\n+      _is_counted_loop(true_path_loop_head->is_CountedLoop()) {}\n@@ -1098,1 +1100,0 @@\n-\/\/ Keep track of whether we are in the correct Predicate Block where Template Assertion Predicates can be found.\n@@ -1100,0 +1101,4 @@\n+\/\/ Does not clone a Loop Limit Check Parse Predicate if a counted loop is unswitched, because it most likely will not be\n+\/\/ used anymore (it could only be used when both unswitched loop versions die and the Loop Limit Check Parse Predicate\n+\/\/ ends up at a LoopNode without Loop Limit Check Parse Predicate directly following the unswitched loop that can then\n+\/\/ be speculatively converted to a counted loop - this is rather rare).\n@@ -1101,0 +1106,4 @@\n+  Deoptimization::DeoptReason deopt_reason = parse_predicate.head()->deopt_reason();\n+  if (_is_counted_loop && deopt_reason == Deoptimization::Reason_loop_limit_check) {\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1179,0 +1179,1 @@\n+  const bool _is_counted_loop;\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    debug_only( if( n->_idx >= _node_regs_max_index ) n->dump(); );\n+    DEBUG_ONLY( if( n->_idx >= _node_regs_max_index ) n->dump(); );\n@@ -68,1 +68,1 @@\n-    debug_only( if( n->_idx >= _node_regs_max_index ) n->dump(); );\n+    DEBUG_ONLY( if( n->_idx >= _node_regs_max_index ) n->dump(); );\n","filename":"src\/hotspot\/share\/opto\/regalloc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1987,1 +1987,1 @@\n-  debug_only(NoHandleMark __hm;)\n+  DEBUG_ONLY(NoHandleMark __hm;)\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-      bt = n->as_Mem()->memory_type();\n+      bt = n->as_Mem()->value_basic_type();\n@@ -194,1 +194,1 @@\n-        bt = n->as_Mem()->memory_type();\n+        bt = n->as_Mem()->value_basic_type();\n@@ -567,1 +567,1 @@\n-        is_java_primitive(mem->memory_type())) {\n+        is_java_primitive(mem->value_basic_type())) {\n@@ -767,2 +767,2 @@\n-  if (!is_java_primitive(s1->as_Mem()->memory_type()) ||\n-      !is_java_primitive(s2->as_Mem()->memory_type())) {\n+  if (!is_java_primitive(s1->as_Mem()->value_basic_type()) ||\n+      !is_java_primitive(s2->as_Mem()->value_basic_type())) {\n@@ -2596,1 +2596,1 @@\n-    BasicType bt = n->as_Mem()->memory_type();\n+    BasicType bt = n->as_Mem()->value_basic_type();\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -815,1 +815,1 @@\n-  debug_only(base());           \/\/ Check the assertion in Type::base().\n+  DEBUG_ONLY(base());           \/\/ Check the assertion in Type::base().\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -369,2 +369,3 @@\n-  if ((opc != Op_CallLeafVector) && (sopc == 0)) {\n-    log_if_needed(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n+  if (sopc == 0 || num_elem == 1) {\n+    log_if_needed(\"  ** operation not supported: arity=%d opc=%s[%d] vlen=%d etype=%s\",\n+                    n, NodeClassNames[opc], opc, num_elem, type2name(elem_bt));\n@@ -373,7 +374,0 @@\n-  if (num_elem == 1) {\n-    if (opc != Op_CallLeafVector || elem_bt != T_DOUBLE) {\n-      log_if_needed(\"  ** not a svml call: arity=%d opc=%d vlen=%d etype=%s\",\n-                      n, opc, num_elem, type2name(elem_bt));\n-      return false;\n-    }\n-  }\n@@ -387,16 +381,0 @@\n-  if (opc == Op_CallLeafVector) {\n-    if (!UseVectorStubs) {\n-      log_if_needed(\"  ** vector stubs support is disabled\");\n-      return false;\n-    }\n-    if (!Matcher::supports_vector_calling_convention()) {\n-      log_if_needed(\"  ** no vector calling conventions supported\");\n-      return false;\n-    }\n-    if (!Matcher::vector_size_supported(elem_bt, num_elem)) {\n-      log_if_needed(\"  ** vector size (vlen=%d, etype=%s) is not supported\",\n-                      num_elem, type2name(elem_bt));\n-      return false;\n-    }\n-  }\n-\n@@ -467,23 +445,10 @@\n-  if (opc == Op_CallLeafVector) {\n-    assert(UseVectorStubs, \"sanity\");\n-    operation = gen_call_to_vector_math(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n-    if (operation == nullptr) {\n-      log_if_needed(\"  ** Vector math call failed for %s_%s_%d\",\n-                         (elem_bt == T_FLOAT) ? \"float\" : \"double\",\n-                         VectorSupport::mathname[opr->get_con() - VectorSupport::VECTOR_OP_MATH_START],\n-                         num_elem * type2aelembytes(elem_bt));\n-      return false;\n-     }\n-  } else {\n-    const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_klass));\n-    switch (n) {\n-      case 1:\n-      case 2: {\n-        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc), is_unsigned);\n-        break;\n-      }\n-      case 3: {\n-        operation = VectorNode::make(sopc, opd1, opd2, opd3, vt);\n-        break;\n-      }\n-      default: fatal(\"unsupported arity: %d\", n);\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_klass));\n+  switch (n) {\n+    case 1:\n+    case 2: {\n+      operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc), is_unsigned);\n+      break;\n+    }\n+    case 3: {\n+      operation = VectorNode::make(sopc, opd1, opd2, opd3, vt);\n+      break;\n@@ -491,0 +456,1 @@\n+    default: fatal(\"unsupported arity: %d\", n);\n@@ -513,0 +479,101 @@\n+\/\/ <V extends Vector<E>, E>\n+\/\/ V libraryUnaryOp(long address, Class<? extends V> vClass, Class<E> elementType, int length, String debugName,\n+\/\/                  V v,\n+\/\/                  UnaryOperation<V, ?> defaultImpl)\n+\/\/\n+\/\/ public static\n+\/\/ <V extends VectorPayload, E>\n+\/\/ V libraryBinaryOp(long address, Class<? extends V> vClass, Class<E> elementType, int length, String debugName,\n+\/\/            V v1, V v2,\n+\/\/            BinaryOperation<V, ?> defaultImpl)\n+bool LibraryCallKit::inline_vector_call(int arity) {\n+  assert(Matcher::supports_vector_calling_convention(), \"required\");\n+\n+  const TypeLong*    entry          = gvn().type(argument(0))->isa_long();\n+  const TypeInstPtr* vector_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInstPtr* elem_klass     = gvn().type(argument(3))->isa_instptr();\n+  const TypeInt*     vlen           = gvn().type(argument(4))->isa_int();\n+  const TypeInstPtr* debug_name_oop = gvn().type(argument(5))->isa_instptr();\n+\n+  if (entry        == nullptr   || !entry->is_con() ||\n+      vector_klass == nullptr   || vector_klass->const_oop() == nullptr ||\n+      elem_klass   == nullptr   || elem_klass->const_oop() == nullptr ||\n+      vlen         == nullptr   || !vlen->is_con() ||\n+      debug_name_oop == nullptr || debug_name_oop->const_oop() == nullptr) {\n+    log_if_needed(\"  ** missing constant: opr=%s vclass=%s etype=%s vlen=%s debug_name=%s\",\n+                  NodeClassNames[argument(0)->Opcode()],\n+                  NodeClassNames[argument(2)->Opcode()],\n+                  NodeClassNames[argument(3)->Opcode()],\n+                  NodeClassNames[argument(4)->Opcode()],\n+                  NodeClassNames[argument(5)->Opcode()]);\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (entry->get_con() == 0) {\n+    log_if_needed(\"  ** missing entry point\");\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    return false; \/\/ should be primitive type\n+  }\n+  if (!is_klass_initialized(vector_klass)) {\n+    log_if_needed(\"  ** klass argument not initialized\");\n+    return false;\n+  }\n+\n+  BasicType elem_bt = elem_type->basic_type();\n+  int num_elem = vlen->get_con();\n+  if (!Matcher::vector_size_supported(elem_bt, num_elem)) {\n+    log_if_needed(\"  ** vector size (vlen=%d, etype=%s) is not supported\",\n+                  num_elem, type2name(elem_bt));\n+    return false;\n+  }\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  Node* opd1 = unbox_vector(argument(6), vbox_type, elem_bt, num_elem);\n+  if (opd1 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v1=%s\", NodeClassNames[argument(6)->Opcode()]);\n+    return false;\n+  }\n+\n+  Node* opd2 = nullptr;\n+  if (arity > 1) {\n+    opd2 = unbox_vector(argument(7), vbox_type, elem_bt, num_elem);\n+    if (opd2 == nullptr) {\n+      log_if_needed(\"  ** unbox failed v2=%s\", NodeClassNames[argument(7)->Opcode()]);\n+      return false;\n+    }\n+  }\n+  assert(arity == 1 || arity == 2, \"arity %d not supported\", arity);\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(arity, vt, vt);\n+  address entry_addr = (address)entry->get_con();\n+\n+  const char* debug_name = \"<unknown>\";\n+  if (!debug_name_oop->const_oop()->is_null_object()) {\n+    size_t buflen = 100;\n+    char* buf = NEW_ARENA_ARRAY(C->comp_arena(), char, buflen);\n+    debug_name = debug_name_oop->const_oop()->as_instance()->java_lang_String_str(buf, buflen);\n+  }\n+  Node* vcall = make_runtime_call(RC_VECTOR,\n+                                  call_type,\n+                                  entry_addr,\n+                                  debug_name,\n+                                  TypePtr::BOTTOM,\n+                                  opd1,\n+                                  opd2);\n+\n+  vcall = gvn().transform(new ProjNode(gvn().transform(vcall), TypeFunc::Parms));\n+\n+  \/\/ Wrap it up in VectorBox to keep object type information.\n+  Node* vbox = box_vector(vcall, vbox_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n@@ -1847,44 +1914,0 @@\n-static address get_vector_math_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n-  address addr = nullptr;\n-  assert(UseVectorStubs, \"sanity\");\n-  assert(name_ptr != nullptr, \"unexpected\");\n-  assert((vop >= VectorSupport::VECTOR_OP_MATH_START) && (vop <= VectorSupport::VECTOR_OP_MATH_END), \"unexpected\");\n-  int op = vop - VectorSupport::VECTOR_OP_MATH_START;\n-\n-  switch(bits) {\n-    case 64:  \/\/fallthough\n-    case 128: \/\/fallthough\n-    case 256: \/\/fallthough\n-    case 512:\n-      if (bt == T_FLOAT) {\n-        snprintf(name_ptr, name_len, \"vector_%s_float_%dbits_fixed\", VectorSupport::mathname[op], bits);\n-        addr = StubRoutines::_vector_f_math[exact_log2(bits\/64)][op];\n-      } else {\n-        assert(bt == T_DOUBLE, \"must be FP type only\");\n-        snprintf(name_ptr, name_len, \"vector_%s_double_%dbits_fixed\", VectorSupport::mathname[op], bits);\n-        addr = StubRoutines::_vector_d_math[exact_log2(bits\/64)][op];\n-      }\n-      break;\n-    default:\n-      if (!Matcher::supports_scalable_vector() || !Matcher::vector_size_supported(bt, bits\/type2aelembytes(bt)) ) {\n-        snprintf(name_ptr, name_len, \"invalid\");\n-        addr = nullptr;\n-        Unimplemented();\n-      }\n-      break;\n-  }\n-\n-  if (addr == nullptr && Matcher::supports_scalable_vector()) {\n-    if (bt == T_FLOAT) {\n-      snprintf(name_ptr, name_len, \"vector_%s_float_%dbits_scalable\", VectorSupport::mathname[op], bits);\n-      addr = StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n-    } else {\n-      assert(bt == T_DOUBLE, \"must be FP type only\");\n-      snprintf(name_ptr, name_len, \"vector_%s_double_%dbits_scalable\", VectorSupport::mathname[op], bits);\n-      addr = StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n-    }\n-  }\n-\n-  return addr;\n-}\n-\n@@ -2047,26 +2070,0 @@\n-Node* LibraryCallKit::gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n-  assert(UseVectorStubs, \"sanity\");\n-  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_MATH_START && vector_api_op_id <= VectorSupport::VECTOR_OP_MATH_END, \"need valid op id\");\n-  assert(opd1 != nullptr, \"must not be null\");\n-  const TypeVect* vt = TypeVect::make(bt, num_elem);\n-  const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(opd2 != nullptr ? 2 : 1, vt, vt);\n-  char name[100] = \"\";\n-\n-  \/\/ Get address for vector math method.\n-  address addr = get_vector_math_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n-\n-  if (addr == nullptr) {\n-    return nullptr;\n-  }\n-\n-  assert(name[0] != '\\0', \"name must not be null\");\n-  Node* operation = make_runtime_call(RC_VECTOR,\n-                                      call_type,\n-                                      addr,\n-                                      name,\n-                                      TypePtr::BOTTOM,\n-                                      opd1,\n-                                      opd2);\n-  return gvn().transform(new ProjNode(gvn().transform(operation), TypeFunc::Parms));\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":115,"deletions":118,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -2240,0 +2240,66 @@\n+static Node* UMinMaxV_Ideal(Node* n, PhaseGVN* phase, bool can_reshape) {\n+  int vopc = n->Opcode();\n+  assert(vopc == Op_UMinV || vopc == Op_UMaxV, \"Unexpected opcode\");\n+\n+  Node* umin = nullptr;\n+  Node* umax = nullptr;\n+  int lopc = n->in(1)->Opcode();\n+  int ropc = n->in(2)->Opcode();\n+\n+  if (lopc == Op_UMinV && ropc == Op_UMaxV) {\n+    umin = n->in(1);\n+    umax = n->in(2);\n+  } else if (lopc == Op_UMaxV && ropc == Op_UMinV) {\n+    umin = n->in(2);\n+    umax = n->in(1);\n+  } else {\n+    return nullptr;\n+  }\n+\n+  \/\/ UMin (UMin(a, b), UMax(a, b))  => UMin(a, b)\n+  \/\/ UMin (UMax(a, b), UMin(b, a))  => UMin(a, b)\n+  \/\/ UMax (UMin(a, b), UMax(a, b))  => UMax(a, b)\n+  \/\/ UMax (UMax(a, b), UMin(b, a))  => UMax(a, b)\n+  if (umin != nullptr && umax != nullptr) {\n+    if ((umin->in(1) == umax->in(1) && umin->in(2) == umax->in(2)) ||\n+        (umin->in(2) == umax->in(1) && umin->in(1) == umax->in(2))) {\n+      if (vopc == Op_UMinV) {\n+        return new UMinVNode(umax->in(1), umax->in(2), n->bottom_type()->is_vect());\n+      } else {\n+        return new UMaxVNode(umax->in(1), umax->in(2), n->bottom_type()->is_vect());\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n+Node* UMinVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* progress = UMinMaxV_Ideal(this, phase, can_reshape);\n+  if (progress != nullptr) return progress;\n+\n+  return VectorNode::Ideal(phase, can_reshape);\n+}\n+\n+Node* UMinVNode::Identity(PhaseGVN* phase) {\n+  \/\/ UMin (a, a) => a\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n+\n+Node* UMaxVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* progress = UMinMaxV_Ideal(this, phase, can_reshape);\n+  if (progress != nullptr) return progress;\n+\n+  return VectorNode::Ideal(phase, can_reshape);\n+}\n+\n+Node* UMaxVNode::Identity(PhaseGVN* phase) {\n+  \/\/ UMax (a, a) => a\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -678,0 +678,2 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -681,0 +683,1 @@\n+\n@@ -694,0 +697,2 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -1087,1 +1092,1 @@\n-  virtual BasicType memory_type() const { return T_VOID; }\n+  virtual BasicType value_basic_type() const { return T_VOID; }\n@@ -1160,1 +1165,1 @@\n-  virtual BasicType memory_type() const { return T_VOID; }\n+  virtual BasicType value_basic_type() const { return T_VOID; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-    debug_only(NoSafepointVerifier nosafepoint;)\n+    DEBUG_ONLY(NoSafepointVerifier nosafepoint;)\n@@ -240,1 +240,1 @@\n-    debug_only(NoSafepointVerifier nosafepoint;)\n+    DEBUG_ONLY(NoSafepointVerifier nosafepoint;)\n@@ -415,1 +415,1 @@\n-    debug_only(id->set_is_static_field_id();)\n+    DEBUG_ONLY(id->set_is_static_field_id();)\n@@ -478,1 +478,1 @@\n-  debug_only(Klass* super2 = ( k->is_array_klass()\n+  DEBUG_ONLY(Klass* super2 = ( k->is_array_klass()\n@@ -913,1 +913,1 @@\n-      debug_only(NoSafepointVerifier nosafepoint;)\n+      DEBUG_ONLY(NoSafepointVerifier nosafepoint;)\n@@ -2065,1 +2065,1 @@\n-  debug_only(id->set_is_static_field_id();)\n+  DEBUG_ONLY(id->set_is_static_field_id();)\n@@ -2067,1 +2067,1 @@\n-  debug_only(id->verify(fd.field_holder()));\n+  DEBUG_ONLY(id->verify(fd.field_holder()));\n@@ -2496,1 +2496,1 @@\n-    bad_address = os::reserve_memory(size, false, mtInternal);\n+    bad_address = os::reserve_memory(size, mtInternal);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2323,1 +2323,1 @@\n-  debug_only(intptr_t *lastPtr = (intptr_t *)((char *)&checked_jni_NativeInterface + \\\n+  DEBUG_ONLY(intptr_t *lastPtr = (intptr_t *)((char *)&checked_jni_NativeInterface + \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-    <xsl:text>debug_only(VMNativeEntryWrapper __vew;)<\/xsl:text>\n+    <xsl:text>DEBUG_ONLY(VMNativeEntryWrapper __vew;)<\/xsl:text>\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnter.xsl","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-    debug_only(VMNativeEntryWrapper __vew;)\n+    DEBUG_ONLY(VMNativeEntryWrapper __vew;)\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -387,1 +387,1 @@\n-    debug_only(VMNativeEntryWrapper __vew;)\n+    DEBUG_ONLY(VMNativeEntryWrapper __vew;)\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-    debug_only(NoSafepointVerifier nosafepoint;)\n+    DEBUG_ONLY(NoSafepointVerifier nosafepoint;)\n@@ -157,1 +157,1 @@\n-    debug_only(NoSafepointVerifier nosafepoint;)\n+    DEBUG_ONLY(NoSafepointVerifier nosafepoint;)\n@@ -762,1 +762,1 @@\n-    debug_only(NoSafepointVerifier nosafepoint;)\n+    DEBUG_ONLY(NoSafepointVerifier nosafepoint;)\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    debug_only(warning(\"unexpected units argument, units = %d\", units));\n+    DEBUG_ONLY(warning(\"unexpected units argument, units = %d\", units));\n@@ -153,1 +153,1 @@\n-    debug_only(warning(\"unexpected variability value: %d\", variability));\n+    DEBUG_ONLY(warning(\"unexpected variability value: %d\", variability));\n@@ -182,1 +182,1 @@\n-    debug_only(warning(\"unexpected variability value: %d\", variability));\n+    DEBUG_ONLY(warning(\"unexpected variability value: %d\", variability));\n@@ -189,1 +189,1 @@\n-    debug_only(warning(\"unexpected units value: %d\", variability));\n+    DEBUG_ONLY(warning(\"unexpected units value: %d\", variability));\n","filename":"src\/hotspot\/share\/prims\/perf.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-  debug_only(thread->inc_java_call_counter());\n+  DEBUG_ONLY(thread->inc_java_call_counter());\n@@ -121,1 +121,1 @@\n-  debug_only(thread->dec_java_call_counter());\n+  DEBUG_ONLY(thread->dec_java_call_counter());\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"opto\/vectornode.hpp\"\n@@ -44,23 +45,0 @@\n-#ifdef COMPILER2\n-const char* VectorSupport::mathname[VectorSupport::NUM_VECTOR_OP_MATH] = {\n-    \"tan\",\n-    \"tanh\",\n-    \"sin\",\n-    \"sinh\",\n-    \"cos\",\n-    \"cosh\",\n-    \"asin\",\n-    \"acos\",\n-    \"atan\",\n-    \"atan2\",\n-    \"cbrt\",\n-    \"log\",\n-    \"log10\",\n-    \"log1p\",\n-    \"pow\",\n-    \"exp\",\n-    \"expm1\",\n-    \"hypot\",\n-};\n-#endif\n-\n@@ -618,19 +596,0 @@\n-    case VECTOR_OP_TAN:\n-    case VECTOR_OP_TANH:\n-    case VECTOR_OP_SIN:\n-    case VECTOR_OP_SINH:\n-    case VECTOR_OP_COS:\n-    case VECTOR_OP_COSH:\n-    case VECTOR_OP_ASIN:\n-    case VECTOR_OP_ACOS:\n-    case VECTOR_OP_ATAN:\n-    case VECTOR_OP_ATAN2:\n-    case VECTOR_OP_CBRT:\n-    case VECTOR_OP_LOG:\n-    case VECTOR_OP_LOG10:\n-    case VECTOR_OP_LOG1P:\n-    case VECTOR_OP_POW:\n-    case VECTOR_OP_EXP:\n-    case VECTOR_OP_EXPM1:\n-    case VECTOR_OP_HYPOT:\n-      return Op_CallLeafVector;\n@@ -658,0 +617,8 @@\n+JVM_ENTRY(jstring, VectorSupport_GetCPUFeatures(JNIEnv* env, jclass ignored))\n+  const char* features_string = VM_Version::features_string();\n+  assert(features_string != nullptr, \"missing cpu features info\");\n+\n+  oop result = java_lang_String::create_oop_from_str(features_string, CHECK_NULL);\n+  return (jstring) JNIHandles::make_local(THREAD, result);\n+JVM_END\n+\n@@ -662,0 +629,1 @@\n+#define LSTR LANG \"String;\"\n@@ -667,1 +635,2 @@\n-    {CC \"getMaxLaneCount\",   CC \"(\" CLS \")I\", FN_PTR(VectorSupport_GetMaxLaneCount)}\n+    {CC \"getMaxLaneCount\", CC \"(\" CLS \")I\", FN_PTR(VectorSupport_GetMaxLaneCount)},\n+    {CC \"getCPUFeatures\",  CC \"()\" LSTR,    FN_PTR(VectorSupport_GetCPUFeatures)}\n@@ -675,0 +644,1 @@\n+#undef LSTR\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":13,"deletions":43,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -104,20 +104,0 @@\n-    \/\/ Vector Math Library\n-    VECTOR_OP_TAN   = 101,\n-    VECTOR_OP_TANH  = 102,\n-    VECTOR_OP_SIN   = 103,\n-    VECTOR_OP_SINH  = 104,\n-    VECTOR_OP_COS   = 105,\n-    VECTOR_OP_COSH  = 106,\n-    VECTOR_OP_ASIN  = 107,\n-    VECTOR_OP_ACOS  = 108,\n-    VECTOR_OP_ATAN  = 109,\n-    VECTOR_OP_ATAN2 = 110,\n-    VECTOR_OP_CBRT  = 111,\n-    VECTOR_OP_LOG   = 112,\n-    VECTOR_OP_LOG10 = 113,\n-    VECTOR_OP_LOG1P = 114,\n-    VECTOR_OP_POW   = 115,\n-    VECTOR_OP_EXP   = 116,\n-    VECTOR_OP_EXPM1 = 117,\n-    VECTOR_OP_HYPOT = 118,\n-\n@@ -130,4 +110,0 @@\n-\n-    VECTOR_OP_MATH_START = VECTOR_OP_TAN,\n-    VECTOR_OP_MATH_END   = VECTOR_OP_HYPOT,\n-    NUM_VECTOR_OP_MATH   = VECTOR_OP_MATH_END - VECTOR_OP_MATH_START + 1\n@@ -150,2 +126,0 @@\n-  static const char* mathname[VectorSupport::NUM_VECTOR_OP_MATH];\n-\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -736,1 +736,1 @@\n-  return (jlong)(uintptr_t)os::reserve_memory(size, false, mtTest);\n+  return (jlong)(uintptr_t)os::reserve_memory(size, mtTest);\n@@ -740,1 +740,1 @@\n-  return (jlong)(uintptr_t)os::attempt_reserve_memory_at((char*)(uintptr_t)addr, (size_t)size, false, mtTest);\n+  return (jlong)(uintptr_t)os::attempt_reserve_memory_at((char*)(uintptr_t)addr, (size_t)size, mtTest);\n@@ -1532,1 +1532,1 @@\n-  p = os::reserve_memory(os::vm_allocation_granularity());\n+  p = os::reserve_memory(os::vm_allocation_granularity(), mtTest);\n@@ -1541,1 +1541,1 @@\n-  const char* features = VM_Version::features_string();\n+  const char* features = VM_Version::cpu_info_string();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+const char* Abstract_VM_Version::_cpu_info_string = \"\";\n@@ -343,0 +344,13 @@\n+const char* Abstract_VM_Version::extract_features_string(const char* cpu_info_string,\n+                                                         size_t cpu_info_string_len,\n+                                                         size_t features_offset) {\n+  assert(features_offset <= cpu_info_string_len, \"\");\n+  if (features_offset < cpu_info_string_len) {\n+    assert(cpu_info_string[features_offset + 0] == ',', \"\");\n+    assert(cpu_info_string[features_offset + 1] == ' ', \"\");\n+    return cpu_info_string + features_offset + 2; \/\/ skip initial \", \"\n+  } else {\n+    return \"\"; \/\/ empty\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+  static const char* _cpu_info_string;\n+\n@@ -131,0 +133,1 @@\n+  static const char* cpu_info_string() { return _cpu_info_string; }\n@@ -132,0 +135,3 @@\n+  static const char* extract_features_string(const char* cpu_info_string,\n+                                             size_t cpu_info_string_len,\n+                                             size_t features_offset);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -336,1 +336,0 @@\n-        matches_property_suffix(property_suffix, ADDOPENS, ADDOPENS_LEN) ||\n@@ -347,0 +346,1 @@\n+          matches_property_suffix(property_suffix, ADDOPENS, ADDOPENS_LEN) ||\n@@ -3882,5 +3882,0 @@\n-\n-    if (!FLAG_IS_DEFAULT(UseVectorStubs) && UseVectorStubs) {\n-      warning(\"Disabling UseVectorStubs since EnableVectorSupport is turned off.\");\n-    }\n-    FLAG_SET_DEFAULT(UseVectorStubs, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  debug_only(_area->_handle_mark_nesting++);\n+  DEBUG_ONLY(_area->_handle_mark_nesting++);\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,2 +193,2 @@\n-    debug_only(_handle_mark_nesting    = 0);\n-    debug_only(_no_handle_mark_nesting = 0);\n+    DEBUG_ONLY(_handle_mark_nesting    = 0);\n+    DEBUG_ONLY(_no_handle_mark_nesting = 0);\n@@ -217,1 +217,1 @@\n-  debug_only(bool no_handle_mark_active() { return _no_handle_mark_nesting > 0; })\n+  DEBUG_ONLY(bool no_handle_mark_active() { return _no_handle_mark_nesting > 0; })\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  debug_only(_area->_handle_mark_nesting++);\n+  DEBUG_ONLY(_area->_handle_mark_nesting++);\n@@ -99,1 +99,1 @@\n-  debug_only(_area->_handle_mark_nesting--);\n+  DEBUG_ONLY(_area->_handle_mark_nesting--);\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-  debug_only(NoHandleMark __hm;)                                     \\\n+  DEBUG_ONLY(NoHandleMark __hm;)                                     \\\n@@ -267,1 +267,1 @@\n-  debug_only(ResetNoHandleMark __rnhm;)                              \\\n+  DEBUG_ONLY(ResetNoHandleMark __rnhm;)                              \\\n@@ -289,1 +289,1 @@\n-    debug_only(VMEntryWrapper __vew;)\n+    DEBUG_ONLY(VMEntryWrapper __vew;)\n@@ -308,1 +308,1 @@\n-  debug_only(NoSafepointVerifier __nsv;)\n+  DEBUG_ONLY(NoSafepointVerifier __nsv;)\n@@ -317,1 +317,1 @@\n-    debug_only(VMEntryWrapper __vew;)\n+    DEBUG_ONLY(VMEntryWrapper __vew;)\n@@ -332,1 +332,1 @@\n-    debug_only(VMEntryWrapper __vew;)\n+    DEBUG_ONLY(VMEntryWrapper __vew;)\n@@ -339,1 +339,1 @@\n-    debug_only(VMEntryWrapper __vew;)\n+    DEBUG_ONLY(VMEntryWrapper __vew;)\n@@ -363,1 +363,1 @@\n-    debug_only(VMNativeEntryWrapper __vew;)                          \\\n+    DEBUG_ONLY(VMNativeEntryWrapper __vew;)                          \\\n@@ -388,1 +388,1 @@\n-    debug_only(VMNativeEntryWrapper __vew;)                          \\\n+    DEBUG_ONLY(VMNativeEntryWrapper __vew;)                          \\\n@@ -398,1 +398,1 @@\n-    debug_only(VMNativeEntryWrapper __vew;)                          \\\n+    DEBUG_ONLY(VMNativeEntryWrapper __vew;)                          \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  debug_only(_thread->inc_java_call_counter());\n+  DEBUG_ONLY(_thread->inc_java_call_counter());\n@@ -113,1 +113,1 @@\n-  debug_only(_thread->dec_java_call_counter());\n+  DEBUG_ONLY(_thread->dec_java_call_counter());\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -557,1 +557,1 @@\n-  debug_only(check_for_dangling_thread_pointer(this);)\n+  DEBUG_ONLY(check_for_dangling_thread_pointer(this);)\n@@ -573,1 +573,1 @@\n-  debug_only(check_for_dangling_thread_pointer(this);)\n+  DEBUG_ONLY(check_for_dangling_thread_pointer(this);)\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-      debug_only(id->set_is_static_field_id());\n+      DEBUG_ONLY(id->set_is_static_field_id());\n","filename":"src\/hotspot\/share\/runtime\/jfieldIDWorkaround.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -385,3 +385,3 @@\n-  debug_only(block->_last = nullptr);\n-  debug_only(block->_free_list = nullptr);\n-  debug_only(block->_allocate_before_rebuild = -1);\n+  DEBUG_ONLY(block->_last = nullptr);\n+  DEBUG_ONLY(block->_free_list = nullptr);\n+  DEBUG_ONLY(block->_allocate_before_rebuild = -1);\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1808,1 +1808,1 @@\n-  Thread::SpinAcquire(&_wait_set_lock, \"wait_set - add\");\n+  Thread::SpinAcquire(&_wait_set_lock);\n@@ -1867,1 +1867,1 @@\n-      Thread::SpinAcquire(&_wait_set_lock, \"wait_set - unlink\");\n+      Thread::SpinAcquire(&_wait_set_lock);\n@@ -1983,1 +1983,1 @@\n-  Thread::SpinAcquire(&_wait_set_lock, \"wait_set - notify\");\n+  Thread::SpinAcquire(&_wait_set_lock);\n@@ -2123,1 +2123,1 @@\n-  Thread::SpinAcquire(&_wait_set_lock, \"wait_set - add\");\n+  Thread::SpinAcquire(&_wait_set_lock);\n@@ -2146,1 +2146,1 @@\n-    Thread::SpinAcquire(&_wait_set_lock, \"wait_set - unlink\");\n+    Thread::SpinAcquire(&_wait_set_lock);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -80,0 +81,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -120,1 +122,1 @@\n-  ALLOW_C_FUNCTION(::vsnprintf, int result = ::vsnprintf(buf, len, fmt, args);)\n+  int result = permit_forbidden_function::vsnprintf(buf, len, fmt, args);\n@@ -244,1 +246,1 @@\n-  debug_only(Thread::check_for_dangling_thread_pointer(thread);)\n+  DEBUG_ONLY(Thread::check_for_dangling_thread_pointer(thread);)\n@@ -599,1 +601,1 @@\n-  strcpy(dup_str, str);\n+  memcpy(dup_str, str, size + 1);\n@@ -657,1 +659,1 @@\n-  ALLOW_C_FUNCTION(::malloc, void* const outer_ptr = ::malloc(outer_size);)\n+  void* const outer_ptr = permit_forbidden_function::malloc(outer_size);\n@@ -724,1 +726,1 @@\n-    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(header, new_outer_size);)\n+    void* const new_outer_ptr = permit_forbidden_function::realloc(header, new_outer_size);\n@@ -752,1 +754,1 @@\n-    ALLOW_C_FUNCTION(::realloc, rc = ::realloc(memblock, size);)\n+    rc = permit_forbidden_function::realloc(memblock, size);\n@@ -780,1 +782,1 @@\n-  ALLOW_C_FUNCTION(::free, ::free(old_outer_ptr);)\n+  permit_forbidden_function::free(old_outer_ptr);\n@@ -1169,1 +1171,1 @@\n-  st->print(\" %s\", VM_Version::features_string());\n+  st->print(\" %s\", VM_Version::cpu_info_string());\n@@ -1969,1 +1971,1 @@\n-char* os::reserve_memory(size_t bytes, bool executable, MemTag mem_tag) {\n+char* os::reserve_memory(size_t bytes, MemTag mem_tag, bool executable) {\n@@ -1980,1 +1982,1 @@\n-char* os::attempt_reserve_memory_at(char* addr, size_t bytes, bool executable, MemTag mem_tag) {\n+char* os::attempt_reserve_memory_at(char* addr, size_t bytes, MemTag mem_tag, bool executable) {\n@@ -2186,1 +2188,1 @@\n-    MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);\n+    MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC, mtNone);\n@@ -2363,2 +2365,2 @@\n-                           char *addr, size_t bytes, bool read_only,\n-                           bool allow_exec, MemTag mem_tag) {\n+                           char *addr, size_t bytes, MemTag mem_tag,\n+                            bool read_only, bool allow_exec) {\n@@ -2402,1 +2404,1 @@\n-    MemTracker::record_virtual_memory_reserve_and_commit((address)result, size, CALLER_PC);\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)result, size, CALLER_PC, mtNone);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -460,1 +460,1 @@\n-  static char*  reserve_memory(size_t bytes, bool executable = false, MemTag mem_tag = mtNone);\n+  static char*  reserve_memory(size_t bytes, MemTag mem_tag, bool executable = false);\n@@ -463,1 +463,1 @@\n-  static char*  reserve_memory_aligned(size_t size, size_t alignment, bool executable = false);\n+  static char*  reserve_memory_aligned(size_t size, size_t alignment, MemTag mem_tag, bool executable = false);\n@@ -467,1 +467,1 @@\n-  static char*  attempt_reserve_memory_at(char* addr, size_t bytes, bool executable = false, MemTag mem_tag = mtNone);\n+  static char*  attempt_reserve_memory_at(char* addr, size_t bytes, MemTag mem_tag, bool executable = false);\n@@ -519,2 +519,2 @@\n-  static char* map_memory_to_file(size_t size, int fd, MemTag mem_tag = mtNone);\n-  static char* map_memory_to_file_aligned(size_t size, size_t alignment, int fd, MemTag mem_tag = mtNone);\n+  static char* map_memory_to_file(size_t size, int fd, MemTag mem_tag);\n+  static char* map_memory_to_file_aligned(size_t size, size_t alignment, int fd, MemTag mem_tag);\n@@ -522,1 +522,1 @@\n-  static char* attempt_map_memory_to_file_at(char* base, size_t size, int fd, MemTag mem_tag = mtNone);\n+  static char* attempt_map_memory_to_file_at(char* base, size_t size, int fd, MemTag mem_tag);\n@@ -527,2 +527,2 @@\n-                           char *addr, size_t bytes, bool read_only = false,\n-                           bool allow_exec = false, MemTag mem_tag = mtNone);\n+                           char *addr, size_t bytes, MemTag mem_tag, bool read_only = false,\n+                           bool allow_exec = false);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  Thread::SpinAcquire(&ListLock, \"ParkEventFreeListAllocate\");\n+  Thread::SpinAcquire(&ListLock);\n@@ -91,1 +91,1 @@\n-  Thread::SpinAcquire(&ListLock, \"ParkEventFreeListRelease\");\n+  Thread::SpinAcquire(&ListLock);\n","filename":"src\/hotspot\/share\/runtime\/park.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,4 +120,0 @@\n-  public:\n-    volatile int TState ;\n-    volatile int Notified ;             \/\/ for native monitor construct\n-\n@@ -140,2 +136,0 @@\n-       TState         = 0 ;\n-       Notified       = 0 ;\n","filename":"src\/hotspot\/share\/runtime\/park.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    char* polling_page = os::reserve_memory(allocation_size, !ExecMem, mtSafepoint);\n+    char* polling_page = os::reserve_memory(allocation_size, mtSafepoint);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2845,1 +2845,1 @@\n-                if (super_method->is_scalarized_arg(arg_num) debug_only(|| (stress && (os::random() & 1) == 1))) {\n+                if (super_method->is_scalarized_arg(arg_num) DEBUG_ONLY(|| (stress && (os::random() & 1) == 1))) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,2 +104,0 @@\n-address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n-address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,4 +311,0 @@\n-  \/\/ Vector Math Routines\n-  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n-  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  debug_only(_owned_locks = nullptr;)\n+  DEBUG_ONLY(_owned_locks = nullptr;)\n@@ -382,1 +382,1 @@\n-  debug_only(check_for_dangling_thread_pointer(thread);)\n+  DEBUG_ONLY(check_for_dangling_thread_pointer(thread);)\n@@ -491,1 +491,1 @@\n-  debug_only(if (WizardMode) print_owned_locks_on(st);)\n+  DEBUG_ONLY(if (WizardMode) print_owned_locks_on(st);)\n@@ -565,1 +565,1 @@\n-void Thread::SpinAcquire(volatile int * adr, const char * LockName) {\n+void Thread::SpinAcquire(volatile int * adr) {\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -608,1 +608,1 @@\n-  static void SpinAcquire(volatile int * Lock, const char * Name);\n+  static void SpinAcquire(volatile int * Lock);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -707,0 +707,1 @@\n+     static_field(Abstract_VM_Version,         _cpu_info_string,                              const char*)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"memory\/metaspaceUtils.hpp\"\n@@ -415,1 +416,2 @@\n-  Universe::heap()->print_on(output());\n+  Universe::heap()->print_heap_on(output());\n+  MetaspaceUtils::print_on(output());\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -555,1 +555,1 @@\n-  debug_only(_sub_record_left -= len);\n+  DEBUG_ONLY(_sub_record_left -= len);\n@@ -567,1 +567,1 @@\n-  debug_only(_sub_record_left -= len);\n+  DEBUG_ONLY(_sub_record_left -= len);\n@@ -691,2 +691,2 @@\n-  debug_only(_sub_record_left = len);\n-  debug_only(_sub_record_ended = false);\n+  DEBUG_ONLY(_sub_record_left = len);\n+  DEBUG_ONLY(_sub_record_ended = false);\n@@ -701,1 +701,1 @@\n-  debug_only(_sub_record_ended = true);\n+  DEBUG_ONLY(_sub_record_ended = true);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-  debug_only(Thread::check_for_dangling_thread_pointer(thread);)\n+  DEBUG_ONLY(Thread::check_for_dangling_thread_pointer(thread);)\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -691,1 +691,1 @@\n-void BitMap::print_on_error(outputStream* st, const char* prefix) const {\n+void BitMap::print_range_on(outputStream* st, const char* prefix) const {\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -396,1 +396,1 @@\n-  void print_on_error(outputStream* st, const char* prefix) const;\n+  void print_range_on(outputStream* st, const char* prefix) const;\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,7 @@\n+\n+\/\/ FORBID_C_FUNCTION(Signature, Alternative)\n+\/\/ - Signature: the function that should not normally be used.\n+\/\/ - Alternative: a string literal that may be used in a warning about a use,\n+\/\/   often suggesting an alternative.\n+\/\/ Declares the C-linkage function designated by Signature to be deprecated,\n+\/\/ using the `deprecated` attribute with Alternative as an argument.\n@@ -92,4 +99,5 @@\n-\/\/ FORBID_C_FUNCTION(signature, alternative)\n-\/\/ - signature: the function that should not normally be used.\n-\/\/ - alternative: a string that may be used in a warning about a use, typically\n-\/\/   suggesting an alternative.\n+\/\/ The variants with IMPORTED in the name are to deal with Windows\n+\/\/ requirements, using FORBIDDEN_FUNCTION_IMPORT_SPEC.  See the Visual\n+\/\/ Studio definition of that macro for more details.  The default has\n+\/\/ an empty expansion.  The potentially added spec must precede the\n+\/\/ base signature but follow all attributes.\n@@ -97,4 +105,9 @@\n-\/\/ ALLOW_C_FUNCTION(name, ... using statement ...)\n-\/\/ - name: the name of a forbidden function whose use is permitted in statement.\n-\/\/ - statement: a use of the otherwise forbidden function.  Using a variadic\n-\/\/   tail allows the statement to contain non-nested commas.\n+\/\/ FORBID_NORETURN_C_FUNCTION deals with a clang issue.  See the clang\n+\/\/ definition of FORBIDDEN_FUNCTION_NORETURN_ATTRIBUTE for more\n+\/\/ details.  The default expands to `[[noreturn]]`.\n+#define FORBID_C_FUNCTION(Signature, Alternative) \\\n+  extern \"C\" { [[deprecated(Alternative)]] Signature; }\n+\n+#ifndef FORBIDDEN_FUNCTION_IMPORT_SPEC\n+#define FORBIDDEN_FUNCTION_IMPORT_SPEC\n+#endif\n@@ -102,2 +115,2 @@\n-#ifndef FORBID_C_FUNCTION\n-#define FORBID_C_FUNCTION(signature, alternative)\n+#ifndef FORBIDDEN_FUNCTION_NORETURN_ATTRIBUTE\n+#define FORBIDDEN_FUNCTION_NORETURN_ATTRIBUTE [[noreturn]]\n@@ -106,2 +119,2 @@\n-#ifndef ALLOW_C_FUNCTION\n-#define ALLOW_C_FUNCTION(name, ...) __VA_ARGS__\n+#ifndef FORBIDDEN_FUNCTION_IGNORE_CLANG_FORTIFY_WARNING\n+#define FORBIDDEN_FUNCTION_IGNORE_CLANG_FORTIFY_WARNING\n@@ -110,0 +123,25 @@\n+#define FORBID_IMPORTED_C_FUNCTION(Signature, Alternative) \\\n+  FORBID_C_FUNCTION(FORBIDDEN_FUNCTION_IMPORT_SPEC Signature, Alternative)\n+\n+#define FORBID_NORETURN_C_FUNCTION(Signature, Alternative) \\\n+  FORBID_C_FUNCTION(FORBIDDEN_FUNCTION_NORETURN_ATTRIBUTE Signature, Alternative)\n+\n+#define FORBID_IMPORTED_NORETURN_C_FUNCTION(Signature, Alternative) \\\n+  FORBID_NORETURN_C_FUNCTION(FORBIDDEN_FUNCTION_IMPORT_SPEC Signature, Alternative)\n+\n+\/\/ A BEGIN\/END_ALLOW_FORBIDDEN_FUNCTIONS pair establishes a scope in which the\n+\/\/ deprecation warnings used to forbid the use of certain functions are\n+\/\/ suppressed.  These macros are not intended for warning suppression at\n+\/\/ individual call sites; see permitForbiddenFunctions.hpp for the approach\n+\/\/ taken for that where needed.  Rather, these are used to suppress warnings\n+\/\/ from 3rd-party code included by HotSpot, such as the gtest framework and\n+\/\/ C++ Standard Library headers, which may refer to functions that are\n+\/\/ disallowed in other parts of HotSpot.  They are also used in the\n+\/\/ implementation of the \"permit\" mechanism.\n+#define BEGIN_ALLOW_FORBIDDEN_FUNCTIONS         \\\n+  PRAGMA_DIAG_PUSH                              \\\n+  PRAGMA_DEPRECATED_IGNORED\n+\n+#define END_ALLOW_FORBIDDEN_FUNCTIONS           \\\n+  PRAGMA_DIAG_POP\n+\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings.hpp","additions":51,"deletions":13,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,4 +73,2 @@\n-#if (__GNUC__ >= 10)\n-\/\/ TODO: Re-enable warning attribute for Clang once\n-\/\/ https:\/\/github.com\/llvm\/llvm-project\/issues\/56519 is fixed and released.\n-\/\/ || (defined(__clang_major__) && (__clang_major__ >= 14))\n+#define PRAGMA_DEPRECATED_IGNORED \\\n+  PRAGMA_DISABLE_GCC_WARNING(\"-Wdeprecated-declarations\")\n@@ -78,1 +76,1 @@\n-\/\/ Use \"warning\" attribute to detect uses of \"forbidden\" functions.\n+\/\/ This macro is used by the NORETURN variants of FORBID_C_FUNCTION.\n@@ -80,2 +78,2 @@\n-\/\/ Note: The warning attribute is available since GCC 9, but disabling pragmas\n-\/\/ does not work reliably in ALLOW_C_FUNCTION. GCC 10+ and up work fine.\n+\/\/ The [[noreturn]] attribute requires that the first declaration of a\n+\/\/ function has it if any have it.\n@@ -83,17 +81,58 @@\n-\/\/ Note: _FORTIFY_SOURCE transforms calls to certain functions into calls to\n-\/\/ associated \"checking\" functions, and that transformation seems to occur\n-\/\/ *before* the attribute check.  We use fortification in fastdebug builds,\n-\/\/ so uses of functions that are both forbidden and fortified won't cause\n-\/\/ forbidden warnings in such builds.\n-#define FORBID_C_FUNCTION(signature, alternative) \\\n-  extern \"C\" __attribute__((__warning__(alternative))) signature;\n-\n-\/\/ Disable warning attribute over the scope of the affected statement.\n-\/\/ The name serves only to document the intended function.\n-#define ALLOW_C_FUNCTION(name, ...)                     \\\n-  PRAGMA_DIAG_PUSH                                      \\\n-  PRAGMA_DISABLE_GCC_WARNING(\"-Wattribute-warning\")     \\\n-  __VA_ARGS__                                           \\\n-  PRAGMA_DIAG_POP\n-\n-#endif \/\/ gcc10+\n+\/\/ gcc, clang, and MSVC all provide compiler-specific alternatives to that\n+\/\/ attribute: __attribute__((noreturn)) for gcc and clang,\n+\/\/ __declspec(noreturn) for MSVC and clang. gcc and MSVC treat their\n+\/\/ respective compiler-specific alternatives as satisfying that requirement.\n+\/\/ clang does not.\n+\/\/\n+\/\/ So clang warns if we use [[noreturn]] in the forbidding declaration and the\n+\/\/ library header has already been included and uses the compiler-specific\n+\/\/ attribute. Similarly, clang warns if we use the compiler-specific attribute\n+\/\/ while the library uses [[noreturn]] and the library header is included\n+\/\/ after the forbidding declaration.\n+\/\/\n+\/\/ For now, we're only going to worry about the standard library, and not\n+\/\/ noreturn functions in some other library that we might want to forbid in\n+\/\/ the future.  If there's more than one library to be accounted for, then\n+\/\/ things may get more complicated.\n+\/\/\n+\/\/ There are several ways we could deal with this.\n+\/\/\n+\/\/ Probably the most robust is to use the same style of noreturn attribute as\n+\/\/ is used by the library providing the function.  That way it doesn't matter\n+\/\/ in which order the inclusion of the library header and the forbidding are\n+\/\/ performed.  We could use configure to determine which to use and provide a\n+\/\/ macro to select on here.\n+\/\/\n+\/\/ Another approach is to always use __attribute__ noreturn in the forbidding\n+\/\/ declaration, but ensure the relevant library header has been included\n+\/\/ before the forbidding declaration.  Since there are currently only a couple\n+\/\/ of affected functions, this is easier to implement.  So this is the\n+\/\/ approach being taken for now.\n+\/\/\n+\/\/ clang's failure to treat the compiler-specific form as counting toward the\n+\/\/ [[noreturn]] requirement is arguably a clang bug.\n+\/\/ https:\/\/github.com\/llvm\/llvm-project\/issues\/131700\n+\n+#ifdef __clang__\n+#define FORBIDDEN_FUNCTION_NORETURN_ATTRIBUTE __attribute__((__noreturn__))\n+#endif\n+\n+\/\/ This macro is used to suppress a warning for some uses of FORBID_C_FUNCTION.\n+\/\/\n+\/\/ libstdc++ provides inline definitions of some functions to support\n+\/\/ _FORTIFY_SOURCE.  clang warns about our forbidding declaration adding the\n+\/\/ [[deprecated]] attribute following such a definition:\n+\/\/ \"warning: attribute declaration must precede definition [-Wignored-attributes]\"\n+\/\/ Use this macro to suppress the warning, not getting protection when using\n+\/\/ that combination.  Other build combinations should provide sufficient\n+\/\/ coverage.\n+\/\/\n+\/\/ clang's warning in this case is arguably a clang bug.\n+\/\/ https:\/\/github.com\/llvm\/llvm-project\/issues\/135481\n+\/\/ This issue has been fixed, with the fix probably appearing in clang 21.\n+#if defined(__clang__) && defined(_FORTIFY_SOURCE)\n+#if _FORTIFY_SOURCE > 0\n+#define FORBIDDEN_FUNCTION_IGNORE_CLANG_FORTIFY_WARNING \\\n+  PRAGMA_DISABLE_GCC_WARNING(\"-Wignored-attributes\")\n+#endif\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings_gcc.hpp","additions":64,"deletions":25,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,26 +33,1 @@\n-\/\/ The Visual Studio implementation of FORBID_C_FUNCTION explicitly does\n-\/\/ nothing, because there doesn't seem to be a way to implement it for Visual\n-\/\/ Studio.  What seems the most likely approach is to use deprecation warnings,\n-\/\/ but that runs into problems.\n-\/\/\n-\/\/ (1) Declaring the function deprecated (using either __declspec(deprecated)\n-\/\/ or the C++14 [[deprecated]] attribute) fails with warnings like this:\n-\/\/   warning C4273: 'exit': inconsistent dll linkage\n-\/\/ It seems attributes are not simply additive with this compiler.\n-\/\/\n-\/\/ (2) Additionally adding __declspec(dllimport) to deal with (1) fails with\n-\/\/ warnings like this:\n-\/\/   error C2375: 'vsnprintf': redefinition; different linkage\n-\/\/ It seems some functions in the set of interest have different linkage than\n-\/\/ others (\"exit\" is marked imported while \"vsnprintf\" is not, for example).\n-\/\/ That makes it difficult to provide a generic macro.\n-\/\/\n-\/\/ (3) Using __pragma(deprecated(name)) fails with\n-\/\/   warning C4995: 'frobnicate': name was marked as #pragma deprecated\n-\/\/ for a *declaration* (not a use) of a 'frobnicate' function.\n-\/\/\n-\/\/ ALLOW_C_FUNCTIONS disables deprecation warnings over the statement scope.\n-\/\/ Some of the functions we're interested in allowing are conditionally\n-\/\/ deprecated on Windows, under the control of various preprocessor defines\n-\/\/ such as _CRT_SECURE_NO_WARNINGS.  Annotating vetted uses allows those\n-\/\/ warnings to catch unchecked uses.\n+#define PRAGMA_DEPRECATED_IGNORED PRAGMA_DISABLE_MSVC_WARNING(4996)\n@@ -60,1 +35,8 @@\n-#define FORBID_C_FUNCTION(signature, alternative)\n+\/\/ This macro is used by the IMPORTED variants of FORBID_C_FUNCTION.\n+\/\/\n+\/\/ Some, but not all, functions we want to forbid using must include a\n+\/\/ `__declspec(dllimport)` in the declaration.  Failure to do so where needed\n+\/\/ leads to \"redefinition; different linkage\" errors for the forbidding\n+\/\/ declaration. But including a dllimport specifier if not present in the\n+\/\/ compiler's header leads to the same errors.  It seems one must just know\n+\/\/ which are imported and which are not, and use the specifier accordingly.\n@@ -62,5 +44,1 @@\n-#define ALLOW_C_FUNCTION(name, ...)             \\\n-  PRAGMA_DIAG_PUSH                              \\\n-  PRAGMA_DISABLE_MSVC_WARNING(4996)             \\\n-  __VA_ARGS__                                   \\\n-  PRAGMA_DIAG_POP\n+#define FORBIDDEN_FUNCTION_IMPORT_SPEC __declspec(dllimport)\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings_visCPP.hpp","additions":11,"deletions":33,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -715,1 +715,1 @@\n-  char* page = os::reserve_memory(os::vm_page_size(), !ExecMem, mtInternal);\n+  char* page = os::reserve_memory(os::vm_page_size(), mtInternal);\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -543,0 +543,1 @@\n+    ResourceMark rm;\n@@ -554,0 +555,1 @@\n+      ResourceMark rm;\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_FORBIDDENFUNCTIONS_HPP\n+#define SHARE_UTILITIES_FORBIDDENFUNCTIONS_HPP\n+\n+#include \"utilities\/compilerWarnings.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/ For types used in the signatures.\n+#include <stdarg.h>\n+#include <stddef.h>\n+\n+\/\/ Workaround for noreturn functions: exit, _exit, _Exit - see the clang\n+\/\/ definition of FORBIDDEN_FUNCTION_NORETURN_ATTRIBUTE.\n+#ifdef __clang__\n+#include <stdlib.h>\n+#endif\n+\n+#ifdef _WINDOWS\n+#include \"forbiddenFunctions_windows.hpp\"\n+#else\n+#include \"forbiddenFunctions_posix.hpp\"\n+#endif\n+\n+\/\/ Forbid the use of various C library functions.  Some of these have os::\n+\/\/ replacements that should be used instead.  Others are considered obsolete\n+\/\/ or have security concerns, either with preferred alternatives, or to be\n+\/\/ avoided entirely.\n+\n+FORBID_IMPORTED_NORETURN_C_FUNCTION(void exit(int), \"use os::exit\")\n+FORBID_IMPORTED_NORETURN_C_FUNCTION(void _Exit(int), \"use os::exit\")\n+\n+\/\/ Windows puts _exit in <stdlib.h>, POSIX in <unistd.h>.\n+FORBID_IMPORTED_NORETURN_C_FUNCTION(void _exit(int), \"use os::exit\")\n+\n+FORBID_IMPORTED_C_FUNCTION(char* strerror(int), \"use os::strerror\");\n+FORBID_IMPORTED_C_FUNCTION(char* strtok(char*, const char*), \"use strtok_r\");\n+\n+FORBID_C_FUNCTION(int sprintf(char*, const char*, ...), \"use os::snprintf\");\n+\n+PRAGMA_DIAG_PUSH\n+FORBIDDEN_FUNCTION_IGNORE_CLANG_FORTIFY_WARNING\n+FORBID_C_FUNCTION(int vsprintf(char*, const char*, va_list), \"use os::vsnprintf\");\n+FORBID_C_FUNCTION(int vsnprintf(char*, size_t, const char*, va_list), \"use os::vsnprintf\");\n+PRAGMA_DIAG_POP\n+\n+\/\/ All of the following functions return raw C-heap pointers (sometimes as an\n+\/\/ option, e.g. realpath or getwd) or, in case of free(), take raw C-heap\n+\/\/ pointers.  We generally want allocation to be done through NMT.\n+FORBID_IMPORTED_C_FUNCTION(void* malloc(size_t size), \"use os::malloc\");\n+FORBID_IMPORTED_C_FUNCTION(void free(void *ptr), \"use os::free\");\n+FORBID_IMPORTED_C_FUNCTION(void* calloc(size_t nmemb, size_t size), \"use os::malloc and zero out manually\");\n+FORBID_IMPORTED_C_FUNCTION(void* realloc(void *ptr, size_t size), \"use os::realloc\");\n+FORBID_IMPORTED_C_FUNCTION(char* strdup(const char *s), \"use os::strdup\");\n+FORBID_IMPORTED_C_FUNCTION(wchar_t* wcsdup(const wchar_t *s), \"don't use\");\n+\n+#endif \/\/ SHARE_UTILITIES_FORBIDDENFUNCTIONS_HPP\n","filename":"src\/hotspot\/share\/utilities\/forbiddenFunctions.hpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/forbiddenFunctions.hpp\"\n@@ -176,29 +177,0 @@\n-\/\/----------------------------------------------------------------------------------------------------\n-\/\/ Forbid the use of various C library functions.\n-\/\/ Some of these have os:: replacements that should normally be used instead.\n-\/\/ Others are considered security concerns, with preferred alternatives.\n-\n-FORBID_C_FUNCTION(void exit(int), \"use os::exit\");\n-FORBID_C_FUNCTION(void _exit(int), \"use os::exit\");\n-FORBID_C_FUNCTION(char* strerror(int), \"use os::strerror\");\n-FORBID_C_FUNCTION(char* strtok(char*, const char*), \"use strtok_r\");\n-FORBID_C_FUNCTION(int sprintf(char*, const char*, ...), \"use os::snprintf\");\n-FORBID_C_FUNCTION(int vsprintf(char*, const char*, va_list), \"use os::vsnprintf\");\n-FORBID_C_FUNCTION(int vsnprintf(char*, size_t, const char*, va_list), \"use os::vsnprintf\");\n-\n-\/\/ All of the following functions return raw C-heap pointers (sometimes as an option, e.g. realpath or getwd)\n-\/\/ or, in case of free(), take raw C-heap pointers. Don't use them unless you are really sure you must.\n-FORBID_C_FUNCTION(void* malloc(size_t size), \"use os::malloc\");\n-FORBID_C_FUNCTION(void* calloc(size_t nmemb, size_t size), \"use os::malloc and zero out manually\");\n-FORBID_C_FUNCTION(void free(void *ptr), \"use os::free\");\n-FORBID_C_FUNCTION(void* realloc(void *ptr, size_t size), \"use os::realloc\");\n-FORBID_C_FUNCTION(char* strdup(const char *s), \"use os::strdup\");\n-FORBID_C_FUNCTION(char* strndup(const char *s, size_t n), \"don't use\");\n-FORBID_C_FUNCTION(int posix_memalign(void **memptr, size_t alignment, size_t size), \"don't use\");\n-FORBID_C_FUNCTION(void* aligned_alloc(size_t alignment, size_t size), \"don't use\");\n-FORBID_C_FUNCTION(char* realpath(const char* path, char* resolved_path), \"use os::realpath\");\n-FORBID_C_FUNCTION(char* get_current_dir_name(void), \"use os::get_current_directory()\");\n-FORBID_C_FUNCTION(char* getwd(char *buf), \"use os::get_current_directory()\");\n-FORBID_C_FUNCTION(wchar_t* wcsdup(const wchar_t *s), \"don't use\");\n-FORBID_C_FUNCTION(void* reallocf(void *ptr, size_t size), \"don't use\");\n-\n@@ -300,0 +272,3 @@\n+\/\/ for timer info max values which include all bits, 0xffffffffffffffff\n+const jlong all_bits_jlong = ~jlong(0);\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -634,1 +634,1 @@\n-  debug_only(GrowableArrayNestingCheck _nesting_check;)\n+  DEBUG_ONLY(GrowableArrayNestingCheck _nesting_check;)\n@@ -657,1 +657,1 @@\n-      debug_only(COMMA _nesting_check(true)) {\n+      DEBUG_ONLY(COMMA _nesting_check(true)) {\n@@ -663,1 +663,1 @@\n-      debug_only(COMMA _nesting_check(arena)) {\n+      DEBUG_ONLY(COMMA _nesting_check(arena)) {\n@@ -669,1 +669,1 @@\n-      debug_only(COMMA _nesting_check(false)) {\n+      DEBUG_ONLY(COMMA _nesting_check(false)) {\n@@ -737,1 +737,1 @@\n-  void init_checks() const { debug_only(_metadata.init_checks(this);) }\n+  void init_checks() const { DEBUG_ONLY(_metadata.init_checks(this);) }\n@@ -746,1 +746,1 @@\n-      debug_only(_metadata.on_resource_area_alloc_check());\n+      DEBUG_ONLY(_metadata.on_resource_area_alloc_check());\n@@ -755,1 +755,1 @@\n-    debug_only(_metadata.on_arena_alloc_check());\n+    DEBUG_ONLY(_metadata.on_arena_alloc_check());\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -380,2 +380,0 @@\n-\/\/ Historical.\n-#define debug_only(code) code\n@@ -386,1 +384,0 @@\n-#define debug_only(code)\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,0 +179,1 @@\n+protected:\n@@ -189,2 +190,1 @@\n-class StreamAutoIndentor : public StackObj {\n-  outputStream* const _os;\n+class StreamAutoIndentor : public streamIndentor {\n@@ -194,3 +194,3 @@\n-  StreamAutoIndentor(outputStream* os) :\n-    _os(os), _old(os->set_autoindent(true)) {}\n-  ~StreamAutoIndentor() { _os->set_autoindent(_old); }\n+  StreamAutoIndentor(outputStream* os, int indentation = 0) :\n+    streamIndentor(os, indentation), _old(os->set_autoindent(true)) {}\n+  ~StreamAutoIndentor() { _str->set_autoindent(_old); }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_PERMITFORBIDDENFUNCTIONS_HPP\n+#define SHARE_UTILITIES_PERMITFORBIDDENFUNCTIONS_HPP\n+\n+#include \"utilities\/compilerWarnings.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#ifdef _WINDOWS\n+#include \"permitForbiddenFunctions_windows.hpp\"\n+#else\n+#include \"permitForbiddenFunctions_posix.hpp\"\n+#endif\n+\n+\/\/ Provide wrappers for some functions otherwise forbidden from use in HotSpot.\n+\/\/\n+\/\/ There may be special circumstances where an otherwise forbidden function\n+\/\/ really does need to be used.  One example is in the implementation of a\n+\/\/ corresponding os:: function.\n+\/\/\n+\/\/ Wrapper functions are provided for such forbidden functions.  These\n+\/\/ wrappers are defined in a context where the forbidding warnings are\n+\/\/ suppressed.  They are defined in a special namespace, to highlight uses as\n+\/\/ unusual and requiring increased scrutiny.\n+\/\/\n+\/\/ Note that there are several seemingly plausible shorter alternatives to\n+\/\/ these written-out wrapper functions.  All that have been tried don't work\n+\/\/ for one reason or another.\n+\n+namespace permit_forbidden_function {\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n+\n+[[noreturn]] inline void exit(int status) { ::exit(status); }\n+[[noreturn]] inline void _exit(int status) { ::_exit(status); }\n+\n+ATTRIBUTE_PRINTF(3, 0)\n+inline int vsnprintf(char* str, size_t size, const char* format, va_list ap) {\n+  return ::vsnprintf(str, size, format, ap);\n+}\n+\n+inline void* malloc(size_t size) { return ::malloc(size); }\n+inline void free(void* ptr) { return ::free(ptr); }\n+inline void* calloc(size_t nmemb, size_t size) { return ::calloc(nmemb, size); }\n+inline void* realloc(void* ptr, size_t size) { return ::realloc(ptr, size); }\n+\n+inline char* strdup(const char* s) { return ::strdup(s); }\n+\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n+} \/\/ namespace permit_forbidden_function\n+\n+#endif \/\/ SHARE_UTILITIES_PERMITFORBIDDENFUNCTIONS_HPP\n","filename":"src\/hotspot\/share\/utilities\/permitForbiddenFunctions.hpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -1203,1 +1203,9 @@\n-      Universe::heap()->print_on_error(st);\n+      StreamAutoIndentor indentor(st, 1);\n+      Universe::heap()->print_heap_on(st);\n+      MetaspaceUtils::print_on(st);\n+      st->cr();\n+    }\n+\n+  STEP_IF(\"printing GC information\", _verbose)\n+    if (Universe::heap() != nullptr) {\n+      Universe::heap()->print_gc_on(st);\n@@ -1385,1 +1393,4 @@\n-  \/\/ STEP(\"printing heap information\")\n+  \/\/ Take heap lock over both heap and GC printing so that information is\n+  \/\/ consistent.\n+  {\n+    MutexLocker ml(Heap_lock);\n@@ -1387,8 +1398,21 @@\n-  if (Universe::is_fully_initialized()) {\n-    MutexLocker hl(Heap_lock);\n-    GCLogPrecious::print_on_error(st);\n-    st->print_cr(\"Heap:\");\n-    Universe::heap()->print_on_error(st);\n-    st->cr();\n-    st->print_cr(\"Polling page: \" PTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));\n-    st->cr();\n+    \/\/ STEP(\"printing heap information\")\n+\n+    if (Universe::is_fully_initialized()) {\n+      GCLogPrecious::print_on_error(st);\n+\n+      st->print_cr(\"Heap:\");\n+      StreamAutoIndentor indentor(st, 1);\n+      Universe::heap()->print_heap_on(st);\n+      MetaspaceUtils::print_on(st);\n+      st->cr();\n+    }\n+\n+    \/\/ STEP(\"printing GC information\")\n+\n+    if (Universe::is_fully_initialized()) {\n+      Universe::heap()->print_gc_on(st);\n+      st->cr();\n+\n+      st->print_cr(\"Polling page: \" PTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));\n+      st->cr();\n+    }\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,4 @@\n+#include \"jni_util.h\"\n+\n+DEF_STATIC_JNI_OnLoad\n+\n","filename":"src\/java.base\/aix\/native\/libsyslookup\/syslookup.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-import jdk.internal.access.JavaIOFilePermissionAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -40,1 +38,0 @@\n-import sun.security.util.FilePermCompat;\n@@ -42,0 +39,1 @@\n+import sun.security.util.SecurityProperties;\n@@ -158,0 +156,20 @@\n+    \/**\n+     * New behavior? Keep compatibility?\n+     * The new behavior does not use the canonical path normalization\n+     *\/\n+    private static final boolean nb = initNb();\n+\n+    \/\/ Initialize the nb flag from the System property jdk.io.permissionsUseCanonicalPath.\n+    private static boolean initNb() {\n+        String flag = SecurityProperties.getOverridableProperty(\n+                \"jdk.io.permissionsUseCanonicalPath\");\n+        return switch (flag) {\n+            case \"true\" -> false;   \/\/ compatibility mode to canonicalize paths\n+            case \"false\" -> true;   \/\/ do not canonicalize\n+            case null -> true;      \/\/ default, do not canonicalize\n+            default ->\n+                throw new RuntimeException(\n+                        \"Invalid jdk.io.permissionsUseCanonicalPath: \" + flag);\n+        };\n+    }\n+\n@@ -235,41 +253,17 @@\n-    static {\n-        SharedSecrets.setJavaIOFilePermissionAccess(\n-            \/**\n-             * Creates FilePermission objects with special internals.\n-             * See {@link FilePermCompat#newPermPlusAltPath(Permission)} and\n-             * {@link FilePermCompat#newPermUsingAltPath(Permission)}.\n-             *\/\n-            new JavaIOFilePermissionAccess() {\n-                public FilePermission newPermPlusAltPath(FilePermission input) {\n-                    if (!input.invalid && input.npath2 == null && !input.allFiles) {\n-                        Path npath2 = altPath(input.npath);\n-                        if (npath2 != null) {\n-                            \/\/ Please note the name of the new permission is\n-                            \/\/ different than the original so that when one is\n-                            \/\/ added to a FilePermissionCollection it will not\n-                            \/\/ be merged with the original one.\n-                            return new FilePermission(input.getName() + \"#plus\",\n-                                    input,\n-                                    input.npath,\n-                                    npath2,\n-                                    input.mask,\n-                                    input.actions);\n-                        }\n-                    }\n-                    return input;\n-                }\n-                public FilePermission newPermUsingAltPath(FilePermission input) {\n-                    if (!input.invalid && !input.allFiles) {\n-                        Path npath2 = altPath(input.npath);\n-                        if (npath2 != null) {\n-                            \/\/ New name, see above.\n-                            return new FilePermission(input.getName() + \"#using\",\n-                                    input,\n-                                    npath2,\n-                                    null,\n-                                    input.mask,\n-                                    input.actions);\n-                        }\n-                    }\n-                    return null;\n-                }\n+    \/\/ Construct a new Permission with altPath\n+    \/\/ Used by test FilePermissionCollectionMerge\n+    private FilePermission newPermPlusAltPath() {\n+        System.err.println(\"PlusAlt path: \" + this + \", npath: \" + npath);\n+        if (nb && !invalid && npath2 == null && !allFiles) {\n+            Path npath2 = altPath(npath);\n+            if (npath2 != null) {\n+                \/\/ Please note the name of the new permission is\n+                \/\/ different than the original so that when one is\n+                \/\/ added to a FilePermissionCollection it will not\n+                \/\/ be merged with the original one.\n+                return new FilePermission(getName() + \"#plus\",\n+                        this,\n+                        npath,\n+                        npath2,\n+                        mask,\n+                        actions);\n@@ -277,1 +271,2 @@\n-        );\n+        }\n+        return this;\n@@ -280,0 +275,21 @@\n+    \/\/ Construct a new Permission adding altPath\n+    \/\/ Used by test FilePermissionCollectionMerge\n+    private FilePermission newPermUsingAltPath() {\n+        System.err.println(\"Alt path: \" + this + \", npath: \" + npath);\n+        if (!invalid && !allFiles) {\n+            Path npath2 = altPath(npath);\n+            if (npath2 != null) {\n+                \/\/ New name, see above.\n+                return new FilePermission(getName() + \"#using\",\n+                        this,\n+                        npath2,\n+                        null,\n+                        mask,\n+                        actions);\n+            }\n+        }\n+        return this;\n+}\n+\n+\n+\n@@ -294,1 +310,1 @@\n-        if (FilePermCompat.nb) {\n+        if (nb) {\n@@ -570,1 +586,1 @@\n-        if (FilePermCompat.nb) {\n+        if (nb) {\n@@ -769,1 +785,1 @@\n-        if (FilePermCompat.nb) {\n+        if (nb) {\n@@ -792,1 +808,1 @@\n-        if (FilePermCompat.nb) {\n+        if (nb) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/FilePermission.java","additions":65,"deletions":49,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.io.IOException;\n@@ -363,0 +362,4 @@\n+        byte coder = this.coder;\n+        byte[] value = this.value;\n+        \/\/ Ensure count is less than or equal to capacity (racy reads and writes can produce inconsistent values)\n+        int count = Math.min(this.count, value.length >> coder);\n@@ -364,1 +367,1 @@\n-        if (isLatin1()) {\n+        if (coder == LATIN1) {\n@@ -423,0 +426,1 @@\n+        byte[] value = this.value;\n@@ -1733,1 +1737,1 @@\n-                    StringUTF16.putChar(this.value, j++, c);\n+                    StringUTF16.putCharSB(this.value, j++, c);\n@@ -1828,1 +1832,1 @@\n-                    StringUTF16.putChar(this.value, j++, c);\n+                    StringUTF16.putCharSB(this.value, j++, c);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -133,1 +133,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Boolean.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,1 +359,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -382,1 +382,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -9244,1 +9244,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2568,3 +2568,1 @@\n-        Class<?> k = ClassLoader.class;\n-        long offset;\n-        offset = unsafe.objectFieldOffset(k, name);\n+        long offset = unsafe.objectFieldOffset(ClassLoader.class, name);\n@@ -2574,0 +2572,13 @@\n+    private void reinitObjectField(String name, Object obj) {\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        long offset = unsafe.objectFieldOffset(ClassLoader.class, name);\n+\n+        \/\/ Extra safety: check the types\n+        Object current = unsafe.getReference(this, offset);\n+        if (current.getClass() != obj.getClass()) {\n+            throw new IllegalStateException(\"Wrong field type\");\n+        }\n+\n+        unsafe.putReference(this, offset, obj);\n+    }\n+\n@@ -2575,1 +2586,5 @@\n-     * Called by the VM, during -Xshare:dump\n+     * Called only by the VM, during -Xshare:dump.\n+     *\n+     * @implNote This is done while the JVM is running in single-threaded mode,\n+     * and at the very end of Java bytecode execution. We know that no more classes\n+     * will be loaded and none of the fields modified by this method will be used again.\n@@ -2579,1 +2594,1 @@\n-            parallelLockMap.clear();\n+            reinitObjectField(\"parallelLockMap\", new ConcurrentHashMap<>());\n@@ -2581,2 +2596,2 @@\n-        packages.clear();\n-        package2certs.clear();\n+        reinitObjectField(\"packages\", new ConcurrentHashMap<>());\n+        reinitObjectField(\"package2certs\", new ConcurrentHashMap<>());\n@@ -2584,0 +2599,1 @@\n+        classes.trimToSize();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1055,1 +1055,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -1076,1 +1076,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -698,1 +698,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -719,1 +719,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1038,1 +1038,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -1060,1 +1060,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1124,1 +1124,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -1147,1 +1147,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import java.security.ProtectionDomain;\n@@ -691,1 +690,0 @@\n-\n@@ -710,2 +708,2 @@\n-        \/\/ exported\/opened via module declaration\/descriptor\n-        if (isStaticallyExportedOrOpen(pn, other, open))\n+        \/\/ exported\/opened via module declaration\/descriptor or CLI options\n+        if (isExplicitlyExportedOrOpened(pn, other, open))\n@@ -715,1 +713,1 @@\n-        if (isReflectivelyExportedOrOpen(pn, other, open))\n+        if (isReflectivelyExportedOrOpened(pn, other, open))\n@@ -726,1 +724,1 @@\n-    private boolean isStaticallyExportedOrOpen(String pn, Module other, boolean open) {\n+    private boolean isExplicitlyExportedOrOpened(String pn, Module other, boolean open) {\n@@ -767,1 +765,1 @@\n-    private boolean isReflectivelyExportedOrOpen(String pn, Module other, boolean open) {\n+    private boolean isReflectivelyExportedOrOpened(String pn, Module other, boolean open) {\n@@ -812,1 +810,1 @@\n-        return isReflectivelyExportedOrOpen(pn, other, false);\n+        return isReflectivelyExportedOrOpened(pn, other, false);\n@@ -820,1 +818,1 @@\n-        return isReflectivelyExportedOrOpen(pn, other, true);\n+        return isReflectivelyExportedOrOpened(pn, other, true);\n@@ -1036,27 +1034,10 @@\n-        \/\/ add package name to exports if absent\n-        Map<String, Boolean> map = ReflectionData.exports\n-            .computeIfAbsent(this, other,\n-                             (m1, m2) -> new ConcurrentHashMap<>());\n-        if (open) {\n-            map.put(pn, Boolean.TRUE);  \/\/ may need to promote from FALSE to TRUE\n-        } else {\n-            map.putIfAbsent(pn, Boolean.FALSE);\n-        }\n-    }\n-\n-    \/**\n-     * Updates a module to open all packages in the given sets to all unnamed\n-     * modules.\n-     *\n-     * @apiNote Used during startup to open packages for illegal access.\n-     *\/\n-    void implAddOpensToAllUnnamed(Set<String> concealedPkgs, Set<String> exportedPkgs) {\n-        if (jdk.internal.misc.VM.isModuleSystemInited()) {\n-            throw new IllegalStateException(\"Module system already initialized\");\n-        }\n-\n-        \/\/ replace this module's openPackages map with a new map that opens\n-        \/\/ the packages to all unnamed modules.\n-        Map<String, Set<Module>> openPackages = this.openPackages;\n-        if (openPackages == null) {\n-            openPackages = HashMap.newHashMap(concealedPkgs.size() + exportedPkgs.size());\n+        if (VM.isBooted()) {\n+            \/\/ add package name to ReflectionData.exports if absent\n+            Map<String, Boolean> map = ReflectionData.exports\n+                .computeIfAbsent(this, other,\n+                                 (m1, m2) -> new ConcurrentHashMap<>());\n+            if (open) {\n+                map.put(pn, Boolean.TRUE);  \/\/ may need to promote from FALSE to TRUE\n+            } else {\n+                map.putIfAbsent(pn, Boolean.FALSE);\n+            }\n@@ -1064,12 +1045,20 @@\n-            openPackages = new HashMap<>(openPackages);\n-        }\n-        implAddOpensToAllUnnamed(concealedPkgs, openPackages);\n-        implAddOpensToAllUnnamed(exportedPkgs, openPackages);\n-        this.openPackages = openPackages;\n-    }\n-\n-    private void implAddOpensToAllUnnamed(Set<String> pkgs, Map<String, Set<Module>> openPackages) {\n-        for (String pn : pkgs) {\n-            Set<Module> prev = openPackages.putIfAbsent(pn, ALL_UNNAMED_MODULE_SET);\n-            if (prev != null) {\n-                prev.add(ALL_UNNAMED_MODULE);\n+            \/\/ export\/open packages during startup (--add-exports and --add-opens)\n+            Map<String, Set<Module>> packageToTargets = (open) ? openPackages : exportedPackages;\n+            if (packageToTargets != null) {\n+                \/\/ copy existing map\n+                packageToTargets = new HashMap<>(packageToTargets);\n+                packageToTargets.compute(pn, (_, values) -> {\n+                    var targets = new HashSet<Module>();\n+                    if (values != null) {\n+                        targets.addAll(values);\n+                    }\n+                    targets.add(other);\n+                    return targets;\n+                });\n+            } else {\n+                packageToTargets = Map.of(pn, Set.of(other));\n+            }\n+            if (open) {\n+                this.openPackages = packageToTargets;\n+            } else {\n+                this.exportedPackages = packageToTargets;\n@@ -1077,3 +1066,0 @@\n-\n-            \/\/ update VM to export the package\n-            addExportsToAllUnnamed0(this, pn);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":38,"deletions":52,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -365,1 +365,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -388,1 +388,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,757 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.lang.stable.StableEnumFunction;\n+import jdk.internal.lang.stable.StableFunction;\n+import jdk.internal.lang.stable.StableIntFunction;\n+import jdk.internal.lang.stable.StableSupplier;\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * A stable value is a holder of contents that can be set at most once.\n+ * <p>\n+ * A {@code StableValue<T>} is typically created using the factory method\n+ * {@linkplain StableValue#of() {@code StableValue.of()}}. When created this way,\n+ * the stable value is <em>unset<\/em>, which means it holds no <em>contents<\/em>.\n+ * Its contents, of type {@code T}, can be <em>set<\/em> by calling\n+ * {@linkplain #trySet(Object) trySet()}, {@linkplain #setOrThrow(Object) setOrThrow()},\n+ * or {@linkplain #orElseSet(Supplier) orElseSet()}. Once set, the contents\n+ * can never change and can be retrieved by calling {@linkplain #orElseThrow() orElseThrow()}\n+ * , {@linkplain #orElse(Object) orElse()}, or {@linkplain #orElseSet(Supplier) orElseSet()}.\n+ * <p>\n+ * Consider the following example where a stable value field \"{@code logger}\" is a\n+ * shallowly immutable holder of contents of type {@code Logger} and that is initially\n+ * created as <em>unset<\/em>, which means it holds no contents. Later in the example, the\n+ * state of the \"{@code logger}\" field is checked and if it is still <em>unset<\/em>,\n+ * the contents is <em>set<\/em>:\n+ *\n+ * {@snippet lang = java:\n+ * public class Component {\n+ *\n+ *    \/\/ Creates a new unset stable value with no contents\n+ *    \/\/ @link substring=\"of\" target=\"#of\" :\n+ *    private final StableValue<Logger> logger = StableValue.of();\n+ *\n+ *    private Logger getLogger() {\n+ *        if (!logger.isSet()) {\n+ *            logger.trySet(Logger.create(Component.class));\n+ *        }\n+ *        return logger.orElseThrow();\n+ *    }\n+ *\n+ *    public void process() {\n+ *        getLogger().info(\"Process started\");\n+ *        \/\/ ...\n+ *    }\n+ * }\n+ *}\n+ * <p>\n+ * If {@code getLogger()} is called from several threads, several instances of\n+ * {@code Logger} might be created. However, the contents can only be set at most once\n+ * meaning the first writer wins.\n+ * <p>\n+ * In order to guarantee that, even under races, only one instance of {@code Logger} is\n+ * ever created, the {@linkplain #orElseSet(Supplier) orElseSet()} method can be used\n+ * instead, where the contents are lazily computed, and atomically set, via a\n+ * {@linkplain Supplier supplier}. In the example below, the supplier is provided in the\n+ * form of a lambda expression:\n+ *\n+ * {@snippet lang = java:\n+ * public class Component {\n+ *\n+ *    \/\/ Creates a new unset stable value with no contents\n+ *    \/\/ @link substring=\"of\" target=\"#of\" :\n+ *    private final StableValue<Logger> logger = StableValue.of();\n+ *\n+ *    private Logger getLogger() {\n+ *        return logger.orElseSet( () -> Logger.create(Component.class) );\n+ *    }\n+ *\n+ *    public void process() {\n+ *        getLogger().info(\"Process started\");\n+ *        \/\/ ...\n+ *    }\n+ * }\n+ *}\n+ * <p>\n+ * The {@code getLogger()} method calls {@code logger.orElseSet()} on the stable value to\n+ * retrieve its contents. If the stable value is <em>unset<\/em>, then {@code orElseSet()}\n+ * evaluates the given supplier, and sets the contents to the result; the result is then\n+ * returned to the client. In other words, {@code orElseSet()} guarantees that a\n+ * stable value's contents is <em>set<\/em> before it returns.\n+ * <p>\n+ * Furthermore, {@code orElseSet()} guarantees that out of one or more suppliers provided,\n+ * only at most one is ever evaluated, and that one is only ever evaluated once,\n+ * even when {@code logger.orElseSet()} is invoked concurrently. This property is crucial\n+ * as evaluation of the supplier may have side effects, for example, the call above to\n+ * {@code Logger.create()} may result in storage resources being prepared.\n+ *\n+ * <h2 id=\"stable-functions\">Stable Functions<\/h2>\n+ * Stable values provide the foundation for higher-level functional abstractions. A\n+ * <em>stable supplier<\/em> is a supplier that computes a value and then caches it into\n+ * a backing stable value storage for subsequent use. A stable supplier is created via the\n+ * {@linkplain StableValue#supplier(Supplier) StableValue.supplier()} factory, by\n+ * providing an underlying {@linkplain Supplier} which is invoked when the stable supplier\n+ * is first accessed:\n+ *\n+ * {@snippet lang = java:\n+ * public class Component {\n+ *\n+ *     private final Supplier<Logger> logger =\n+ *             \/\/ @link substring=\"supplier\" target=\"#supplier(Supplier)\" :\n+ *             StableValue.supplier( () -> Logger.getLogger(Component.class) );\n+ *\n+ *     public void process() {\n+ *        logger.get().info(\"Process started\");\n+ *        \/\/ ...\n+ *     }\n+ * }\n+ *}\n+ * A stable supplier encapsulates access to its backing stable value storage. This means\n+ * that code inside {@code Component} can obtain the logger object directly from the\n+ * stable supplier, without having to go through an accessor method like {@code getLogger()}.\n+ * <p>\n+ * A <em>stable int function<\/em> is a function that takes an {@code int} parameter and\n+ * uses it to compute a result that is then cached by the backing stable value storage\n+ * for that parameter value. A stable {@link IntFunction} is created via the\n+ * {@linkplain StableValue#intFunction(int, IntFunction) StableValue.intFunction()}\n+ * factory. Upon creation, the input range (i.e. {@code [0, size)}) is specified together\n+ * with an underlying {@linkplain IntFunction} which is invoked at most once per input\n+ * value. In effect, the stable int function will act like a cache for the underlying\n+ * {@linkplain IntFunction}:\n+ *\n+ * {@snippet lang = java:\n+ * final class PowerOf2Util {\n+ *\n+ *     private PowerOf2Util() {}\n+ *\n+ *     private static final int SIZE = 6;\n+ *     private static final IntFunction<Integer> UNDERLYING_POWER_OF_TWO =\n+ *         v -> 1 << v;\n+ *\n+ *     private static final IntFunction<Integer> POWER_OF_TWO =\n+ *         \/\/ @link substring=\"intFunction\" target=\"#intFunction(int,IntFunction)\" :\n+ *         StableValue.intFunction(SIZE, UNDERLYING_POWER_OF_TWO);\n+ *\n+ *     public static int powerOfTwo(int a) {\n+ *         return POWER_OF_TWO.apply(a);\n+ *     }\n+ * }\n+ *\n+ * int result = PowerOf2Util.powerOfTwo(4);   \/\/ May eventually constant fold to 16 at runtime\n+ *\n+ *}\n+ * The {@code PowerOf2Util.powerOfTwo()} function is a <em>partial function<\/em> that only\n+ * allows a subset {@code [0, 5]} of the underlying function's {@code UNDERLYING_POWER_OF_TWO}\n+ * input range.\n+ *\n+ * <p>\n+ * A <em>stable function<\/em> is a function that takes a parameter (of type {@code T}) and\n+ * uses it to compute a result (of type {@code R}) that is then cached by the backing\n+ * stable value storage for that parameter value. A stable function is created via the\n+ * {@linkplain StableValue#function(Set, Function) StableValue.function()} factory.\n+ * Upon creation, the input {@linkplain Set} is specified together with an underlying\n+ * {@linkplain Function} which is invoked at most once per input value. In effect, the\n+ * stable function will act like a cache for the underlying {@linkplain Function}:\n+ *\n+ * {@snippet lang = java:\n+ * class Log2Util {\n+ *\n+ *     private Log2Util() {}\n+ *\n+ *     private static final Set<Integer> KEYS =\n+ *         Set.of(1, 2, 4, 8, 16, 32);\n+ *     private static final UnaryOperator<Integer> UNDERLYING_LOG2 =\n+ *         i -> 31 - Integer.numberOfLeadingZeros(i);\n+ *\n+ *     private static final Function<Integer, Integer> LOG2 =\n+ *         \/\/ @link substring=\"function\" target=\"#function(Set,Function)\" :\n+ *         StableValue.function(KEYS, UNDERLYING_LOG2);\n+ *\n+ *     public static int log2(int a) {\n+ *         return LOG2.apply(a);\n+ *     }\n+ *\n+ * }\n+ *\n+ * int result = Log2Util.log2(16);   \/\/ May eventually constant fold to 4 at runtime\n+ *}\n+ *\n+ * The {@code Log2Util.log2()} function is a <em>partial function<\/em> that only allows\n+ * a subset {@code {1, 2, 4, 8, 16, 32}} of the underlying function's\n+ * {@code UNDERLYING_LOG2} input range.\n+ *\n+ * <h2 id=\"stable-collections\">Stable Collections<\/h2>\n+ * Stable values can also be used as backing storage for\n+ * {@linkplain Collection##unmodifiable unmodifiable collections}. A <em>stable list<\/em>\n+ * is an unmodifiable list, backed by an array of stable values. The stable list elements\n+ * are computed when they are first accessed, using a provided {@linkplain IntFunction}:\n+ *\n+ * {@snippet lang = java:\n+ * final class PowerOf2Util {\n+ *\n+ *     private PowerOf2Util() {}\n+ *\n+ *     private static final int SIZE = 6;\n+ *     private static final IntFunction<Integer> UNDERLYING_POWER_OF_TWO =\n+ *             v -> 1 << v;\n+ *\n+ *     private static final List<Integer> POWER_OF_TWO =\n+ *         \/\/ @link substring=\"list\" target=\"#list(int,IntFunction)\" :\n+ *         StableValue.list(SIZE, UNDERLYING_POWER_OF_TWO);\n+ *\n+ *     public static int powerOfTwo(int a) {\n+ *         return POWER_OF_TWO.get(a);\n+ *     }\n+ * }\n+ *\n+ * int result = PowerOf2Util.powerOfTwo(4);   \/\/ May eventually constant fold to 16 at runtime\n+ *\n+ * }\n+ * <p>\n+ * Similarly, a <em>stable map<\/em> is an unmodifiable map whose keys are known at\n+ * construction. The stable map values are computed when they are first accessed,\n+ * using a provided {@linkplain Function}:\n+ *\n+ * {@snippet lang = java:\n+ * class Log2Util {\n+ *\n+ *     private Log2Util() {}\n+ *\n+ *     private static final Set<Integer> KEYS =\n+ *         Set.of(1, 2, 4, 8, 16, 32);\n+ *     private static final UnaryOperator<Integer> UNDERLYING_LOG2 =\n+ *         i -> 31 - Integer.numberOfLeadingZeros(i);\n+ *\n+ *     private static final Map<Integer, INTEGER> LOG2 =\n+ *         \/\/ @link substring=\"map\" target=\"#map(Set,Function)\" :\n+ *         StableValue.map(CACHED_KEYS, UNDERLYING_LOG2);\n+ *\n+ *     public static int log2(int a) {\n+ *          return LOG2.get(a);\n+ *     }\n+ *\n+ * }\n+ *\n+ * int result = Log2Util.log2(16);   \/\/ May eventually constant fold to 4 at runtime\n+ *\n+ *}\n+ *\n+ * <h2 id=\"composition\">Composing stable values<\/h2>\n+ * A stable value can depend on other stable values, forming a dependency graph\n+ * that can be lazily computed but where access to individual elements can still be\n+ * performant. In the following example, a single {@code Foo} and a {@code Bar}\n+ * instance (that is dependent on the {@code Foo} instance) are lazily created, both of\n+ * which are held by stable values:\n+ * {@snippet lang = java:\n+ * public final class DependencyUtil {\n+ *\n+ *     private DependencyUtil() {}\n+ *\n+ *     public static class Foo {\n+ *          \/\/ ...\n+ *      }\n+ *\n+ *     public static class Bar {\n+ *         public Bar(Foo foo) {\n+ *              \/\/ ...\n+ *         }\n+ *     }\n+ *\n+ *     private static final Supplier<Foo> FOO = StableValue.supplier(Foo::new);\n+ *     private static final Supplier<Bar> BAR = StableValue.supplier(() -> new Bar(FOO.get()));\n+ *\n+ *     public static Foo foo() {\n+ *         return FOO.get();\n+ *     }\n+ *\n+ *     public static Bar bar() {\n+ *         return BAR.get();\n+ *     }\n+ *\n+ * }\n+ *}\n+ * Calling {@code bar()} will create the {@code Bar} singleton if it is not already\n+ * created. Upon such a creation, the dependent {@code Foo} will first be created if\n+ * the {@code Foo} does not already exist.\n+ * <p>\n+ * Another example, which has a more complex dependency graph, is to compute the\n+ * Fibonacci sequence lazily:\n+ * {@snippet lang = java:\n+ * public final class Fibonacci {\n+ *\n+ *     private Fibonacci() {}\n+ *\n+ *     private static final int MAX_SIZE_INT = 46;\n+ *\n+ *     private static final IntFunction<Integer> FIB =\n+ *         StableValue.intFunction(MAX_SIZE_INT, Fibonacci::fib);\n+ *\n+ *     public static int fib(int n) {\n+ *         return n < 2\n+ *                 ? n\n+ *                 : FIB.apply(n - 1) + FIB.apply(n - 2);\n+ *     }\n+ *\n+ * }\n+ *}\n+ * Both {@code FIB} and {@code Fibonacci::fib} recurse into each other. Because the\n+ * stable int function {@code FIB} caches intermediate results, the initial\n+ * computational complexity is reduced from exponential to linear compared to a\n+ * traditional non-caching recursive fibonacci method. Once computed, the VM is free to\n+ * constant-fold expressions like {@code Fibonacci.fib(5)}.\n+ * <p>\n+ * The fibonacci example above is a directed acyclic graph (i.e.,\n+ * it has no circular dependencies and is therefore a dependency tree):\n+ *{@snippet lang=text :\n+ *\n+ *              ___________fib(5)____________\n+ *             \/                             \\\n+ *       ____fib(4)____                  ____fib(3)____\n+ *      \/              \\                \/              \\\n+ *    fib(3)          fib(2)          fib(2)          fib(1)\n+ *   \/     \\         \/     \\         \/     \\\n+ * fib(2) fib(1)   fib(1) fib(0)   fib(1) fib(0)\n+ *}\n+ *\n+ * If there are circular dependencies in a dependency graph, a stable value will\n+ * eventually throw an {@linkplain IllegalStateException} upon referencing elements in\n+ * a circularity.\n+ *\n+ * <h2 id=\"thread-safety\">Thread Safety<\/h2>\n+ * The contents of a stable value is guaranteed to be set at most once. If competing\n+ * threads are racing to set a stable value, only one update succeeds, while the other\n+ * updates are blocked until the stable value is set, whereafter the other updates\n+ * observes the stable value is set and leave the stable value unchanged.\n+ * <p>\n+ * The at-most-once write operation on a stable value that succeeds\n+ * (e.g. {@linkplain #trySet(Object) trySet()})\n+ * {@linkplain java.util.concurrent##MemoryVisibility <em>happens-before<\/em>}\n+ * any successful read operation (e.g. {@linkplain #orElseThrow()}).\n+ * A successful write operation can be either:\n+ * <ul>\n+ *     <li>a {@link #trySet(Object)} that returns {@code true},<\/li>\n+ *     <li>a {@link #setOrThrow(Object)} that does not throw, or<\/li>\n+ *     <li>an {@link #orElseSet(Supplier)} that successfully runs the supplier<\/li>\n+ * <\/ul>\n+ * A successful read operation can be either:\n+ * <ul>\n+ *     <li>a {@link #orElseThrow()} that does not throw,<\/li>\n+ *     <li>a {@link #orElse(Object) orElse(other)} that does not return the {@code other} value<\/li>\n+ *     <li>an {@link #orElseSet(Supplier)} that does not {@code throw}, or<\/li>\n+ *     <li>an {@link #isSet()} that returns {@code true}<\/li>\n+ * <\/ul>\n+ * <p>\n+ * The method {@link #orElseSet(Supplier)} guarantees that the provided\n+ * {@linkplain Supplier} is invoked successfully at most once, even under race.\n+ * Invocations of {@link #setOrThrow(Object)} form a total order of zero or more\n+ * exceptional invocations followed by zero (if the contents were already set) or one\n+ * successful invocation. Since stable functions and stable collections are built on top\n+ * of the same principles as {@linkplain StableValue#orElseSet(Supplier) orElseSet()} they\n+ * too are thread safe and guarantee at-most-once-per-input invocation.\n+ *\n+ * <h2 id=\"performance\">Performance<\/h2>\n+ * As the contents of a stable value can never change after it has been set, a JVM\n+ * implementation may, for a set stable value, elide all future reads of that\n+ * stable value, and instead directly use any contents that it has previously observed.\n+ * This is true if the reference to the stable value is a constant (e.g. in cases where\n+ * the stable value itself is stored in a {@code static final} field). Stable functions\n+ * and collections are built on top of StableValue. As such, they might also be eligible\n+ * for the same JVM optimizations as for StableValue.\n+ *\n+ * @implSpec Implementing classes of {@code StableValue} are free to synchronize on\n+ *           {@code this} and consequently, it should be avoided to\n+ *           (directly or indirectly) synchronize on a {@code StableValue}. Hence,\n+ *           synchronizing on {@code this} may lead to deadlock.\n+ *           <p>\n+ *           Except for a {@code StableValue}'s contents itself,\n+ *           an {@linkplain #orElse(Object) orElse(other)} parameter, and\n+ *           an {@linkplain #equals(Object) equals(obj)} parameter; all\n+ *           method parameters must be <em>non-null<\/em> or a {@link NullPointerException}\n+ *           will be thrown.\n+ *\n+ * @implNote A {@code StableValue} is mainly intended to be a non-public field in\n+ *           a class and is usually neither exposed directly via accessors nor passed as\n+ *           a method parameter.\n+ *           <p>\n+ *           Stable functions and collections make reasonable efforts to provide\n+ *           {@link Object#toString()} operations that do not trigger evaluation\n+ *           of the internal stable values when called.\n+ *           Stable collections have {@link Object#equals(Object)} operations that try\n+ *           to minimize evaluation of the internal stable values when called.\n+ *           <p>\n+ *           As objects can be set via stable values but never removed, this can be a\n+ *           source of unintended memory leaks. A stable value's contents are\n+ *           {@linkplain java.lang.ref##reachability strongly reachable}.\n+ *           Be advised that reachable stable values will hold their set contents until\n+ *           the stable value itself is collected.\n+ *           <p>\n+ *           A {@code StableValue} that has a type parameter {@code T} that is an array\n+ *           type (of arbitrary rank) will only allow the JVM to treat the\n+ *           <em>array reference<\/em> as a stable value but <em>not its components<\/em>.\n+ *           Instead, a {@linkplain #list(int, IntFunction) a stable list} of arbitrary\n+ *           depth can be used, which provides stable components. More generally, a\n+ *           stable value can hold other stable values of arbitrary depth and still\n+ *           provide transitive constantness.\n+ *           <p>\n+ *           Stable values, functions, and collections are not {@link Serializable}.\n+ *\n+ * @param <T> type of the contents\n+ *\n+ * @since 25\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.STABLE_VALUES)\n+public sealed interface StableValue<T>\n+        permits StableValueImpl {\n+\n+    \/\/ Principal methods\n+\n+    \/**\n+     * Tries to set the contents of this StableValue to the provided {@code contents}.\n+     * The contents of this StableValue can only be set once, implying this method only\n+     * returns {@code true} once.\n+     * <p>\n+     * When this method returns, the contents of this StableValue is always set.\n+     *\n+     * @return {@code true} if the contents of this StableValue was set to the\n+     *         provided {@code contents}, {@code false} otherwise\n+     * @param contents to set\n+     * @throws IllegalStateException if a supplier invoked by {@link #orElseSet(Supplier)}\n+     *         recursively attempts to set this stable value by calling this method\n+     *         directly or indirectly.\n+     *\/\n+    boolean trySet(T contents);\n+\n+    \/**\n+     * {@return the contents if set, otherwise, returns the provided {@code other} value}\n+     *\n+     * @param other to return if the contents is not set\n+     *\/\n+    T orElse(T other);\n+\n+    \/**\n+     * {@return the contents if set, otherwise, throws {@code NoSuchElementException}}\n+     *\n+     * @throws NoSuchElementException if no contents is set\n+     *\/\n+    T orElseThrow();\n+\n+    \/**\n+     * {@return {@code true} if the contents is set, {@code false} otherwise}\n+     *\/\n+    boolean isSet();\n+\n+    \/**\n+     * {@return the contents; if unset, first attempts to compute and set the\n+     *          contents using the provided {@code supplier}}\n+     * <p>\n+     * The provided {@code supplier} is guaranteed to be invoked at most once if it\n+     * completes without throwing an exception. If this method is invoked several times\n+     * with different suppliers, only one of them will be invoked provided it completes\n+     * without throwing an exception.\n+     * <p>\n+     * If the supplier throws an (unchecked) exception, the exception is rethrown and no\n+     * contents is set. The most common usage is to construct a new object serving\n+     * as a lazily computed value or memoized result, as in:\n+     *\n+     * {@snippet lang=java:\n+     * Value v = stable.orElseSet(Value::new);\n+     * }\n+     * <p>\n+     * When this method returns successfully, the contents is always set.\n+     * <p>\n+     * The provided {@code supplier} will only be invoked once even if invoked from\n+     * several threads unless the {@code supplier} throws an exception.\n+     *\n+     * @param  supplier to be used for computing the contents, if not previously set\n+     * @throws IllegalStateException if the provided {@code supplier} recursively\n+     *                               attempts to set this stable value.\n+     *\/\n+    T orElseSet(Supplier<? extends T> supplier);\n+\n+    \/\/ Convenience methods\n+\n+    \/**\n+     * Sets the contents of this StableValue to the provided {@code contents}, or, if\n+     * already set, throws {@code IllegalStateException}.\n+     * <p>\n+     * When this method returns (or throws an exception), the contents is always set.\n+     *\n+     * @param contents to set\n+     * @throws IllegalStateException if the contents was already set\n+     *\/\n+    void setOrThrow(T contents);\n+\n+    \/\/ Object methods\n+\n+    \/**\n+     * {@return {@code true} if {@code this == obj}, {@code false} otherwise}\n+     *\n+     * @param obj to check for equality\n+     *\/\n+    boolean equals(Object obj);\n+\n+    \/**\n+     * {@return the {@linkplain System#identityHashCode(Object) identity hash code} of\n+     *          {@code this} object}\n+     *\/\n+    int hashCode();\n+\n+    \/\/ Factories\n+\n+    \/**\n+     * {@return a new unset stable value}\n+     * <p>\n+     * An unset stable value has no contents.\n+     *\n+     * @param <T> type of the contents\n+     *\/\n+    static <T> StableValue<T> of() {\n+        return StableValueImpl.of();\n+    }\n+\n+    \/**\n+     * {@return a new pre-set stable value with the provided {@code contents}}\n+     *\n+     * @param contents to set\n+     * @param <T>     type of the contents\n+     *\/\n+    static <T> StableValue<T> of(T contents) {\n+        final StableValue<T> stableValue = StableValue.of();\n+        stableValue.trySet(contents);\n+        return stableValue;\n+    }\n+\n+    \/**\n+     * {@return a new stable supplier}\n+     * <p>\n+     * The returned {@linkplain Supplier supplier} is a caching supplier that records\n+     * the value of the provided {@code underlying} supplier upon being first accessed via\n+     * the returned supplier's {@linkplain Supplier#get() get()} method.\n+     * <p>\n+     * The provided {@code underlying} supplier is guaranteed to be successfully invoked\n+     * at most once even in a multi-threaded environment. Competing threads invoking the\n+     * returned supplier's {@linkplain Supplier#get() get()} method when a value is\n+     * already under computation will block until a value is computed or an exception is\n+     * thrown by the computing thread. The computing threads will then observe the newly\n+     * computed value (if any) and will then never execute.\n+     * <p>\n+     * If the provided {@code underlying} supplier throws an exception, it is rethrown\n+     * to the initial caller and no contents is recorded.\n+     * <p>\n+     * If the provided {@code underlying} supplier recursively calls the returned\n+     * supplier, an {@linkplain IllegalStateException} will be thrown.\n+     *\n+     * @param underlying supplier used to compute a cached value\n+     * @param <T>        the type of results supplied by the returned supplier\n+     *\/\n+    static <T> Supplier<T> supplier(Supplier<? extends T> underlying) {\n+        Objects.requireNonNull(underlying);\n+        return StableSupplier.of(underlying);\n+    }\n+\n+    \/**\n+     * {@return a new stable {@linkplain IntFunction}}\n+     * <p>\n+     * The returned function is a caching function that, for each allowed {@code int}\n+     * input, records the values of the provided {@code underlying}\n+     * function upon being first accessed via the returned function's\n+     * {@linkplain IntFunction#apply(int) apply()} method. If the returned function is\n+     * invoked with an input that is not in the range {@code [0, size)}, an\n+     * {@link IllegalArgumentException} will be thrown.\n+     * <p>\n+     * The provided {@code underlying} function is guaranteed to be successfully invoked\n+     * at most once per allowed input, even in a multi-threaded environment. Competing\n+     * threads invoking the returned function's\n+     * {@linkplain IntFunction#apply(int) apply()} method when a value is already under\n+     * computation will block until a value is computed or an exception is thrown by\n+     * the computing thread.\n+     * <p>\n+     * If invoking the provided {@code underlying} function throws an exception, it is\n+     * rethrown to the initial caller and no contents is recorded.\n+     * <p>\n+     * If the provided {@code underlying} function recursively calls the returned\n+     * function for the same input, an {@linkplain IllegalStateException} will\n+     * be thrown.\n+     *\n+     * @param size       the size of the allowed inputs in the continuous\n+     *                   interval {@code [0, size)}\n+     * @param underlying IntFunction used to compute cached values\n+     * @param <R>        the type of results delivered by the returned IntFunction\n+     * @throws IllegalArgumentException if the provided {@code size} is negative.\n+     *\/\n+    static <R> IntFunction<R> intFunction(int size,\n+                                          IntFunction<? extends R> underlying) {\n+        StableUtil.assertSizeNonNegative(size);\n+        Objects.requireNonNull(underlying);\n+        return StableIntFunction.of(size, underlying);\n+    }\n+\n+    \/**\n+     * {@return a new stable {@linkplain Function}}\n+     * <p>\n+     * The returned function is a caching function that, for each allowed\n+     * input in the given set of {@code inputs}, records the values of the provided\n+     * {@code underlying} function upon being first accessed via the returned function's\n+     * {@linkplain Function#apply(Object) apply()} method. If the returned function is\n+     * invoked with an input that is not in {@code inputs}, an {@link IllegalArgumentException}\n+     * will be thrown.\n+     * <p>\n+     * The provided {@code underlying} function is guaranteed to be successfully invoked\n+     * at most once per allowed input, even in a multi-threaded environment. Competing\n+     * threads invoking the returned function's {@linkplain Function#apply(Object) apply()}\n+     * method when a value is already under computation will block until a value is\n+     * computed or an exception is thrown by the computing thread.\n+     * <p>\n+     * If invoking the provided {@code underlying} function throws an exception, it is\n+     * rethrown to the initial caller and no contents is recorded.\n+     * <p>\n+     * If the provided {@code underlying} function recursively calls the returned\n+     * function for the same input, an {@linkplain IllegalStateException} will\n+     * be thrown.\n+     *\n+     * @param inputs     the set of (non-null) allowed input values\n+     * @param underlying {@code Function} used to compute cached values\n+     * @param <T>        the type of the input to the returned Function\n+     * @param <R>        the type of results delivered by the returned Function\n+     * @throws NullPointerException if the provided set of {@code inputs} contains a\n+     *                              {@code null} element.\n+     *\/\n+    static <T, R> Function<T, R> function(Set<? extends T> inputs,\n+                                          Function<? super T, ? extends R> underlying) {\n+        Objects.requireNonNull(inputs);\n+        \/\/ Checking that the Set of inputs does not contain a `null` value is made in the\n+        \/\/ implementing classes.\n+        Objects.requireNonNull(underlying);\n+        return inputs instanceof EnumSet<?> && !inputs.isEmpty()\n+                ? StableEnumFunction.of(inputs, underlying)\n+                : StableFunction.of(inputs, underlying);\n+    }\n+\n+    \/**\n+     * {@return a new stable list with the provided {@code size}}\n+     * <p>\n+     * The returned list is an {@linkplain Collection##unmodifiable unmodifiable} list\n+     * with the provided {@code size}. The list's elements are computed via the\n+     * provided {@code mapper} when they are first accessed\n+     * (e.g. via {@linkplain List#get(int) List::get}).\n+     * <p>\n+     * The provided {@code mapper} function is guaranteed to be successfully invoked\n+     * at most once per list index, even in a multi-threaded environment. Competing\n+     * threads accessing an element already under computation will block until an element\n+     * is computed or an exception is thrown by the computing thread.\n+     * <p>\n+     * If invoking the provided {@code mapper} function throws an exception, it\n+     * is rethrown to the initial caller and no value for the element is recorded.\n+     * <p>\n+     * Any direct {@link List#subList(int, int) subList} or {@link List#reversed()} views\n+     * of the returned list are also stable.\n+     * <p>\n+     * The returned list and its {@link List#subList(int, int) subList} or\n+     * {@link List#reversed()} views implement the {@link RandomAccess} interface.\n+     * <p>\n+     * The returned list is unmodifiable and does not implement the\n+     * {@linkplain Collection##optional-operation optional operations} in the\n+     * {@linkplain List} interface.\n+     * <p>\n+     * If the provided {@code mapper} recursively calls the returned list for the\n+     * same index, an {@linkplain IllegalStateException} will be thrown.\n+     *\n+     * @param size   the size of the returned list\n+     * @param mapper to invoke whenever an element is first accessed\n+     *               (may return {@code null})\n+     * @param <E>    the type of elements in the returned list\n+     * @throws IllegalArgumentException if the provided {@code size} is negative.\n+     *\/\n+    static <E> List<E> list(int size,\n+                            IntFunction<? extends E> mapper) {\n+        StableUtil.assertSizeNonNegative(size);\n+        Objects.requireNonNull(mapper);\n+        return SharedSecrets.getJavaUtilCollectionAccess().stableList(size, mapper);\n+    }\n+\n+    \/**\n+     * {@return a new stable map with the provided {@code keys}}\n+     * <p>\n+     * The returned map is an {@linkplain Collection##unmodifiable unmodifiable} map whose\n+     * keys are known at construction. The map's values are computed via the provided\n+     * {@code mapper} when they are first accessed\n+     * (e.g. via {@linkplain Map#get(Object) Map::get}).\n+     * <p>\n+     * The provided {@code mapper} function is guaranteed to be successfully invoked\n+     * at most once per key, even in a multi-threaded environment. Competing\n+     * threads accessing a value already under computation will block until an element\n+     * is computed or an exception is thrown by the computing thread.\n+     * <p>\n+     * If invoking the provided {@code mapper} function throws an exception, it\n+     * is rethrown to the initial caller and no value associated with the provided key\n+     * is recorded.\n+     * <p>\n+     * Any direct {@link Map#values()} or {@link Map#entrySet()} views\n+     * of the returned map are also stable.\n+     * <p>\n+     * The returned map is unmodifiable and does not implement the\n+     * {@linkplain Collection##optional-operations optional operations} in the\n+     * {@linkplain Map} interface.\n+     * <p>\n+     * If the provided {@code mapper} recursively calls the returned map for\n+     * the same key, an {@linkplain IllegalStateException} will be thrown.\n+     *\n+     * @param keys   the (non-null) keys in the returned map\n+     * @param mapper to invoke whenever an associated value is first accessed\n+     *               (may return {@code null})\n+     * @param <K>    the type of keys maintained by the returned map\n+     * @param <V>    the type of mapped values in the returned map\n+     * @throws NullPointerException if the provided set of {@code inputs} contains a\n+     *                              {@code null} element.\n+     *\/\n+    static <K, V> Map<K, V> map(Set<K> keys,\n+                                Function<? super K, ? extends V> mapper) {\n+        Objects.requireNonNull(keys);\n+        \/\/ Checking that the Set of keys does not contain a `null` value is made in the\n+        \/\/ implementing class.\n+        Objects.requireNonNull(mapper);\n+        return SharedSecrets.getJavaUtilCollectionAccess().stableMap(keys, mapper);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StableValue.java","additions":757,"deletions":0,"binary":false,"changes":757,"status":"added"},{"patch":"@@ -120,1 +120,1 @@\n-     * open and ready to supply input data. Typically this stream\n+     * open and ready to supply input data. This stream\n@@ -122,4 +122,3 @@\n-     * the host environment or user. In case this stream is wrapped\n-     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n-     * should be used for the charset, or consider using\n-     * {@link Console#reader()}.\n+     * the host environment or user. Applications should use the encoding\n+     * specified by the {@link ##stdin.encoding stdin.encoding} property\n+     * to convert input bytes to character data.\n@@ -127,2 +126,11 @@\n-     * @see Console#charset()\n-     * @see Console#reader()\n+     * @apiNote\n+     * The typical approach to read character data is to wrap {@code System.in}\n+     * within an {@link java.io.InputStreamReader InputStreamReader} or other object\n+     * that handles character encoding. After this is done, subsequent reading should\n+     * use only the wrapper object; operating directly on {@code System.in} results\n+     * in unspecified behavior.\n+     * <p>\n+     * For handling interactive input, consider using {@link Console}.\n+     *\n+     * @see Console\n+     * @see ##stdin.encoding stdin.encoding\n@@ -579,2 +587,7 @@\n-     *     <td>Character encoding name derived from the host environment and\/or\n-     *     the user's settings. Setting this system property has no effect.<\/td><\/tr>\n+     *     <td>Character encoding name derived from the host environment and\n+     *     the user's settings. Setting this system property on the command line\n+     *     has no effect.<\/td><\/tr>\n+     * <tr><th scope=\"row\">{@systemProperty stdin.encoding}<\/th>\n+     *     <td>Character encoding name for {@link System#in System.in}.\n+     *     The Java runtime can be started with the system property set to {@code UTF-8}.\n+     *     Starting it with the property set to another value results in unspecified behavior.\n@@ -584,2 +597,2 @@\n-     *     The Java runtime can be started with the system property set to {@code UTF-8},\n-     *     starting it with the property set to another value leads to undefined behavior.\n+     *     The Java runtime can be started with the system property set to {@code UTF-8}.\n+     *     Starting it with the property set to another value results in unspecified behavior.\n@@ -588,2 +601,2 @@\n-     *     The Java runtime can be started with the system property set to {@code UTF-8},\n-     *     starting it with the property set to another value leads to undefined behavior.\n+     *     The Java runtime can be started with the system property set to {@code UTF-8}.\n+     *     Starting it with the property set to another value results in unspecified behavior.\n@@ -643,1 +656,1 @@\n-     *     {@code COMPAT} leads to unspecified behavior.\n+     *     {@code COMPAT} results in unspecified behavior.\n@@ -2063,3 +2076,0 @@\n-            public void addOpensToAllUnnamed(Module m, Set<String> concealedPackages, Set<String> exportedPackages) {\n-                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -107,0 +107,5 @@\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #matches(ClassDesc)\n+     * matches} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n+     *\n@@ -111,0 +116,9 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given reference type}  Returns\n+     * {@code false} if {@code desc} is primitive.\n+     *\n+     * @param desc the reference type\n+     * @since 25\n+     *\/\n+    boolean matches(ClassDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ClassEntry.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -73,0 +73,5 @@\n+     *\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #matches(MethodTypeDesc)\n+     * matches} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n@@ -75,0 +80,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given method type}\n+     *\n+     * @param desc the method type descriptor\n+     * @since 25\n+     *\/\n+    boolean matches(MethodTypeDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodTypeEntry.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -58,0 +58,5 @@\n+     *\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #matches(ModuleDesc)\n+     * matches} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n@@ -60,0 +65,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given module}\n+     *\n+     * @param desc the module descriptor\n+     * @since 25\n+     *\/\n+    boolean matches(ModuleDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ModuleEntry.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -61,0 +61,5 @@\n+     *\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #matches(PackageDesc)\n+     * matches} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n@@ -63,0 +68,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given package}\n+     *\n+     * @param desc the package descriptor\n+     * @since 25\n+     *\/\n+    boolean matches(PackageDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/PackageEntry.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,0 +59,7 @@\n+     * @apiNote\n+     * A {@code Utf8Entry} can be used directly as a {@link CharSequence} if\n+     * {@code String} functionalities are not strictly desired.  If only string\n+     * equivalence is desired, {@link #equalsString(String) equalsString} should\n+     * be used.  Reduction of string processing can significantly improve {@code\n+     * class} file reading performance.\n+     *\n@@ -62,0 +69,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the same string as the provided string}\n+     *\n+     * @param value the string to compare to\n+     * @since 25\n+     *\/\n+    boolean equalsString(String value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/StringEntry.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,0 +87,18 @@\n+\n+    \/**\n+     * {@return whether this entry describes the descriptor string of this\n+     * field type}\n+     *\n+     * @param desc the field type\n+     * @since 25\n+     *\/\n+    boolean isFieldType(ClassDesc desc);\n+\n+    \/**\n+     * {@return whether this entry describes the descriptor string of this\n+     * method type}\n+     *\n+     * @param desc the method type\n+     * @since 25\n+     *\/\n+    boolean isMethodType(MethodTypeDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/Utf8Entry.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -862,1 +862,1 @@\n-            Set<CapturableState> set = Stream.of(Objects.requireNonNull(capturedState))\n+            int set = Stream.of(Objects.requireNonNull(capturedState))\n@@ -865,1 +865,2 @@\n-                    .collect(Collectors.toSet());\n+                    .mapToInt(state -> 1 << state.ordinal())\n+                    .sum();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.value.ValueClass;\n@@ -217,1 +218,0 @@\n-        maybeCompile(lform, m);\n@@ -323,6 +323,0 @@\n-    private static void maybeCompile(LambdaForm lform, MemberName m) {\n-        if (lform.vmentry == null && VerifyAccess.isSamePackage(m.getDeclaringClass(), MethodHandle.class))\n-            \/\/ Help along bootstrapping...\n-            lform.compileToBytecode();\n-    }\n-\n@@ -646,6 +640,21 @@\n-            FT_LAST_WRAPPER     = Wrapper.COUNT-1,\n-            FT_UNCHECKED_REF    = Wrapper.OBJECT.ordinal(),\n-            FT_CHECKED_REF      = FT_LAST_WRAPPER+1,\n-            FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  \/\/ flat vs non-flat x null value vs null-restricted value\n-            FT_LIMIT            = FT_LAST_WRAPPER+6;\n-    private static int afIndex(byte formOp, boolean isVolatile, boolean isFlat, boolean isNullRestricted, int ftypeKind) {\n+            FT_FIRST_REFERENCE = 8,\n+            \/\/ Any oop, same sig (Runnable?)\n+            FT_UNCHECKED_REF    = FT_FIRST_REFERENCE,\n+            \/\/ Oop with type checks (Number?)\n+            FT_CHECKED_REF      = FT_FIRST_REFERENCE + 1,\n+            \/\/ Oop with null checks, (Runnable!)\n+            FT_UNCHECKED_NR_REF = FT_FIRST_REFERENCE + 2,\n+            \/\/ Oop with null and type checks, (Number!)\n+            FT_CHECKED_NR_REF   = FT_FIRST_REFERENCE + 3,\n+            FT_FIRST_FLAT = FT_FIRST_REFERENCE + 4,\n+            \/\/ nullable flat (must check type), (Integer?)\n+            FT_NULLABLE_FLAT    = FT_FIRST_FLAT,\n+            \/\/ Null restricted flat (must check type), (Integer!)\n+            FT_NR_FLAT          = FT_FIRST_FLAT + 1,\n+            FT_LIMIT            = FT_FIRST_FLAT + 2;\n+\n+    static {\n+        assert FT_FIRST_REFERENCE == Wrapper.OBJECT.ordinal();\n+    }\n+\n+    private static int afIndex(byte formOp, boolean isVolatile, int ftypeKind) {\n@@ -654,2 +663,0 @@\n-                + (isFlat ? 1 : 0)\n-                + (isNullRestricted ? 1 : 0)\n@@ -660,2 +667,2 @@\n-            = new LambdaForm[afIndex(AF_LIMIT, false, false, false, 0)];\n-    static int ftypeKind(Class<?> ftype) {\n+            = new LambdaForm[afIndex(AF_LIMIT, false, 0)];\n+    static int ftypeKind(Class<?> ftype, boolean isFlat, boolean isNullRestricted) {\n@@ -663,0 +670,1 @@\n+            assert !isFlat && !isNullRestricted : ftype;\n@@ -665,0 +673,1 @@\n+            assert !isFlat : ftype;\n@@ -666,3 +675,1 @@\n-            return FT_UNCHECKED_REF;\n-        } else {\n-            return ftype.isValue() ? FT_CHECKED_VALUE : FT_CHECKED_REF;\n+            return isNullRestricted ? FT_UNCHECKED_NR_REF : FT_UNCHECKED_REF;\n@@ -670,0 +677,5 @@\n+        if (isFlat) {\n+            assert ValueClass.isConcreteValueClass(ftype) : ftype;\n+            return isNullRestricted ? FT_NR_FLAT : FT_NULLABLE_FLAT;\n+        }\n+        return isNullRestricted ? FT_CHECKED_NR_REF : FT_CHECKED_REF;\n@@ -694,1 +706,0 @@\n-        maybeCompile(lform, m);\n@@ -703,2 +714,6 @@\n-        int ftypeKind = ftypeKind(ftype);\n-        int afIndex = afIndex(formOp, isVolatile, isFlat, isNullRestricted, ftypeKind);\n+        int ftypeKind = ftypeKind(ftype, isFlat, isNullRestricted);\n+        return preparedFieldLambdaForm(formOp, isVolatile, ftypeKind);\n+    }\n+\n+    private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftypeKind) {\n+        int afIndex = afIndex(formOp, isVolatile, ftypeKind);\n@@ -707,1 +722,1 @@\n-        lform = makePreparedFieldLambdaForm(formOp, isVolatile,isFlat, isNullRestricted, ftypeKind);\n+        lform = makePreparedFieldLambdaForm(formOp, isVolatile, ftypeKind);\n@@ -712,1 +727,32 @@\n-    private static final Wrapper[] ALL_WRAPPERS = Wrapper.values();\n+    private static final @Stable Wrapper[] ALL_WRAPPERS = Wrapper.values();\n+\n+    \/\/ Names in kind may overload but differ from their basic type\n+    private static Kind getFieldKind(boolean isGetter,\n+                                     boolean isVolatile,\n+                                     boolean needsInit,\n+                                     boolean needsCast,\n+                                     boolean isFlat,\n+                                     boolean isNullRestricted,\n+                                     Wrapper wrapper) {\n+        if (!wrapper.isOther()) {\n+            \/\/ primitives\n+            assert !isFlat && !isNullRestricted && !needsCast;\n+            return switch (wrapper) {\n+                case BYTE -> isVolatile\n+                        ? (needsInit ? VOLATILE_FIELD_ACCESS_INIT_B : VOLATILE_FIELD_ACCESS_B)\n+                        : (needsInit ? FIELD_ACCESS_INIT_B : FIELD_ACCESS_B);\n+                case CHAR -> isVolatile\n+                        ? (needsInit ? VOLATILE_FIELD_ACCESS_INIT_C : VOLATILE_FIELD_ACCESS_C)\n+                        : (needsInit ? FIELD_ACCESS_INIT_C : FIELD_ACCESS_C);\n+                case SHORT -> isVolatile\n+                        ? (needsInit ? VOLATILE_FIELD_ACCESS_INIT_S : VOLATILE_FIELD_ACCESS_S)\n+                        : (needsInit ? FIELD_ACCESS_INIT_S : FIELD_ACCESS_S);\n+                case BOOLEAN -> isVolatile\n+                        ? (needsInit ? VOLATILE_FIELD_ACCESS_INIT_Z : VOLATILE_FIELD_ACCESS_Z)\n+                        : (needsInit ? FIELD_ACCESS_INIT_Z : FIELD_ACCESS_Z);\n+                \/\/ basic types\n+                default -> isVolatile\n+                        ? (needsInit ? VOLATILE_FIELD_ACCESS_INIT : VOLATILE_FIELD_ACCESS)\n+                        : (needsInit ? FIELD_ACCESS_INIT : FIELD_ACCESS);\n+            };\n+        }\n@@ -714,13 +760,10 @@\n-    private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlat, Wrapper wrapper) {\n-        if (isGetter) {\n-            if (isVolatile) {\n-                switch (wrapper) {\n-                    case BOOLEAN: return GET_BOOLEAN_VOLATILE;\n-                    case BYTE:    return GET_BYTE_VOLATILE;\n-                    case SHORT:   return GET_SHORT_VOLATILE;\n-                    case CHAR:    return GET_CHAR_VOLATILE;\n-                    case INT:     return GET_INT_VOLATILE;\n-                    case LONG:    return GET_LONG_VOLATILE;\n-                    case FLOAT:   return GET_FLOAT_VOLATILE;\n-                    case DOUBLE:  return GET_DOUBLE_VOLATILE;\n-                    case OBJECT:  return isFlat ? GET_FLAT_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;\n+        assert !(isGetter && isNullRestricted);\n+        if (isVolatile) {\n+            if (isFlat) {\n+                assert !needsInit && needsCast;\n+                return isNullRestricted ? VOLATILE_PUT_NULL_RESTRICTED_FLAT_VALUE : VOLATILE_FIELD_ACCESS_FLAT;\n+            } else if (needsCast) {\n+                if (needsInit) {\n+                    return isNullRestricted ? VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_CAST_INIT : VOLATILE_FIELD_ACCESS_INIT_CAST;\n+                } else {\n+                    return isNullRestricted ? VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_CAST : VOLATILE_FIELD_ACCESS_CAST;\n@@ -729,10 +772,4 @@\n-                switch (wrapper) {\n-                    case BOOLEAN: return GET_BOOLEAN;\n-                    case BYTE:    return GET_BYTE;\n-                    case SHORT:   return GET_SHORT;\n-                    case CHAR:    return GET_CHAR;\n-                    case INT:     return GET_INT;\n-                    case LONG:    return GET_LONG;\n-                    case FLOAT:   return GET_FLOAT;\n-                    case DOUBLE:  return GET_DOUBLE;\n-                    case OBJECT:  return isFlat ? GET_FLAT_VALUE : GET_REFERENCE;\n+                if (needsInit) {\n+                    return isNullRestricted ? VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_INIT : VOLATILE_FIELD_ACCESS_INIT;\n+                } else {\n+                    return isNullRestricted ? VOLATILE_PUT_NULL_RESTRICTED_REFERENCE : VOLATILE_FIELD_ACCESS;\n@@ -742,11 +779,8 @@\n-            if (isVolatile) {\n-                switch (wrapper) {\n-                    case BOOLEAN: return PUT_BOOLEAN_VOLATILE;\n-                    case BYTE:    return PUT_BYTE_VOLATILE;\n-                    case SHORT:   return PUT_SHORT_VOLATILE;\n-                    case CHAR:    return PUT_CHAR_VOLATILE;\n-                    case INT:     return PUT_INT_VOLATILE;\n-                    case LONG:    return PUT_LONG_VOLATILE;\n-                    case FLOAT:   return PUT_FLOAT_VOLATILE;\n-                    case DOUBLE:  return PUT_DOUBLE_VOLATILE;\n-                    case OBJECT:  return isFlat ? PUT_FLAT_VALUE_VOLATILE : PUT_REFERENCE_VOLATILE;\n+            if (isFlat) {\n+                assert !needsInit && needsCast;\n+                return isNullRestricted ? PUT_NULL_RESTRICTED_FLAT_VALUE : FIELD_ACCESS_FLAT;\n+            } else if (needsCast) {\n+                if (needsInit) {\n+                    return isNullRestricted ? PUT_NULL_RESTRICTED_REFERENCE_CAST_INIT : FIELD_ACCESS_INIT_CAST;\n+                } else {\n+                    return isNullRestricted ? PUT_NULL_RESTRICTED_REFERENCE_CAST : FIELD_ACCESS_CAST;\n@@ -755,10 +789,4 @@\n-                switch (wrapper) {\n-                    case BOOLEAN: return PUT_BOOLEAN;\n-                    case BYTE:    return PUT_BYTE;\n-                    case SHORT:   return PUT_SHORT;\n-                    case CHAR:    return PUT_CHAR;\n-                    case INT:     return PUT_INT;\n-                    case LONG:    return PUT_LONG;\n-                    case FLOAT:   return PUT_FLOAT;\n-                    case DOUBLE:  return PUT_DOUBLE;\n-                    case OBJECT:  return isFlat ? PUT_FLAT_VALUE : PUT_REFERENCE;\n+                if (needsInit) {\n+                    return isNullRestricted ? PUT_NULL_RESTRICTED_REFERENCE_INIT : FIELD_ACCESS_INIT;\n+                } else {\n+                    return isNullRestricted ? PUT_NULL_RESTRICTED_REFERENCE : FIELD_ACCESS;\n@@ -768,1 +796,0 @@\n-        throw new AssertionError(\"Invalid arguments\");\n@@ -771,3 +798,22 @@\n-    \/** invoked by GenerateJLIClassesHelper *\/\n-    static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftype) {\n-        return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, ftype);\n+    private static String unsafeMethodName(boolean isGetter,\n+                                           boolean isVolatile,\n+                                           Wrapper wrapper) {\n+        var name = switch (wrapper) {\n+            case BOOLEAN -> \"Boolean\";\n+            case BYTE -> \"Byte\";\n+            case CHAR -> \"Char\";\n+            case SHORT -> \"Short\";\n+            case INT -> \"Int\";\n+            case FLOAT -> \"Float\";\n+            case LONG -> \"Long\";\n+            case DOUBLE -> \"Double\";\n+            case OBJECT -> \"Reference\";\n+            case VOID -> \"FlatValue\";\n+        };\n+        var sb = new StringBuilder(3 + name.length() + (isVolatile ? 8 : 0))\n+                .append(isGetter ? \"get\" : \"put\")\n+                .append(name);\n+        if (isVolatile) {\n+            sb.append(\"Volatile\");\n+        }\n+        return sb.toString();\n@@ -776,2 +822,1 @@\n-    private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile,\n-                                                          boolean isFlat, boolean isNullRestricted, int ftypeKind) {\n+    static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftypeKind) {\n@@ -781,4 +826,20 @@\n-        boolean needsCast = (ftypeKind == FT_CHECKED_REF || ftypeKind == FT_CHECKED_VALUE);\n-        Wrapper fw = (needsCast ? Wrapper.OBJECT : ALL_WRAPPERS[ftypeKind]);\n-        Class<?> ft = fw.primitiveType();\n-        assert(needsCast ? true : ftypeKind(ft) == ftypeKind);\n+        boolean isFlat = (ftypeKind >= FT_FIRST_FLAT);\n+        boolean isNullRestricted = (ftypeKind == FT_NR_FLAT || ftypeKind == FT_CHECKED_NR_REF || ftypeKind == FT_UNCHECKED_NR_REF);\n+        boolean needsCast = (isFlat || ftypeKind == FT_CHECKED_REF || ftypeKind == FT_CHECKED_NR_REF);\n+\n+        if (isGetter && isNullRestricted) {\n+            int newKind = switch (ftypeKind) {\n+                case FT_NR_FLAT -> FT_NULLABLE_FLAT;\n+                case FT_CHECKED_NR_REF -> FT_CHECKED_REF;\n+                case FT_UNCHECKED_NR_REF -> FT_UNCHECKED_REF;\n+                default -> throw new InternalError();\n+            };\n+            return preparedFieldLambdaForm(formOp, isVolatile, newKind);\n+        }\n+\n+        if (isFlat && isStatic)\n+            throw new InternalError(\"Static flat not supported yet\");\n+\n+        \/\/ primitives, reference, and void for flat\n+        Wrapper fw = ftypeKind < FT_FIRST_REFERENCE ? ALL_WRAPPERS[ftypeKind] :\n+                isFlat ? Wrapper.VOID : Wrapper.OBJECT;\n@@ -787,1 +848,5 @@\n-        Kind kind = getFieldKind(isGetter, isVolatile, isFlat, fw);\n+        String unsafeMethodName = unsafeMethodName(isGetter, isVolatile, fw);\n+        \/\/ isGetter and isStatic is reflected in field type;\n+        \/\/ flat, NR distinguished\n+        \/\/ basic type clash for subwords\n+        Kind kind = getFieldKind(isGetter, isVolatile, needsInit, needsCast, isFlat, isNullRestricted, fw);\n@@ -789,0 +854,1 @@\n+        Class<?> ft = ftypeKind < FT_FIRST_REFERENCE ? fw.primitiveType() : Object.class;\n@@ -799,1 +865,1 @@\n-        MemberName linker = new MemberName(Unsafe.class, kind.methodName, linkerType, REF_invokeVirtual);\n+        MemberName linker = new MemberName(Unsafe.class, unsafeMethodName, linkerType, REF_invokeVirtual);\n@@ -857,1 +923,0 @@\n-            assert !isStatic : \"static field is flat form requested\";\n@@ -871,7 +936,1 @@\n-        LambdaForm form;\n-        if (needsCast || needsInit) {\n-            \/\/ can't use the pre-generated form when casting and\/or initializing\n-            form = LambdaForm.create(ARG_LIMIT, names, RESULT);\n-        } else {\n-            form = LambdaForm.create(ARG_LIMIT, names, RESULT, kind);\n-        }\n+        LambdaForm form = LambdaForm.create(ARG_LIMIT, names, RESULT, kind);\n@@ -882,1 +941,1 @@\n-            StringBuilder nameBuilder = new StringBuilder(kind.methodName);\n+            StringBuilder nameBuilder = new StringBuilder(unsafeMethodName);\n@@ -888,0 +947,3 @@\n+            if (isNullRestricted) {\n+                nameBuilder.append(\"NullRestricted\");\n+            }\n@@ -896,0 +958,3 @@\n+\n+        \/\/ NF_UNSAFE uses field form, avoid circular dependency in interpreter\n+        form.compileToBytecode();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":155,"deletions":90,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.List;\n@@ -432,3 +433,5 @@\n-        for (Wrapper wrapper : Wrapper.values()) {\n-            if (wrapper == Wrapper.VOID) {\n-                continue;\n+        record FieldLfToken(byte formOp, int ftypeKind) {}\n+        List<FieldLfToken> tokens = new ArrayList<>();\n+        for (int i = 0; i <= DirectMethodHandle.FT_CHECKED_REF; i++) {\n+            for (byte formOp = DirectMethodHandle.AF_GETFIELD; formOp < DirectMethodHandle.AF_LIMIT; formOp++) {\n+                tokens.add(new FieldLfToken(formOp, i));\n@@ -436,14 +439,6 @@\n-            for (byte b = DirectMethodHandle.AF_GETFIELD; b < DirectMethodHandle.AF_LIMIT; b++) {\n-                int ftype = DirectMethodHandle.ftypeKind(wrapper.primitiveType());\n-                LambdaForm form = DirectMethodHandle\n-                        .makePreparedFieldLambdaForm(b, \/*isVolatile*\/false, ftype);\n-                if (form.kind != LambdaForm.Kind.GENERIC) {\n-                    forms.add(form);\n-                    names.add(form.kind.defaultLambdaName);\n-                }\n-                \/\/ volatile\n-                form = DirectMethodHandle\n-                        .makePreparedFieldLambdaForm(b, \/*isVolatile*\/true, ftype);\n-                if (form.kind != LambdaForm.Kind.GENERIC) {\n-                    forms.add(form);\n-                    names.add(form.kind.defaultLambdaName);\n+        }\n+        for (int i : new int[] {DirectMethodHandle.FT_UNCHECKED_NR_REF, DirectMethodHandle.FT_CHECKED_NR_REF}) {\n+            for (byte formOp = DirectMethodHandle.AF_GETFIELD; formOp < DirectMethodHandle.AF_LIMIT; formOp++) {\n+                boolean isGetter = (formOp & 1) == (DirectMethodHandle.AF_GETFIELD & 1);\n+                if (!isGetter) {\n+                    tokens.add(new FieldLfToken(formOp, i));\n@@ -453,0 +448,22 @@\n+        \/\/ Only legal flat combinations; no static\n+        tokens.add(new FieldLfToken(DirectMethodHandle.AF_GETFIELD, DirectMethodHandle.FT_NULLABLE_FLAT));\n+        tokens.add(new FieldLfToken(DirectMethodHandle.AF_PUTFIELD, DirectMethodHandle.FT_NULLABLE_FLAT));\n+        tokens.add(new FieldLfToken(DirectMethodHandle.AF_PUTFIELD, DirectMethodHandle.FT_NR_FLAT));\n+        \/\/ Compile\n+        for (var token : tokens) {\n+            byte b = token.formOp;\n+            int ftype = token.ftypeKind;\n+            LambdaForm form = DirectMethodHandle\n+                    .makePreparedFieldLambdaForm(b, \/*isVolatile*\/false, ftype);\n+            if (form.kind == GENERIC)\n+                throw new InternalError(b + \" non-volatile \" + ftype);\n+            forms.add(form);\n+            names.add(form.kind.defaultLambdaName);\n+            \/\/ volatile\n+            form = DirectMethodHandle\n+                    .makePreparedFieldLambdaForm(b, \/*isVolatile*\/true, ftype);\n+            if (form.kind == GENERIC)\n+                throw new InternalError(b + \" volatile \" + ftype);\n+            forms.add(form);\n+            names.add(form.kind.defaultLambdaName);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -471,18 +471,24 @@\n-            case GET_REFERENCE:             \/\/ fall-through\n-            case GET_BOOLEAN:               \/\/ fall-through\n-            case GET_BYTE:                  \/\/ fall-through\n-            case GET_CHAR:                  \/\/ fall-through\n-            case GET_SHORT:                 \/\/ fall-through\n-            case GET_INT:                   \/\/ fall-through\n-            case GET_LONG:                  \/\/ fall-through\n-            case GET_FLOAT:                 \/\/ fall-through\n-            case GET_DOUBLE:                \/\/ fall-through\n-            case PUT_REFERENCE:             \/\/ fall-through\n-            case PUT_BOOLEAN:               \/\/ fall-through\n-            case PUT_BYTE:                  \/\/ fall-through\n-            case PUT_CHAR:                  \/\/ fall-through\n-            case PUT_SHORT:                 \/\/ fall-through\n-            case PUT_INT:                   \/\/ fall-through\n-            case PUT_LONG:                  \/\/ fall-through\n-            case PUT_FLOAT:                 \/\/ fall-through\n-            case PUT_DOUBLE:                \/\/ fall-through\n+            case FIELD_ACCESS:              \/\/ fall-through\n+            case FIELD_ACCESS_INIT:         \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS:     \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS_INIT:\/\/ fall-through\n+            case FIELD_ACCESS_B:              \/\/ fall-through\n+            case FIELD_ACCESS_INIT_B:         \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS_B:     \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS_INIT_B:\/\/ fall-through\n+            case FIELD_ACCESS_C:              \/\/ fall-through\n+            case FIELD_ACCESS_INIT_C:         \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS_C:     \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS_INIT_C:\/\/ fall-through\n+            case FIELD_ACCESS_S:              \/\/ fall-through\n+            case FIELD_ACCESS_INIT_S:         \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS_S:     \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS_INIT_S:\/\/ fall-through\n+            case FIELD_ACCESS_Z:              \/\/ fall-through\n+            case FIELD_ACCESS_INIT_Z:         \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS_Z:     \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS_INIT_Z:\/\/ fall-through\n+            case FIELD_ACCESS_CAST:              \/\/ fall-through\n+            case FIELD_ACCESS_INIT_CAST:         \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS_CAST:     \/\/ fall-through\n+            case VOLATILE_FIELD_ACCESS_INIT_CAST:\/\/ fall-through\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -266,40 +266,48 @@\n-        GET_REFERENCE(\"getReference\"),\n-        PUT_REFERENCE(\"putReference\"),\n-        GET_REFERENCE_VOLATILE(\"getReferenceVolatile\"),\n-        PUT_REFERENCE_VOLATILE(\"putReferenceVolatile\"),\n-        GET_FLAT_VALUE(\"getFlatValue\"),\n-        PUT_FLAT_VALUE(\"putFlatValue\"),\n-        GET_FLAT_VALUE_VOLATILE(\"getFlatValueVolatile\"),\n-        PUT_FLAT_VALUE_VOLATILE(\"putFlatValueVolatile\"),\n-        GET_INT(\"getInt\"),\n-        PUT_INT(\"putInt\"),\n-        GET_INT_VOLATILE(\"getIntVolatile\"),\n-        PUT_INT_VOLATILE(\"putIntVolatile\"),\n-        GET_BOOLEAN(\"getBoolean\"),\n-        PUT_BOOLEAN(\"putBoolean\"),\n-        GET_BOOLEAN_VOLATILE(\"getBooleanVolatile\"),\n-        PUT_BOOLEAN_VOLATILE(\"putBooleanVolatile\"),\n-        GET_BYTE(\"getByte\"),\n-        PUT_BYTE(\"putByte\"),\n-        GET_BYTE_VOLATILE(\"getByteVolatile\"),\n-        PUT_BYTE_VOLATILE(\"putByteVolatile\"),\n-        GET_CHAR(\"getChar\"),\n-        PUT_CHAR(\"putChar\"),\n-        GET_CHAR_VOLATILE(\"getCharVolatile\"),\n-        PUT_CHAR_VOLATILE(\"putCharVolatile\"),\n-        GET_SHORT(\"getShort\"),\n-        PUT_SHORT(\"putShort\"),\n-        GET_SHORT_VOLATILE(\"getShortVolatile\"),\n-        PUT_SHORT_VOLATILE(\"putShortVolatile\"),\n-        GET_LONG(\"getLong\"),\n-        PUT_LONG(\"putLong\"),\n-        GET_LONG_VOLATILE(\"getLongVolatile\"),\n-        PUT_LONG_VOLATILE(\"putLongVolatile\"),\n-        GET_FLOAT(\"getFloat\"),\n-        PUT_FLOAT(\"putFloat\"),\n-        GET_FLOAT_VOLATILE(\"getFloatVolatile\"),\n-        PUT_FLOAT_VOLATILE(\"putFloatVolatile\"),\n-        GET_DOUBLE(\"getDouble\"),\n-        PUT_DOUBLE(\"putDouble\"),\n-        GET_DOUBLE_VOLATILE(\"getDoubleVolatile\"),\n-        PUT_DOUBLE_VOLATILE(\"putDoubleVolatile\"),\n+        \/\/ Start field forms\n+        \/\/ IJFDL, instance\/static differ in method type, can share form\n+        \/\/ init form only applicable to static\n+        FIELD_ACCESS(\"fieldAccess\"),\n+        FIELD_ACCESS_INIT(\"fieldAccessInit\"),\n+        VOLATILE_FIELD_ACCESS(\"volatileFieldAccess\"),\n+        VOLATILE_FIELD_ACCESS_INIT(\"volatileFieldAccessInit\"),\n+        \/\/ BCSZ need own forms to avoid clashing with basic type I, +-init\/volatile\n+        FIELD_ACCESS_B(\"fieldAccessB\"),\n+        FIELD_ACCESS_INIT_B(\"fieldAccessInitB\"),\n+        VOLATILE_FIELD_ACCESS_B(\"volatileFieldAccessB\"),\n+        VOLATILE_FIELD_ACCESS_INIT_B(\"volatileFieldAccessInitB\"),\n+        FIELD_ACCESS_C(\"fieldAccessC\"),\n+        FIELD_ACCESS_INIT_C(\"fieldAccessInitC\"),\n+        VOLATILE_FIELD_ACCESS_C(\"volatileFieldAccessC\"),\n+        VOLATILE_FIELD_ACCESS_INIT_C(\"volatileFieldAccessInitC\"),\n+        FIELD_ACCESS_S(\"fieldAccessS\"),\n+        FIELD_ACCESS_INIT_S(\"fieldAccessInitS\"),\n+        VOLATILE_FIELD_ACCESS_S(\"volatileFieldAccessS\"),\n+        VOLATILE_FIELD_ACCESS_INIT_S(\"volatileFieldAccessInitS\"),\n+        FIELD_ACCESS_Z(\"fieldAccessZ\"),\n+        FIELD_ACCESS_INIT_Z(\"fieldAccessInitZ\"),\n+        VOLATILE_FIELD_ACCESS_Z(\"volatileFieldAccessZ\"),\n+        VOLATILE_FIELD_ACCESS_INIT_Z(\"volatileFieldAccessInitZ\"),\n+        \/\/ cast, nr, flat need their own forms to avoid clashing with L\n+        FIELD_ACCESS_CAST(\"fieldAccessCast\"),\n+        FIELD_ACCESS_INIT_CAST(\"fieldAccessInitCast\"),\n+        VOLATILE_FIELD_ACCESS_CAST(\"volatileFieldAccessCast\"),\n+        VOLATILE_FIELD_ACCESS_INIT_CAST(\"volatileFieldAccessInitCast\"),\n+        \/\/ null-check and put reference, +-cast, +-init\/volatile\n+        \/\/ non-cast forms serve bytecode emulation purpose, which always enforces null checks\n+        PUT_NULL_RESTRICTED_REFERENCE(\"putNullRestrictedReference\"),\n+        PUT_NULL_RESTRICTED_REFERENCE_INIT(\"putNullRestrictedReferenceInit\"),\n+        VOLATILE_PUT_NULL_RESTRICTED_REFERENCE(\"volatilePutNullRestrictedReference\"),\n+        VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_INIT(\"volatilePutNullRestrictedReferenceInit\"),\n+        PUT_NULL_RESTRICTED_REFERENCE_CAST(\"putNullRestrictedReferenceCast\"),\n+        PUT_NULL_RESTRICTED_REFERENCE_CAST_INIT(\"putNullRestrictedReferenceInitCast\"),\n+        VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_CAST(\"volatilePutNullRestrictedReferenceCast\"),\n+        VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_CAST_INIT(\"volatilePutNullRestrictedReferenceCastInit\"),\n+        \/\/ flat implies cast, +-init\/volatile\n+        FIELD_ACCESS_FLAT(\"fieldAccessFlat\"),\n+        FIELD_ACCESS_INIT_FLAT(\"fieldAccessInitFlat\"),\n+        VOLATILE_FIELD_ACCESS_FLAT(\"volatileFieldAccessFlat\"),\n+        VOLATILE_FIELD_ACCESS_INIT_FLAT(\"volatileFieldAccessInitFlat\"),\n+        \/\/ write guard NR flat, implies cast; +-volatile; no init forms - no flat in static fields yet\n+        PUT_NULL_RESTRICTED_FLAT_VALUE(\"putNullRestrictedFlatValue\"),\n+        VOLATILE_PUT_NULL_RESTRICTED_FLAT_VALUE(\"volatilePutNullRestrictedFlatValue\"),\n+        \/\/ End fields\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":48,"deletions":40,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -93,2 +92,1 @@\n-    private static final class Transform {\n-        final Object cache;\n+    private static final class Transform extends SoftReference<LambdaForm> {\n@@ -99,5 +97,1 @@\n-            if (USE_SOFT_CACHE) {\n-                cache = new SoftReference<LambdaForm>(result);\n-            } else {\n-                cache = result;\n-            }\n+            super(result);\n@@ -144,9 +138,0 @@\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public LambdaForm get() {\n-            if (cache instanceof LambdaForm lf) {\n-                return lf;\n-            } else {\n-                return ((SoftReference<LambdaForm>)cache).get();\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -730,1 +730,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -671,18 +671,0 @@\n-\n-    \/\/--- AOTCache support\n-\n-    \/**\n-     * In normal execution, this is set to true, so that LambdaFormEditor and MethodTypeForm will\n-     * use soft references to allow class unloading.\n-     *\n-     * When dumping the AOTCache, this is set to false so that no cached heap objects will\n-     * contain soft references (which are not yet supported by AOTCache - see JDK-8341587). AOTCache\n-     * only stores LambdaFormEditors and MethodTypeForms for classes in the boot\/platform\/app loaders.\n-     * Such classes will never be unloaded, so it's OK to use hard references.\n-     *\/\n-    static final boolean USE_SOFT_CACHE;\n-\n-    static {\n-        USE_SOFT_CACHE = Boolean.parseBoolean(\n-                System.getProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"true\"));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-import java.util.HashMap;\n-import java.util.Iterator;\n@@ -45,1 +43,0 @@\n-import jdk.internal.misc.CDS;\n@@ -397,11 +394,0 @@\n-        if (archivedMethodTypes != null) {\n-            \/\/ If this JVM process reads from archivedMethodTypes, it never\n-            \/\/ modifies the table. So there's no need for synchronization.\n-            \/\/ See copyInternTable() below.\n-            assert CDS.isUsingArchive();\n-            MethodType mt = archivedMethodTypes.get(primordialMT);\n-            if (mt != null) {\n-                return mt;\n-            }\n-        }\n-\n@@ -428,1 +414,0 @@\n-    private static @Stable HashMap<MethodType,MethodType> archivedMethodTypes;\n@@ -1400,11 +1385,0 @@\n-    static HashMap<MethodType,MethodType> copyInternTable() {\n-        HashMap<MethodType,MethodType> copy = new HashMap<>();\n-\n-        for (Iterator<MethodType> i = internTable.iterator(); i.hasNext(); ) {\n-            MethodType t = i.next();\n-            copy.put(t, t);\n-        }\n-\n-        return copy;\n-    }\n-\n@@ -1413,11 +1387,2 @@\n-    static void createArchivedObjects() {\n-        \/\/ After the archivedMethodTypes field is assigned, this table\n-        \/\/ is never modified. So we don't need synchronization when reading from\n-        \/\/ it (which happens only in a future JVM process, never in the current process).\n-        \/\/\n-        \/\/ @implNote CDS.isDumpingStaticArchive() is mutually exclusive with\n-        \/\/ CDS.isUsingArchive(); at most one of them can return true for any given JVM\n-        \/\/ process.\n-        assert CDS.isDumpingStaticArchive();\n-        archivedMethodTypes = copyInternTable();\n-        internTable.clear();\n+    private static void assemblySetup() {\n+        internTable.prepareForAOTCache();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":3,"deletions":38,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -55,1 +54,1 @@\n-    private final Object[] methodHandles;\n+    private final SoftReference<MethodHandle>[] methodHandles;\n@@ -65,1 +64,1 @@\n-    private final Object[] lambdaForms;\n+    private final SoftReference<LambdaForm>[] lambdaForms;\n@@ -114,1 +113,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -116,8 +114,2 @@\n-        Object entry = methodHandles[which];\n-        if (entry == null) {\n-            return null;\n-        } else if (entry instanceof MethodHandle mh) {\n-            return mh;\n-        } else {\n-            return ((SoftReference<MethodHandle>)entry).get();\n-        }\n+        SoftReference<MethodHandle> entry = methodHandles[which];\n+        return (entry != null) ? entry.get() : null;\n@@ -132,5 +124,1 @@\n-        if (USE_SOFT_CACHE) {\n-            methodHandles[which] = new SoftReference<>(mh);\n-        } else {\n-            methodHandles[which] = mh;\n-        }\n+        methodHandles[which] = new SoftReference<>(mh);\n@@ -140,1 +128,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -142,8 +129,2 @@\n-        Object entry = lambdaForms[which];\n-        if (entry == null) {\n-            return null;\n-        } else if (entry instanceof LambdaForm lf) {\n-            return lf;\n-        } else {\n-            return ((SoftReference<LambdaForm>)entry).get();\n-        }\n+        SoftReference<LambdaForm> entry = lambdaForms[which];\n+        return (entry != null) ? entry.get() : null;\n@@ -158,5 +139,1 @@\n-        if (USE_SOFT_CACHE) {\n-            lambdaForms[which] = new SoftReference<>(form);\n-        } else {\n-            lambdaForms[which] = form;\n-        }\n+        lambdaForms[which] = new SoftReference<>(form);\n@@ -184,0 +161,1 @@\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -224,2 +202,2 @@\n-            this.lambdaForms   = new Object[LF_LIMIT];\n-            this.methodHandles = new Object[MH_LIMIT];\n+            this.lambdaForms   = new SoftReference[LF_LIMIT];\n+            this.methodHandles = new SoftReference[MH_LIMIT];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":11,"deletions":33,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-     *   queue = ReferenceQueue.NULL; next = this.\n+     *   queue = ReferenceQueue.NULL_QUEUE; next = this.\n@@ -92,1 +92,1 @@\n-     *   queue = ReferenceQueue.NULL.\n+     *   queue = ReferenceQueue.NULL_QUEUE.\n@@ -174,2 +174,2 @@\n-     *        dequeued: ReferenceQueue.NULL\n-     *    unregistered: ReferenceQueue.NULL\n+     *        dequeued: ReferenceQueue.NULL_QUEUE\n+     *    unregistered: ReferenceQueue.NULL_QUEUE\n@@ -245,1 +245,1 @@\n-        if (q != ReferenceQueue.NULL) q.enqueue(this);\n+        if (q != ReferenceQueue.NULL_QUEUE) q.enqueue(this);\n@@ -319,0 +319,1 @@\n+    \/\/ Called from JVM when loading an AOT cache\n@@ -320,0 +321,4 @@\n+        runtimeSetup();\n+    }\n+\n+    private static void runtimeSetup() {\n@@ -556,1 +561,1 @@\n-        this.queue = (queue == null) ? ReferenceQueue.NULL : queue;\n+        this.queue = (queue == null) ? ReferenceQueue.NULL_QUEUE : queue;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    static final ReferenceQueue<Object> NULL = new Null();\n+    static final ReferenceQueue<Object> NULL_QUEUE = new Null();\n@@ -77,1 +77,1 @@\n-        if ((queue == NULL) || (queue == ENQUEUED)) {\n+        if ((queue == NULL_QUEUE) || (queue == ENQUEUED)) {\n@@ -99,1 +99,1 @@\n-            r.queue = NULL;\n+            r.queue = NULL_QUEUE;\n@@ -251,1 +251,1 @@\n-                    \/\/ already dequeued: r.queue == NULL; ->\n+                    \/\/ already dequeued: r.queue == NULL_QUEUE; ->\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,14 @@\n-import java.util.Collections;\n-import java.util.Objects;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.MethodParameterInfo;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleExportInfo;\n+import java.lang.classfile.attribute.ModuleOpenInfo;\n+import java.lang.classfile.attribute.ModuleRequireInfo;\n+import java.lang.module.ModuleDescriptor;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n@@ -34,0 +46,2 @@\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n@@ -35,2 +49,7 @@\n-import java.util.function.Function;\n-import static java.util.Map.entry;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.reflect.ClassFileFormatVersion.*;\n@@ -99,5 +118,0 @@\n-    \/\/ Note to maintainers: anonymous class instances are used rather\n-    \/\/ than lambdas to initialize the functions used for the\n-    \/\/ cffvToLocations field to avoid using lambdas too early in JDK\n-    \/\/ initialization.\n-\n@@ -110,9 +124,2 @@\n-           Location.SET_PUBLIC_1,\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                       Location.SET_CLASS_FIELD_METHOD:\n-                       Location.SET_PUBLIC_1;\n-               }\n-           }),\n+           Location.SET_CLASS_FIELD_METHOD_INNER_CLASS,\n+           List.of(Map.entry(RELEASE_0, Location.SET_CLASS_FIELD_METHOD))),\n@@ -126,8 +133,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                    public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                        Location.SET_FIELD_METHOD:\n-                        Location.SET_FIELD_METHOD_INNER_CLASS;\n-                }\n-            }),\n+            List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -141,8 +141,1 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                  return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                      Location.SET_FIELD_METHOD:\n-                      Location.SET_FIELD_METHOD_INNER_CLASS;\n-                  }\n-              }),\n+              List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -156,7 +149,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                       Location.SET_FIELD_METHOD:\n-                       Location.SET_FIELD_METHOD_INNER_CLASS;}\n-           }),\n+           List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -171,12 +158,2 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-              @Override\n-              public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                  if (cffv.compareTo(ClassFileFormatVersion.RELEASE_8) >= 0) {\n-                      return Location.SET_FINAL_8;\n-                  } else {\n-                      return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                          Location.SET_CLASS_FIELD_METHOD :\n-                          Location.SET_CLASS_FIELD_METHOD_INNER_CLASS;\n-                  }\n-              }\n-          }),\n+          List.of(Map.entry(RELEASE_7, Location.SET_CLASS_FIELD_METHOD_INNER_CLASS),\n+                  Map.entry(RELEASE_0, Location.SET_CLASS_FIELD_METHOD))),\n@@ -195,8 +172,2 @@\n-            PreviewFeatures.isEnabled() ? Location.EMPTY_SET : Location.SET_CLASS,\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-            @Override\n-            public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                return (cffv.compareTo(ClassFileFormatVersion.latest()) >= 0) &&\n-                        PreviewFeatures.isEnabled() ? Location.EMPTY_SET : Location.SET_CLASS;\n-            }\n-        }),\n+          PreviewFeatures.isEnabled() ? Location.EMPTY_SET : Location.SET_CLASS,\n+          List.of()),\n@@ -215,8 +186,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv.compareTo(ClassFileFormatVersion.latest()) >= 0\n-                            && PreviewFeatures.isEnabled())\n-                            ? Location.SET_CLASS_INNER_CLASS : Location.EMPTY_SET;\n-                }\n-            }),\n+            List.of()),\n@@ -230,7 +194,1 @@\n-         new Function<ClassFileFormatVersion, Set<Location>>() {\n-             @Override\n-             public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                 return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                     Location.SET_MODULE:\n-                     Location.EMPTY_SET;}\n-         }),\n+         List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -244,7 +202,1 @@\n-               new Function<ClassFileFormatVersion, Set<Location>>() {\n-                   @Override\n-                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                           Location.SET_MODULE_REQUIRES:\n-                           Location.EMPTY_SET;}\n-               }),\n+               List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -257,1 +209,1 @@\n-    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD, null),\n+    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD, List.of()),\n@@ -265,7 +217,1 @@\n-                 new Function<ClassFileFormatVersion, Set<Location>>() {\n-                     @Override\n-                     public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                         return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                             Location.SET_MODULE_REQUIRES:\n-                             Location.EMPTY_SET;}\n-                 }),\n+                 List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -278,1 +224,1 @@\n-    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD, null),\n+    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD, List.of()),\n@@ -286,7 +232,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                       Location.SET_METHOD:\n-                       Location.EMPTY_SET;}\n-           }),\n+           List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -299,1 +239,1 @@\n-    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD, null),\n+    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD, List.of()),\n@@ -303,1 +243,1 @@\n-     <code>{@value \"0x%04x\" Modifier#VARARGS}<\/code>.\n+     * <code>{@value \"0x%04x\" Modifier#VARARGS}<\/code>.\n@@ -307,7 +247,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                        Location.SET_METHOD:\n-                        Location.EMPTY_SET;}\n-            }),\n+            List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -320,1 +254,1 @@\n-    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD, null),\n+    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD, List.of()),\n@@ -328,7 +262,1 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                      return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n-                          Location.SET_CLASS:\n-                          Location.SET_CLASS_INNER_CLASS;}\n-              }),\n+              List.of(Map.entry(RELEASE_0, Location.SET_CLASS))),\n@@ -343,7 +271,1 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-                 @Override\n-                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                     return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n-                         Location.SET_CLASS_METHOD:\n-                         Location.SET_CLASS_METHOD_INNER_CLASS;}\n-             }),\n+             List.of(Map.entry(RELEASE_0, Location.SET_CLASS_METHOD))),\n@@ -362,8 +284,2 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n-                           cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n-                       Location.SET_METHOD:\n-                       Location.EMPTY_SET;}\n-           }),\n+           List.of(Map.entry(RELEASE_16, Location.SET_METHOD),\n+                   Map.entry(RELEASE_1, Location.EMPTY_SET))),\n@@ -381,8 +297,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv.compareTo(ClassFileFormatVersion.latest()) >= 0\n-                            && PreviewFeatures.isEnabled())\n-                            ? Location.SET_FIELD : Location.EMPTY_SET;\n-                }\n-            }),\n+                List.of()),\n@@ -398,15 +307,3 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                      if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 )\n-                          return Location.SET_SYNTHETIC_9;\n-                      else {\n-                          return\n-                              switch(cffv) {\n-                              case RELEASE_7 -> Location.SET_SYNTHETIC_7;\n-                              case RELEASE_8 -> Location.SET_SYNTHETIC_8;\n-                              default        -> Location.EMPTY_SET;\n-                              };\n-                      }\n-                  }\n-              }),\n+              List.of(Map.entry(RELEASE_8, Location.SET_SYNTHETIC_8),\n+                      Map.entry(RELEASE_7, Location.SET_SYNTHETIC_5),\n+                      Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -420,7 +317,1 @@\n-               new Function<ClassFileFormatVersion, Set<Location>>() {\n-                   @Override\n-                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                           Location.SET_CLASS_INNER_CLASS:\n-                           Location.EMPTY_SET;}\n-               }),\n+               List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -434,7 +325,1 @@\n-         new Function<ClassFileFormatVersion, Set<Location>>() {\n-             @Override\n-             public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                 return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                     Location.SET_CLASS_FIELD_INNER_CLASS:\n-                     Location.EMPTY_SET;}\n-         }),\n+         List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -447,12 +332,2 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-                 @Override\n-                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                     if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) {\n-                         return Location.SET_MANDATED_9;\n-                     } else {\n-                         return (cffv == ClassFileFormatVersion.RELEASE_8) ?\n-                             Location.SET_METHOD_PARAM:\n-                             Location.EMPTY_SET;\n-                     }\n-                 }\n-             }),\n+             List.of(Map.entry(RELEASE_8, Location.SET_METHOD_PARAM),\n+                     Map.entry(RELEASE_7, Location.EMPTY_SET))),\n@@ -465,7 +340,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                       Location.SET_CLASS:\n-                       Location.EMPTY_SET;}\n-           })\n+           List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -480,2 +349,1 @@\n-    \/\/ Intentionally using Set rather than EnumSet since EnumSet is\n-    \/\/ mutable.\n+    \/\/ immutable\n@@ -483,2 +351,2 @@\n-    \/\/ Lambda to implement locations(ClassFileFormatVersion cffv)\n-    private final Function<ClassFileFormatVersion, Set<Location>> cffvToLocations;\n+    \/\/ historical locations up to a given version; immutable\n+    private final List<Map.Entry<ClassFileFormatVersion, Set<Location>>> historicalLocations;\n@@ -489,1 +357,1 @@\n-                       Function<ClassFileFormatVersion, Set<Location>> cffvToLocations) {\n+                       List<Map.Entry<ClassFileFormatVersion, Set<Location>>> historicalLocations) {\n@@ -493,1 +361,1 @@\n-        this.cffvToLocations = cffvToLocations;\n+        this.historicalLocations = Location.ensureHistoryOrdered(historicalLocations);\n@@ -497,1 +365,2 @@\n-     * {@return the corresponding integer mask for the access flag}\n+     * {@return the corresponding mask for the access flag}  The mask has\n+     * exactly one bit set and is in the range of {@code char}.\n@@ -504,1 +373,1 @@\n-     * {@return whether or not the flag has a directly corresponding\n+     * {@return whether or not this flag has a directly corresponding\n@@ -512,2 +381,5 @@\n-     * {@return kinds of constructs the flag can be applied to in the\n-     * latest class file format version}\n+     * {@return locations this flag can be applied to in the current class file\n+     * format version}\n+     * <p>\n+     * This method returns an empty set if this flag is not defined in\n+     * the current class file format version.\n@@ -520,2 +392,6 @@\n-     * {@return kinds of constructs the flag can be applied to in the\n-     * given class file format version}\n+     * {@return locations this flag can be applied to in the given class file\n+     * format version}\n+     * <p>\n+     * This method returns an empty set if this flag is not defined in\n+     * the given {@code cffv}.\n+     *\n@@ -526,6 +402,1 @@\n-        Objects.requireNonNull(cffv);\n-        if (cffvToLocations == null) {\n-            return locations;\n-        } else {\n-            return cffvToLocations.apply(cffv);\n-        }\n+        return Location.findInHistory(locations, historicalLocations, cffv);\n@@ -544,12 +415,5 @@\n-        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n-        for (var accessFlag : LocationToFlags.locationToFlags.get(location)) {\n-            int accessMask = accessFlag.mask();\n-            if ((mask & accessMask) != 0) {\n-                result.add(accessFlag);\n-                mask = mask & ~accessMask;\n-                if (mask == 0) {\n-                    break;      \/\/ no more mask bits\n-                }\n-            }\n-        }\n-        if (mask != 0) {\n+        var definition = findDefinition(location);\n+        int flagsMask = location.flagsMask();\n+        int parsingMask = location == Location.METHOD ? flagsMask | ACC_STRICT : flagsMask; \/\/ flagMask lacks strictfp\n+        int unmatchedMask = mask & (~parsingMask);\n+        if (unmatchedMask != 0) {\n@@ -557,2 +421,2 @@\n-                                               Integer.toHexString(mask) +\n-                                               \" for location \" + location);\n+                    Integer.toHexString(unmatchedMask) +\n+                    \" for location \" + location);\n@@ -560,1 +424,1 @@\n-        return Collections.unmodifiableSet(result);\n+        return new AccessFlagSet(definition, mask);\n@@ -577,15 +441,5 @@\n-        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n-        for (var accessFlag : AccessFlag.values()) {\n-            int accessMask = accessFlag.mask();\n-            if ((mask & accessMask) != 0) {\n-                var locations = accessFlag.locations(cffv);\n-                if (locations.contains(location)) {\n-                    result.add(accessFlag);\n-                    mask = mask & ~accessMask;\n-                    if (mask == 0) {\n-                        break;      \/\/ no more mask bits\n-                    }\n-                }\n-            }\n-        }\n-        if (mask != 0) {\n+        var definition = findDefinition(location);\n+        int flagsMask = location.flagsMask(cffv);\n+        int parsingMask = location == Location.METHOD ? flagsMask | ACC_STRICT : flagsMask; \/\/ flagMask lacks strictfp\n+        int unmatchedMask = mask & (~parsingMask);\n+        if (unmatchedMask != 0) {\n@@ -593,3 +447,2 @@\n-                                               Integer.toHexString(mask) +\n-                                               \" for location \" + location +\n-                                               \" for class file format version \" + cffv);\n+                    Integer.toHexString(unmatchedMask) +\n+                    \" for location \" + location);\n@@ -597,1 +450,1 @@\n-        return Collections.unmodifiableSet(result);\n+        return new AccessFlagSet(definition, mask);\n@@ -600,1 +453,0 @@\n-\n@@ -602,4 +454,4 @@\n-     * A location within a class file where flags can be applied.\n-     *\n-     * Note that since these locations represent class file structures\n-     * rather than language structures many language structures, such\n+     * A location within a {@code class} file where flags can be applied.\n+     * <p>\n+     * Note that since these locations represent {@code class} file structures\n+     * rather than language structures, many language structures, such\n@@ -612,1 +464,6 @@\n-         * @jvms 4.1 The ClassFile Structure\n+         *\n+         * @see Class#accessFlags()\n+         * @see ClassModel#flags()\n+         * @see Modifier#classModifiers()\n+         * @see Modifier#interfaceModifiers()\n+         * @jvms 4.1 The {@code ClassFile} Structure\n@@ -614,1 +471,11 @@\n-        CLASS,\n+        CLASS(ACC_PUBLIC | ACC_FINAL | (PreviewFeatures.isEnabled() ? ACC_IDENTITY : ACC_SUPER) |\n+              ACC_INTERFACE | ACC_ABSTRACT |\n+              ACC_SYNTHETIC | ACC_ANNOTATION |\n+              ACC_ENUM | ACC_MODULE,\n+              List.of(Map.entry(RELEASE_8, \/\/ no module\n+                                ACC_PUBLIC | ACC_FINAL | ACC_SUPER |\n+                                ACC_INTERFACE | ACC_ABSTRACT |\n+                                ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM),\n+                      Map.entry(RELEASE_4, \/\/ no synthetic, annotation, enum\n+                                ACC_PUBLIC | ACC_FINAL | ACC_SUPER |\n+                                ACC_INTERFACE | ACC_ABSTRACT))),\n@@ -618,0 +485,4 @@\n+         *\n+         * @see Field#accessFlags()\n+         * @see FieldModel#flags()\n+         * @see Modifier#fieldModifiers()\n@@ -620,1 +491,7 @@\n-        FIELD,\n+        FIELD(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+              ACC_STATIC | ACC_FINAL | ACC_VOLATILE |\n+              ACC_TRANSIENT | ACC_SYNTHETIC | ACC_ENUM | (PreviewFeatures.isEnabled() ? ACC_STRICT : 0),\n+              List.of(Map.entry(RELEASE_4, \/\/ no synthetic, enum\n+                                ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                ACC_STATIC | ACC_FINAL | ACC_VOLATILE |\n+                                ACC_TRANSIENT))),\n@@ -624,0 +501,5 @@\n+         *\n+         * @see Executable#accessFlags()\n+         * @see MethodModel#flags()\n+         * @see Modifier#methodModifiers()\n+         * @see Modifier#constructorModifiers()\n@@ -626,1 +508,17 @@\n-        METHOD,\n+        METHOD(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+               ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+               ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE |\n+               ACC_ABSTRACT | ACC_SYNTHETIC,\n+               List.of(Map.entry(RELEASE_16, \/\/ had strict\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE |\n+                                 ACC_ABSTRACT | ACC_STRICT | ACC_SYNTHETIC),\n+                       Map.entry(RELEASE_4, \/\/ no bridge, varargs, synthetic\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_NATIVE | ACC_ABSTRACT | ACC_STRICT),\n+                       Map.entry(RELEASE_1, \/\/ no strict\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_NATIVE | ACC_ABSTRACT))),\n@@ -630,1 +528,6 @@\n-         * @jvms 4.7.6 The InnerClasses Attribute\n+         *\n+         * @see Class#accessFlags()\n+         * @see InnerClassInfo#flags()\n+         * @see Modifier#classModifiers()\n+         * @see Modifier#interfaceModifiers()\n+         * @jvms 4.7.6 The {@code InnerClasses} Attribute\n@@ -632,1 +535,8 @@\n-        INNER_CLASS,\n+        INNER_CLASS(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | (PreviewFeatures.isEnabled() ? ACC_IDENTITY : 0) |\n+                    ACC_STATIC | ACC_FINAL | ACC_INTERFACE | ACC_ABSTRACT |\n+                    ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM,\n+                    List.of(Map.entry(RELEASE_4, \/\/ no synthetic, annotation, enum\n+                            ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                            ACC_STATIC | ACC_FINAL | ACC_INTERFACE |\n+                            ACC_ABSTRACT),\n+                            Map.entry(RELEASE_0, 0))), \/\/ did not exist\n@@ -636,1 +546,5 @@\n-         * @jvms 4.7.24 The MethodParameters Attribute\n+         *\n+         * @see Parameter#accessFlags()\n+         * @see MethodParameterInfo#flags()\n+         * @see Modifier#parameterModifiers()\n+         * @jvms 4.7.24 The {@code MethodParameters} Attribute\n@@ -638,1 +552,2 @@\n-        METHOD_PARAMETER,\n+        METHOD_PARAMETER(ACC_FINAL | ACC_SYNTHETIC | ACC_MANDATED,\n+                         List.of(Map.entry(RELEASE_7, 0))),  \/\/ did not exist\n@@ -641,2 +556,5 @@\n-         * Module location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module location.\n+         *\n+         * @see ModuleDescriptor#accessFlags()\n+         * @see ModuleAttribute#moduleFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -644,1 +562,2 @@\n-        MODULE,\n+        MODULE(ACC_OPEN | ACC_SYNTHETIC | ACC_MANDATED,\n+               List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -647,2 +566,5 @@\n-         * Module requires location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module requires location.\n+         *\n+         * @see ModuleDescriptor.Requires#accessFlags()\n+         * @see ModuleRequireInfo#requiresFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -650,1 +572,2 @@\n-        MODULE_REQUIRES,\n+        MODULE_REQUIRES(ACC_TRANSITIVE | ACC_STATIC_PHASE | ACC_SYNTHETIC | ACC_MANDATED,\n+                        List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -653,2 +576,5 @@\n-         * Module exports location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module exports location.\n+         *\n+         * @see ModuleDescriptor.Exports#accessFlags()\n+         * @see ModuleExportInfo#exportsFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -656,1 +582,2 @@\n-        MODULE_EXPORTS,\n+        MODULE_EXPORTS(ACC_SYNTHETIC | ACC_MANDATED,\n+                       List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -659,2 +586,5 @@\n-         * Module opens location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module opens location.\n+         *\n+         * @see ModuleDescriptor.Opens#accessFlags()\n+         * @see ModuleOpenInfo#opensFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -662,1 +592,3 @@\n-        MODULE_OPENS;\n+        MODULE_OPENS(ACC_SYNTHETIC | ACC_MANDATED,\n+                     List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n+        ;\n@@ -689,2 +621,0 @@\n-        private static final Set<Location> SET_PUBLIC_1 =\n-            Set.of(CLASS, FIELD, METHOD, INNER_CLASS);\n@@ -695,1 +625,1 @@\n-        private static final Set<Location> SET_SYNTHETIC_7 =\n+        private static final Set<Location> SET_SYNTHETIC_5 =\n@@ -702,1 +632,1 @@\n-              \/\/ Added as an access flag in 7\n+              \/\/ Added as an access flag in 5.0\n@@ -714,0 +644,94 @@\n+\n+        private final int flagsMask;\n+        private final List<Map.Entry<ClassFileFormatVersion, Integer>> historicalFlagsMasks;\n+\n+        Location(int flagsMask,\n+                 List<Map.Entry<ClassFileFormatVersion, Integer>> historicalFlagsMasks) {\n+            this.flagsMask = flagsMask;\n+            this.historicalFlagsMasks = ensureHistoryOrdered(historicalFlagsMasks);\n+        }\n+\n+        \/\/ Ensures the historical versions are from newest to oldest and do not include the latest\n+        \/\/ These 2 utilities reside in Location because Location must be initialized before AccessFlag\n+        private static <T> List<Map.Entry<ClassFileFormatVersion, T>> ensureHistoryOrdered(\n+                List<Map.Entry<ClassFileFormatVersion, T>> history) {\n+            ClassFileFormatVersion lastVersion = ClassFileFormatVersion.latest();\n+            for (var e : history) {\n+                var historyVersion = e.getKey();\n+                if (lastVersion.compareTo(historyVersion) <= 0) {\n+                    throw new IllegalArgumentException(\"Versions out of order\");\n+                }\n+                lastVersion = historyVersion;\n+            }\n+            return history;\n+        }\n+\n+        private static <T> T findInHistory(T candidate, List<Map.Entry<ClassFileFormatVersion, T>> history,\n+                                           ClassFileFormatVersion cffv) {\n+            Objects.requireNonNull(cffv);\n+            for (var e : history) {\n+                if (e.getKey().compareTo(cffv) < 0) {\n+                    \/\/ last version found was valid\n+                    return candidate;\n+                }\n+                candidate = e.getValue();\n+            }\n+            return candidate;\n+        }\n+\n+        \/**\n+         * {@return the union of masks of all access flags defined for\n+         * this location in the current class file format version}\n+         * <p>\n+         * This method returns {@code 0} if this location does not exist in\n+         * the current class file format version.\n+         *\n+         * @since 25\n+         *\/\n+        public int flagsMask() {\n+            return flagsMask;\n+        }\n+\n+        \/**\n+         * {@return the union of masks of all access flags defined for\n+         * this location in the given class file format version}\n+         * <p>\n+         * This method returns {@code 0} if this location does not exist in\n+         * the given {@code cffv}.\n+         *\n+         * @param cffv the class file format version\n+         * @throws NullPointerException if {@code cffv} is {@code null}\n+         * @since 25\n+         *\/\n+        public int flagsMask(ClassFileFormatVersion cffv) {\n+            return findInHistory(flagsMask, historicalFlagsMasks, cffv);\n+        }\n+\n+        \/**\n+         * {@return the set of access flags defined for this location in the\n+         * current class file format version}  The set is immutable.\n+         * <p>\n+         * This method returns an empty set if this location does not exist\n+         * in the current class file format version.\n+         *\n+         * @since 25\n+         *\/\n+        public Set<AccessFlag> flags() {\n+            return new AccessFlagSet(findDefinition(this), flagsMask());\n+        }\n+\n+        \/**\n+         * {@return the set of access flags defined for this location in the\n+         * given class file format version}  The set is immutable.\n+         * <p>\n+         * This method returns an empty set if this location does not exist\n+         * in the given {@code cffv}.\n+         *\n+         * @param cffv the class file format version\n+         * @throws NullPointerException if {@code cffv} is {@code null}\n+         * @since 25\n+         *\/\n+        public Set<AccessFlag> flags(ClassFileFormatVersion cffv) {\n+            \/\/ implicit null check cffv\n+            return new AccessFlagSet(findDefinition(this), flagsMask(cffv));\n+        }\n@@ -716,35 +740,127 @@\n-    private static class LocationToFlags {\n-        private static Map<Location, Set<AccessFlag>> locationToFlags =\n-            Map.ofEntries(entry(Location.CLASS,\n-                                Set.of(PUBLIC, FINAL, (PreviewFeatures.isEnabled() ? IDENTITY : SUPER),\n-                                       INTERFACE, ABSTRACT,\n-                                       SYNTHETIC, ANNOTATION,\n-                                       ENUM, AccessFlag.MODULE)),\n-                          entry(Location.FIELD,\n-                                PreviewFeatures.isEnabled() ?\n-                                        \/\/ STRICT_INIT should be included only if preview is enabled\n-                                        Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                            STATIC, FINAL, VOLATILE,\n-                                            TRANSIENT, SYNTHETIC, ENUM, STRICT_INIT) :\n-                                        Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                                STATIC, FINAL, VOLATILE,\n-                                                TRANSIENT, SYNTHETIC, ENUM)),\n-                          entry(Location.METHOD,\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                       STATIC, FINAL, SYNCHRONIZED,\n-                                       BRIDGE, VARARGS, NATIVE,\n-                                       ABSTRACT, STRICT, SYNTHETIC)),\n-                          entry(Location.INNER_CLASS,\n-                                          Set.of(PUBLIC, PRIVATE, PROTECTED, (PreviewFeatures.isEnabled() ? IDENTITY : SUPER),\n-                                                  STATIC, FINAL, INTERFACE, ABSTRACT,\n-                                                  SYNTHETIC, ANNOTATION, ENUM)),\n-                          entry(Location.METHOD_PARAMETER,\n-                                Set.of(FINAL, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE,\n-                                Set.of(OPEN, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_REQUIRES,\n-                                Set.of(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_EXPORTS,\n-                                Set.of(SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_OPENS,\n-                                Set.of(SYNTHETIC, MANDATED)));\n+    private static AccessFlag[] createDefinition(AccessFlag... known) {\n+        var ret = new AccessFlag[Character.SIZE];\n+        for (var flag : known) {\n+            var mask = flag.mask;\n+            int pos = Integer.numberOfTrailingZeros(mask);\n+            assert ret[pos] == null : ret[pos] + \" \" + flag;\n+            ret[pos] = flag;\n+        }\n+        return ret;\n+    }\n+\n+    private static AccessFlag[] findDefinition(Location location) {\n+        return switch (location) {\n+            case CLASS -> CLASS_FLAGS;\n+            case FIELD -> FIELD_FLAGS;\n+            case METHOD -> METHOD_FLAGS;\n+            case INNER_CLASS -> INNER_CLASS_FLAGS;\n+            case METHOD_PARAMETER -> METHOD_PARAMETER_FLAGS;\n+            case MODULE -> MODULE_FLAGS;\n+            case MODULE_REQUIRES -> MODULE_REQUIRES_FLAGS;\n+            case MODULE_EXPORTS -> MODULE_EXPORTS_FLAGS;\n+            case MODULE_OPENS -> MODULE_OPENS_FLAGS;\n+        };\n+    }\n+\n+    private static final @Stable AccessFlag[] \/\/ Can use stable array and lazy init in the future\n+            CLASS_FLAGS = createDefinition(PUBLIC, FINAL, (PreviewFeatures.isEnabled() ? IDENTITY : SUPER), INTERFACE, ABSTRACT, SYNTHETIC, ANNOTATION, ENUM, MODULE),\n+              FIELD_FLAGS = PreviewFeatures.isEnabled() ? \/\/ Using Valhalla\n+              createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, VOLATILE, TRANSIENT, SYNTHETIC, ENUM, STRICT_INIT) :\n+              createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, VOLATILE, TRANSIENT, SYNTHETIC, ENUM),\n+            METHOD_FLAGS = createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, SYNCHRONIZED, BRIDGE, VARARGS, NATIVE, ABSTRACT, STRICT, SYNTHETIC),\n+            INNER_CLASS_FLAGS = createDefinition(PUBLIC, PRIVATE, PROTECTED, (PreviewFeatures.isEnabled() ? IDENTITY : SUPER), STATIC, FINAL, INTERFACE, ABSTRACT, SYNTHETIC, ANNOTATION, ENUM),\n+            METHOD_PARAMETER_FLAGS = createDefinition(FINAL, SYNTHETIC, MANDATED),\n+            MODULE_FLAGS = createDefinition(OPEN, SYNTHETIC, MANDATED),\n+            MODULE_REQUIRES_FLAGS = createDefinition(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED),\n+            MODULE_EXPORTS_FLAGS = createDefinition(SYNTHETIC, MANDATED),\n+            MODULE_OPENS_FLAGS = createDefinition(SYNTHETIC, MANDATED);\n+\n+    private static int undefinedMask(AccessFlag[] definition, int mask) {\n+        assert definition.length == Character.SIZE;\n+        int definedMask = 0;\n+        for (int i = 0; i < Character.SIZE; i++) {\n+            if (definition[i] != null) {\n+                definedMask |= 1 << i;\n+            }\n+        }\n+        return mask & ~definedMask;\n+    }\n+\n+    private static final class AccessFlagSet extends AbstractSet<AccessFlag> {\n+        private final @Stable AccessFlag[] definition;\n+        private final int mask;\n+\n+        \/\/ all mutating methods throw UnsupportedOperationException\n+        @Override public boolean add(AccessFlag e) { throw uoe(); }\n+        @Override public boolean addAll(Collection<? extends AccessFlag> c) { throw uoe(); }\n+        @Override public void    clear() { throw uoe(); }\n+        @Override public boolean remove(Object o) { throw uoe(); }\n+        @Override public boolean removeAll(Collection<?> c) { throw uoe(); }\n+        @Override public boolean removeIf(Predicate<? super AccessFlag> filter) { throw uoe(); }\n+        @Override public boolean retainAll(Collection<?> c) { throw uoe(); }\n+        private static UnsupportedOperationException uoe() { return new UnsupportedOperationException(); }\n+\n+        private AccessFlagSet(AccessFlag[] definition, int mask) {\n+            assert undefinedMask(definition, mask) == 0 : mask;\n+            this.definition = definition;\n+            this.mask = mask;\n+        }\n+\n+        @Override\n+        public Iterator<AccessFlag> iterator() {\n+            return new AccessFlagIterator(definition, mask);\n+        }\n+\n+        @Override\n+        public void forEach(Consumer<? super AccessFlag> action) {\n+            Objects.requireNonNull(action); \/\/ in case of empty\n+            for (int i = 0; i < Character.SIZE; i++) {\n+                if ((mask & (1 << i)) != 0) {\n+                    action.accept(definition[i]);\n+                }\n+            }\n+        }\n+\n+        private static final class AccessFlagIterator implements Iterator<AccessFlag> {\n+            private final @Stable AccessFlag[] definition;\n+            private int remainingMask;\n+\n+            private AccessFlagIterator(AccessFlag[] definition, int remainingMask) {\n+                this.definition = definition;\n+                this.remainingMask = remainingMask;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return remainingMask != 0;\n+            }\n+\n+            @Override\n+            public AccessFlag next() {\n+                int flagBit = Integer.lowestOneBit(remainingMask);\n+                if (flagBit == 0) {\n+                    throw new NoSuchElementException();\n+                }\n+                remainingMask &= ~flagBit;\n+                return definition[Integer.numberOfTrailingZeros(flagBit)];\n+            }\n+        }\n+\n+        @Override\n+        public int size() {\n+            return Integer.bitCount(mask);\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            if (Objects.requireNonNull(o) instanceof AccessFlag flag) {\n+                int bit = flag.mask;\n+                return (bit & mask) != 0 && definition[Integer.numberOfTrailingZeros(bit)] == flag;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return mask == 0;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":420,"deletions":304,"binary":false,"changes":724,"status":"modified"},{"patch":"@@ -484,0 +484,2 @@\n+     * @see AccessFlag.Location#CLASS\n+     * @see AccessFlag.Location#INNER_CLASS\n@@ -497,0 +499,2 @@\n+     * @see AccessFlag.Location#CLASS\n+     * @see AccessFlag.Location#INNER_CLASS\n@@ -510,0 +514,1 @@\n+     * @see AccessFlag.Location#METHOD\n@@ -523,0 +528,1 @@\n+     * @see AccessFlag.Location#METHOD\n@@ -536,0 +542,1 @@\n+     * @see AccessFlag.Location#FIELD\n@@ -549,0 +556,1 @@\n+     * @see AccessFlag.Location#METHOD_PARAMETER\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,2 +64,0 @@\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n@@ -783,1 +781,1 @@\n-            return baseClock.hashCode() ^ ((int) (tickNanos ^ (tickNanos >>> 32)));\n+            return baseClock.hashCode() ^ Long.hashCode(tickNanos);\n","filename":"src\/java.base\/share\/classes\/java\/time\/Clock.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1471,1 +1471,1 @@\n-        return ((int) (seconds ^ (seconds >>> 32))) + (51 * nanos);\n+        return Long.hashCode(seconds) + (51 * nanos);\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1374,1 +1374,1 @@\n-        return ((int) (seconds ^ (seconds >>> 32))) + 51 * nanos;\n+        return Long.hashCode(seconds) + 51 * nanos;\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2144,4 +2144,1 @@\n-        int yearValue = year;\n-        int monthValue = month;\n-        int dayValue = day;\n-        return (yearValue & 0xFFFFF800) ^ ((yearValue << 11) + (monthValue << 6) + (dayValue));\n+        return (year & 0xFFFFF800) ^ ((year << 11) + (month << 6) + day);\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -425,1 +425,1 @@\n-        return getChronology().hashCode() ^ ((int) (epDay ^ (epDay >>> 32)));\n+        return getChronology().hashCode() ^ Long.hashCode(epDay);\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoLocalDateImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n- * <p>Certain methods are specified to be\n+ * <p><a id=\"optional-operations\"><\/a>Certain methods are specified to be\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.function.IntFunction;\n@@ -40,0 +41,1 @@\n+import java.util.function.Supplier;\n@@ -41,0 +43,1 @@\n+\n@@ -43,0 +46,2 @@\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n@@ -44,0 +49,3 @@\n+import jdk.internal.util.ArraysSupport;\n+import jdk.internal.util.NullableKeyValueHolder;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -131,0 +139,6 @@\n+                public <E> List<E> stableList(int size, IntFunction<? extends E> mapper) {\n+                    return ImmutableCollections.stableList(size, mapper);\n+                }\n+                public <K, V> Map<K, V> stableMap(Set<K> keys, Function<? super K, ? extends V> mapper) {\n+                    return new StableMap<>(keys, mapper);\n+                }\n@@ -253,0 +267,5 @@\n+    static <E> List<E> stableList(int size, IntFunction<? extends E> mapper) {\n+        \/\/ A lazy list is not Serializable so, we cannot return `List.of()` if size == 0\n+        return new StableList<>(size, mapper);\n+    }\n+\n@@ -451,1 +470,1 @@\n-            assert root instanceof List12 || root instanceof ListN;\n+            assert root instanceof List12 || root instanceof ListN || root instanceof StableList;\n@@ -502,1 +521,2 @@\n-            return root instanceof ListN && ((ListN<?>)root).allowNulls;\n+            return root instanceof ListN<?> listN && listN.allowNulls\n+                    || root instanceof StableList<E>;\n@@ -554,0 +574,9 @@\n+\n+        @Override\n+        public String toString() {\n+            if (root instanceof StableList<E> stableList) {\n+                return StableUtil.renderElements(root, \"StableList\", stableList.delegates, offset, size);\n+            } else {\n+                return super.toString();\n+            }\n+        }\n@@ -771,0 +800,110 @@\n+    @jdk.internal.ValueBased\n+    static final class StableList<E> extends AbstractImmutableList<E> {\n+\n+        @Stable\n+        private final IntFunction<? extends E> mapper;\n+        @Stable\n+        final StableValueImpl<E>[] delegates;\n+\n+        StableList(int size, IntFunction<? extends E> mapper) {\n+            this.mapper = mapper;\n+            this.delegates = StableUtil.array(size);\n+        }\n+\n+        @Override public boolean  isEmpty() { return delegates.length == 0;}\n+        @Override public int      size() { return delegates.length; }\n+        @Override public Object[] toArray() { return copyInto(new Object[size()]); }\n+\n+        @ForceInline\n+        @Override\n+        public E get(int i) {\n+            final StableValueImpl<E> delegate;\n+            try {\n+                delegate = delegates[i];\n+            } catch (ArrayIndexOutOfBoundsException aioobe) {\n+                throw new IndexOutOfBoundsException(i);\n+            }\n+            return delegate.orElseSet(new Supplier<E>() {\n+                        @Override  public E get() { return mapper.apply(i); }});\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(T[] a) {\n+            final int size = delegates.length;\n+            if (a.length < size) {\n+                \/\/ Make a new array of a's runtime type, but my contents:\n+                T[] n = (T[])Array.newInstance(a.getClass().getComponentType(), size);\n+                return copyInto(n);\n+            }\n+            copyInto(a);\n+            if (a.length > size) {\n+                a[size] = null; \/\/ null-terminate\n+            }\n+            return a;\n+        }\n+\n+        @Override\n+        public int indexOf(Object o) {\n+            final int size = size();\n+            for (int i = 0; i < size; i++) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object o) {\n+            for (int i = size() - 1; i >= 0; i--) {\n+                if (Objects.equals(o, get(i))) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private <T> T[] copyInto(Object[] a) {\n+            final int len = delegates.length;\n+            for (int i = 0; i < len; i++) {\n+                a[i] = get(i);\n+            }\n+            return (T[]) a;\n+        }\n+\n+        @Override\n+        public List<E> reversed() {\n+            return new StableReverseOrderListView<>(this);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return StableUtil.renderElements(this, \"StableList\", delegates);\n+        }\n+\n+        private static final class StableReverseOrderListView<E> extends ReverseOrderListView.Rand<E> {\n+\n+            private StableReverseOrderListView(List<E> base) {\n+                super(base, false);\n+            }\n+\n+            \/\/ This method does not evaluate the elements\n+            @Override\n+            public String toString() {\n+                final StableValueImpl<E>[] delegates = ((StableList<E>)base).delegates;\n+                final StableValueImpl<E>[] reversed = ArraysSupport.reverse(\n+                        Arrays.copyOf(delegates, delegates.length));\n+                return StableUtil.renderElements(base, \"Collection\", reversed);\n+            }\n+\n+            @Override\n+            public List<E> reversed() {\n+                return base;\n+            }\n+\n+        }\n+\n+    }\n+\n@@ -1115,1 +1254,1 @@\n-    abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> implements Serializable {\n+    abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> {\n@@ -1146,1 +1285,1 @@\n-    static final class Map1<K,V> extends AbstractImmutableMap<K,V> {\n+    static final class Map1<K,V> extends AbstractImmutableMap<K,V> implements Serializable {\n@@ -1218,1 +1357,1 @@\n-    static final class MapN<K,V> extends AbstractImmutableMap<K,V> {\n+    static final class MapN<K,V> extends AbstractImmutableMap<K,V> implements Serializable {\n@@ -1408,0 +1547,124 @@\n+\n+    static final class StableMap<K, V>\n+            extends AbstractImmutableMap<K, V> {\n+\n+        @Stable\n+        private final Function<? super K, ? extends V> mapper;\n+        @Stable\n+        private final Map<K, StableValueImpl<V>> delegate;\n+\n+        StableMap(Set<K> keys, Function<? super K, ? extends V> mapper) {\n+            this.mapper = mapper;\n+            this.delegate = StableUtil.map(keys);\n+        }\n+\n+        @Override public boolean              containsKey(Object o) { return delegate.containsKey(o); }\n+        @Override public int                  size() { return delegate.size(); }\n+        @Override public Set<Map.Entry<K, V>> entrySet() { return new StableMapEntrySet(); }\n+\n+        @ForceInline\n+        @Override\n+        public V get(Object key) {\n+            return getOrDefault(key, null);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public V getOrDefault(Object key, V defaultValue) {\n+            final StableValueImpl<V> stable = delegate.get(key);\n+            if (stable == null) {\n+                return defaultValue;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final K k = (K) key;\n+            return stable.orElseSet(new Supplier<V>() {\n+                @Override public V get() { return mapper.apply(k); }});\n+        }\n+\n+        @jdk.internal.ValueBased\n+        final class StableMapEntrySet extends AbstractImmutableSet<Map.Entry<K, V>> {\n+\n+            @Stable\n+            private final Set<Map.Entry<K, StableValueImpl<V>>> delegateEntrySet;\n+\n+            StableMapEntrySet() {\n+                this.delegateEntrySet = delegate.entrySet();\n+            }\n+\n+            @Override public Iterator<Map.Entry<K, V>> iterator() { return new LazyMapIterator(); }\n+            @Override public int                       size() { return delegateEntrySet.size(); }\n+            @Override public int                       hashCode() { return StableMap.this.hashCode(); }\n+\n+            @Override\n+            public String toString() {\n+                return StableUtil.renderMappings(this, \"StableSet\", delegateEntrySet, false);\n+            }\n+\n+            @jdk.internal.ValueBased\n+            final class LazyMapIterator implements Iterator<Map.Entry<K, V>> {\n+\n+                @Stable\n+                private final Iterator<Map.Entry<K, StableValueImpl<V>>> delegateIterator;\n+\n+                LazyMapIterator() {\n+                    this.delegateIterator = delegateEntrySet.iterator();\n+                }\n+\n+                @Override public boolean hasNext() { return delegateIterator.hasNext(); }\n+\n+                @Override\n+                public Entry<K, V> next() {\n+                    final Map.Entry<K, StableValueImpl<V>> inner = delegateIterator.next();\n+                    final K k = inner.getKey();\n+                    return new NullableKeyValueHolder<>(k, inner.getValue().orElseSet(new Supplier<V>() {\n+                        @Override public V get() { return mapper.apply(k); }}));\n+                }\n+\n+                @Override\n+                public void forEachRemaining(Consumer<? super Map.Entry<K, V>> action) {\n+                    final Consumer<? super Map.Entry<K, StableValueImpl<V>>> innerAction =\n+                            new Consumer<>() {\n+                                @Override\n+                                public void accept(Entry<K, StableValueImpl<V>> inner) {\n+                                    final K k = inner.getKey();\n+                                    action.accept(new NullableKeyValueHolder<>(k, inner.getValue().orElseSet(new Supplier<V>() {\n+                                        @Override public V get() { return mapper.apply(k); }})));\n+                                }\n+                            };\n+                    delegateIterator.forEachRemaining(innerAction);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public Collection<V> values() {\n+            return new StableMapValues();\n+        }\n+\n+        final class StableMapValues extends AbstractImmutableCollection<V> {\n+            @Override public Iterator<V> iterator() { return new ValueIterator(); }\n+            @Override public int size() { return StableMap.this.size(); }\n+            @Override public boolean isEmpty() { return StableMap.this.isEmpty();}\n+            @Override public boolean contains(Object v) { return StableMap.this.containsValue(v); }\n+\n+            private static final IntFunction<StableValueImpl<?>[]> GENERATOR = new IntFunction<StableValueImpl<?>[]>() {\n+                @Override\n+                public StableValueImpl<?>[] apply(int len) {\n+                    return new StableValueImpl<?>[len];\n+                }\n+            };\n+\n+            @Override\n+            public String toString() {\n+                final StableValueImpl<?>[] values = delegate.values().toArray(GENERATOR);\n+                return StableUtil.renderElements(StableMap.this, \"StableMap\", values);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return StableUtil.renderMappings(this, \"StableMap\", delegate.entrySet(), true);\n+        }\n+\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":269,"deletions":6,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-     *          supplying function is {@code null}\n+     *         supplying function is {@code null} or produces a {@code null} result\n","filename":"src\/java.base\/share\/classes\/java\/util\/Optional.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,3 @@\n-import java.lang.reflect.Field;\n+import jdk.internal.misc.Unsafe;\n+\n+import java.lang.invoke.VarHandle;\n@@ -179,0 +181,2 @@\n+            \/\/ Needed to ensure safe publication of setMap()\n+            VarHandle.releaseFence();\n@@ -530,7 +534,6 @@\n-        try {\n-            Field mapField = ConcurrentSkipListSet.class.getDeclaredField(\"m\");\n-            mapField.setAccessible(true);\n-            mapField.set(this, map);\n-        } catch (IllegalAccessException | NoSuchFieldException e) {\n-            throw new Error(e);\n-        }\n+        final Unsafe U = Unsafe.getUnsafe();\n+        U.putReference(\n+            this,\n+            U.objectFieldOffset(ConcurrentSkipListSet.class, \"m\"),\n+            map\n+        );\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentSkipListSet.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.lang.reflect.Field;\n@@ -60,0 +59,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -2098,7 +2098,6 @@\n-        try {\n-            Field lockField = CopyOnWriteArrayList.class.getDeclaredField(\"lock\");\n-            lockField.setAccessible(true);\n-            lockField.set(this, new Object());\n-        } catch (IllegalAccessException | NoSuchFieldException e) {\n-            throw new Error(e);\n-        }\n+        final Unsafe U = Unsafe.getUnsafe();\n+        U.putReference(\n+            this,\n+            U.objectFieldOffset(CopyOnWriteArrayList.class, \"lock\"),\n+            new Object()\n+        );\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CopyOnWriteArrayList.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.internal.misc.Unsafe;\n+\n@@ -41,1 +43,0 @@\n-import java.lang.reflect.Field;\n@@ -333,1 +334,0 @@\n-        try {\n@@ -335,6 +335,6 @@\n-            Field arrayField = AtomicReferenceArray.class.getDeclaredField(\"array\");\n-            arrayField.setAccessible(true);\n-            arrayField.set(this, a);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n-            throw new Error(e);\n-        }\n+        final Unsafe U = Unsafe.getUnsafe();\n+        U.putReference(\n+            this,\n+            U.objectFieldOffset(AtomicReferenceArray.class, \"array\"),\n+            a\n+        );\n@@ -526,1 +526,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceArray.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -101,1 +101,6 @@\n-        if (iv == null) throw new IllegalArgumentException(\"IV missing\");\n+        if (iv == null) {\n+            throw new IllegalArgumentException(\"IV missing\");\n+        }\n+        if (offset < 0) {\n+            throw new ArrayIndexOutOfBoundsException(\"offset is negative\");\n+        }\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/RC2ParameterSpec.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.access;\n-\n-import java.io.FilePermission;\n-\n-public interface JavaIOFilePermissionAccess {\n-\n-    \/**\n-     * Returns a new FilePermission plus an alternative path.\n-     *\n-     * @param input the input\n-     * @return the new FilePermission plus the alt path (as npath2)\n-     *         or the input itself if no alt path is available.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    FilePermission newPermPlusAltPath(FilePermission input);\n-\n-    \/**\n-     * Returns a new FilePermission using an alternative path.\n-     *\n-     * @param input the input\n-     * @return the new FilePermission using the alt path (as npath)\n-     *         or null if no alt path is available\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    FilePermission newPermUsingAltPath(FilePermission input);\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaIOFilePermissionAccess.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -234,5 +234,0 @@\n-    \/**\n-     * Updates module m to open all packages in the given sets.\n-     *\/\n-    void addOpensToAllUnnamed(Module m, Set<String> concealedPkgs, Set<String> exportedPkgs);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,4 @@\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n@@ -33,0 +37,2 @@\n+    <E> List<E> stableList(int size, IntFunction<? extends E> mapper);\n+    <K, V> Map<K, V> stableMap(Set<K> keys, Function<? super K, ? extends V> mapper);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilCollectionAccess.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-    private static JavaIOFilePermissionAccess javaIOFilePermissionAccess;\n@@ -290,14 +289,0 @@\n-    @SuppressWarnings(\"removal\")\n-    public static JavaIOFilePermissionAccess getJavaIOFilePermissionAccess() {\n-        var access = javaIOFilePermissionAccess;\n-        if (access == null) {\n-            ensureClassInitialized(FilePermission.class);\n-            access = javaIOFilePermissionAccess;\n-        }\n-        return access;\n-    }\n-\n-    public static void setJavaIOFilePermissionAccess(JavaIOFilePermissionAccess jiofpa) {\n-        javaIOFilePermissionAccess = jiofpa;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n+import jdk.internal.constant.PrimitiveClassDescImpl;\n@@ -76,5 +78,0 @@\n-    static boolean isArrayDescriptor(Utf8EntryImpl cs) {\n-        \/\/ Do not throw out-of-bounds for empty strings\n-        return !cs.isEmpty() && cs.charAt(0) == '[';\n-    }\n-\n@@ -441,0 +438,73 @@\n+\n+        @Override\n+        public boolean isFieldType(ClassDesc desc) {\n+            var sym = typeSym;\n+            if (sym != null) {\n+                return sym instanceof ClassDesc cd && cd.equals(desc);\n+            }\n+\n+            \/\/ In parsing, Utf8Entry is not even inflated by this point\n+            \/\/ We can operate on the raw byte arrays, as all ascii are compatible\n+            var ret = state == State.RAW\n+                    ? rawEqualsSym(desc)\n+                    : equalsString(desc.descriptorString());\n+            if (ret)\n+                this.typeSym = desc;\n+            return ret;\n+        }\n+\n+        private boolean rawEqualsSym(ClassDesc desc) {\n+            int len = rawLen;\n+            if (len < 1) {\n+                return false;\n+            }\n+            int c = rawBytes[offset];\n+            if (len == 1) {\n+                return desc instanceof PrimitiveClassDescImpl pd && pd.wrapper().basicTypeChar() == c;\n+            } else if (c == 'L') {\n+                return desc.isClassOrInterface() && equalsString(desc.descriptorString());\n+            } else if (c == '[') {\n+                return desc.isArray() && equalsString(desc.descriptorString());\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        boolean mayBeArrayDescriptor() {\n+            if (state == State.RAW) {\n+                return rawLen > 0 && rawBytes[offset] == '[';\n+            } else {\n+                return charLen > 0 && charAt(0) == '[';\n+            }\n+        }\n+\n+        @Override\n+        public boolean isMethodType(MethodTypeDesc desc) {\n+            var sym = typeSym;\n+            if (sym != null) {\n+                return sym instanceof MethodTypeDesc mtd && mtd.equals(desc);\n+            }\n+\n+            \/\/ In parsing, Utf8Entry is not even inflated by this point\n+            \/\/ We can operate on the raw byte arrays, as all ascii are compatible\n+            var ret = state == State.RAW\n+                    ? rawEqualsSym(desc)\n+                    : equalsString(desc.descriptorString());\n+            if (ret)\n+                this.typeSym = desc;\n+            return ret;\n+        }\n+\n+        private boolean rawEqualsSym(MethodTypeDesc desc) {\n+            if (rawLen < 3) {\n+                return false;\n+            }\n+            var bytes = rawBytes;\n+            int index = offset;\n+            int c = bytes[index] | (bytes[index + 1] << Byte.SIZE);\n+            if ((desc.parameterCount() == 0) != (c == ('(' | (')' << Byte.SIZE)))) {\n+                \/\/ heuristic - avoid inflation for no-arg status mismatch\n+                return false;\n+            }\n+            return (c & 0xFF) == '(' && equalsString(desc.descriptorString());\n+        }\n@@ -541,1 +611,1 @@\n-            if (isArrayDescriptor(ref1)) {\n+            if (ref1.mayBeArrayDescriptor()) {\n@@ -549,0 +619,22 @@\n+        @Override\n+        public boolean matches(ClassDesc desc) {\n+            var sym = this.sym;\n+            if (sym != null) {\n+                return sym.equals(desc);\n+            }\n+\n+            var ret = rawEqualsSymbol(desc);\n+            if (ret)\n+                this.sym = desc;\n+            return ret;\n+        }\n+\n+        private boolean rawEqualsSymbol(ClassDesc desc) {\n+            if (ref1.mayBeArrayDescriptor()) {\n+                return desc.isArray() && ref1.isFieldType(desc);\n+            } else {\n+                return desc instanceof ClassOrInterfaceDescImpl coid\n+                        && ref1.equalsString(coid.internalName());\n+            }\n+        }\n+\n@@ -574,1 +666,1 @@\n-            return this.hash = hashClassFromUtf8(isArrayDescriptor(ref1), ref1);\n+            return this.hash = hashClassFromUtf8(ref1.mayBeArrayDescriptor(), ref1);\n@@ -599,0 +691,5 @@\n+        @Override\n+        public boolean matches(PackageDesc desc) {\n+            return ref1.equalsString(desc.internalName());\n+        }\n+\n@@ -630,0 +727,5 @@\n+        @Override\n+        public boolean matches(ModuleDesc desc) {\n+            return ref1.equalsString(desc.name());\n+        }\n+\n@@ -986,0 +1088,5 @@\n+        @Override\n+        public boolean matches(MethodTypeDesc desc) {\n+            return ref1.isMethodType(desc);\n+        }\n+\n@@ -1019,0 +1126,5 @@\n+        @Override\n+        public boolean equalsString(String value) {\n+            return ref1.equalsString(value);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":120,"deletions":8,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    static final int DEFAULT_CLASS_FLAGS = ClassFile.ACC_PUBLIC;\n+    static final int DEFAULT_CLASS_FLAGS = ClassFile.ACC_PUBLIC | ClassFile.ACC_SUPER;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -500,1 +500,1 @@\n-        return classEntry(ne, AbstractPoolEntry.isArrayDescriptor(ne));\n+        return classEntry(ne, ne.mayBeArrayDescriptor());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.loader.NativeLibraries;\n@@ -69,1 +70,1 @@\n-                return libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n+                return sysLookup();\n@@ -87,1 +88,1 @@\n-        SymbolLookup lookup = libLookup(libs -> libs.load(stdLib));\n+        SymbolLookup lookup = stdLibLookup(libs -> libs.load(stdLib));\n@@ -92,2 +93,1 @@\n-            SymbolLookup fallbackLibLookup =\n-                    libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n+            SymbolLookup fallbackLibLookup = sysLookup();\n@@ -113,2 +113,1 @@\n-    private static SymbolLookup libLookup(Function<RawNativeLibraries, NativeLibrary> loader) {\n-        NativeLibrary lib = loader.apply(RawNativeLibraries.newInstance(MethodHandles.lookup()));\n+    private static SymbolLookup lookup(NativeLibrary lib) {\n@@ -129,8 +128,3 @@\n-    \/*\n-     * Returns the path of the given library name from JDK\n-     *\/\n-    private static Path jdkLibraryPath(String name) {\n-        Path javahome = Path.of(StaticProperty.javaHome());\n-        String lib = OperatingSystem.isWindows() ? \"bin\" : \"lib\";\n-        String libname = System.mapLibraryName(name);\n-        return javahome.resolve(lib).resolve(libname);\n+    private static SymbolLookup stdLibLookup(Function<RawNativeLibraries, NativeLibrary> loader) {\n+        NativeLibrary lib = loader.apply(RawNativeLibraries.newInstance(MethodHandles.lookup()));\n+        return lookup(lib);\n@@ -139,0 +133,6 @@\n+    @SuppressWarnings(\"restricted\")\n+    private static SymbolLookup sysLookup() {\n+        NativeLibraries libs = NativeLibraries.newInstance(null);\n+        NativeLibrary lib = libs.loadLibrary(SymbolLookup.class, \"syslookup\");\n+        return lookup(lib);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -74,1 +74,14 @@\n-    private record LinkRequest(FunctionDescriptor descriptor, LinkerOptions options) {}\n+    private record LinkRequest(FunctionDescriptor descriptor, LinkerOptions options) {\n+        \/\/ Overrides for boot performance\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof LinkRequest other &&\n+                    other.descriptor.equals(descriptor) &&\n+                    other.options.equals(options);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return descriptor.hashCode() * 1237 + options.hashCode();\n+        }\n+    }\n@@ -311,3 +324,7 @@\n-            case AddressLayout al -> al.targetLayout()\n-                    .map(tl -> al.withoutName().withTargetLayout(stripNames(tl))) \/\/ restricted\n-                    .orElseGet(al::withoutName);\n+            case AddressLayout al -> {\n+                var stripped = al.withoutName();\n+                var target = al.targetLayout();\n+                if (target.isPresent())\n+                    stripped = stripped.withTargetLayout(stripNames(target.get()));\n+                yield stripped;\n+            }\n@@ -319,3 +336,5 @@\n-        return layouts.stream()\n-                .map(AbstractLinker::stripNames)\n-                .toArray(MemoryLayout[]::new);\n+        var ret = new MemoryLayout[layouts.size()];\n+        for (int i = 0; i < ret.length; i++) {\n+            ret[i] = stripNames(layouts.get(i));\n+        }\n+        return ret;\n@@ -325,3 +344,5 @@\n-        return function.returnLayout()\n-                .map(rl -> FunctionDescriptor.of(stripNames(rl), stripNames(function.argumentLayouts())))\n-                .orElseGet(() -> FunctionDescriptor.ofVoid(stripNames(function.argumentLayouts())));\n+        var retLayout = function.returnLayout();\n+        if (retLayout.isEmpty()) {\n+            return FunctionDescriptor.ofVoid(stripNames(function.argumentLayouts()));\n+        }\n+        return FunctionDescriptor.of(stripNames(retLayout.get()), stripNames(function.argumentLayouts()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.List;\n@@ -45,0 +46,5 @@\n+    public static final List<CapturableState> BY_ORDINAL = List.of(values());\n+\n+    static {\n+        assert (BY_ORDINAL.size() < Integer.SIZE); \/\/ Update LinkerOptions.CaptureCallState\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CapturableState.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.EnumSet;\n@@ -140,0 +141,10 @@\n+\n+        @Override\n+        public int hashCode() {\n+            return index;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof FirstVariadicArg that && index == that.index;\n+        }\n@@ -142,1 +153,1 @@\n-    public record CaptureCallState(Set<CapturableState> saved) implements LinkerOptionImpl {\n+    public record CaptureCallState(int compact) implements LinkerOptionImpl {\n@@ -147,0 +158,25 @@\n+\n+        public Set<CapturableState> saved() {\n+            var set = EnumSet.noneOf(CapturableState.class);\n+            int mask = compact;\n+            int i = 0;\n+            while (mask != 0) {\n+                if ((mask & 1) == 1) {\n+                    set.add(CapturableState.BY_ORDINAL.get(i));\n+                }\n+                mask >>= 1;\n+                i++;\n+            }\n+            return set;\n+        }\n+\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof CaptureCallState that && compact == that.compact;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return compact;\n+        }\n@@ -149,3 +185,7 @@\n-    public record Critical(boolean allowHeapAccess) implements LinkerOptionImpl {\n-        public static Critical ALLOW_HEAP = new Critical(true);\n-        public static Critical DONT_ALLOW_HEAP = new Critical(false);\n+    public enum Critical implements LinkerOptionImpl {\n+        ALLOW_HEAP,\n+        DONT_ALLOW_HEAP;\n+\n+        public boolean allowHeapAccess() {\n+            return ordinal() == 0; \/\/ this == ALLOW_HEAP\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":44,"deletions":4,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -51,1 +51,23 @@\n-                            boolean needsTransition) {}\n+                            boolean needsTransition) {\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof CacheKey other)) return false;\n+\n+            return methodType == other.methodType && abi == other.abi && capturedStateMask == other.capturedStateMask\n+                    && needsTransition == other.needsTransition && needsReturnBuffer == other.needsReturnBuffer\n+                    && argMoves.equals(other.argMoves) && retMoves.equals(other.retMoves);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int result = System.identityHashCode(methodType);\n+            result = 31 * result + abi.hashCode();\n+            result = 31 * result + argMoves.hashCode();\n+            result = 31 * result + retMoves.hashCode();\n+            result = 31 * result + Boolean.hashCode(needsReturnBuffer);\n+            result = 31 * result + capturedStateMask;\n+            result = 31 * result + Boolean.hashCode(needsTransition);\n+            return result;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.Objects;\n+\n@@ -35,1 +37,1 @@\n- * @param debugName         the debug name\n+ * @param debugName         the debug name, mostly derived from type\n@@ -46,0 +48,10 @@\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(type, segmentMaskOrSize, indexOrOffset);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj instanceof VMStorage that &&\n+                type == that.type && segmentMaskOrSize == that.segmentMaskOrSize && indexOrOffset == that.indexOrOffset;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/VMStorage.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,2 @@\n+        @JEP(number = 502, title = \"Stable Values\", status = \"Preview\")\n+        STABLE_VALUES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.util.ImmutableBitSetPredicate;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.IntPredicate;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Optimized implementation of a stable Function with enums as keys.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param firstOrdinal the lowest ordinal used\n+ * @param delegates    a delegate array of inputs to StableValue mappings\n+ * @param original     the original Function\n+ * @param <E>          the type of the input to the function\n+ * @param <R>          the type of the result of the function\n+ *\/\n+public record StableEnumFunction<E extends Enum<E>, R>(Class<E> enumType,\n+                                                       int firstOrdinal,\n+                                                       IntPredicate member,\n+                                                       @Stable StableValueImpl<R>[] delegates,\n+                                                       Function<? super E, ? extends R> original) implements Function<E, R> {\n+    @ForceInline\n+    @Override\n+    public R apply(E value) {\n+        if (!member.test(value.ordinal())) { \/\/ Implicit null-check of value\n+            throw new IllegalArgumentException(\"Input not allowed: \" + value);\n+        }\n+        final int index = value.ordinal() - firstOrdinal;\n+        final StableValueImpl<R> delegate;\n+        \/\/ Since we did the member.test above, we know the index is in bounds\n+        delegate = delegates[index];\n+        return delegate.orElseSet(new Supplier<R>() {\n+                    @Override public R get() { return original.apply(value); }});\n+\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final E[] enumElements = enumType.getEnumConstants();\n+        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>(enumElements.length);\n+        int ordinal = firstOrdinal;\n+        for (int i = 0; i < delegates.length; i++, ordinal++) {\n+            if (member.test(ordinal)) {\n+                entries.add(new AbstractMap.SimpleImmutableEntry<>(enumElements[ordinal], delegates[i]));\n+            }\n+        }\n+        return StableUtil.renderMappings(this, \"StableFunction\", entries, true);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T, E extends Enum<E>, R> Function<T, R> of(Set<? extends T> inputs,\n+                                                              Function<? super T, ? extends R> original) {\n+        \/\/ The input set is not empty\n+        final Class<E> enumType = (Class<E>)inputs.iterator().next().getClass();\n+        final BitSet bitSet = new BitSet(enumType.getEnumConstants().length);\n+        int min = Integer.MAX_VALUE;\n+        int max = Integer.MIN_VALUE;\n+        for (T t : inputs) {\n+            final int ordinal = ((E) t).ordinal();\n+            min = Math.min(min, ordinal);\n+            max = Math.max(max, ordinal);\n+            bitSet.set(ordinal);\n+        }\n+        final int size = max - min + 1;\n+        final IntPredicate member = ImmutableBitSetPredicate.of(bitSet);\n+        return (Function<T, R>) new StableEnumFunction<E, R>(enumType, min, member, StableUtil.array(size), (Function<E, R>) original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableEnumFunction.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+\/\/ Note: It would be possible to just use `LazyMap::get` with some additional logic\n+\/\/ instead of this class but explicitly providing a class like this provides better\n+\/\/ debug capability, exception handling, and may provide better performance.\n+\/**\n+ * Implementation of a stable Function.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param values   a delegate map of inputs to StableValue mappings\n+ * @param original the original Function\n+ * @param <T>      the type of the input to the function\n+ * @param <R>      the type of the result of the function\n+ *\/\n+public record StableFunction<T, R>(Map<? extends T, StableValueImpl<R>> values,\n+                                   Function<? super T, ? extends R> original) implements Function<T, R> {\n+\n+    @ForceInline\n+    @Override\n+    public R apply(T value) {\n+        final StableValueImpl<R> stable = values.get(value);\n+        if (stable == null) {\n+            throw new IllegalArgumentException(\"Input not allowed: \" + value);\n+        }\n+        return stable.orElseSet(new Supplier<R>() {\n+            @Override  public R get() { return original.apply(value); }});\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return StableUtil.renderMappings(this, \"StableFunction\", values.entrySet(), true);\n+    }\n+\n+    public static <T, R> StableFunction<T, R> of(Set<? extends T> inputs,\n+                                                 Function<? super T, ? extends R> original) {\n+        return new StableFunction<>(StableUtil.map(inputs), original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFunction.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+\/\/ Note: It would be possible to just use `LazyList::get` instead of this\n+\/\/ class but explicitly providing a class like this provides better\n+\/\/ debug capability, exception handling, and may provide better performance.\n+\/**\n+ * Implementation of a stable IntFunction.\n+ * <p>\n+ * For performance reasons (~10%), we are not delegating to a StableList but are using\n+ * the more primitive functions in StableValueUtil that are shared with StableList\/StableValueImpl.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param <R> the return type\n+ *\/\n+public record StableIntFunction<R>(@Stable StableValueImpl<R>[] delegates,\n+                                   IntFunction<? extends R> original) implements IntFunction<R> {\n+\n+    @ForceInline\n+    @Override\n+    public R apply(int index) {\n+        final StableValueImpl<R> delegate;\n+        try {\n+            delegate =  delegates[index];\n+        } catch (ArrayIndexOutOfBoundsException ioob) {\n+            throw new IllegalArgumentException(\"Input not allowed: \" + index, ioob);\n+        }\n+        return delegate.orElseSet(new Supplier<R>() {\n+                    @Override public R get() { return original.apply(index); }});\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return StableUtil.renderElements(this, \"StableIntFunction\", delegates);\n+    }\n+\n+    public static <R> StableIntFunction<R> of(int size, IntFunction<? extends R> original) {\n+        return new StableIntFunction<>(StableUtil.array(size), original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableIntFunction.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Implementation of a stable supplier.\n+ * <p>\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param <T> the return type\n+ *\/\n+public record StableSupplier<T>(StableValueImpl<T> delegate,\n+                                Supplier<? extends T> original) implements Supplier<T> {\n+\n+    @ForceInline\n+    @Override\n+    public T get() {\n+        return delegate.orElseSet(original);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(this);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj == this;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final Object t = delegate.wrappedContentAcquire();\n+        return t == this ? \"(this StableSupplier)\" : StableValueImpl.renderWrapped(t);\n+    }\n+\n+    public static <T> StableSupplier<T> of(Supplier<? extends T> original) {\n+        return new StableSupplier<>(StableValueImpl.of(), original);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableSupplier.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+\n+public final class StableUtil {\n+\n+    private StableUtil() {}\n+\n+    public static <R> String renderElements(Object self,\n+                                            String selfName,\n+                                            StableValueImpl<?>[] delegates) {\n+        return renderElements(self, selfName, delegates, 0, delegates.length);\n+    }\n+\n+    public static <R> String renderElements(Object self,\n+                                            String selfName,\n+                                            StableValueImpl<?>[] delegates,\n+                                            int offset,\n+                                            int length) {\n+        final StringJoiner sj = new StringJoiner(\", \", \"[\", \"]\");\n+        for (int i = 0; i < length; i++) {\n+            final Object value = delegates[i + offset].wrappedContentAcquire();\n+            if (value == self) {\n+                sj.add(\"(this \" + selfName + \")\");\n+            } else {\n+                sj.add(StableValueImpl.renderWrapped(value));\n+            }\n+        }\n+        return sj.toString();\n+    }\n+\n+    public static <K, V> String renderMappings(Object self,\n+                                               String selfName,\n+                                               Iterable<Map.Entry<K, StableValueImpl<V>>> delegates,\n+                                               boolean curly) {\n+        final StringJoiner sj = new StringJoiner(\", \", curly ? \"{\" : \"[\", curly ? \"}\" : \"]\");\n+        for (var e : delegates) {\n+            final Object value = e.getValue().wrappedContentAcquire();\n+            final String valueString;\n+            if (value == self) {\n+                valueString = (\"(this \") + selfName + \")\";\n+            } else {\n+                valueString = StableValueImpl.renderWrapped(value);\n+            }\n+            sj.add(e.getKey() + \"=\" + valueString);\n+        }\n+        return sj.toString();\n+    }\n+\n+    public static <T> StableValueImpl<T>[] array(int size) {\n+        assertSizeNonNegative(size);\n+        @SuppressWarnings(\"unchecked\")\n+        final var stableValues = (StableValueImpl<T>[]) new StableValueImpl<?>[size];\n+        for (int i = 0; i < size; i++) {\n+            stableValues[i] = StableValueImpl.of();\n+        }\n+        return stableValues;\n+    }\n+\n+    public static <K, T> Map<K, StableValueImpl<T>> map(Set<K> keys) {\n+        Objects.requireNonNull(keys);\n+        @SuppressWarnings(\"unchecked\")\n+        final var entries = (Map.Entry<K, StableValueImpl<T>>[]) new Map.Entry<?, ?>[keys.size()];\n+        int i = 0;\n+        for (K key : keys) {\n+            entries[i++] = Map.entry(key, StableValueImpl.of());\n+        }\n+        return Map.ofEntries(entries);\n+    }\n+\n+    public static void assertSizeNonNegative(int size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException(\"size can not be negative: \" + size);\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * The implementation of StableValue.\n+ *\n+ * @implNote This implementation can be used early in the boot sequence as it does not\n+ *           rely on reflection, MethodHandles, Streams etc.\n+ *\n+ * @param <T> type of the contents\n+ *\/\n+public final class StableValueImpl<T> implements StableValue<T> {\n+\n+    static final String UNSET_LABEL = \".unset\";\n+\n+    \/\/ Unsafe allows StableValue to be used early in the boot sequence\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ Unsafe offsets for direct field access\n+\n+    private static final long CONTENT_OFFSET =\n+            UNSAFE.objectFieldOffset(StableValueImpl.class, \"contents\");\n+    \/\/ Used to indicate a holder value is `null` (see field `value` below)\n+    \/\/ A wrapper method `nullSentinel()` is used for generic type conversion.\n+    private static final Object NULL_SENTINEL = new Object();\n+\n+    \/\/ Generally, fields annotated with `@Stable` are accessed by the JVM using special\n+    \/\/ memory semantics rules (see `parse.hpp` and `parse(1|2|3).cpp`).\n+    \/\/\n+    \/\/ This field is used directly and reflectively via Unsafe using explicit memory semantics.\n+    \/\/\n+    \/\/ | Value          |  Meaning      |\n+    \/\/ | -------------- |  ------------ |\n+    \/\/ | null           |  Unset        |\n+    \/\/ | NULL_SENTINEL  |  Set(null)    |\n+    \/\/ | other          |  Set(other)   |\n+    \/\/\n+    @Stable\n+    private Object contents;\n+\n+    \/\/ Only allow creation via the factory `StableValueImpl::newInstance`\n+    private StableValueImpl() {}\n+\n+    @ForceInline\n+    @Override\n+    public boolean trySet(T contents) {\n+        if (wrappedContentAcquire() != null) {\n+            return false;\n+        }\n+        \/\/ Prevent reentry via an orElseSet(supplier)\n+        preventReentry();\n+        \/\/ Mutual exclusion is required here as `orElseSet` might also\n+        \/\/ attempt to modify the `wrappedValue`\n+        synchronized (this) {\n+            return wrapAndSet(contents);\n+        }\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void setOrThrow(T contents) {\n+        if (!trySet(contents)) {\n+            \/\/ Neither the set contents nor the provided contents is revealed in the\n+            \/\/ exception message as it might be sensitive.\n+            throw new IllegalStateException(\"The contents is already set\");\n+        }\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public T orElseThrow() {\n+        final Object t = wrappedContentAcquire();\n+        if (t == null) {\n+            throw new NoSuchElementException(\"No contents set\");\n+        }\n+        return unwrap(t);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public T orElse(T other) {\n+        final Object t = wrappedContentAcquire();\n+        return (t == null) ? other : unwrap(t);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public boolean isSet() {\n+        return wrappedContentAcquire() != null;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public T orElseSet(Supplier<? extends T> supplier) {\n+        Objects.requireNonNull(supplier);\n+        final Object t = wrappedContentAcquire();\n+        return (t == null) ? orElseSetSlowPath(supplier) : unwrap(t);\n+    }\n+\n+    @DontInline\n+    private T orElseSetSlowPath(Supplier<? extends T> supplier) {\n+        preventReentry();\n+        synchronized (this) {\n+            final Object t = contents;  \/\/ Plain semantics suffice here\n+            if (t == null) {\n+                final T newValue = supplier.get();\n+                \/\/ The mutex is not reentrant so we know newValue should be returned\n+                wrapAndSet(newValue);\n+                return newValue;\n+            }\n+            return unwrap(t);\n+        }\n+    }\n+\n+    \/\/ The methods equals() and hashCode() should be based on identity (defaults from Object)\n+\n+    @Override\n+    public String toString() {\n+        final Object t = wrappedContentAcquire();\n+        return t == this\n+                ? \"(this StableValue)\"\n+                : renderWrapped(t);\n+    }\n+\n+    \/\/ Internal methods shared with other internal classes\n+\n+    @ForceInline\n+    public Object wrappedContentAcquire() {\n+        return UNSAFE.getReferenceAcquire(this, CONTENT_OFFSET);\n+    }\n+\n+    static String renderWrapped(Object t) {\n+        return (t == null) ? UNSET_LABEL : Objects.toString(unwrap(t));\n+    }\n+\n+    \/\/ Private methods\n+\n+    \/\/ This method is not annotated with @ForceInline as it is always called\n+    \/\/ in a slow path.\n+    private void preventReentry() {\n+        if (Thread.holdsLock(this)) {\n+            throw new IllegalStateException(\"Recursive initialization of a stable value is illegal\");\n+        }\n+    }\n+\n+    \/**\n+     * Wraps the provided {@code newValue} and tries to set the contents.\n+     * <p>\n+     * This method ensures the {@link Stable} field is written to at most once.\n+     *\n+     * @param newValue to wrap and set\n+     * @return if the contents was set\n+     *\/\n+    @ForceInline\n+    private boolean wrapAndSet(Object newValue) {\n+        assert Thread.holdsLock(this);\n+        \/\/ We know we hold the monitor here so plain semantic is enough\n+        if (contents == null) {\n+            UNSAFE.putReferenceRelease(this, CONTENT_OFFSET, wrap(newValue));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+\n+    \/\/ Wraps `null` values into a sentinel value\n+    @ForceInline\n+    private static Object wrap(Object t) {\n+        return (t == null) ? NULL_SENTINEL : t;\n+    }\n+\n+    \/\/ Unwraps null sentinel values into `null`\n+    @SuppressWarnings(\"unchecked\")\n+    @ForceInline\n+    private static <T> T unwrap(Object t) {\n+        return t != NULL_SENTINEL ? (T) t : null;\n+    }\n+\n+    \/\/ Factory\n+\n+    public static <T> StableValueImpl<T> of() {\n+        return new StableValueImpl<>();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -85,0 +85,4 @@\n+    public static boolean isSingleThreadVM() {\n+        return isDumpingStaticArchive();\n+    }\n+\n@@ -88,0 +92,23 @@\n+\n+    \/\/ Used only when dumping static archive to keep weak references alive to\n+    \/\/ ensure that Soft\/Weak Reference objects can be reliably archived.\n+    private static ArrayList<Object> keepAliveList;\n+\n+    public static void keepAlive(Object s) {\n+        assert isSingleThreadVM(); \/\/ no need for synchronization\n+        assert isDumpingStaticArchive();\n+        if (keepAliveList == null) {\n+            keepAliveList = new ArrayList<>();\n+        }\n+        keepAliveList.add(s);\n+    }\n+\n+    \/\/ This is called by native JVM code at the very end of Java execution before\n+    \/\/ dumping the static archive.\n+    \/\/ It collects the objects from keepAliveList so that they can be easily processed\n+    \/\/ by the native JVM code to check that any Reference objects that need special\n+    \/\/ clean up must have been registed with keepAlive()\n+    private static Object[] getKeepAliveObjects() {\n+        return keepAliveList.toArray();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -145,2 +145,1 @@\n-               getProperty(\"jdk.module.addreads.0\") == null &&    \/\/ --add-reads\n-               getProperty(\"jdk.module.addopens.0\") == null;      \/\/ --add-opens\n+               getProperty(\"jdk.module.addreads.0\") == null;      \/\/ --add-reads\n@@ -455,1 +454,1 @@\n-        boolean extraExportsOrOpens = addExtraExportsAndOpens(bootLayer);\n+        addExtraExportsAndOpens(bootLayer);\n@@ -725,2 +724,1 @@\n-    private static boolean addExtraExportsAndOpens(ModuleLayer bootLayer) {\n-        boolean extraExportsOrOpens = false;\n+    private static void addExtraExportsAndOpens(ModuleLayer bootLayer) {\n@@ -733,1 +731,0 @@\n-            extraExportsOrOpens = true;\n@@ -742,1 +739,0 @@\n-            extraExportsOrOpens = true;\n@@ -745,1 +741,0 @@\n-        return extraExportsOrOpens;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import jdk.internal.misc.CDS;\n@@ -340,0 +341,34 @@\n+    @SuppressWarnings(\"unchecked\")\n+    public void prepareForAOTCache() {\n+        \/\/ We are running the AOT assembly phase. The JVM has a single Java thread, so\n+        \/\/ we don't have any concurrent threads that may modify the map while we are\n+        \/\/ iterating its keys.\n+        \/\/\n+        \/\/ Also, the java.lang.ref.Reference$ReferenceHandler thread is not running,\n+        \/\/ so even if the GC has put some of the keys on the pending ReferencePendingList,\n+        \/\/ none of the keys would have been added to the stale queue yet.\n+        assert CDS.isSingleThreadVM();\n+\n+        for (ReferenceKey<K> key : map.keySet()) {\n+            Object referent = key.get();\n+            if (referent == null) {\n+                \/\/ We don't need this key anymore. Add to stale queue\n+                ((Reference)key).enqueue();\n+            } else {\n+                \/\/ Make sure the referent cannot be collected. Otherwise, when\n+                \/\/ the referent is collected, the GC may push the key onto\n+                \/\/ Universe::reference_pending_list() at an unpredictable time,\n+                \/\/ making it difficult to correctly serialize the key's\n+                \/\/ state into the CDS archive.\n+                \/\/\n+                \/\/ See aotReferenceObjSupport.cpp for more info.\n+                CDS.keepAlive(referent);\n+            }\n+            Reference.reachabilityFence(referent);\n+        }\n+\n+        \/\/ Remove all keys enqueued above\n+        removeStaleReferences();\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,0 +196,4 @@\n+\n+    public void prepareForAOTCache() {\n+        map.prepareForAOTCache();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeySet.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,3 +91,6 @@\n-        \/\/ \"stdout\/err.encoding\", prepared for System.out\/err. For compatibility\n-        \/\/ purposes, substitute them with \"sun.*\" if they don't exist. If \"sun.*\" aren't\n-        \/\/ available either, fall back to \"native.encoding\".\n+        \/\/ Encoding properties for stdin, stdout, and stderr. For stdout and stderr,\n+        \/\/ check \"sun.stdout.encoding\" and \"sun.stderr.encoding\" properties for backward\n+        \/\/ compatibility reasons before falling back to the \"native.encoding\" property.\n+        putIfAbsent(props, \"stdin.encoding\",\n+                raw.propDefault(Raw._stdin_encoding_NDX));\n+        putIfAbsent(props, \"stdin.encoding\", nativeEncoding);\n@@ -244,1 +247,2 @@\n-        @Native private static final int _stdout_encoding_NDX = 1 + _stderr_encoding_NDX;\n+        @Native private static final int _stdin_encoding_NDX = 1 + _stderr_encoding_NDX;\n+        @Native private static final int _stdout_encoding_NDX = 1 + _stdin_encoding_NDX;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SystemProps.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm.vector;\n+\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+\/**\n+ * Miscellaneous utility methods.\n+ *\/\n+public class Utils {\n+    public static final boolean DEBUG = Boolean.getBoolean(\"jdk.incubator.vector.DEBUG\");\n+\n+    public static boolean isNonCapturingLambda(Object o) {\n+        return o.getClass().getDeclaredFields().length == 0;\n+    }\n+\n+    @CallerSensitive\n+    public static void debug(String format, Object... args) {\n+        if (DEBUG) {\n+            Class<?> caller = Reflection.getCallerClass();\n+            System.out.printf(\"DEBUG: %s: \", caller.getSimpleName());\n+            System.out.printf(format, args);\n+            System.out.println();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/Utils.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+import static jdk.internal.vm.vector.Utils.isNonCapturingLambda;\n+\n@@ -117,0 +119,3 @@\n+    public static final int VECTOR_OP_MATHLIB_FIRST = VECTOR_OP_TAN;\n+    public static final int VECTOR_OP_MATHLIB_LAST  = VECTOR_OP_HYPOT;\n+\n@@ -326,0 +331,17 @@\n+\/\/    public interface LibraryUnaryOperation<V extends Vector<?>,\n+\/\/            M extends VectorMask<?>> {\n+\/\/        V apply(MemorySegment entry, V v, M m);\n+\/\/    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>, E>\n+    V libraryUnaryOp(long addr, Class<? extends V> vClass, Class<E> eClass, int length, String debugName,\n+                     V v,\n+                     UnaryOperation<V,?> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v, null);\n+    }\n+\n+    \/* ============================================================================ *\/\n+\n@@ -344,0 +366,18 @@\n+\n+    \/* ============================================================================ *\/\n+\n+\/\/    public interface LibraryBinaryOperation<V extends VectorPayload,\n+\/\/            M extends VectorMask<?>> {\n+\/\/        V apply(MemorySegment entry, V v1, V v2, M m);\n+\/\/    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends VectorPayload, E>\n+    V libraryBinaryOp(long addr, Class<? extends V> vClass, Class<E> eClass, int length, String debugName,\n+                      V v1, V v2,\n+                      BinaryOperation<V,?> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v1, v2, null);\n+    }\n+\n@@ -721,0 +761,5 @@\n+    \/\/ Returns a string containing a list of CPU features VM detected.\n+    public static native String getCPUFeatures();\n+\n+    \/* ============================================================================ *\/\n+\n@@ -726,2 +771,3 @@\n-    public static boolean isNonCapturingLambda(Object o) {\n-        return o.getClass().getDeclaredFields().length == 0;\n+    @SuppressWarnings({\"restricted\"})\n+    public static void loadNativeLibrary(String name) {\n+        System.loadLibrary(name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -276,0 +276,1 @@\n+        jdk.incubator.vector,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,2 +145,4 @@\n-            int offset = property.indexOf(\"ssl\");\n-            if (offset != -1 && property.indexOf(\"sslctx\", offset) != -1) {\n+            \/\/ remove first occurrence of \"sslctx\" since\n+            \/\/ it interferes with search for \"ssl\"\n+            String modified = property.replaceFirst(\"sslctx\", \"\");\n+            if (modified.contains(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLLogger.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.math.BigInteger;\n@@ -282,0 +281,2 @@\n+     * < 4 bytes > maximumPacketSize\n+     * < 4 bytes > negotiatedMaxFragSize\n@@ -307,2 +308,0 @@\n-     * < 4 bytes > maximumPacketSize\n-     * < 4 bytes > negotiatedMaxFragSize\n@@ -1303,1 +1302,1 @@\n-     *\n+     * <P>\n@@ -1308,1 +1307,1 @@\n-     *\n+     * <P>\n@@ -1321,1 +1320,1 @@\n-    protected void expandBufferSizes() {\n+    void expandBufferSizes() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.util;\n-\n-import java.io.FilePermission;\n-import java.security.Permission;\n-import jdk.internal.access.SharedSecrets;\n-\n-\/**\n- * Take care of FilePermission compatibility after JDK-8164705.\n- *\/\n-public class FilePermCompat {\n-    \/**\n-     * New behavior? Keep compatibility? Both default true.\n-     *\/\n-    public static final boolean nb;\n-    public static final boolean compat;\n-\n-    static {\n-        String flag = SecurityProperties.getOverridableProperty(\n-                \"jdk.io.permissionsUseCanonicalPath\");\n-        if (flag == null) {\n-            flag = \"false\";\n-        }\n-        switch (flag) {\n-            case \"true\":\n-                nb = false;\n-                compat = false;\n-                break;\n-            case \"false\":\n-                nb = true;\n-                compat = true;\n-                break;\n-            default:\n-                throw new RuntimeException(\n-                        \"Invalid jdk.io.permissionsUseCanonicalPath: \" + flag);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    public static Permission newPermPlusAltPath(Permission input) {\n-        if (compat && input instanceof FilePermission) {\n-            return SharedSecrets.getJavaIOFilePermissionAccess()\n-                    .newPermPlusAltPath((FilePermission) input);\n-        }\n-        return input;\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    public static Permission newPermUsingAltPath(Permission input) {\n-        if (input instanceof FilePermission) {\n-            return SharedSecrets.getJavaIOFilePermissionAccess()\n-                    .newPermUsingAltPath((FilePermission) input);\n-        }\n-        return null;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/FilePermCompat.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -46,20 +46,8 @@\n-    \/\/ SHA-256 certificate fingerprints of distrusted roots\n-    private static final Set<String> FINGERPRINTS = Set.of(\n-        \/\/ cacerts alias: camerfirmachamberscommerceca\n-        \/\/ DN: CN=Chambers of Commerce Root,\n-        \/\/     OU=http:\/\/www.chambersign.org,\n-        \/\/     O=AC Camerfirma SA CIF A82743287, C=EU\n-        \"0C258A12A5674AEF25F28BA7DCFAECEEA348E541E6F5CC4EE63B71B361606AC3\",\n-        \/\/ cacerts alias: camerfirmachambersca\n-        \/\/ DN: CN=Chambers of Commerce Root - 2008,\n-        \/\/     O=AC Camerfirma S.A., SERIALNUMBER=A82743287,\n-        \/\/     L=Madrid (see current address at www.camerfirma.com\/address),\n-        \/\/     C=EU\n-        \"063E4AFAC491DFD332F3089B8542E94617D893D7FE944E10A7937EE29D9693C0\",\n-        \/\/ cacerts alias: camerfirmachambersignca\n-        \/\/ DN: CN=Global Chambersign Root - 2008,\n-        \/\/     O=AC Camerfirma S.A., SERIALNUMBER=A82743287,\n-        \/\/     L=Madrid (see current address at www.camerfirma.com\/address),\n-        \/\/     C=EU\n-        \"136335439334A7698016A0D324DE72284E079D7B5220BB8FBD747816EEBEBACA\"\n-    );\n+    \/\/ SHA-256 certificate fingerprint of distrusted root for TLS\n+    \/\/ cacerts alias: camerfirmachambersca\n+    \/\/ DN: CN=Chambers of Commerce Root - 2008,\n+    \/\/     O=AC Camerfirma S.A., SERIALNUMBER=A82743287,\n+    \/\/     L=Madrid (see current address at www.camerfirma.com\/address),\n+    \/\/     C=EU\n+    private static final String FINGERPRINT =\n+            \"063E4AFAC491DFD332F3089B8542E94617D893D7FE944E10A7937EE29D9693C0\";\n@@ -88,1 +76,1 @@\n-        if (FINGERPRINTS.contains(fp)) {\n+        if (FINGERPRINT.equalsIgnoreCase(fp)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/CamerfirmaTLSPolicy.java","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -932,3 +932,1 @@\n-            {\"MET\", new String[] {\"Middle Europe Time\", \"MET\",\n-                                  \"Middle Europe Summer Time\", \"MEST\",\n-                                  \"Middle Europe Time\", \"MET\"}},\n+            {\"MET\", CET},\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/TimeZoneNames.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-Owner: CN=Chambers of Commerce Root, OU=http:\/\/www.chambersign.org, O=AC Camerfirma SA CIF A82743287, C=EU\n-Issuer: CN=Chambers of Commerce Root, OU=http:\/\/www.chambersign.org, O=AC Camerfirma SA CIF A82743287, C=EU\n-Serial number: 0\n-Valid from: Tue Sep 30 16:13:43 GMT 2003 until: Wed Sep 30 16:13:44 GMT 2037\n-Signature algorithm name: SHA1withRSA\n-Subject Public Key Algorithm: 2048-bit RSA key\n-Version: 3\n------BEGIN CERTIFICATE-----\n-MIIEvTCCA6WgAwIBAgIBADANBgkqhkiG9w0BAQUFADB\/MQswCQYDVQQGEwJFVTEn\r\n-MCUGA1UEChMeQUMgQ2FtZXJmaXJtYSBTQSBDSUYgQTgyNzQzMjg3MSMwIQYDVQQL\r\n-ExpodHRwOi8vd3d3LmNoYW1iZXJzaWduLm9yZzEiMCAGA1UEAxMZQ2hhbWJlcnMg\r\n-b2YgQ29tbWVyY2UgUm9vdDAeFw0wMzA5MzAxNjEzNDNaFw0zNzA5MzAxNjEzNDRa\r\n-MH8xCzAJBgNVBAYTAkVVMScwJQYDVQQKEx5BQyBDYW1lcmZpcm1hIFNBIENJRiBB\r\n-ODI3NDMyODcxIzAhBgNVBAsTGmh0dHA6Ly93d3cuY2hhbWJlcnNpZ24ub3JnMSIw\r\n-IAYDVQQDExlDaGFtYmVycyBvZiBDb21tZXJjZSBSb290MIIBIDANBgkqhkiG9w0B\r\n-AQEFAAOCAQ0AMIIBCAKCAQEAtzZV5aVdGDDg2olUkfzIx1L4L1DZ77F1c2VHfRtb\r\n-unXF\/KGIJPov7coISjlUxFF6tdpg6jg8gbLL8bvZkSM\/SAFwdakFKq0fcfPJVD0d\r\n-BmpAPrMMhe5cG3nCYsS4No41XQEMIwRHNaqbYE6gZj3LJgqcQKH0XZi\/caulAGgq\r\n-7YN6D6IUtdQis4CwPAxaUWktWBiP7Zme8a7ileb2R6jWDA+wWFjbw2Y3npuRVDM3\r\n-0pQcakjJyfKl2qUMI\/cjDpwyVV5xnIQFUZot\/eZOKjRa3spAN2cMVCFVd9oKDMyX\r\n-roDclDZK9D7ONhMeU+SsTjoF7Nuucpw4i9A5O4kKPnf+dQIBA6OCAUQwggFAMBIG\r\n-A1UdEwEB\/wQIMAYBAf8CAQwwPAYDVR0fBDUwMzAxoC+gLYYraHR0cDovL2NybC5j\r\n-aGFtYmVyc2lnbi5vcmcvY2hhbWJlcnNyb290LmNybDAdBgNVHQ4EFgQU45T1sU3p\r\n-26EpW1eLTXYGduHRooowDgYDVR0PAQH\/BAQDAgEGMBEGCWCGSAGG+EIBAQQEAwIA\r\n-BzAnBgNVHREEIDAegRxjaGFtYmVyc3Jvb3RAY2hhbWJlcnNpZ24ub3JnMCcGA1Ud\r\n-EgQgMB6BHGNoYW1iZXJzcm9vdEBjaGFtYmVyc2lnbi5vcmcwWAYDVR0gBFEwTzBN\r\n-BgsrBgEEAYGHLgoDATA+MDwGCCsGAQUFBwIBFjBodHRwOi8vY3BzLmNoYW1iZXJz\r\n-aWduLm9yZy9jcHMvY2hhbWJlcnNyb290Lmh0bWwwDQYJKoZIhvcNAQEFBQADggEB\r\n-AAxBl8IahsAifJ\/7kPMa0QOx7xP5IV8EnNrJpY0nbJaHkb5BkAFyk+cefV\/2icZd\r\n-p0AJPaxJRUXcLo0waLIJuvvDL8y6C98\/d3tGfToSJI6WjzwFCm\/SlCgdbQzALogi\r\n-1djPHRPH8EjX1wWnz8dHnjs8NMiAT9QUu\/wNUPf6s+xCX6ndbcj0dc97wXImsQEc\r\n-XCz9ek60AcUFV7nnPKoF2YjpB0ZBzu9Bga5Y34OirsrXdx\/nADydb47kMgkdTXg0\r\n-eDQ8lJsm7U9xxhl6vSAiSFr+S30Dt+dYvsYyTnQeaN2oaFuzPu5ifdmA6Ap1erfu\r\n-tGWaIZDgqtCYvDi1czyL+Nw=\n------END CERTIFICATE-----\n","filename":"src\/java.base\/share\/data\/cacerts\/camerfirmachamberscommerceca","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-Owner: CN=Global Chambersign Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com\/address), C=EU\n-Issuer: CN=Global Chambersign Root - 2008, O=AC Camerfirma S.A., SERIALNUMBER=A82743287, L=Madrid (see current address at www.camerfirma.com\/address), C=EU\n-Serial number: c9cdd3e9d57d23ce\n-Valid from: Fri Aug 01 12:31:40 GMT 2008 until: Sat Jul 31 12:31:40 GMT 2038\n-Signature algorithm name: SHA1withRSA\n-Subject Public Key Algorithm: 4096-bit RSA key\n-Version: 3\n------BEGIN CERTIFICATE-----\n-MIIHSTCCBTGgAwIBAgIJAMnN0+nVfSPOMA0GCSqGSIb3DQEBBQUAMIGsMQswCQYD\r\n-VQQGEwJFVTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3VycmVudCBhZGRyZXNzIGF0\r\n-IHd3dy5jYW1lcmZpcm1hLmNvbS9hZGRyZXNzKTESMBAGA1UEBRMJQTgyNzQzMjg3\r\n-MRswGQYDVQQKExJBQyBDYW1lcmZpcm1hIFMuQS4xJzAlBgNVBAMTHkdsb2JhbCBD\r\n-aGFtYmVyc2lnbiBSb290IC0gMjAwODAeFw0wODA4MDExMjMxNDBaFw0zODA3MzEx\r\n-MjMxNDBaMIGsMQswCQYDVQQGEwJFVTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3Vy\r\n-cmVudCBhZGRyZXNzIGF0IHd3dy5jYW1lcmZpcm1hLmNvbS9hZGRyZXNzKTESMBAG\r\n-A1UEBRMJQTgyNzQzMjg3MRswGQYDVQQKExJBQyBDYW1lcmZpcm1hIFMuQS4xJzAl\r\n-BgNVBAMTHkdsb2JhbCBDaGFtYmVyc2lnbiBSb290IC0gMjAwODCCAiIwDQYJKoZI\r\n-hvcNAQEBBQADggIPADCCAgoCggIBAMDfVtPkOpt2RbQT2\/\/BthmLN0EYlVJH6xed\r\n-KYiONWwGMi5HYvNJBL99RDaxccy9Wglz1dmFRP+RVyXfXjaOcNFccUMd2drvXNL7\r\n-G706tcuto8xEpw2uIRU\/uXpbknXYpBI4iRmKt4DS4jJvVpyR1ogQC7N0ZJJ0YPP2\r\n-zxhPYLIj0Mc7zmFLmY\/CDNBAspjcDahOo7kKrmCgrUVSY7pmvWjg+b4aqIG7HkF4\r\n-ddPB\/gBVsIdU6CeQNR1MM62X\/JcumIS\/LMmjv9GYERTtY\/jKmIhYF5ntRQOXfjyG\r\n-HoiMvvKRhI9lNNgATH23MRdaKXoKGCQwoze1eqkBfSbW+Q6OWfH9GzO1KTsXO0G2\r\n-Id3UwD2ln58fQ1DJu7xsepeY7s2MH\/ucUa6LcL0nn3HAa6x9kGbo1106DbDVwo3V\r\n-yJ2dwW3Q0L9R5OP4wzg2rtandeavhENdk5IMagfeOx2YItaswTXbo6Al\/3K1dh3e\r\n-beksZixShNBFks4c5eUzHdwHU1SjqoI7mjcv3N2gZOnm3b2u\/GSFHTynyQbehP9r\r\n-6GsaPMWis0L7iwk+XwhSx2LE1AVxv8Rk5Pihg+g+EpuoHtQ2TS9x9o0o9oOpE9Jh\r\n-wZG7SMA0j0GMS0zbaRL\/UJScIINZc+18ofLx\/d33SdNDWKBWY8o9PeU1VlnpDsog\r\n-zCtLkykPAgMBAAGjggFqMIIBZjASBgNVHRMBAf8ECDAGAQH\/AgEMMB0GA1UdDgQW\r\n-BBS5CcqcHtvTbDprru1U8VuTBjUuXjCB4QYDVR0jBIHZMIHWgBS5CcqcHtvTbDpr\r\n-ru1U8VuTBjUuXqGBsqSBrzCBrDELMAkGA1UEBhMCRVUxQzBBBgNVBAcTOk1hZHJp\r\n-ZCAoc2VlIGN1cnJlbnQgYWRkcmVzcyBhdCB3d3cuY2FtZXJmaXJtYS5jb20vYWRk\r\n-cmVzcykxEjAQBgNVBAUTCUE4Mjc0MzI4NzEbMBkGA1UEChMSQUMgQ2FtZXJmaXJt\r\n-YSBTLkEuMScwJQYDVQQDEx5HbG9iYWwgQ2hhbWJlcnNpZ24gUm9vdCAtIDIwMDiC\r\n-CQDJzdPp1X0jzjAOBgNVHQ8BAf8EBAMCAQYwPQYDVR0gBDYwNDAyBgRVHSAAMCow\r\n-KAYIKwYBBQUHAgEWHGh0dHA6Ly9wb2xpY3kuY2FtZXJmaXJtYS5jb20wDQYJKoZI\r\n-hvcNAQEFBQADggIBAICIf3DekijZBZRG\/5BXqfEv3xoNa\/p8DhxJJHkn2EaqbylZ\r\n-UohwEurdPfWbU1Rv4WCiqAm57OtZfMY18dwY6fFn5a+6ReAJ3spED8IXDneRRXoz\r\n-X1+WLGiLwUePmJs9wOzL9dWCkoQ10b42OFZyMVtHLaoXpGNR6woBrX\/sdZ7LoR\/x\r\n-fxKxueRkf2fWIyr0uDldmOghp+G9PUIadJpwr2hsUF1Jz\/\/7Dl3mLEfXgTpZALVz\r\n-a2Mg9jFFCDkO9HB+QHBaP9BrQql0PSgvAm11cpUJjUhjxsYjV5KTXjXBjfkK9yyd\r\n-Yhz2rXzdpjEetrHHfoUm+qRqtdpjMNHvkzeyZi99Bffnt0uYlDXA2TopwZ2yUDMd\r\n-SqlapskD7+3056huirRXhOukP9DuqqqHW2Pok+JrqNS4cnhrG+055F3Lm6qH1U9O\r\n-AP7Zap88MQ8oAgF9mOinsKJknnn4SPIVqczmyETrP3iZ8ntxPjzxmKfFGBI\/5rso\r\n-M0LpRQp8bfKGeS\/Fghl9CYl8slR2iK7ewfPM4W7bMdaTrpmg7yVqc5iJWzouE4ge\r\n-v8CSlDQb4ye3ix5vQv\/n6TebUB0tovkC7stYWDpxvGjjqsGvHCgfotwjZT+B6q6Z\r\n-09gwzxMNTxXJhLynSC34MCN32EZLeW32jO06f2ARePTpm67VVMB0gNELQp\/B\n------END CERTIFICATE-----\n","filename":"src\/java.base\/share\/data\/cacerts\/camerfirmachambersignca","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -157,0 +157,1 @@\n+    PUTPROP(propArray, _stdin_encoding_NDX, sprops->stdin_encoding);\n","filename":"src\/java.base\/share\/native\/libjava\/System.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+    char *stdin_encoding;\n","filename":"src\/java.base\/share\/native\/libjava\/java_props.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,4 @@\n+#include \"jni_util.h\"\n+\n+DEF_STATIC_JNI_OnLoad\n+\n","filename":"src\/java.base\/share\/native\/libsyslookup\/syslookup.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -467,0 +467,3 @@\n+    if (isatty(STDIN_FILENO) == 1) {\n+        sprops.stdin_encoding = sprops.encoding;\n+    }\n","filename":"src\/java.base\/unix\/native\/libjava\/java_props_md.c","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -637,1 +637,1 @@\n-            HANDLE hStdOutErr;\n+            HANDLE hStdHandle;\n@@ -680,3 +680,8 @@\n-            hStdOutErr = GetStdHandle(STD_OUTPUT_HANDLE);\n-            if (hStdOutErr != INVALID_HANDLE_VALUE &&\n-                GetFileType(hStdOutErr) == FILE_TYPE_CHAR) {\n+            hStdHandle = GetStdHandle(STD_INPUT_HANDLE);\n+            if (hStdHandle != INVALID_HANDLE_VALUE &&\n+                GetFileType(hStdHandle) == FILE_TYPE_CHAR) {\n+                sprops.stdin_encoding = getConsoleEncoding(FALSE);\n+            }\n+            hStdHandle = GetStdHandle(STD_OUTPUT_HANDLE);\n+            if (hStdHandle != INVALID_HANDLE_VALUE &&\n+                GetFileType(hStdHandle) == FILE_TYPE_CHAR) {\n@@ -685,3 +690,3 @@\n-            hStdOutErr = GetStdHandle(STD_ERROR_HANDLE);\n-            if (hStdOutErr != INVALID_HANDLE_VALUE &&\n-                GetFileType(hStdOutErr) == FILE_TYPE_CHAR) {\n+            hStdHandle = GetStdHandle(STD_ERROR_HANDLE);\n+            if (hStdHandle != INVALID_HANDLE_VALUE &&\n+                GetFileType(hStdHandle) == FILE_TYPE_CHAR) {\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,4 @@\n+#include \"jni_util.h\"\n+\n+DEF_STATIC_JNI_OnLoad\n+\n","filename":"src\/java.base\/windows\/native\/libsyslookup\/syslookup.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,0 +197,8 @@\n+        \/**\n+         * This identifies the default button in a window\/dialog.\n+         * The name PULSED has become misleading over time.\n+         * The default button used to continually pulse up until\n+         * Mac OS 10.9, but now there is no pulsing animation.\n+         * We still need this State constant to render default\n+         * buttons correctly, though.\n+         *\/\n","filename":"src\/java.desktop\/macosx\/classes\/apple\/laf\/JRSUIConstants.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,6 +205,0 @@\n-        protected State getButtonState(final AbstractButton b, final ButtonModel model) {\n-            final State state = super.getButtonState(b, model);\n-            painter.state.set(state == State.PULSED ? Animating.YES : Animating.NO);\n-            return state;\n-        }\n-\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaButtonBorder.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,2 +61,0 @@\n-import javax.swing.event.AncestorEvent;\n-import javax.swing.event.AncestorListener;\n@@ -228,2 +226,0 @@\n-\n-            b.addAncestorListener(listener);\n@@ -255,1 +251,0 @@\n-        final AquaButtonListener listener = (AquaButtonListener)b.getClientProperty(this);\n@@ -257,3 +252,0 @@\n-        if (listener != null) {\n-            b.removeAncestorListener(listener);\n-        }\n@@ -594,1 +586,1 @@\n-    class AquaButtonListener extends BasicButtonListener implements AncestorListener {\n+    class AquaButtonListener extends BasicButtonListener {\n@@ -661,22 +653,0 @@\n-\n-        public void ancestorMoved(final AncestorEvent e) {}\n-\n-        public void ancestorAdded(final AncestorEvent e) {\n-            updateDefaultButton();\n-        }\n-\n-        public void ancestorRemoved(final AncestorEvent e) {\n-            updateDefaultButton();\n-        }\n-\n-        protected void updateDefaultButton() {\n-            if (!(b instanceof JButton)) return;\n-            if (!((JButton)b).isDefaultButton()) return;\n-\n-            final JRootPane rootPane = b.getRootPane();\n-            if (rootPane == null) return;\n-\n-            final RootPaneUI ui = rootPane.getUI();\n-            if (!(ui instanceof AquaRootPaneUI)) return;\n-            ((AquaRootPaneUI)ui).updateDefaultButton(rootPane);\n-        }\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaButtonUI.java","additions":2,"deletions":32,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,3 +43,0 @@\n- * The JRootPane manages the default button.  There can be only one active rootpane,\n- * and one default button, so we need only one timer\n- *\n@@ -50,4 +47,0 @@\n-\n-    static final int kDefaultButtonPaintDelayBetweenFrames = 50;\n-    JButton fCurrentDefaultButton = null;\n-    Timer fTimer = null;\n@@ -64,4 +57,0 @@\n-        if (c.isShowing() && c.isEnabled()) {\n-            updateDefaultButton((JRootPane)c);\n-        }\n-\n@@ -95,1 +84,0 @@\n-        stopTimer();\n@@ -164,67 +152,0 @@\n-    \/**\n-     * Invoked when a property changes on the root pane. If the event\n-     * indicates the {@code defaultButton} has changed, this will\n-     * update the animation.\n-     * If the enabled state changed, it will start or stop the animation\n-     *\/\n-    public void propertyChange(final PropertyChangeEvent e) {\n-        super.propertyChange(e);\n-\n-        final String prop = e.getPropertyName();\n-        if (\"defaultButton\".equals(prop) || \"temporaryDefaultButton\".equals(prop)) {\n-            \/\/ Change the animating button if this root is showing and enabled\n-            \/\/ otherwise do nothing - someone else may be active\n-            final JRootPane root = (JRootPane)e.getSource();\n-\n-            if (root.isShowing() && root.isEnabled()) {\n-                updateDefaultButton(root);\n-            }\n-        } else if (\"enabled\".equals(prop) || AquaFocusHandler.FRAME_ACTIVE_PROPERTY.equals(prop)) {\n-            final JRootPane root = (JRootPane)e.getSource();\n-            if (root.isShowing()) {\n-                if (((Boolean)e.getNewValue()).booleanValue()) {\n-                    updateDefaultButton((JRootPane)e.getSource());\n-                } else {\n-                    stopTimer();\n-                }\n-            }\n-        }\n-    }\n-\n-    synchronized void stopTimer() {\n-        if (fTimer != null) {\n-            fTimer.stop();\n-            fTimer = null;\n-        }\n-    }\n-\n-    synchronized void updateDefaultButton(final JRootPane root) {\n-        final JButton button = root.getDefaultButton();\n-        \/\/System.err.println(\"in updateDefaultButton button = \" + button);\n-        fCurrentDefaultButton = button;\n-        stopTimer();\n-        if (button != null) {\n-            fTimer = new Timer(kDefaultButtonPaintDelayBetweenFrames, new DefaultButtonPainter(root));\n-            fTimer.start();\n-        }\n-    }\n-\n-    class DefaultButtonPainter implements ActionListener {\n-        JRootPane root;\n-\n-        public DefaultButtonPainter(final JRootPane root) {\n-            this.root = root;\n-        }\n-\n-        public void actionPerformed(final ActionEvent e) {\n-            final JButton defaultButton = root.getDefaultButton();\n-            if ((defaultButton != null) && defaultButton.isShowing()) {\n-                if (defaultButton.isEnabled()) {\n-                    defaultButton.repaint();\n-                }\n-            } else {\n-                stopTimer();\n-            }\n-        }\n-    }\n-\n@@ -252,12 +173,0 @@\n-\n-        \/\/ The root pane has been added to the hierarchy.  If it's enabled update the default\n-        \/\/ button to start the throbbing.  Since the UI is a singleton make sure the root pane\n-        \/\/ we are checking has a default button before calling update otherwise we will stop\n-        \/\/ throbbing the current default button.\n-        final JComponent comp = event.getComponent();\n-        if (comp instanceof JRootPane) {\n-            final JRootPane rp = (JRootPane)comp;\n-            if (rp.isEnabled() && rp.getDefaultButton() != null) {\n-                updateDefaultButton((JRootPane)comp);\n-            }\n-        }\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaRootPaneUI.java","additions":1,"deletions":92,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-    private final SurfaceManager.ProxyCache surfaceDataProxyCache = new SurfaceManager.ProxyCache();\n+    private final SurfaceManager.ProxyCache surfaceDataProxyCache =\n+            new SurfaceManager.ProxyCache();\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/CGraphicsConfig.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import sun.java2d.MacosxSurfaceManagerFactory;\n@@ -42,1 +41,0 @@\n-import sun.java2d.SurfaceManagerFactory;\n@@ -73,2 +71,0 @@\n-        \/\/ Install the correct surface manager factory.\n-        SurfaceManagerFactory.setInstance(new MacosxSurfaceManagerFactory());\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/CGraphicsEnvironment.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d;\n-\n-import sun.awt.image.SunVolatileImage;\n-import sun.awt.image.VolatileSurfaceManager;\n-import sun.awt.CGraphicsDevice;\n-import sun.java2d.metal.MTLVolatileSurfaceManager;\n-import sun.java2d.opengl.CGLVolatileSurfaceManager;\n-\n-\/**\n- * This is a factory class with static methods for creating a\n- * platform-specific instance of a particular SurfaceManager.  Each platform\n- * (Windows, Unix, etc.) has its own specialized SurfaceManagerFactory.\n- *\/\n-public class MacosxSurfaceManagerFactory extends SurfaceManagerFactory {\n-\n-    \/**\n-     * Creates a new instance of a VolatileSurfaceManager given any\n-     * arbitrary SunVolatileImage.  An optional context Object can be supplied\n-     * as a way for the caller to pass pipeline-specific context data to\n-     * the VolatileSurfaceManager (such as a backbuffer handle, for example).\n-     *\n-     * For Mac OS X, this method returns either an CGL\/MTL-specific\n-     * VolatileSurfaceManager based on the GraphicsConfiguration\n-     * under which the SunVolatileImage was created.\n-     *\/\n-    public VolatileSurfaceManager createVolatileManager(SunVolatileImage vImg,\n-                                                        Object context)\n-    {\n-        return CGraphicsDevice.usingMetalPipeline() ? new MTLVolatileSurfaceManager(vImg, context) :\n-                new CGLVolatileSurfaceManager(vImg, context);\n-    }\n-}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/MacosxSurfaceManagerFactory.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -32,0 +32,2 @@\n+import sun.awt.image.SurfaceManager;\n+import sun.awt.image.VolatileSurfaceManager;\n@@ -70,1 +72,1 @@\n-        implements AccelGraphicsConfig\n+        implements AccelGraphicsConfig, SurfaceManager.Factory\n@@ -375,0 +377,6 @@\n+\n+    @Override\n+    public VolatileSurfaceManager createVolatileManager(SunVolatileImage image,\n+                                                        Object context) {\n+        return new MTLVolatileSurfaceManager(image, context);\n+    }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLGraphicsConfig.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+import sun.awt.image.SurfaceManager;\n+import sun.awt.image.VolatileSurfaceManager;\n@@ -389,0 +391,6 @@\n+\n+    @Override\n+    public VolatileSurfaceManager createVolatileManager(SunVolatileImage image,\n+                                                        Object context) {\n+        return new CGLVolatileSurfaceManager(image, context);\n+    }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/opengl\/CGLGraphicsConfig.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import javax.print.attribute.standard.Chromaticity;\n@@ -76,0 +77,2 @@\n+    private boolean monochrome = false;\n+\n@@ -215,0 +218,5 @@\n+\n+        PrintService service = getPrintService();\n+        Chromaticity chromaticity = (Chromaticity)attributes.get(Chromaticity.class);\n+        monochrome = chromaticity == Chromaticity.MONOCHROME && service != null &&\n+                service.isAttributeCategorySupported(Chromaticity.class);\n@@ -791,0 +799,3 @@\n+                if (monochrome) {\n+                    pathGraphics = new GrayscaleProxyGraphics2D(pathGraphics, printerJob);\n+                }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPrinterJob.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -738,6 +738,2 @@\n-        int n = CSS.Attribute.allAttributes.length;\n-        for (int i = 0; i < n; i++) {\n-            CSS.Attribute key = CSS.Attribute.allAttributes[i];\n-            if (valueConvertor.get(key) == null) {\n-                valueConvertor.put(key, generic);\n-            }\n+        for (CSS.Attribute key : CSS.Attribute.allAttributes) {\n+            valueConvertor.putIfAbsent(key, generic);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/CSS.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import sun.java2d.SurfaceManagerFactory;\n@@ -161,19 +160,11 @@\n-    protected VolatileSurfaceManager createSurfaceManager(Object context,\n-                                                          ImageCapabilities caps)\n-    {\n-        \/**\n-         * Platform-specific SurfaceManagerFactories will return a\n-         * manager suited to acceleration on each platform.  But if\n-         * the user is asking for a VolatileImage from a BufferedImageGC,\n-         * then we need to return the appropriate unaccelerated manager.\n-         * Note: this could change in the future; if some platform would\n-         * like to accelerate BIGC volatile images, then this special-casing\n-         * of the BIGC graphicsConfig should live in platform-specific\n-         * code instead.\n-         * We do the same for a Printer Device, and if user requested an\n-         * unaccelerated VolatileImage by passing the capabilities object.\n-         *\/\n-        if (graphicsConfig instanceof BufferedImageGraphicsConfig ||\n-            graphicsConfig instanceof sun.print.PrinterGraphicsConfig ||\n-            (caps != null && !caps.isAccelerated()))\n-        {\n+    private VolatileSurfaceManager createSurfaceManager(\n+            Object context, ImageCapabilities caps) {\n+        \/\/ GraphicsConfig may provide some specific surface manager\n+        \/\/ implementation.\n+        \/\/ In case it doesn't, or we were specifically requested to use\n+        \/\/ an unaccelerated surface, fall back to the buffered image\n+        \/\/ surface manager.\n+        if ((caps == null || caps.isAccelerated()) &&\n+            graphicsConfig instanceof SurfaceManager.Factory factory) {\n+            return factory.createVolatileManager(this, context);\n+        } else {\n@@ -182,2 +173,0 @@\n-        SurfaceManagerFactory smf = SurfaceManagerFactory.getInstance();\n-        return smf.createVolatileManager(this, context);\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/SunVolatileImage.java","additions":11,"deletions":22,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -186,0 +186,17 @@\n+    \/**\n+     * An interface for GraphicsConfiguration objects to implement if\n+     * they create their own VolatileSurfaceManager implementations.\n+     *\/\n+    public interface Factory {\n+\n+        \/**\n+         * Creates a new instance of a VolatileSurfaceManager given a\n+         * compatible SunVolatileImage.\n+         * An optional context Object can be supplied as a way for the caller\n+         * to pass pipeline-specific context data to the VolatileSurfaceManager\n+         * (such as a backbuffer handle, for example).\n+         *\/\n+        VolatileSurfaceManager createVolatileManager(SunVolatileImage image,\n+                                                     Object context);\n+    }\n+\n@@ -204,1 +221,2 @@\n-        private final Map<SurfaceManager, SurfaceDataProxy> map = Collections.synchronizedMap(new WeakHashMap<>());\n+        private final Map<SurfaceManager, SurfaceDataProxy> map =\n+                Collections.synchronizedMap(new WeakHashMap<>());\n@@ -255,1 +273,2 @@\n-            Iterator<WeakReference<SurfaceDataProxy>> i = weakCache.values().iterator();\n+            Iterator<WeakReference<SurfaceDataProxy>> i =\n+                    weakCache.values().iterator();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/SurfaceManager.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d;\n-\n-import sun.awt.image.SunVolatileImage;\n-import sun.awt.image.VolatileSurfaceManager;\n-\n-\/**\n- * This factory creates platform specific VolatileSurfaceManager\n- * implementations.\n- *\n- * There are two platform specific SurfaceManagerFactories in OpenJDK,\n- * UnixSurfaceManagerFactory and WindowsSurfaceManagerFactory.\n- * The actually used SurfaceManagerFactory is set by the respective platform\n- * GraphicsEnvironment implementations in the static initializer.\n- *\/\n-public abstract class SurfaceManagerFactory {\n-\n-    \/**\n-     * The single shared instance.\n-     *\/\n-    private static SurfaceManagerFactory instance;\n-\n-    \/**\n-     * Returns the surface manager factory instance. This returns a factory\n-     * that has been set by {@link #setInstance(SurfaceManagerFactory)}.\n-     *\n-     * @return the surface manager factory\n-     *\/\n-    public static synchronized SurfaceManagerFactory getInstance() {\n-\n-        if (instance == null) {\n-            throw new IllegalStateException(\"No SurfaceManagerFactory set.\");\n-        }\n-        return instance;\n-    }\n-\n-    \/**\n-     * Sets the surface manager factory. This may only be called once, and it\n-     * may not be set back to {@code null} when the factory is already\n-     * instantiated.\n-     *\n-     * @param factory the factory to set\n-     *\/\n-    public static synchronized void setInstance(SurfaceManagerFactory factory) {\n-\n-        if (factory == null) {\n-            \/\/ We don't want to allow setting this to null at any time.\n-            throw new IllegalArgumentException(\"factory must be non-null\");\n-        }\n-\n-        if (instance != null) {\n-            \/\/ We don't want to re-set the instance at any time.\n-            throw new IllegalStateException(\"The surface manager factory is already initialized\");\n-        }\n-\n-        instance = factory;\n-    }\n-\n-    \/**\n-     * Creates a new instance of a VolatileSurfaceManager given any\n-     * arbitrary SunVolatileImage.  An optional context Object can be supplied\n-     * as a way for the caller to pass pipeline-specific context data to\n-     * the VolatileSurfaceManager (such as a backbuffer handle, for example).\n-     *\/\n-     public abstract VolatileSurfaceManager\n-         createVolatileManager(SunVolatileImage image, Object context);\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SurfaceManagerFactory.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -38,1 +38,1 @@\n-    AccelGraphicsConfig, SurfaceManager.ProxiedGraphicsConfig\n+    AccelGraphicsConfig, SurfaceManager.ProxiedGraphicsConfig, SurfaceManager.Factory\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/opengl\/OGLGraphicsConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.print;\n+\n+\n+import java.awt.Color;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.LinearGradientPaint;\n+import java.awt.Paint;\n+import java.awt.RadialGradientPaint;\n+import java.awt.TexturePaint;\n+import java.awt.color.ColorSpace;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.RenderedImage;\n+import java.awt.print.PrinterJob;\n+\n+\/**\n+ * Proxy class to print with grayscale.\n+ * Convert Colors, Paints and Images to the grayscale.\n+ *\n+ *\/\n+public class GrayscaleProxyGraphics2D extends ProxyGraphics2D {\n+\n+    \/**\n+     * The new ProxyGraphics2D will forward all graphics\n+     * calls to 'graphics'.\n+     *\n+     * @param graphics\n+     * @param printerJob\n+     *\/\n+    public GrayscaleProxyGraphics2D(Graphics2D graphics, PrinterJob printerJob) {\n+        super(graphics, printerJob);\n+    }\n+\n+    @Override\n+    public void setBackground(Color color) {\n+        Color gcolor = getGrayscaleColor(color);\n+        super.setBackground(gcolor);\n+    }\n+\n+    @Override\n+    public void setColor(Color c) {\n+        Color gcolor = getGrayscaleColor(c);\n+        super.setColor(gcolor);\n+    }\n+\n+    @Override\n+    public void setPaint(Paint paint) {\n+        if (paint instanceof Color color) {\n+            super.setPaint(getGrayscaleColor(color));\n+        } else if (paint instanceof TexturePaint texturePaint) {\n+            super.setPaint(new TexturePaint(getGrayscaleImage(texturePaint.getImage()), texturePaint.getAnchorRect()));\n+        } else if (paint instanceof GradientPaint gradientPaint) {\n+            super.setPaint(new GradientPaint(gradientPaint.getPoint1(),\n+                    getGrayscaleColor(gradientPaint.getColor1()),\n+                    gradientPaint.getPoint2(),\n+                    getGrayscaleColor(gradientPaint.getColor2()),\n+                    gradientPaint.isCyclic()));\n+        } else if (paint instanceof LinearGradientPaint linearGradientPaint) {\n+            Color[] colors = new Color[linearGradientPaint.getColors().length];\n+            Color[] oldColors = linearGradientPaint.getColors();\n+            for (int i = 0; i < colors.length; i++) {\n+                colors[i] = getGrayscaleColor(oldColors[i]);\n+            }\n+            super.setPaint(new LinearGradientPaint(linearGradientPaint.getStartPoint(),\n+                    linearGradientPaint.getEndPoint(),\n+                    linearGradientPaint.getFractions(),\n+                    colors,\n+                    linearGradientPaint.getCycleMethod(),\n+                    linearGradientPaint.getColorSpace(),\n+                    linearGradientPaint.getTransform()\n+            ));\n+        } else if (paint instanceof RadialGradientPaint radialGradientPaint) {\n+            Color[] colors = new Color[radialGradientPaint.getColors().length];\n+            Color[] oldColors = radialGradientPaint.getColors();\n+            for (int i = 0; i < colors.length; i++) {\n+                colors[i] = getGrayscaleColor(oldColors[i]);\n+            }\n+            super.setPaint(new RadialGradientPaint(radialGradientPaint.getCenterPoint(),\n+                    radialGradientPaint.getRadius(),\n+                    radialGradientPaint.getFocusPoint(),\n+                    radialGradientPaint.getFractions(),\n+                    colors,\n+                    radialGradientPaint.getCycleMethod(),\n+                    radialGradientPaint.getColorSpace(),\n+                    radialGradientPaint.getTransform()));\n+        } else if (paint == null) {\n+            super.setPaint(paint);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported Paint\");\n+        }\n+    }\n+\n+    @Override\n+    public void drawRenderedImage(RenderedImage img, AffineTransform xform) {\n+        BufferedImage grayImage = new BufferedImage(img.getWidth() + img.getTileWidth(),\n+                img.getHeight() + img.getTileHeight(), BufferedImage.TYPE_BYTE_GRAY);\n+        Graphics2D g2 = grayImage.createGraphics();\n+        g2.drawRenderedImage(img, new AffineTransform());\n+        g2.dispose();\n+        super.drawRenderedImage(getGrayscaleImage(grayImage), xform);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2,\n+                             Color bgcolor, ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2,\n+                             ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int x, int y, int width, int height, Color bgcolor, ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), x, y, width, height, bgcolor, observer);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int x, int y, Color bgcolor, ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), x, y, bgcolor, observer);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int x, int y, int width, int height, ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), x, y, width, height, observer);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, int x, int y, ImageObserver observer) {\n+        return super.drawImage(getGrayscaleImage(img), x, y, observer);\n+    }\n+\n+    @Override\n+    public void drawImage(BufferedImage img, BufferedImageOp op, int x, int y) {\n+        super.drawImage(getGrayscaleImage(img), op, x, y);\n+    }\n+\n+    @Override\n+    public boolean drawImage(Image img, AffineTransform xform, ImageObserver obs) {\n+        return super.drawImage(getGrayscaleImage(img), xform, obs);\n+    }\n+\n+    \/**\n+     * Returns grayscale variant of the input Color\n+     * @param color color to transform to grayscale\n+     * @return grayscale color\n+     *\/\n+    private Color getGrayscaleColor(Color color) {\n+        if (color == null) {\n+            return null;\n+        }\n+        float[] gcolor = color.getComponents(ColorSpace.getInstance(ColorSpace.CS_GRAY), null);\n+        return switch (gcolor.length) {\n+            case 1 -> new Color(gcolor[0], gcolor[0], gcolor[0]);\n+            case 2 -> new Color(gcolor[0], gcolor[0], gcolor[0], gcolor[1]);\n+            default -> throw new IllegalArgumentException(\"Unknown grayscale color. \" +\n+                    \"Expected 1 or 2 components, received \" + gcolor.length + \" components.\");\n+        };\n+    }\n+\n+    \/**\n+     * Converts Image to a grayscale\n+     * @param img colored image\n+     * @return grayscale BufferedImage\n+     *\/\n+    private BufferedImage getGrayscaleImage(Image img) {\n+        if (img == null) {\n+            return null;\n+        }\n+        BufferedImage grayImage = new BufferedImage(img.getWidth(null), img.getHeight(null),\n+                BufferedImage.TYPE_BYTE_GRAY);\n+        Graphics grayGraphics = grayImage.getGraphics();\n+        grayGraphics.drawImage(img, 0, 0, null);\n+        grayGraphics.dispose();\n+        return grayImage;\n+    }\n+\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/GrayscaleProxyGraphics2D.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-static const char szNetscape20ext[11] = \"NETSCAPE2.0\";\n+static const char szNetscape20ext[] = \"NETSCAPE2.0\";\n@@ -184,1 +184,1 @@\n-                    if (size == sizeof(szNetscape20ext)\n+                    if (size == strlen(szNetscape20ext)\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/splashscreen_gif.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import sun.awt.image.VolatileSurfaceManager;\n@@ -58,0 +59,1 @@\n+import sun.java2d.x11.X11VolatileSurfaceManager;\n@@ -67,1 +69,1 @@\n-    implements SurfaceManager.ProxiedGraphicsConfig\n+    implements SurfaceManager.ProxiedGraphicsConfig, SurfaceManager.Factory\n@@ -503,0 +505,6 @@\n+\n+    @Override\n+    public VolatileSurfaceManager createVolatileManager(SunVolatileImage image,\n+                                                        Object context) {\n+        return new X11VolatileSurfaceManager(image, context);\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsConfig.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-    Map<SurfaceType, SurfaceManager.ProxyCache> x11ProxyCacheMap = Collections.synchronizedMap(new HashMap<>());\n+    Map<SurfaceType, SurfaceManager.ProxyCache> x11ProxyCacheMap =\n+            Collections.synchronizedMap(new HashMap<>());\n@@ -98,1 +99,2 @@\n-        return x11ProxyCacheMap.computeIfAbsent(st, unused -> new SurfaceManager.ProxyCache());\n+        return x11ProxyCacheMap.computeIfAbsent(st,\n+                unused -> new SurfaceManager.ProxyCache());\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsDevice.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-import sun.java2d.SurfaceManagerFactory;\n-import sun.java2d.UnixSurfaceManagerFactory;\n@@ -127,4 +125,0 @@\n-\n-        \/\/ Install the correct surface manager factory.\n-        SurfaceManagerFactory.setInstance(new UnixSurfaceManagerFactory());\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsEnvironment.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package sun.java2d;\n-\n-import java.awt.GraphicsConfiguration;\n-\n-import sun.awt.image.SunVolatileImage;\n-import sun.awt.image.VolatileSurfaceManager;\n-import sun.java2d.opengl.GLXGraphicsConfig;\n-import sun.java2d.opengl.GLXVolatileSurfaceManager;\n-import sun.java2d.x11.X11VolatileSurfaceManager;\n-import sun.java2d.xr.*;\n-\n-\/**\n- * The SurfaceManagerFactory that creates VolatileSurfaceManager\n- * implementations for the Unix volatile images.\n- *\/\n-public class UnixSurfaceManagerFactory extends SurfaceManagerFactory {\n-\n-    \/**\n-     * Creates a new instance of a VolatileSurfaceManager given any\n-     * arbitrary SunVolatileImage.  An optional context Object can be supplied\n-     * as a way for the caller to pass pipeline-specific context data to\n-     * the VolatileSurfaceManager (such as a backbuffer handle, for example).\n-     *\n-     * For Unix platforms, this method returns either an X11- or a GLX-\n-     * specific VolatileSurfaceManager based on the GraphicsConfiguration\n-     * under which the SunVolatileImage was created.\n-     *\/\n-    public VolatileSurfaceManager createVolatileManager(SunVolatileImage vImg,\n-                                                        Object context)\n-    {\n-        GraphicsConfiguration gc = vImg.getGraphicsConfig();\n-\n-        if (gc instanceof GLXGraphicsConfig) {\n-            return new GLXVolatileSurfaceManager(vImg, context);\n-        } else if(gc instanceof XRGraphicsConfig) {\n-            return new XRVolatileSurfaceManager(vImg, context);\n-        }else {\n-            return new X11VolatileSurfaceManager(vImg, context);\n-        }\n-    }\n-\n-}\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/UnixSurfaceManagerFactory.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -52,0 +52,1 @@\n+import sun.awt.image.VolatileSurfaceManager;\n@@ -75,1 +76,2 @@\n-    private final SurfaceManager.ProxyCache surfaceDataProxyCache = new SurfaceManager.ProxyCache();\n+    private final SurfaceManager.ProxyCache surfaceDataProxyCache =\n+            new SurfaceManager.ProxyCache();\n@@ -416,0 +418,6 @@\n+\n+    @Override\n+    public VolatileSurfaceManager createVolatileManager(SunVolatileImage image,\n+                                                        Object context) {\n+        return new GLXVolatileSurfaceManager(image, context);\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/opengl\/GLXGraphicsConfig.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import sun.awt.image.SunVolatileImage;\n+import sun.awt.image.VolatileSurfaceManager;\n@@ -37,1 +39,2 @@\n-    private final SurfaceManager.ProxyCache surfaceDataProxyCache = new SurfaceManager.ProxyCache();\n+    private final SurfaceManager.ProxyCache surfaceDataProxyCache =\n+            new SurfaceManager.ProxyCache();\n@@ -62,0 +65,6 @@\n+\n+    @Override\n+    public VolatileSurfaceManager createVolatileManager(SunVolatileImage image,\n+                                                        Object context) {\n+        return new XRVolatileSurfaceManager(image, context);\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRGraphicsConfig.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -575,2 +575,9 @@\n-                Chromaticity[]arr = new Chromaticity[1];\n-                arr[0] = Chromaticity.COLOR;\n+                Chromaticity[] arr;\n+                if (PrintServiceLookupProvider.isMac()) {\n+                    arr = new Chromaticity[2];\n+                    arr[0] = Chromaticity.COLOR;\n+                    arr[1] = Chromaticity.MONOCHROME;\n+                } else {\n+                    arr = new Chromaticity[1];\n+                    arr[0] = Chromaticity.COLOR;\n+                }\n@@ -1403,1 +1410,1 @@\n-                return attr == Chromaticity.COLOR;\n+                return PrintServiceLookupProvider.isMac() || attr == Chromaticity.COLOR;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/IPPPrintService.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-    final SurfaceManager.ProxyCache surfaceDataProxyCache = new SurfaceManager.ProxyCache();\n+    final SurfaceManager.ProxyCache surfaceDataProxyCache =\n+            new SurfaceManager.ProxyCache();\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/Win32GraphicsDevice.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import sun.java2d.SurfaceManagerFactory;\n-import sun.java2d.WindowsSurfaceManagerFactory;\n@@ -66,3 +64,0 @@\n-        \/\/ Install correct surface manager factory.\n-        SurfaceManagerFactory.setInstance(new WindowsSurfaceManagerFactory());\n-\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/Win32GraphicsEnvironment.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d;\n-\n-import java.awt.GraphicsConfiguration;\n-import sun.awt.image.BufImgVolatileSurfaceManager;\n-import sun.awt.image.SunVolatileImage;\n-import sun.awt.image.VolatileSurfaceManager;\n-import sun.java2d.d3d.D3DGraphicsConfig;\n-import sun.java2d.d3d.D3DVolatileSurfaceManager;\n-import sun.java2d.opengl.WGLGraphicsConfig;\n-import sun.java2d.opengl.WGLVolatileSurfaceManager;\n-\n-\/**\n- * The SurfaceManagerFactory that creates VolatileSurfaceManager\n- * implementations for the Windows volatile images.\n- *\/\n-public final class WindowsSurfaceManagerFactory extends SurfaceManagerFactory {\n-\n-    \/**\n-     * Creates a new instance of a VolatileSurfaceManager given any\n-     * arbitrary SunVolatileImage.  An optional context Object can be supplied\n-     * as a way for the caller to pass pipeline-specific context data to\n-     * the VolatileSurfaceManager (such as a backbuffer handle, for example).\n-     *\n-     * For Windows platforms, this method returns a Windows-specific\n-     * VolatileSurfaceManager.\n-     *\/\n-    @Override\n-    public VolatileSurfaceManager createVolatileManager(SunVolatileImage vImg,\n-                                                        Object context)\n-    {\n-        GraphicsConfiguration gc = vImg.getGraphicsConfig();\n-        if (gc instanceof D3DGraphicsConfig) {\n-            return new D3DVolatileSurfaceManager(vImg, context);\n-        } else if (gc instanceof WGLGraphicsConfig) {\n-            return new WGLVolatileSurfaceManager(vImg, context);\n-        } else {\n-            return new BufImgVolatileSurfaceManager(vImg, context);\n-        }\n-    }\n-\n-}\n","filename":"src\/java.desktop\/windows\/classes\/sun\/java2d\/WindowsSurfaceManagerFactory.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -42,0 +42,1 @@\n+import sun.awt.image.VolatileSurfaceManager;\n@@ -54,1 +55,1 @@\n-    implements AccelGraphicsConfig\n+    implements AccelGraphicsConfig, SurfaceManager.Factory\n@@ -310,0 +311,6 @@\n+\n+    @Override\n+    public VolatileSurfaceManager createVolatileManager(SunVolatileImage image,\n+                                                        Object context) {\n+        return new D3DVolatileSurfaceManager(image, context);\n+    }\n","filename":"src\/java.desktop\/windows\/classes\/sun\/java2d\/d3d\/D3DGraphicsConfig.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import sun.awt.image.VolatileSurfaceManager;\n@@ -76,1 +77,2 @@\n-    private final SurfaceManager.ProxyCache surfaceDataProxyCache = new SurfaceManager.ProxyCache();\n+    private final SurfaceManager.ProxyCache surfaceDataProxyCache =\n+            new SurfaceManager.ProxyCache();\n@@ -435,0 +437,6 @@\n+\n+    @Override\n+    public VolatileSurfaceManager createVolatileManager(SunVolatileImage image,\n+                                                        Object context) {\n+        return new WGLVolatileSurfaceManager(image, context);\n+    }\n","filename":"src\/java.desktop\/windows\/classes\/sun\/java2d\/opengl\/WGLGraphicsConfig.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -310,0 +310,4 @@\n+                \/\/ Handle overflow.\n+                if (grow <= 0) {\n+                    throw new IndexOutOfBoundsException();\n+                }\n@@ -312,4 +316,1 @@\n-            \/\/ Handle overflow.\n-            if (grow < map.length) {\n-                throw new IndexOutOfBoundsException();\n-            } else if (grow != map.length) {\n+            if (grow != map.length) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavadocTokenizer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -86,0 +86,16 @@\n+    private static class WhereClauses {\n+        private final Map<WhereClauseKind, Map<Type, JCDiagnostic>> whereClauses;\n+\n+        WhereClauses() {\n+            Map<WhereClauseKind, Map<Type, JCDiagnostic>> whereClauses = new EnumMap<>(WhereClauseKind.class);\n+            for (WhereClauseKind kind : WhereClauseKind.values()) {\n+                whereClauses.put(kind, new LinkedHashMap<>());\n+            }\n+            this.whereClauses = whereClauses;\n+        }\n+\n+        public Map<Type, JCDiagnostic> get(WhereClauseKind kind) {\n+            return whereClauses.get(kind);\n+        }\n+    }\n+\n@@ -87,1 +103,14 @@\n-    Map<WhereClauseKind, Map<Type, JCDiagnostic>> whereClauses;\n+    WhereClauses whereClauses;\n+\n+    private void enter() {\n+        if (nameSimplifier != null || whereClauses != null) {\n+            throw new IllegalStateException();\n+        }\n+        nameSimplifier = new ClassNameSimplifier();\n+        whereClauses = new WhereClauses();\n+    }\n+\n+    private void exit() {\n+        nameSimplifier = null;\n+        whereClauses = null;\n+    }\n@@ -105,1 +134,0 @@\n-        whereClauses = new EnumMap<>(WhereClauseKind.class);\n@@ -107,2 +135,0 @@\n-        for (WhereClauseKind kind : WhereClauseKind.values())\n-            whereClauses.put(kind, new LinkedHashMap<Type, JCDiagnostic>());\n@@ -113,14 +139,14 @@\n-        StringBuilder sb = new StringBuilder();\n-        nameSimplifier = new ClassNameSimplifier();\n-        for (WhereClauseKind kind : WhereClauseKind.values())\n-            whereClauses.get(kind).clear();\n-        preprocessDiagnostic(diag);\n-        sb.append(formatter.format(diag, l));\n-        if (getConfiguration().isEnabled(RichFormatterFeature.WHERE_CLAUSES)) {\n-            List<JCDiagnostic> clauses = getWhereClauses();\n-            String indent = formatter.isRaw() ? \"\" :\n-                formatter.indentString(DetailsInc);\n-            for (JCDiagnostic d : clauses) {\n-                String whereClause = formatter.format(d, l);\n-                if (whereClause.length() > 0) {\n-                    sb.append('\\n' + indent + whereClause);\n+        enter();\n+        try {\n+            StringBuilder sb = new StringBuilder();\n+            preprocessDiagnostic(diag);\n+            sb.append(formatter.format(diag, l));\n+            if (getConfiguration().isEnabled(RichFormatterFeature.WHERE_CLAUSES)) {\n+                List<JCDiagnostic> clauses = getWhereClauses();\n+                String indent = formatter.isRaw() ? \"\" :\n+                        formatter.indentString(DetailsInc);\n+                for (JCDiagnostic d : clauses) {\n+                    String whereClause = formatter.format(d, l);\n+                    if (whereClause.length() > 0) {\n+                        sb.append('\\n' + indent + whereClause);\n+                    }\n@@ -129,0 +155,3 @@\n+            return sb.toString();\n+        } finally {\n+            exit();\n@@ -130,1 +159,0 @@\n-        return sb.toString();\n@@ -135,3 +163,7 @@\n-        nameSimplifier = new ClassNameSimplifier();\n-        preprocessDiagnostic(diag);\n-        return super.formatMessage(diag, l);\n+        enter();\n+        try {\n+            preprocessDiagnostic(diag);\n+            return super.formatMessage(diag, l);\n+        } finally {\n+            exit();\n+        }\n@@ -559,1 +591,1 @@\n-            t = (TypeVar)t.stripMetadataIfNeeded();\n+            t = (TypeVar)t.stripMetadata();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":55,"deletions":23,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.compiler;\n-\n-import java.io.PrintStream;\n-import java.util.*;\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.oops.*;\n-import sun.jvm.hotspot.prims.JvmtiExport;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class CompileTask extends VMObject {\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n-    Type type      = db.lookupType(\"CompileTask\");\n-    methodField = type.getAddressField(\"_method\");\n-    osrBciField = new CIntField(type.getCIntegerField(\"_osr_bci\"), 0);\n-    compLevelField = new CIntField(type.getCIntegerField(\"_comp_level\"), 0);\n-  }\n-\n-  private static AddressField methodField;\n-  private static CIntField osrBciField;\n-  private static CIntField compLevelField;\n-\n-  public CompileTask(Address addr) {\n-    super(addr);\n-  }\n-\n-  public Method method() {\n-    Address oh =  methodField.getValue(getAddress());\n-    return (Method)Metadata.instantiateWrapperFor(oh);\n-  }\n-\n-  public int osrBci() {\n-    return (int)osrBciField.getValue(getAddress());\n-  }\n-\n-  public int compLevel() {\n-      return (int)compLevelField.getValue(getAddress());\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/compiler\/CompileTask.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -692,1 +692,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -720,1 +720,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -731,0 +731,1 @@\n+\n@@ -827,0 +828,1 @@\n+\n@@ -853,0 +855,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import java.util.Locale;\n+import java.util.Set;\n+\n+import static jdk.incubator.vector.Util.requires;\n+import static jdk.internal.util.Architecture.isX64;\n+import static jdk.internal.vm.vector.Utils.debug;\n+\n+\/**\n+ * Enumerates CPU ISA extensions supported by the JVM on the current hardware.\n+ *\/\n+\/*package-private*\/ class CPUFeatures {\n+    private static final Set<String> features = getCPUFeatures();\n+\n+    private static Set<String> getCPUFeatures() {\n+        String featuresString = VectorSupport.getCPUFeatures();\n+        debug(featuresString);\n+\n+        if (featuresString.equals(\"\")) return Set.of();\n+\n+        String[] features = featuresString.toLowerCase(Locale.ROOT)\n+                                          .split(\",? \"); \/\/ \" \" or \", \" are used as a delimiter by JVM\n+        assert validateFeatures(features);\n+        return Set.of(features);\n+    }\n+\n+    private static boolean validateFeatures(String[] features) {\n+        for (String s : features) {\n+            assert s != null && s.matches(\"[a-z0-9._]+\") : String.format(\"Invalid CPU feature name: '%s'\", s);\n+        }\n+        return true;\n+    }\n+\n+    private static boolean hasFeature(String feature) {\n+        return features.contains(feature.toLowerCase(Locale.ROOT));\n+    }\n+\n+    public static class X64 {\n+        public static boolean SUPPORTS_AVX      = hasFeature(\"avx\");\n+        public static boolean SUPPORTS_AVX2     = hasFeature(\"avx2\");\n+        public static boolean SUPPORTS_AVX512F  = hasFeature(\"avx512f\");\n+        public static boolean SUPPORTS_AVX512DQ = hasFeature(\"avx512dq\");\n+\n+        static {\n+            requires(isX64(), \"unsupported platform\");\n+\n+            debug(\"AVX=%b; AVX2=%b; AVX512F=%b; AVX512DQ=%b\",\n+                  SUPPORTS_AVX, SUPPORTS_AVX2, SUPPORTS_AVX512F, SUPPORTS_AVX512DQ);\n+\n+            assert SUPPORTS_AVX512F == (VectorShape.getMaxVectorBitSize(int.class)   == 512);\n+            assert SUPPORTS_AVX2    == (VectorShape.getMaxVectorBitSize(byte.class)  >= 256);\n+            assert SUPPORTS_AVX     == (VectorShape.getMaxVectorBitSize(float.class) >= 256);\n+        }\n+    }\n+\n+    public static Set<String> features() {\n+        return features;\n+    }\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/CPUFeatures.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -681,0 +681,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return unaryMathOp(op);\n+            }\n@@ -706,0 +709,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return blend(unaryMathOp(op), m);\n+            }\n@@ -714,0 +720,7 @@\n+    @ForceInline\n+    final\n+    DoubleVector unaryMathOp(VectorOperators.Unary op) {\n+        return VectorMathLibrary.unaryMathOp(op, opCode(op), species(), DoubleVector::unaryOperations,\n+                                             this);\n+    }\n+\n@@ -784,0 +797,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return binaryMathOp(op, that);\n+            }\n@@ -818,0 +834,4 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return this.blend(binaryMathOp(op, that), m);\n+            }\n+\n@@ -827,0 +847,7 @@\n+    @ForceInline\n+    final\n+    DoubleVector binaryMathOp(VectorOperators.Binary op, DoubleVector that) {\n+        return VectorMathLibrary.binaryMathOp(op, opCode(op), species(), DoubleVector::binaryOperations,\n+                                              this, that);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -681,0 +681,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return unaryMathOp(op);\n+            }\n@@ -706,0 +709,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return blend(unaryMathOp(op), m);\n+            }\n@@ -714,0 +720,7 @@\n+    @ForceInline\n+    final\n+    FloatVector unaryMathOp(VectorOperators.Unary op) {\n+        return VectorMathLibrary.unaryMathOp(op, opCode(op), species(), FloatVector::unaryOperations,\n+                                             this);\n+    }\n+\n@@ -784,0 +797,3 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return binaryMathOp(op, that);\n+            }\n@@ -818,0 +834,4 @@\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return this.blend(binaryMathOp(op, that), m);\n+            }\n+\n@@ -827,0 +847,7 @@\n+    @ForceInline\n+    final\n+    FloatVector binaryMathOp(VectorOperators.Binary op, FloatVector that) {\n+        return VectorMathLibrary.binaryMathOp(op, opCode(op), species(), FloatVector::binaryOperations,\n+                                              this, that);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -692,1 +692,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -720,1 +720,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -731,0 +731,1 @@\n+\n@@ -827,0 +828,1 @@\n+\n@@ -853,0 +855,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -650,1 +650,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -678,1 +678,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -689,0 +689,1 @@\n+\n@@ -785,0 +786,1 @@\n+\n@@ -811,0 +813,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -692,1 +692,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -720,1 +720,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -731,0 +731,1 @@\n+\n@@ -827,0 +828,1 @@\n+\n@@ -853,0 +855,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+\/*package-private*\/ class Util {\n+    public static void requires(boolean cond, String message) {\n+        if (!cond) {\n+            throw new InternalError(message);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Util.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,325 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import jdk.internal.util.StaticProperty;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.util.function.IntFunction;\n+\n+import static jdk.incubator.vector.Util.requires;\n+import static jdk.incubator.vector.VectorOperators.*;\n+import static jdk.internal.util.Architecture.*;\n+import static jdk.internal.vm.vector.Utils.debug;\n+\n+\/**\n+ * A wrapper for native vector math libraries bundled with the JDK (SVML and SLEEF).\n+ * Binds vector operations to native implementations provided by the libraries.\n+ *\/\n+\/*package-private*\/ class VectorMathLibrary {\n+    private static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n+\n+    interface Library {\n+        String symbolName(Operator op, VectorSpecies<?> vspecies);\n+        boolean isSupported(Operator op, VectorSpecies<?> vspecies);\n+\n+        String SVML  = \"svml\";\n+        String SLEEF = \"sleef\";\n+        String JAVA  = \"java\";\n+\n+        static Library getInstance() {\n+            String libraryName = System.getProperty(\"jdk.incubator.vector.VectorMathLibrary\", getDefaultName());\n+            try {\n+                return switch (libraryName) {\n+                    case SVML  -> new SVML();\n+                    case SLEEF -> new SLEEF();\n+                    case JAVA  -> new Java();\n+                    default    -> throw new IllegalArgumentException(\"Unsupported vector math library: \" + libraryName);\n+                };\n+            } catch (Throwable e) {\n+                debug(\"Error during initialization of %s library: %s\", libraryName, e);\n+                return new Java(); \/\/ fallback\n+            }\n+        }\n+\n+        static String getDefaultName() {\n+            return switch (StaticProperty.osArch()) {\n+                case \"amd64\", \"x86_64\" -> SVML;\n+                case \"aarch64\", \"riscv64\" -> SLEEF;\n+                default -> JAVA;\n+            };\n+        }\n+    }\n+\n+    private static final Library LIBRARY = Library.getInstance();\n+\n+    static {\n+        debug(\"%s library is used (cpu features: %s)\", LIBRARY.getClass().getSimpleName(), CPUFeatures.features());\n+    }\n+\n+    private static class Java implements Library {\n+        @Override\n+        public String symbolName(Operator op, VectorSpecies<?> vspecies) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean isSupported(Operator op, VectorSpecies<?> vspecies) {\n+            return false; \/\/ always use default implementation\n+        }\n+    }\n+\n+    \/**\n+     * Naming convention in SVML vector math library.\n+     * All the methods are named as __jsvml_<op><T><N>_ha_<VV> where:\n+     *      ha stands for high accuracy\n+     *      <T> is optional to indicate float\/double\n+     *              Set to f for vector float operation\n+     *              Omitted for vector double operation\n+     *      <N> is the number of elements in the vector\n+     *              1, 2, 4, 8, 16\n+     *              e.g. 128 bit float vector has 4 float elements\n+     *      <VV> indicates the avx\/sse level:\n+     *              z0 is AVX512, l9 is AVX2, e9 is AVX1 and ex is for SSE2\n+     *      e.g. __jsvml_expf16_ha_z0 is the method for computing 16 element vector float exp using AVX 512 insns\n+     *           __jsvml_exp8_ha_z0 is the method for computing 8 element vector double exp using AVX 512 insns\n+     *\/\n+    private static class SVML implements Library {\n+        static {\n+            loadNativeLibrary();\n+        }\n+\n+        private static void loadNativeLibrary() {\n+            requires(isX64(), \"SVML library is x64-specific\");\n+            VectorSupport.loadNativeLibrary(\"jsvml\");\n+        }\n+\n+        private static String suffix(VectorSpecies<?> vspecies) {\n+            assert vspecies.vectorBitSize() <= VectorShape.getMaxVectorBitSize(vspecies.elementType());\n+\n+            if (vspecies.vectorBitSize() == 512) {\n+                assert CPUFeatures.X64.SUPPORTS_AVX512F;\n+                return \"z0\";\n+            } else if (CPUFeatures.X64.SUPPORTS_AVX2) {\n+                return \"l9\";\n+            } else if (CPUFeatures.X64.SUPPORTS_AVX) {\n+                return \"e9\";\n+            } else {\n+                return \"ex\";\n+            }\n+        }\n+\n+        @Override\n+        public String symbolName(Operator op, VectorSpecies<?> vspecies) {\n+            String suffix = suffix(vspecies);\n+            String elemType = (vspecies.elementType() == float.class ? \"f\" : \"\");\n+            boolean isFloat64Vector = (vspecies.elementType() == float.class) && (vspecies.length() == 2); \/\/ Float64Vector or FloatMaxVector\n+            int vlen = (isFloat64Vector ? 4 : vspecies.length()); \/\/ reuse 128-bit variant for 64-bit float vectors\n+            return String.format(\"__jsvml_%s%s%d_ha_%s\", op.operatorName(), elemType, vlen, suffix);\n+        }\n+\n+        @Override\n+        public boolean isSupported(Operator op, VectorSpecies<?> vspecies) {\n+            Class<?> etype = vspecies.elementType();\n+            if (etype != float.class && etype != double.class) {\n+                return false; \/\/ only FP types are supported\n+            }\n+            int maxLaneCount = VectorSupport.getMaxLaneCount(vspecies.elementType());\n+            if (vspecies.length() > maxLaneCount) {\n+                return false; \/\/ lacking vector support (either hardware or disabled on JVM side)\n+            }\n+            if (vspecies == DoubleVector.SPECIES_64) {\n+                return false; \/\/ 64-bit double vectors are not supported\n+            }\n+            if (vspecies.vectorBitSize() == 512) {\n+                if (op == LOG || op == LOG10 || op == POW) {\n+                    return CPUFeatures.X64.SUPPORTS_AVX512DQ; \/\/ requires AVX512DQ CPU support\n+                }\n+            } else if (op == POW) {\n+                return false; \/\/ not supported\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * Naming convention in SLEEF-based vector math library .\n+     * All the methods are named as <OP><T><N>_<U><suffix> where:\n+     *     <OP>     is the operation name, e.g. sin\n+     *     <T>      is optional to indicate float\/double\n+     *              \"f\/d\" for vector float\/double operation\n+     *     <N>      is the number of elements in the vector\n+     *              \"2\/4\" for neon, and \"x\" for sve\/rvv\n+     *     <U>      is the precision level\n+     *              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n+     *               We use \"u10\" for all operations by default\n+     *               But for those functions do not have u10 support, we use \"u05\" instead\n+     *     <suffix> indicates neon\/sve\/rvv\n+     *              \"sve\/advsimd\/rvv\" for sve\/neon\/rvv implementations\n+     *     e.g. sinfx_u10sve is the method for computing vector float sin using SVE instructions\n+     *          cosd2_u10advsimd is the method for computing 2 elements vector double cos using NEON instructions\n+     *\/\n+    private static class SLEEF implements Library {\n+        static {\n+            VectorSupport.loadNativeLibrary(\"sleef\");\n+        }\n+\n+        private static String suffix(VectorShape vshape, boolean isShapeAgnostic) {\n+            if (isAARCH64()) {\n+                if (isShapeAgnostic) {\n+                    return \"sve\";\n+                } else {\n+                    return \"advsimd\";\n+                }\n+            } else if (isRISCV64()) {\n+                assert isShapeAgnostic : \"not supported\";\n+                return \"rvv\";\n+            } else {\n+                throw new InternalError(\"unsupported platform\");\n+            }\n+        }\n+\n+        private static String precisionLevel(Operator op) {\n+            return (op == HYPOT ? \"u05\" : \"u10\");\n+        }\n+\n+        @Override\n+        public String symbolName(Operator op, VectorSpecies<?> vspecies) {\n+            boolean isFloat64Vector = (vspecies.elementType() == float.class) && (vspecies.length() == 2); \/\/ Float64Vector or FloatMaxVector\n+            int vlen = (isFloat64Vector ? 4 : vspecies.length()); \/\/ reuse 128-bit variant for 64-bit float vectors\n+            boolean isShapeAgnostic = isRISCV64() || (isAARCH64() && vspecies.vectorBitSize() > 128);\n+            return String.format(\"%s%s%s_%s%s\", op.operatorName(),\n+                                 (vspecies.elementType() == float.class ? \"f\" : \"d\"),\n+                                 (isShapeAgnostic ? \"x\" : Integer.toString(vlen)),\n+                                 precisionLevel(op),\n+                                 suffix(vspecies.vectorShape(), isShapeAgnostic));\n+        }\n+\n+        @Override\n+        public boolean isSupported(Operator op, VectorSpecies<?> vspecies) {\n+            Class<?> etype = vspecies.elementType();\n+            if (etype != float.class && etype != double.class) {\n+                return false; \/\/ only FP element types are supported\n+            }\n+            int maxLaneCount = VectorSupport.getMaxLaneCount(vspecies.elementType());\n+            if (vspecies.length() > maxLaneCount) {\n+                return false; \/\/ lacking vector support (either hardware or disabled on JVM side)\n+            }\n+            if (vspecies == DoubleVector.SPECIES_64) {\n+                return false; \/\/ 64-bit double vectors are not supported\n+            }\n+            if (op == TANH) {\n+                return false; \/\/ skip due to performance considerations\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private static final int SIZE = VectorSupport.VECTOR_OP_MATHLIB_LAST - VectorSupport.VECTOR_OP_MATHLIB_FIRST + 1;\n+\n+    private record Entry<T> (String name, MemorySegment entry, T impl) {}\n+\n+    private static final @Stable Entry<?>[][][] LIBRARY_ENTRIES = new Entry<?>[SIZE][LaneType.SK_LIMIT][VectorShape.SK_LIMIT]; \/\/ OP x SHAPE x TYPE\n+\n+    @ForceInline\n+    private static <T> Entry<T> lookup(Operator op, int opc, VectorSpecies<?> vspecies, IntFunction<T> implSupplier) {\n+        int idx = opc - VectorSupport.VECTOR_OP_MATHLIB_FIRST;\n+        int elem_idx = ((AbstractSpecies<?>)vspecies).laneType.switchKey;\n+        int shape_idx = vspecies.vectorShape().switchKey;\n+        @SuppressWarnings({\"unchecked\"})\n+        Entry<T> entry = (Entry<T>)LIBRARY_ENTRIES[idx][elem_idx][shape_idx];\n+        if (entry == null) {\n+            entry = constructEntry(op, opc, vspecies, implSupplier);\n+            LIBRARY_ENTRIES[idx][elem_idx][shape_idx] = entry;\n+        }\n+        return entry;\n+    }\n+\n+    @DontInline\n+    private static\n+    <E,T>\n+    Entry<T> constructEntry(Operator op, int opc, VectorSpecies<E> vspecies, IntFunction<T> implSupplier) {\n+        if (LIBRARY.isSupported(op, vspecies)) {\n+            String symbol = LIBRARY.symbolName(op, vspecies);\n+            try {\n+                MemorySegment addr = LOOKUP.findOrThrow(symbol);\n+                debug(\"%s %s => 0x%016x\\n\", op, symbol, addr.address());\n+                T impl = implSupplier.apply(opc); \/\/ TODO: should call the very same native implementation eventually (once FFM API supports vectors)\n+                return new Entry<>(symbol, addr, impl);\n+            } catch (RuntimeException e) {\n+              throw new InternalError(\"not supported: \" + op + \" \" + vspecies + \" \" + symbol, e);\n+            }\n+        } else {\n+            return new Entry<>(null, MemorySegment.NULL, implSupplier.apply(opc));\n+        }\n+    }\n+\n+    @ForceInline\n+    \/*package-private*\/ static\n+    <E, V extends Vector<E>>\n+    V unaryMathOp(Unary op, int opc, VectorSpecies<E> vspecies,\n+                  IntFunction<VectorSupport.UnaryOperation<V,?>> implSupplier,\n+                  V v) {\n+        var entry = lookup(op, opc, vspecies, implSupplier);\n+\n+        long entryAddress = entry.entry.address();\n+        if (entryAddress != 0) {\n+            @SuppressWarnings({\"unchecked\"})\n+            Class<V> vt = (Class<V>)vspecies.vectorType();\n+            return VectorSupport.libraryUnaryOp(\n+                    entry.entry.address(), vt, vspecies.elementType(), vspecies.length(), entry.name,\n+                    v,\n+                    entry.impl);\n+        } else {\n+            return entry.impl.apply(v, null);\n+        }\n+    }\n+\n+    @ForceInline\n+    \/*package-private*\/ static\n+    <E, V extends Vector<E>>\n+    V binaryMathOp(Binary op, int opc, VectorSpecies<E> vspecies,\n+                   IntFunction<VectorSupport.BinaryOperation<V,?>> implSupplier,\n+                   V v1, V v2) {\n+        var entry = lookup(op, opc, vspecies, implSupplier);\n+\n+        long entryAddress = entry.entry.address();\n+        if (entryAddress != 0) {\n+            @SuppressWarnings({\"unchecked\"})\n+            Class<V> vt = (Class<V>)vspecies.vectorType();\n+            return VectorSupport.libraryBinaryOp(\n+                    entry.entry.address(), vt, vspecies.elementType(), vspecies.length(), entry.name,\n+                    v1, v2,\n+                    entry.impl);\n+        } else {\n+            return entry.impl.apply(v1, v2, null);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMathLibrary.java","additions":325,"deletions":0,"binary":false,"changes":325,"status":"added"},{"patch":"@@ -36,0 +36,2 @@\n+import static jdk.internal.vm.vector.Utils.isNonCapturingLambda;\n+\n@@ -429,0 +431,1 @@\n+        VO_MATHLIB                 = 0x400,\n@@ -479,1 +482,1 @@\n-    public static final \/*float*\/ Unary SIN = unary(\"SIN\", \"sin\", VectorSupport.VECTOR_OP_SIN, VO_ONLYFP);\n+    public static final \/*float*\/ Unary SIN = unary(\"SIN\", \"sin\", VectorSupport.VECTOR_OP_SIN, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -483,1 +486,1 @@\n-    public static final \/*float*\/ Unary COS = unary(\"COS\", \"cos\", VectorSupport.VECTOR_OP_COS, VO_ONLYFP);\n+    public static final \/*float*\/ Unary COS = unary(\"COS\", \"cos\", VectorSupport.VECTOR_OP_COS, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -487,1 +490,1 @@\n-    public static final \/*float*\/ Unary TAN = unary(\"TAN\", \"tan\", VectorSupport.VECTOR_OP_TAN, VO_ONLYFP);\n+    public static final \/*float*\/ Unary TAN = unary(\"TAN\", \"tan\", VectorSupport.VECTOR_OP_TAN, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -491,1 +494,1 @@\n-    public static final \/*float*\/ Unary ASIN = unary(\"ASIN\", \"asin\", VectorSupport.VECTOR_OP_ASIN, VO_ONLYFP);\n+    public static final \/*float*\/ Unary ASIN = unary(\"ASIN\", \"asin\", VectorSupport.VECTOR_OP_ASIN, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -495,1 +498,1 @@\n-    public static final \/*float*\/ Unary ACOS = unary(\"ACOS\", \"acos\", VectorSupport.VECTOR_OP_ACOS, VO_ONLYFP);\n+    public static final \/*float*\/ Unary ACOS = unary(\"ACOS\", \"acos\", VectorSupport.VECTOR_OP_ACOS, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -499,1 +502,1 @@\n-    public static final \/*float*\/ Unary ATAN = unary(\"ATAN\", \"atan\", VectorSupport.VECTOR_OP_ATAN, VO_ONLYFP);\n+    public static final \/*float*\/ Unary ATAN = unary(\"ATAN\", \"atan\", VectorSupport.VECTOR_OP_ATAN, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -504,1 +507,1 @@\n-    public static final \/*float*\/ Unary EXP = unary(\"EXP\", \"exp\", VectorSupport.VECTOR_OP_EXP, VO_ONLYFP);\n+    public static final \/*float*\/ Unary EXP = unary(\"EXP\", \"exp\", VectorSupport.VECTOR_OP_EXP, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -508,1 +511,1 @@\n-    public static final \/*float*\/ Unary LOG = unary(\"LOG\", \"log\", VectorSupport.VECTOR_OP_LOG, VO_ONLYFP);\n+    public static final \/*float*\/ Unary LOG = unary(\"LOG\", \"log\", VectorSupport.VECTOR_OP_LOG, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -512,1 +515,1 @@\n-    public static final \/*float*\/ Unary LOG10 = unary(\"LOG10\", \"log10\", VectorSupport.VECTOR_OP_LOG10, VO_ONLYFP);\n+    public static final \/*float*\/ Unary LOG10 = unary(\"LOG10\", \"log10\", VectorSupport.VECTOR_OP_LOG10, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -518,1 +521,1 @@\n-    public static final \/*float*\/ Unary CBRT = unary(\"CBRT\", \"cbrt\", VectorSupport.VECTOR_OP_CBRT, VO_ONLYFP);\n+    public static final \/*float*\/ Unary CBRT = unary(\"CBRT\", \"cbrt\", VectorSupport.VECTOR_OP_CBRT, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -523,1 +526,1 @@\n-    public static final \/*float*\/ Unary SINH = unary(\"SINH\", \"sinh\", VectorSupport.VECTOR_OP_SINH, VO_ONLYFP);\n+    public static final \/*float*\/ Unary SINH = unary(\"SINH\", \"sinh\", VectorSupport.VECTOR_OP_SINH, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -527,1 +530,1 @@\n-    public static final \/*float*\/ Unary COSH = unary(\"COSH\", \"cosh\", VectorSupport.VECTOR_OP_COSH, VO_ONLYFP);\n+    public static final \/*float*\/ Unary COSH = unary(\"COSH\", \"cosh\", VectorSupport.VECTOR_OP_COSH, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -531,1 +534,1 @@\n-    public static final \/*float*\/ Unary TANH = unary(\"TANH\", \"tanh\", VectorSupport.VECTOR_OP_TANH, VO_ONLYFP);\n+    public static final \/*float*\/ Unary TANH = unary(\"TANH\", \"tanh\", VectorSupport.VECTOR_OP_TANH, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -535,1 +538,1 @@\n-    public static final \/*float*\/ Unary EXPM1 = unary(\"EXPM1\", \"expm1\", VectorSupport.VECTOR_OP_EXPM1, VO_ONLYFP);\n+    public static final \/*float*\/ Unary EXPM1 = unary(\"EXPM1\", \"expm1\", VectorSupport.VECTOR_OP_EXPM1, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -539,1 +542,1 @@\n-    public static final \/*float*\/ Unary LOG1P = unary(\"LOG1P\", \"log1p\", VectorSupport.VECTOR_OP_LOG1P, VO_ONLYFP);\n+    public static final \/*float*\/ Unary LOG1P = unary(\"LOG1P\", \"log1p\", VectorSupport.VECTOR_OP_LOG1P, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -618,1 +621,1 @@\n-    public static final \/*float*\/ Binary ATAN2 = binary(\"ATAN2\", \"atan2\", VectorSupport.VECTOR_OP_ATAN2, VO_ONLYFP);\n+    public static final \/*float*\/ Binary ATAN2 = binary(\"ATAN2\", \"atan2\", VectorSupport.VECTOR_OP_ATAN2, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -622,1 +625,1 @@\n-    public static final \/*float*\/ Binary POW = binary(\"POW\", \"pow\", VectorSupport.VECTOR_OP_POW, VO_ONLYFP);\n+    public static final \/*float*\/ Binary POW = binary(\"POW\", \"pow\", VectorSupport.VECTOR_OP_POW, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -626,1 +629,1 @@\n-    public static final \/*float*\/ Binary HYPOT = binary(\"HYPOT\", \"hypot\", VectorSupport.VECTOR_OP_HYPOT, VO_ONLYFP);\n+    public static final \/*float*\/ Binary HYPOT = binary(\"HYPOT\", \"hypot\", VectorSupport.VECTOR_OP_HYPOT, VO_ONLYFP | VO_SPECIAL | VO_MATHLIB);\n@@ -1376,1 +1379,1 @@\n-            assert(VectorSupport.isNonCapturingLambda(fn)) : fn;\n+            assert(isNonCapturingLambda(fn)) : fn;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -715,1 +715,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -719,0 +719,5 @@\n+#if[FP]\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return unaryMathOp(op);\n+            }\n+#end[FP]\n@@ -745,1 +750,1 @@\n-            if (op == NOT) {\n+            else if (op == NOT) {\n@@ -749,0 +754,5 @@\n+#if[FP]\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return blend(unaryMathOp(op), m);\n+            }\n+#end[FP]\n@@ -757,0 +767,9 @@\n+#if[FP]\n+    @ForceInline\n+    final\n+    $abstractvectortype$ unaryMathOp(VectorOperators.Unary op) {\n+        return VectorMathLibrary.unaryMathOp(op, opCode(op), species(), $abstractvectortype$::unaryOperations,\n+                                             this);\n+    }\n+#end[FP]\n+\n@@ -859,0 +878,5 @@\n+#if[FP]\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return binaryMathOp(op, that);\n+            }\n+#end[FP]\n@@ -918,0 +942,6 @@\n+#if[FP]\n+            else if (opKind(op, VO_MATHLIB)) {\n+                return this.blend(binaryMathOp(op, that), m);\n+            }\n+#end[FP]\n+\n@@ -948,0 +978,9 @@\n+#if[FP]\n+    @ForceInline\n+    final\n+    $abstractvectortype$ binaryMathOp(VectorOperators.Binary op, $abstractvectortype$ that) {\n+        return VectorMathLibrary.binaryMathOp(op, opCode(op), species(), $abstractvectortype$::binaryOperations,\n+                                              this, that);\n+    }\n+#end[FP]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,0 +186,2 @@\n+        FPHP,\n+        ASIMDHP,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/aarch64\/AArch64.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -314,0 +314,6 @@\n+        var syntaxHighlight = options.syntaxHighlight();\n+        if (syntaxHighlight) {\n+            copyResource(DocPaths.HIGHLIGHT_CSS, DocPaths.RESOURCE_FILES.resolve(DocPaths.HIGHLIGHT_CSS), true);\n+            copyResource(DocPaths.HIGHLIGHT_JS, DocPaths.SCRIPT_FILES.resolve(DocPaths.HIGHLIGHT_JS), true);\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -514,0 +514,1 @@\n+                .setSyntaxHighlight(options.syntaxHighlight())\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,0 +201,5 @@\n+    \/**\n+     * Argument for command line option {@code --syntax-highlight}.\n+     *\/\n+    private boolean syntaxHighlight = false;\n+\n@@ -426,0 +431,8 @@\n+                new Option(resources, \"--syntax-highlight\") {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        syntaxHighlight = true;\n+                        return true;\n+                    }\n+                },\n+\n@@ -809,0 +822,7 @@\n+    \/**\n+     * Argument for command line option {@code --syntax-highlight}.\n+     * True if command line option \"--syntax-highlight\" is used and syntax\n+     * highlighting should be enabled. Default value is false.\n+     *\/\n+    public boolean syntaxHighlight() { return syntaxHighlight; }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlOptions.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+    private boolean syntaxHighlight = false;\n@@ -241,0 +242,10 @@\n+    \/**\n+     * Enables or disables support for syntax highlighting.\n+     * @param value {@code true} to enable syntax highligting\n+     * @return this object\n+     *\/\n+    public Head setSyntaxHighlight(boolean value) {\n+        this.syntaxHighlight = value;\n+        return this;\n+    }\n+\n@@ -342,0 +353,5 @@\n+        if (syntaxHighlight) {\n+            addStylesheet(head, DocPaths.RESOURCE_FILES.resolve(DocPaths.HIGHLIGHT_CSS));\n+            addScriptElement(head, DocPaths.HIGHLIGHT_JS);\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Head.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n+ *\/\n+\/* Syntax highlight style sheet *\/\n+.hljs-title.function_,\n+.hljs-template-variable {\n+    color: #00738F;\n+}\n+.hljs-code,\n+.hljs-comment,\n+.hljs-quote {\n+    color: #6e6e71;\n+    font-style: italic;\n+}\n+.hljs-meta {\n+    color: #836F00;\n+}\n+.hljs-symbol,\n+.hljs-template-tag,\n+.hljs-keyword,\n+.hljs-literal,\n+.hljs-name,\n+.hljs-built_in,\n+.hljs-char.escape_ {\n+    color: #0C40C2;\n+}\n+.hljs-variable,\n+.hljs-property,\n+.hljs-attr,\n+.hljs-section {\n+    color: #841191;\n+}\n+.hljs-attribute {\n+    color: #164ad9;\n+}\n+.hljs-regexp,\n+.hljs-number {\n+    color: #104BEB;\n+}\n+.hljs-link {\n+    color: #47688a;\n+}\n+.hljs-string {\n+    color: #008313;\n+}\n+.hljs-doctag {\n+    text-decoration: underline;\n+}\n+.hljs-emphasis {\n+    font-style: italic;\n+}\n+.hljs-strong {\n+    font-weight: bold;\n+}\n+.hljs-subst,\n+.hljs-title,\n+.hljs-params,\n+.hljs-bullet,\n+.hljs-formula,\n+.hljs-tag,\n+.hljs-type {\n+    \/* ignored *\/\n+}\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/highlight.css","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,3278 @@\n+\/*!\n+  Highlight.js v11.11.1 (git: 08cb242e7d)\n+  (c) 2006-2025 Josh Goebel <hello@joshgoebel.com> and other contributors\n+  License: BSD-3-Clause\n+ *\/\n+var hljs = (function () {\n+  'use strict';\n+\n+  \/* eslint-disable no-multi-assign *\/\n+\n+  function deepFreeze(obj) {\n+    if (obj instanceof Map) {\n+      obj.clear =\n+        obj.delete =\n+        obj.set =\n+          function () {\n+            throw new Error('map is read-only');\n+          };\n+    } else if (obj instanceof Set) {\n+      obj.add =\n+        obj.clear =\n+        obj.delete =\n+          function () {\n+            throw new Error('set is read-only');\n+          };\n+    }\n+\n+    \/\/ Freeze self\n+    Object.freeze(obj);\n+\n+    Object.getOwnPropertyNames(obj).forEach((name) => {\n+      const prop = obj[name];\n+      const type = typeof prop;\n+\n+      \/\/ Freeze prop if it is an object or function and also not already frozen\n+      if ((type === 'object' || type === 'function') && !Object.isFrozen(prop)) {\n+        deepFreeze(prop);\n+      }\n+    });\n+\n+    return obj;\n+  }\n+\n+  \/** @typedef {import('highlight.js').CallbackResponse} CallbackResponse *\/\n+  \/** @typedef {import('highlight.js').CompiledMode} CompiledMode *\/\n+  \/** @implements CallbackResponse *\/\n+\n+  class Response {\n+    \/**\n+     * @param {CompiledMode} mode\n+     *\/\n+    constructor(mode) {\n+      \/\/ eslint-disable-next-line no-undefined\n+      if (mode.data === undefined) mode.data = {};\n+\n+      this.data = mode.data;\n+      this.isMatchIgnored = false;\n+    }\n+\n+    ignoreMatch() {\n+      this.isMatchIgnored = true;\n+    }\n+  }\n+\n+  \/**\n+   * @param {string} value\n+   * @returns {string}\n+   *\/\n+  function escapeHTML(value) {\n+    return value\n+      .replace(\/&\/g, '&amp;')\n+      .replace(\/<\/g, '&lt;')\n+      .replace(\/>\/g, '&gt;')\n+      .replace(\/\"\/g, '&quot;')\n+      .replace(\/'\/g, '&#x27;');\n+  }\n+\n+  \/**\n+   * performs a shallow merge of multiple objects into one\n+   *\n+   * @template T\n+   * @param {T} original\n+   * @param {Record<string,any>[]} objects\n+   * @returns {T} a single new object\n+   *\/\n+  function inherit$1(original, ...objects) {\n+    \/** @type Record<string,any> *\/\n+    const result = Object.create(null);\n+\n+    for (const key in original) {\n+      result[key] = original[key];\n+    }\n+    objects.forEach(function(obj) {\n+      for (const key in obj) {\n+        result[key] = obj[key];\n+      }\n+    });\n+    return \/** @type {T} *\/ (result);\n+  }\n+\n+  \/**\n+   * @typedef {object} Renderer\n+   * @property {(text: string) => void} addText\n+   * @property {(node: Node) => void} openNode\n+   * @property {(node: Node) => void} closeNode\n+   * @property {() => string} value\n+   *\/\n+\n+  \/** @typedef {{scope?: string, language?: string, sublanguage?: boolean}} Node *\/\n+  \/** @typedef {{walk: (r: Renderer) => void}} Tree *\/\n+  \/** *\/\n+\n+  const SPAN_CLOSE = '<\/span>';\n+\n+  \/**\n+   * Determines if a node needs to be wrapped in <span>\n+   *\n+   * @param {Node} node *\/\n+  const emitsWrappingTags = (node) => {\n+    \/\/ rarely we can have a sublanguage where language is undefined\n+    \/\/ TODO: track down why\n+    return !!node.scope;\n+  };\n+\n+  \/**\n+   *\n+   * @param {string} name\n+   * @param {{prefix:string}} options\n+   *\/\n+  const scopeToCSSClass = (name, { prefix }) => {\n+    \/\/ sub-language\n+    if (name.startsWith(\"language:\")) {\n+      return name.replace(\"language:\", \"language-\");\n+    }\n+    \/\/ tiered scope: comment.line\n+    if (name.includes(\".\")) {\n+      const pieces = name.split(\".\");\n+      return [\n+        `${prefix}${pieces.shift()}`,\n+        ...(pieces.map((x, i) => `${x}${\"_\".repeat(i + 1)}`))\n+      ].join(\" \");\n+    }\n+    \/\/ simple scope\n+    return `${prefix}${name}`;\n+  };\n+\n+  \/** @type {Renderer} *\/\n+  class HTMLRenderer {\n+    \/**\n+     * Creates a new HTMLRenderer\n+     *\n+     * @param {Tree} parseTree - the parse tree (must support `walk` API)\n+     * @param {{classPrefix: string}} options\n+     *\/\n+    constructor(parseTree, options) {\n+      this.buffer = \"\";\n+      this.classPrefix = options.classPrefix;\n+      parseTree.walk(this);\n+    }\n+\n+    \/**\n+     * Adds texts to the output stream\n+     *\n+     * @param {string} text *\/\n+    addText(text) {\n+      this.buffer += escapeHTML(text);\n+    }\n+\n+    \/**\n+     * Adds a node open to the output stream (if needed)\n+     *\n+     * @param {Node} node *\/\n+    openNode(node) {\n+      if (!emitsWrappingTags(node)) return;\n+\n+      const className = scopeToCSSClass(node.scope,\n+        { prefix: this.classPrefix });\n+      this.span(className);\n+    }\n+\n+    \/**\n+     * Adds a node close to the output stream (if needed)\n+     *\n+     * @param {Node} node *\/\n+    closeNode(node) {\n+      if (!emitsWrappingTags(node)) return;\n+\n+      this.buffer += SPAN_CLOSE;\n+    }\n+\n+    \/**\n+     * returns the accumulated buffer\n+    *\/\n+    value() {\n+      return this.buffer;\n+    }\n+\n+    \/\/ helpers\n+\n+    \/**\n+     * Builds a span element\n+     *\n+     * @param {string} className *\/\n+    span(className) {\n+      this.buffer += `<span class=\"${className}\">`;\n+    }\n+  }\n+\n+  \/** @typedef {{scope?: string, language?: string, children: Node[]} | string} Node *\/\n+  \/** @typedef {{scope?: string, language?: string, children: Node[]} } DataNode *\/\n+  \/** @typedef {import('highlight.js').Emitter} Emitter *\/\n+  \/**  *\/\n+\n+  \/** @returns {DataNode} *\/\n+  const newNode = (opts = {}) => {\n+    \/** @type DataNode *\/\n+    const result = { children: [] };\n+    Object.assign(result, opts);\n+    return result;\n+  };\n+\n+  class TokenTree {\n+    constructor() {\n+      \/** @type DataNode *\/\n+      this.rootNode = newNode();\n+      this.stack = [this.rootNode];\n+    }\n+\n+    get top() {\n+      return this.stack[this.stack.length - 1];\n+    }\n+\n+    get root() { return this.rootNode; }\n+\n+    \/** @param {Node} node *\/\n+    add(node) {\n+      this.top.children.push(node);\n+    }\n+\n+    \/** @param {string} scope *\/\n+    openNode(scope) {\n+      \/** @type Node *\/\n+      const node = newNode({ scope });\n+      this.add(node);\n+      this.stack.push(node);\n+    }\n+\n+    closeNode() {\n+      if (this.stack.length > 1) {\n+        return this.stack.pop();\n+      }\n+      \/\/ eslint-disable-next-line no-undefined\n+      return undefined;\n+    }\n+\n+    closeAllNodes() {\n+      while (this.closeNode());\n+    }\n+\n+    toJSON() {\n+      return JSON.stringify(this.rootNode, null, 4);\n+    }\n+\n+    \/**\n+     * @typedef { import(\".\/html_renderer\").Renderer } Renderer\n+     * @param {Renderer} builder\n+     *\/\n+    walk(builder) {\n+      \/\/ this does not\n+      return this.constructor._walk(builder, this.rootNode);\n+      \/\/ this works\n+      \/\/ return TokenTree._walk(builder, this.rootNode);\n+    }\n+\n+    \/**\n+     * @param {Renderer} builder\n+     * @param {Node} node\n+     *\/\n+    static _walk(builder, node) {\n+      if (typeof node === \"string\") {\n+        builder.addText(node);\n+      } else if (node.children) {\n+        builder.openNode(node);\n+        node.children.forEach((child) => this._walk(builder, child));\n+        builder.closeNode(node);\n+      }\n+      return builder;\n+    }\n+\n+    \/**\n+     * @param {Node} node\n+     *\/\n+    static _collapse(node) {\n+      if (typeof node === \"string\") return;\n+      if (!node.children) return;\n+\n+      if (node.children.every(el => typeof el === \"string\")) {\n+        \/\/ node.text = node.children.join(\"\");\n+        \/\/ delete node.children;\n+        node.children = [node.children.join(\"\")];\n+      } else {\n+        node.children.forEach((child) => {\n+          TokenTree._collapse(child);\n+        });\n+      }\n+    }\n+  }\n+\n+  \/**\n+    Currently this is all private API, but this is the minimal API necessary\n+    that an Emitter must implement to fully support the parser.\n+\n+    Minimal interface:\n+\n+    - addText(text)\n+    - __addSublanguage(emitter, subLanguageName)\n+    - startScope(scope)\n+    - endScope()\n+    - finalize()\n+    - toHTML()\n+\n+  *\/\n+\n+  \/**\n+   * @implements {Emitter}\n+   *\/\n+  class TokenTreeEmitter extends TokenTree {\n+    \/**\n+     * @param {*} options\n+     *\/\n+    constructor(options) {\n+      super();\n+      this.options = options;\n+    }\n+\n+    \/**\n+     * @param {string} text\n+     *\/\n+    addText(text) {\n+      if (text === \"\") { return; }\n+\n+      this.add(text);\n+    }\n+\n+    \/** @param {string} scope *\/\n+    startScope(scope) {\n+      this.openNode(scope);\n+    }\n+\n+    endScope() {\n+      this.closeNode();\n+    }\n+\n+    \/**\n+     * @param {Emitter & {root: DataNode}} emitter\n+     * @param {string} name\n+     *\/\n+    __addSublanguage(emitter, name) {\n+      \/** @type DataNode *\/\n+      const node = emitter.root;\n+      if (name) node.scope = `language:${name}`;\n+\n+      this.add(node);\n+    }\n+\n+    toHTML() {\n+      const renderer = new HTMLRenderer(this, this.options);\n+      return renderer.value();\n+    }\n+\n+    finalize() {\n+      this.closeAllNodes();\n+      return true;\n+    }\n+  }\n+\n+  \/**\n+   * @param {string} value\n+   * @returns {RegExp}\n+   * *\/\n+\n+  \/**\n+   * @param {RegExp | string } re\n+   * @returns {string}\n+   *\/\n+  function source(re) {\n+    if (!re) return null;\n+    if (typeof re === \"string\") return re;\n+\n+    return re.source;\n+  }\n+\n+  \/**\n+   * @param {RegExp | string } re\n+   * @returns {string}\n+   *\/\n+  function lookahead(re) {\n+    return concat('(?=', re, ')');\n+  }\n+\n+  \/**\n+   * @param {RegExp | string } re\n+   * @returns {string}\n+   *\/\n+  function anyNumberOfTimes(re) {\n+    return concat('(?:', re, ')*');\n+  }\n+\n+  \/**\n+   * @param {RegExp | string } re\n+   * @returns {string}\n+   *\/\n+  function optional(re) {\n+    return concat('(?:', re, ')?');\n+  }\n+\n+  \/**\n+   * @param {...(RegExp | string) } args\n+   * @returns {string}\n+   *\/\n+  function concat(...args) {\n+    const joined = args.map((x) => source(x)).join(\"\");\n+    return joined;\n+  }\n+\n+  \/**\n+   * @param { Array<string | RegExp | Object> } args\n+   * @returns {object}\n+   *\/\n+  function stripOptionsFromArgs(args) {\n+    const opts = args[args.length - 1];\n+\n+    if (typeof opts === 'object' && opts.constructor === Object) {\n+      args.splice(args.length - 1, 1);\n+      return opts;\n+    } else {\n+      return {};\n+    }\n+  }\n+\n+  \/** @typedef { {capture?: boolean} } RegexEitherOptions *\/\n+\n+  \/**\n+   * Any of the passed expresssions may match\n+   *\n+   * Creates a huge this | this | that | that match\n+   * @param {(RegExp | string)[] | [...(RegExp | string)[], RegexEitherOptions]} args\n+   * @returns {string}\n+   *\/\n+  function either(...args) {\n+    \/** @type { object & {capture?: boolean} }  *\/\n+    const opts = stripOptionsFromArgs(args);\n+    const joined = '('\n+      + (opts.capture ? \"\" : \"?:\")\n+      + args.map((x) => source(x)).join(\"|\") + \")\";\n+    return joined;\n+  }\n+\n+  \/**\n+   * @param {RegExp | string} re\n+   * @returns {number}\n+   *\/\n+  function countMatchGroups(re) {\n+    return (new RegExp(re.toString() + '|')).exec('').length - 1;\n+  }\n+\n+  \/**\n+   * Does lexeme start with a regular expression match at the beginning\n+   * @param {RegExp} re\n+   * @param {string} lexeme\n+   *\/\n+  function startsWith(re, lexeme) {\n+    const match = re && re.exec(lexeme);\n+    return match && match.index === 0;\n+  }\n+\n+  \/\/ BACKREF_RE matches an open parenthesis or backreference. To avoid\n+  \/\/ an incorrect parse, it additionally matches the following:\n+  \/\/ - [...] elements, where the meaning of parentheses and escapes change\n+  \/\/ - other escape sequences, so we do not misparse escape sequences as\n+  \/\/   interesting elements\n+  \/\/ - non-matching or lookahead parentheses, which do not capture. These\n+  \/\/   follow the '(' with a '?'.\n+  const BACKREF_RE = \/\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\.\/;\n+\n+  \/\/ **INTERNAL** Not intended for outside usage\n+  \/\/ join logically computes regexps.join(separator), but fixes the\n+  \/\/ backreferences so they continue to match.\n+  \/\/ it also places each individual regular expression into it's own\n+  \/\/ match group, keeping track of the sequencing of those match groups\n+  \/\/ is currently an exercise for the caller. :-)\n+  \/**\n+   * @param {(string | RegExp)[]} regexps\n+   * @param {{joinWith: string}} opts\n+   * @returns {string}\n+   *\/\n+  function _rewriteBackreferences(regexps, { joinWith }) {\n+    let numCaptures = 0;\n+\n+    return regexps.map((regex) => {\n+      numCaptures += 1;\n+      const offset = numCaptures;\n+      let re = source(regex);\n+      let out = '';\n+\n+      while (re.length > 0) {\n+        const match = BACKREF_RE.exec(re);\n+        if (!match) {\n+          out += re;\n+          break;\n+        }\n+        out += re.substring(0, match.index);\n+        re = re.substring(match.index + match[0].length);\n+        if (match[0][0] === '\\\\' && match[1]) {\n+          \/\/ Adjust the backreference.\n+          out += '\\\\' + String(Number(match[1]) + offset);\n+        } else {\n+          out += match[0];\n+          if (match[0] === '(') {\n+            numCaptures++;\n+          }\n+        }\n+      }\n+      return out;\n+    }).map(re => `(${re})`).join(joinWith);\n+  }\n+\n+  \/** @typedef {import('highlight.js').Mode} Mode *\/\n+  \/** @typedef {import('highlight.js').ModeCallback} ModeCallback *\/\n+\n+  \/\/ Common regexps\n+  const MATCH_NOTHING_RE = \/\\b\\B\/;\n+  const IDENT_RE = '[a-zA-Z]\\\\w*';\n+  const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\\\w*';\n+  const NUMBER_RE = '\\\\b\\\\d+(\\\\.\\\\d+)?';\n+  const C_NUMBER_RE = '(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)'; \/\/ 0x..., 0..., decimal, float\n+  const BINARY_NUMBER_RE = '\\\\b(0b[01]+)'; \/\/ 0b...\n+  const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|\/=|\/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~';\n+\n+  \/**\n+  * @param { Partial<Mode> & {binary?: string | RegExp} } opts\n+  *\/\n+  const SHEBANG = (opts = {}) => {\n+    const beginShebang = \/^#![ ]*\\\/\/;\n+    if (opts.binary) {\n+      opts.begin = concat(\n+        beginShebang,\n+        \/.*\\b\/,\n+        opts.binary,\n+        \/\\b.*\/);\n+    }\n+    return inherit$1({\n+      scope: 'meta',\n+      begin: beginShebang,\n+      end: \/$\/,\n+      relevance: 0,\n+      \/** @type {ModeCallback} *\/\n+      \"on:begin\": (m, resp) => {\n+        if (m.index !== 0) resp.ignoreMatch();\n+      }\n+    }, opts);\n+  };\n+\n+  \/\/ Common modes\n+  const BACKSLASH_ESCAPE = {\n+    begin: '\\\\\\\\[\\\\s\\\\S]', relevance: 0\n+  };\n+  const APOS_STRING_MODE = {\n+    scope: 'string',\n+    begin: '\\'',\n+    end: '\\'',\n+    illegal: '\\\\n',\n+    contains: [BACKSLASH_ESCAPE]\n+  };\n+  const QUOTE_STRING_MODE = {\n+    scope: 'string',\n+    begin: '\"',\n+    end: '\"',\n+    illegal: '\\\\n',\n+    contains: [BACKSLASH_ESCAPE]\n+  };\n+  const PHRASAL_WORDS_MODE = {\n+    begin: \/\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b\/\n+  };\n+  \/**\n+   * Creates a comment mode\n+   *\n+   * @param {string | RegExp} begin\n+   * @param {string | RegExp} end\n+   * @param {Mode | {}} [modeOptions]\n+   * @returns {Partial<Mode>}\n+   *\/\n+  const COMMENT = function(begin, end, modeOptions = {}) {\n+    const mode = inherit$1(\n+      {\n+        scope: 'comment',\n+        begin,\n+        end,\n+        contains: []\n+      },\n+      modeOptions\n+    );\n+    mode.contains.push({\n+      scope: 'doctag',\n+      \/\/ hack to avoid the space from being included. the space is necessary to\n+      \/\/ match here to prevent the plain text rule below from gobbling up doctags\n+      begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',\n+      end: \/(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):\/,\n+      excludeBegin: true,\n+      relevance: 0\n+    });\n+    const ENGLISH_WORD = either(\n+      \/\/ list of common 1 and 2 letter words in English\n+      \"I\",\n+      \"a\",\n+      \"is\",\n+      \"so\",\n+      \"us\",\n+      \"to\",\n+      \"at\",\n+      \"if\",\n+      \"in\",\n+      \"it\",\n+      \"on\",\n+      \/\/ note: this is not an exhaustive list of contractions, just popular ones\n+      \/[A-Za-z]+['](d|ve|re|ll|t|s|n)\/, \/\/ contractions - can't we'd they're let's, etc\n+      \/[A-Za-z]+[-][a-z]+\/, \/\/ `no-way`, etc.\n+      \/[A-Za-z][a-z]{2,}\/ \/\/ allow capitalized words at beginning of sentences\n+    );\n+    \/\/ looking like plain text, more likely to be a comment\n+    mode.contains.push(\n+      {\n+        \/\/ TODO: how to include \", (, ) without breaking grammars that use these for\n+        \/\/ comment delimiters?\n+        \/\/ begin: \/[ ]+([()\"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()\":]?([.][ ]|[ ]|\\))){3}\/\n+        \/\/ ---\n+\n+        \/\/ this tries to find sequences of 3 english words in a row (without any\n+        \/\/ \"programming\" type syntax) this gives us a strong signal that we've\n+        \/\/ TRULY found a comment - vs perhaps scanning with the wrong language.\n+        \/\/ It's possible to find something that LOOKS like the start of the\n+        \/\/ comment - but then if there is no readable text - good chance it is a\n+        \/\/ false match and not a comment.\n+        \/\/\n+        \/\/ for a visual example please see:\n+        \/\/ https:\/\/github.com\/highlightjs\/highlight.js\/issues\/2827\n+\n+        begin: concat(\n+          \/[ ]+\/, \/\/ necessary to prevent us gobbling up doctags like \/* @author Bob Mcgill *\/\n+          '(',\n+          ENGLISH_WORD,\n+          \/[.]?[:]?([.][ ]|[ ])\/,\n+          '){3}') \/\/ look for 3 words in a row\n+      }\n+    );\n+    return mode;\n+  };\n+  const C_LINE_COMMENT_MODE = COMMENT('\/\/', '$');\n+  const C_BLOCK_COMMENT_MODE = COMMENT('\/\\\\*', '\\\\*\/');\n+  const HASH_COMMENT_MODE = COMMENT('#', '$');\n+  const NUMBER_MODE = {\n+    scope: 'number',\n+    begin: NUMBER_RE,\n+    relevance: 0\n+  };\n+  const C_NUMBER_MODE = {\n+    scope: 'number',\n+    begin: C_NUMBER_RE,\n+    relevance: 0\n+  };\n+  const BINARY_NUMBER_MODE = {\n+    scope: 'number',\n+    begin: BINARY_NUMBER_RE,\n+    relevance: 0\n+  };\n+  const REGEXP_MODE = {\n+    scope: \"regexp\",\n+    begin: \/\\\/(?=[^\/\\n]*\\\/)\/,\n+    end: \/\\\/[gimuy]*\/,\n+    contains: [\n+      BACKSLASH_ESCAPE,\n+      {\n+        begin: \/\\[\/,\n+        end: \/\\]\/,\n+        relevance: 0,\n+        contains: [BACKSLASH_ESCAPE]\n+      }\n+    ]\n+  };\n+  const TITLE_MODE = {\n+    scope: 'title',\n+    begin: IDENT_RE,\n+    relevance: 0\n+  };\n+  const UNDERSCORE_TITLE_MODE = {\n+    scope: 'title',\n+    begin: UNDERSCORE_IDENT_RE,\n+    relevance: 0\n+  };\n+  const METHOD_GUARD = {\n+    \/\/ excludes method names from keyword processing\n+    begin: '\\\\.\\\\s*' + UNDERSCORE_IDENT_RE,\n+    relevance: 0\n+  };\n+\n+  \/**\n+   * Adds end same as begin mechanics to a mode\n+   *\n+   * Your mode must include at least a single () match group as that first match\n+   * group is what is used for comparison\n+   * @param {Partial<Mode>} mode\n+   *\/\n+  const END_SAME_AS_BEGIN = function(mode) {\n+    return Object.assign(mode,\n+      {\n+        \/** @type {ModeCallback} *\/\n+        'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },\n+        \/** @type {ModeCallback} *\/\n+        'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }\n+      });\n+  };\n+\n+  var MODES = \/*#__PURE__*\/Object.freeze({\n+    __proto__: null,\n+    APOS_STRING_MODE: APOS_STRING_MODE,\n+    BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,\n+    BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,\n+    BINARY_NUMBER_RE: BINARY_NUMBER_RE,\n+    COMMENT: COMMENT,\n+    C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,\n+    C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,\n+    C_NUMBER_MODE: C_NUMBER_MODE,\n+    C_NUMBER_RE: C_NUMBER_RE,\n+    END_SAME_AS_BEGIN: END_SAME_AS_BEGIN,\n+    HASH_COMMENT_MODE: HASH_COMMENT_MODE,\n+    IDENT_RE: IDENT_RE,\n+    MATCH_NOTHING_RE: MATCH_NOTHING_RE,\n+    METHOD_GUARD: METHOD_GUARD,\n+    NUMBER_MODE: NUMBER_MODE,\n+    NUMBER_RE: NUMBER_RE,\n+    PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,\n+    QUOTE_STRING_MODE: QUOTE_STRING_MODE,\n+    REGEXP_MODE: REGEXP_MODE,\n+    RE_STARTERS_RE: RE_STARTERS_RE,\n+    SHEBANG: SHEBANG,\n+    TITLE_MODE: TITLE_MODE,\n+    UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,\n+    UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE\n+  });\n+\n+  \/**\n+  @typedef {import('highlight.js').CallbackResponse} CallbackResponse\n+  @typedef {import('highlight.js').CompilerExt} CompilerExt\n+  *\/\n+\n+  \/\/ Grammar extensions \/ plugins\n+  \/\/ See: https:\/\/github.com\/highlightjs\/highlight.js\/issues\/2833\n+\n+  \/\/ Grammar extensions allow \"syntactic sugar\" to be added to the grammar modes\n+  \/\/ without requiring any underlying changes to the compiler internals.\n+\n+  \/\/ `compileMatch` being the perfect small example of now allowing a grammar\n+  \/\/ author to write `match` when they desire to match a single expression rather\n+  \/\/ than being forced to use `begin`.  The extension then just moves `match` into\n+  \/\/ `begin` when it runs.  Ie, no features have been added, but we've just made\n+  \/\/ the experience of writing (and reading grammars) a little bit nicer.\n+\n+  \/\/ ------\n+\n+  \/\/ TODO: We need negative look-behind support to do this properly\n+  \/**\n+   * Skip a match if it has a preceding dot\n+   *\n+   * This is used for `beginKeywords` to prevent matching expressions such as\n+   * `bob.keyword.do()`. The mode compiler automatically wires this up as a\n+   * special _internal_ 'on:begin' callback for modes with `beginKeywords`\n+   * @param {RegExpMatchArray} match\n+   * @param {CallbackResponse} response\n+   *\/\n+  function skipIfHasPrecedingDot(match, response) {\n+    const before = match.input[match.index - 1];\n+    if (before === \".\") {\n+      response.ignoreMatch();\n+    }\n+  }\n+\n+  \/**\n+   *\n+   * @type {CompilerExt}\n+   *\/\n+  function scopeClassName(mode, _parent) {\n+    \/\/ eslint-disable-next-line no-undefined\n+    if (mode.className !== undefined) {\n+      mode.scope = mode.className;\n+      delete mode.className;\n+    }\n+  }\n+\n+  \/**\n+   * `beginKeywords` syntactic sugar\n+   * @type {CompilerExt}\n+   *\/\n+  function beginKeywords(mode, parent) {\n+    if (!parent) return;\n+    if (!mode.beginKeywords) return;\n+\n+    \/\/ for languages with keywords that include non-word characters checking for\n+    \/\/ a word boundary is not sufficient, so instead we check for a word boundary\n+    \/\/ or whitespace - this does no harm in any case since our keyword engine\n+    \/\/ doesn't allow spaces in keywords anyways and we still check for the boundary\n+    \/\/ first\n+    mode.begin = '\\\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\\\.)(?=\\\\b|\\\\s)';\n+    mode.__beforeBegin = skipIfHasPrecedingDot;\n+    mode.keywords = mode.keywords || mode.beginKeywords;\n+    delete mode.beginKeywords;\n+\n+    \/\/ prevents double relevance, the keywords themselves provide\n+    \/\/ relevance, the mode doesn't need to double it\n+    \/\/ eslint-disable-next-line no-undefined\n+    if (mode.relevance === undefined) mode.relevance = 0;\n+  }\n+\n+  \/**\n+   * Allow `illegal` to contain an array of illegal values\n+   * @type {CompilerExt}\n+   *\/\n+  function compileIllegal(mode, _parent) {\n+    if (!Array.isArray(mode.illegal)) return;\n+\n+    mode.illegal = either(...mode.illegal);\n+  }\n+\n+  \/**\n+   * `match` to match a single expression for readability\n+   * @type {CompilerExt}\n+   *\/\n+  function compileMatch(mode, _parent) {\n+    if (!mode.match) return;\n+    if (mode.begin || mode.end) throw new Error(\"begin & end are not supported with match\");\n+\n+    mode.begin = mode.match;\n+    delete mode.match;\n+  }\n+\n+  \/**\n+   * provides the default 1 relevance to all modes\n+   * @type {CompilerExt}\n+   *\/\n+  function compileRelevance(mode, _parent) {\n+    \/\/ eslint-disable-next-line no-undefined\n+    if (mode.relevance === undefined) mode.relevance = 1;\n+  }\n+\n+  \/\/ allow beforeMatch to act as a \"qualifier\" for the match\n+  \/\/ the full match begin must be [beforeMatch][begin]\n+  const beforeMatchExt = (mode, parent) => {\n+    if (!mode.beforeMatch) return;\n+    \/\/ starts conflicts with endsParent which we need to make sure the child\n+    \/\/ rule is not matched multiple times\n+    if (mode.starts) throw new Error(\"beforeMatch cannot be used with starts\");\n+\n+    const originalMode = Object.assign({}, mode);\n+    Object.keys(mode).forEach((key) => { delete mode[key]; });\n+\n+    mode.keywords = originalMode.keywords;\n+    mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));\n+    mode.starts = {\n+      relevance: 0,\n+      contains: [\n+        Object.assign(originalMode, { endsParent: true })\n+      ]\n+    };\n+    mode.relevance = 0;\n+\n+    delete originalMode.beforeMatch;\n+  };\n+\n+  \/\/ keywords that should have no default relevance value\n+  const COMMON_KEYWORDS = [\n+    'of',\n+    'and',\n+    'for',\n+    'in',\n+    'not',\n+    'or',\n+    'if',\n+    'then',\n+    'parent', \/\/ common variable name\n+    'list', \/\/ common variable name\n+    'value' \/\/ common variable name\n+  ];\n+\n+  const DEFAULT_KEYWORD_SCOPE = \"keyword\";\n+\n+  \/**\n+   * Given raw keywords from a language definition, compile them.\n+   *\n+   * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords\n+   * @param {boolean} caseInsensitive\n+   *\/\n+  function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {\n+    \/** @type {import(\"highlight.js\/private\").KeywordDict} *\/\n+    const compiledKeywords = Object.create(null);\n+\n+    \/\/ input can be a string of keywords, an array of keywords, or a object with\n+    \/\/ named keys representing scopeName (which can then point to a string or array)\n+    if (typeof rawKeywords === 'string') {\n+      compileList(scopeName, rawKeywords.split(\" \"));\n+    } else if (Array.isArray(rawKeywords)) {\n+      compileList(scopeName, rawKeywords);\n+    } else {\n+      Object.keys(rawKeywords).forEach(function(scopeName) {\n+        \/\/ collapse all our objects back into the parent object\n+        Object.assign(\n+          compiledKeywords,\n+          compileKeywords(rawKeywords[scopeName], caseInsensitive, scopeName)\n+        );\n+      });\n+    }\n+    return compiledKeywords;\n+\n+    \/\/ ---\n+\n+    \/**\n+     * Compiles an individual list of keywords\n+     *\n+     * Ex: \"for if when while|5\"\n+     *\n+     * @param {string} scopeName\n+     * @param {Array<string>} keywordList\n+     *\/\n+    function compileList(scopeName, keywordList) {\n+      if (caseInsensitive) {\n+        keywordList = keywordList.map(x => x.toLowerCase());\n+      }\n+      keywordList.forEach(function(keyword) {\n+        const pair = keyword.split('|');\n+        compiledKeywords[pair[0]] = [scopeName, scoreForKeyword(pair[0], pair[1])];\n+      });\n+    }\n+  }\n+\n+  \/**\n+   * Returns the proper score for a given keyword\n+   *\n+   * Also takes into account comment keywords, which will be scored 0 UNLESS\n+   * another score has been manually assigned.\n+   * @param {string} keyword\n+   * @param {string} [providedScore]\n+   *\/\n+  function scoreForKeyword(keyword, providedScore) {\n+    \/\/ manual scores always win over common keywords\n+    \/\/ so you can force a score of 1 if you really insist\n+    if (providedScore) {\n+      return Number(providedScore);\n+    }\n+\n+    return commonKeyword(keyword) ? 0 : 1;\n+  }\n+\n+  \/**\n+   * Determines if a given keyword is common or not\n+   *\n+   * @param {string} keyword *\/\n+  function commonKeyword(keyword) {\n+    return COMMON_KEYWORDS.includes(keyword.toLowerCase());\n+  }\n+\n+  \/*\n+\n+  For the reasoning behind this please see:\n+  https:\/\/github.com\/highlightjs\/highlight.js\/issues\/2880#issuecomment-747275419\n+\n+  *\/\n+\n+  \/**\n+   * @type {Record<string, boolean>}\n+   *\/\n+  const seenDeprecations = {};\n+\n+  \/**\n+   * @param {string} message\n+   *\/\n+  const error = (message) => {\n+    console.error(message);\n+  };\n+\n+  \/**\n+   * @param {string} message\n+   * @param {any} args\n+   *\/\n+  const warn = (message, ...args) => {\n+    console.log(`WARN: ${message}`, ...args);\n+  };\n+\n+  \/**\n+   * @param {string} version\n+   * @param {string} message\n+   *\/\n+  const deprecated = (version, message) => {\n+    if (seenDeprecations[`${version}\/${message}`]) return;\n+\n+    console.log(`Deprecated as of ${version}. ${message}`);\n+    seenDeprecations[`${version}\/${message}`] = true;\n+  };\n+\n+  \/* eslint-disable no-throw-literal *\/\n+\n+  \/**\n+  @typedef {import('highlight.js').CompiledMode} CompiledMode\n+  *\/\n+\n+  const MultiClassError = new Error();\n+\n+  \/**\n+   * Renumbers labeled scope names to account for additional inner match\n+   * groups that otherwise would break everything.\n+   *\n+   * Lets say we 3 match scopes:\n+   *\n+   *   { 1 => ..., 2 => ..., 3 => ... }\n+   *\n+   * So what we need is a clean match like this:\n+   *\n+   *   (a)(b)(c) => [ \"a\", \"b\", \"c\" ]\n+   *\n+   * But this falls apart with inner match groups:\n+   *\n+   * (a)(((b)))(c) => [\"a\", \"b\", \"b\", \"b\", \"c\" ]\n+   *\n+   * Our scopes are now \"out of alignment\" and we're repeating `b` 3 times.\n+   * What needs to happen is the numbers are remapped:\n+   *\n+   *   { 1 => ..., 2 => ..., 5 => ... }\n+   *\n+   * We also need to know that the ONLY groups that should be output\n+   * are 1, 2, and 5.  This function handles this behavior.\n+   *\n+   * @param {CompiledMode} mode\n+   * @param {Array<RegExp | string>} regexes\n+   * @param {{key: \"beginScope\"|\"endScope\"}} opts\n+   *\/\n+  function remapScopeNames(mode, regexes, { key }) {\n+    let offset = 0;\n+    const scopeNames = mode[key];\n+    \/** @type Record<number,boolean> *\/\n+    const emit = {};\n+    \/** @type Record<number,string> *\/\n+    const positions = {};\n+\n+    for (let i = 1; i <= regexes.length; i++) {\n+      positions[i + offset] = scopeNames[i];\n+      emit[i + offset] = true;\n+      offset += countMatchGroups(regexes[i - 1]);\n+    }\n+    \/\/ we use _emit to keep track of which match groups are \"top-level\" to avoid double\n+    \/\/ output from inside match groups\n+    mode[key] = positions;\n+    mode[key]._emit = emit;\n+    mode[key]._multi = true;\n+  }\n+\n+  \/**\n+   * @param {CompiledMode} mode\n+   *\/\n+  function beginMultiClass(mode) {\n+    if (!Array.isArray(mode.begin)) return;\n+\n+    if (mode.skip || mode.excludeBegin || mode.returnBegin) {\n+      error(\"skip, excludeBegin, returnBegin not compatible with beginScope: {}\");\n+      throw MultiClassError;\n+    }\n+\n+    if (typeof mode.beginScope !== \"object\" || mode.beginScope === null) {\n+      error(\"beginScope must be object\");\n+      throw MultiClassError;\n+    }\n+\n+    remapScopeNames(mode, mode.begin, { key: \"beginScope\" });\n+    mode.begin = _rewriteBackreferences(mode.begin, { joinWith: \"\" });\n+  }\n+\n+  \/**\n+   * @param {CompiledMode} mode\n+   *\/\n+  function endMultiClass(mode) {\n+    if (!Array.isArray(mode.end)) return;\n+\n+    if (mode.skip || mode.excludeEnd || mode.returnEnd) {\n+      error(\"skip, excludeEnd, returnEnd not compatible with endScope: {}\");\n+      throw MultiClassError;\n+    }\n+\n+    if (typeof mode.endScope !== \"object\" || mode.endScope === null) {\n+      error(\"endScope must be object\");\n+      throw MultiClassError;\n+    }\n+\n+    remapScopeNames(mode, mode.end, { key: \"endScope\" });\n+    mode.end = _rewriteBackreferences(mode.end, { joinWith: \"\" });\n+  }\n+\n+  \/**\n+   * this exists only to allow `scope: {}` to be used beside `match:`\n+   * Otherwise `beginScope` would necessary and that would look weird\n+\n+    {\n+      match: [ \/def\/, \/\\w+\/ ]\n+      scope: { 1: \"keyword\" , 2: \"title\" }\n+    }\n+\n+   * @param {CompiledMode} mode\n+   *\/\n+  function scopeSugar(mode) {\n+    if (mode.scope && typeof mode.scope === \"object\" && mode.scope !== null) {\n+      mode.beginScope = mode.scope;\n+      delete mode.scope;\n+    }\n+  }\n+\n+  \/**\n+   * @param {CompiledMode} mode\n+   *\/\n+  function MultiClass(mode) {\n+    scopeSugar(mode);\n+\n+    if (typeof mode.beginScope === \"string\") {\n+      mode.beginScope = { _wrap: mode.beginScope };\n+    }\n+    if (typeof mode.endScope === \"string\") {\n+      mode.endScope = { _wrap: mode.endScope };\n+    }\n+\n+    beginMultiClass(mode);\n+    endMultiClass(mode);\n+  }\n+\n+  \/**\n+  @typedef {import('highlight.js').Mode} Mode\n+  @typedef {import('highlight.js').CompiledMode} CompiledMode\n+  @typedef {import('highlight.js').Language} Language\n+  @typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n+  @typedef {import('highlight.js').CompiledLanguage} CompiledLanguage\n+  *\/\n+\n+  \/\/ compilation\n+\n+  \/**\n+   * Compiles a language definition result\n+   *\n+   * Given the raw result of a language definition (Language), compiles this so\n+   * that it is ready for highlighting code.\n+   * @param {Language} language\n+   * @returns {CompiledLanguage}\n+   *\/\n+  function compileLanguage(language) {\n+    \/**\n+     * Builds a regex with the case sensitivity of the current language\n+     *\n+     * @param {RegExp | string} value\n+     * @param {boolean} [global]\n+     *\/\n+    function langRe(value, global) {\n+      return new RegExp(\n+        source(value),\n+        'm'\n+        + (language.case_insensitive ? 'i' : '')\n+        + (language.unicodeRegex ? 'u' : '')\n+        + (global ? 'g' : '')\n+      );\n+    }\n+\n+    \/**\n+      Stores multiple regular expressions and allows you to quickly search for\n+      them all in a string simultaneously - returning the first match.  It does\n+      this by creating a huge (a|b|c) regex - each individual item wrapped with ()\n+      and joined by `|` - using match groups to track position.  When a match is\n+      found checking which position in the array has content allows us to figure\n+      out which of the original regexes \/ match groups triggered the match.\n+\n+      The match object itself (the result of `Regex.exec`) is returned but also\n+      enhanced by merging in any meta-data that was registered with the regex.\n+      This is how we keep track of which mode matched, and what type of rule\n+      (`illegal`, `begin`, end, etc).\n+    *\/\n+    class MultiRegex {\n+      constructor() {\n+        this.matchIndexes = {};\n+        \/\/ @ts-ignore\n+        this.regexes = [];\n+        this.matchAt = 1;\n+        this.position = 0;\n+      }\n+\n+      \/\/ @ts-ignore\n+      addRule(re, opts) {\n+        opts.position = this.position++;\n+        \/\/ @ts-ignore\n+        this.matchIndexes[this.matchAt] = opts;\n+        this.regexes.push([opts, re]);\n+        this.matchAt += countMatchGroups(re) + 1;\n+      }\n+\n+      compile() {\n+        if (this.regexes.length === 0) {\n+          \/\/ avoids the need to check length every time exec is called\n+          \/\/ @ts-ignore\n+          this.exec = () => null;\n+        }\n+        const terminators = this.regexes.map(el => el[1]);\n+        this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: '|' }), true);\n+        this.lastIndex = 0;\n+      }\n+\n+      \/** @param {string} s *\/\n+      exec(s) {\n+        this.matcherRe.lastIndex = this.lastIndex;\n+        const match = this.matcherRe.exec(s);\n+        if (!match) { return null; }\n+\n+        \/\/ eslint-disable-next-line no-undefined\n+        const i = match.findIndex((el, i) => i > 0 && el !== undefined);\n+        \/\/ @ts-ignore\n+        const matchData = this.matchIndexes[i];\n+        \/\/ trim off any earlier non-relevant match groups (ie, the other regex\n+        \/\/ match groups that make up the multi-matcher)\n+        match.splice(0, i);\n+\n+        return Object.assign(match, matchData);\n+      }\n+    }\n+\n+    \/*\n+      Created to solve the key deficiently with MultiRegex - there is no way to\n+      test for multiple matches at a single location.  Why would we need to do\n+      that?  In the future a more dynamic engine will allow certain matches to be\n+      ignored.  An example: if we matched say the 3rd regex in a large group but\n+      decided to ignore it - we'd need to started testing again at the 4th\n+      regex... but MultiRegex itself gives us no real way to do that.\n+\n+      So what this class creates MultiRegexs on the fly for whatever search\n+      position they are needed.\n+\n+      NOTE: These additional MultiRegex objects are created dynamically.  For most\n+      grammars most of the time we will never actually need anything more than the\n+      first MultiRegex - so this shouldn't have too much overhead.\n+\n+      Say this is our search group, and we match regex3, but wish to ignore it.\n+\n+        regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0\n+\n+      What we need is a new MultiRegex that only includes the remaining\n+      possibilities:\n+\n+        regex4 | regex5                               ' ie, startAt = 3\n+\n+      This class wraps all that complexity up in a simple API... `startAt` decides\n+      where in the array of expressions to start doing the matching. It\n+      auto-increments, so if a match is found at position 2, then startAt will be\n+      set to 3.  If the end is reached startAt will return to 0.\n+\n+      MOST of the time the parser will be setting startAt manually to 0.\n+    *\/\n+    class ResumableMultiRegex {\n+      constructor() {\n+        \/\/ @ts-ignore\n+        this.rules = [];\n+        \/\/ @ts-ignore\n+        this.multiRegexes = [];\n+        this.count = 0;\n+\n+        this.lastIndex = 0;\n+        this.regexIndex = 0;\n+      }\n+\n+      \/\/ @ts-ignore\n+      getMatcher(index) {\n+        if (this.multiRegexes[index]) return this.multiRegexes[index];\n+\n+        const matcher = new MultiRegex();\n+        this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));\n+        matcher.compile();\n+        this.multiRegexes[index] = matcher;\n+        return matcher;\n+      }\n+\n+      resumingScanAtSamePosition() {\n+        return this.regexIndex !== 0;\n+      }\n+\n+      considerAll() {\n+        this.regexIndex = 0;\n+      }\n+\n+      \/\/ @ts-ignore\n+      addRule(re, opts) {\n+        this.rules.push([re, opts]);\n+        if (opts.type === \"begin\") this.count++;\n+      }\n+\n+      \/** @param {string} s *\/\n+      exec(s) {\n+        const m = this.getMatcher(this.regexIndex);\n+        m.lastIndex = this.lastIndex;\n+        let result = m.exec(s);\n+\n+        \/\/ The following is because we have no easy way to say \"resume scanning at the\n+        \/\/ existing position but also skip the current rule ONLY\". What happens is\n+        \/\/ all prior rules are also skipped which can result in matching the wrong\n+        \/\/ thing. Example of matching \"booger\":\n+\n+        \/\/ our matcher is [string, \"booger\", number]\n+        \/\/\n+        \/\/ ....booger....\n+\n+        \/\/ if \"booger\" is ignored then we'd really need a regex to scan from the\n+        \/\/ SAME position for only: [string, number] but ignoring \"booger\" (if it\n+        \/\/ was the first match), a simple resume would scan ahead who knows how\n+        \/\/ far looking only for \"number\", ignoring potential string matches (or\n+        \/\/ future \"booger\" matches that might be valid.)\n+\n+        \/\/ So what we do: We execute two matchers, one resuming at the same\n+        \/\/ position, but the second full matcher starting at the position after:\n+\n+        \/\/     \/--- resume first regex match here (for [number])\n+        \/\/     |\/---- full match here for [string, \"booger\", number]\n+        \/\/     vv\n+        \/\/ ....booger....\n+\n+        \/\/ Which ever results in a match first is then used. So this 3-4 step\n+        \/\/ process essentially allows us to say \"match at this position, excluding\n+        \/\/ a prior rule that was ignored\".\n+        \/\/\n+        \/\/ 1. Match \"booger\" first, ignore. Also proves that [string] does non match.\n+        \/\/ 2. Resume matching for [number]\n+        \/\/ 3. Match at index + 1 for [string, \"booger\", number]\n+        \/\/ 4. If #2 and #3 result in matches, which came first?\n+        if (this.resumingScanAtSamePosition()) {\n+          if (result && result.index === this.lastIndex) ; else { \/\/ use the second matcher result\n+            const m2 = this.getMatcher(0);\n+            m2.lastIndex = this.lastIndex + 1;\n+            result = m2.exec(s);\n+          }\n+        }\n+\n+        if (result) {\n+          this.regexIndex += result.position + 1;\n+          if (this.regexIndex === this.count) {\n+            \/\/ wrap-around to considering all matches again\n+            this.considerAll();\n+          }\n+        }\n+\n+        return result;\n+      }\n+    }\n+\n+    \/**\n+     * Given a mode, builds a huge ResumableMultiRegex that can be used to walk\n+     * the content and find matches.\n+     *\n+     * @param {CompiledMode} mode\n+     * @returns {ResumableMultiRegex}\n+     *\/\n+    function buildModeRegex(mode) {\n+      const mm = new ResumableMultiRegex();\n+\n+      mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: \"begin\" }));\n+\n+      if (mode.terminatorEnd) {\n+        mm.addRule(mode.terminatorEnd, { type: \"end\" });\n+      }\n+      if (mode.illegal) {\n+        mm.addRule(mode.illegal, { type: \"illegal\" });\n+      }\n+\n+      return mm;\n+    }\n+\n+    \/** skip vs abort vs ignore\n+     *\n+     * @skip   - The mode is still entered and exited normally (and contains rules apply),\n+     *           but all content is held and added to the parent buffer rather than being\n+     *           output when the mode ends.  Mostly used with `sublanguage` to build up\n+     *           a single large buffer than can be parsed by sublanguage.\n+     *\n+     *             - The mode begin ands ends normally.\n+     *             - Content matched is added to the parent mode buffer.\n+     *             - The parser cursor is moved forward normally.\n+     *\n+     * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it\n+     *           never matched) but DOES NOT continue to match subsequent `contains`\n+     *           modes.  Abort is bad\/suboptimal because it can result in modes\n+     *           farther down not getting applied because an earlier rule eats the\n+     *           content but then aborts.\n+     *\n+     *             - The mode does not begin.\n+     *             - Content matched by `begin` is added to the mode buffer.\n+     *             - The parser cursor is moved forward accordingly.\n+     *\n+     * @ignore - Ignores the mode (as if it never matched) and continues to match any\n+     *           subsequent `contains` modes.  Ignore isn't technically possible with\n+     *           the current parser implementation.\n+     *\n+     *             - The mode does not begin.\n+     *             - Content matched by `begin` is ignored.\n+     *             - The parser cursor is not moved forward.\n+     *\/\n+\n+    \/**\n+     * Compiles an individual mode\n+     *\n+     * This can raise an error if the mode contains certain detectable known logic\n+     * issues.\n+     * @param {Mode} mode\n+     * @param {CompiledMode | null} [parent]\n+     * @returns {CompiledMode | never}\n+     *\/\n+    function compileMode(mode, parent) {\n+      const cmode = \/** @type CompiledMode *\/ (mode);\n+      if (mode.isCompiled) return cmode;\n+\n+      [\n+        scopeClassName,\n+        \/\/ do this early so compiler extensions generally don't have to worry about\n+        \/\/ the distinction between match\/begin\n+        compileMatch,\n+        MultiClass,\n+        beforeMatchExt\n+      ].forEach(ext => ext(mode, parent));\n+\n+      language.compilerExtensions.forEach(ext => ext(mode, parent));\n+\n+      \/\/ __beforeBegin is considered private API, internal use only\n+      mode.__beforeBegin = null;\n+\n+      [\n+        beginKeywords,\n+        \/\/ do this later so compiler extensions that come earlier have access to the\n+        \/\/ raw array if they wanted to perhaps manipulate it, etc.\n+        compileIllegal,\n+        \/\/ default to 1 relevance if not specified\n+        compileRelevance\n+      ].forEach(ext => ext(mode, parent));\n+\n+      mode.isCompiled = true;\n+\n+      let keywordPattern = null;\n+      if (typeof mode.keywords === \"object\" && mode.keywords.$pattern) {\n+        \/\/ we need a copy because keywords might be compiled multiple times\n+        \/\/ so we can't go deleting $pattern from the original on the first\n+        \/\/ pass\n+        mode.keywords = Object.assign({}, mode.keywords);\n+        keywordPattern = mode.keywords.$pattern;\n+        delete mode.keywords.$pattern;\n+      }\n+      keywordPattern = keywordPattern || \/\\w+\/;\n+\n+      if (mode.keywords) {\n+        mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);\n+      }\n+\n+      cmode.keywordPatternRe = langRe(keywordPattern, true);\n+\n+      if (parent) {\n+        if (!mode.begin) mode.begin = \/\\B|\\b\/;\n+        cmode.beginRe = langRe(cmode.begin);\n+        if (!mode.end && !mode.endsWithParent) mode.end = \/\\B|\\b\/;\n+        if (mode.end) cmode.endRe = langRe(cmode.end);\n+        cmode.terminatorEnd = source(cmode.end) || '';\n+        if (mode.endsWithParent && parent.terminatorEnd) {\n+          cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;\n+        }\n+      }\n+      if (mode.illegal) cmode.illegalRe = langRe(\/** @type {RegExp | string} *\/ (mode.illegal));\n+      if (!mode.contains) mode.contains = [];\n+\n+      mode.contains = [].concat(...mode.contains.map(function(c) {\n+        return expandOrCloneMode(c === 'self' ? mode : c);\n+      }));\n+      mode.contains.forEach(function(c) { compileMode(\/** @type Mode *\/ (c), cmode); });\n+\n+      if (mode.starts) {\n+        compileMode(mode.starts, parent);\n+      }\n+\n+      cmode.matcher = buildModeRegex(cmode);\n+      return cmode;\n+    }\n+\n+    if (!language.compilerExtensions) language.compilerExtensions = [];\n+\n+    \/\/ self is not valid at the top-level\n+    if (language.contains && language.contains.includes('self')) {\n+      throw new Error(\"ERR: contains `self` is not supported at the top-level of a language.  See documentation.\");\n+    }\n+\n+    \/\/ we need a null object, which inherit will guarantee\n+    language.classNameAliases = inherit$1(language.classNameAliases || {});\n+\n+    return compileMode(\/** @type Mode *\/ (language));\n+  }\n+\n+  \/**\n+   * Determines if a mode has a dependency on it's parent or not\n+   *\n+   * If a mode does have a parent dependency then often we need to clone it if\n+   * it's used in multiple places so that each copy points to the correct parent,\n+   * where-as modes without a parent can often safely be re-used at the bottom of\n+   * a mode chain.\n+   *\n+   * @param {Mode | null} mode\n+   * @returns {boolean} - is there a dependency on the parent?\n+   * *\/\n+  function dependencyOnParent(mode) {\n+    if (!mode) return false;\n+\n+    return mode.endsWithParent || dependencyOnParent(mode.starts);\n+  }\n+\n+  \/**\n+   * Expands a mode or clones it if necessary\n+   *\n+   * This is necessary for modes with parental dependenceis (see notes on\n+   * `dependencyOnParent`) and for nodes that have `variants` - which must then be\n+   * exploded into their own individual modes at compile time.\n+   *\n+   * @param {Mode} mode\n+   * @returns {Mode | Mode[]}\n+   * *\/\n+  function expandOrCloneMode(mode) {\n+    if (mode.variants && !mode.cachedVariants) {\n+      mode.cachedVariants = mode.variants.map(function(variant) {\n+        return inherit$1(mode, { variants: null }, variant);\n+      });\n+    }\n+\n+    \/\/ EXPAND\n+    \/\/ if we have variants then essentially \"replace\" the mode with the variants\n+    \/\/ this happens in compileMode, where this function is called from\n+    if (mode.cachedVariants) {\n+      return mode.cachedVariants;\n+    }\n+\n+    \/\/ CLONE\n+    \/\/ if we have dependencies on parents then we need a unique\n+    \/\/ instance of ourselves, so we can be reused with many\n+    \/\/ different parents without issue\n+    if (dependencyOnParent(mode)) {\n+      return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });\n+    }\n+\n+    if (Object.isFrozen(mode)) {\n+      return inherit$1(mode);\n+    }\n+\n+    \/\/ no special dependency issues, just return ourselves\n+    return mode;\n+  }\n+\n+  var version = \"11.11.1\";\n+\n+  class HTMLInjectionError extends Error {\n+    constructor(reason, html) {\n+      super(reason);\n+      this.name = \"HTMLInjectionError\";\n+      this.html = html;\n+    }\n+  }\n+\n+  \/*\n+  Syntax highlighting with language autodetection.\n+  https:\/\/highlightjs.org\/\n+  *\/\n+\n+\n+\n+  \/**\n+  @typedef {import('highlight.js').Mode} Mode\n+  @typedef {import('highlight.js').CompiledMode} CompiledMode\n+  @typedef {import('highlight.js').CompiledScope} CompiledScope\n+  @typedef {import('highlight.js').Language} Language\n+  @typedef {import('highlight.js').HLJSApi} HLJSApi\n+  @typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n+  @typedef {import('highlight.js').PluginEvent} PluginEvent\n+  @typedef {import('highlight.js').HLJSOptions} HLJSOptions\n+  @typedef {import('highlight.js').LanguageFn} LanguageFn\n+  @typedef {import('highlight.js').HighlightedHTMLElement} HighlightedHTMLElement\n+  @typedef {import('highlight.js').BeforeHighlightContext} BeforeHighlightContext\n+  @typedef {import('highlight.js\/private').MatchType} MatchType\n+  @typedef {import('highlight.js\/private').KeywordData} KeywordData\n+  @typedef {import('highlight.js\/private').EnhancedMatch} EnhancedMatch\n+  @typedef {import('highlight.js\/private').AnnotatedError} AnnotatedError\n+  @typedef {import('highlight.js').AutoHighlightResult} AutoHighlightResult\n+  @typedef {import('highlight.js').HighlightOptions} HighlightOptions\n+  @typedef {import('highlight.js').HighlightResult} HighlightResult\n+  *\/\n+\n+\n+  const escape = escapeHTML;\n+  const inherit = inherit$1;\n+  const NO_MATCH = Symbol(\"nomatch\");\n+  const MAX_KEYWORD_HITS = 7;\n+\n+  \/**\n+   * @param {any} hljs - object that is extended (legacy)\n+   * @returns {HLJSApi}\n+   *\/\n+  const HLJS = function(hljs) {\n+    \/\/ Global internal variables used within the highlight.js library.\n+    \/** @type {Record<string, Language>} *\/\n+    const languages = Object.create(null);\n+    \/** @type {Record<string, string>} *\/\n+    const aliases = Object.create(null);\n+    \/** @type {HLJSPlugin[]} *\/\n+    const plugins = [];\n+\n+    \/\/ safe\/production mode - swallows more errors, tries to keep running\n+    \/\/ even if a single syntax or parse hits a fatal error\n+    let SAFE_MODE = true;\n+    const LANGUAGE_NOT_FOUND = \"Could not find the language '{}', did you forget to load\/include a language module?\";\n+    \/** @type {Language} *\/\n+    const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };\n+\n+    \/\/ Global options used when within external APIs. This is modified when\n+    \/\/ calling the `hljs.configure` function.\n+    \/** @type HLJSOptions *\/\n+    let options = {\n+      ignoreUnescapedHTML: false,\n+      throwUnescapedHTML: false,\n+      noHighlightRe: \/^(no-?highlight)$\/i,\n+      languageDetectRe: \/\\blang(?:uage)?-([\\w-]+)\\b\/i,\n+      classPrefix: 'hljs-',\n+      cssSelector: 'pre code',\n+      languages: null,\n+      \/\/ beta configuration options, subject to change, welcome to discuss\n+      \/\/ https:\/\/github.com\/highlightjs\/highlight.js\/issues\/1086\n+      __emitter: TokenTreeEmitter\n+    };\n+\n+    \/* Utility functions *\/\n+\n+    \/**\n+     * Tests a language name to see if highlighting should be skipped\n+     * @param {string} languageName\n+     *\/\n+    function shouldNotHighlight(languageName) {\n+      return options.noHighlightRe.test(languageName);\n+    }\n+\n+    \/**\n+     * @param {HighlightedHTMLElement} block - the HTML element to determine language for\n+     *\/\n+    function blockLanguage(block) {\n+      let classes = block.className + ' ';\n+\n+      classes += block.parentNode ? block.parentNode.className : '';\n+\n+      \/\/ language-* takes precedence over non-prefixed class names.\n+      const match = options.languageDetectRe.exec(classes);\n+      if (match) {\n+        const language = getLanguage(match[1]);\n+        if (!language) {\n+          warn(LANGUAGE_NOT_FOUND.replace(\"{}\", match[1]));\n+          warn(\"Falling back to no-highlight mode for this block.\", block);\n+        }\n+        return language ? match[1] : 'no-highlight';\n+      }\n+\n+      return classes\n+        .split(\/\\s+\/)\n+        .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));\n+    }\n+\n+    \/**\n+     * Core highlighting function.\n+     *\n+     * OLD API\n+     * highlight(lang, code, ignoreIllegals, continuation)\n+     *\n+     * NEW API\n+     * highlight(code, {lang, ignoreIllegals})\n+     *\n+     * @param {string} codeOrLanguageName - the language to use for highlighting\n+     * @param {string | HighlightOptions} optionsOrCode - the code to highlight\n+     * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n+     *\n+     * @returns {HighlightResult} Result - an object that represents the result\n+     * @property {string} language - the language name\n+     * @property {number} relevance - the relevance score\n+     * @property {string} value - the highlighted HTML code\n+     * @property {string} code - the original raw code\n+     * @property {CompiledMode} top - top of the current mode stack\n+     * @property {boolean} illegal - indicates whether any illegal matches were found\n+    *\/\n+    function highlight(codeOrLanguageName, optionsOrCode, ignoreIllegals) {\n+      let code = \"\";\n+      let languageName = \"\";\n+      if (typeof optionsOrCode === \"object\") {\n+        code = codeOrLanguageName;\n+        ignoreIllegals = optionsOrCode.ignoreIllegals;\n+        languageName = optionsOrCode.language;\n+      } else {\n+        \/\/ old API\n+        deprecated(\"10.7.0\", \"highlight(lang, code, ...args) has been deprecated.\");\n+        deprecated(\"10.7.0\", \"Please use highlight(code, options) instead.\\nhttps:\/\/github.com\/highlightjs\/highlight.js\/issues\/2277\");\n+        languageName = codeOrLanguageName;\n+        code = optionsOrCode;\n+      }\n+\n+      \/\/ https:\/\/github.com\/highlightjs\/highlight.js\/issues\/3149\n+      \/\/ eslint-disable-next-line no-undefined\n+      if (ignoreIllegals === undefined) { ignoreIllegals = true; }\n+\n+      \/** @type {BeforeHighlightContext} *\/\n+      const context = {\n+        code,\n+        language: languageName\n+      };\n+      \/\/ the plugin can change the desired language or the code to be highlighted\n+      \/\/ just be changing the object it was passed\n+      fire(\"before:highlight\", context);\n+\n+      \/\/ a before plugin can usurp the result completely by providing it's own\n+      \/\/ in which case we don't even need to call highlight\n+      const result = context.result\n+        ? context.result\n+        : _highlight(context.language, context.code, ignoreIllegals);\n+\n+      result.code = context.code;\n+      \/\/ the plugin can change anything in result to suite it\n+      fire(\"after:highlight\", result);\n+\n+      return result;\n+    }\n+\n+    \/**\n+     * private highlight that's used internally and does not fire callbacks\n+     *\n+     * @param {string} languageName - the language to use for highlighting\n+     * @param {string} codeToHighlight - the code to highlight\n+     * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n+     * @param {CompiledMode?} [continuation] - current continuation mode, if any\n+     * @returns {HighlightResult} - result of the highlight operation\n+    *\/\n+    function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {\n+      const keywordHits = Object.create(null);\n+\n+      \/**\n+       * Return keyword data if a match is a keyword\n+       * @param {CompiledMode} mode - current mode\n+       * @param {string} matchText - the textual match\n+       * @returns {KeywordData | false}\n+       *\/\n+      function keywordData(mode, matchText) {\n+        return mode.keywords[matchText];\n+      }\n+\n+      function processKeywords() {\n+        if (!top.keywords) {\n+          emitter.addText(modeBuffer);\n+          return;\n+        }\n+\n+        let lastIndex = 0;\n+        top.keywordPatternRe.lastIndex = 0;\n+        let match = top.keywordPatternRe.exec(modeBuffer);\n+        let buf = \"\";\n+\n+        while (match) {\n+          buf += modeBuffer.substring(lastIndex, match.index);\n+          const word = language.case_insensitive ? match[0].toLowerCase() : match[0];\n+          const data = keywordData(top, word);\n+          if (data) {\n+            const [kind, keywordRelevance] = data;\n+            emitter.addText(buf);\n+            buf = \"\";\n+\n+            keywordHits[word] = (keywordHits[word] || 0) + 1;\n+            if (keywordHits[word] <= MAX_KEYWORD_HITS) relevance += keywordRelevance;\n+            if (kind.startsWith(\"_\")) {\n+              \/\/ _ implied for relevance only, do not highlight\n+              \/\/ by applying a class name\n+              buf += match[0];\n+            } else {\n+              const cssClass = language.classNameAliases[kind] || kind;\n+              emitKeyword(match[0], cssClass);\n+            }\n+          } else {\n+            buf += match[0];\n+          }\n+          lastIndex = top.keywordPatternRe.lastIndex;\n+          match = top.keywordPatternRe.exec(modeBuffer);\n+        }\n+        buf += modeBuffer.substring(lastIndex);\n+        emitter.addText(buf);\n+      }\n+\n+      function processSubLanguage() {\n+        if (modeBuffer === \"\") return;\n+        \/** @type HighlightResult *\/\n+        let result = null;\n+\n+        if (typeof top.subLanguage === 'string') {\n+          if (!languages[top.subLanguage]) {\n+            emitter.addText(modeBuffer);\n+            return;\n+          }\n+          result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);\n+          continuations[top.subLanguage] = \/** @type {CompiledMode} *\/ (result._top);\n+        } else {\n+          result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);\n+        }\n+\n+        \/\/ Counting embedded language score towards the host language may be disabled\n+        \/\/ with zeroing the containing mode relevance. Use case in point is Markdown that\n+        \/\/ allows XML everywhere and makes every XML snippet to have a much larger Markdown\n+        \/\/ score.\n+        if (top.relevance > 0) {\n+          relevance += result.relevance;\n+        }\n+        emitter.__addSublanguage(result._emitter, result.language);\n+      }\n+\n+      function processBuffer() {\n+        if (top.subLanguage != null) {\n+          processSubLanguage();\n+        } else {\n+          processKeywords();\n+        }\n+        modeBuffer = '';\n+      }\n+\n+      \/**\n+       * @param {string} text\n+       * @param {string} scope\n+       *\/\n+      function emitKeyword(keyword, scope) {\n+        if (keyword === \"\") return;\n+\n+        emitter.startScope(scope);\n+        emitter.addText(keyword);\n+        emitter.endScope();\n+      }\n+\n+      \/**\n+       * @param {CompiledScope} scope\n+       * @param {RegExpMatchArray} match\n+       *\/\n+      function emitMultiClass(scope, match) {\n+        let i = 1;\n+        const max = match.length - 1;\n+        while (i <= max) {\n+          if (!scope._emit[i]) { i++; continue; }\n+          const klass = language.classNameAliases[scope[i]] || scope[i];\n+          const text = match[i];\n+          if (klass) {\n+            emitKeyword(text, klass);\n+          } else {\n+            modeBuffer = text;\n+            processKeywords();\n+            modeBuffer = \"\";\n+          }\n+          i++;\n+        }\n+      }\n+\n+      \/**\n+       * @param {CompiledMode} mode - new mode to start\n+       * @param {RegExpMatchArray} match\n+       *\/\n+      function startNewMode(mode, match) {\n+        if (mode.scope && typeof mode.scope === \"string\") {\n+          emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);\n+        }\n+        if (mode.beginScope) {\n+          \/\/ beginScope just wraps the begin match itself in a scope\n+          if (mode.beginScope._wrap) {\n+            emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);\n+            modeBuffer = \"\";\n+          } else if (mode.beginScope._multi) {\n+            \/\/ at this point modeBuffer should just be the match\n+            emitMultiClass(mode.beginScope, match);\n+            modeBuffer = \"\";\n+          }\n+        }\n+\n+        top = Object.create(mode, { parent: { value: top } });\n+        return top;\n+      }\n+\n+      \/**\n+       * @param {CompiledMode } mode - the mode to potentially end\n+       * @param {RegExpMatchArray} match - the latest match\n+       * @param {string} matchPlusRemainder - match plus remainder of content\n+       * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode\n+       *\/\n+      function endOfMode(mode, match, matchPlusRemainder) {\n+        let matched = startsWith(mode.endRe, matchPlusRemainder);\n+\n+        if (matched) {\n+          if (mode[\"on:end\"]) {\n+            const resp = new Response(mode);\n+            mode[\"on:end\"](match, resp);\n+            if (resp.isMatchIgnored) matched = false;\n+          }\n+\n+          if (matched) {\n+            while (mode.endsParent && mode.parent) {\n+              mode = mode.parent;\n+            }\n+            return mode;\n+          }\n+        }\n+        \/\/ even if on:end fires an `ignore` it's still possible\n+        \/\/ that we might trigger the end node because of a parent mode\n+        if (mode.endsWithParent) {\n+          return endOfMode(mode.parent, match, matchPlusRemainder);\n+        }\n+      }\n+\n+      \/**\n+       * Handle matching but then ignoring a sequence of text\n+       *\n+       * @param {string} lexeme - string containing full match text\n+       *\/\n+      function doIgnore(lexeme) {\n+        if (top.matcher.regexIndex === 0) {\n+          \/\/ no more regexes to potentially match here, so we move the cursor forward one\n+          \/\/ space\n+          modeBuffer += lexeme[0];\n+          return 1;\n+        } else {\n+          \/\/ no need to move the cursor, we still have additional regexes to try and\n+          \/\/ match at this very spot\n+          resumeScanAtSamePosition = true;\n+          return 0;\n+        }\n+      }\n+\n+      \/**\n+       * Handle the start of a new potential mode match\n+       *\n+       * @param {EnhancedMatch} match - the current match\n+       * @returns {number} how far to advance the parse cursor\n+       *\/\n+      function doBeginMatch(match) {\n+        const lexeme = match[0];\n+        const newMode = match.rule;\n+\n+        const resp = new Response(newMode);\n+        \/\/ first internal before callbacks, then the public ones\n+        const beforeCallbacks = [newMode.__beforeBegin, newMode[\"on:begin\"]];\n+        for (const cb of beforeCallbacks) {\n+          if (!cb) continue;\n+          cb(match, resp);\n+          if (resp.isMatchIgnored) return doIgnore(lexeme);\n+        }\n+\n+        if (newMode.skip) {\n+          modeBuffer += lexeme;\n+        } else {\n+          if (newMode.excludeBegin) {\n+            modeBuffer += lexeme;\n+          }\n+          processBuffer();\n+          if (!newMode.returnBegin && !newMode.excludeBegin) {\n+            modeBuffer = lexeme;\n+          }\n+        }\n+        startNewMode(newMode, match);\n+        return newMode.returnBegin ? 0 : lexeme.length;\n+      }\n+\n+      \/**\n+       * Handle the potential end of mode\n+       *\n+       * @param {RegExpMatchArray} match - the current match\n+       *\/\n+      function doEndMatch(match) {\n+        const lexeme = match[0];\n+        const matchPlusRemainder = codeToHighlight.substring(match.index);\n+\n+        const endMode = endOfMode(top, match, matchPlusRemainder);\n+        if (!endMode) { return NO_MATCH; }\n+\n+        const origin = top;\n+        if (top.endScope && top.endScope._wrap) {\n+          processBuffer();\n+          emitKeyword(lexeme, top.endScope._wrap);\n+        } else if (top.endScope && top.endScope._multi) {\n+          processBuffer();\n+          emitMultiClass(top.endScope, match);\n+        } else if (origin.skip) {\n+          modeBuffer += lexeme;\n+        } else {\n+          if (!(origin.returnEnd || origin.excludeEnd)) {\n+            modeBuffer += lexeme;\n+          }\n+          processBuffer();\n+          if (origin.excludeEnd) {\n+            modeBuffer = lexeme;\n+          }\n+        }\n+        do {\n+          if (top.scope) {\n+            emitter.closeNode();\n+          }\n+          if (!top.skip && !top.subLanguage) {\n+            relevance += top.relevance;\n+          }\n+          top = top.parent;\n+        } while (top !== endMode.parent);\n+        if (endMode.starts) {\n+          startNewMode(endMode.starts, match);\n+        }\n+        return origin.returnEnd ? 0 : lexeme.length;\n+      }\n+\n+      function processContinuations() {\n+        const list = [];\n+        for (let current = top; current !== language; current = current.parent) {\n+          if (current.scope) {\n+            list.unshift(current.scope);\n+          }\n+        }\n+        list.forEach(item => emitter.openNode(item));\n+      }\n+\n+      \/** @type {{type?: MatchType, index?: number, rule?: Mode}}} *\/\n+      let lastMatch = {};\n+\n+      \/**\n+       *  Process an individual match\n+       *\n+       * @param {string} textBeforeMatch - text preceding the match (since the last match)\n+       * @param {EnhancedMatch} [match] - the match itself\n+       *\/\n+      function processLexeme(textBeforeMatch, match) {\n+        const lexeme = match && match[0];\n+\n+        \/\/ add non-matched text to the current mode buffer\n+        modeBuffer += textBeforeMatch;\n+\n+        if (lexeme == null) {\n+          processBuffer();\n+          return 0;\n+        }\n+\n+        \/\/ we've found a 0 width match and we're stuck, so we need to advance\n+        \/\/ this happens when we have badly behaved rules that have optional matchers to the degree that\n+        \/\/ sometimes they can end up matching nothing at all\n+        \/\/ Ref: https:\/\/github.com\/highlightjs\/highlight.js\/issues\/2140\n+        if (lastMatch.type === \"begin\" && match.type === \"end\" && lastMatch.index === match.index && lexeme === \"\") {\n+          \/\/ spit the \"skipped\" character that our regex choked on back into the output sequence\n+          modeBuffer += codeToHighlight.slice(match.index, match.index + 1);\n+          if (!SAFE_MODE) {\n+            \/** @type {AnnotatedError} *\/\n+            const err = new Error(`0 width match regex (${languageName})`);\n+            err.languageName = languageName;\n+            err.badRule = lastMatch.rule;\n+            throw err;\n+          }\n+          return 1;\n+        }\n+        lastMatch = match;\n+\n+        if (match.type === \"begin\") {\n+          return doBeginMatch(match);\n+        } else if (match.type === \"illegal\" && !ignoreIllegals) {\n+          \/\/ illegal match, we do not continue processing\n+          \/** @type {AnnotatedError} *\/\n+          const err = new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.scope || '<unnamed>') + '\"');\n+          err.mode = top;\n+          throw err;\n+        } else if (match.type === \"end\") {\n+          const processed = doEndMatch(match);\n+          if (processed !== NO_MATCH) {\n+            return processed;\n+          }\n+        }\n+\n+        \/\/ edge case for when illegal matches $ (end of line) which is technically\n+        \/\/ a 0 width match but not a begin\/end match so it's not caught by the\n+        \/\/ first handler (when ignoreIllegals is true)\n+        if (match.type === \"illegal\" && lexeme === \"\") {\n+          \/\/ advance so we aren't stuck in an infinite loop\n+          modeBuffer += \"\\n\";\n+          return 1;\n+        }\n+\n+        \/\/ infinite loops are BAD, this is a last ditch catch all. if we have a\n+        \/\/ decent number of iterations yet our index (cursor position in our\n+        \/\/ parsing) still 3x behind our index then something is very wrong\n+        \/\/ so we bail\n+        if (iterations > 100000 && iterations > match.index * 3) {\n+          const err = new Error('potential infinite loop, way more iterations than matches');\n+          throw err;\n+        }\n+\n+        \/*\n+        Why might be find ourselves here?  An potential end match that was\n+        triggered but could not be completed.  IE, `doEndMatch` returned NO_MATCH.\n+        (this could be because a callback requests the match be ignored, etc)\n+\n+        This causes no real harm other than stopping a few times too many.\n+        *\/\n+\n+        modeBuffer += lexeme;\n+        return lexeme.length;\n+      }\n+\n+      const language = getLanguage(languageName);\n+      if (!language) {\n+        error(LANGUAGE_NOT_FOUND.replace(\"{}\", languageName));\n+        throw new Error('Unknown language: \"' + languageName + '\"');\n+      }\n+\n+      const md = compileLanguage(language);\n+      let result = '';\n+      \/** @type {CompiledMode} *\/\n+      let top = continuation || md;\n+      \/** @type Record<string,CompiledMode> *\/\n+      const continuations = {}; \/\/ keep continuations for sub-languages\n+      const emitter = new options.__emitter(options);\n+      processContinuations();\n+      let modeBuffer = '';\n+      let relevance = 0;\n+      let index = 0;\n+      let iterations = 0;\n+      let resumeScanAtSamePosition = false;\n+\n+      try {\n+        if (!language.__emitTokens) {\n+          top.matcher.considerAll();\n+\n+          for (;;) {\n+            iterations++;\n+            if (resumeScanAtSamePosition) {\n+              \/\/ only regexes not matched previously will now be\n+              \/\/ considered for a potential match\n+              resumeScanAtSamePosition = false;\n+            } else {\n+              top.matcher.considerAll();\n+            }\n+            top.matcher.lastIndex = index;\n+\n+            const match = top.matcher.exec(codeToHighlight);\n+            \/\/ console.log(\"match\", match[0], match.rule && match.rule.begin)\n+\n+            if (!match) break;\n+\n+            const beforeMatch = codeToHighlight.substring(index, match.index);\n+            const processedCount = processLexeme(beforeMatch, match);\n+            index = match.index + processedCount;\n+          }\n+          processLexeme(codeToHighlight.substring(index));\n+        } else {\n+          language.__emitTokens(codeToHighlight, emitter);\n+        }\n+\n+        emitter.finalize();\n+        result = emitter.toHTML();\n+\n+        return {\n+          language: languageName,\n+          value: result,\n+          relevance,\n+          illegal: false,\n+          _emitter: emitter,\n+          _top: top\n+        };\n+      } catch (err) {\n+        if (err.message && err.message.includes('Illegal')) {\n+          return {\n+            language: languageName,\n+            value: escape(codeToHighlight),\n+            illegal: true,\n+            relevance: 0,\n+            _illegalBy: {\n+              message: err.message,\n+              index,\n+              context: codeToHighlight.slice(index - 100, index + 100),\n+              mode: err.mode,\n+              resultSoFar: result\n+            },\n+            _emitter: emitter\n+          };\n+        } else if (SAFE_MODE) {\n+          return {\n+            language: languageName,\n+            value: escape(codeToHighlight),\n+            illegal: false,\n+            relevance: 0,\n+            errorRaised: err,\n+            _emitter: emitter,\n+            _top: top\n+          };\n+        } else {\n+          throw err;\n+        }\n+      }\n+    }\n+\n+    \/**\n+     * returns a valid highlight result, without actually doing any actual work,\n+     * auto highlight starts with this and it's possible for small snippets that\n+     * auto-detection may not find a better match\n+     * @param {string} code\n+     * @returns {HighlightResult}\n+     *\/\n+    function justTextHighlightResult(code) {\n+      const result = {\n+        value: escape(code),\n+        illegal: false,\n+        relevance: 0,\n+        _top: PLAINTEXT_LANGUAGE,\n+        _emitter: new options.__emitter(options)\n+      };\n+      result._emitter.addText(code);\n+      return result;\n+    }\n+\n+    \/**\n+    Highlighting with language detection. Accepts a string with the code to\n+    highlight. Returns an object with the following properties:\n+\n+    - language (detected language)\n+    - relevance (int)\n+    - value (an HTML string with highlighting markup)\n+    - secondBest (object with the same structure for second-best heuristically\n+      detected language, may be absent)\n+\n+      @param {string} code\n+      @param {Array<string>} [languageSubset]\n+      @returns {AutoHighlightResult}\n+    *\/\n+    function highlightAuto(code, languageSubset) {\n+      languageSubset = languageSubset || options.languages || Object.keys(languages);\n+      const plaintext = justTextHighlightResult(code);\n+\n+      const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>\n+        _highlight(name, code, false)\n+      );\n+      results.unshift(plaintext); \/\/ plaintext is always an option\n+\n+      const sorted = results.sort((a, b) => {\n+        \/\/ sort base on relevance\n+        if (a.relevance !== b.relevance) return b.relevance - a.relevance;\n+\n+        \/\/ always award the tie to the base language\n+        \/\/ ie if C++ and Arduino are tied, it's more likely to be C++\n+        if (a.language && b.language) {\n+          if (getLanguage(a.language).supersetOf === b.language) {\n+            return 1;\n+          } else if (getLanguage(b.language).supersetOf === a.language) {\n+            return -1;\n+          }\n+        }\n+\n+        \/\/ otherwise say they are equal, which has the effect of sorting on\n+        \/\/ relevance while preserving the original ordering - which is how ties\n+        \/\/ have historically been settled, ie the language that comes first always\n+        \/\/ wins in the case of a tie\n+        return 0;\n+      });\n+\n+      const [best, secondBest] = sorted;\n+\n+      \/** @type {AutoHighlightResult} *\/\n+      const result = best;\n+      result.secondBest = secondBest;\n+\n+      return result;\n+    }\n+\n+    \/**\n+     * Builds new class name for block given the language name\n+     *\n+     * @param {HTMLElement} element\n+     * @param {string} [currentLang]\n+     * @param {string} [resultLang]\n+     *\/\n+    function updateClassName(element, currentLang, resultLang) {\n+      const language = (currentLang && aliases[currentLang]) || resultLang;\n+\n+      element.classList.add(\"hljs\");\n+      element.classList.add(`language-${language}`);\n+    }\n+\n+    \/**\n+     * Applies highlighting to a DOM node containing code.\n+     *\n+     * @param {HighlightedHTMLElement} element - the HTML element to highlight\n+    *\/\n+    function highlightElement(element) {\n+      \/** @type HTMLElement *\/\n+      let node = null;\n+      const language = blockLanguage(element);\n+\n+      if (shouldNotHighlight(language)) return;\n+\n+      fire(\"before:highlightElement\",\n+        { el: element, language });\n+\n+      if (element.dataset.highlighted) {\n+        console.log(\"Element previously highlighted. To highlight again, first unset `dataset.highlighted`.\", element);\n+        return;\n+      }\n+\n+      \/\/ we should be all text, no child nodes (unescaped HTML) - this is possibly\n+      \/\/ an HTML injection attack - it's likely too late if this is already in\n+      \/\/ production (the code has likely already done its damage by the time\n+      \/\/ we're seeing it)... but we yell loudly about this so that hopefully it's\n+      \/\/ more likely to be caught in development before making it to production\n+      if (element.children.length > 0) {\n+        if (!options.ignoreUnescapedHTML) {\n+          console.warn(\"One of your code blocks includes unescaped HTML. This is a potentially serious security risk.\");\n+          console.warn(\"https:\/\/github.com\/highlightjs\/highlight.js\/wiki\/security\");\n+          console.warn(\"The element with unescaped HTML:\");\n+          console.warn(element);\n+        }\n+        if (options.throwUnescapedHTML) {\n+          const err = new HTMLInjectionError(\n+            \"One of your code blocks includes unescaped HTML.\",\n+            element.innerHTML\n+          );\n+          throw err;\n+        }\n+      }\n+\n+      node = element;\n+      const text = node.textContent;\n+      const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);\n+\n+      element.innerHTML = result.value;\n+      element.dataset.highlighted = \"yes\";\n+      updateClassName(element, language, result.language);\n+      element.result = {\n+        language: result.language,\n+        \/\/ TODO: remove with version 11.0\n+        re: result.relevance,\n+        relevance: result.relevance\n+      };\n+      if (result.secondBest) {\n+        element.secondBest = {\n+          language: result.secondBest.language,\n+          relevance: result.secondBest.relevance\n+        };\n+      }\n+\n+      fire(\"after:highlightElement\", { el: element, result, text });\n+    }\n+\n+    \/**\n+     * Updates highlight.js global options with the passed options\n+     *\n+     * @param {Partial<HLJSOptions>} userOptions\n+     *\/\n+    function configure(userOptions) {\n+      options = inherit(options, userOptions);\n+    }\n+\n+    \/\/ TODO: remove v12, deprecated\n+    const initHighlighting = () => {\n+      highlightAll();\n+      deprecated(\"10.6.0\", \"initHighlighting() deprecated.  Use highlightAll() now.\");\n+    };\n+\n+    \/\/ TODO: remove v12, deprecated\n+    function initHighlightingOnLoad() {\n+      highlightAll();\n+      deprecated(\"10.6.0\", \"initHighlightingOnLoad() deprecated.  Use highlightAll() now.\");\n+    }\n+\n+    let wantsHighlight = false;\n+\n+    \/**\n+     * auto-highlights all pre>code elements on the page\n+     *\/\n+    function highlightAll() {\n+      function boot() {\n+        \/\/ if a highlight was requested before DOM was loaded, do now\n+        highlightAll();\n+      }\n+\n+      \/\/ if we are called too early in the loading process\n+      if (document.readyState === \"loading\") {\n+        \/\/ make sure the event listener is only added once\n+        if (!wantsHighlight) {\n+          window.addEventListener('DOMContentLoaded', boot, false);\n+        }\n+        wantsHighlight = true;\n+        return;\n+      }\n+\n+      const blocks = document.querySelectorAll(options.cssSelector);\n+      blocks.forEach(highlightElement);\n+    }\n+\n+    \/**\n+     * Register a language grammar module\n+     *\n+     * @param {string} languageName\n+     * @param {LanguageFn} languageDefinition\n+     *\/\n+    function registerLanguage(languageName, languageDefinition) {\n+      let lang = null;\n+      try {\n+        lang = languageDefinition(hljs);\n+      } catch (error$1) {\n+        error(\"Language definition for '{}' could not be registered.\".replace(\"{}\", languageName));\n+        \/\/ hard or soft error\n+        if (!SAFE_MODE) { throw error$1; } else { error(error$1); }\n+        \/\/ languages that have serious errors are replaced with essentially a\n+        \/\/ \"plaintext\" stand-in so that the code blocks will still get normal\n+        \/\/ css classes applied to them - and one bad language won't break the\n+        \/\/ entire highlighter\n+        lang = PLAINTEXT_LANGUAGE;\n+      }\n+      \/\/ give it a temporary name if it doesn't have one in the meta-data\n+      if (!lang.name) lang.name = languageName;\n+      languages[languageName] = lang;\n+      lang.rawDefinition = languageDefinition.bind(null, hljs);\n+\n+      if (lang.aliases) {\n+        registerAliases(lang.aliases, { languageName });\n+      }\n+    }\n+\n+    \/**\n+     * Remove a language grammar module\n+     *\n+     * @param {string} languageName\n+     *\/\n+    function unregisterLanguage(languageName) {\n+      delete languages[languageName];\n+      for (const alias of Object.keys(aliases)) {\n+        if (aliases[alias] === languageName) {\n+          delete aliases[alias];\n+        }\n+      }\n+    }\n+\n+    \/**\n+     * @returns {string[]} List of language internal names\n+     *\/\n+    function listLanguages() {\n+      return Object.keys(languages);\n+    }\n+\n+    \/**\n+     * @param {string} name - name of the language to retrieve\n+     * @returns {Language | undefined}\n+     *\/\n+    function getLanguage(name) {\n+      name = (name || '').toLowerCase();\n+      return languages[name] || languages[aliases[name]];\n+    }\n+\n+    \/**\n+     *\n+     * @param {string|string[]} aliasList - single alias or list of aliases\n+     * @param {{languageName: string}} opts\n+     *\/\n+    function registerAliases(aliasList, { languageName }) {\n+      if (typeof aliasList === 'string') {\n+        aliasList = [aliasList];\n+      }\n+      aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });\n+    }\n+\n+    \/**\n+     * Determines if a given language has auto-detection enabled\n+     * @param {string} name - name of the language\n+     *\/\n+    function autoDetection(name) {\n+      const lang = getLanguage(name);\n+      return lang && !lang.disableAutodetect;\n+    }\n+\n+    \/**\n+     * Upgrades the old highlightBlock plugins to the new\n+     * highlightElement API\n+     * @param {HLJSPlugin} plugin\n+     *\/\n+    function upgradePluginAPI(plugin) {\n+      \/\/ TODO: remove with v12\n+      if (plugin[\"before:highlightBlock\"] && !plugin[\"before:highlightElement\"]) {\n+        plugin[\"before:highlightElement\"] = (data) => {\n+          plugin[\"before:highlightBlock\"](\n+            Object.assign({ block: data.el }, data)\n+          );\n+        };\n+      }\n+      if (plugin[\"after:highlightBlock\"] && !plugin[\"after:highlightElement\"]) {\n+        plugin[\"after:highlightElement\"] = (data) => {\n+          plugin[\"after:highlightBlock\"](\n+            Object.assign({ block: data.el }, data)\n+          );\n+        };\n+      }\n+    }\n+\n+    \/**\n+     * @param {HLJSPlugin} plugin\n+     *\/\n+    function addPlugin(plugin) {\n+      upgradePluginAPI(plugin);\n+      plugins.push(plugin);\n+    }\n+\n+    \/**\n+     * @param {HLJSPlugin} plugin\n+     *\/\n+    function removePlugin(plugin) {\n+      const index = plugins.indexOf(plugin);\n+      if (index !== -1) {\n+        plugins.splice(index, 1);\n+      }\n+    }\n+\n+    \/**\n+     *\n+     * @param {PluginEvent} event\n+     * @param {any} args\n+     *\/\n+    function fire(event, args) {\n+      const cb = event;\n+      plugins.forEach(function(plugin) {\n+        if (plugin[cb]) {\n+          plugin[cb](args);\n+        }\n+      });\n+    }\n+\n+    \/**\n+     * DEPRECATED\n+     * @param {HighlightedHTMLElement} el\n+     *\/\n+    function deprecateHighlightBlock(el) {\n+      deprecated(\"10.7.0\", \"highlightBlock will be removed entirely in v12.0\");\n+      deprecated(\"10.7.0\", \"Please use highlightElement now.\");\n+\n+      return highlightElement(el);\n+    }\n+\n+    \/* Interface definition *\/\n+    Object.assign(hljs, {\n+      highlight,\n+      highlightAuto,\n+      highlightAll,\n+      highlightElement,\n+      \/\/ TODO: Remove with v12 API\n+      highlightBlock: deprecateHighlightBlock,\n+      configure,\n+      initHighlighting,\n+      initHighlightingOnLoad,\n+      registerLanguage,\n+      unregisterLanguage,\n+      listLanguages,\n+      getLanguage,\n+      registerAliases,\n+      autoDetection,\n+      inherit,\n+      addPlugin,\n+      removePlugin\n+    });\n+\n+    hljs.debugMode = function() { SAFE_MODE = false; };\n+    hljs.safeMode = function() { SAFE_MODE = true; };\n+    hljs.versionString = version;\n+\n+    hljs.regex = {\n+      concat: concat,\n+      lookahead: lookahead,\n+      either: either,\n+      optional: optional,\n+      anyNumberOfTimes: anyNumberOfTimes\n+    };\n+\n+    for (const key in MODES) {\n+      \/\/ @ts-ignore\n+      if (typeof MODES[key] === \"object\") {\n+        \/\/ @ts-ignore\n+        deepFreeze(MODES[key]);\n+      }\n+    }\n+\n+    \/\/ merge all the modes\/regexes into our main object\n+    Object.assign(hljs, MODES);\n+\n+    return hljs;\n+  };\n+\n+  \/\/ Other names for the variable may break build script\n+  const highlight = HLJS({});\n+\n+  \/\/ returns a new instance of the highlighter to be used for extensions\n+  \/\/ check https:\/\/github.com\/wooorm\/lowlight\/issues\/47\n+  highlight.newInstance = () => HLJS({});\n+\n+  \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se15\/html\/jls-3.html#jls-3.10\n+  var decimalDigits = '[0-9](_*[0-9])*';\n+  var frac = `\\\\.(${decimalDigits})`;\n+  var hexDigits = '[0-9a-fA-F](_*[0-9a-fA-F])*';\n+  var NUMERIC = {\n+    className: 'number',\n+    variants: [\n+      \/\/ DecimalFloatingPointLiteral\n+      \/\/ including ExponentPart\n+      { begin: `(\\\\b(${decimalDigits})((${frac})|\\\\.)?|(${frac}))` +\n+        `[eE][+-]?(${decimalDigits})[fFdD]?\\\\b` },\n+      \/\/ excluding ExponentPart\n+      { begin: `\\\\b(${decimalDigits})((${frac})[fFdD]?\\\\b|\\\\.([fFdD]\\\\b)?)` },\n+      { begin: `(${frac})[fFdD]?\\\\b` },\n+      { begin: `\\\\b(${decimalDigits})[fFdD]\\\\b` },\n+\n+      \/\/ HexadecimalFloatingPointLiteral\n+      { begin: `\\\\b0[xX]((${hexDigits})\\\\.?|(${hexDigits})?\\\\.(${hexDigits}))` +\n+        `[pP][+-]?(${decimalDigits})[fFdD]?\\\\b` },\n+\n+      \/\/ DecimalIntegerLiteral\n+      { begin: '\\\\b(0|[1-9](_*[0-9])*)[lL]?\\\\b' },\n+\n+      \/\/ HexIntegerLiteral\n+      { begin: `\\\\b0[xX](${hexDigits})[lL]?\\\\b` },\n+\n+      \/\/ OctalIntegerLiteral\n+      { begin: '\\\\b0(_*[0-7])*[lL]?\\\\b' },\n+\n+      \/\/ BinaryIntegerLiteral\n+      { begin: '\\\\b0[bB][01](_*[01])*[lL]?\\\\b' },\n+    ],\n+    relevance: 0\n+  };\n+\n+  \/*\n+  Language: Java\n+  Author: Vsevolod Solovyov <vsevolod.solovyov@gmail.com>\n+  Category: common, enterprise\n+  Website: https:\/\/www.java.com\/\n+  *\/\n+\n+\n+  \/**\n+   * Allows recursive regex expressions to a given depth\n+   *\n+   * ie: recurRegex(\"(abc~~~)\", \/~~~\/g, 2) becomes:\n+   * (abc(abc(abc)))\n+   *\n+   * @param {string} re\n+   * @param {RegExp} substitution (should be a g mode regex)\n+   * @param {number} depth\n+   * @returns {string}``\n+   *\/\n+  function recurRegex(re, substitution, depth) {\n+    if (depth === -1) return \"\";\n+\n+    return re.replace(substitution, _ => {\n+      return recurRegex(re, substitution, depth - 1);\n+    });\n+  }\n+\n+  \/** @type LanguageFn *\/\n+  function java(hljs) {\n+    const regex = hljs.regex;\n+    const JAVA_IDENT_RE = '[\\u00C0-\\u02B8a-zA-Z_$][\\u00C0-\\u02B8a-zA-Z_$0-9]*';\n+    const TYPE_ARG_RE = '(?:(?:' + JAVA_IDENT_RE + '~~~)|(?:\\\\?\\\\s+(?:extends|super)\\\\s+' + JAVA_IDENT_RE + '~~~)|(?:\\\\?))';\n+    const GENERIC_RE = recurRegex('(?:<' + TYPE_ARG_RE + '(?:\\\\s*,\\\\s*' + TYPE_ARG_RE + ')*>)?', \/~~~\/g, 2);\n+    const ARRAY_RE = '(?:(?:\\\\[])+)?';\n+    const MAIN_KEYWORDS = [\n+      'synchronized',\n+      'abstract',\n+      'private',\n+      'var',\n+      'static',\n+      'if',\n+      'const ',\n+      'for',\n+      'while',\n+      'strictfp',\n+      'finally',\n+      'protected',\n+      'import',\n+      'native',\n+      'final',\n+      'void',\n+      'enum',\n+      'else',\n+      'break',\n+      'transient',\n+      'catch',\n+      'instanceof',\n+      'volatile',\n+      'case',\n+      'assert',\n+      'package',\n+      'default',\n+      'public',\n+      'try',\n+      'switch',\n+      'continue',\n+      'throws',\n+      'protected',\n+      'public',\n+      'private',\n+      'module',\n+      'requires',\n+      'exports',\n+      'do',\n+      'sealed',\n+      'yield',\n+      'permits',\n+      'goto',\n+      'when'\n+    ];\n+\n+    const BUILT_INS = [\n+      'super',\n+      'this'\n+    ];\n+\n+    const LITERALS = [\n+      'false',\n+      'true',\n+      'null'\n+    ];\n+\n+    const TYPES = [\n+      'char',\n+      'boolean',\n+      'long',\n+      'float',\n+      'int',\n+      'byte',\n+      'short',\n+      'double'\n+    ];\n+\n+    const KEYWORDS = {\n+      keyword: MAIN_KEYWORDS,\n+      literal: LITERALS,\n+      type: TYPES,\n+      built_in: BUILT_INS\n+    };\n+\n+    const ANNOTATION = {\n+      className: 'meta',\n+      begin: '@' + JAVA_IDENT_RE,\n+      contains: [\n+        {\n+          begin: \/\\(\/,\n+          end: \/\\)\/,\n+          contains: [ \"self\" ] \/\/ allow nested () inside our annotation\n+        }\n+      ]\n+    };\n+    const PARAMS = {\n+      className: 'params',\n+      begin: \/\\(\/,\n+      end: \/\\)\/,\n+      keywords: KEYWORDS,\n+      relevance: 0,\n+      contains: [ hljs.C_BLOCK_COMMENT_MODE ],\n+      endsParent: true\n+    };\n+\n+    return {\n+      name: 'Java',\n+      aliases: [ 'jsp' ],\n+      keywords: KEYWORDS,\n+      illegal: \/<\\\/|#\/,\n+      contains: [\n+        hljs.COMMENT(\n+          '\/\\\\*\\\\*',\n+          '\\\\*\/',\n+          {\n+            relevance: 0,\n+            contains: [\n+              {\n+                \/\/ eat up @'s in emails to prevent them to be recognized as doctags\n+                begin: \/\\w+@\/,\n+                relevance: 0\n+              },\n+              {\n+                className: 'doctag',\n+                begin: '@[A-Za-z]+'\n+              }\n+            ]\n+          }\n+        ),\n+        \/\/ relevance boost\n+        {\n+          begin: \/import java\\.[a-z]+\\.\/,\n+          keywords: \"import\",\n+          relevance: 2\n+        },\n+        hljs.C_LINE_COMMENT_MODE,\n+        hljs.C_BLOCK_COMMENT_MODE,\n+        {\n+          begin: \/\"\"\"\/,\n+          end: \/\"\"\"\/,\n+          className: \"string\",\n+          contains: [ hljs.BACKSLASH_ESCAPE ]\n+        },\n+        hljs.APOS_STRING_MODE,\n+        hljs.QUOTE_STRING_MODE,\n+        {\n+          match: [\n+            \/\\b(?:class|interface|enum|extends|implements|new)\/,\n+            \/\\s+\/,\n+            JAVA_IDENT_RE\n+          ],\n+          className: {\n+            1: \"keyword\",\n+            3: \"title.class\"\n+          }\n+        },\n+        {\n+          \/\/ Exceptions for hyphenated keywords\n+          match: \/non-sealed\/,\n+          scope: \"keyword\"\n+        },\n+        {\n+          begin: [\n+            regex.concat(\/(?!else)\/, JAVA_IDENT_RE),\n+            GENERIC_RE,\n+            ARRAY_RE,\n+            \/\\s+\/,\n+            JAVA_IDENT_RE,\n+            \/\\s+\/,\n+            \/=(?!=)\/\n+          ],\n+          className: {\n+            1: \"type\",\n+            5: \"variable\",\n+            7: \"operator\"\n+          }\n+        },\n+        {\n+          begin: [\n+            \/record\/,\n+            \/\\s+\/,\n+            JAVA_IDENT_RE\n+          ],\n+          className: {\n+            1: \"keyword\",\n+            3: \"title.class\"\n+          },\n+          contains: [\n+            PARAMS,\n+            hljs.C_LINE_COMMENT_MODE,\n+            hljs.C_BLOCK_COMMENT_MODE\n+          ]\n+        },\n+        {\n+          \/\/ Expression keywords prevent 'keyword Name(...)' from being\n+          \/\/ recognized as a function definition\n+          beginKeywords: 'new throw return else',\n+          relevance: 0\n+        },\n+        {\n+          begin: [\n+            '(?:' + JAVA_IDENT_RE + GENERIC_RE + ARRAY_RE + '\\\\s+)',\n+            hljs.UNDERSCORE_IDENT_RE,\n+            \/\\s*(?=\\()\/\n+          ],\n+          className: { 2: \"title.function\" },\n+          keywords: KEYWORDS,\n+          contains: [\n+            {\n+              className: 'params',\n+              begin: \/\\(\/,\n+              end: \/\\)\/,\n+              keywords: KEYWORDS,\n+              relevance: 0,\n+              contains: [\n+                ANNOTATION,\n+                hljs.APOS_STRING_MODE,\n+                hljs.QUOTE_STRING_MODE,\n+                NUMERIC,\n+                hljs.C_BLOCK_COMMENT_MODE\n+              ]\n+            },\n+            hljs.C_LINE_COMMENT_MODE,\n+            hljs.C_BLOCK_COMMENT_MODE\n+          ]\n+        },\n+        NUMERIC,\n+        ANNOTATION\n+      ]\n+    };\n+  }\n+\n+  \/*\n+  Language: .properties\n+  Contributors: Valentin Aitken <valentin@nalisbg.com>, Egor Rogov <e.rogov@postgrespro.ru>\n+  Website: https:\/\/en.wikipedia.org\/wiki\/.properties\n+  Category: config\n+  *\/\n+\n+  \/** @type LanguageFn *\/\n+  function properties(hljs) {\n+    \/\/ whitespaces: space, tab, formfeed\n+    const WS0 = '[ \\\\t\\\\f]*';\n+    const WS1 = '[ \\\\t\\\\f]+';\n+    \/\/ delimiter\n+    const EQUAL_DELIM = WS0 + '[:=]' + WS0;\n+    const WS_DELIM = WS1;\n+    const DELIM = '(' + EQUAL_DELIM + '|' + WS_DELIM + ')';\n+    const KEY = '([^\\\\\\\\:= \\\\t\\\\f\\\\n]|\\\\\\\\.)+';\n+\n+    const DELIM_AND_VALUE = {\n+      \/\/ skip DELIM\n+      end: DELIM,\n+      relevance: 0,\n+      starts: {\n+        \/\/ value: everything until end of line (again, taking into account backslashes)\n+        className: 'string',\n+        end: \/$\/,\n+        relevance: 0,\n+        contains: [\n+          { begin: '\\\\\\\\\\\\\\\\' },\n+          { begin: '\\\\\\\\\\\\n' }\n+        ]\n+      }\n+    };\n+\n+    return {\n+      name: '.properties',\n+      disableAutodetect: true,\n+      case_insensitive: true,\n+      illegal: \/\\S\/,\n+      contains: [\n+        hljs.COMMENT('^\\\\s*[!#]', '$'),\n+        \/\/ key: everything until whitespace or = or : (taking into account backslashes)\n+        \/\/ case of a key-value pair\n+        {\n+          returnBegin: true,\n+          variants: [\n+            { begin: KEY + EQUAL_DELIM },\n+            { begin: KEY + WS_DELIM }\n+          ],\n+          contains: [\n+            {\n+              className: 'attr',\n+              begin: KEY,\n+              endsParent: true\n+            }\n+          ],\n+          starts: DELIM_AND_VALUE\n+        },\n+        \/\/ case of an empty key\n+        {\n+          className: 'attr',\n+          begin: KEY + WS0 + '$'\n+        }\n+      ]\n+    };\n+  }\n+\n+  \/*\n+  Language: HTML, XML\n+  Website: https:\/\/www.w3.org\/XML\/\n+  Category: common, web\n+  Audit: 2020\n+  *\/\n+\n+  \/** @type LanguageFn *\/\n+  function xml(hljs) {\n+    const regex = hljs.regex;\n+    \/\/ XML names can have the following additional letters: https:\/\/www.w3.org\/TR\/xml\/#NT-NameChar\n+    \/\/ OTHER_NAME_CHARS = \/[:\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]\/;\n+    \/\/ Element names start with NAME_START_CHAR followed by optional other Unicode letters, ASCII digits, hyphens, underscores, and periods\n+    \/\/ const TAG_NAME_RE = regex.concat(\/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]\/, regex.optional(\/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*:\/), \/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*\/);;\n+    \/\/ const XML_IDENT_RE = \/[A-Z_a-z:\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]+\/;\n+    \/\/ const TAG_NAME_RE = regex.concat(\/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]\/, regex.optional(\/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*:\/), \/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*\/);\n+    \/\/ however, to cater for performance and more Unicode support rely simply on the Unicode letter class\n+    const TAG_NAME_RE = regex.concat(\/[\\p{L}_]\/u, regex.optional(\/[\\p{L}0-9_.-]*:\/u), \/[\\p{L}0-9_.-]*\/u);\n+    const XML_IDENT_RE = \/[\\p{L}0-9._:-]+\/u;\n+    const XML_ENTITIES = {\n+      className: 'symbol',\n+      begin: \/&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;\/\n+    };\n+    const XML_META_KEYWORDS = {\n+      begin: \/\\s\/,\n+      contains: [\n+        {\n+          className: 'keyword',\n+          begin: \/#?[a-z_][a-z1-9_-]+\/,\n+          illegal: \/\\n\/\n+        }\n+      ]\n+    };\n+    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n+      begin: \/\\(\/,\n+      end: \/\\)\/\n+    });\n+    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: 'string' });\n+    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: 'string' });\n+    const TAG_INTERNALS = {\n+      endsWithParent: true,\n+      illegal: \/<\/,\n+      relevance: 0,\n+      contains: [\n+        {\n+          className: 'attr',\n+          begin: XML_IDENT_RE,\n+          relevance: 0\n+        },\n+        {\n+          begin: \/=\\s*\/,\n+          relevance: 0,\n+          contains: [\n+            {\n+              className: 'string',\n+              endsParent: true,\n+              variants: [\n+                {\n+                  begin: \/\"\/,\n+                  end: \/\"\/,\n+                  contains: [ XML_ENTITIES ]\n+                },\n+                {\n+                  begin: \/'\/,\n+                  end: \/'\/,\n+                  contains: [ XML_ENTITIES ]\n+                },\n+                { begin: \/[^\\s\"'=<>`]+\/ }\n+              ]\n+            }\n+          ]\n+        }\n+      ]\n+    };\n+    return {\n+      name: 'HTML, XML',\n+      aliases: [\n+        'html',\n+        'xhtml',\n+        'rss',\n+        'atom',\n+        'xjb',\n+        'xsd',\n+        'xsl',\n+        'plist',\n+        'wsf',\n+        'svg'\n+      ],\n+      case_insensitive: true,\n+      unicodeRegex: true,\n+      contains: [\n+        {\n+          className: 'meta',\n+          begin: \/<![a-z]\/,\n+          end: \/>\/,\n+          relevance: 10,\n+          contains: [\n+            XML_META_KEYWORDS,\n+            QUOTE_META_STRING_MODE,\n+            APOS_META_STRING_MODE,\n+            XML_META_PAR_KEYWORDS,\n+            {\n+              begin: \/\\[\/,\n+              end: \/\\]\/,\n+              contains: [\n+                {\n+                  className: 'meta',\n+                  begin: \/<![a-z]\/,\n+                  end: \/>\/,\n+                  contains: [\n+                    XML_META_KEYWORDS,\n+                    XML_META_PAR_KEYWORDS,\n+                    QUOTE_META_STRING_MODE,\n+                    APOS_META_STRING_MODE\n+                  ]\n+                }\n+              ]\n+            }\n+          ]\n+        },\n+        hljs.COMMENT(\n+          \/<!--\/,\n+          \/-->\/,\n+          { relevance: 10 }\n+        ),\n+        {\n+          begin: \/<!\\[CDATA\\[\/,\n+          end: \/\\]\\]>\/,\n+          relevance: 10\n+        },\n+        XML_ENTITIES,\n+        \/\/ xml processing instructions\n+        {\n+          className: 'meta',\n+          end: \/\\?>\/,\n+          variants: [\n+            {\n+              begin: \/<\\?xml\/,\n+              relevance: 10,\n+              contains: [\n+                QUOTE_META_STRING_MODE\n+              ]\n+            },\n+            {\n+              begin: \/<\\?[a-z][a-z0-9]+\/,\n+            }\n+          ]\n+\n+        },\n+        {\n+          className: 'tag',\n+          \/*\n+          The lookahead pattern (?=...) ensures that 'begin' only matches\n+          '<style' as a single word, followed by a whitespace or an\n+          ending bracket.\n+          *\/\n+          begin: \/<style(?=\\s|>)\/,\n+          end: \/>\/,\n+          keywords: { name: 'style' },\n+          contains: [ TAG_INTERNALS ],\n+          starts: {\n+            end: \/<\\\/style>\/,\n+            returnEnd: true,\n+            subLanguage: [\n+              'css',\n+              'xml'\n+            ]\n+          }\n+        },\n+        {\n+          className: 'tag',\n+          \/\/ See the comment in the <style tag about the lookahead pattern\n+          begin: \/<script(?=\\s|>)\/,\n+          end: \/>\/,\n+          keywords: { name: 'script' },\n+          contains: [ TAG_INTERNALS ],\n+          starts: {\n+            end: \/<\\\/script>\/,\n+            returnEnd: true,\n+            subLanguage: [\n+              'javascript',\n+              'handlebars',\n+              'xml'\n+            ]\n+          }\n+        },\n+        \/\/ we need this for now for jSX\n+        {\n+          className: 'tag',\n+          begin: \/<>|<\\\/>\/\n+        },\n+        \/\/ open tag\n+        {\n+          className: 'tag',\n+          begin: regex.concat(\n+            \/<\/,\n+            regex.lookahead(regex.concat(\n+              TAG_NAME_RE,\n+              \/\/ <tag\/>\n+              \/\/ <tag>\n+              \/\/ <tag ...\n+              regex.either(\/\\\/>\/, \/>\/, \/\\s\/)\n+            ))\n+          ),\n+          end: \/\\\/?>\/,\n+          contains: [\n+            {\n+              className: 'name',\n+              begin: TAG_NAME_RE,\n+              relevance: 0,\n+              starts: TAG_INTERNALS\n+            }\n+          ]\n+        },\n+        \/\/ close tag\n+        {\n+          className: 'tag',\n+          begin: regex.concat(\n+            \/<\\\/\/,\n+            regex.lookahead(regex.concat(\n+              TAG_NAME_RE, \/>\/\n+            ))\n+          ),\n+          contains: [\n+            {\n+              className: 'name',\n+              begin: TAG_NAME_RE,\n+              relevance: 0\n+            },\n+            {\n+              begin: \/>\/,\n+              relevance: 0,\n+              endsParent: true\n+            }\n+          ]\n+        }\n+      ]\n+    };\n+  }\n+\n+  \/*\n+  Language: JSON\n+  Description: JSON (JavaScript Object Notation) is a lightweight data-interchange format.\n+  Author: Ivan Sagalaev <maniac@softwaremaniacs.org>\n+  Website: http:\/\/www.json.org\n+  Category: common, protocols, web\n+  *\/\n+\n+  function json(hljs) {\n+    const ATTRIBUTE = {\n+      className: 'attr',\n+      begin: \/\"(\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)\/,\n+      relevance: 1.01\n+    };\n+    const PUNCTUATION = {\n+      match: \/[{}[\\],:]\/,\n+      className: \"punctuation\",\n+      relevance: 0\n+    };\n+    const LITERALS = [\n+      \"true\",\n+      \"false\",\n+      \"null\"\n+    ];\n+    \/\/ NOTE: normally we would rely on `keywords` for this but using a mode here allows us\n+    \/\/ - to use the very tight `illegal: \\S` rule later to flag any other character\n+    \/\/ - as illegal indicating that despite looking like JSON we do not truly have\n+    \/\/ - JSON and thus improve false-positively greatly since JSON will try and claim\n+    \/\/ - all sorts of JSON looking stuff\n+    const LITERALS_MODE = {\n+      scope: \"literal\",\n+      beginKeywords: LITERALS.join(\" \"),\n+    };\n+\n+    return {\n+      name: 'JSON',\n+      aliases: ['jsonc'],\n+      keywords:{\n+        literal: LITERALS,\n+      },\n+      contains: [\n+        ATTRIBUTE,\n+        PUNCTUATION,\n+        hljs.QUOTE_STRING_MODE,\n+        LITERALS_MODE,\n+        hljs.C_NUMBER_MODE,\n+        hljs.C_LINE_COMMENT_MODE,\n+        hljs.C_BLOCK_COMMENT_MODE\n+      ],\n+      illegal: '\\\\S'\n+    };\n+  }\n+\n+  var builtIns = \/*#__PURE__*\/Object.freeze({\n+    __proto__: null,\n+    grmr_java: java,\n+    grmr_json: json,\n+    grmr_properties: properties,\n+    grmr_xml: xml\n+  });\n+\n+  const hljs = highlight;\n+\n+  for (const key of Object.keys(builtIns)) {\n+    \/\/ our builtInLanguages Rollup plugin has to use `_` to allow identifiers to be\n+    \/\/ compatible with `export` naming conventions, so we need to convert the\n+    \/\/ identifiers back into the more typical dash style that we use for language\n+    \/\/ naming via the API\n+    const languageName = key.replace(\"grmr_\", \"\").replace(\"_\", \"-\");\n+    hljs.registerLanguage(languageName, builtIns[key]);\n+  }\n+\n+  return hljs;\n+\n+})();\n+if (typeof exports === 'object' && typeof module !== 'undefined') { module.exports = hljs; }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/highlight.js","additions":3278,"deletions":0,"binary":false,"changes":3278,"status":"added"},{"patch":"@@ -24,0 +24,4 @@\n+if (hljs) {\n+    hljs.highlightAll();\n+}\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -738,0 +738,4 @@\n+doclet.usage.syntax-highlight.description=\\\n+    Enable syntax highlighting for code fragments in {@snippet} tags\\n\\\n+    and <pre><code> elements.\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-    --code-font-size: 14px;\n+    --code-font-size: 13.9px;\n@@ -30,1 +30,1 @@\n-    --code-line-height: 1.55;\n+    --code-line-height: 1.6;\n@@ -66,1 +66,1 @@\n-    --snippet-background-color: #f0f0f2;\n+    --snippet-background-color: #f2f2f4;\n@@ -69,1 +69,1 @@\n-    --pre-background-color: #f3f3f5;\n+    --pre-background-color: var(--snippet-background-color);\n@@ -568,3 +568,0 @@\n-div.inheritance {\n-    font-size: 0.99em;\n-}\n@@ -1392,2 +1389,2 @@\n-    top: 2px;\n-    right: 2px;\n+    top: 4px;\n+    right: 1px;\n@@ -1656,1 +1653,1 @@\n-    padding: 10px;\n+    padding: 12px;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,6 @@\n+    \/** The name of the syntax highlighting style sheet. *\/\n+    public static final DocPath HIGHLIGHT_CSS = DocPath.create(\"highlight.css\");\n+\n+    \/** The name of the syntax highlighting script file. *\/\n+    public static final DocPath HIGHLIGHT_JS = DocPath.create(\"highlight.js\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -870,0 +870,17 @@\n+<span id=\"option-syntax-highlight\">`--syntax-highlight`<\/span>\n+:   Enables syntax highlighting for code fragments in `{@snippet}` tags and\n+    `<pre><code>` elements. For snippets, the `lang` attribute is used to\n+    determine the language of code fragments, which defaults to \"java\" for\n+    inline snippets and is derived from the file extension for external\n+    snippets. In HTML `<pre><code>` tags, the `class` attribute can be used\n+    to specify the language of the contained code fragment as shown below:\n+\n+    ```\n+    <pre><code class=\"language-java\">...<\/code><\/pre>\n+    ```\n+\n+    If neither of these attributes is available automatic language detection is\n+    applied. To disable syntax highlighting for a code fragment set the language\n+    to \"text\" using one of the mechanisms described above. The languages and\n+    formats supported by this option are Java, Properties, JSON, HTML and XML.\n+\n","filename":"src\/jdk.javadoc\/share\/man\/javadoc.md","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,12 @@\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.Signature;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.ModuleEntry;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -32,5 +44,3 @@\n-import java.lang.classfile.*;\n-import java.lang.reflect.AccessFlag;\n-import java.lang.classfile.constantpool.*;\n-import java.lang.classfile.attribute.*;\n-import static java.lang.classfile.ClassFile.*;\n+\n+import static java.lang.classfile.ClassFile.ACC_MANDATED;\n+import static java.lang.classfile.ClassFile.ACC_SYNTHETIC;\n@@ -69,2 +79,2 @@\n-    public void write(List<Attribute<?>> attrs) {\n-        write(attrs, null);\n+    public void write(List<Attribute<?>> attrs, ClassFileFormatVersion cffv) {\n+        write(attrs, null, cffv);\n@@ -73,1 +83,1 @@\n-    public void write(List<Attribute<?>> attrs, CodeAttribute lr) {\n+    public void write(List<Attribute<?>> attrs, CodeAttribute lr, ClassFileFormatVersion cffv) {\n@@ -76,1 +86,1 @@\n-                write(attr, lr);\n+                write(attr, lr, cffv);\n@@ -83,1 +93,1 @@\n-    public void write(Attribute<?> a, CodeAttribute lr) {\n+    public void write(Attribute<?> a, CodeAttribute lr, ClassFileFormatVersion cffv) {\n@@ -215,1 +225,1 @@\n-                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS)) {\n+                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS, cffv)) {\n@@ -500,1 +510,1 @@\n-                        write(componentInfo.attributes());\n+                        write(componentInfo.attributes(), cffv);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -47,19 +48,0 @@\n-    private static final Map<AccessFlag.Location, Integer> LOCATION_MASKS;\n-\n-    static {\n-        var map = new EnumMap<AccessFlag.Location, Integer>(AccessFlag.Location.class);\n-        for (var loc : AccessFlag.Location.values()) {\n-            map.put(loc, 0);\n-        }\n-\n-        for (var flag : AccessFlag.values()) {\n-            for (var loc : flag.locations()) {\n-                map.compute(loc, (_, v) -> v | flag.mask());\n-            }\n-        }\n-\n-        \/\/ Peculiarities from AccessFlag.maskToAccessFlag\n-        map.compute(AccessFlag.Location.METHOD, (_, v) -> v | Modifier.STRICT);\n-\n-        LOCATION_MASKS = map;\n-    }\n@@ -75,2 +57,2 @@\n-    protected Set<AccessFlag> flagsReportUnknown(AccessFlags flags) {\n-        return maskToAccessFlagsReportUnknown(flags.flagsMask(), flags.location());\n+    protected Set<AccessFlag> flagsReportUnknown(AccessFlags flags, ClassFileFormatVersion cffv) {\n+        return maskToAccessFlagsReportUnknown(flags.flagsMask(), flags.location(), cffv);\n@@ -79,1 +61,2 @@\n-    protected Set<AccessFlag> maskToAccessFlagsReportUnknown(int mask, AccessFlag.Location location) {\n+    protected Set<AccessFlag> maskToAccessFlagsReportUnknown(int mask, AccessFlag.Location location, ClassFileFormatVersion cffv) {\n+        \/\/ TODO pass cffv to maskToAccessFlags\n@@ -83,1 +66,1 @@\n-            mask &= LOCATION_MASKS.get(location);\n+            mask &= location.flagsMask(cffv);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/BasicWriter.java","additions":7,"deletions":24,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,14 +28,0 @@\n-import java.lang.reflect.AccessFlag;\n-import java.net.URI;\n-import java.text.DateFormat;\n-import java.util.Collection;\n-import java.util.Date;\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Set;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.LinkedHashSet;\n-\n@@ -43,0 +29,1 @@\n+\n@@ -45,2 +32,0 @@\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.ClassSignature;\n@@ -48,1 +33,0 @@\n-import static java.lang.classfile.ClassFile.*;\n@@ -50,1 +34,2 @@\n-import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassSignature;\n@@ -57,0 +42,18 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantValueEntry;\n+import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.ClassFileFormatVersion;\n+import java.lang.reflect.Modifier;\n+import java.net.URI;\n+import java.text.DateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.EnumSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.lang.classfile.ClassFile.*;\n@@ -117,0 +120,10 @@\n+    protected ClassFileFormatVersion cffv() {\n+        var major = classModel.majorVersion();\n+        if (major < JAVA_1_VERSION || major > ClassFile.latestMajorVersion())\n+            return null;\n+        if (major >= JAVA_12_VERSION && classModel.minorVersion() != 0) {\n+            return null;\n+        }\n+        return ClassFileFormatVersion.fromMajor(major);\n+    }\n+\n@@ -254,1 +267,1 @@\n-            attrWriter.write(classModel.attributes());\n+            attrWriter.write(classModel.attributes(), cffv());\n@@ -271,1 +284,1 @@\n-    private static final ClassFile VERIFIER = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(\n+    private static final ClassFile VERIFIER = ClassFile.of(ClassHierarchyResolverOption.of(\n@@ -274,1 +287,1 @@\n-                public ClassHierarchyResolver.ClassHierarchyInfo getClassInfo(ClassDesc classDesc) {\n+                public ClassHierarchyInfo getClassInfo(ClassDesc classDesc) {\n@@ -424,1 +437,1 @@\n-        writeModifiers(flagsReportUnknown(flags).stream().filter(fl -> fl.sourceModifier())\n+        writeModifiers(flagsReportUnknown(flags, cffv()).stream().filter(fl -> fl.sourceModifier())\n@@ -453,1 +466,1 @@\n-                    flagsReportUnknown(flags).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n+                    flagsReportUnknown(flags, cffv()).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n@@ -457,1 +470,1 @@\n-            attrWriter.write(f.attributes());\n+            attrWriter.write(f.attributes(), cffv());\n@@ -485,1 +498,1 @@\n-        for (var f : flagsReportUnknown(m.flags()))\n+        for (var f : flagsReportUnknown(m.flags(), cffv()))\n@@ -568,1 +581,1 @@\n-            for (var f : flagsReportUnknown(m.flags())) {\n+            for (var f : flagsReportUnknown(m.flags(), cffv())) {\n@@ -578,1 +591,1 @@\n-            attrWriter.write(m.attributes());\n+            attrWriter.write(m.attributes(), cffv());\n@@ -791,1 +804,1 @@\n-        var flagSet = flagsReportUnknown(flags);\n+        var flagSet = flagsReportUnknown(flags, cffv());\n@@ -804,1 +817,1 @@\n-        Set<AccessFlag> flagSet = flagsReportUnknown(flags);\n+        Set<AccessFlag> flagSet = flagsReportUnknown(flags, cffv());\n@@ -816,1 +829,1 @@\n-    private static Set<String> getModifiers(Set<java.lang.reflect.AccessFlag> flags) {\n+    private static Set<String> getModifiers(Set<AccessFlag> flags) {\n@@ -824,1 +837,1 @@\n-        return getFlags(flags.flagsMask(), flagsReportUnknown(flags));\n+        return getFlags(flags.flagsMask(), flagsReportUnknown(flags, cffv()));\n@@ -827,1 +840,1 @@\n-    private static Set<String> getFlags(int mask, Set<java.lang.reflect.AccessFlag> flags) {\n+    private static Set<String> getFlags(int mask, Set<AccessFlag> flags) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":46,"deletions":33,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,8 @@\n-import java.lang.classfile.*;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.attribute.CodeAttribute;\n+import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.classfile.instruction.*;\n@@ -31,1 +38,0 @@\n-\n@@ -34,3 +40,0 @@\n-import java.lang.classfile.constantpool.*;\n-import java.lang.classfile.attribute.CodeAttribute;\n-import java.lang.classfile.instruction.*;\n@@ -280,1 +283,1 @@\n-        attrWriter.write(attr.attributes(), attr);\n+        attrWriter.write(attr.attributes(), attr, classWriter.cffv());\n@@ -285,1 +288,1 @@\n-            .ifPresent(a -> attrWriter.write(a, attr));\n+            .ifPresent(a -> attrWriter.write(a, attr, classWriter.cffv()));\n@@ -287,1 +290,1 @@\n-            .ifPresent(a -> attrWriter.write(a, attr));\n+            .ifPresent(a -> attrWriter.write(a, attr, classWriter.cffv()));\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/CodeWriter.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-                upgradeableFiles.add(scanner.nextLine());\n+                upgradeableFiles.add(line);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/LinkableRuntimeImage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n-lib\/tzdb.dat\n@@ -5,0 +4,1 @@\n+lib\/tzdb.dat\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/upgrade_files_java.base.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -497,0 +497,10 @@\n+\n+        PlatformPackage thePackage = createMetaPackage(params);\n+\n+        new ScriptRunner()\n+              .setDirectory(thePackage.sourceRoot())\n+              .setResourceCategoryId(\"resource.post-app-image-script\")\n+              .setScriptNameSuffix(\"post-image\")\n+              .setEnvironmentVariable(\"JpAppImageDir\", thePackage.sourceRoot().toAbsolutePath().toString())\n+              .run(params);\n+\n@@ -502,2 +512,0 @@\n-        PlatformPackage thePackage = createMetaPackage(params);\n-\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -299,0 +299,9 @@\n+        PlatformPackage thePackage = createMetaPackage(params);\n+\n+        new ScriptRunner()\n+                .setDirectory(thePackage.sourceRoot())\n+                .setResourceCategoryId(\"resource.post-app-image-script\")\n+                .setScriptNameSuffix(\"post-image\")\n+                .setEnvironmentVariable(\"JpAppImageDir\", thePackage.sourceRoot().toAbsolutePath().toString())\n+                .run(params);\n+\n@@ -307,2 +316,0 @@\n-        PlatformPackage thePackage = createMetaPackage(params);\n-\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -83,4 +83,6 @@\n-                Path configScript = getConfig_Script(params);\n-                if (IOUtils.exists(configScript)) {\n-                    IOUtils.run(\"bash\", configScript);\n-                }\n+                new ScriptRunner()\n+                        .setDirectory(appLocation)\n+                        .setResourceCategoryId(\"resource.post-app-image-script\")\n+                        .setScriptNameSuffix(\"post-image\")\n+                        .setEnvironmentVariable(\"JpAppImageDir\", appLocation.toAbsolutePath().toString())\n+                        .run(params);\n@@ -200,4 +202,0 @@\n-        createResource(null, params)\n-                .setCategory(I18N.getString(\"resource.post-install-script\"))\n-                .saveToFile(getConfig_Script(params));\n-\n@@ -211,6 +209,0 @@\n-    \/\/ name of post-image script\n-    private Path getConfig_Script(Map<String, ? super Object> params) {\n-        return CONFIG_ROOT.fetchFrom(params).resolve(\n-                APP_NAME.fetchFrom(params) + \"-post-image.sh\");\n-    }\n-\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -57,3 +57,0 @@\n-import static jdk.jpackage.internal.MacBaseInstallerBundler.SIGNING_KEYCHAIN;\n-import static jdk.jpackage.internal.MacBaseInstallerBundler.SIGNING_KEY_USER;\n-import static jdk.jpackage.internal.MacBaseInstallerBundler.INSTALLER_SIGN_IDENTITY;\n@@ -157,0 +154,1 @@\n+                prepareCPLFile(params, appImageDir);\n@@ -158,3 +156,2 @@\n-                Path configScript = getConfig_Script(params);\n-                if (IOUtils.exists(configScript)) {\n-                    IOUtils.run(\"bash\", configScript);\n+                if (withServicesPkg(params)) {\n+                    prepareServicesPkg(params);\n@@ -163,0 +160,11 @@\n+                if (!APP_STORE.fetchFrom(params)) {\n+                    preparePackageScripts(params);\n+                }\n+\n+                new ScriptRunner()\n+                        .setDirectory(appImageDir)\n+                        .setResourceCategoryId(\"resource.post-app-image-script\")\n+                        .setScriptNameSuffix(\"post-image\")\n+                        .setEnvironmentVariable(\"JpAppImageDir\", appImageDir.toAbsolutePath().toString())\n+                        .run(params);\n+\n@@ -363,4 +371,0 @@\n-        createResource(null, params)\n-                .setCategory(I18N.getString(\"resource.post-install-script\"))\n-                .saveToFile(getConfig_Script(params));\n-\n@@ -370,6 +374,0 @@\n-    \/\/ name of post-image script\n-    private Path getConfig_Script(Map<String, ? super Object> params) {\n-        return CONFIG_ROOT.fetchFrom(params).resolve(\n-                APP_NAME.fetchFrom(params) + \"-post-image.sh\");\n-    }\n-\n@@ -467,2 +465,1 @@\n-    private void createServicesPkg(Map<String, Object> params) throws\n-            IOException {\n+    private void prepareServicesPkg(Map<String, Object> params) throws IOException {\n@@ -485,13 +482,1 @@\n-        var pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n-                \"--root\",\n-                srcRoot.toString(),\n-                \"--install-location\",\n-                \"\/\",\n-                \"--scripts\",\n-                scriptsDir.toString(),\n-                \"--identifier\",\n-                getServicesIdentifier(params),\n-                getPackages_ServicesPackage(params).toAbsolutePath().toString());\n-        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-\n-        createSupportPkg(params, data);\n+        prepareSupportPkg(params, data);\n@@ -500,1 +485,1 @@\n-    private void createSupportPkg(Map<String, Object> params,\n+    private void prepareSupportPkg(Map<String, Object> params,\n@@ -521,0 +506,29 @@\n+    }\n+\n+    private void createServicesPkg(Map<String, Object> params) throws\n+            IOException {\n+        Path root = TEMP_ROOT.fetchFrom(params).resolve(\"services\");\n+\n+        Path srcRoot = root.resolve(\"src\");\n+\n+        Path scriptsDir = root.resolve(\"scripts\");\n+\n+        var pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n+                \"--root\",\n+                srcRoot.toString(),\n+                \"--install-location\",\n+                \"\/\",\n+                \"--scripts\",\n+                scriptsDir.toString(),\n+                \"--identifier\",\n+                getServicesIdentifier(params),\n+                getPackages_ServicesPackage(params).toAbsolutePath().toString());\n+        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+\n+        createSupportPkg(params);\n+    }\n+\n+    private void createSupportPkg(Map<String, Object> params) throws IOException {\n+        Path root = TEMP_ROOT.fetchFrom(params).resolve(\"support\");\n+\n+        Path srcRoot = root.resolve(\"src\");\n@@ -533,0 +547,17 @@\n+    private void prepareCPLFile(Map<String, ? super Object> params, Path appLocation) throws IOException {\n+        String root = getRoot(params, appLocation);\n+        \/\/ Generate default CPL file\n+        Path cpl = CONFIG_ROOT.fetchFrom(params).resolve(\"cpl.plist\");\n+        ProcessBuilder pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n+                \"--root\",\n+                root,\n+                \"--install-location\",\n+                getInstallDir(params, false),\n+                \"--analyze\",\n+                cpl.toAbsolutePath().toString());\n+\n+        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+\n+        patchCPLFile(cpl);\n+    }\n+\n@@ -545,11 +576,1 @@\n-            \/\/ Generate default CPL file\n-            Path cpl = CONFIG_ROOT.fetchFrom(params).resolve(\"cpl.plist\");\n-            ProcessBuilder pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n-                    \"--root\",\n-                    root,\n-                    \"--install-location\",\n-                    getInstallDir(params, false),\n-                    \"--analyze\",\n-                    cpl.toAbsolutePath().toString());\n-\n-            IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+            ProcessBuilder pb;\n@@ -557,1 +578,1 @@\n-            patchCPLFile(cpl);\n+            Path cpl = CONFIG_ROOT.fetchFrom(params).resolve(\"cpl.plist\");\n@@ -573,1 +594,0 @@\n-                preparePackageScripts(params);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":65,"deletions":45,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-resource.post-install-script=script to run after application image is populated\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+resource.post-app-image-script=script to run after application image is populated\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -434,8 +434,0 @@\n-\n-            new ScriptRunner()\n-            .setDirectory(imageDir)\n-            .setResourceCategoryId(\"resource.post-app-image-script\")\n-            .setScriptNameSuffix(\"post-image\")\n-            .setEnvironmentVariable(\"JpAppImageDir\", imageDir.toAbsolutePath().toString())\n-            .run(params);\n-\n@@ -603,0 +595,9 @@\n+        final var imageDir = WIN_APP_IMAGE.fetchFrom(params);\n+\n+        new ScriptRunner()\n+                .setDirectory(imageDir)\n+                .setResourceCategoryId(\"resource.post-app-image-script\")\n+                .setScriptNameSuffix(\"post-image\")\n+                .setEnvironmentVariable(\"JpAppImageDir\", imageDir.toAbsolutePath().toString())\n+                .run(params);\n+\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-resource.post-app-image-script=script to run after application image is populated\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -906,3 +906,1 @@\n-            {\"MET\", new String[] {\"Zentraleurop\\u00e4ische Zeit\", \"MET\",\n-                                  \"Zentraleurop\\u00e4ische Sommerzeit\", \"MEST\",\n-                                  \"MET\", \"MET\"}},\n+            {\"MET\", CET},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_de.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -906,3 +906,1 @@\n-            {\"MET\", new String[] {\"Hora de Europa Central\", \"MET\",\n-                                  \"Hora de verano de Europa Central\", \"MEST\",\n-                                  \"MET\", \"MET\"}},\n+            {\"MET\", CET},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_es.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -906,3 +906,1 @@\n-            {\"MET\", new String[] {\"Heure de l'Europe centrale\", \"MET\",\n-                                  \"Heure d'\\u00e9t\\u00e9 de l'Europe centrale\", \"MEST\",\n-                                  \"MET\", \"MET\"}},\n+            {\"MET\", CET},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_fr.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -906,3 +906,1 @@\n-            {\"MET\", new String[] {\"Ora dell'Europa centrale\", \"MET\",\n-                                  \"Ora estiva dell'Europa centrale\", \"MEST\",\n-                                  \"MET\", \"MET\"}},\n+            {\"MET\", CET},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_it.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -906,3 +906,1 @@\n-            {\"MET\", new String[] {\"\\u4e2d\\u90e8\\u30e8\\u30fc\\u30ed\\u30c3\\u30d1\\u6642\\u9593\", \"MET\",\n-                                  \"\\u4e2d\\u90e8\\u30e8\\u30fc\\u30ed\\u30c3\\u30d1\\u590f\\u6642\\u9593\", \"MEST\",\n-                                  \"MET\", \"MET\"}},\n+            {\"MET\", CET},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_ja.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -906,3 +906,1 @@\n-            {\"MET\", new String[] {\"\\uc911\\ubd80 \\uc720\\ub7fd \\uc2dc\\uac04\", \"MET\",\n-                                  \"\\uc911\\ubd80 \\uc720\\ub7fd \\uc77c\\uad11\\uc808\\uc57d\\uc2dc\\uac04\", \"MEST\",\n-                                  \"MET\", \"MET\"}},\n+            {\"MET\", CET},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_ko.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -906,3 +906,1 @@\n-            {\"MET\", new String[] {\"Fuso hor\\u00e1rio da Europa M\\u00e9dia\", \"MET\",\n-                                  \"Fuso hor\\u00e1rio de ver\\u00e3o da Europa M\\u00e9dia\", \"MEST\",\n-                                  \"MET\", \"MET\"}},\n+            {\"MET\", CET},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_pt_BR.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -906,3 +906,1 @@\n-            {\"MET\", new String[] {\"Mellaneuropeisk tid\", \"MET\",\n-                                  \"Mellaneuropeisk sommartid\", \"MEST\",\n-                                  \"MET\", \"MET\"}},\n+            {\"MET\", CET},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_sv.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -906,3 +906,1 @@\n-            {\"MET\", new String[] {\"\\u4e2d\\u6b27\\u65f6\\u95f4\", \"MET\",\n-                                  \"\\u4e2d\\u6b27\\u590f\\u4ee4\\u65f6\", \"MEST\",\n-                                  \"MET\", \"MET\"}},\n+            {\"MET\", CET},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_zh_CN.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -908,3 +908,1 @@\n-            {\"MET\", new String[] {\"\\u4e2d\\u6b50\\u6642\\u9593\", \"MET\",\n-                                  \"\\u4e2d\\u6b50\\u590f\\u4ee4\\u6642\\u9593\", \"MEST\",\n-                                  \"MET\", \"MET\"}},\n+            {\"MET\", CET},\n","filename":"src\/jdk.localedata\/share\/classes\/sun\/util\/resources\/ext\/TimeZoneNames_zh_TW.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -17,4 +17,3 @@\n-        0x7e0, 0xfc0, 0x1f80, 0x3ff0, 0x7e00, 0x7e00,\n-        0x8000, 0x81ff, 0xc1ff, 0xc003, 0xc7ff, 0xdfff,\n-        0xe03f, 0xe10f, 0xe1ff, 0xf801, 0xfc00, 0xfc07,\n-        0xff03, 0xfffe]\n+        0x7e0, 0xfc0, 0x1f80, 0x3ff0, 0x7e00, 0x8000,\n+        0x81ff, 0xc1ff, 0xc003, 0xc7ff, 0xdfff, 0xe03f,\n+        0xe1ff, 0xf801, 0xfc00, 0xfc07, 0xff03, 0xfffe]\n@@ -1068,1 +1067,1 @@\n-        elif (self._name.endswith(\"s\") | self._name.endswith(\"d\")):\n+        elif (self._name.endswith(\"h\") | self._name.endswith(\"s\") | self._name.endswith(\"d\")):\n@@ -1687,1 +1686,4 @@\n-         [[\"fabds\", \"sss\"], [\"fmuls\", \"sss\"], [\"fdivs\", \"sss\"], [\"fadds\", \"sss\"], [\"fsubs\", \"sss\"],\n+         [[\"fabdh\", \"hhh\"], [\"fmulh\", \"hhh\"], [\"fdivh\", \"hhh\"], [\"faddh\", \"hhh\"], [\"fsubh\", \"hhh\"],\n+          [\"fmaxh\", \"hhh\"], [\"fminh\", \"hhh\"], [\"fnmulh\", \"hhh\"],\n+          [\"fabds\", \"sss\"], [\"fmuls\", \"sss\"], [\"fdivs\", \"sss\"], [\"fadds\", \"sss\"], [\"fsubs\", \"sss\"],\n+          [\"fmaxs\", \"sss\"], [\"fmins\", \"sss\"], [\"fnmuls\", \"sss\"],\n@@ -1689,0 +1691,1 @@\n+          [\"fmaxd\", \"ddd\"], [\"fmind\", \"ddd\"], [\"fnmuld\", \"ddd\"]\n@@ -1692,2 +1695,3 @@\n-         [[\"fmadds\", \"ssss\"], [\"fmsubs\", \"ssss\"], [\"fnmadds\", \"ssss\"], [\"fnmadds\", \"ssss\"],\n-          [\"fmaddd\", \"dddd\"], [\"fmsubd\", \"dddd\"], [\"fnmaddd\", \"dddd\"], [\"fnmaddd\", \"dddd\"],])\n+         [[\"fmaddh\", \"hhhh\"], [\"fmadds\", \"ssss\"], [\"fmsubs\", \"ssss\"], [\"fnmadds\", \"ssss\"],\n+          [\"fnmadds\", \"ssss\"], [\"fmaddd\", \"dddd\"], [\"fmsubd\", \"dddd\"], [\"fnmaddd\", \"dddd\"],\n+          [\"fnmaddd\", \"dddd\"],])\n@@ -1699,1 +1703,1 @@\n-          [\"fcvtd\", \"sd\"],\n+          [\"fcvtd\", \"sd\"], [\"fsqrth\", \"hh\"]\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -487,10 +487,24 @@\n-    __ fabds(v30, v15, v3);                            \/\/       fabd    s30, s15, s3\n-    __ fmuls(v12, v12, v16);                           \/\/       fmul    s12, s12, s16\n-    __ fdivs(v31, v31, v18);                           \/\/       fdiv    s31, s31, s18\n-    __ fadds(v19, v21, v16);                           \/\/       fadd    s19, s21, s16\n-    __ fsubs(v15, v10, v21);                           \/\/       fsub    s15, s10, s21\n-    __ fabdd(v2, v10, v28);                            \/\/       fabd    d2, d10, d28\n-    __ fmuld(v7, v30, v31);                            \/\/       fmul    d7, d30, d31\n-    __ fdivd(v18, v1, v2);                             \/\/       fdiv    d18, d1, d2\n-    __ faddd(v6, v10, v3);                             \/\/       fadd    d6, d10, d3\n-    __ fsubd(v25, v11, v7);                            \/\/       fsub    d25, d11, d7\n+    __ fabdh(v30, v15, v3);                            \/\/       fabd    h30, h15, h3\n+    __ fmulh(v12, v12, v16);                           \/\/       fmul    h12, h12, h16\n+    __ fdivh(v31, v31, v18);                           \/\/       fdiv    h31, h31, h18\n+    __ faddh(v19, v21, v16);                           \/\/       fadd    h19, h21, h16\n+    __ fsubh(v15, v10, v21);                           \/\/       fsub    h15, h10, h21\n+    __ fmaxh(v2, v10, v28);                            \/\/       fmax    h2, h10, h28\n+    __ fminh(v7, v30, v31);                            \/\/       fmin    h7, h30, h31\n+    __ fnmulh(v18, v1, v2);                            \/\/       fnmul   h18, h1, h2\n+    __ fabds(v6, v10, v3);                             \/\/       fabd    s6, s10, s3\n+    __ fmuls(v25, v11, v7);                            \/\/       fmul    s25, s11, s7\n+    __ fdivs(v1, v12, v0);                             \/\/       fdiv    s1, s12, s0\n+    __ fadds(v3, v19, v29);                            \/\/       fadd    s3, s19, s29\n+    __ fsubs(v6, v23, v6);                             \/\/       fsub    s6, s23, s6\n+    __ fmaxs(v0, v28, v27);                            \/\/       fmax    s0, s28, s27\n+    __ fmins(v2, v5, v7);                              \/\/       fmin    s2, s5, s7\n+    __ fnmuls(v29, v12, v25);                          \/\/       fnmul   s29, s12, s25\n+    __ fabdd(v13, v12, v24);                           \/\/       fabd    d13, d12, d24\n+    __ fmuld(v19, v8, v18);                            \/\/       fmul    d19, d8, d18\n+    __ fdivd(v22, v26, v21);                           \/\/       fdiv    d22, d26, d21\n+    __ faddd(v20, v19, v2);                            \/\/       fadd    d20, d19, d2\n+    __ fsubd(v30, v22, v8);                            \/\/       fsub    d30, d22, d8\n+    __ fmaxd(v22, v19, v21);                           \/\/       fmax    d22, d19, d21\n+    __ fmind(v12, v18, v21);                           \/\/       fmin    d12, d18, d21\n+    __ fnmuld(v6, v16, v3);                            \/\/       fnmul   d6, d16, d3\n@@ -499,8 +513,9 @@\n-    __ fmadds(v1, v12, v0, v3);                        \/\/       fmadd   s1, s12, s0, s3\n-    __ fmsubs(v19, v29, v6, v23);                      \/\/       fmsub   s19, s29, s6, s23\n-    __ fnmadds(v6, v0, v28, v27);                      \/\/       fnmadd  s6, s0, s28, s27\n-    __ fnmadds(v2, v5, v7, v29);                       \/\/       fnmadd  s2, s5, s7, s29\n-    __ fmaddd(v12, v25, v13, v12);                     \/\/       fmadd   d12, d25, d13, d12\n-    __ fmsubd(v24, v19, v8, v18);                      \/\/       fmsub   d24, d19, d8, d18\n-    __ fnmaddd(v22, v26, v21, v20);                    \/\/       fnmadd  d22, d26, d21, d20\n-    __ fnmaddd(v19, v2, v30, v22);                     \/\/       fnmadd  d19, d2, d30, d22\n+    __ fmaddh(v3, v29, v3, v28);                       \/\/       fmadd   h3, h29, h3, h28\n+    __ fmadds(v15, v14, v10, v13);                     \/\/       fmadd   s15, s14, s10, s13\n+    __ fmsubs(v12, v18, v10, v26);                     \/\/       fmsub   s12, s18, s10, s26\n+    __ fnmadds(v7, v7, v15, v29);                      \/\/       fnmadd  s7, s7, s15, s29\n+    __ fnmadds(v0, v23, v0, v12);                      \/\/       fnmadd  s0, s23, s0, s12\n+    __ fmaddd(v24, v14, v13, v8);                      \/\/       fmadd   d24, d14, d13, d8\n+    __ fmsubd(v15, v7, v9, v20);                       \/\/       fmsub   d15, d7, d9, d20\n+    __ fnmaddd(v19, v29, v31, v16);                    \/\/       fnmadd  d19, d29, d31, d16\n+    __ fnmaddd(v2, v9, v16, v21);                      \/\/       fnmadd  d2, d9, d16, d21\n@@ -509,12 +524,13 @@\n-    __ fmovs(v8, v22);                                 \/\/       fmov    s8, s22\n-    __ fabss(v19, v21);                                \/\/       fabs    s19, s21\n-    __ fnegs(v12, v18);                                \/\/       fneg    s12, s18\n-    __ fsqrts(v21, v6);                                \/\/       fsqrt   s21, s6\n-    __ fcvts(v16, v3);                                 \/\/       fcvt    d16, s3\n-    __ fcvtsh(v3, v29);                                \/\/       fcvt    h3, s29\n-    __ fcvths(v3, v28);                                \/\/       fcvt    s3, h28\n-    __ fmovd(v15, v14);                                \/\/       fmov    d15, d14\n-    __ fabsd(v10, v13);                                \/\/       fabs    d10, d13\n-    __ fnegd(v12, v18);                                \/\/       fneg    d12, d18\n-    __ fsqrtd(v10, v26);                               \/\/       fsqrt   d10, d26\n-    __ fcvtd(v7, v7);                                  \/\/       fcvt    s7, d7\n+    __ fmovs(v30, v4);                                 \/\/       fmov    s30, s4\n+    __ fabss(v1, v27);                                 \/\/       fabs    s1, s27\n+    __ fnegs(v25, v24);                                \/\/       fneg    s25, s24\n+    __ fsqrts(v14, v21);                               \/\/       fsqrt   s14, s21\n+    __ fcvts(v13, v6);                                 \/\/       fcvt    d13, s6\n+    __ fcvtsh(v12, v25);                               \/\/       fcvt    h12, s25\n+    __ fcvths(v25, v30);                               \/\/       fcvt    s25, h30\n+    __ fmovd(v28, v21);                                \/\/       fmov    d28, d21\n+    __ fabsd(v16, v23);                                \/\/       fabs    d16, d23\n+    __ fnegd(v5, v29);                                 \/\/       fneg    d5, d29\n+    __ fsqrtd(v22, v19);                               \/\/       fsqrt   d22, d19\n+    __ fcvtd(v13, v20);                                \/\/       fcvt    s13, d20\n+    __ fsqrth(v19, v28);                               \/\/       fsqrt   h19, h28\n@@ -523,16 +539,16 @@\n-    __ fcvtzsw(r14, v29);                              \/\/       fcvtzs  w14, s29\n-    __ fcvtzs(r0, v23);                                \/\/       fcvtzs  x0, s23\n-    __ fcvtzdw(r0, v12);                               \/\/       fcvtzs  w0, d12\n-    __ fcvtzd(r23, v14);                               \/\/       fcvtzs  x23, d14\n-    __ scvtfws(v13, r7);                               \/\/       scvtf   s13, w7\n-    __ scvtfs(v15, r7);                                \/\/       scvtf   s15, x7\n-    __ scvtfwd(v9, r20);                               \/\/       scvtf   d9, w20\n-    __ scvtfd(v19, r28);                               \/\/       scvtf   d19, x28\n-    __ fcvtassw(r30, v16);                             \/\/       fcvtas  w30, s16\n-    __ fcvtasd(r2, v9);                                \/\/       fcvtas  x2, d9\n-    __ fcvtmssw(r16, v21);                             \/\/       fcvtms  w16, s21\n-    __ fcvtmsd(r29, v4);                               \/\/       fcvtms  x29, d4\n-    __ fmovs(r1, v27);                                 \/\/       fmov    w1, s27\n-    __ fmovd(r24, v24);                                \/\/       fmov    x24, d24\n-    __ fmovs(v14, r21);                                \/\/       fmov    s14, w21\n-    __ fmovd(v13, r5);                                 \/\/       fmov    d13, x5\n+    __ fcvtzsw(r17, v6);                               \/\/       fcvtzs  w17, s6\n+    __ fcvtzs(r13, v7);                                \/\/       fcvtzs  x13, s7\n+    __ fcvtzdw(r28, v26);                              \/\/       fcvtzs  w28, d26\n+    __ fcvtzd(r17, v6);                                \/\/       fcvtzs  x17, d6\n+    __ scvtfws(v1, r4);                                \/\/       scvtf   s1, w4\n+    __ scvtfs(v14, r20);                               \/\/       scvtf   s14, x20\n+    __ scvtfwd(v7, r21);                               \/\/       scvtf   d7, w21\n+    __ scvtfd(v27, r23);                               \/\/       scvtf   d27, x23\n+    __ fcvtassw(r13, v20);                             \/\/       fcvtas  w13, s20\n+    __ fcvtasd(r30, v28);                              \/\/       fcvtas  x30, d28\n+    __ fcvtmssw(r10, v21);                             \/\/       fcvtms  w10, s21\n+    __ fcvtmsd(r5, v17);                               \/\/       fcvtms  x5, d17\n+    __ fmovs(r11, v14);                                \/\/       fmov    w11, s14\n+    __ fmovd(r13, v21);                                \/\/       fmov    x13, d21\n+    __ fmovs(v27, r14);                                \/\/       fmov    s27, w14\n+    __ fmovd(v4, r23);                                 \/\/       fmov    d4, x23\n@@ -541,4 +557,4 @@\n-    __ fcmps(v12, v25);                                \/\/       fcmp    s12, s25\n-    __ fcmpd(v25, v30);                                \/\/       fcmp    d25, d30\n-    __ fcmps(v28, 0.0);                                \/\/       fcmp    s28, #0.0\n-    __ fcmpd(v21, 0.0);                                \/\/       fcmp    d21, #0.0\n+    __ fcmps(v24, v30);                                \/\/       fcmp    s24, s30\n+    __ fcmpd(v12, v14);                                \/\/       fcmp    d12, d14\n+    __ fcmps(v17, 0.0);                                \/\/       fcmp    s17, #0.0\n+    __ fcmpd(v28, 0.0);                                \/\/       fcmp    d28, #0.0\n@@ -547,5 +563,5 @@\n-    __ stpw(r22, r5, Address(r28, -48));               \/\/       stp     w22, w5, [x28, #-48]\n-    __ ldpw(r19, r27, Address(r19, 16));               \/\/       ldp     w19, w27, [x19, #16]\n-    __ ldpsw(r28, r26, Address(r7, -32));              \/\/       ldpsw   x28, x26, [x7, #-32]\n-    __ stp(r6, r1, Address(r4, -48));                  \/\/       stp     x6, x1, [x4, #-48]\n-    __ ldp(r26, r23, Address(r21, -80));               \/\/       ldp     x26, x23, [x21, #-80]\n+    __ stpw(r0, r6, Address(r26, 16));                 \/\/       stp     w0, w6, [x26, #16]\n+    __ ldpw(r0, r30, Address(r6, -32));                \/\/       ldp     w0, w30, [x6, #-32]\n+    __ ldpsw(r16, r2, Address(r11, -208));             \/\/       ldpsw   x16, x2, [x11, #-208]\n+    __ stp(r15, r0, Address(r12, 128));                \/\/       stp     x15, x0, [x12, #128]\n+    __ ldp(r7, r30, Address(r23, 32));                 \/\/       ldp     x7, x30, [x23, #32]\n@@ -554,5 +570,5 @@\n-    __ stpw(r20, r30, Address(__ pre(r9, -96)));       \/\/       stp     w20, w30, [x9, #-96]!\n-    __ ldpw(r13, r20, Address(__ pre(r26, 16)));       \/\/       ldp     w13, w20, [x26, #16]!\n-    __ ldpsw(r29, r11, Address(__ pre(r13, -80)));     \/\/       ldpsw   x29, x11, [x13, #-80]!\n-    __ stp(r27, r21, Address(__ pre(r5, -48)));        \/\/       stp     x27, x21, [x5, #-48]!\n-    __ ldp(r6, r0, Address(__ pre(r30, 80)));          \/\/       ldp     x6, x0, [x30, #80]!\n+    __ stpw(r26, r15, Address(__ pre(r7, -256)));      \/\/       stp     w26, w15, [x7, #-256]!\n+    __ ldpw(r11, r15, Address(__ pre(r10, -32)));      \/\/       ldp     w11, w15, [x10, #-32]!\n+    __ ldpsw(r19, r16, Address(__ pre(r1, 64)));       \/\/       ldpsw   x19, x16, [x1, #64]!\n+    __ stp(r14, r9, Address(__ pre(r0, 128)));         \/\/       stp     x14, x9, [x0, #128]!\n+    __ ldp(r27, r3, Address(__ pre(r12, -96)));        \/\/       ldp     x27, x3, [x12, #-96]!\n@@ -561,5 +577,5 @@\n-    __ stpw(r19, r15, Address(__ post(r16, -208)));    \/\/       stp     w19, w15, [x16], #-208\n-    __ ldpw(r12, r23, Address(__ post(r9, -240)));     \/\/       ldp     w12, w23, [x9], #-240\n-    __ ldpsw(r0, r26, Address(__ post(r15, 32)));      \/\/       ldpsw   x0, x26, [x15], #32\n-    __ stp(r8, r17, Address(__ post(r26, -208)));      \/\/       stp     x8, x17, [x26], #-208\n-    __ ldp(r25, r7, Address(__ post(r2, -176)));       \/\/       ldp     x25, x7, [x2], #-176\n+    __ stpw(r8, r11, Address(__ post(r12, -256)));     \/\/       stp     w8, w11, [x12], #-256\n+    __ ldpw(r10, r16, Address(__ post(r4, 64)));       \/\/       ldp     w10, w16, [x4], #64\n+    __ ldpsw(r10, r30, Address(__ post(r19, -64)));    \/\/       ldpsw   x10, x30, [x19], #-64\n+    __ stp(r24, r2, Address(__ post(r15, -96)));       \/\/       stp     x24, x2, [x15], #-96\n+    __ ldp(r24, r10, Address(__ post(r16, 80)));       \/\/       ldp     x24, x10, [x16], #80\n@@ -568,4 +584,4 @@\n-    __ stnpw(r19, r17, Address(r1, -208));             \/\/       stnp    w19, w17, [x1, #-208]\n-    __ ldnpw(r0, r13, Address(r22, 128));              \/\/       ldnp    w0, w13, [x22, #128]\n-    __ stnp(r29, r23, Address(r27, 0));                \/\/       stnp    x29, x23, [x27, #0]\n-    __ ldnp(r11, r10, Address(r8, -224));              \/\/       ldnp    x11, x10, [x8, #-224]\n+    __ stnpw(r30, r21, Address(r29, 16));              \/\/       stnp    w30, w21, [x29, #16]\n+    __ ldnpw(r8, r30, Address(r10, -112));             \/\/       ldnp    w8, w30, [x10, #-112]\n+    __ stnp(r30, r26, Address(r6, -128));              \/\/       stnp    x30, x26, [x6, #-128]\n+    __ ldnp(r24, r2, Address(r20, 64));                \/\/       ldnp    x24, x2, [x20, #64]\n@@ -574,22 +590,22 @@\n-    __ ld1(v0, __ T8B, Address(r11));                  \/\/       ld1     {v0.8B}, [x11]\n-    __ ld1(v16, v17, __ T16B, Address(__ post(r26, 32))); \/\/    ld1     {v16.16B, v17.16B}, [x26], 32\n-    __ ld1(v22, v23, v24, __ T1D, Address(__ post(r26, r17))); \/\/       ld1     {v22.1D, v23.1D, v24.1D}, [x26], x17\n-    __ ld1(v27, v28, v29, v30, __ T8H, Address(__ post(r29, 64))); \/\/   ld1     {v27.8H, v28.8H, v29.8H, v30.8H}, [x29], 64\n-    __ ld1r(v22, __ T8B, Address(r6));                 \/\/       ld1r    {v22.8B}, [x6]\n-    __ ld1r(v14, __ T4S, Address(__ post(r29, 4)));    \/\/       ld1r    {v14.4S}, [x29], 4\n-    __ ld1r(v22, __ T1D, Address(__ post(r12, r16)));  \/\/       ld1r    {v22.1D}, [x12], x16\n-    __ ld2(v1, v2, __ T2D, Address(r0));               \/\/       ld2     {v1.2D, v2.2D}, [x0]\n-    __ ld2(v10, v11, __ T4H, Address(__ post(r21, 16))); \/\/     ld2     {v10.4H, v11.4H}, [x21], 16\n-    __ ld2r(v7, v8, __ T16B, Address(r25));            \/\/       ld2r    {v7.16B, v8.16B}, [x25]\n-    __ ld2r(v9, v10, __ T2S, Address(__ post(r9, 8))); \/\/       ld2r    {v9.2S, v10.2S}, [x9], 8\n-    __ ld2r(v9, v10, __ T2D, Address(__ post(r12, r14))); \/\/    ld2r    {v9.2D, v10.2D}, [x12], x14\n-    __ ld3(v7, v8, v9, __ T4S, Address(__ post(r4, r17))); \/\/   ld3     {v7.4S, v8.4S, v9.4S}, [x4], x17\n-    __ ld3(v23, v24, v25, __ T2S, Address(r17));       \/\/       ld3     {v23.2S, v24.2S, v25.2S}, [x17]\n-    __ ld3r(v4, v5, v6, __ T8H, Address(r22));         \/\/       ld3r    {v4.8H, v5.8H, v6.8H}, [x22]\n-    __ ld3r(v13, v14, v15, __ T4S, Address(__ post(r2, 12))); \/\/        ld3r    {v13.4S, v14.4S, v15.4S}, [x2], 12\n-    __ ld3r(v16, v17, v18, __ T1D, Address(__ post(r10, r12))); \/\/      ld3r    {v16.1D, v17.1D, v18.1D}, [x10], x12\n-    __ ld4(v4, v5, v6, v7, __ T8H, Address(__ post(r2, 64))); \/\/        ld4     {v4.8H, v5.8H, v6.8H, v7.8H}, [x2], 64\n-    __ ld4(v6, v7, v8, v9, __ T8B, Address(__ post(r20, r11))); \/\/      ld4     {v6.8B, v7.8B, v8.8B, v9.8B}, [x20], x11\n-    __ ld4r(v12, v13, v14, v15, __ T8B, Address(r12)); \/\/       ld4r    {v12.8B, v13.8B, v14.8B, v15.8B}, [x12]\n-    __ ld4r(v16, v17, v18, v19, __ T4H, Address(__ post(r17, 8))); \/\/   ld4r    {v16.4H, v17.4H, v18.4H, v19.4H}, [x17], 8\n-    __ ld4r(v14, v15, v16, v17, __ T2S, Address(__ post(r25, r16))); \/\/ ld4r    {v14.2S, v15.2S, v16.2S, v17.2S}, [x25], x16\n+    __ ld1(v31, __ T8B, Address(r25));                 \/\/       ld1     {v31.8B}, [x25]\n+    __ ld1(v5, v6, __ T16B, Address(__ post(r15, 32))); \/\/      ld1     {v5.16B, v6.16B}, [x15], 32\n+    __ ld1(v10, v11, v12, __ T1D, Address(__ post(r7, r13))); \/\/        ld1     {v10.1D, v11.1D, v12.1D}, [x7], x13\n+    __ ld1(v13, v14, v15, v16, __ T8H, Address(__ post(r16, 64))); \/\/   ld1     {v13.8H, v14.8H, v15.8H, v16.8H}, [x16], 64\n+    __ ld1r(v7, __ T8B, Address(r17));                 \/\/       ld1r    {v7.8B}, [x17]\n+    __ ld1r(v16, __ T4S, Address(__ post(r25, 4)));    \/\/       ld1r    {v16.4S}, [x25], 4\n+    __ ld1r(v11, __ T1D, Address(__ post(r3, r7)));    \/\/       ld1r    {v11.1D}, [x3], x7\n+    __ ld2(v13, v14, __ T2D, Address(r7));             \/\/       ld2     {v13.2D, v14.2D}, [x7]\n+    __ ld2(v9, v10, __ T4H, Address(__ post(r27, 16))); \/\/      ld2     {v9.4H, v10.4H}, [x27], 16\n+    __ ld2r(v6, v7, __ T16B, Address(r26));            \/\/       ld2r    {v6.16B, v7.16B}, [x26]\n+    __ ld2r(v23, v24, __ T2S, Address(__ post(r16, 8))); \/\/     ld2r    {v23.2S, v24.2S}, [x16], 8\n+    __ ld2r(v6, v7, __ T2D, Address(__ post(r13, r8))); \/\/      ld2r    {v6.2D, v7.2D}, [x13], x8\n+    __ ld3(v20, v21, v22, __ T4S, Address(__ post(r1, r26))); \/\/        ld3     {v20.4S, v21.4S, v22.4S}, [x1], x26\n+    __ ld3(v15, v16, v17, __ T2S, Address(r15));       \/\/       ld3     {v15.2S, v16.2S, v17.2S}, [x15]\n+    __ ld3r(v29, v30, v31, __ T8H, Address(r22));      \/\/       ld3r    {v29.8H, v30.8H, v31.8H}, [x22]\n+    __ ld3r(v6, v7, v8, __ T4S, Address(__ post(r10, 12))); \/\/  ld3r    {v6.4S, v7.4S, v8.4S}, [x10], 12\n+    __ ld3r(v15, v16, v17, __ T1D, Address(__ post(r6, r15))); \/\/       ld3r    {v15.1D, v16.1D, v17.1D}, [x6], x15\n+    __ ld4(v6, v7, v8, v9, __ T8H, Address(__ post(r10, 64))); \/\/       ld4     {v6.8H, v7.8H, v8.8H, v9.8H}, [x10], 64\n+    __ ld4(v11, v12, v13, v14, __ T8B, Address(__ post(r3, r7))); \/\/    ld4     {v11.8B, v12.8B, v13.8B, v14.8B}, [x3], x7\n+    __ ld4r(v12, v13, v14, v15, __ T8B, Address(r25)); \/\/       ld4r    {v12.8B, v13.8B, v14.8B, v15.8B}, [x25]\n+    __ ld4r(v11, v12, v13, v14, __ T4H, Address(__ post(r15, 8))); \/\/   ld4r    {v11.4H, v12.4H, v13.4H, v14.4H}, [x15], 8\n+    __ ld4r(v30, v31, v0, v1, __ T2S, Address(__ post(r6, r28))); \/\/    ld4r    {v30.2S, v31.2S, v0.2S, v1.2S}, [x6], x28\n@@ -598,19 +614,19 @@\n-    __ addv(v20, __ T8B, v21);                         \/\/       addv    b20, v21.8B\n-    __ addv(v1, __ T16B, v2);                          \/\/       addv    b1, v2.16B\n-    __ addv(v23, __ T4H, v24);                         \/\/       addv    h23, v24.4H\n-    __ addv(v30, __ T8H, v31);                         \/\/       addv    h30, v31.8H\n-    __ addv(v14, __ T4S, v15);                         \/\/       addv    s14, v15.4S\n-    __ smaxv(v2, __ T8B, v3);                          \/\/       smaxv   b2, v3.8B\n-    __ smaxv(v6, __ T16B, v7);                         \/\/       smaxv   b6, v7.16B\n-    __ smaxv(v3, __ T4H, v4);                          \/\/       smaxv   h3, v4.4H\n-    __ smaxv(v8, __ T8H, v9);                          \/\/       smaxv   h8, v9.8H\n-    __ smaxv(v25, __ T4S, v26);                        \/\/       smaxv   s25, v26.4S\n-    __ fmaxv(v0, __ T4S, v1);                          \/\/       fmaxv   s0, v1.4S\n-    __ sminv(v27, __ T8B, v28);                        \/\/       sminv   b27, v28.8B\n-    __ uminv(v30, __ T8B, v31);                        \/\/       uminv   b30, v31.8B\n-    __ sminv(v5, __ T16B, v6);                         \/\/       sminv   b5, v6.16B\n-    __ uminv(v5, __ T16B, v6);                         \/\/       uminv   b5, v6.16B\n-    __ sminv(v30, __ T4H, v31);                        \/\/       sminv   h30, v31.4H\n-    __ uminv(v11, __ T4H, v12);                        \/\/       uminv   h11, v12.4H\n-    __ sminv(v25, __ T8H, v26);                        \/\/       sminv   h25, v26.8H\n-    __ uminv(v0, __ T8H, v1);                          \/\/       uminv   h0, v1.8H\n+    __ addv(v27, __ T8B, v28);                         \/\/       addv    b27, v28.8B\n+    __ addv(v28, __ T16B, v29);                        \/\/       addv    b28, v29.16B\n+    __ addv(v1, __ T4H, v2);                           \/\/       addv    h1, v2.4H\n+    __ addv(v28, __ T8H, v29);                         \/\/       addv    h28, v29.8H\n+    __ addv(v1, __ T4S, v2);                           \/\/       addv    s1, v2.4S\n+    __ smaxv(v20, __ T8B, v21);                        \/\/       smaxv   b20, v21.8B\n+    __ smaxv(v29, __ T16B, v30);                       \/\/       smaxv   b29, v30.16B\n+    __ smaxv(v16, __ T4H, v17);                        \/\/       smaxv   h16, v17.4H\n+    __ smaxv(v13, __ T8H, v14);                        \/\/       smaxv   h13, v14.8H\n+    __ smaxv(v10, __ T4S, v11);                        \/\/       smaxv   s10, v11.4S\n+    __ fmaxv(v29, __ T4S, v30);                        \/\/       fmaxv   s29, v30.4S\n+    __ sminv(v29, __ T8B, v30);                        \/\/       sminv   b29, v30.8B\n+    __ uminv(v19, __ T8B, v20);                        \/\/       uminv   b19, v20.8B\n+    __ sminv(v22, __ T16B, v23);                       \/\/       sminv   b22, v23.16B\n+    __ uminv(v10, __ T16B, v11);                       \/\/       uminv   b10, v11.16B\n+    __ sminv(v4, __ T4H, v5);                          \/\/       sminv   h4, v5.4H\n+    __ uminv(v31, __ T4H, v0);                         \/\/       uminv   h31, v0.4H\n+    __ sminv(v21, __ T8H, v22);                        \/\/       sminv   h21, v22.8H\n+    __ uminv(v8, __ T8H, v9);                          \/\/       uminv   h8, v9.8H\n@@ -618,6 +634,6 @@\n-    __ uminv(v0, __ T4S, v1);                          \/\/       uminv   s0, v1.4S\n-    __ fminv(v19, __ T4S, v20);                        \/\/       fminv   s19, v20.4S\n-    __ fmaxp(v29, v30, __ S);                          \/\/       fmaxp   s29, v30.2S\n-    __ fmaxp(v26, v27, __ D);                          \/\/       fmaxp   d26, v27.2D\n-    __ fminp(v9, v10, __ S);                           \/\/       fminp   s9, v10.2S\n-    __ fminp(v26, v27, __ D);                          \/\/       fminp   d26, v27.2D\n+    __ uminv(v19, __ T4S, v20);                        \/\/       uminv   s19, v20.4S\n+    __ fminv(v10, __ T4S, v11);                        \/\/       fminv   s10, v11.4S\n+    __ fmaxp(v28, v29, __ S);                          \/\/       fmaxp   s28, v29.2S\n+    __ fmaxp(v2, v3, __ D);                            \/\/       fmaxp   d2, v3.2D\n+    __ fminp(v25, v26, __ S);                          \/\/       fminp   s25, v26.2S\n+    __ fminp(v5, v6, __ D);                            \/\/       fminp   d5, v6.2D\n@@ -626,7 +642,7 @@\n-    __ fcm(Assembler::GT, v12, __ T2S, v13);           \/\/       fcmgt   v12.2S, v13.2S, #0.0\n-    __ fcm(Assembler::GT, v15, __ T4S, v16);           \/\/       fcmgt   v15.4S, v16.4S, #0.0\n-    __ fcm(Assembler::GT, v11, __ T2D, v12);           \/\/       fcmgt   v11.2D, v12.2D, #0.0\n-    __ fcm(Assembler::GE, v11, __ T2S, v12);           \/\/       fcmge   v11.2S, v12.2S, #0.0\n-    __ fcm(Assembler::GE, v18, __ T4S, v19);           \/\/       fcmge   v18.4S, v19.4S, #0.0\n-    __ fcm(Assembler::GE, v25, __ T2D, v26);           \/\/       fcmge   v25.2D, v26.2D, #0.0\n-    __ fcm(Assembler::EQ, v22, __ T2S, v23);           \/\/       fcmeq   v22.2S, v23.2S, #0.0\n+    __ fcm(Assembler::GT, v3, __ T2S, v4);             \/\/       fcmgt   v3.2S, v4.2S, #0.0\n+    __ fcm(Assembler::GT, v8, __ T4S, v9);             \/\/       fcmgt   v8.4S, v9.4S, #0.0\n+    __ fcm(Assembler::GT, v22, __ T2D, v23);           \/\/       fcmgt   v22.2D, v23.2D, #0.0\n+    __ fcm(Assembler::GE, v19, __ T2S, v20);           \/\/       fcmge   v19.2S, v20.2S, #0.0\n+    __ fcm(Assembler::GE, v13, __ T4S, v14);           \/\/       fcmge   v13.4S, v14.4S, #0.0\n+    __ fcm(Assembler::GE, v5, __ T2D, v6);             \/\/       fcmge   v5.2D, v6.2D, #0.0\n+    __ fcm(Assembler::EQ, v29, __ T2S, v30);           \/\/       fcmeq   v29.2S, v30.2S, #0.0\n@@ -634,7 +650,7 @@\n-    __ fcm(Assembler::EQ, v0, __ T2D, v1);             \/\/       fcmeq   v0.2D, v1.2D, #0.0\n-    __ fcm(Assembler::LT, v17, __ T2S, v18);           \/\/       fcmlt   v17.2S, v18.2S, #0.0\n-    __ fcm(Assembler::LT, v11, __ T4S, v12);           \/\/       fcmlt   v11.4S, v12.4S, #0.0\n-    __ fcm(Assembler::LT, v6, __ T2D, v7);             \/\/       fcmlt   v6.2D, v7.2D, #0.0\n-    __ fcm(Assembler::LE, v29, __ T2S, v30);           \/\/       fcmle   v29.2S, v30.2S, #0.0\n-    __ fcm(Assembler::LE, v6, __ T4S, v7);             \/\/       fcmle   v6.4S, v7.4S, #0.0\n-    __ fcm(Assembler::LE, v5, __ T2D, v6);             \/\/       fcmle   v5.2D, v6.2D, #0.0\n+    __ fcm(Assembler::EQ, v21, __ T2D, v22);           \/\/       fcmeq   v21.2D, v22.2D, #0.0\n+    __ fcm(Assembler::LT, v26, __ T2S, v27);           \/\/       fcmlt   v26.2S, v27.2S, #0.0\n+    __ fcm(Assembler::LT, v24, __ T4S, v25);           \/\/       fcmlt   v24.4S, v25.4S, #0.0\n+    __ fcm(Assembler::LT, v3, __ T2D, v4);             \/\/       fcmlt   v3.2D, v4.2D, #0.0\n+    __ fcm(Assembler::LE, v24, __ T2S, v25);           \/\/       fcmle   v24.2S, v25.2S, #0.0\n+    __ fcm(Assembler::LE, v26, __ T4S, v27);           \/\/       fcmle   v26.4S, v27.4S, #0.0\n+    __ fcm(Assembler::LE, v23, __ T2D, v24);           \/\/       fcmle   v23.2D, v24.2D, #0.0\n@@ -643,1 +659,1 @@\n-    __ absr(v5, __ T8B, v6);                           \/\/       abs     v5.8B, v6.8B\n+    __ absr(v15, __ T8B, v16);                         \/\/       abs     v15.8B, v16.8B\n@@ -645,8 +661,8 @@\n-    __ absr(v19, __ T4H, v20);                         \/\/       abs     v19.4H, v20.4H\n-    __ absr(v16, __ T8H, v17);                         \/\/       abs     v16.8H, v17.8H\n-    __ absr(v18, __ T2S, v19);                         \/\/       abs     v18.2S, v19.2S\n-    __ absr(v30, __ T4S, v31);                         \/\/       abs     v30.4S, v31.4S\n-    __ absr(v27, __ T2D, v28);                         \/\/       abs     v27.2D, v28.2D\n-    __ fabs(v28, __ T2S, v29);                         \/\/       fabs    v28.2S, v29.2S\n-    __ fabs(v1, __ T4S, v2);                           \/\/       fabs    v1.4S, v2.4S\n-    __ fabs(v28, __ T2D, v29);                         \/\/       fabs    v28.2D, v29.2D\n+    __ absr(v3, __ T4H, v4);                           \/\/       abs     v3.4H, v4.4H\n+    __ absr(v24, __ T8H, v25);                         \/\/       abs     v24.8H, v25.8H\n+    __ absr(v8, __ T2S, v9);                           \/\/       abs     v8.2S, v9.2S\n+    __ absr(v25, __ T4S, v26);                         \/\/       abs     v25.4S, v26.4S\n+    __ absr(v20, __ T2D, v21);                         \/\/       abs     v20.2D, v21.2D\n+    __ fabs(v16, __ T2S, v17);                         \/\/       fabs    v16.2S, v17.2S\n+    __ fabs(v17, __ T4S, v18);                         \/\/       fabs    v17.4S, v18.4S\n+    __ fabs(v2, __ T2D, v3);                           \/\/       fabs    v2.2D, v3.2D\n@@ -654,7 +670,7 @@\n-    __ fneg(v20, __ T4S, v21);                         \/\/       fneg    v20.4S, v21.4S\n-    __ fneg(v29, __ T2D, v30);                         \/\/       fneg    v29.2D, v30.2D\n-    __ fsqrt(v16, __ T2S, v17);                        \/\/       fsqrt   v16.2S, v17.2S\n-    __ fsqrt(v13, __ T4S, v14);                        \/\/       fsqrt   v13.4S, v14.4S\n-    __ fsqrt(v10, __ T2D, v11);                        \/\/       fsqrt   v10.2D, v11.2D\n-    __ notr(v29, __ T8B, v30);                         \/\/       not     v29.8B, v30.8B\n-    __ notr(v29, __ T16B, v30);                        \/\/       not     v29.16B, v30.16B\n+    __ fneg(v0, __ T4S, v1);                           \/\/       fneg    v0.4S, v1.4S\n+    __ fneg(v24, __ T2D, v25);                         \/\/       fneg    v24.2D, v25.2D\n+    __ fsqrt(v4, __ T2S, v5);                          \/\/       fsqrt   v4.2S, v5.2S\n+    __ fsqrt(v3, __ T4S, v4);                          \/\/       fsqrt   v3.4S, v4.4S\n+    __ fsqrt(v12, __ T2D, v13);                        \/\/       fsqrt   v12.2D, v13.2D\n+    __ notr(v31, __ T8B, v0);                          \/\/       not     v31.8B, v0.8B\n+    __ notr(v28, __ T16B, v29);                        \/\/       not     v28.16B, v29.16B\n@@ -663,87 +679,87 @@\n-    __ andr(v19, __ T8B, v20, v21);                    \/\/       and     v19.8B, v20.8B, v21.8B\n-    __ andr(v22, __ T16B, v23, v24);                   \/\/       and     v22.16B, v23.16B, v24.16B\n-    __ orr(v10, __ T8B, v11, v12);                     \/\/       orr     v10.8B, v11.8B, v12.8B\n-    __ orr(v4, __ T16B, v5, v6);                       \/\/       orr     v4.16B, v5.16B, v6.16B\n-    __ eor(v31, __ T8B, v0, v1);                       \/\/       eor     v31.8B, v0.8B, v1.8B\n-    __ eor(v21, __ T16B, v22, v23);                    \/\/       eor     v21.16B, v22.16B, v23.16B\n-    __ addv(v8, __ T8B, v9, v10);                      \/\/       add     v8.8B, v9.8B, v10.8B\n-    __ addv(v31, __ T16B, v0, v1);                     \/\/       add     v31.16B, v0.16B, v1.16B\n-    __ addv(v19, __ T4H, v20, v21);                    \/\/       add     v19.4H, v20.4H, v21.4H\n-    __ addv(v10, __ T8H, v11, v12);                    \/\/       add     v10.8H, v11.8H, v12.8H\n-    __ addv(v28, __ T2S, v29, v30);                    \/\/       add     v28.2S, v29.2S, v30.2S\n-    __ addv(v2, __ T4S, v3, v4);                       \/\/       add     v2.4S, v3.4S, v4.4S\n-    __ addv(v25, __ T2D, v26, v27);                    \/\/       add     v25.2D, v26.2D, v27.2D\n-    __ sqaddv(v5, __ T8B, v6, v7);                     \/\/       sqadd   v5.8B, v6.8B, v7.8B\n-    __ sqaddv(v3, __ T16B, v4, v5);                    \/\/       sqadd   v3.16B, v4.16B, v5.16B\n-    __ sqaddv(v8, __ T4H, v9, v10);                    \/\/       sqadd   v8.4H, v9.4H, v10.4H\n-    __ sqaddv(v22, __ T8H, v23, v24);                  \/\/       sqadd   v22.8H, v23.8H, v24.8H\n-    __ sqaddv(v19, __ T2S, v20, v21);                  \/\/       sqadd   v19.2S, v20.2S, v21.2S\n-    __ sqaddv(v13, __ T4S, v14, v15);                  \/\/       sqadd   v13.4S, v14.4S, v15.4S\n-    __ sqaddv(v5, __ T2D, v6, v7);                     \/\/       sqadd   v5.2D, v6.2D, v7.2D\n-    __ uqaddv(v29, __ T8B, v30, v31);                  \/\/       uqadd   v29.8B, v30.8B, v31.8B\n-    __ uqaddv(v24, __ T16B, v25, v26);                 \/\/       uqadd   v24.16B, v25.16B, v26.16B\n-    __ uqaddv(v21, __ T4H, v22, v23);                  \/\/       uqadd   v21.4H, v22.4H, v23.4H\n-    __ uqaddv(v26, __ T8H, v27, v28);                  \/\/       uqadd   v26.8H, v27.8H, v28.8H\n-    __ uqaddv(v24, __ T2S, v25, v26);                  \/\/       uqadd   v24.2S, v25.2S, v26.2S\n-    __ uqaddv(v3, __ T4S, v4, v5);                     \/\/       uqadd   v3.4S, v4.4S, v5.4S\n-    __ uqaddv(v24, __ T2D, v25, v26);                  \/\/       uqadd   v24.2D, v25.2D, v26.2D\n-    __ fadd(v26, __ T2S, v27, v28);                    \/\/       fadd    v26.2S, v27.2S, v28.2S\n-    __ fadd(v23, __ T4S, v24, v25);                    \/\/       fadd    v23.4S, v24.4S, v25.4S\n-    __ fadd(v15, __ T2D, v16, v17);                    \/\/       fadd    v15.2D, v16.2D, v17.2D\n-    __ subv(v21, __ T8B, v22, v23);                    \/\/       sub     v21.8B, v22.8B, v23.8B\n-    __ subv(v3, __ T16B, v4, v5);                      \/\/       sub     v3.16B, v4.16B, v5.16B\n-    __ subv(v24, __ T4H, v25, v26);                    \/\/       sub     v24.4H, v25.4H, v26.4H\n-    __ subv(v8, __ T8H, v9, v10);                      \/\/       sub     v8.8H, v9.8H, v10.8H\n-    __ subv(v25, __ T2S, v26, v27);                    \/\/       sub     v25.2S, v26.2S, v27.2S\n-    __ subv(v20, __ T4S, v21, v22);                    \/\/       sub     v20.4S, v21.4S, v22.4S\n-    __ subv(v16, __ T2D, v17, v18);                    \/\/       sub     v16.2D, v17.2D, v18.2D\n-    __ sqsubv(v17, __ T8B, v18, v19);                  \/\/       sqsub   v17.8B, v18.8B, v19.8B\n-    __ sqsubv(v2, __ T16B, v3, v4);                    \/\/       sqsub   v2.16B, v3.16B, v4.16B\n-    __ sqsubv(v1, __ T4H, v2, v3);                     \/\/       sqsub   v1.4H, v2.4H, v3.4H\n-    __ sqsubv(v0, __ T8H, v1, v2);                     \/\/       sqsub   v0.8H, v1.8H, v2.8H\n-    __ sqsubv(v24, __ T2S, v25, v26);                  \/\/       sqsub   v24.2S, v25.2S, v26.2S\n-    __ sqsubv(v4, __ T4S, v5, v6);                     \/\/       sqsub   v4.4S, v5.4S, v6.4S\n-    __ sqsubv(v3, __ T2D, v4, v5);                     \/\/       sqsub   v3.2D, v4.2D, v5.2D\n-    __ uqsubv(v12, __ T8B, v13, v14);                  \/\/       uqsub   v12.8B, v13.8B, v14.8B\n-    __ uqsubv(v31, __ T16B, v0, v1);                   \/\/       uqsub   v31.16B, v0.16B, v1.16B\n-    __ uqsubv(v28, __ T4H, v29, v30);                  \/\/       uqsub   v28.4H, v29.4H, v30.4H\n-    __ uqsubv(v10, __ T8H, v11, v12);                  \/\/       uqsub   v10.8H, v11.8H, v12.8H\n-    __ uqsubv(v26, __ T2S, v27, v28);                  \/\/       uqsub   v26.2S, v27.2S, v28.2S\n-    __ uqsubv(v2, __ T4S, v3, v4);                     \/\/       uqsub   v2.4S, v3.4S, v4.4S\n-    __ uqsubv(v12, __ T2D, v13, v14);                  \/\/       uqsub   v12.2D, v13.2D, v14.2D\n-    __ fsub(v18, __ T2S, v19, v20);                    \/\/       fsub    v18.2S, v19.2S, v20.2S\n-    __ fsub(v31, __ T4S, v0, v1);                      \/\/       fsub    v31.4S, v0.4S, v1.4S\n-    __ fsub(v1, __ T2D, v2, v3);                       \/\/       fsub    v1.2D, v2.2D, v3.2D\n-    __ mulv(v13, __ T8B, v14, v15);                    \/\/       mul     v13.8B, v14.8B, v15.8B\n-    __ mulv(v29, __ T16B, v30, v31);                   \/\/       mul     v29.16B, v30.16B, v31.16B\n-    __ mulv(v0, __ T4H, v1, v2);                       \/\/       mul     v0.4H, v1.4H, v2.4H\n-    __ mulv(v19, __ T8H, v20, v21);                    \/\/       mul     v19.8H, v20.8H, v21.8H\n-    __ mulv(v12, __ T2S, v13, v14);                    \/\/       mul     v12.2S, v13.2S, v14.2S\n-    __ mulv(v17, __ T4S, v18, v19);                    \/\/       mul     v17.4S, v18.4S, v19.4S\n-    __ fabd(v22, __ T2S, v23, v24);                    \/\/       fabd    v22.2S, v23.2S, v24.2S\n-    __ fabd(v13, __ T4S, v14, v15);                    \/\/       fabd    v13.4S, v14.4S, v15.4S\n-    __ fabd(v28, __ T2D, v29, v30);                    \/\/       fabd    v28.2D, v29.2D, v30.2D\n-    __ faddp(v30, __ T2S, v31, v0);                    \/\/       faddp   v30.2S, v31.2S, v0.2S\n-    __ faddp(v31, __ T4S, v0, v1);                     \/\/       faddp   v31.4S, v0.4S, v1.4S\n-    __ faddp(v1, __ T2D, v2, v3);                      \/\/       faddp   v1.2D, v2.2D, v3.2D\n-    __ fmul(v26, __ T2S, v27, v28);                    \/\/       fmul    v26.2S, v27.2S, v28.2S\n-    __ fmul(v28, __ T4S, v29, v30);                    \/\/       fmul    v28.4S, v29.4S, v30.4S\n-    __ fmul(v4, __ T2D, v5, v6);                       \/\/       fmul    v4.2D, v5.2D, v6.2D\n-    __ mlav(v30, __ T4H, v31, v0);                     \/\/       mla     v30.4H, v31.4H, v0.4H\n-    __ mlav(v4, __ T8H, v5, v6);                       \/\/       mla     v4.8H, v5.8H, v6.8H\n-    __ mlav(v6, __ T2S, v7, v8);                       \/\/       mla     v6.2S, v7.2S, v8.2S\n-    __ mlav(v30, __ T4S, v31, v0);                     \/\/       mla     v30.4S, v31.4S, v0.4S\n-    __ fmla(v26, __ T2S, v27, v28);                    \/\/       fmla    v26.2S, v27.2S, v28.2S\n-    __ fmla(v18, __ T4S, v19, v20);                    \/\/       fmla    v18.4S, v19.4S, v20.4S\n-    __ fmla(v9, __ T2D, v10, v11);                     \/\/       fmla    v9.2D, v10.2D, v11.2D\n-    __ mlsv(v8, __ T4H, v9, v10);                      \/\/       mls     v8.4H, v9.4H, v10.4H\n-    __ mlsv(v12, __ T8H, v13, v14);                    \/\/       mls     v12.8H, v13.8H, v14.8H\n-    __ mlsv(v0, __ T2S, v1, v2);                       \/\/       mls     v0.2S, v1.2S, v2.2S\n-    __ mlsv(v20, __ T4S, v21, v22);                    \/\/       mls     v20.4S, v21.4S, v22.4S\n-    __ fmls(v1, __ T2S, v2, v3);                       \/\/       fmls    v1.2S, v2.2S, v3.2S\n-    __ fmls(v24, __ T4S, v25, v26);                    \/\/       fmls    v24.4S, v25.4S, v26.4S\n-    __ fmls(v2, __ T2D, v3, v4);                       \/\/       fmls    v2.2D, v3.2D, v4.2D\n-    __ fdiv(v0, __ T2S, v1, v2);                       \/\/       fdiv    v0.2S, v1.2S, v2.2S\n-    __ fdiv(v9, __ T4S, v10, v11);                     \/\/       fdiv    v9.4S, v10.4S, v11.4S\n-    __ fdiv(v24, __ T2D, v25, v26);                    \/\/       fdiv    v24.2D, v25.2D, v26.2D\n-    __ maxv(v26, __ T8B, v27, v28);                    \/\/       smax    v26.8B, v27.8B, v28.8B\n+    __ andr(v10, __ T8B, v11, v12);                    \/\/       and     v10.8B, v11.8B, v12.8B\n+    __ andr(v26, __ T16B, v27, v28);                   \/\/       and     v26.16B, v27.16B, v28.16B\n+    __ orr(v2, __ T8B, v3, v4);                        \/\/       orr     v2.8B, v3.8B, v4.8B\n+    __ orr(v12, __ T16B, v13, v14);                    \/\/       orr     v12.16B, v13.16B, v14.16B\n+    __ eor(v18, __ T8B, v19, v20);                     \/\/       eor     v18.8B, v19.8B, v20.8B\n+    __ eor(v31, __ T16B, v0, v1);                      \/\/       eor     v31.16B, v0.16B, v1.16B\n+    __ addv(v1, __ T8B, v2, v3);                       \/\/       add     v1.8B, v2.8B, v3.8B\n+    __ addv(v13, __ T16B, v14, v15);                   \/\/       add     v13.16B, v14.16B, v15.16B\n+    __ addv(v29, __ T4H, v30, v31);                    \/\/       add     v29.4H, v30.4H, v31.4H\n+    __ addv(v0, __ T8H, v1, v2);                       \/\/       add     v0.8H, v1.8H, v2.8H\n+    __ addv(v19, __ T2S, v20, v21);                    \/\/       add     v19.2S, v20.2S, v21.2S\n+    __ addv(v12, __ T4S, v13, v14);                    \/\/       add     v12.4S, v13.4S, v14.4S\n+    __ addv(v17, __ T2D, v18, v19);                    \/\/       add     v17.2D, v18.2D, v19.2D\n+    __ sqaddv(v22, __ T8B, v23, v24);                  \/\/       sqadd   v22.8B, v23.8B, v24.8B\n+    __ sqaddv(v13, __ T16B, v14, v15);                 \/\/       sqadd   v13.16B, v14.16B, v15.16B\n+    __ sqaddv(v28, __ T4H, v29, v30);                  \/\/       sqadd   v28.4H, v29.4H, v30.4H\n+    __ sqaddv(v30, __ T8H, v31, v0);                   \/\/       sqadd   v30.8H, v31.8H, v0.8H\n+    __ sqaddv(v31, __ T2S, v0, v1);                    \/\/       sqadd   v31.2S, v0.2S, v1.2S\n+    __ sqaddv(v1, __ T4S, v2, v3);                     \/\/       sqadd   v1.4S, v2.4S, v3.4S\n+    __ sqaddv(v26, __ T2D, v27, v28);                  \/\/       sqadd   v26.2D, v27.2D, v28.2D\n+    __ uqaddv(v28, __ T8B, v29, v30);                  \/\/       uqadd   v28.8B, v29.8B, v30.8B\n+    __ uqaddv(v4, __ T16B, v5, v6);                    \/\/       uqadd   v4.16B, v5.16B, v6.16B\n+    __ uqaddv(v30, __ T4H, v31, v0);                   \/\/       uqadd   v30.4H, v31.4H, v0.4H\n+    __ uqaddv(v4, __ T8H, v5, v6);                     \/\/       uqadd   v4.8H, v5.8H, v6.8H\n+    __ uqaddv(v6, __ T2S, v7, v8);                     \/\/       uqadd   v6.2S, v7.2S, v8.2S\n+    __ uqaddv(v30, __ T4S, v31, v0);                   \/\/       uqadd   v30.4S, v31.4S, v0.4S\n+    __ uqaddv(v26, __ T2D, v27, v28);                  \/\/       uqadd   v26.2D, v27.2D, v28.2D\n+    __ fadd(v18, __ T2S, v19, v20);                    \/\/       fadd    v18.2S, v19.2S, v20.2S\n+    __ fadd(v9, __ T4S, v10, v11);                     \/\/       fadd    v9.4S, v10.4S, v11.4S\n+    __ fadd(v8, __ T2D, v9, v10);                      \/\/       fadd    v8.2D, v9.2D, v10.2D\n+    __ subv(v12, __ T8B, v13, v14);                    \/\/       sub     v12.8B, v13.8B, v14.8B\n+    __ subv(v0, __ T16B, v1, v2);                      \/\/       sub     v0.16B, v1.16B, v2.16B\n+    __ subv(v20, __ T4H, v21, v22);                    \/\/       sub     v20.4H, v21.4H, v22.4H\n+    __ subv(v1, __ T8H, v2, v3);                       \/\/       sub     v1.8H, v2.8H, v3.8H\n+    __ subv(v24, __ T2S, v25, v26);                    \/\/       sub     v24.2S, v25.2S, v26.2S\n+    __ subv(v2, __ T4S, v3, v4);                       \/\/       sub     v2.4S, v3.4S, v4.4S\n+    __ subv(v0, __ T2D, v1, v2);                       \/\/       sub     v0.2D, v1.2D, v2.2D\n+    __ sqsubv(v9, __ T8B, v10, v11);                   \/\/       sqsub   v9.8B, v10.8B, v11.8B\n+    __ sqsubv(v24, __ T16B, v25, v26);                 \/\/       sqsub   v24.16B, v25.16B, v26.16B\n+    __ sqsubv(v26, __ T4H, v27, v28);                  \/\/       sqsub   v26.4H, v27.4H, v28.4H\n+    __ sqsubv(v16, __ T8H, v17, v18);                  \/\/       sqsub   v16.8H, v17.8H, v18.8H\n+    __ sqsubv(v30, __ T2S, v31, v0);                   \/\/       sqsub   v30.2S, v31.2S, v0.2S\n+    __ sqsubv(v3, __ T4S, v4, v5);                     \/\/       sqsub   v3.4S, v4.4S, v5.4S\n+    __ sqsubv(v10, __ T2D, v11, v12);                  \/\/       sqsub   v10.2D, v11.2D, v12.2D\n+    __ uqsubv(v23, __ T8B, v24, v25);                  \/\/       uqsub   v23.8B, v24.8B, v25.8B\n+    __ uqsubv(v10, __ T16B, v11, v12);                 \/\/       uqsub   v10.16B, v11.16B, v12.16B\n+    __ uqsubv(v4, __ T4H, v5, v6);                     \/\/       uqsub   v4.4H, v5.4H, v6.4H\n+    __ uqsubv(v18, __ T8H, v19, v20);                  \/\/       uqsub   v18.8H, v19.8H, v20.8H\n+    __ uqsubv(v2, __ T2S, v3, v4);                     \/\/       uqsub   v2.2S, v3.2S, v4.2S\n+    __ uqsubv(v11, __ T4S, v12, v13);                  \/\/       uqsub   v11.4S, v12.4S, v13.4S\n+    __ uqsubv(v8, __ T2D, v9, v10);                    \/\/       uqsub   v8.2D, v9.2D, v10.2D\n+    __ fsub(v10, __ T2S, v11, v12);                    \/\/       fsub    v10.2S, v11.2S, v12.2S\n+    __ fsub(v15, __ T4S, v16, v17);                    \/\/       fsub    v15.4S, v16.4S, v17.4S\n+    __ fsub(v17, __ T2D, v18, v19);                    \/\/       fsub    v17.2D, v18.2D, v19.2D\n+    __ mulv(v2, __ T8B, v3, v4);                       \/\/       mul     v2.8B, v3.8B, v4.8B\n+    __ mulv(v10, __ T16B, v11, v12);                   \/\/       mul     v10.16B, v11.16B, v12.16B\n+    __ mulv(v12, __ T4H, v13, v14);                    \/\/       mul     v12.4H, v13.4H, v14.4H\n+    __ mulv(v12, __ T8H, v13, v14);                    \/\/       mul     v12.8H, v13.8H, v14.8H\n+    __ mulv(v15, __ T2S, v16, v17);                    \/\/       mul     v15.2S, v16.2S, v17.2S\n+    __ mulv(v13, __ T4S, v14, v15);                    \/\/       mul     v13.4S, v14.4S, v15.4S\n+    __ fabd(v2, __ T2S, v3, v4);                       \/\/       fabd    v2.2S, v3.2S, v4.2S\n+    __ fabd(v7, __ T4S, v8, v9);                       \/\/       fabd    v7.4S, v8.4S, v9.4S\n+    __ fabd(v20, __ T2D, v21, v22);                    \/\/       fabd    v20.2D, v21.2D, v22.2D\n+    __ faddp(v26, __ T2S, v27, v28);                   \/\/       faddp   v26.2S, v27.2S, v28.2S\n+    __ faddp(v16, __ T4S, v17, v18);                   \/\/       faddp   v16.4S, v17.4S, v18.4S\n+    __ faddp(v4, __ T2D, v5, v6);                      \/\/       faddp   v4.2D, v5.2D, v6.2D\n+    __ fmul(v2, __ T2S, v3, v4);                       \/\/       fmul    v2.2S, v3.2S, v4.2S\n+    __ fmul(v4, __ T4S, v5, v6);                       \/\/       fmul    v4.4S, v5.4S, v6.4S\n+    __ fmul(v12, __ T2D, v13, v14);                    \/\/       fmul    v12.2D, v13.2D, v14.2D\n+    __ mlav(v18, __ T4H, v19, v20);                    \/\/       mla     v18.4H, v19.4H, v20.4H\n+    __ mlav(v21, __ T8H, v22, v23);                    \/\/       mla     v21.8H, v22.8H, v23.8H\n+    __ mlav(v16, __ T2S, v17, v18);                    \/\/       mla     v16.2S, v17.2S, v18.2S\n+    __ mlav(v18, __ T4S, v19, v20);                    \/\/       mla     v18.4S, v19.4S, v20.4S\n+    __ fmla(v11, __ T2S, v12, v13);                    \/\/       fmla    v11.2S, v12.2S, v13.2S\n+    __ fmla(v21, __ T4S, v22, v23);                    \/\/       fmla    v21.4S, v22.4S, v23.4S\n+    __ fmla(v23, __ T2D, v24, v25);                    \/\/       fmla    v23.2D, v24.2D, v25.2D\n+    __ mlsv(v12, __ T4H, v13, v14);                    \/\/       mls     v12.4H, v13.4H, v14.4H\n+    __ mlsv(v26, __ T8H, v27, v28);                    \/\/       mls     v26.8H, v27.8H, v28.8H\n+    __ mlsv(v23, __ T2S, v24, v25);                    \/\/       mls     v23.2S, v24.2S, v25.2S\n+    __ mlsv(v28, __ T4S, v29, v30);                    \/\/       mls     v28.4S, v29.4S, v30.4S\n+    __ fmls(v14, __ T2S, v15, v16);                    \/\/       fmls    v14.2S, v15.2S, v16.2S\n+    __ fmls(v11, __ T4S, v12, v13);                    \/\/       fmls    v11.4S, v12.4S, v13.4S\n+    __ fmls(v24, __ T2D, v25, v26);                    \/\/       fmls    v24.2D, v25.2D, v26.2D\n+    __ fdiv(v1, __ T2S, v2, v3);                       \/\/       fdiv    v1.2S, v2.2S, v3.2S\n+    __ fdiv(v12, __ T4S, v13, v14);                    \/\/       fdiv    v12.4S, v13.4S, v14.4S\n+    __ fdiv(v31, __ T2D, v0, v1);                      \/\/       fdiv    v31.2D, v0.2D, v1.2D\n+    __ maxv(v10, __ T8B, v11, v12);                    \/\/       smax    v10.8B, v11.8B, v12.8B\n@@ -751,53 +767,53 @@\n-    __ maxv(v30, __ T4H, v31, v0);                     \/\/       smax    v30.4H, v31.4H, v0.4H\n-    __ maxv(v3, __ T8H, v4, v5);                       \/\/       smax    v3.8H, v4.8H, v5.8H\n-    __ maxv(v10, __ T2S, v11, v12);                    \/\/       smax    v10.2S, v11.2S, v12.2S\n-    __ maxv(v23, __ T4S, v24, v25);                    \/\/       smax    v23.4S, v24.4S, v25.4S\n-    __ umaxv(v10, __ T8B, v11, v12);                   \/\/       umax    v10.8B, v11.8B, v12.8B\n-    __ umaxv(v4, __ T16B, v5, v6);                     \/\/       umax    v4.16B, v5.16B, v6.16B\n-    __ umaxv(v18, __ T4H, v19, v20);                   \/\/       umax    v18.4H, v19.4H, v20.4H\n-    __ umaxv(v2, __ T8H, v3, v4);                      \/\/       umax    v2.8H, v3.8H, v4.8H\n-    __ umaxv(v11, __ T2S, v12, v13);                   \/\/       umax    v11.2S, v12.2S, v13.2S\n-    __ umaxv(v8, __ T4S, v9, v10);                     \/\/       umax    v8.4S, v9.4S, v10.4S\n-    __ smaxp(v10, __ T8B, v11, v12);                   \/\/       smaxp   v10.8B, v11.8B, v12.8B\n-    __ smaxp(v15, __ T16B, v16, v17);                  \/\/       smaxp   v15.16B, v16.16B, v17.16B\n-    __ smaxp(v17, __ T4H, v18, v19);                   \/\/       smaxp   v17.4H, v18.4H, v19.4H\n-    __ smaxp(v2, __ T8H, v3, v4);                      \/\/       smaxp   v2.8H, v3.8H, v4.8H\n-    __ smaxp(v10, __ T2S, v11, v12);                   \/\/       smaxp   v10.2S, v11.2S, v12.2S\n-    __ smaxp(v12, __ T4S, v13, v14);                   \/\/       smaxp   v12.4S, v13.4S, v14.4S\n-    __ fmax(v12, __ T2S, v13, v14);                    \/\/       fmax    v12.2S, v13.2S, v14.2S\n-    __ fmax(v15, __ T4S, v16, v17);                    \/\/       fmax    v15.4S, v16.4S, v17.4S\n-    __ fmax(v13, __ T2D, v14, v15);                    \/\/       fmax    v13.2D, v14.2D, v15.2D\n-    __ minv(v2, __ T8B, v3, v4);                       \/\/       smin    v2.8B, v3.8B, v4.8B\n-    __ minv(v7, __ T16B, v8, v9);                      \/\/       smin    v7.16B, v8.16B, v9.16B\n-    __ minv(v20, __ T4H, v21, v22);                    \/\/       smin    v20.4H, v21.4H, v22.4H\n-    __ minv(v26, __ T8H, v27, v28);                    \/\/       smin    v26.8H, v27.8H, v28.8H\n-    __ minv(v16, __ T2S, v17, v18);                    \/\/       smin    v16.2S, v17.2S, v18.2S\n-    __ minv(v4, __ T4S, v5, v6);                       \/\/       smin    v4.4S, v5.4S, v6.4S\n-    __ uminv(v2, __ T8B, v3, v4);                      \/\/       umin    v2.8B, v3.8B, v4.8B\n-    __ uminv(v4, __ T16B, v5, v6);                     \/\/       umin    v4.16B, v5.16B, v6.16B\n-    __ uminv(v12, __ T4H, v13, v14);                   \/\/       umin    v12.4H, v13.4H, v14.4H\n-    __ uminv(v18, __ T8H, v19, v20);                   \/\/       umin    v18.8H, v19.8H, v20.8H\n-    __ uminv(v21, __ T2S, v22, v23);                   \/\/       umin    v21.2S, v22.2S, v23.2S\n-    __ uminv(v16, __ T4S, v17, v18);                   \/\/       umin    v16.4S, v17.4S, v18.4S\n-    __ sminp(v18, __ T8B, v19, v20);                   \/\/       sminp   v18.8B, v19.8B, v20.8B\n-    __ sminp(v11, __ T16B, v12, v13);                  \/\/       sminp   v11.16B, v12.16B, v13.16B\n-    __ sminp(v21, __ T4H, v22, v23);                   \/\/       sminp   v21.4H, v22.4H, v23.4H\n-    __ sminp(v23, __ T8H, v24, v25);                   \/\/       sminp   v23.8H, v24.8H, v25.8H\n-    __ sminp(v12, __ T2S, v13, v14);                   \/\/       sminp   v12.2S, v13.2S, v14.2S\n-    __ sminp(v26, __ T4S, v27, v28);                   \/\/       sminp   v26.4S, v27.4S, v28.4S\n-    __ sqdmulh(v23, __ T4H, v24, v25);                 \/\/       sqdmulh v23.4H, v24.4H, v25.4H\n-    __ sqdmulh(v28, __ T8H, v29, v30);                 \/\/       sqdmulh v28.8H, v29.8H, v30.8H\n-    __ sqdmulh(v14, __ T2S, v15, v16);                 \/\/       sqdmulh v14.2S, v15.2S, v16.2S\n-    __ sqdmulh(v11, __ T4S, v12, v13);                 \/\/       sqdmulh v11.4S, v12.4S, v13.4S\n-    __ shsubv(v24, __ T8B, v25, v26);                  \/\/       shsub   v24.8B, v25.8B, v26.8B\n-    __ shsubv(v1, __ T16B, v2, v3);                    \/\/       shsub   v1.16B, v2.16B, v3.16B\n-    __ shsubv(v12, __ T4H, v13, v14);                  \/\/       shsub   v12.4H, v13.4H, v14.4H\n-    __ shsubv(v31, __ T8H, v0, v1);                    \/\/       shsub   v31.8H, v0.8H, v1.8H\n-    __ shsubv(v10, __ T2S, v11, v12);                  \/\/       shsub   v10.2S, v11.2S, v12.2S\n-    __ shsubv(v16, __ T4S, v17, v18);                  \/\/       shsub   v16.4S, v17.4S, v18.4S\n-    __ fmin(v7, __ T2S, v8, v9);                       \/\/       fmin    v7.2S, v8.2S, v9.2S\n-    __ fmin(v2, __ T4S, v3, v4);                       \/\/       fmin    v2.4S, v3.4S, v4.4S\n-    __ fmin(v3, __ T2D, v4, v5);                       \/\/       fmin    v3.2D, v4.2D, v5.2D\n-    __ facgt(v13, __ T2S, v14, v15);                   \/\/       facgt   v13.2S, v14.2S, v15.2S\n-    __ facgt(v19, __ T4S, v20, v21);                   \/\/       facgt   v19.4S, v20.4S, v21.4S\n-    __ facgt(v17, __ T2D, v18, v19);                   \/\/       facgt   v17.2D, v18.2D, v19.2D\n+    __ maxv(v7, __ T4H, v8, v9);                       \/\/       smax    v7.4H, v8.4H, v9.4H\n+    __ maxv(v2, __ T8H, v3, v4);                       \/\/       smax    v2.8H, v3.8H, v4.8H\n+    __ maxv(v3, __ T2S, v4, v5);                       \/\/       smax    v3.2S, v4.2S, v5.2S\n+    __ maxv(v13, __ T4S, v14, v15);                    \/\/       smax    v13.4S, v14.4S, v15.4S\n+    __ umaxv(v19, __ T8B, v20, v21);                   \/\/       umax    v19.8B, v20.8B, v21.8B\n+    __ umaxv(v17, __ T16B, v18, v19);                  \/\/       umax    v17.16B, v18.16B, v19.16B\n+    __ umaxv(v16, __ T4H, v17, v18);                   \/\/       umax    v16.4H, v17.4H, v18.4H\n+    __ umaxv(v3, __ T8H, v4, v5);                      \/\/       umax    v3.8H, v4.8H, v5.8H\n+    __ umaxv(v1, __ T2S, v2, v3);                      \/\/       umax    v1.2S, v2.2S, v3.2S\n+    __ umaxv(v11, __ T4S, v12, v13);                   \/\/       umax    v11.4S, v12.4S, v13.4S\n+    __ smaxp(v30, __ T8B, v31, v0);                    \/\/       smaxp   v30.8B, v31.8B, v0.8B\n+    __ smaxp(v5, __ T16B, v6, v7);                     \/\/       smaxp   v5.16B, v6.16B, v7.16B\n+    __ smaxp(v8, __ T4H, v9, v10);                     \/\/       smaxp   v8.4H, v9.4H, v10.4H\n+    __ smaxp(v15, __ T8H, v16, v17);                   \/\/       smaxp   v15.8H, v16.8H, v17.8H\n+    __ smaxp(v29, __ T2S, v30, v31);                   \/\/       smaxp   v29.2S, v30.2S, v31.2S\n+    __ smaxp(v30, __ T4S, v31, v0);                    \/\/       smaxp   v30.4S, v31.4S, v0.4S\n+    __ fmax(v0, __ T2S, v1, v2);                       \/\/       fmax    v0.2S, v1.2S, v2.2S\n+    __ fmax(v20, __ T4S, v21, v22);                    \/\/       fmax    v20.4S, v21.4S, v22.4S\n+    __ fmax(v7, __ T2D, v8, v9);                       \/\/       fmax    v7.2D, v8.2D, v9.2D\n+    __ minv(v20, __ T8B, v21, v22);                    \/\/       smin    v20.8B, v21.8B, v22.8B\n+    __ minv(v23, __ T16B, v24, v25);                   \/\/       smin    v23.16B, v24.16B, v25.16B\n+    __ minv(v28, __ T4H, v29, v30);                    \/\/       smin    v28.4H, v29.4H, v30.4H\n+    __ minv(v21, __ T8H, v22, v23);                    \/\/       smin    v21.8H, v22.8H, v23.8H\n+    __ minv(v27, __ T2S, v28, v29);                    \/\/       smin    v27.2S, v28.2S, v29.2S\n+    __ minv(v25, __ T4S, v26, v27);                    \/\/       smin    v25.4S, v26.4S, v27.4S\n+    __ uminv(v5, __ T8B, v6, v7);                      \/\/       umin    v5.8B, v6.8B, v7.8B\n+    __ uminv(v1, __ T16B, v2, v3);                     \/\/       umin    v1.16B, v2.16B, v3.16B\n+    __ uminv(v23, __ T4H, v24, v25);                   \/\/       umin    v23.4H, v24.4H, v25.4H\n+    __ uminv(v16, __ T8H, v17, v18);                   \/\/       umin    v16.8H, v17.8H, v18.8H\n+    __ uminv(v31, __ T2S, v0, v1);                     \/\/       umin    v31.2S, v0.2S, v1.2S\n+    __ uminv(v5, __ T4S, v6, v7);                      \/\/       umin    v5.4S, v6.4S, v7.4S\n+    __ sminp(v12, __ T8B, v13, v14);                   \/\/       sminp   v12.8B, v13.8B, v14.8B\n+    __ sminp(v9, __ T16B, v10, v11);                   \/\/       sminp   v9.16B, v10.16B, v11.16B\n+    __ sminp(v28, __ T4H, v29, v30);                   \/\/       sminp   v28.4H, v29.4H, v30.4H\n+    __ sminp(v15, __ T8H, v16, v17);                   \/\/       sminp   v15.8H, v16.8H, v17.8H\n+    __ sminp(v29, __ T2S, v30, v31);                   \/\/       sminp   v29.2S, v30.2S, v31.2S\n+    __ sminp(v22, __ T4S, v23, v24);                   \/\/       sminp   v22.4S, v23.4S, v24.4S\n+    __ sqdmulh(v31, __ T4H, v0, v1);                   \/\/       sqdmulh v31.4H, v0.4H, v1.4H\n+    __ sqdmulh(v19, __ T8H, v20, v21);                 \/\/       sqdmulh v19.8H, v20.8H, v21.8H\n+    __ sqdmulh(v31, __ T2S, v0, v1);                   \/\/       sqdmulh v31.2S, v0.2S, v1.2S\n+    __ sqdmulh(v5, __ T4S, v6, v7);                    \/\/       sqdmulh v5.4S, v6.4S, v7.4S\n+    __ shsubv(v14, __ T8B, v15, v16);                  \/\/       shsub   v14.8B, v15.8B, v16.8B\n+    __ shsubv(v18, __ T16B, v19, v20);                 \/\/       shsub   v18.16B, v19.16B, v20.16B\n+    __ shsubv(v31, __ T4H, v0, v1);                    \/\/       shsub   v31.4H, v0.4H, v1.4H\n+    __ shsubv(v18, __ T8H, v19, v20);                  \/\/       shsub   v18.8H, v19.8H, v20.8H\n+    __ shsubv(v27, __ T2S, v28, v29);                  \/\/       shsub   v27.2S, v28.2S, v29.2S\n+    __ shsubv(v20, __ T4S, v21, v22);                  \/\/       shsub   v20.4S, v21.4S, v22.4S\n+    __ fmin(v16, __ T2S, v17, v18);                    \/\/       fmin    v16.2S, v17.2S, v18.2S\n+    __ fmin(v12, __ T4S, v13, v14);                    \/\/       fmin    v12.4S, v13.4S, v14.4S\n+    __ fmin(v11, __ T2D, v12, v13);                    \/\/       fmin    v11.2D, v12.2D, v13.2D\n+    __ facgt(v9, __ T2S, v10, v11);                    \/\/       facgt   v9.2S, v10.2S, v11.2S\n+    __ facgt(v6, __ T4S, v7, v8);                      \/\/       facgt   v6.4S, v7.4S, v8.4S\n+    __ facgt(v30, __ T2D, v31, v0);                    \/\/       facgt   v30.2D, v31.2D, v0.2D\n@@ -806,4 +822,1 @@\n-    __ fmlavs(v1, __ T2S, v2, v3, 1);                  \/\/       fmla    v1.2S, v2.2S, v3.S[1]\n-    __ mulvs(v5, __ T4S, v6, v7, 0);                   \/\/       mul     v5.4S, v6.4S, v7.S[0]\n-    __ fmlavs(v2, __ T2D, v3, v4, 1);                  \/\/       fmla    v2.2D, v3.2D, v4.D[1]\n-    __ fmlsvs(v7, __ T2S, v8, v9, 0);                  \/\/       fmls    v7.2S, v8.2S, v9.S[0]\n+    __ fmlavs(v13, __ T2S, v14, v15, 1);               \/\/       fmla    v13.2S, v14.2S, v15.S[1]\n@@ -811,8 +824,11 @@\n-    __ fmlsvs(v10, __ T2D, v11, v12, 0);               \/\/       fmls    v10.2D, v11.2D, v12.D[0]\n-    __ fmulxvs(v10, __ T2S, v11, v12, 0);              \/\/       fmulx   v10.2S, v11.2S, v12.S[0]\n-    __ mulvs(v14, __ T4S, v15, v16, 2);                \/\/       mul     v14.4S, v15.4S, v16.S[2]\n-    __ fmulxvs(v13, __ T2D, v14, v15, 1);              \/\/       fmulx   v13.2D, v14.2D, v15.D[1]\n-    __ mulvs(v2, __ T4H, v3, v4, 3);                   \/\/       mul     v2.4H, v3.4H, v4.H[3]\n-    __ mulvs(v11, __ T8H, v12, v13, 0);                \/\/       mul     v11.8H, v12.8H, v13.H[0]\n-    __ mulvs(v15, __ T2S, v0, v1, 1);                  \/\/       mul     v15.2S, v0.2S, v1.S[1]\n-    __ mulvs(v6, __ T4S, v7, v8, 0);                   \/\/       mul     v6.4S, v7.4S, v8.S[0]\n+    __ fmlavs(v5, __ T2D, v6, v7, 0);                  \/\/       fmla    v5.2D, v6.2D, v7.D[0]\n+    __ fmlsvs(v5, __ T2S, v6, v7, 1);                  \/\/       fmls    v5.2S, v6.2S, v7.S[1]\n+    __ mulvs(v12, __ T4S, v13, v14, 0);                \/\/       mul     v12.4S, v13.4S, v14.S[0]\n+    __ fmlsvs(v8, __ T2D, v9, v10, 1);                 \/\/       fmls    v8.2D, v9.2D, v10.D[1]\n+    __ fmulxvs(v1, __ T2S, v2, v3, 1);                 \/\/       fmulx   v1.2S, v2.2S, v3.S[1]\n+    __ mulvs(v7, __ T4S, v8, v9, 3);                   \/\/       mul     v7.4S, v8.4S, v9.S[3]\n+    __ fmulxvs(v9, __ T2D, v10, v11, 1);               \/\/       fmulx   v9.2D, v10.2D, v11.D[1]\n+    __ mulvs(v11, __ T4H, v12, v13, 2);                \/\/       mul     v11.4H, v12.4H, v13.H[2]\n+    __ mulvs(v7, __ T8H, v8, v9, 0);                   \/\/       mul     v7.8H, v8.8H, v9.H[0]\n+    __ mulvs(v6, __ T2S, v7, v8, 0);                   \/\/       mul     v6.2S, v7.2S, v8.S[0]\n+    __ mulvs(v5, __ T4S, v6, v7, 2);                   \/\/       mul     v5.4S, v6.4S, v7.S[2]\n@@ -821,38 +837,38 @@\n-    __ cm(Assembler::GT, v9, __ T8B, v10, v11);        \/\/       cmgt    v9.8B, v10.8B, v11.8B\n-    __ cm(Assembler::GT, v28, __ T16B, v29, v30);      \/\/       cmgt    v28.16B, v29.16B, v30.16B\n-    __ cm(Assembler::GT, v15, __ T4H, v16, v17);       \/\/       cmgt    v15.4H, v16.4H, v17.4H\n-    __ cm(Assembler::GT, v29, __ T8H, v30, v31);       \/\/       cmgt    v29.8H, v30.8H, v31.8H\n-    __ cm(Assembler::GT, v22, __ T2S, v23, v24);       \/\/       cmgt    v22.2S, v23.2S, v24.2S\n-    __ cm(Assembler::GT, v31, __ T4S, v0, v1);         \/\/       cmgt    v31.4S, v0.4S, v1.4S\n-    __ cm(Assembler::GT, v19, __ T2D, v20, v21);       \/\/       cmgt    v19.2D, v20.2D, v21.2D\n-    __ cm(Assembler::GE, v31, __ T8B, v0, v1);         \/\/       cmge    v31.8B, v0.8B, v1.8B\n-    __ cm(Assembler::GE, v5, __ T16B, v6, v7);         \/\/       cmge    v5.16B, v6.16B, v7.16B\n-    __ cm(Assembler::GE, v14, __ T4H, v15, v16);       \/\/       cmge    v14.4H, v15.4H, v16.4H\n-    __ cm(Assembler::GE, v18, __ T8H, v19, v20);       \/\/       cmge    v18.8H, v19.8H, v20.8H\n-    __ cm(Assembler::GE, v31, __ T2S, v0, v1);         \/\/       cmge    v31.2S, v0.2S, v1.2S\n-    __ cm(Assembler::GE, v18, __ T4S, v19, v20);       \/\/       cmge    v18.4S, v19.4S, v20.4S\n-    __ cm(Assembler::GE, v27, __ T2D, v28, v29);       \/\/       cmge    v27.2D, v28.2D, v29.2D\n-    __ cm(Assembler::EQ, v20, __ T8B, v21, v22);       \/\/       cmeq    v20.8B, v21.8B, v22.8B\n-    __ cm(Assembler::EQ, v16, __ T16B, v17, v18);      \/\/       cmeq    v16.16B, v17.16B, v18.16B\n-    __ cm(Assembler::EQ, v12, __ T4H, v13, v14);       \/\/       cmeq    v12.4H, v13.4H, v14.4H\n-    __ cm(Assembler::EQ, v11, __ T8H, v12, v13);       \/\/       cmeq    v11.8H, v12.8H, v13.8H\n-    __ cm(Assembler::EQ, v9, __ T2S, v10, v11);        \/\/       cmeq    v9.2S, v10.2S, v11.2S\n-    __ cm(Assembler::EQ, v6, __ T4S, v7, v8);          \/\/       cmeq    v6.4S, v7.4S, v8.4S\n-    __ cm(Assembler::EQ, v30, __ T2D, v31, v0);        \/\/       cmeq    v30.2D, v31.2D, v0.2D\n-    __ cm(Assembler::HI, v17, __ T8B, v18, v19);       \/\/       cmhi    v17.8B, v18.8B, v19.8B\n-    __ cm(Assembler::HI, v27, __ T16B, v28, v29);      \/\/       cmhi    v27.16B, v28.16B, v29.16B\n-    __ cm(Assembler::HI, v28, __ T4H, v29, v30);       \/\/       cmhi    v28.4H, v29.4H, v30.4H\n-    __ cm(Assembler::HI, v30, __ T8H, v31, v0);        \/\/       cmhi    v30.8H, v31.8H, v0.8H\n-    __ cm(Assembler::HI, v7, __ T2S, v8, v9);          \/\/       cmhi    v7.2S, v8.2S, v9.2S\n-    __ cm(Assembler::HI, v10, __ T4S, v11, v12);       \/\/       cmhi    v10.4S, v11.4S, v12.4S\n-    __ cm(Assembler::HI, v20, __ T2D, v21, v22);       \/\/       cmhi    v20.2D, v21.2D, v22.2D\n-    __ cm(Assembler::HS, v10, __ T8B, v11, v12);       \/\/       cmhs    v10.8B, v11.8B, v12.8B\n-    __ cm(Assembler::HS, v4, __ T16B, v5, v6);         \/\/       cmhs    v4.16B, v5.16B, v6.16B\n-    __ cm(Assembler::HS, v24, __ T4H, v25, v26);       \/\/       cmhs    v24.4H, v25.4H, v26.4H\n-    __ cm(Assembler::HS, v17, __ T8H, v18, v19);       \/\/       cmhs    v17.8H, v18.8H, v19.8H\n-    __ cm(Assembler::HS, v17, __ T2S, v18, v19);       \/\/       cmhs    v17.2S, v18.2S, v19.2S\n-    __ cm(Assembler::HS, v22, __ T4S, v23, v24);       \/\/       cmhs    v22.4S, v23.4S, v24.4S\n-    __ cm(Assembler::HS, v3, __ T2D, v4, v5);          \/\/       cmhs    v3.2D, v4.2D, v5.2D\n-    __ fcm(Assembler::EQ, v29, __ T2S, v30, v31);      \/\/       fcmeq   v29.2S, v30.2S, v31.2S\n-    __ fcm(Assembler::EQ, v15, __ T4S, v16, v17);      \/\/       fcmeq   v15.4S, v16.4S, v17.4S\n-    __ fcm(Assembler::EQ, v22, __ T2D, v23, v24);      \/\/       fcmeq   v22.2D, v23.2D, v24.2D\n+    __ cm(Assembler::GT, v13, __ T8B, v14, v15);       \/\/       cmgt    v13.8B, v14.8B, v15.8B\n+    __ cm(Assembler::GT, v23, __ T16B, v24, v25);      \/\/       cmgt    v23.16B, v24.16B, v25.16B\n+    __ cm(Assembler::GT, v1, __ T4H, v2, v3);          \/\/       cmgt    v1.4H, v2.4H, v3.4H\n+    __ cm(Assembler::GT, v30, __ T8H, v31, v0);        \/\/       cmgt    v30.8H, v31.8H, v0.8H\n+    __ cm(Assembler::GT, v19, __ T2S, v20, v21);       \/\/       cmgt    v19.2S, v20.2S, v21.2S\n+    __ cm(Assembler::GT, v5, __ T4S, v6, v7);          \/\/       cmgt    v5.4S, v6.4S, v7.4S\n+    __ cm(Assembler::GT, v17, __ T2D, v18, v19);       \/\/       cmgt    v17.2D, v18.2D, v19.2D\n+    __ cm(Assembler::GE, v2, __ T8B, v3, v4);          \/\/       cmge    v2.8B, v3.8B, v4.8B\n+    __ cm(Assembler::GE, v16, __ T16B, v17, v18);      \/\/       cmge    v16.16B, v17.16B, v18.16B\n+    __ cm(Assembler::GE, v22, __ T4H, v23, v24);       \/\/       cmge    v22.4H, v23.4H, v24.4H\n+    __ cm(Assembler::GE, v13, __ T8H, v14, v15);       \/\/       cmge    v13.8H, v14.8H, v15.8H\n+    __ cm(Assembler::GE, v10, __ T2S, v11, v12);       \/\/       cmge    v10.2S, v11.2S, v12.2S\n+    __ cm(Assembler::GE, v21, __ T4S, v22, v23);       \/\/       cmge    v21.4S, v22.4S, v23.4S\n+    __ cm(Assembler::GE, v29, __ T2D, v30, v31);       \/\/       cmge    v29.2D, v30.2D, v31.2D\n+    __ cm(Assembler::EQ, v27, __ T8B, v28, v29);       \/\/       cmeq    v27.8B, v28.8B, v29.8B\n+    __ cm(Assembler::EQ, v12, __ T16B, v13, v14);      \/\/       cmeq    v12.16B, v13.16B, v14.16B\n+    __ cm(Assembler::EQ, v27, __ T4H, v28, v29);       \/\/       cmeq    v27.4H, v28.4H, v29.4H\n+    __ cm(Assembler::EQ, v3, __ T8H, v4, v5);          \/\/       cmeq    v3.8H, v4.8H, v5.8H\n+    __ cm(Assembler::EQ, v1, __ T2S, v2, v3);          \/\/       cmeq    v1.2S, v2.2S, v3.2S\n+    __ cm(Assembler::EQ, v31, __ T4S, v0, v1);         \/\/       cmeq    v31.4S, v0.4S, v1.4S\n+    __ cm(Assembler::EQ, v24, __ T2D, v25, v26);       \/\/       cmeq    v24.2D, v25.2D, v26.2D\n+    __ cm(Assembler::HI, v19, __ T8B, v20, v21);       \/\/       cmhi    v19.8B, v20.8B, v21.8B\n+    __ cm(Assembler::HI, v17, __ T16B, v18, v19);      \/\/       cmhi    v17.16B, v18.16B, v19.16B\n+    __ cm(Assembler::HI, v9, __ T4H, v10, v11);        \/\/       cmhi    v9.4H, v10.4H, v11.4H\n+    __ cm(Assembler::HI, v28, __ T8H, v29, v30);       \/\/       cmhi    v28.8H, v29.8H, v30.8H\n+    __ cm(Assembler::HI, v27, __ T2S, v28, v29);       \/\/       cmhi    v27.2S, v28.2S, v29.2S\n+    __ cm(Assembler::HI, v15, __ T4S, v16, v17);       \/\/       cmhi    v15.4S, v16.4S, v17.4S\n+    __ cm(Assembler::HI, v7, __ T2D, v8, v9);          \/\/       cmhi    v7.2D, v8.2D, v9.2D\n+    __ cm(Assembler::HS, v21, __ T8B, v22, v23);       \/\/       cmhs    v21.8B, v22.8B, v23.8B\n+    __ cm(Assembler::HS, v23, __ T16B, v24, v25);      \/\/       cmhs    v23.16B, v24.16B, v25.16B\n+    __ cm(Assembler::HS, v31, __ T4H, v0, v1);         \/\/       cmhs    v31.4H, v0.4H, v1.4H\n+    __ cm(Assembler::HS, v25, __ T8H, v26, v27);       \/\/       cmhs    v25.8H, v26.8H, v27.8H\n+    __ cm(Assembler::HS, v2, __ T2S, v3, v4);          \/\/       cmhs    v2.2S, v3.2S, v4.2S\n+    __ cm(Assembler::HS, v31, __ T4S, v0, v1);         \/\/       cmhs    v31.4S, v0.4S, v1.4S\n+    __ cm(Assembler::HS, v27, __ T2D, v28, v29);       \/\/       cmhs    v27.2D, v28.2D, v29.2D\n+    __ fcm(Assembler::EQ, v18, __ T2S, v19, v20);      \/\/       fcmeq   v18.2S, v19.2S, v20.2S\n+    __ fcm(Assembler::EQ, v10, __ T4S, v11, v12);      \/\/       fcmeq   v10.4S, v11.4S, v12.4S\n+    __ fcm(Assembler::EQ, v23, __ T2D, v24, v25);      \/\/       fcmeq   v23.2D, v24.2D, v25.2D\n@@ -860,5 +876,5 @@\n-    __ fcm(Assembler::GT, v19, __ T4S, v20, v21);      \/\/       fcmgt   v19.4S, v20.4S, v21.4S\n-    __ fcm(Assembler::GT, v22, __ T2D, v23, v24);      \/\/       fcmgt   v22.2D, v23.2D, v24.2D\n-    __ fcm(Assembler::GE, v2, __ T2S, v3, v4);         \/\/       fcmge   v2.2S, v3.2S, v4.2S\n-    __ fcm(Assembler::GE, v15, __ T4S, v16, v17);      \/\/       fcmge   v15.4S, v16.4S, v17.4S\n-    __ fcm(Assembler::GE, v6, __ T2D, v7, v8);         \/\/       fcmge   v6.2D, v7.2D, v8.2D\n+    __ fcm(Assembler::GT, v3, __ T4S, v4, v5);         \/\/       fcmgt   v3.4S, v4.4S, v5.4S\n+    __ fcm(Assembler::GT, v18, __ T2D, v19, v20);      \/\/       fcmgt   v18.2D, v19.2D, v20.2D\n+    __ fcm(Assembler::GE, v0, __ T2S, v1, v2);         \/\/       fcmge   v0.2S, v1.2S, v2.2S\n+    __ fcm(Assembler::GE, v25, __ T4S, v26, v27);      \/\/       fcmge   v25.4S, v26.4S, v27.4S\n+    __ fcm(Assembler::GE, v26, __ T2D, v27, v28);      \/\/       fcmge   v26.2D, v27.2D, v28.2D\n@@ -867,6 +883,6 @@\n-    __ sve_fcm(Assembler::EQ, p6, __ S, p3, z16, 0.0); \/\/       fcmeq   p6.s, p3\/z, z16.s, #0.0\n-    __ sve_fcm(Assembler::GT, p11, __ D, p4, z1, 0.0); \/\/       fcmgt   p11.d, p4\/z, z1.d, #0.0\n-    __ sve_fcm(Assembler::GE, p2, __ S, p4, z17, 0.0); \/\/       fcmge   p2.s, p4\/z, z17.s, #0.0\n-    __ sve_fcm(Assembler::LT, p11, __ S, p5, z13, 0.0); \/\/      fcmlt   p11.s, p5\/z, z13.s, #0.0\n-    __ sve_fcm(Assembler::LE, p14, __ S, p6, z27, 0.0); \/\/      fcmle   p14.s, p6\/z, z27.s, #0.0\n-    __ sve_fcm(Assembler::NE, p1, __ D, p6, z1, 0.0);  \/\/       fcmne   p1.d, p6\/z, z1.d, #0.0\n+    __ sve_fcm(Assembler::EQ, p11, __ D, p3, z2, 0.0); \/\/       fcmeq   p11.d, p3\/z, z2.d, #0.0\n+    __ sve_fcm(Assembler::GT, p2, __ D, p7, z28, 0.0); \/\/       fcmgt   p2.d, p7\/z, z28.d, #0.0\n+    __ sve_fcm(Assembler::GE, p8, __ S, p2, z27, 0.0); \/\/       fcmge   p8.s, p2\/z, z27.s, #0.0\n+    __ sve_fcm(Assembler::LT, p14, __ S, p1, z18, 0.0); \/\/      fcmlt   p14.s, p1\/z, z18.s, #0.0\n+    __ sve_fcm(Assembler::LE, p3, __ S, p5, z15, 0.0); \/\/       fcmle   p3.s, p5\/z, z15.s, #0.0\n+    __ sve_fcm(Assembler::NE, p4, __ D, p5, z2, 0.0);  \/\/       fcmne   p4.d, p5\/z, z2.d, #0.0\n@@ -875,10 +891,10 @@\n-    __ sve_cmp(Assembler::EQ, p9, __ H, p7, z17, 11);  \/\/       cmpeq   p9.h, p7\/z, z17.h, #11\n-    __ sve_cmp(Assembler::GT, p7, __ S, p5, z7, 15);   \/\/       cmpgt   p7.s, p5\/z, z7.s, #15\n-    __ sve_cmp(Assembler::GE, p12, __ D, p6, z2, 2);   \/\/       cmpge   p12.d, p6\/z, z2.d, #2\n-    __ sve_cmp(Assembler::LT, p5, __ S, p0, z23, 2);   \/\/       cmplt   p5.s, p0\/z, z23.s, #2\n-    __ sve_cmp(Assembler::LE, p0, __ D, p5, z25, -14); \/\/       cmple   p0.d, p5\/z, z25.d, #-14\n-    __ sve_cmp(Assembler::NE, p9, __ B, p7, z12, 14);  \/\/       cmpne   p9.b, p7\/z, z12.b, #14\n-    __ sve_cmp(Assembler::HS, p14, __ D, p1, z16, 37); \/\/       cmphs   p14.d, p1\/z, z16.d, #37\n-    __ sve_cmp(Assembler::HI, p14, __ B, p1, z18, 29); \/\/       cmphi   p14.b, p1\/z, z18.b, #29\n-    __ sve_cmp(Assembler::LS, p7, __ S, p2, z9, 10);   \/\/       cmpls   p7.s, p2\/z, z9.s, #10\n-    __ sve_cmp(Assembler::LO, p14, __ D, p1, z21, 111); \/\/      cmplo   p14.d, p1\/z, z21.d, #111\n+    __ sve_cmp(Assembler::EQ, p15, __ D, p0, z5, 1);   \/\/       cmpeq   p15.d, p0\/z, z5.d, #1\n+    __ sve_cmp(Assembler::GT, p7, __ D, p2, z4, 12);   \/\/       cmpgt   p7.d, p2\/z, z4.d, #12\n+    __ sve_cmp(Assembler::GE, p11, __ D, p6, z27, 7);  \/\/       cmpge   p11.d, p6\/z, z27.d, #7\n+    __ sve_cmp(Assembler::LT, p0, __ B, p4, z4, -16);  \/\/       cmplt   p0.b, p4\/z, z4.b, #-16\n+    __ sve_cmp(Assembler::LE, p2, __ B, p2, z15, -9);  \/\/       cmple   p2.b, p2\/z, z15.b, #-9\n+    __ sve_cmp(Assembler::NE, p2, __ D, p1, z10, 4);   \/\/       cmpne   p2.d, p1\/z, z10.d, #4\n+    __ sve_cmp(Assembler::HS, p11, __ B, p2, z21, 34); \/\/       cmphs   p11.b, p2\/z, z21.b, #34\n+    __ sve_cmp(Assembler::HI, p8, __ B, p4, z31, 8);   \/\/       cmphi   p8.b, p4\/z, z31.b, #8\n+    __ sve_cmp(Assembler::LS, p6, __ D, p0, z30, 109); \/\/       cmpls   p6.d, p0\/z, z30.d, #109\n+    __ sve_cmp(Assembler::LO, p11, __ H, p3, z29, 114); \/\/      cmplo   p11.h, p3\/z, z29.h, #114\n@@ -1139,9 +1155,9 @@\n-    __ swp(Assembler::xword, r0, r17, r15);            \/\/       swp     x0, x17, [x15]\n-    __ ldadd(Assembler::xword, r4, r26, r8);           \/\/       ldadd   x4, x26, [x8]\n-    __ ldbic(Assembler::xword, r28, r22, r27);         \/\/       ldclr   x28, x22, [x27]\n-    __ ldeor(Assembler::xword, r27, r25, r23);         \/\/       ldeor   x27, x25, [x23]\n-    __ ldorr(Assembler::xword, r0, r4, r6);            \/\/       ldset   x0, x4, [x6]\n-    __ ldsmin(Assembler::xword, r16, r0, r4);          \/\/       ldsmin  x16, x0, [x4]\n-    __ ldsmax(Assembler::xword, r15, r1, r10);         \/\/       ldsmax  x15, x1, [x10]\n-    __ ldumin(Assembler::xword, r7, r5, r10);          \/\/       ldumin  x7, x5, [x10]\n-    __ ldumax(Assembler::xword, r28, r7, r20);         \/\/       ldumax  x28, x7, [x20]\n+    __ swp(Assembler::xword, r17, r24, r5);            \/\/       swp     x17, x24, [x5]\n+    __ ldadd(Assembler::xword, r2, r14, r10);          \/\/       ldadd   x2, x14, [x10]\n+    __ ldbic(Assembler::xword, r16, r11, r27);         \/\/       ldclr   x16, x11, [x27]\n+    __ ldeor(Assembler::xword, r23, r12, r4);          \/\/       ldeor   x23, x12, [x4]\n+    __ ldorr(Assembler::xword, r22, r17, r4);          \/\/       ldset   x22, x17, [x4]\n+    __ ldsmin(Assembler::xword, r1, r19, r16);         \/\/       ldsmin  x1, x19, [x16]\n+    __ ldsmax(Assembler::xword, r16, r13, r14);        \/\/       ldsmax  x16, x13, [x14]\n+    __ ldumin(Assembler::xword, r12, r2, r17);         \/\/       ldumin  x12, x2, [x17]\n+    __ ldumax(Assembler::xword, r3, r21, r23);         \/\/       ldumax  x3, x21, [x23]\n@@ -1150,9 +1166,9 @@\n-    __ swpa(Assembler::xword, r23, r21, r6);           \/\/       swpa    x23, x21, [x6]\n-    __ ldadda(Assembler::xword, r11, r8, r17);         \/\/       ldadda  x11, x8, [x17]\n-    __ ldbica(Assembler::xword, zr, r6, r17);          \/\/       ldclra  xzr, x6, [x17]\n-    __ ldeora(Assembler::xword, r2, r12, r30);         \/\/       ldeora  x2, x12, [x30]\n-    __ ldorra(Assembler::xword, r29, r3, r27);         \/\/       ldseta  x29, x3, [x27]\n-    __ ldsmina(Assembler::xword, r22, r29, r14);       \/\/       ldsmina x22, x29, [x14]\n-    __ ldsmaxa(Assembler::xword, r13, r28, r17);       \/\/       ldsmaxa x13, x28, [x17]\n-    __ ldumina(Assembler::xword, r24, r5, r2);         \/\/       ldumina x24, x5, [x2]\n-    __ ldumaxa(Assembler::xword, r14, r10, r16);       \/\/       ldumaxa x14, x10, [x16]\n+    __ swpa(Assembler::xword, r5, r6, r7);             \/\/       swpa    x5, x6, [x7]\n+    __ ldadda(Assembler::xword, r19, r13, r28);        \/\/       ldadda  x19, x13, [x28]\n+    __ ldbica(Assembler::xword, r17, r16, r6);         \/\/       ldclra  x17, x16, [x6]\n+    __ ldeora(Assembler::xword, r2, r29, r3);          \/\/       ldeora  x2, x29, [x3]\n+    __ ldorra(Assembler::xword, r4, r6, r15);          \/\/       ldseta  x4, x6, [x15]\n+    __ ldsmina(Assembler::xword, r20, r13, r12);       \/\/       ldsmina x20, x13, [x12]\n+    __ ldsmaxa(Assembler::xword, r20, r8, r25);        \/\/       ldsmaxa x20, x8, [x25]\n+    __ ldumina(Assembler::xword, r20, r19, r0);        \/\/       ldumina x20, x19, [x0]\n+    __ ldumaxa(Assembler::xword, r11, r24, r6);        \/\/       ldumaxa x11, x24, [x6]\n@@ -1161,9 +1177,9 @@\n-    __ swpal(Assembler::xword, r11, r27, r23);         \/\/       swpal   x11, x27, [x23]\n-    __ ldaddal(Assembler::xword, r12, r4, r22);        \/\/       ldaddal x12, x4, [x22]\n-    __ ldbical(Assembler::xword, r17, r4, r1);         \/\/       ldclral x17, x4, [x1]\n-    __ ldeoral(Assembler::xword, r19, r16, r15);       \/\/       ldeoral x19, x16, [x15]\n-    __ ldorral(Assembler::xword, r13, r14, r12);       \/\/       ldsetal x13, x14, [x12]\n-    __ ldsminal(Assembler::xword, r2, r17, r3);        \/\/       ldsminal        x2, x17, [x3]\n-    __ ldsmaxal(Assembler::xword, r21, r23, r5);       \/\/       ldsmaxal        x21, x23, [x5]\n-    __ lduminal(Assembler::xword, r6, r7, r19);        \/\/       lduminal        x6, x7, [x19]\n-    __ ldumaxal(Assembler::xword, r13, r28, r17);      \/\/       ldumaxal        x13, x28, [x17]\n+    __ swpal(Assembler::xword, r20, zr, r14);          \/\/       swpal   x20, xzr, [x14]\n+    __ ldaddal(Assembler::xword, r16, r6, r0);         \/\/       ldaddal x16, x6, [x0]\n+    __ ldbical(Assembler::xword, r7, r15, r19);        \/\/       ldclral x7, x15, [x19]\n+    __ ldeoral(Assembler::xword, r26, r9, r10);        \/\/       ldeoral x26, x9, [x10]\n+    __ ldorral(Assembler::xword, r23, r21, r22);       \/\/       ldsetal x23, x21, [x22]\n+    __ ldsminal(Assembler::xword, r28, r2, r3);        \/\/       ldsminal        x28, x2, [x3]\n+    __ ldsmaxal(Assembler::xword, r15, r19, r20);      \/\/       ldsmaxal        x15, x19, [x20]\n+    __ lduminal(Assembler::xword, r7, r4, r29);        \/\/       lduminal        x7, x4, [x29]\n+    __ ldumaxal(Assembler::xword, r7, r0, r9);         \/\/       ldumaxal        x7, x0, [x9]\n@@ -1172,9 +1188,9 @@\n-    __ swpl(Assembler::xword, r16, r6, r2);            \/\/       swpl    x16, x6, [x2]\n-    __ ldaddl(Assembler::xword, r29, r3, r4);          \/\/       ldaddl  x29, x3, [x4]\n-    __ ldbicl(Assembler::xword, r6, r16, r20);         \/\/       ldclrl  x6, x16, [x20]\n-    __ ldeorl(Assembler::xword, r13, r12, r20);        \/\/       ldeorl  x13, x12, [x20]\n-    __ ldorrl(Assembler::xword, r8, r25, r20);         \/\/       ldsetl  x8, x25, [x20]\n-    __ ldsminl(Assembler::xword, r19, r0, r11);        \/\/       ldsminl x19, x0, [x11]\n-    __ ldsmaxl(Assembler::xword, r24, r6, r20);        \/\/       ldsmaxl x24, x6, [x20]\n-    __ lduminl(Assembler::xword, zr, r14, r16);        \/\/       lduminl xzr, x14, [x16]\n-    __ ldumaxl(Assembler::xword, r6, r0, r7);          \/\/       ldumaxl x6, x0, [x7]\n+    __ swpl(Assembler::xword, r16, r20, r23);          \/\/       swpl    x16, x20, [x23]\n+    __ ldaddl(Assembler::xword, r4, r16, r10);         \/\/       ldaddl  x4, x16, [x10]\n+    __ ldbicl(Assembler::xword, r23, r11, r25);        \/\/       ldclrl  x23, x11, [x25]\n+    __ ldeorl(Assembler::xword, r6, zr, r16);          \/\/       ldeorl  x6, xzr, [x16]\n+    __ ldorrl(Assembler::xword, r13, r23, r12);        \/\/       ldsetl  x13, x23, [x12]\n+    __ ldsminl(Assembler::xword, r1, r14, r9);         \/\/       ldsminl x1, x14, [x9]\n+    __ ldsmaxl(Assembler::xword, r21, r16, r26);       \/\/       ldsmaxl x21, x16, [x26]\n+    __ lduminl(Assembler::xword, r15, r4, r4);         \/\/       lduminl x15, x4, [x4]\n+    __ ldumaxl(Assembler::xword, r16, r8, r6);         \/\/       ldumaxl x16, x8, [x6]\n@@ -1183,9 +1199,9 @@\n-    __ swp(Assembler::word, r15, r19, r26);            \/\/       swp     w15, w19, [x26]\n-    __ ldadd(Assembler::word, r9, r10, r23);           \/\/       ldadd   w9, w10, [x23]\n-    __ ldbic(Assembler::word, r21, r22, r28);          \/\/       ldclr   w21, w22, [x28]\n-    __ ldeor(Assembler::word, r2, r3, r15);            \/\/       ldeor   w2, w3, [x15]\n-    __ ldorr(Assembler::word, r19, r20, r7);           \/\/       ldset   w19, w20, [x7]\n-    __ ldsmin(Assembler::word, r4, r29, r7);           \/\/       ldsmin  w4, w29, [x7]\n-    __ ldsmax(Assembler::word, r0, r9, r16);           \/\/       ldsmax  w0, w9, [x16]\n-    __ ldumin(Assembler::word, r20, r23, r4);          \/\/       ldumin  w20, w23, [x4]\n-    __ ldumax(Assembler::word, r16, r10, r23);         \/\/       ldumax  w16, w10, [x23]\n+    __ swp(Assembler::word, r30, r4, r29);             \/\/       swp     w30, w4, [x29]\n+    __ ldadd(Assembler::word, r17, r29, r26);          \/\/       ldadd   w17, w29, [x26]\n+    __ ldbic(Assembler::word, r9, r15, r2);            \/\/       ldclr   w9, w15, [x2]\n+    __ ldeor(Assembler::word, r11, r29, r3);           \/\/       ldeor   w11, w29, [x3]\n+    __ ldorr(Assembler::word, r7, r1, r27);            \/\/       ldset   w7, w1, [x27]\n+    __ ldsmin(Assembler::word, r21, r16, r14);         \/\/       ldsmin  w21, w16, [x14]\n+    __ ldsmax(Assembler::word, r8, r16, r22);          \/\/       ldsmax  w8, w16, [x22]\n+    __ ldumin(Assembler::word, r25, r5, r20);          \/\/       ldumin  w25, w5, [x20]\n+    __ ldumax(Assembler::word, r21, r16, r23);         \/\/       ldumax  w21, w16, [x23]\n@@ -1194,9 +1210,9 @@\n-    __ swpa(Assembler::word, r11, r25, r6);            \/\/       swpa    w11, w25, [x6]\n-    __ ldadda(Assembler::word, zr, r16, r13);          \/\/       ldadda  wzr, w16, [x13]\n-    __ ldbica(Assembler::word, r23, r12, r1);          \/\/       ldclra  w23, w12, [x1]\n-    __ ldeora(Assembler::word, r14, r9, r21);          \/\/       ldeora  w14, w9, [x21]\n-    __ ldorra(Assembler::word, r16, r26, r15);         \/\/       ldseta  w16, w26, [x15]\n-    __ ldsmina(Assembler::word, r4, r4, r15);          \/\/       ldsmina w4, w4, [x15]\n-    __ ldsmaxa(Assembler::word, r8, r6, r30);          \/\/       ldsmaxa w8, w6, [x30]\n-    __ ldumina(Assembler::word, r4, r29, r17);         \/\/       ldumina w4, w29, [x17]\n-    __ ldumaxa(Assembler::word, r29, r26, r9);         \/\/       ldumaxa w29, w26, [x9]\n+    __ swpa(Assembler::word, r16, r30, r20);           \/\/       swpa    w16, w30, [x20]\n+    __ ldadda(Assembler::word, r20, r0, r4);           \/\/       ldadda  w20, w0, [x4]\n+    __ ldbica(Assembler::word, r19, r24, r4);          \/\/       ldclra  w19, w24, [x4]\n+    __ ldeora(Assembler::word, r20, r4, r24);          \/\/       ldeora  w20, w4, [x24]\n+    __ ldorra(Assembler::word, r26, r19, r2);          \/\/       ldseta  w26, w19, [x2]\n+    __ ldsmina(Assembler::word, r8, r8, r14);          \/\/       ldsmina w8, w8, [x14]\n+    __ ldsmaxa(Assembler::word, r24, r16, sp);         \/\/       ldsmaxa w24, w16, [sp]\n+    __ ldumina(Assembler::word, r22, r4, sp);          \/\/       ldumina w22, w4, [sp]\n+    __ ldumaxa(Assembler::word, r1, r10, r20);         \/\/       ldumaxa w1, w10, [x20]\n@@ -1205,9 +1221,9 @@\n-    __ swpal(Assembler::word, r15, r2, r11);           \/\/       swpal   w15, w2, [x11]\n-    __ ldaddal(Assembler::word, r29, r3, r7);          \/\/       ldaddal w29, w3, [x7]\n-    __ ldbical(Assembler::word, r1, r27, r21);         \/\/       ldclral w1, w27, [x21]\n-    __ ldeoral(Assembler::word, r16, r14, r8);         \/\/       ldeoral w16, w14, [x8]\n-    __ ldorral(Assembler::word, r16, r22, r25);        \/\/       ldsetal w16, w22, [x25]\n-    __ ldsminal(Assembler::word, r5, r20, r21);        \/\/       ldsminal        w5, w20, [x21]\n-    __ ldsmaxal(Assembler::word, r16, r23, r16);       \/\/       ldsmaxal        w16, w23, [x16]\n-    __ lduminal(Assembler::word, r30, r20, r20);       \/\/       lduminal        w30, w20, [x20]\n-    __ ldumaxal(Assembler::word, r0, r4, r19);         \/\/       ldumaxal        w0, w4, [x19]\n+    __ swpal(Assembler::word, r12, r0, r9);            \/\/       swpal   w12, w0, [x9]\n+    __ ldaddal(Assembler::word, r7, r24, r15);         \/\/       ldaddal w7, w24, [x15]\n+    __ ldbical(Assembler::word, r4, r27, r6);          \/\/       ldclral w4, w27, [x6]\n+    __ ldeoral(Assembler::word, r10, r27, r24);        \/\/       ldeoral w10, w27, [x24]\n+    __ ldorral(Assembler::word, r13, r16, sp);         \/\/       ldsetal w13, w16, [sp]\n+    __ ldsminal(Assembler::word, r22, r22, r20);       \/\/       ldsminal        w22, w22, [x20]\n+    __ ldsmaxal(Assembler::word, zr, r29, r9);         \/\/       ldsmaxal        wzr, w29, [x9]\n+    __ lduminal(Assembler::word, r14, r20, r7);        \/\/       lduminal        w14, w20, [x7]\n+    __ ldumaxal(Assembler::word, r20, r28, r9);        \/\/       ldumaxal        w20, w28, [x9]\n@@ -1216,9 +1232,9 @@\n-    __ swpl(Assembler::word, r24, r4, r20);            \/\/       swpl    w24, w4, [x20]\n-    __ ldaddl(Assembler::word, r4, r24, r26);          \/\/       ldaddl  w4, w24, [x26]\n-    __ ldbicl(Assembler::word, r19, r2, r8);           \/\/       ldclrl  w19, w2, [x8]\n-    __ ldeorl(Assembler::word, r8, r14, r24);          \/\/       ldeorl  w8, w14, [x24]\n-    __ ldorrl(Assembler::word, r16, zr, r22);          \/\/       ldsetl  w16, wzr, [x22]\n-    __ ldsminl(Assembler::word, r4, zr, r1);           \/\/       ldsminl w4, wzr, [x1]\n-    __ ldsmaxl(Assembler::word, r10, r20, r12);        \/\/       ldsmaxl w10, w20, [x12]\n-    __ lduminl(Assembler::word, r0, r9, r7);           \/\/       lduminl w0, w9, [x7]\n-    __ ldumaxl(Assembler::word, r24, r16, r4);         \/\/       ldumaxl w24, w16, [x4]\n+    __ swpl(Assembler::word, r11, r14, r12);           \/\/       swpl    w11, w14, [x12]\n+    __ ldaddl(Assembler::word, r20, r1, r24);          \/\/       ldaddl  w20, w1, [x24]\n+    __ ldbicl(Assembler::word, r9, r19, r13);          \/\/       ldclrl  w9, w19, [x13]\n+    __ ldeorl(Assembler::word, r19, r16, r16);         \/\/       ldeorl  w19, w16, [x16]\n+    __ ldorrl(Assembler::word, r5, r0, r3);            \/\/       ldsetl  w5, w0, [x3]\n+    __ ldsminl(Assembler::word, r12, r8, r15);         \/\/       ldsminl w12, w8, [x15]\n+    __ ldsmaxl(Assembler::word, r15, r16, r4);         \/\/       ldsmaxl w15, w16, [x4]\n+    __ lduminl(Assembler::word, r15, r30, r5);         \/\/       lduminl w15, w30, [x5]\n+    __ ldumaxl(Assembler::word, r0, r10, r22);         \/\/       ldumaxl w0, w10, [x22]\n@@ -1227,4 +1243,4 @@\n-    __ bcax(v27, __ T16B, v6, v10, v27);               \/\/       bcax            v27.16B, v6.16B, v10.16B, v27.16B\n-    __ eor3(v24, __ T16B, v13, v16, v31);              \/\/       eor3            v24.16B, v13.16B, v16.16B, v31.16B\n-    __ rax1(v22, __ T2D, v22, v20);                    \/\/       rax1            v22.2D, v22.2D, v20.2D\n-    __ xar(v31, __ T2D, v29, v9, 28);                  \/\/       xar             v31.2D, v29.2D, v9.2D, #28\n+    __ bcax(v27, __ T16B, v3, v0, v9);                 \/\/       bcax            v27.16B, v3.16B, v0.16B, v9.16B\n+    __ eor3(v19, __ T16B, v29, v10, v24);              \/\/       eor3            v19.16B, v29.16B, v10.16B, v24.16B\n+    __ rax1(v4, __ T2D, v20, v7);                      \/\/       rax1            v4.2D, v20.2D, v7.2D\n+    __ xar(v24, __ T2D, v29, v14, 43);                 \/\/       xar             v24.2D, v29.2D, v14.2D, #43\n@@ -1233,4 +1249,4 @@\n-    __ sha512h(v20, __ T2D, v7, v20);                  \/\/       sha512h         q20, q7, v20.2D\n-    __ sha512h2(v28, __ T2D, v9, v11);                 \/\/       sha512h2                q28, q9, v11.2D\n-    __ sha512su0(v14, __ T2D, v12);                    \/\/       sha512su0               v14.2D, v12.2D\n-    __ sha512su1(v20, __ T2D, v1, v24);                \/\/       sha512su1               v20.2D, v1.2D, v24.2D\n+    __ sha512h(v11, __ T2D, v27, v13);                 \/\/       sha512h         q11, q27, v13.2D\n+    __ sha512h2(v18, __ T2D, v31, v17);                \/\/       sha512h2                q18, q31, v17.2D\n+    __ sha512su0(v14, __ T2D, v3);                     \/\/       sha512su0               v14.2D, v3.2D\n+    __ sha512su1(v30, __ T2D, v16, v22);               \/\/       sha512su1               v30.2D, v16.2D, v22.2D\n@@ -1239,5 +1255,5 @@\n-    __ sve_add(z9, __ S, 108u);                        \/\/       add     z9.s, z9.s, #0x6c\n-    __ sve_sub(z19, __ S, 132u);                       \/\/       sub     z19.s, z19.s, #0x84\n-    __ sve_and(z5, __ B, 124u);                        \/\/       and     z5.b, z5.b, #0x7c\n-    __ sve_eor(z8, __ H, 32768u);                      \/\/       eor     z8.h, z8.h, #0x8000\n-    __ sve_orr(z4, __ H, 508u);                        \/\/       orr     z4.h, z4.h, #0x1fc\n+    __ sve_add(z20, __ B, 163u);                       \/\/       add     z20.b, z20.b, #0xa3\n+    __ sve_sub(z3, __ B, 215u);                        \/\/       sub     z3.b, z3.b, #0xd7\n+    __ sve_and(z19, __ H, 33279u);                     \/\/       and     z19.h, z19.h, #0x81ff\n+    __ sve_eor(z21, __ B, 12u);                        \/\/       eor     z21.b, z21.b, #0xc\n+    __ sve_orr(z24, __ H, 8064u);                      \/\/       orr     z24.h, z24.h, #0x1f80\n@@ -1246,5 +1262,5 @@\n-    __ sve_add(z0, __ H, 181u);                        \/\/       add     z0.h, z0.h, #0xb5\n-    __ sve_sub(z27, __ B, 7u);                         \/\/       sub     z27.b, z27.b, #0x7\n-    __ sve_and(z9, __ S, 130023424u);                  \/\/       and     z9.s, z9.s, #0x7c00000\n-    __ sve_eor(z24, __ B, 62u);                        \/\/       eor     z24.b, z24.b, #0x3e\n-    __ sve_orr(z24, __ D, 18428729675200069887u);      \/\/       orr     z24.d, z24.d, #0xffc00000000000ff\n+    __ sve_add(z21, __ H, 139u);                       \/\/       add     z21.h, z21.h, #0x8b\n+    __ sve_sub(z30, __ H, 26u);                        \/\/       sub     z30.h, z30.h, #0x1a\n+    __ sve_and(z3, __ S, 122880u);                     \/\/       and     z3.s, z3.s, #0x1e000\n+    __ sve_eor(z24, __ D, 18158513714670600195u);      \/\/       eor     z24.d, z24.d, #0xfc000003fc000003\n+    __ sve_orr(z23, __ B, 191u);                       \/\/       orr     z23.b, z23.b, #0xbf\n@@ -1253,5 +1269,5 @@\n-    __ sve_add(z11, __ D, 104u);                       \/\/       add     z11.d, z11.d, #0x68\n-    __ sve_sub(z18, __ D, 142u);                       \/\/       sub     z18.d, z18.d, #0x8e\n-    __ sve_and(z14, __ B, 131u);                       \/\/       and     z14.b, z14.b, #0x83\n-    __ sve_eor(z22, __ S, 4042322160u);                \/\/       eor     z22.s, z22.s, #0xf0f0f0f0\n-    __ sve_orr(z3, __ B, 225u);                        \/\/       orr     z3.b, z3.b, #0xe1\n+    __ sve_add(z14, __ B, 66u);                        \/\/       add     z14.b, z14.b, #0x42\n+    __ sve_sub(z26, __ B, 180u);                       \/\/       sub     z26.b, z26.b, #0xb4\n+    __ sve_and(z18, __ S, 253952u);                    \/\/       and     z18.s, z18.s, #0x3e000\n+    __ sve_eor(z9, __ S, 16744448u);                   \/\/       eor     z9.s, z9.s, #0xff8000\n+    __ sve_orr(z12, __ H, 33279u);                     \/\/       orr     z12.h, z12.h, #0x81ff\n@@ -1260,5 +1276,5 @@\n-    __ sve_add(z9, __ S, 142u);                        \/\/       add     z9.s, z9.s, #0x8e\n-    __ sve_sub(z21, __ B, 36u);                        \/\/       sub     z21.b, z21.b, #0x24\n-    __ sve_and(z2, __ D, 8796093020160u);              \/\/       and     z2.d, z2.d, #0x7fffffff800\n-    __ sve_eor(z11, __ S, 3221229567u);                \/\/       eor     z11.s, z11.s, #0xc0000fff\n-    __ sve_orr(z30, __ H, 126u);                       \/\/       orr     z30.h, z30.h, #0x7e\n+    __ sve_add(z11, __ H, 206u);                       \/\/       add     z11.h, z11.h, #0xce\n+    __ sve_sub(z18, __ D, 154u);                       \/\/       sub     z18.d, z18.d, #0x9a\n+    __ sve_and(z9, __ S, 4294459391u);                 \/\/       and     z9.s, z9.s, #0xfff83fff\n+    __ sve_eor(z23, __ D, 562675075514368u);           \/\/       eor     z23.d, z23.d, #0x1ffc000000000\n+    __ sve_orr(z8, __ B, 243u);                        \/\/       orr     z8.b, z8.b, #0xf3\n@@ -1267,5 +1283,5 @@\n-    __ sve_add(z23, __ H, 29u);                        \/\/       add     z23.h, z23.h, #0x1d\n-    __ sve_sub(z24, __ D, 26u);                        \/\/       sub     z24.d, z24.d, #0x1a\n-    __ sve_and(z19, __ S, 4294049777u);                \/\/       and     z19.s, z19.s, #0xfff1fff1\n-    __ sve_eor(z21, __ H, 1008u);                      \/\/       eor     z21.h, z21.h, #0x3f0\n-    __ sve_orr(z26, __ B, 131u);                       \/\/       orr     z26.b, z26.b, #0x83\n+    __ sve_add(z10, __ B, 121u);                       \/\/       add     z10.b, z10.b, #0x79\n+    __ sve_sub(z25, __ S, 172u);                       \/\/       sub     z25.s, z25.s, #0xac\n+    __ sve_and(z0, __ B, 239u);                        \/\/       and     z0.b, z0.b, #0xef\n+    __ sve_eor(z5, __ D, 17870287719452639231u);       \/\/       eor     z5.d, z5.d, #0xf80003ffffffffff\n+    __ sve_orr(z17, __ B, 128u);                       \/\/       orr     z17.b, z17.b, #0x80\n@@ -1274,5 +1290,5 @@\n-    __ sve_add(z17, __ B, 31u);                        \/\/       add     z17.b, z17.b, #0x1f\n-    __ sve_sub(z9, __ S, 97u);                         \/\/       sub     z9.s, z9.s, #0x61\n-    __ sve_and(z8, __ H, 49155u);                      \/\/       and     z8.h, z8.h, #0xc003\n-    __ sve_eor(z17, __ H, 57855u);                     \/\/       eor     z17.h, z17.h, #0xe1ff\n-    __ sve_orr(z18, __ D, 2251799811588096u);          \/\/       orr     z18.d, z18.d, #0x7ffffffe00000\n+    __ sve_add(z30, __ H, 3u);                         \/\/       add     z30.h, z30.h, #0x3\n+    __ sve_sub(z18, __ B, 253u);                       \/\/       sub     z18.b, z18.b, #0xfd\n+    __ sve_and(z21, __ S, 4294965263u);                \/\/       and     z21.s, z21.s, #0xfffff80f\n+    __ sve_eor(z12, __ H, 1u);                         \/\/       eor     z12.h, z12.h, #0x1\n+    __ sve_orr(z15, __ S, 1u);                         \/\/       orr     z15.s, z15.s, #0x1\n@@ -1281,66 +1297,66 @@\n-    __ sve_add(z16, __ S, z15, z27);                   \/\/       add     z16.s, z15.s, z27.s\n-    __ sve_sub(z28, __ H, z22, z8);                    \/\/       sub     z28.h, z22.h, z8.h\n-    __ sve_fadd(z5, __ S, z28, z28);                   \/\/       fadd    z5.s, z28.s, z28.s\n-    __ sve_fmul(z0, __ D, z15, z25);                   \/\/       fmul    z0.d, z15.d, z25.d\n-    __ sve_fsub(z21, __ D, z0, z3);                    \/\/       fsub    z21.d, z0.d, z3.d\n-    __ sve_sqadd(z26, __ D, z5, z26);                  \/\/       sqadd   z26.d, z5.d, z26.d\n-    __ sve_sqsub(z19, __ H, z17, z1);                  \/\/       sqsub   z19.h, z17.h, z1.h\n-    __ sve_uqadd(z14, __ B, z30, z14);                 \/\/       uqadd   z14.b, z30.b, z14.b\n-    __ sve_uqsub(z18, __ S, z2, z31);                  \/\/       uqsub   z18.s, z2.s, z31.s\n-    __ sve_abs(z23, __ H, p5, z30);                    \/\/       abs     z23.h, p5\/m, z30.h\n-    __ sve_add(z8, __ H, p0, z0);                      \/\/       add     z8.h, p0\/m, z8.h, z0.h\n-    __ sve_and(z23, __ S, p5, z0);                     \/\/       and     z23.s, p5\/m, z23.s, z0.s\n-    __ sve_asr(z26, __ H, p6, z24);                    \/\/       asr     z26.h, p6\/m, z26.h, z24.h\n-    __ sve_bic(z22, __ B, p5, z2);                     \/\/       bic     z22.b, p5\/m, z22.b, z2.b\n-    __ sve_clz(z11, __ S, p5, z12);                    \/\/       clz     z11.s, p5\/m, z12.s\n-    __ sve_cnt(z24, __ D, p6, z9);                     \/\/       cnt     z24.d, p6\/m, z9.d\n-    __ sve_eor(z17, __ S, p5, z20);                    \/\/       eor     z17.s, p5\/m, z17.s, z20.s\n-    __ sve_lsl(z4, __ D, p5, z13);                     \/\/       lsl     z4.d, p5\/m, z4.d, z13.d\n-    __ sve_lsr(z22, __ D, p7, z31);                    \/\/       lsr     z22.d, p7\/m, z22.d, z31.d\n-    __ sve_mul(z18, __ H, p4, z15);                    \/\/       mul     z18.h, p4\/m, z18.h, z15.h\n-    __ sve_neg(z13, __ B, p7, z20);                    \/\/       neg     z13.b, p7\/m, z20.b\n-    __ sve_not(z1, __ B, p3, z14);                     \/\/       not     z1.b, p3\/m, z14.b\n-    __ sve_orr(z7, __ S, p2, z12);                     \/\/       orr     z7.s, p2\/m, z7.s, z12.s\n-    __ sve_rbit(z4, __ B, p6, z15);                    \/\/       rbit    z4.b, p6\/m, z15.b\n-    __ sve_revb(z3, __ S, p7, z1);                     \/\/       revb    z3.s, p7\/m, z1.s\n-    __ sve_smax(z5, __ D, p5, z31);                    \/\/       smax    z5.d, p5\/m, z5.d, z31.d\n-    __ sve_smin(z13, __ H, p3, z9);                    \/\/       smin    z13.h, p3\/m, z13.h, z9.h\n-    __ sve_umax(z30, __ D, p0, z15);                   \/\/       umax    z30.d, p0\/m, z30.d, z15.d\n-    __ sve_umin(z3, __ H, p0, z26);                    \/\/       umin    z3.h, p0\/m, z3.h, z26.h\n-    __ sve_sub(z25, __ D, p2, z1);                     \/\/       sub     z25.d, p2\/m, z25.d, z1.d\n-    __ sve_fabs(z10, __ D, p3, z1);                    \/\/       fabs    z10.d, p3\/m, z1.d\n-    __ sve_fadd(z26, __ D, p1, z29);                   \/\/       fadd    z26.d, p1\/m, z26.d, z29.d\n-    __ sve_fdiv(z17, __ S, p1, z28);                   \/\/       fdiv    z17.s, p1\/m, z17.s, z28.s\n-    __ sve_fmax(z1, __ S, p7, z11);                    \/\/       fmax    z1.s, p7\/m, z1.s, z11.s\n-    __ sve_fmin(z1, __ D, p0, z1);                     \/\/       fmin    z1.d, p0\/m, z1.d, z1.d\n-    __ sve_fmul(z27, __ S, p3, z2);                    \/\/       fmul    z27.s, p3\/m, z27.s, z2.s\n-    __ sve_fneg(z30, __ S, p4, z25);                   \/\/       fneg    z30.s, p4\/m, z25.s\n-    __ sve_frintm(z2, __ D, p6, z3);                   \/\/       frintm  z2.d, p6\/m, z3.d\n-    __ sve_frintn(z29, __ D, p3, z3);                  \/\/       frintn  z29.d, p3\/m, z3.d\n-    __ sve_frintp(z14, __ D, p4, z28);                 \/\/       frintp  z14.d, p4\/m, z28.d\n-    __ sve_fsqrt(z4, __ D, p2, z27);                   \/\/       fsqrt   z4.d, p2\/m, z27.d\n-    __ sve_fsub(z2, __ D, p4, z1);                     \/\/       fsub    z2.d, p4\/m, z2.d, z1.d\n-    __ sve_fmad(z7, __ D, p5, z31, z28);               \/\/       fmad    z7.d, p5\/m, z31.d, z28.d\n-    __ sve_fmla(z10, __ S, p5, z17, z29);              \/\/       fmla    z10.s, p5\/m, z17.s, z29.s\n-    __ sve_fmls(z22, __ S, p1, z12, z24);              \/\/       fmls    z22.s, p1\/m, z12.s, z24.s\n-    __ sve_fmsb(z9, __ S, p2, z11, z0);                \/\/       fmsb    z9.s, p2\/m, z11.s, z0.s\n-    __ sve_fnmad(z23, __ S, p5, z20, z4);              \/\/       fnmad   z23.s, p5\/m, z20.s, z4.s\n-    __ sve_fnmsb(z15, __ D, p3, z4, z30);              \/\/       fnmsb   z15.d, p3\/m, z4.d, z30.d\n-    __ sve_fnmla(z27, __ S, p1, z21, z26);             \/\/       fnmla   z27.s, p1\/m, z21.s, z26.s\n-    __ sve_fnmls(z31, __ S, p0, z25, z4);              \/\/       fnmls   z31.s, p0\/m, z25.s, z4.s\n-    __ sve_mla(z6, __ D, p0, z21, z7);                 \/\/       mla     z6.d, p0\/m, z21.d, z7.d\n-    __ sve_mls(z24, __ S, p7, z24, z31);               \/\/       mls     z24.s, p7\/m, z24.s, z31.s\n-    __ sve_and(z1, z10, z12);                          \/\/       and     z1.d, z10.d, z12.d\n-    __ sve_eor(z13, z8, z25);                          \/\/       eor     z13.d, z8.d, z25.d\n-    __ sve_orr(z1, z31, z23);                          \/\/       orr     z1.d, z31.d, z23.d\n-    __ sve_bic(z20, z0, z21);                          \/\/       bic     z20.d, z0.d, z21.d\n-    __ sve_uzp1(z31, __ S, z29, z27);                  \/\/       uzp1    z31.s, z29.s, z27.s\n-    __ sve_uzp2(z8, __ S, z29, z26);                   \/\/       uzp2    z8.s, z29.s, z26.s\n-    __ sve_fabd(z5, __ D, p1, z18);                    \/\/       fabd    z5.d, p1\/m, z5.d, z18.d\n-    __ sve_bext(z13, __ H, z26, z21);                  \/\/       bext    z13.h, z26.h, z21.h\n-    __ sve_bdep(z0, __ D, z19, z10);                   \/\/       bdep    z0.d, z19.d, z10.d\n-    __ sve_eor3(z7, z17, z6);                          \/\/       eor3    z7.d, z7.d, z17.d, z6.d\n-    __ sve_sqadd(z20, __ H, p6, z28);                  \/\/       sqadd   z20.h, p6\/m, z20.h, z28.h\n-    __ sve_sqsub(z17, __ H, p3, z19);                  \/\/       sqsub   z17.h, p3\/m, z17.h, z19.h\n-    __ sve_uqadd(z26, __ B, p2, z24);                  \/\/       uqadd   z26.b, p2\/m, z26.b, z24.b\n-    __ sve_uqsub(z11, __ S, p3, z28);                  \/\/       uqsub   z11.s, p3\/m, z11.s, z28.s\n+    __ sve_add(z19, __ D, z26, z27);                   \/\/       add     z19.d, z26.d, z27.d\n+    __ sve_sub(z13, __ B, z22, z22);                   \/\/       sub     z13.b, z22.b, z22.b\n+    __ sve_fadd(z1, __ S, z11, z20);                   \/\/       fadd    z1.s, z11.s, z20.s\n+    __ sve_fmul(z20, __ S, z24, z24);                  \/\/       fmul    z20.s, z24.s, z24.s\n+    __ sve_fsub(z31, __ D, z17, z20);                  \/\/       fsub    z31.d, z17.d, z20.d\n+    __ sve_sqadd(z21, __ H, z4, z21);                  \/\/       sqadd   z21.h, z4.h, z21.h\n+    __ sve_sqsub(z30, __ D, z22, z31);                 \/\/       sqsub   z30.d, z22.d, z31.d\n+    __ sve_uqadd(z26, __ H, z18, z19);                 \/\/       uqadd   z26.h, z18.h, z19.h\n+    __ sve_uqsub(z11, __ S, z13, z29);                 \/\/       uqsub   z11.s, z13.s, z29.s\n+    __ sve_abs(z5, __ H, p0, z14);                     \/\/       abs     z5.h, p0\/m, z14.h\n+    __ sve_add(z2, __ H, p1, z10);                     \/\/       add     z2.h, p1\/m, z2.h, z10.h\n+    __ sve_and(z19, __ H, p1, z26);                    \/\/       and     z19.h, p1\/m, z19.h, z26.h\n+    __ sve_asr(z2, __ B, p0, z30);                     \/\/       asr     z2.b, p0\/m, z2.b, z30.b\n+    __ sve_bic(z20, __ D, p1, z20);                    \/\/       bic     z20.d, p1\/m, z20.d, z20.d\n+    __ sve_clz(z29, __ H, p3, z13);                    \/\/       clz     z29.h, p3\/m, z13.h\n+    __ sve_cnt(z14, __ H, p7, z1);                     \/\/       cnt     z14.h, p7\/m, z1.h\n+    __ sve_eor(z28, __ D, p0, z3);                     \/\/       eor     z28.d, p0\/m, z28.d, z3.d\n+    __ sve_lsl(z9, __ B, p6, z9);                      \/\/       lsl     z9.b, p6\/m, z9.b, z9.b\n+    __ sve_lsr(z26, __ B, p2, z14);                    \/\/       lsr     z26.b, p2\/m, z26.b, z14.b\n+    __ sve_mul(z20, __ D, p6, z7);                     \/\/       mul     z20.d, p6\/m, z20.d, z7.d\n+    __ sve_neg(z20, __ D, p4, z6);                     \/\/       neg     z20.d, p4\/m, z6.d\n+    __ sve_not(z13, __ H, p0, z29);                    \/\/       not     z13.h, p0\/m, z29.h\n+    __ sve_orr(z9, __ B, p0, z1);                      \/\/       orr     z9.b, p0\/m, z9.b, z1.b\n+    __ sve_rbit(z27, __ B, p6, z15);                   \/\/       rbit    z27.b, p6\/m, z15.b\n+    __ sve_revb(z4, __ D, p7, z17);                    \/\/       revb    z4.d, p7\/m, z17.d\n+    __ sve_smax(z2, __ B, p0, z24);                    \/\/       smax    z2.b, p0\/m, z2.b, z24.b\n+    __ sve_smin(z26, __ B, p7, z13);                   \/\/       smin    z26.b, p7\/m, z26.b, z13.b\n+    __ sve_umax(z22, __ D, p3, z16);                   \/\/       umax    z22.d, p3\/m, z22.d, z16.d\n+    __ sve_umin(z17, __ D, p1, z11);                   \/\/       umin    z17.d, p1\/m, z17.d, z11.d\n+    __ sve_sub(z16, __ B, p0, z16);                    \/\/       sub     z16.b, p0\/m, z16.b, z16.b\n+    __ sve_fabs(z28, __ D, p1, z23);                   \/\/       fabs    z28.d, p1\/m, z23.d\n+    __ sve_fadd(z28, __ D, p4, z10);                   \/\/       fadd    z28.d, p4\/m, z28.d, z10.d\n+    __ sve_fdiv(z17, __ D, p7, z7);                    \/\/       fdiv    z17.d, p7\/m, z17.d, z7.d\n+    __ sve_fmax(z4, __ S, p3, z24);                    \/\/       fmax    z4.s, p3\/m, z4.s, z24.s\n+    __ sve_fmin(z9, __ S, p2, z11);                    \/\/       fmin    z9.s, p2\/m, z9.s, z11.s\n+    __ sve_fmul(z4, __ D, p5, z22);                    \/\/       fmul    z4.d, p5\/m, z4.d, z22.d\n+    __ sve_fneg(z4, __ S, p0, z15);                    \/\/       fneg    z4.s, p0\/m, z15.s\n+    __ sve_frintm(z4, __ D, p7, z26);                  \/\/       frintm  z4.d, p7\/m, z26.d\n+    __ sve_frintn(z5, __ S, p5, z26);                  \/\/       frintn  z5.s, p5\/m, z26.s\n+    __ sve_frintp(z31, __ S, p0, z25);                 \/\/       frintp  z31.s, p0\/m, z25.s\n+    __ sve_fsqrt(z8, __ D, p1, z3);                    \/\/       fsqrt   z8.d, p1\/m, z3.d\n+    __ sve_fsub(z7, __ D, p6, z24);                    \/\/       fsub    z7.d, p6\/m, z7.d, z24.d\n+    __ sve_fmad(z24, __ S, p7, z17, z1);               \/\/       fmad    z24.s, p7\/m, z17.s, z1.s\n+    __ sve_fmla(z12, __ D, p7, z13, z8);               \/\/       fmla    z12.d, p7\/m, z13.d, z8.d\n+    __ sve_fmls(z29, __ D, p0, z31, z23);              \/\/       fmls    z29.d, p0\/m, z31.d, z23.d\n+    __ sve_fmsb(z20, __ D, p0, z21, z7);               \/\/       fmsb    z20.d, p0\/m, z21.d, z7.d\n+    __ sve_fnmad(z29, __ D, p6, z22, z8);              \/\/       fnmad   z29.d, p6\/m, z22.d, z8.d\n+    __ sve_fnmsb(z26, __ D, p5, z5, z6);               \/\/       fnmsb   z26.d, p5\/m, z5.d, z6.d\n+    __ sve_fnmla(z18, __ S, p3, z26, z21);             \/\/       fnmla   z18.s, p3\/m, z26.s, z21.s\n+    __ sve_fnmls(z0, __ S, p4, z10, z28);              \/\/       fnmls   z0.s, p4\/m, z10.s, z28.s\n+    __ sve_mla(z17, __ D, p1, z30, z20);               \/\/       mla     z17.d, p1\/m, z30.d, z20.d\n+    __ sve_mls(z28, __ S, p3, z17, z14);               \/\/       mls     z28.s, p3\/m, z17.s, z14.s\n+    __ sve_and(z10, z26, z11);                         \/\/       and     z10.d, z26.d, z11.d\n+    __ sve_eor(z0, z11, z15);                          \/\/       eor     z0.d, z11.d, z15.d\n+    __ sve_orr(z23, z23, z20);                         \/\/       orr     z23.d, z23.d, z20.d\n+    __ sve_bic(z23, z20, z29);                         \/\/       bic     z23.d, z20.d, z29.d\n+    __ sve_uzp1(z0, __ S, z27, z6);                    \/\/       uzp1    z0.s, z27.s, z6.s\n+    __ sve_uzp2(z13, __ H, z12, z4);                   \/\/       uzp2    z13.h, z12.h, z4.h\n+    __ sve_fabd(z31, __ D, p6, z23);                   \/\/       fabd    z31.d, p6\/m, z31.d, z23.d\n+    __ sve_bext(z6, __ D, z2, z29);                    \/\/       bext    z6.d, z2.d, z29.d\n+    __ sve_bdep(z0, __ B, z29, z23);                   \/\/       bdep    z0.b, z29.b, z23.b\n+    __ sve_eor3(z4, z5, z8);                           \/\/       eor3    z4.d, z4.d, z5.d, z8.d\n+    __ sve_sqadd(z13, __ H, p4, z13);                  \/\/       sqadd   z13.h, p4\/m, z13.h, z13.h\n+    __ sve_sqsub(z8, __ H, p2, z8);                    \/\/       sqsub   z8.h, p2\/m, z8.h, z8.h\n+    __ sve_uqadd(z19, __ S, p0, z29);                  \/\/       uqadd   z19.s, p0\/m, z19.s, z29.s\n+    __ sve_uqsub(z16, __ D, p3, z23);                  \/\/       uqsub   z16.d, p3\/m, z16.d, z23.d\n@@ -1349,9 +1365,9 @@\n-    __ sve_andv(v23, __ S, p5, z28);                   \/\/       andv s23, p5, z28.s\n-    __ sve_orv(v20, __ B, p7, z24);                    \/\/       orv b20, p7, z24.b\n-    __ sve_eorv(v27, __ H, p1, z23);                   \/\/       eorv h27, p1, z23.h\n-    __ sve_smaxv(v12, __ D, p1, z13);                  \/\/       smaxv d12, p1, z13.d\n-    __ sve_sminv(v26, __ B, p5, z20);                  \/\/       sminv b26, p5, z20.b\n-    __ sve_fminv(v2, __ S, p7, z29);                   \/\/       fminv s2, p7, z29.s\n-    __ sve_fmaxv(v29, __ S, p5, z3);                   \/\/       fmaxv s29, p5, z3.s\n-    __ sve_fadda(v5, __ S, p2, z28);                   \/\/       fadda s5, p2, s5, z28.s\n-    __ sve_uaddv(v17, __ H, p3, z14);                  \/\/       uaddv d17, p3, z14.h\n+    __ sve_andv(v23, __ B, p7, z13);                   \/\/       andv b23, p7, z13.b\n+    __ sve_orv(v25, __ H, p5, z0);                     \/\/       orv h25, p5, z0.h\n+    __ sve_eorv(v25, __ H, p7, z11);                   \/\/       eorv h25, p7, z11.h\n+    __ sve_smaxv(v14, __ H, p5, z22);                  \/\/       smaxv h14, p5, z22.h\n+    __ sve_sminv(v5, __ H, p4, z0);                    \/\/       sminv h5, p4, z0.h\n+    __ sve_fminv(v9, __ D, p0, z3);                    \/\/       fminv d9, p0, z3.d\n+    __ sve_fmaxv(v14, __ S, p1, z29);                  \/\/       fmaxv s14, p1, z29.s\n+    __ sve_fadda(v14, __ D, p5, z4);                   \/\/       fadda d14, p5, d14, z4.d\n+    __ sve_uaddv(v27, __ S, p3, z22);                  \/\/       uaddv d27, p3, z22.s\n@@ -1360,12 +1376,12 @@\n-    __ saddwv(v10, v11, __ T8H, v12, __ T8B);          \/\/       saddw   v10.8H, v11.8H, v12.8B\n-    __ saddwv2(v8, v9, __ T8H, v10, __ T16B);          \/\/       saddw2  v8.8H, v9.8H, v10.16B\n-    __ saddwv(v9, v10, __ T4S, v11, __ T4H);           \/\/       saddw   v9.4S, v10.4S, v11.4H\n-    __ saddwv2(v19, v20, __ T4S, v21, __ T8H);         \/\/       saddw2  v19.4S, v20.4S, v21.8H\n-    __ saddwv(v0, v1, __ T2D, v2, __ T2S);             \/\/       saddw   v0.2D, v1.2D, v2.2S\n-    __ saddwv2(v29, v30, __ T2D, v31, __ T4S);         \/\/       saddw2  v29.2D, v30.2D, v31.4S\n-    __ uaddwv(v16, v17, __ T8H, v18, __ T8B);          \/\/       uaddw   v16.8H, v17.8H, v18.8B\n-    __ uaddwv2(v16, v17, __ T8H, v18, __ T16B);        \/\/       uaddw2  v16.8H, v17.8H, v18.16B\n-    __ uaddwv(v13, v14, __ T4S, v15, __ T4H);          \/\/       uaddw   v13.4S, v14.4S, v15.4H\n-    __ uaddwv2(v23, v24, __ T4S, v25, __ T8H);         \/\/       uaddw2  v23.4S, v24.4S, v25.8H\n-    __ uaddwv(v24, v25, __ T2D, v26, __ T2S);          \/\/       uaddw   v24.2D, v25.2D, v26.2S\n-    __ uaddwv2(v23, v24, __ T2D, v25, __ T4S);         \/\/       uaddw2  v23.2D, v24.2D, v25.4S\n+    __ saddwv(v31, v0, __ T8H, v1, __ T8B);            \/\/       saddw   v31.8H, v0.8H, v1.8B\n+    __ saddwv2(v24, v25, __ T8H, v26, __ T16B);        \/\/       saddw2  v24.8H, v25.8H, v26.16B\n+    __ saddwv(v11, v12, __ T4S, v13, __ T4H);          \/\/       saddw   v11.4S, v12.4S, v13.4H\n+    __ saddwv2(v16, v17, __ T4S, v18, __ T8H);         \/\/       saddw2  v16.4S, v17.4S, v18.8H\n+    __ saddwv(v12, v13, __ T2D, v14, __ T2S);          \/\/       saddw   v12.2D, v13.2D, v14.2S\n+    __ saddwv2(v17, v18, __ T2D, v19, __ T4S);         \/\/       saddw2  v17.2D, v18.2D, v19.4S\n+    __ uaddwv(v28, v29, __ T8H, v30, __ T8B);          \/\/       uaddw   v28.8H, v29.8H, v30.8B\n+    __ uaddwv2(v3, v4, __ T8H, v5, __ T16B);           \/\/       uaddw2  v3.8H, v4.8H, v5.16B\n+    __ uaddwv(v28, v29, __ T4S, v30, __ T4H);          \/\/       uaddw   v28.4S, v29.4S, v30.4H\n+    __ uaddwv2(v16, v17, __ T4S, v18, __ T8H);         \/\/       uaddw2  v16.4S, v17.4S, v18.8H\n+    __ uaddwv(v4, v5, __ T2D, v6, __ T2S);             \/\/       uaddw   v4.2D, v5.2D, v6.2S\n+    __ uaddwv2(v29, v30, __ T2D, v31, __ T4S);         \/\/       uaddw2  v29.2D, v30.2D, v31.4S\n@@ -1390,7 +1406,7 @@\n-    0x14000000,     0x17ffffd7,     0x1400047d,     0x94000000,\n-    0x97ffffd4,     0x9400047a,     0x3400000a,     0x34fffa2a,\n-    0x34008eea,     0x35000008,     0x35fff9c8,     0x35008e88,\n-    0xb400000b,     0xb4fff96b,     0xb4008e2b,     0xb500001d,\n-    0xb5fff91d,     0xb5008ddd,     0x10000013,     0x10fff8b3,\n-    0x10008d73,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36308cf6,     0x3758000c,     0x375ff7cc,     0x37588c8c,\n+    0x14000000,     0x17ffffd7,     0x1400048d,     0x94000000,\n+    0x97ffffd4,     0x9400048a,     0x3400000a,     0x34fffa2a,\n+    0x340090ea,     0x35000008,     0x35fff9c8,     0x35009088,\n+    0xb400000b,     0xb4fff96b,     0xb400902b,     0xb500001d,\n+    0xb5fff91d,     0xb5008fdd,     0x10000013,     0x10fff8b3,\n+    0x10008f73,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36308ef6,     0x3758000c,     0x375ff7cc,     0x37588e8c,\n@@ -1401,13 +1417,13 @@\n-    0x54008a60,     0x54000001,     0x54fff541,     0x54008a01,\n-    0x54000002,     0x54fff4e2,     0x540089a2,     0x54000002,\n-    0x54fff482,     0x54008942,     0x54000003,     0x54fff423,\n-    0x540088e3,     0x54000003,     0x54fff3c3,     0x54008883,\n-    0x54000004,     0x54fff364,     0x54008824,     0x54000005,\n-    0x54fff305,     0x540087c5,     0x54000006,     0x54fff2a6,\n-    0x54008766,     0x54000007,     0x54fff247,     0x54008707,\n-    0x54000008,     0x54fff1e8,     0x540086a8,     0x54000009,\n-    0x54fff189,     0x54008649,     0x5400000a,     0x54fff12a,\n-    0x540085ea,     0x5400000b,     0x54fff0cb,     0x5400858b,\n-    0x5400000c,     0x54fff06c,     0x5400852c,     0x5400000d,\n-    0x54fff00d,     0x540084cd,     0x5400000e,     0x54ffefae,\n-    0x5400846e,     0x5400000f,     0x54ffef4f,     0x5400840f,\n+    0x54008c60,     0x54000001,     0x54fff541,     0x54008c01,\n+    0x54000002,     0x54fff4e2,     0x54008ba2,     0x54000002,\n+    0x54fff482,     0x54008b42,     0x54000003,     0x54fff423,\n+    0x54008ae3,     0x54000003,     0x54fff3c3,     0x54008a83,\n+    0x54000004,     0x54fff364,     0x54008a24,     0x54000005,\n+    0x54fff305,     0x540089c5,     0x54000006,     0x54fff2a6,\n+    0x54008966,     0x54000007,     0x54fff247,     0x54008907,\n+    0x54000008,     0x54fff1e8,     0x540088a8,     0x54000009,\n+    0x54fff189,     0x54008849,     0x5400000a,     0x54fff12a,\n+    0x540087ea,     0x5400000b,     0x54fff0cb,     0x5400878b,\n+    0x5400000c,     0x54fff06c,     0x5400872c,     0x5400000d,\n+    0x54fff00d,     0x540086cd,     0x5400000e,     0x54ffefae,\n+    0x5400866e,     0x5400000f,     0x54ffef4f,     0x5400860f,\n@@ -1475,92 +1491,96 @@\n-    0x9bae275e,     0x9ba7954d,     0x7ea3d5fe,     0x1e30098c,\n-    0x1e321bff,     0x1e302ab3,     0x1e35394f,     0x7efcd542,\n-    0x1e7f0bc7,     0x1e621832,     0x1e632946,     0x1e673979,\n-    0x1f000d81,     0x1f06dfb3,     0x1f3c6c06,     0x1f2774a2,\n-    0x1f4d332c,     0x1f48ca78,     0x1f755356,     0x1f7e5853,\n-    0x1e2042c8,     0x1e20c2b3,     0x1e21424c,     0x1e21c0d5,\n-    0x1e22c070,     0x1e23c3a3,     0x1ee24383,     0x1e6041cf,\n-    0x1e60c1aa,     0x1e61424c,     0x1e61c34a,     0x1e6240e7,\n-    0x1e3803ae,     0x9e3802e0,     0x1e780180,     0x9e7801d7,\n-    0x1e2200ed,     0x9e2200ef,     0x1e620289,     0x9e620393,\n-    0x1e24021e,     0x9e640122,     0x1e3002b0,     0x9e70009d,\n-    0x1e260361,     0x9e660318,     0x1e2702ae,     0x9e6700ad,\n-    0x1e392180,     0x1e7e2320,     0x1e202388,     0x1e6022a8,\n-    0x293a1796,     0x29426e73,     0x697c68fc,     0xa93d0486,\n-    0xa97b5eba,     0x29b47934,     0x29c2534d,     0x69f62dbd,\n-    0xa9bd54bb,     0xa9c503c6,     0x28a63e13,     0x28e25d2c,\n-    0x68c469e0,     0xa8b34748,     0xa8f51c59,     0x28264433,\n-    0x285036c0,     0xa8005f7d,     0xa872290b,     0x0c407160,\n-    0x4cdfa350,     0x0cd16f56,     0x4cdf27bb,     0x0d40c0d6,\n-    0x4ddfcbae,     0x0dd0cd96,     0x4c408c01,     0x0cdf86aa,\n-    0x4d60c327,     0x0dffc929,     0x4deecd89,     0x4cd14887,\n-    0x0c404a37,     0x4d40e6c4,     0x4ddfe84d,     0x0dcced50,\n-    0x4cdf0444,     0x0ccb0286,     0x0d60e18c,     0x0dffe630,\n-    0x0df0eb2e,     0x0e31bab4,     0x4e31b841,     0x0e71bb17,\n-    0x4e71bbfe,     0x4eb1b9ee,     0x0e30a862,     0x4e30a8e6,\n-    0x0e70a883,     0x4e70a928,     0x4eb0ab59,     0x6e30f820,\n-    0x0e31ab9b,     0x2e31abfe,     0x4e31a8c5,     0x6e31a8c5,\n-    0x0e71abfe,     0x2e71a98b,     0x4e71ab59,     0x6e71a820,\n-    0x4eb1a81f,     0x6eb1a820,     0x6eb0fa93,     0x7e30fbdd,\n-    0x7e70fb7a,     0x7eb0f949,     0x7ef0fb7a,     0x0ea0c9ac,\n-    0x4ea0ca0f,     0x4ee0c98b,     0x2ea0c98b,     0x6ea0ca72,\n-    0x6ee0cb59,     0x0ea0daf6,     0x4ea0db38,     0x4ee0d820,\n-    0x0ea0ea51,     0x4ea0e98b,     0x4ee0e8e6,     0x2ea0dbdd,\n-    0x6ea0d8e6,     0x6ee0d8c5,     0x0e20b8c5,     0x4e20bad5,\n-    0x0e60ba93,     0x4e60ba30,     0x0ea0ba72,     0x4ea0bbfe,\n-    0x4ee0bb9b,     0x0ea0fbbc,     0x4ea0f841,     0x4ee0fbbc,\n-    0x2ea0f841,     0x6ea0fab4,     0x6ee0fbdd,     0x2ea1fa30,\n-    0x6ea1f9cd,     0x6ee1f96a,     0x2e205bdd,     0x6e205bdd,\n-    0x0e351e93,     0x4e381ef6,     0x0eac1d6a,     0x4ea61ca4,\n-    0x2e211c1f,     0x6e371ed5,     0x0e2a8528,     0x4e21841f,\n-    0x0e758693,     0x4e6c856a,     0x0ebe87bc,     0x4ea48462,\n-    0x4efb8759,     0x0e270cc5,     0x4e250c83,     0x0e6a0d28,\n-    0x4e780ef6,     0x0eb50e93,     0x4eaf0dcd,     0x4ee70cc5,\n-    0x2e3f0fdd,     0x6e3a0f38,     0x2e770ed5,     0x6e7c0f7a,\n-    0x2eba0f38,     0x6ea50c83,     0x6efa0f38,     0x0e3cd77a,\n-    0x4e39d717,     0x4e71d60f,     0x2e3786d5,     0x6e258483,\n-    0x2e7a8738,     0x6e6a8528,     0x2ebb8759,     0x6eb686b4,\n-    0x6ef28630,     0x0e332e51,     0x4e242c62,     0x0e632c41,\n-    0x4e622c20,     0x0eba2f38,     0x4ea62ca4,     0x4ee52c83,\n-    0x2e2e2dac,     0x6e212c1f,     0x2e7e2fbc,     0x6e6c2d6a,\n-    0x2ebc2f7a,     0x6ea42c62,     0x6eee2dac,     0x0eb4d672,\n-    0x4ea1d41f,     0x4ee3d441,     0x0e2f9dcd,     0x4e3f9fdd,\n-    0x0e629c20,     0x4e759e93,     0x0eae9dac,     0x4eb39e51,\n-    0x2eb8d6f6,     0x6eafd5cd,     0x6efed7bc,     0x2e20d7fe,\n-    0x6e21d41f,     0x6e63d441,     0x2e3cdf7a,     0x6e3edfbc,\n-    0x6e66dca4,     0x0e6097fe,     0x4e6694a4,     0x0ea894e6,\n-    0x4ea097fe,     0x0e3ccf7a,     0x4e34ce72,     0x4e6bcd49,\n-    0x2e6a9528,     0x6e6e95ac,     0x2ea29420,     0x6eb696b4,\n-    0x0ea3cc41,     0x4ebacf38,     0x4ee4cc62,     0x2e22fc20,\n-    0x6e2bfd49,     0x6e7aff38,     0x0e3c677a,     0x4e326630,\n-    0x0e6067fe,     0x4e656483,     0x0eac656a,     0x4eb96717,\n-    0x2e2c656a,     0x6e2664a4,     0x2e746672,     0x6e646462,\n-    0x2ead658b,     0x6eaa6528,     0x0e2ca56a,     0x4e31a60f,\n-    0x0e73a651,     0x4e64a462,     0x0eaca56a,     0x4eaea5ac,\n-    0x0e2ef5ac,     0x4e31f60f,     0x4e6ff5cd,     0x0e246c62,\n-    0x4e296d07,     0x0e766eb4,     0x4e7c6f7a,     0x0eb26e30,\n-    0x4ea66ca4,     0x2e246c62,     0x6e266ca4,     0x2e6e6dac,\n-    0x6e746e72,     0x2eb76ed5,     0x6eb26e30,     0x0e34ae72,\n-    0x4e2dad8b,     0x0e77aed5,     0x4e79af17,     0x0eaeadac,\n-    0x4ebcaf7a,     0x0e79b717,     0x4e7eb7bc,     0x0eb0b5ee,\n-    0x4eadb58b,     0x0e3a2738,     0x4e232441,     0x0e6e25ac,\n-    0x4e61241f,     0x0eac256a,     0x4eb22630,     0x0ea9f507,\n-    0x4ea4f462,     0x4ee5f483,     0x2eafedcd,     0x6eb5ee93,\n-    0x6ef3ee51,     0x0fa31041,     0x4f8780c5,     0x4fc41862,\n-    0x0f895107,     0x4fa1880f,     0x4fcc516a,     0x2f8c916a,\n-    0x4f9089ee,     0x6fcf99cd,     0x0f748062,     0x4f4d818b,\n-    0x0fa1800f,     0x4f8880e6,     0x0e2b3549,     0x4e3e37bc,\n-    0x0e71360f,     0x4e7f37dd,     0x0eb836f6,     0x4ea1341f,\n-    0x4ef53693,     0x0e213c1f,     0x4e273cc5,     0x0e703dee,\n-    0x4e743e72,     0x0ea13c1f,     0x4eb43e72,     0x4efd3f9b,\n-    0x2e368eb4,     0x6e328e30,     0x2e6e8dac,     0x6e6d8d8b,\n-    0x2eab8d49,     0x6ea88ce6,     0x6ee08ffe,     0x2e333651,\n-    0x6e3d379b,     0x2e7e37bc,     0x6e6037fe,     0x2ea93507,\n-    0x6eac356a,     0x6ef636b4,     0x2e2c3d6a,     0x6e263ca4,\n-    0x2e7a3f38,     0x6e733e51,     0x2eb33e51,     0x6eb83ef6,\n-    0x6ee53c83,     0x0e3fe7dd,     0x4e31e60f,     0x4e78e6f6,\n-    0x2eb5e693,     0x6eb5e693,     0x6ef8e6f6,     0x2e24e462,\n-    0x6e31e60f,     0x6e68e4e6,     0x65922e06,     0x65d0303b,\n-    0x65903222,     0x659135ab,     0x65913b7e,     0x65d33821,\n-    0x254b9e29,     0x258f14f7,     0x25c2184c,     0x258222e5,\n-    0x25d23730,     0x250e9d99,     0x24e9460e,     0x2427465e,\n-    0x24a2a937,     0x24fbe6ae,     0xba5fd3e3,     0x3a5f03e5,\n+    0x9bae275e,     0x9ba7954d,     0x7ec315fe,     0x1ef0098c,\n+    0x1ef21bff,     0x1ef02ab3,     0x1ef5394f,     0x1efc4942,\n+    0x1eff5bc7,     0x1ee28832,     0x7ea3d546,     0x1e270979,\n+    0x1e201981,     0x1e3d2a63,     0x1e263ae6,     0x1e3b4b80,\n+    0x1e2758a2,     0x1e39899d,     0x7ef8d58d,     0x1e720913,\n+    0x1e751b56,     0x1e622a74,     0x1e683ade,     0x1e754a76,\n+    0x1e755a4c,     0x1e638a06,     0x1fc373a3,     0x1f0a35cf,\n+    0x1f0aea4c,     0x1f2f74e7,     0x1f2032e0,     0x1f4d21d8,\n+    0x1f49d0ef,     0x1f7f43b3,     0x1f705522,     0x1e20409e,\n+    0x1e20c361,     0x1e214319,     0x1e21c2ae,     0x1e22c0cd,\n+    0x1e23c32c,     0x1ee243d9,     0x1e6042bc,     0x1e60c2f0,\n+    0x1e6143a5,     0x1e61c276,     0x1e62428d,     0x1ee1c393,\n+    0x1e3800d1,     0x9e3800ed,     0x1e78035c,     0x9e7800d1,\n+    0x1e220081,     0x9e22028e,     0x1e6202a7,     0x9e6202fb,\n+    0x1e24028d,     0x9e64039e,     0x1e3002aa,     0x9e700225,\n+    0x1e2601cb,     0x9e6602ad,     0x1e2701db,     0x9e6702e4,\n+    0x1e3e2300,     0x1e6e2180,     0x1e202228,     0x1e602388,\n+    0x29021b40,     0x297c78c0,     0x69660970,     0xa908018f,\n+    0xa9427ae7,     0x29a03cfa,     0x29fc3d4b,     0x69c84033,\n+    0xa988240e,     0xa9fa0d9b,     0x28a02d88,     0x28c8408a,\n+    0x68f87a6a,     0xa8ba09f8,     0xa8c52a18,     0x280257be,\n+    0x28727948,     0xa83868de,     0xa8440a98,     0x0c40733f,\n+    0x4cdfa1e5,     0x0ccd6cea,     0x4cdf260d,     0x0d40c227,\n+    0x4ddfcb30,     0x0dc7cc6b,     0x4c408ced,     0x0cdf8769,\n+    0x4d60c346,     0x0dffca17,     0x4de8cda6,     0x4cda4834,\n+    0x0c4049ef,     0x4d40e6dd,     0x4ddfe946,     0x0dcfeccf,\n+    0x4cdf0546,     0x0cc7006b,     0x0d60e32c,     0x0dffe5eb,\n+    0x0dfce8de,     0x0e31bb9b,     0x4e31bbbc,     0x0e71b841,\n+    0x4e71bbbc,     0x4eb1b841,     0x0e30aab4,     0x4e30abdd,\n+    0x0e70aa30,     0x4e70a9cd,     0x4eb0a96a,     0x6e30fbdd,\n+    0x0e31abdd,     0x2e31aa93,     0x4e31aaf6,     0x6e31a96a,\n+    0x0e71a8a4,     0x2e71a81f,     0x4e71aad5,     0x6e71a928,\n+    0x4eb1a81f,     0x6eb1aa93,     0x6eb0f96a,     0x7e30fbbc,\n+    0x7e70f862,     0x7eb0fb59,     0x7ef0f8c5,     0x0ea0c883,\n+    0x4ea0c928,     0x4ee0caf6,     0x2ea0ca93,     0x6ea0c9cd,\n+    0x6ee0c8c5,     0x0ea0dbdd,     0x4ea0db38,     0x4ee0dad5,\n+    0x0ea0eb7a,     0x4ea0eb38,     0x4ee0e883,     0x2ea0db38,\n+    0x6ea0db7a,     0x6ee0db17,     0x0e20ba0f,     0x4e20bad5,\n+    0x0e60b883,     0x4e60bb38,     0x0ea0b928,     0x4ea0bb59,\n+    0x4ee0bab4,     0x0ea0fa30,     0x4ea0fa51,     0x4ee0f862,\n+    0x2ea0f841,     0x6ea0f820,     0x6ee0fb38,     0x2ea1f8a4,\n+    0x6ea1f883,     0x6ee1f9ac,     0x2e20581f,     0x6e205bbc,\n+    0x0e2c1d6a,     0x4e3c1f7a,     0x0ea41c62,     0x4eae1dac,\n+    0x2e341e72,     0x6e211c1f,     0x0e238441,     0x4e2f85cd,\n+    0x0e7f87dd,     0x4e628420,     0x0eb58693,     0x4eae85ac,\n+    0x4ef38651,     0x0e380ef6,     0x4e2f0dcd,     0x0e7e0fbc,\n+    0x4e600ffe,     0x0ea10c1f,     0x4ea30c41,     0x4efc0f7a,\n+    0x2e3e0fbc,     0x6e260ca4,     0x2e600ffe,     0x6e660ca4,\n+    0x2ea80ce6,     0x6ea00ffe,     0x6efc0f7a,     0x0e34d672,\n+    0x4e2bd549,     0x4e6ad528,     0x2e2e85ac,     0x6e228420,\n+    0x2e7686b4,     0x6e638441,     0x2eba8738,     0x6ea48462,\n+    0x6ee28420,     0x0e2b2d49,     0x4e3a2f38,     0x0e7c2f7a,\n+    0x4e722e30,     0x0ea02ffe,     0x4ea52c83,     0x4eec2d6a,\n+    0x2e392f17,     0x6e2c2d6a,     0x2e662ca4,     0x6e742e72,\n+    0x2ea42c62,     0x6ead2d8b,     0x6eea2d28,     0x0eacd56a,\n+    0x4eb1d60f,     0x4ef3d651,     0x0e249c62,     0x4e2c9d6a,\n+    0x0e6e9dac,     0x4e6e9dac,     0x0eb19e0f,     0x4eaf9dcd,\n+    0x2ea4d462,     0x6ea9d507,     0x6ef6d6b4,     0x2e3cd77a,\n+    0x6e32d630,     0x6e66d4a4,     0x2e24dc62,     0x6e26dca4,\n+    0x6e6eddac,     0x0e749672,     0x4e7796d5,     0x0eb29630,\n+    0x4eb49672,     0x0e2dcd8b,     0x4e37ced5,     0x4e79cf17,\n+    0x2e6e95ac,     0x6e7c977a,     0x2eb99717,     0x6ebe97bc,\n+    0x0eb0cdee,     0x4eadcd8b,     0x4efacf38,     0x2e23fc41,\n+    0x6e2efdac,     0x6e61fc1f,     0x0e2c656a,     0x4e326630,\n+    0x0e696507,     0x4e646462,     0x0ea56483,     0x4eaf65cd,\n+    0x2e356693,     0x6e336651,     0x2e726630,     0x6e656483,\n+    0x2ea36441,     0x6ead658b,     0x0e20a7fe,     0x4e27a4c5,\n+    0x0e6aa528,     0x4e71a60f,     0x0ebfa7dd,     0x4ea0a7fe,\n+    0x0e22f420,     0x4e36f6b4,     0x4e69f507,     0x0e366eb4,\n+    0x4e396f17,     0x0e7e6fbc,     0x4e776ed5,     0x0ebd6f9b,\n+    0x4ebb6f59,     0x2e276cc5,     0x6e236c41,     0x2e796f17,\n+    0x6e726e30,     0x2ea16c1f,     0x6ea76cc5,     0x0e2eadac,\n+    0x4e2bad49,     0x0e7eafbc,     0x4e71ae0f,     0x0ebfafdd,\n+    0x4eb8aef6,     0x0e61b41f,     0x4e75b693,     0x0ea1b41f,\n+    0x4ea7b4c5,     0x0e3025ee,     0x4e342672,     0x0e61241f,\n+    0x4e742672,     0x0ebd279b,     0x4eb626b4,     0x0eb2f630,\n+    0x4eaef5ac,     0x4eedf58b,     0x2eabed49,     0x6ea8ece6,\n+    0x6ee0effe,     0x0faf11cd,     0x4fa1880f,     0x4fc710c5,\n+    0x0fa750c5,     0x4f8e81ac,     0x4fca5928,     0x2fa39041,\n+    0x4fa98907,     0x6fcb9949,     0x0f6d818b,     0x4f498107,\n+    0x0f8880e6,     0x4f8788c5,     0x0e2f35cd,     0x4e393717,\n+    0x0e633441,     0x4e6037fe,     0x0eb53693,     0x4ea734c5,\n+    0x4ef33651,     0x0e243c62,     0x4e323e30,     0x0e783ef6,\n+    0x4e6f3dcd,     0x0eac3d6a,     0x4eb73ed5,     0x4eff3fdd,\n+    0x2e3d8f9b,     0x6e2e8dac,     0x2e7d8f9b,     0x6e658c83,\n+    0x2ea38c41,     0x6ea18c1f,     0x6efa8f38,     0x2e353693,\n+    0x6e333651,     0x2e6b3549,     0x6e7e37bc,     0x2ebd379b,\n+    0x6eb1360f,     0x6ee93507,     0x2e373ed5,     0x6e393f17,\n+    0x2e613c1f,     0x6e7b3f59,     0x2ea43c62,     0x6ea13c1f,\n+    0x6efd3f9b,     0x0e34e672,     0x4e2ce56a,     0x4e79e717,\n+    0x2eb5e693,     0x6ea5e483,     0x6ef4e672,     0x2e22e420,\n+    0x6e3be759,     0x6e7ce77a,     0x65d22c4b,     0x65d03f92,\n+    0x65902b68,     0x6591264e,     0x659135f3,     0x65d33444,\n+    0x25c180af,     0x25cc0897,     0x25c71b6b,     0x25103080,\n+    0x251729f2,     0x25c48552,     0x24288aab,     0x242213f8,\n+    0x24fb63d6,     0x247cafab,     0xba5fd3e3,     0x3a5f03e5,\n@@ -1628,50 +1648,50 @@\n-    0x1e7e1000,     0x1e7e3000,     0xf82081f1,     0xf824011a,\n-    0xf83c1376,     0xf83b22f9,     0xf82030c4,     0xf8305080,\n-    0xf82f4141,     0xf8277145,     0xf83c6287,     0xf8b780d5,\n-    0xf8ab0228,     0xf8bf1226,     0xf8a223cc,     0xf8bd3363,\n-    0xf8b651dd,     0xf8ad423c,     0xf8b87045,     0xf8ae620a,\n-    0xf8eb82fb,     0xf8ec02c4,     0xf8f11024,     0xf8f321f0,\n-    0xf8ed318e,     0xf8e25071,     0xf8f540b7,     0xf8e67267,\n-    0xf8ed623c,     0xf8708046,     0xf87d0083,     0xf8661290,\n-    0xf86d228c,     0xf8683299,     0xf8735160,     0xf8784286,\n-    0xf87f720e,     0xf86660e0,     0xb82f8353,     0xb82902ea,\n-    0xb8351396,     0xb82221e3,     0xb83330f4,     0xb82450fd,\n-    0xb8204209,     0xb8347097,     0xb83062ea,     0xb8ab80d9,\n-    0xb8bf01b0,     0xb8b7102c,     0xb8ae22a9,     0xb8b031fa,\n-    0xb8a451e4,     0xb8a843c6,     0xb8a4723d,     0xb8bd613a,\n-    0xb8ef8162,     0xb8fd00e3,     0xb8e112bb,     0xb8f0210e,\n-    0xb8f03336,     0xb8e552b4,     0xb8f04217,     0xb8fe7294,\n-    0xb8e06264,     0xb8788284,     0xb8640358,     0xb8731102,\n-    0xb868230e,     0xb87032df,     0xb864503f,     0xb86a4194,\n-    0xb86070e9,     0xb8786090,     0xce2a6cdb,     0xce107db8,\n-    0xce748ed6,     0xce8973bf,     0xce7480f4,     0xce6b853c,\n-    0xcec0818e,     0xce788834,     0x25a0cd89,     0x25a1d093,\n-    0x05803685,     0x05400c08,     0x050074c4,     0x2560d6a0,\n-    0x2521c0fb,     0x05805089,     0x05403e98,     0x05025238,\n-    0x25e0cd0b,     0x25e1d1d2,     0x05800e4e,     0x05402676,\n-    0x05001e63,     0x25a0d1c9,     0x2521c495,     0x0583abe2,\n-    0x054011ab,     0x05007cbe,     0x2560c3b7,     0x25e1c358,\n-    0x05806593,     0x054064b5,     0x05000e5a,     0x2520c3f1,\n-    0x25a1cc29,     0x05801468,     0x05401d71,     0x05035bb2,\n-    0x04bb01f0,     0x046806dc,     0x659c0385,     0x65d909e0,\n-    0x65c30415,     0x04fa10ba,     0x04611a33,     0x042e17ce,\n-    0x04bf1c52,     0x0456b7d7,     0x04400008,     0x049a1417,\n-    0x04509b1a,     0x041b1456,     0x0499b58b,     0x04dab938,\n-    0x04991691,     0x04d395a4,     0x04d19ff6,     0x045011f2,\n-    0x0417be8d,     0x041eadc1,     0x04980987,     0x052799e4,\n-    0x05a49c23,     0x04c817e5,     0x044a0d2d,     0x04c901fe,\n-    0x044b0343,     0x04c10839,     0x04dcac2a,     0x65c087ba,\n-    0x658d8791,     0x65869d61,     0x65c78021,     0x65828c5b,\n-    0x049db33e,     0x65c2b862,     0x65c0ac7d,     0x65c1b38e,\n-    0x65cdab64,     0x65c19022,     0x65fc97e7,     0x65bd162a,\n-    0x65b82596,     0x65a0a969,     0x65a4d697,     0x65feec8f,\n-    0x65ba46bb,     0x65a4633f,     0x04c742a6,     0x049f7f18,\n-    0x042c3141,     0x04b9310d,     0x047733e1,     0x04f53014,\n-    0x05bb6bbf,     0x05ba6fa8,     0x65c88645,     0x4555b34d,\n-    0x45cab660,     0x043138c7,     0x44589b94,     0x445a8e71,\n-    0x44198b1a,     0x449b8f8b,     0x049a3797,     0x04183f14,\n-    0x045926fb,     0x04c825ac,     0x040a369a,     0x65873fa2,\n-    0x6586347d,     0x65982b85,     0x04412dd1,     0x0e2c116a,\n-    0x4e2a1128,     0x0e6b1149,     0x4e751293,     0x0ea21020,\n-    0x4ebf13dd,     0x2e321230,     0x6e321230,     0x2e6f11cd,\n-    0x6e791317,     0x2eba1338,     0x6eb91317,\n+    0x1e7e1000,     0x1e7e3000,     0xf83180b8,     0xf822014e,\n+    0xf830136b,     0xf837208c,     0xf8363091,     0xf8215213,\n+    0xf83041cd,     0xf82c7222,     0xf82362f5,     0xf8a580e6,\n+    0xf8b3038d,     0xf8b110d0,     0xf8a2207d,     0xf8a431e6,\n+    0xf8b4518d,     0xf8b44328,     0xf8b47013,     0xf8ab60d8,\n+    0xf8f481df,     0xf8f00006,     0xf8e7126f,     0xf8fa2149,\n+    0xf8f732d5,     0xf8fc5062,     0xf8ef4293,     0xf8e773a4,\n+    0xf8e76120,     0xf87082f4,     0xf8640150,     0xf877132b,\n+    0xf866221f,     0xf86d3197,     0xf861512e,     0xf8754350,\n+    0xf86f7084,     0xf87060c8,     0xb83e83a4,     0xb831035d,\n+    0xb829104f,     0xb82b207d,     0xb8273361,     0xb83551d0,\n+    0xb82842d0,     0xb8397285,     0xb83562f0,     0xb8b0829e,\n+    0xb8b40080,     0xb8b31098,     0xb8b42304,     0xb8ba3053,\n+    0xb8a851c8,     0xb8b843f0,     0xb8b673e4,     0xb8a1628a,\n+    0xb8ec8120,     0xb8e701f8,     0xb8e410db,     0xb8ea231b,\n+    0xb8ed33f0,     0xb8f65296,     0xb8ff413d,     0xb8ee70f4,\n+    0xb8f4613c,     0xb86b818e,     0xb8740301,     0xb86911b3,\n+    0xb8732210,     0xb8653060,     0xb86c51e8,     0xb86f4090,\n+    0xb86f70be,     0xb86062ca,     0xce20247b,     0xce0a63b3,\n+    0xce678e84,     0xce8eafb8,     0xce6d836b,     0xce7187f2,\n+    0xcec0806e,     0xce768a1e,     0x2520d474,     0x2521dae3,\n+    0x05800d33,     0x05403635,     0x05004cb8,     0x2560d175,\n+    0x2561c35e,     0x05809863,     0x054030f8,     0x05000ed7,\n+    0x2520c84e,     0x2521d69a,     0x05809892,     0x05408909,\n+    0x05000d2c,     0x2560d9cb,     0x25e1d352,     0x05806b49,\n+    0x0542d157,     0x050026a8,     0x2520cf2a,     0x25a1d599,\n+    0x05801ec0,     0x05422dc5,     0x05000e11,     0x2560c07e,\n+    0x2521dfb2,     0x0580ab15,     0x0540040c,     0x0500000f,\n+    0x04fb0353,     0x043606cd,     0x65940161,     0x65980b14,\n+    0x65d4063f,     0x04751095,     0x04ff1ade,     0x0473165a,\n+    0x04bd1dab,     0x0456a1c5,     0x04400542,     0x045a0753,\n+    0x041083c2,     0x04db0694,     0x0459adbd,     0x045abc2e,\n+    0x04d9007c,     0x04139929,     0x041189da,     0x04d018f4,\n+    0x04d7b0d4,     0x045ea3ad,     0x04180029,     0x052799fb,\n+    0x05e49e24,     0x04080302,     0x040a1dba,     0x04c90e16,\n+    0x04cb0571,     0x04010210,     0x04dca6fc,     0x65c0915c,\n+    0x65cd9cf1,     0x65868f04,     0x65878969,     0x65c296c4,\n+    0x049da1e4,     0x65c2bf44,     0x6580b745,     0x6581a33f,\n+    0x65cda468,     0x65c19b07,     0x65a19e38,     0x65e81dac,\n+    0x65f723fd,     0x65e7a2b4,     0x65e8dadd,     0x65e6f4ba,\n+    0x65b54f52,     0x65bc7140,     0x04d447d1,     0x048e6e3c,\n+    0x042b334a,     0x04af3160,     0x047432f7,     0x04fd3297,\n+    0x05a66b60,     0x05646d8d,     0x65c89aff,     0x45ddb046,\n+    0x4517b7a0,     0x04253904,     0x445891ad,     0x445a8908,\n+    0x449983b3,     0x44db8ef0,     0x041a3db7,     0x04583419,\n+    0x04593d79,     0x044836ce,     0x044a3005,     0x65c72069,\n+    0x658627ae,     0x65d8348e,     0x04812edb,     0x0e21101f,\n+    0x4e3a1338,     0x0e6d118b,     0x4e721230,     0x0eae11ac,\n+    0x4eb31251,     0x2e3e13bc,     0x6e251083,     0x2e7e13bc,\n+    0x6e721230,     0x2ea610a4,     0x6ebf13dd,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":736,"deletions":716,"binary":false,"changes":1452,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -33,0 +34,1 @@\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n@@ -34,0 +36,1 @@\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n","filename":"test\/hotspot\/gtest\/code\/test_codestrings.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,1 +85,2 @@\n-                                             os::vm_page_size());\n+                                             os::vm_page_size(),\n+                                             mtTest);\n@@ -93,1 +94,1 @@\n-                                         mtGC);\n+                                         mtTest);\n@@ -111,1 +112,2 @@\n-                                             os::vm_page_size());\n+                                             os::vm_page_size(),\n+                                             mtTest);\n@@ -118,1 +120,1 @@\n-                                         mtGC);\n+                                         mtTest);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_stressCommitUncommit.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n@@ -30,0 +31,1 @@\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahNumberSeq.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-\n-#include <iostream>\n@@ -29,0 +27,1 @@\n+\n@@ -30,0 +29,3 @@\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n+#include <iostream>\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-      char* const reserved = os::attempt_reserve_memory_at((char*)ZAddressHeapBase + start, ZGranuleSize, false \/* executable *\/);\n+      char* const reserved = os::attempt_reserve_memory_at((char*)ZAddressHeapBase + start, ZGranuleSize, mtTest);\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zForwarding.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-      char* const result = os::attempt_reserve_memory_at((char*)untype(blocked), ZGranuleSize, !ExecMem, mtTest);\n+      char* const result = os::attempt_reserve_memory_at((char*)untype(blocked), ZGranuleSize, mtTest);\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zVirtualMemoryManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/permitForbiddenFunctions.hpp\"\n@@ -195,1 +196,1 @@\n-  ALLOW_C_FUNCTION(::malloc, char** new_argv = (char**) malloc(sizeof(char*) * argc);)\n+  char** new_argv = (char**)permit_forbidden_function::malloc(sizeof(char*) * argc);\n@@ -291,1 +292,1 @@\n-  ALLOW_C_FUNCTION(::free, ::free(argv);)\n+  permit_forbidden_function::free(argv);\n","filename":"test\/hotspot\/gtest\/gtestMain.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    ReservedSpace rs = MemoryReserver::reserve(size, alignment, page_size);\n+    ReservedSpace rs = MemoryReserver::reserve(size, alignment, page_size, mtTest);\n@@ -104,1 +104,1 @@\n-    ReservedSpace rs = MemoryReserver::reserve(size, alignment, page_size);\n+    ReservedSpace rs = MemoryReserver::reserve(size, alignment, page_size, mtTest);\n@@ -220,1 +220,2 @@\n-                                       os::vm_page_size());\n+                                       os::vm_page_size(),\n+                                       mtTest);\n@@ -299,1 +300,1 @@\n-  ReservedSpace reserved = MemoryReserver::reserve(large_page_size, large_page_size, large_page_size);\n+  ReservedSpace reserved = MemoryReserver::reserve(large_page_size, large_page_size, large_page_size, mtTest);\n@@ -368,1 +369,2 @@\n-                                               page_size);\n+                                               page_size,\n+                                               mtTest);\n@@ -413,1 +415,2 @@\n-                                               page_size);\n+                                               page_size,\n+                                               mtTest);\n@@ -517,1 +520,2 @@\n-      return MemoryReserver::reserve(reserve_size_aligned, mtTest);\n+      return MemoryReserver::reserve(reserve_size_aligned,\n+                                     mtTest);\n@@ -522,1 +526,2 @@\n-                                     os::vm_page_size());\n+                                     os::vm_page_size(),\n+                                     mtTest);\n@@ -579,1 +584,2 @@\n-                                                     large_page_size);\n+                                                     large_page_size,\n+                                                     mtTest);\n","filename":"test\/hotspot\/gtest\/memory\/test_virtualspace.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-  char* addr = os::reserve_memory(sz, false, mtTest);\n+  char* addr = os::reserve_memory(sz, mtTest);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_locationprinting.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    char* base = os::reserve_memory(size, !ExecMem, mtThreadStack);\n+    char* base = os::reserve_memory(size, mtThreadStack);\n@@ -162,1 +162,1 @@\n-    char* base = os::reserve_memory(size, !ExecMem, mtTest);\n+    char* base = os::reserve_memory(size, mtTest);\n@@ -208,1 +208,1 @@\n-    char* base = os::reserve_memory(size, !ExecMem, mtTest);\n+    char* base = os::reserve_memory(size, mtTest);\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-  char* two_pages = os::reserve_memory(ps * 2, false, mtTest);\n+  char* two_pages = os::reserve_memory(ps * 2, mtTest);\n@@ -496,1 +496,1 @@\n-  char* p = os::reserve_memory(len, executable);\n+  char* p = os::reserve_memory(len, mtTest, executable);\n@@ -534,1 +534,1 @@\n-    p = (address)os::reserve_memory(total_range_len);\n+    p = (address)os::reserve_memory(total_range_len, mtTest);\n@@ -548,1 +548,1 @@\n-      q = (address)os::attempt_reserve_memory_at((char*)q, stripe_len, executable);\n+      q = (address)os::attempt_reserve_memory_at((char*)q, stripe_len, mtTest, executable);\n@@ -568,1 +568,1 @@\n-  address p = (address)os::reserve_memory(total_range_len);\n+  address p = (address)os::reserve_memory(total_range_len, mtTest);\n@@ -635,1 +635,1 @@\n-  address p2 = (address)os::attempt_reserve_memory_at((char*)p_middle_stripes, middle_stripe_len);\n+  address p2 = (address)os::attempt_reserve_memory_at((char*)p_middle_stripes, middle_stripe_len, mtTest);\n@@ -658,1 +658,1 @@\n-  char* p = os::reserve_memory(4 * M);\n+  char* p = os::reserve_memory(4 * M, mtTest);\n@@ -693,1 +693,1 @@\n-  address p2 = (address)os::attempt_reserve_memory_at((char*)border, stripe_len);\n+  address p2 = (address)os::attempt_reserve_memory_at((char*)border, stripe_len, mtTest);\n@@ -734,1 +734,1 @@\n-  char* p = os::reserve_memory(1 * M, false, mtInternal);\n+  char* p = os::reserve_memory(1 * M, mtTest);\n@@ -758,1 +758,1 @@\n-    address p = (address)os::reserve_memory(total_range_len);\n+    address p = (address)os::reserve_memory(total_range_len, mtTest);\n@@ -1063,1 +1063,1 @@\n-  char* p1 = os::reserve_memory(M, false, mtTest);\n+  char* p1 = os::reserve_memory(M, mtTest);\n@@ -1065,1 +1065,1 @@\n-  char* p2 = os::attempt_reserve_memory_at(p1, M);\n+  char* p2 = os::attempt_reserve_memory_at(p1, M, mtTest);\n@@ -1073,1 +1073,1 @@\n-    char* p1 = os::reserve_memory_aligned(lpsz, lpsz, false);\n+    char* p1 = os::reserve_memory_aligned(lpsz, lpsz, mtTest);\n@@ -1099,1 +1099,1 @@\n-  char* base = os::reserve_memory(size, false, mtTest);\n+  char* base = os::reserve_memory(size, mtTest);\n@@ -1123,1 +1123,1 @@\n-  char* base = os::reserve_memory(size, false, mtTest);\n+  char* base = os::reserve_memory(size, mtTest, false);\n@@ -1161,1 +1161,1 @@\n-  char* result = os::map_memory(fd, path, 0, nullptr, size, true, false, mtTest);\n+  char* result = os::map_memory(fd, path, 0, nullptr, size, mtTest, true, false);\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M);\n+    char* p = os::attempt_reserve_memory_at((char*)0x1f00000, M, mtTest);\n@@ -39,1 +39,1 @@\n-    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M);\n+    p = os::attempt_reserve_memory_at((char*)((64 * G) + M), M, mtTest);\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_aix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-  char* const heap = os::reserve_memory(size, false, mtInternal);\n+  char* const heap = os::reserve_memory(size, mtTest);\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-        _base = os::attempt_reserve_memory_at((char*)candidate, _len);\n+        _base = os::attempt_reserve_memory_at((char*)candidate, _len, mtTest);\n@@ -168,2 +168,2 @@\n-    _p1 = os::attempt_reserve_memory_at(_base + _p1_offset, _p1_size);\n-    _p2 = os::attempt_reserve_memory_at(_base + _p2_offset, _p2_size);\n+    _p1 = os::attempt_reserve_memory_at(_base + _p1_offset, _p1_size, mtTest);\n+    _p2 = os::attempt_reserve_memory_at(_base + _p2_offset, _p2_size, mtTest);\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_reserve_between.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n@@ -52,0 +54,1 @@\n+BEGIN_ALLOW_FORBIDDEN_FUNCTIONS\n@@ -54,0 +57,1 @@\n+END_ALLOW_FORBIDDEN_FUNCTIONS\n","filename":"test\/hotspot\/gtest\/unittest.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,0 +81,5 @@\n+compiler\/c2\/TestVerifyConstraintCasts.java 8355574 generic-all\n+\n+compiler\/c2\/irTests\/TestFloat16ScalarOperations.java 8355708 linux-aarch64\n+compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java 8355708 linux-aarch64\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -472,1 +472,2 @@\n- -runtime\/cds\/appcds\/LotsOfClasses.java \\\n+ -runtime\/cds\/appcds\/LotsOfJRTClasses.java \\\n+ -runtime\/cds\/appcds\/LotsOfSyntheticClasses.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8346836\n+ * @requires vm.debug == true & vm.flavor == \"server\"\n+ * @summary Empty main program to run with flag VerifyConstraintCasts.\n+ *\n+ * @run main\/othervm\/timeout=300 -Xbatch -Xcomp -XX:+StressGCM -XX:VerifyConstraintCasts=1 compiler.c2.TestVerifyConstraintCasts\n+ * @run main\/othervm\/timeout=300 -Xbatch -Xcomp -XX:+StressGCM -XX:VerifyConstraintCasts=2 compiler.c2.TestVerifyConstraintCasts\n+ *\/\n+package compiler.c2;\n+\n+public class TestVerifyConstraintCasts {\n+    public static void main(String[] args) {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestVerifyConstraintCasts.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8319372 8320909\n+ * @summary Missed optimization in IGVN because `CastIINode::Value` used to\n+ *          look for deep structures. Reported in 8320909. Fixed in 8319372.\n+ *\n+ * @run main\/othervm\n+ *           -XX:CompileCommand=quiet\n+ *           -XX:CompileCommand=compileonly,MissedOptCastII::*\n+ *           -XX:-TieredCompilation -Xcomp\n+ *           -XX:+IgnoreUnrecognizedVMOptions\n+ *           -XX:+UnlockDiagnosticVMOptions\n+ *           -XX:+StressIGVN -XX:VerifyIterativeGVN=10\n+ *           MissedOptCastII\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8319372 8320909\n+ *\n+ * @run main\/othervm MissedOptCastII\n+ *\/\n+\n+public class MissedOptCastII {\n+    static long res = 0;\n+\n+    static void test() {\n+        int i, i1 = 0, k, l = -4;\n+        for (i = 0; i < 100; i++) {\n+            for (int j = 0; j < 10; j++) {\n+                for (k = 1; k < 2; k++) {\n+                    i1 = l;\n+                    l += k * k;\n+                    if (l != 0) {\n+                        res = i + i1 + Float.floatToIntBits(2);\n+                    }\n+                }\n+            }\n+        }\n+        res = i + i1;\n+    }\n+\n+    public static void main(String[] args) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/MissedOptCastII.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8320909\n+ * @summary AndNode has a special handling when one of the operands is a LShiftNode:\n+ *          (LHS << s) & RHS\n+ *          if RHS fits in less than s bits, the value of this expression is 0.\n+ *          The case where there is a conversion node between the Shift and the And as in:\n+ *          AndLNode(ConvI2L(LShiftI(LHS, s)), RHS)\n+ *          is also handled, but the AndL must be pushed directly in IGVN's worklist because\n+ *          ConvI2L might not have an update when its input change. In this example, the\n+ *          input was a Phi with a dead branch and becomes a LShiftI with the same type.\n+ *\n+ * @run main\/othervm\n+ *          -XX:CompileOnly=MissedOptWithShiftConvAnd::test\n+ *          -XX:-TieredCompilation -Xbatch\n+ *          -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=10\n+ *          MissedOptWithShiftConvAnd\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8320909\n+ *\n+ * @run main\/othervm MissedOptWithShiftConvAnd\n+ *\/\n+\n+public class MissedOptWithShiftConvAnd {\n+    static long lFld;\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 100; i++) {\n+            test();\n+        }\n+    }\n+\n+    static void test() {\n+        long l3 = 0;\n+        int i13 = 1;\n+        for (l3 = 8; l3 < 200; ++l3) {\n+            for (int i12 = 1; i12 < 2; i12++) {\n+                i13 <<= 73;\n+            }\n+        }\n+        for (int i14 = 1; 2 > i14; ++i14) {\n+            i13 &= l3;\n+            lFld = i13;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/MissedOptWithShiftConvAnd.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8320909\n+ * @summary Similar to MissedOptWithShiftConvAnd, but with CastII on the way.\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm\n+ *          -XX:CompileOnly=MissedOptWithShiftConvCastAnd::test\n+ *          -XX:-TieredCompilation -Xbatch\n+ *          -XX:+IgnoreUnrecognizedVMOptions -XX:VerifyIterativeGVN=10\n+ *          MissedOptWithShiftConvCastAnd\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8320909\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm MissedOptWithShiftConvCastAnd\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+public class MissedOptWithShiftConvCastAnd {\n+    static long instanceCount;\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread thread = new Thread() {\n+            public void run() {\n+                test(0);\n+            }\n+        };\n+        \/\/ Give thread some time to trigger compilation\n+        thread.setDaemon(true);\n+        thread.start();\n+        Thread.sleep(Utils.adjustTimeout(500));\n+    }\n+\n+    static void test(int x) {\n+        for (int i = 3; ; ++i) {\n+            for (int j = 5; j > 1; --j) {\n+                instanceCount >>= x <<= 16;\n+            }\n+            x >>>= 16;\n+            for (int j = 1; j < 5; j++) {\n+                try {\n+                    x = 1;\n+                } catch (ArithmeticException a_e) {\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/MissedOptWithShiftConvCastAnd.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -58,0 +58,3 @@\n+    @IR(counts = {IRNode.REINTERPRET_S2HF, \">=1\", IRNode.REINTERPRET_HF2S, \">=1\", IRNode.ADD_HF, \">=1\" },\n+        failOn = {IRNode.ADD_F, IRNode.CONV_HF2F, IRNode.CONV_F2HF},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConvF2HFIdealizationTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,0 +59,4 @@\n+    @IR(counts = {IRNode.ADD_HF, \"1\"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"},\n+        failOn = {IRNode.MUL_HF})\n+    \/\/ Test if x * 2 is optimized to x + x\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+    private float[] fl;\n+\n@@ -79,0 +81,1 @@\n+        fl = new float[count];\n@@ -81,0 +84,1 @@\n+            fl[i] = r.nextFloat();\n@@ -102,0 +106,14 @@\n+    @Test\n+    @IR(counts = {\"convF2HFAndS2HF\", \" >0 \"}, phase = {CompilePhase.FINAL_CODE},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    @IR(counts = {\"convF2HFAndS2HF\", \" >0 \"}, phase = {CompilePhase.FINAL_CODE},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testconvF2HFAndS2HF() {\n+        for (int i = 0; i < count; i++) {\n+            \/\/ Transform the pattern (S2HF ConvF2HF) in this IR -\n+            \/\/ HF2S (AddHF (S2HF (ConvF2HF fl[i])), (S2HF (ConvF2HF fl[i])))\n+            \/\/ to a single convert operation after matching and eliminate redundant moves\n+            dst[i] = float16ToRawShortBits(add(valueOf(fl[i]), valueOf(fl[i])));\n+        }\n+    }\n+\n@@ -105,0 +123,2 @@\n+    @IR(counts = {\"convHF2SAndHF2F\", \" >0 \"}, phase = {CompilePhase.FINAL_CODE},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -110,0 +130,1 @@\n+            \/\/ Also, the backend optimizes away the extra move while converting res to a float - ConvHF2F (S2HF (AddHF ..))\n@@ -118,0 +139,2 @@\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -129,0 +152,2 @@\n+    @IR(failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -141,0 +166,2 @@\n+    @IR(counts = {IRNode.SUB_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -152,0 +179,2 @@\n+    @IR(counts = {IRNode.MUL_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -163,0 +192,2 @@\n+    @IR(counts = {IRNode.DIV_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -174,0 +205,2 @@\n+    @IR(counts = {IRNode.DIV_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -185,0 +218,2 @@\n+    @IR(counts = {IRNode.MAX_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -196,0 +231,2 @@\n+    @IR(counts = {IRNode.MIN_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -207,0 +244,2 @@\n+    @IR(counts = {IRNode.SQRT_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -218,0 +257,2 @@\n+    @IR(counts = {IRNode.FMA_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -230,0 +271,2 @@\n+    @IR(counts = {IRNode.MUL_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -247,0 +290,2 @@\n+    @IR(counts = {IRNode.MUL_HF, \" 0 \", IRNode.ADD_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -284,0 +329,2 @@\n+    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -327,0 +374,2 @@\n+    @IR(counts = {IRNode.SUB_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -360,0 +409,2 @@\n+    @IR(counts = {IRNode.MAX_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -378,0 +429,2 @@\n+    @IR(counts = {IRNode.MIN_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -395,0 +448,2 @@\n+    @IR(counts = {IRNode.DIV_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -435,0 +490,2 @@\n+    @IR(counts = {IRNode.MUL_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -458,0 +515,2 @@\n+    @IR(counts = {IRNode.SQRT_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -477,0 +536,2 @@\n+    @IR(counts = {IRNode.FMA_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -512,0 +573,2 @@\n+    @IR(failOn = {IRNode.ADD_HF, IRNode.SUB_HF, IRNode.MUL_HF, IRNode.DIV_HF, IRNode.SQRT_HF, IRNode.FMA_HF},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -551,0 +614,3 @@\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \",\n+                  IRNode.DIV_HF, \" >0 \", IRNode.SQRT_HF, \" >0 \", IRNode.FMA_HF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFloat16ScalarOperations.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349139\n+ * @summary C2: Div looses dependency on condition that guarantees divisor not null in counted loop\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestDivDependentOnMainLoopGuard::*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:StressSeed=35878193 TestDivDependentOnMainLoopGuard\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestDivDependentOnMainLoopGuard::*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestDivDependentOnMainLoopGuard\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=TestDivDependentOnMainLoopGuard::* TestDivDependentOnMainLoopGuard\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+\n+public class TestDivDependentOnMainLoopGuard {\n+\n+    public static final int N = 400;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    public static final int stop = RANDOM.nextInt(0, 68);\n+\n+    public int iArrFld[]=new int[N];\n+\n+    public void mainTest(String[] strArr1, int otherPhi) {\n+\n+        int i=57657, i1=577, i2=6, i3=157, i4=12, i23=61271;\n+        boolean bArr[]=new boolean[N];\n+\n+        for (i = 9; 379 > i; i++) {\n+            i2 = 1;\n+            do {\n+                i1 <<= i3;\n+            } while (++i2 < 68);\n+            for (i23 = 68; i23 > stop; otherPhi=i23-1, i23--) {\n+                bArr[i23 + 1] = true;\n+                try {\n+                    i1 = (-42360 \/ i23);\n+                    iArrFld[i + 1] = otherPhi;\n+                } catch (ArithmeticException a_e) {}\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestDivDependentOnMainLoopGuard _instance = new TestDivDependentOnMainLoopGuard();\n+        for (int i = 0; i < 10; i++ ) {\n+            _instance.mainTest(strArr, 0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestDivDependentOnMainLoopGuard.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349139\n+ * @summary C2: Div looses dependency on condition that guarantees divisor not null in counted loop\n+ * @run main\/othervm -XX:-BackgroundCompilation TestMainLoopNoBackedgeFloatingDiv\n+ *\/\n+\n+public class TestMainLoopNoBackedgeFloatingDiv {\n+    private static int field;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+           test1(1000, 0, false);\n+           test1Helper(1000, 0, false, false);\n+        }\n+       test1(1, 0, false);\n+    }\n+\n+    private static int test1(int stop, int res, boolean alwaysTrueInMain) {\n+        stop = Integer.max(stop, 1);\n+        res = test1Helper(stop, res, alwaysTrueInMain, true);\n+        return res;\n+    }\n+\n+    private static int test1Helper(int stop, int res, boolean alwaysTrueInMain, boolean flag) {\n+        for (int i = stop; i >= 1; i--) {\n+            res = res \/ i;\n+            if (alwaysTrueInMain) {\n+                break;\n+            }\n+            alwaysTrueInMain = flag;\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestMainLoopNoBackedgeFloatingDiv.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -58,3 +58,2 @@\n-    \/\/ TODO: uncomment once Float16 support lands in aarch64 with JDK-8345125\n-    \/\/@IR(counts = { IRNode.SUB, \"2\" }, applyIfPlatform = {\"aarch64\", \"true\"}, applyIfCPUFeatureAnd = {\"fphp\", \"false\", \"asimdhp\", \"false\"})\n-    \/\/@IR(counts = { IRNode.SUB_HF, \"2\" }, applyIfPlatform = {\"aarch64\", \"true\"}, applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    @IR(counts = { IRNode.SUB, \"2\" }, applyIfPlatform = {\"aarch64\", \"true\"}, applyIfCPUFeatureAnd = {\"fphp\", \"false\", \"asimdhp\", \"false\"})\n+    @IR(counts = { IRNode.SUB_HF, \"2\" }, applyIfPlatform = {\"aarch64\", \"true\"}, applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestSubNodeFloatDoubleNegation.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1388,0 +1388,40 @@\n+    public static final String UMIN_VB = VECTOR_PREFIX + \"UMIN_VB\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VB, \"UMinV\", TYPE_BYTE);\n+    }\n+\n+    public static final String UMIN_VS = VECTOR_PREFIX + \"UMIN_VS\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VS, \"UMinV\", TYPE_SHORT);\n+    }\n+\n+    public static final String UMIN_VI = VECTOR_PREFIX + \"UMIN_VI\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VI, \"UMinV\", TYPE_INT);\n+    }\n+\n+    public static final String UMIN_VL = VECTOR_PREFIX + \"UMIN_VL\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VL, \"UMinV\", TYPE_LONG);\n+    }\n+\n+    public static final String UMAX_VB = VECTOR_PREFIX + \"UMAX_VB\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VB, \"UMaxV\", TYPE_BYTE);\n+    }\n+\n+    public static final String UMAX_VS = VECTOR_PREFIX + \"UMAX_VS\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VS, \"UMaxV\", TYPE_SHORT);\n+    }\n+\n+    public static final String UMAX_VI = VECTOR_PREFIX + \"UMAX_VI\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VI, \"UMaxV\", TYPE_INT);\n+    }\n+\n+    public static final String UMAX_VL = VECTOR_PREFIX + \"UMAX_VL\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VL, \"UMaxV\", TYPE_LONG);\n+    }\n+\n@@ -1525,0 +1565,5 @@\n+    public static final String OPAQUE_TEMPLATE_ASSERTION_PREDICATE = PREFIX + \"OPAQUE_TEMPLATE_ASSERTION_PREDICATE\" + POSTFIX;\n+    static {\n+        duringLoopOpts(OPAQUE_TEMPLATE_ASSERTION_PREDICATE, \"OpaqueTemplateAssertionPredicate\");\n+    }\n+\n@@ -1631,1 +1676,1 @@\n-        parsePredicateNodes(LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"Loop Limit Check\");\n+        parsePredicateNodes(LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"Loop_Limit_Check\");\n@@ -1636,1 +1681,6 @@\n-        parsePredicateNodes(PROFILED_LOOP_PARSE_PREDICATE, \"Profiled Loop\");\n+        parsePredicateNodes(PROFILED_LOOP_PARSE_PREDICATE, \"Profiled_Loop\");\n+    }\n+\n+    public static final String AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE = PREFIX + \"AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE\" + POSTFIX;\n+    static {\n+        parsePredicateNodes(AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"Auto_Vectorization_Check\");\n@@ -2186,0 +2236,20 @@\n+    public static final String RISCV_VAND_NOTI_VX = PREFIX + \"RISCV_VAND_NOTI_VX\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTI_VX, \"vand_notI_vx\");\n+    }\n+\n+    public static final String RISCV_VAND_NOTL_VX = PREFIX + \"RISCV_VAND_NOTL_VX\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTL_VX, \"vand_notL_vx\");\n+    }\n+\n+    public static final String RISCV_VAND_NOTI_VX_MASKED = PREFIX + \"RISCV_VAND_NOTI_VX_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTI_VX_MASKED, \"vand_notI_vx_masked\");\n+    }\n+\n+    public static final String RISCV_VAND_NOTL_VX_MASKED = PREFIX + \"RISCV_VAND_NOTL_VX_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTL_VX_MASKED, \"vand_notL_vx_masked\");\n+    }\n+\n@@ -2886,0 +2956,10 @@\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#BEFORE_LOOP_OPTS}\n+     * up to and including {@link CompilePhase#AFTER_LOOP_OPTS}.\n+     *\/\n+    private static void duringLoopOpts(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.AFTER_LOOP_OPTS, regex,\n+                                                                          CompilePhase.BEFORE_LOOP_OPTS,\n+                                                                          CompilePhase.AFTER_LOOP_OPTS));\n+    }\n+\n@@ -2892,1 +2972,1 @@\n-        String regex = START + \"ParsePredicate\" + MID + \"#\" + label + \"[ ]*!jvms:\" + END;\n+        String regex = START + \"ParsePredicate\" + MID + \"#\" + label + \" \" + END;\n@@ -2895,1 +2975,1 @@\n-                                                                          CompilePhase.PHASEIDEALLOOP_ITERATIONS));\n+                                                                          CompilePhase.AFTER_LOOP_OPTS));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":84,"deletions":4,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -112,0 +112,2 @@\n+        \"fphp\",\n+        \"asimdhp\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8346552\n+ * @summary Test that all parse predicates are cloned after loop unswitching.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.TestUnswitchPredicateCloning\n+ *\/\n+\n+public class TestUnswitchPredicateCloning {\n+    static final int SIZE = 100;\n+\n+    private static final Random random = Utils.getRandomInstance();\n+\n+    public static void main(String[] strArr) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"testUnswitchingBeforePredication\", \"testPredicationBeforeUnswitching\", \"testUnswitchingUncounted\"})\n+    @Warmup(0)\n+    private static void runNoWarmup() {\n+        final int idx = random.nextInt(SIZE);\n+        final boolean cond = random.nextBoolean();\n+        int res = testUnswitchingBeforePredication(idx);\n+        Asserts.assertEQ(SIZE * idx, res);\n+        res = testPredicationBeforeUnswitching(idx, cond);\n+        Asserts.assertEQ((SIZE * (SIZE - 1)) \/ 2 + (cond ? SIZE * idx : 0), res);\n+        res = testUnswitchingUncounted(cond);\n+        Asserts.assertEQ((SIZE * (SIZE - 1)) \/ 2 + (cond ? SIZE : 0), res);\n+    }\n+\n+    @DontInline\n+    private static int[] getArr() {\n+        int[] arr = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            arr[i] = i;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    \/\/ Check that Loop Unswitching doubled the number of Parse Predicates: We have\n+    \/\/ them at the true- and false-path-loop. Note that the Loop Limit Check Parse\n+    \/\/ Predicate is not cloned when we already have a counted loop.\n+    @IR(counts = { IRNode.LOOP_PARSE_PREDICATE, \"3\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"3\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"3\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"3\" },\n+        phase = CompilePhase.BEFORE_LOOP_UNSWITCHING)\n+    \/\/ Since we know that Loop Predication happens after Loop Unswitching, we can test the\n+    \/\/ have already been removed in the beautify loop phase.\n+    @IR(counts = { IRNode.LOOP_PARSE_PREDICATE, \"4\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"4\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"3\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"4\" },\n+        phase = CompilePhase.BEFORE_LOOP_PREDICATION_RC)\n+    \/\/ Check that Opaque Template Assertion Predicates are added in Loop Predication\n+    \/\/ even if Loop Predication only happens after Loop Unswitching.\n+    @IR(failOn = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE },\n+        phase = CompilePhase.AFTER_LOOP_UNSWITCHING)\n+    @IR(counts = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE, \"2\" },\n+        phase = CompilePhase.AFTER_LOOP_PREDICATION_RC)\n+    static int testUnswitchingBeforePredication(int j) {\n+        int zero = 34;\n+        int limit = 2;\n+\n+        \/\/ Ensure zero == 0 is only known after CCP\n+        for (; limit < 4; limit *= 2) {\n+        }\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        int[] arr = getArr();\n+        int res = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            \/\/ Trigger unswitching only after CCP\n+            if (zero == 0) {\n+                \/\/ Trigger range check after loop unswitching\n+                res += arr[j];\n+            } else {\n+                res += arr[i];\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Check that Loop Unswitching doubled the number of Parse and Template\n+    \/\/ Assertion Predicates. Again, the Loop Limit Check Parse Predicate\n+    \/\/ remains at the Loop Selector since this is a counted loop.\n+    @IR(failOn = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE },\n+        phase = CompilePhase.BEFORE_LOOP_PREDICATION_RC)\n+    @IR(counts = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE, \"2\",\n+                   IRNode.LOOP_PARSE_PREDICATE, \"1\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"1\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"1\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"1\" },\n+        phase = CompilePhase.BEFORE_LOOP_UNSWITCHING)\n+    \/\/ After Loop Unswitching and after removing the killed predicates.\n+    @IR(counts = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE, \"4\",\n+                   IRNode.LOOP_PARSE_PREDICATE, \"2\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"2\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"1\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"2\" },\n+        phase = CompilePhase.PHASEIDEALLOOP2)\n+    static int testPredicationBeforeUnswitching(int j, boolean cond) {\n+        int[] arr = getArr();\n+        int res = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            if (cond) {\n+                res += arr[j];\n+            }\n+            res += arr[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Check that Loop Unswitching doubled the number of all Parse Predicates.\n+    \/\/ Since this is not counted loop, the Loop Limit Check Parse Predicate\n+    \/\/ has to be cloned to both unswitched loops.\n+    @IR(counts = { IRNode.LOOP_PARSE_PREDICATE, \"1\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"1\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"1\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"1\" },\n+        phase = CompilePhase.BEFORE_LOOP_UNSWITCHING)\n+    \/\/ After Loop Unswitching and after removing the killed predicates all\n+    \/\/ Parse Predicates are doubled.\n+    @IR(counts = { IRNode.LOOP_PARSE_PREDICATE, \"2\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"2\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"2\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"2\" },\n+        failOn = { IRNode.COUNTED_LOOP },\n+        phase = CompilePhase.PHASEIDEALLOOP1)\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    static int testUnswitchingUncounted(boolean cond) {\n+        int[] arr = getArr();\n+        int res = 0;\n+        int i = 0;\n+        while (i < arr.length) {\n+            if (cond) {\n+                res += 1;\n+            }\n+            res += arr[i];\n+\n+            i = arr[i] + 1; \/\/ effectively i += 1, but don't tell the compiler!\n+        }\n+\n+        return res;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestUnswitchPredicateCloning.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -91,0 +91,4 @@\n+    \/\/ There is no efficient way to implement strict-ordered version on riscv64.\n+    @IR(applyIf = {\"SuperWordReductions\", \"true\"},\n+        applyIfCPUFeature = {\"rvv\", \"true\"},\n+        failOn = {IRNode.MUL_REDUCTION_VD})\n@@ -104,0 +108,4 @@\n+    \/\/ There is no efficient way to implement strict-ordered version on riscv64.\n+    @IR(applyIf = {\"SuperWordReductions\", \"true\"},\n+        applyIfCPUFeature = {\"rvv\", \"true\"},\n+        failOn = {IRNode.MUL_REDUCTION_VD})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Double.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -89,0 +89,4 @@\n+    \/\/ There is no efficient way to implement strict-ordered version on riscv64.\n+    @IR(applyIfCPUFeature = {\"rvv\", \"true\"},\n+        applyIf = {\"SuperWordReductions\", \"true\"},\n+        failOn = {IRNode.MUL_REDUCTION_VF})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Float.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,2 +88,1 @@\n-    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n-        applyIfCPUFeature = {\"rvv\", \"true\"},\n+    @IR(applyIfCPUFeature = {\"rvv\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Int.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n@@ -30,1 +31,1 @@\n- * @requires vm.debug & vm.compiler2.enabled & (os.simpleArch == \"x64\" | os.arch == \"aarch64\")\n+ * @requires vm.debug & vm.compiler2.enabled & (os.simpleArch == \"x64\" | os.arch == \"aarch64\" | os.arch == \"riscv64\")\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -157,0 +157,62 @@\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.RISCV_VAND_NOTI_VX, \" >= 1\" }, applyIfPlatform = {\"riscv64\", \"true\"})\n+    public static void testAllBitsSetVectorRegI() {\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        int bs = ib[0];\n+        av.not().lanewise(VectorOperators.AND_NOT, bs).intoArray(ir, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            Asserts.assertEquals((~ia[i]) & (~bs), ir[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.RISCV_VAND_NOTL_VX, \" >= 1\" }, applyIfPlatform = {\"riscv64\", \"true\"})\n+    public static void testAllBitsSetVectorRegL() {\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        long bs = lb[0];\n+        av.not().lanewise(VectorOperators.AND_NOT, bs).intoArray(lr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            Asserts.assertEquals((~la[i]) & (~bs), lr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.RISCV_VAND_NOTI_VX_MASKED, \" >= 1\" }, applyIfPlatform = {\"riscv64\", \"true\"})\n+    public static void testAllBitsSetVectorRegIMask() {\n+        VectorMask<Integer> avm = VectorMask.fromArray(I_SPECIES, ma, 0);\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        int bs = ib[0];\n+        av.not().lanewise(VectorOperators.AND_NOT, bs, avm).intoArray(ir, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            if (ma[i] == true) {\n+                Asserts.assertEquals((~ia[i]) & (~bs), ir[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.RISCV_VAND_NOTL_VX_MASKED, \" >= 1\" }, applyIfPlatform = {\"riscv64\", \"true\"})\n+    public static void testAllBitsSetVectorRegLMask() {\n+        VectorMask<Long> avm = VectorMask.fromArray(L_SPECIES, ma, 0);\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        long bs = lb[0];\n+        av.not().lanewise(VectorOperators.AND_NOT, bs, avm).intoArray(lr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            if (ma[i] == true) {\n+                Asserts.assertEquals((~la[i]) & (~bs), lr[i]);\n+            }\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/AllBitsSetVectorMatchRuleTest.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        applyIfCPUFeature = {\"avx\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -118,1 +118,1 @@\n-        applyIfCPUFeature = {\"avx\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -175,1 +175,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -200,1 +200,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -225,1 +225,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -250,1 +250,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -275,1 +275,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -300,1 +300,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -325,1 +325,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -350,1 +350,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -375,1 +375,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -400,1 +400,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -425,1 +425,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 2 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -450,1 +450,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -475,1 +475,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -500,1 +500,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -525,1 +525,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeature = {\"avx\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n@@ -550,1 +550,1 @@\n-    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx512vl\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY, \" 3 \"}, applyIfCPUFeatureOr = {\"avx512vl\", \"true\", \"sve\", \"true\", \"rvv\", \"true\"})\n@@ -576,0 +576,50 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, IRNode.VECTOR_SIZE_ANY, \" 1 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    public void testVectorIRSharing20(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ UMax ((UMax vec1, vec2), (UMax vec2, vec1))\n+        vec1.lanewise(VectorOperators.UMAX, vec2)\n+            .lanewise(VectorOperators.UMAX, vec2.lanewise(VectorOperators.UMAX, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing20\")\n+    public void testVectorIRSharingDriver20() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing20(i);\n+        }\n+        checkVectorIRSharing20();\n+    }\n+\n+    public void checkVectorIRSharing20() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], VectorMath.maxUnsigned(ia[i], ib[i]));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, IRNode.VECTOR_SIZE_ANY, \" 1 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    public void testVectorIRSharing21(int index) {\n+        IntVector vec1 = IntVector.fromArray(I_SPECIES, ia, index);\n+        IntVector vec2 = IntVector.fromArray(I_SPECIES, ib, index);\n+        \/\/ UMin ((UMin vec1, vec2), (UMin vec2, vec1))\n+        vec1.lanewise(VectorOperators.UMIN, vec2)\n+            .lanewise(VectorOperators.UMIN, vec2.lanewise(VectorOperators.UMIN, vec1))\n+            .intoArray(ir1, index);\n+    }\n+\n+    @Run(test = \"testVectorIRSharing21\")\n+    public void testVectorIRSharingDriver21() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i += I_SPECIES.length()) {\n+            testVectorIRSharing21(i);\n+        }\n+        checkVectorIRSharing21();\n+    }\n+\n+    public void checkVectorIRSharing21() {\n+        for (int i = 0; i < I_SPECIES.loopBound(LENGTH); i++) {\n+            Verify.checkEQ(ir1[i], VectorMath.minUnsigned(ia[i], ib[i]));\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorCommutativeOperSharingTest.java","additions":68,"deletions":18,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -0,0 +1,472 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8342676\n+* @summary Unsigned Vector Min \/ Max transforms\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorapi.VectorUnsignedMinMaxOperationsTest\n+*\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.*;\n+import compiler.lib.ir_framework.*;\n+import java.util.stream.IntStream;\n+\n+public class VectorUnsignedMinMaxOperationsTest {\n+    private static final int COUNT = 2048;\n+    private static final VectorSpecies<Long> lspec    = LongVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> ispec = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Short> sspec   = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Byte> bspec    = ByteVector.SPECIES_PREFERRED;\n+\n+    private long[]  long_in1;\n+    private int[]   int_in1;\n+    private short[] short_in1;\n+    private byte[]  byte_in1;\n+\n+    private long[]  long_in2;\n+    private int[]   int_in2;\n+    private short[] short_in2;\n+    private byte[]  byte_in2;\n+\n+    private long[]  long_out;\n+    private int[]   int_out;\n+    private short[] short_out;\n+    private byte[]  byte_out;\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+\n+    public VectorUnsignedMinMaxOperationsTest() {\n+        byte_in1  = new byte[COUNT];\n+        short_in1 = new short[COUNT];\n+        int_in1   = new int[COUNT];\n+        long_in1  = new long[COUNT];\n+\n+        byte_in2  = new byte[COUNT];\n+        short_in2 = new short[COUNT];\n+        int_in2   = new int[COUNT];\n+        long_in2  = new long[COUNT];\n+        IntStream.range(0, COUNT).forEach(\n+            i -> {\n+                if ((i & 1) == 0) {\n+                    long_in1[i] = Long.MAX_VALUE;\n+                    long_in2[i] = i;\n+                    int_in1[i]  = Integer.MAX_VALUE;\n+                    int_in2[i]  = i;\n+                    short_in1[i] = Short.MAX_VALUE;\n+                    short_in2[i] = (short)i;\n+                    byte_in1[i]  = Byte.MAX_VALUE;\n+                    byte_in2[i]  = (byte)i;\n+                } else {\n+                    long_in1[i] = Long.MIN_VALUE;\n+                    long_in2[i] = -i;\n+                    int_in1[i]  = Integer.MIN_VALUE;\n+                    int_in2[i]  = -i;\n+                    short_in1[i] = Short.MIN_VALUE;\n+                    short_in2[i] = (short)-i;\n+                    byte_in1[i]  = Byte.MIN_VALUE;\n+                    byte_in2[i]  = (byte)-i;\n+                }\n+            }\n+        );\n+        long_out  = new long[COUNT];\n+        int_out   = new int[COUNT];\n+        short_out = new short[COUNT];\n+        byte_out  = new byte[COUNT];\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VB, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umax_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                      .lanewise(VectorOperators.UMAX,\n+                                ByteVector.fromArray(bspec, byte_in2, i))\n+                      .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_byte\", when = CheckAt.COMPILED)\n+    public void umax_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.maxUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VS, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umax_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                       .lanewise(VectorOperators.UMAX,\n+                                 ShortVector.fromArray(sspec, short_in2, i))\n+                       .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_short\", when = CheckAt.COMPILED)\n+    public void umax_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.maxUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umax_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_int\", when = CheckAt.COMPILED)\n+    public void umax_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VL, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umax_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                      .lanewise(VectorOperators.UMAX,\n+                                LongVector.fromArray(lspec, long_in2, i))\n+                      .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_long\", when = CheckAt.COMPILED)\n+    public void umax_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.maxUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VB, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_byte() {\n+        for (int i = 0; i < COUNT; i += bspec.length()) {\n+            ByteVector.fromArray(bspec, byte_in1, i)\n+                      .lanewise(VectorOperators.UMIN,\n+                                ByteVector.fromArray(bspec, byte_in2, i))\n+                      .intoArray(byte_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_byte\", when = CheckAt.COMPILED)\n+    public void umin_byte_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            byte actual = byte_out[i];\n+            byte expected = VectorMath.minUnsigned(byte_in1[i], byte_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VS, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_short() {\n+        for (int i = 0; i < COUNT; i += sspec.length()) {\n+            ShortVector.fromArray(sspec, short_in1, i)\n+                       .lanewise(VectorOperators.UMIN,\n+                                 ShortVector.fromArray(sspec, short_in2, i))\n+                       .intoArray(short_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_short\", when = CheckAt.COMPILED)\n+    public void umin_short_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            short actual = short_out[i];\n+            short expected = VectorMath.minUnsigned(short_in1[i], short_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_int() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               IntVector.fromArray(ispec, int_in2, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_int\", when = CheckAt.COMPILED)\n+    public void umin_int_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(int_in1[i], int_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VL, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_long() {\n+        for (int i = 0; i < COUNT; i += lspec.length()) {\n+            LongVector.fromArray(lspec, long_in1, i)\n+                      .lanewise(VectorOperators.UMIN,\n+                                LongVector.fromArray(lspec, long_in2, i))\n+                      .intoArray(long_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_long\")\n+    public void umin_long_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            long actual = long_out[i];\n+            long expected = VectorMath.minUnsigned(long_in1[i], long_in2[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_ir_transform1() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMIN,\n+                               IntVector.fromArray(ispec, int_in1, i))\n+                     .intoArray(int_out, i);\n+       }\n+    }\n+\n+    @Check(test = \"umin_ir_transform1\", when = CheckAt.COMPILED)\n+    public void umin_ir_transform1_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(int_in1[i], int_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umax_ir_transform1() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector.fromArray(ispec, int_in1, i)\n+                     .lanewise(VectorOperators.UMAX,\n+                               IntVector.fromArray(ispec, int_in1, i))\n+                     .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umax_ir_transform1\", when = CheckAt.COMPILED)\n+    public void umax_ir_transform1_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(int_in1[i], int_in1[i]);\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \", IRNode.UMIN_VI, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform1() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMinV (UMinV vec1, vec2) (UMaxV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform1\", when = CheckAt.COMPILED)\n+    public void umin_max_ir_transform1_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \", IRNode.UMAX_VI, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform2() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMaxV (UMinV vec2, vec1) (UMaxV vec1, vec2) => UMaxV vec1 vec2\n+            vec2.lanewise(VectorOperators.UMIN, vec1)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform2\", when = CheckAt.COMPILED)\n+    public void umin_max_ir_transform2_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(int_in2[i], int_in1[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMAX_VI, \" 0 \", IRNode.UMIN_VI, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform3() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMaxV (UMinV vec1, vec2) (UMinV vec1, vec2) => UMinV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec1.lanewise(VectorOperators.UMIN, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform3\", when = CheckAt.COMPILED)\n+    public void umin_max_ir_transform3_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.minUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \", IRNode.UMAX_VI, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform4() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMinV (UMaxV vec2, vec1) (UMaxV vec1, vec2) => UMaxV vec1 vec2\n+            vec2.lanewise(VectorOperators.UMAX, vec1)\n+                .lanewise(VectorOperators.UMIN,\n+                          vec1.lanewise(VectorOperators.UMAX, vec2))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform4\", when = CheckAt.COMPILED)\n+    public void umin_max_ir_transform4_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.minUnsigned(VectorMath.maxUnsigned(int_in2[i], int_in1[i]),\n+                                                  VectorMath.maxUnsigned(int_in1[i], int_in2[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UMIN_VI, \" 0 \", IRNode.UMAX_VI, \" >0 \"}, applyIfCPUFeatureOr = {\"avx\", \"true\", \"rvv\", \"true\"})\n+    @Warmup(value = 10000)\n+    public void umin_max_ir_transform5() {\n+        for (int i = 0; i < COUNT; i += ispec.length()) {\n+            IntVector vec1 = IntVector.fromArray(ispec, int_in1, i);\n+            IntVector vec2 = IntVector.fromArray(ispec, int_in2, i);\n+            \/\/ UMaxV (UMinV vec1, vec2) (UMaxV vec2, vec1) => UMaxV vec1 vec2\n+            vec1.lanewise(VectorOperators.UMIN, vec2)\n+                .lanewise(VectorOperators.UMAX,\n+                          vec2.lanewise(VectorOperators.UMAX, vec1))\n+                .intoArray(int_out, i);\n+        }\n+    }\n+\n+    @Check(test = \"umin_max_ir_transform5\", when = CheckAt.COMPILED)\n+    public void umin_max_ir_transform5_verify() {\n+        for (int i = 0; i < COUNT; i++) {\n+            int actual = int_out[i];\n+            int expected = VectorMath.maxUnsigned(VectorMath.minUnsigned(int_in1[i], int_in2[i]),\n+                                                  VectorMath.maxUnsigned(int_in2[i], int_in1[i]));\n+            if (actual != expected) {\n+                throw new AssertionError(\"Result Mismatch : actual (\" +  actual + \") !=  expected (\" + expected  + \")\");\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorUnsignedMinMaxOperationsTest.java","additions":472,"deletions":0,"binary":false,"changes":472,"status":"added"},{"patch":"@@ -48,0 +48,2 @@\n+    @IR(applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"fphp\", \"false\", \"asimdhp\", \"false\"},\n+        counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorConvChain.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n@@ -78,1 +79,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n@@ -80,4 +81,1 @@\n-    @IR(applyIfCPUFeature = {\"avx512f\", \"true\"},\n-        counts = {IRNode.ROTATE_RIGHT_V, \">0\"})\n-    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n-        applyIfCPUFeature = {\"zvbb\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"zvbb\", \"true\"},\n@@ -94,1 +92,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n@@ -96,1 +94,1 @@\n-    @IR(applyIfCPUFeature = {\"avx512f\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"zvbb\", \"true\"},\n@@ -110,1 +108,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n@@ -112,4 +110,1 @@\n-    @IR(applyIfCPUFeature = {\"avx512f\", \"true\"},\n-        counts = {IRNode.ROTATE_RIGHT_V, \">0\"})\n-    @IR(applyIfPlatform = {\"riscv64\", \"true\"},\n-        applyIfCPUFeature = {\"zvbb\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"zvbb\", \"true\"},\n@@ -138,1 +133,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n@@ -140,1 +135,1 @@\n-    @IR(applyIfCPUFeature = {\"avx512f\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"avx512f\", \"true\", \"zvbb\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -78,1 +78,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"ssse3\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"ssse3\", \"true\", \"rvv\", \"true\"},\n@@ -89,1 +89,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -100,1 +100,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -111,1 +111,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n@@ -122,1 +122,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n@@ -133,1 +133,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse4.1\", \"true\", \"rvv\", \"true\"},\n@@ -144,1 +144,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\"},\n@@ -156,1 +156,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -167,1 +167,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -178,1 +178,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n@@ -189,1 +189,1 @@\n-    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\", \"rvv\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (C) 2025 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.arguments;\n+\n+\/*\n+ * @test TestG1CompressedOops\n+ * @bug 8354145\n+ * @requires vm.flagless\n+ * @summary Verify that the flag UseCompressedOops is updated properly\n+ * @library \/test\/lib\n+ * @library \/\n+ * @run driver gc.arguments.TestG1CompressedOops\n+ *\/\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestG1CompressedOops {\n+\n+  private static void checkG1CompressedOops(String[] flags, boolean expectedValue, int exitValue) throws Exception {\n+    ArrayList<String> flagList = new ArrayList<String>();\n+    flagList.addAll(Arrays.asList(flags));\n+    flagList.add(\"-XX:+UseG1GC\");\n+    flagList.add(\"-XX:+PrintFlagsFinal\");\n+    flagList.add(\"-version\");\n+\n+    OutputAnalyzer output = GCArguments.executeTestJava(flagList);\n+    output.shouldHaveExitValue(exitValue);\n+\n+    if (exitValue == 0) {\n+      String stdout = output.getStdout();\n+      boolean flagValue = getFlagValue(\"UseCompressedOops\", stdout);\n+      if (flagValue != expectedValue) {\n+        throw new RuntimeException(\"Wrong value for UseCompressedOops. Expected \" + expectedValue + \" but got \" + flagValue);\n+      }\n+    }\n+  }\n+\n+  private static boolean getFlagValue(String flag, String where) {\n+      Matcher m = Pattern.compile(flag + \"\\\\s+:?=\\\\s+\\\\D+\").matcher(where);\n+      if (!m.find()) {\n+          throw new RuntimeException(\"Could not find value for flag \" + flag + \" in output string\");\n+      }\n+      String match = m.group();\n+      return match.contains(\"true\");\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    checkG1CompressedOops(new String[] { \"-Xmx64m\"   \/* default is 1m *\/        }, true, 0);\n+    checkG1CompressedOops(new String[] { \"-Xmx64m\",  \"-XX:G1HeapRegionSize=2m\"  }, true, 0);\n+    checkG1CompressedOops(new String[] { \"-Xmx32768m\" \/* 32g will turn off the usecompressedoops *\/  }, false, 0);\n+    checkG1CompressedOops(new String[] { \"-Xmx32760m\" }, false, 0);\n+    checkG1CompressedOops(new String[] { \"-Xmx32736m\", \/* 32g - 32m will turn on the usecomppressedoops *\/ }, true, 0);\n+\n+    \/\/ if set G1HeapRegionSize explicitly with -Xmx32736m will turn off the UseCompressedOops\n+    checkG1CompressedOops(new String[] { \"-Xmx32736m\", \"-XX:G1HeapRegionSize=1m\" }, false, 0);\n+    checkG1CompressedOops(new String[] { \"-Xmx32256m\", \"-XX:G1HeapRegionSize=512m\" }, true, 0);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1CompressedOops.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,9 @@\n-    String bootCP = \"-Xbootclasspath\/a:\" + System.getProperty(\"test.src\")\n-                       + File.separator + \"dummy.jar\";\n+\n+    \/\/ Create an empty file in the scratch directory\n+    final String filename = \"empty.jar\";\n+    File emptyJar = new File(filename);\n+    emptyJar.createNewFile();\n+\n+    \/\/ Explicitly tell to use it for class loading\n+    String bootCP = \"-Xbootclasspath\/a:\" + emptyJar.getAbsolutePath();\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/LoadClass\/LoadClassNegative.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/LoadClass\/dummy.jar","additions":0,"deletions":0,"binary":false,"changes":0,"status":"deleted"},{"patch":"@@ -60,1 +60,1 @@\n-                        \"(malloc=\" + numKB + \"KB #1) (at peak)\"\n+                        \"(malloc=\" + numKB + \"KB tag=Test #1) (at peak)\" \/\/ (malloc=1KB tag=Test #1) (at peak)\n@@ -68,1 +68,1 @@\n-                        \"(malloc=0KB) (peak=\" + numKB + \"KB #1)\"\n+                        \"(malloc=0KB tag=Test) (peak=\" + numKB + \"KB #1)\"\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocRoundingReportTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-                         \"(malloc=384KB #2) (at peak)\"});\n+                         \"(malloc=384KB tag=Test #2) (at peak)\"});\n@@ -57,1 +57,1 @@\n-                         \"(malloc=512KB #1) (peak=768KB #2)\"});\n+                         \"(malloc=512KB tag=Test #1) (peak=768KB #2)\"});\n@@ -64,1 +64,1 @@\n-                         \"(malloc=0KB) (peak=768KB #2)\"});\n+                         \"(malloc=0KB tag=Test) (peak=768KB #2)\"});\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocTestType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-                \"(malloc=4KB #\" + mallocd_memory.size() + \") (at peak)\"\n+                \"(malloc=4KB tag=Test #\" + mallocd_memory.size() + \") (at peak)\"\n@@ -86,1 +86,1 @@\n-                \"(malloc=0KB) (peak=4KB #\" + + mallocd_memory.size() + \")\"\n+                \"(malloc=0KB tag=Test) (peak=4KB #\" + + mallocd_memory.size() + \")\"\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocTrackingVerify.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-            \"(malloc=896KB #3) (at peak)\"\n+            \"(malloc=896KB tag=Test #3) (at peak)\"\n@@ -81,1 +81,1 @@\n-            \"(malloc=0KB) (peak=896KB #3)\"\n+            \"(malloc=0KB tag=Test) (peak=896KB #3)\"\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/ThreadedMallocTestType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver\/timeout=500 LotsOfClasses\n+ * @run driver\/timeout=500 LotsOfJRTClasses\n@@ -39,1 +39,1 @@\n-public class LotsOfClasses {\n+public class LotsOfJRTClasses {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfJRTClasses.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfClasses.java","status":"renamed"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.Files;\n+\n+import jdk.test.lib.cds.CDSJarUtils;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/*\n+ * @test\n+ * @summary Try to archive lots and lots of classes.\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @run driver\/timeout=500 LotsOfSyntheticClasses\n+ *\/\n+\n+public class LotsOfSyntheticClasses {\n+\n+    \/\/ Generate 100 top-level classes, each containing 1000 nested classes.\n+    \/\/ 100K total classes are more than enough to push the CDS limits.\n+    private static final int NUM_CLASSES = 100;\n+    private static final int NUM_NESTED_CLASSES = 1000;\n+\n+    private static final Path USER_DIR = Paths.get(CDSTestUtils.getOutputDir());\n+    private static final Path APP_JAR = USER_DIR.resolve(\"test.jar\");\n+    private static final Path SRC_DIR = USER_DIR.resolve(\"src\");\n+\n+    private static final String TOP_CLASS_NAME = \"Class\";\n+    private static final String NESTED_CLASS_NAME = \"Nested\";\n+    private static final String MAIN_CLASS_NAME = \"Main\";\n+\n+    public static List<String> generateClass(int idx) {\n+        List<String> out = new ArrayList<>();\n+        out.add(\"public class \" + TOP_CLASS_NAME + idx + \" {\");\n+        out.add(\"public \" + TOP_CLASS_NAME + idx + \"() {\");\n+        for (int c = 0; c < NUM_NESTED_CLASSES; c++) {\n+            out.add(\"new \" + NESTED_CLASS_NAME + c + \"();\");\n+        }\n+        out.add(\"}\");\n+        for (int c = 0; c < NUM_NESTED_CLASSES; c++) {\n+            out.add(\"public static class \" + NESTED_CLASS_NAME + c + \" {}\");\n+        }\n+        out.add(\"}\");\n+        return out;\n+    }\n+\n+    public static List<String> generateMainClass() {\n+        List<String> out = new ArrayList<>();\n+        out.add(\"public class \" + MAIN_CLASS_NAME + \" {\");\n+        out.add(\"public static void main(String... args) {\");\n+        for (int c = 0; c < NUM_CLASSES; c++) {\n+            out.add(\"new \" + TOP_CLASS_NAME + c + \"();\");\n+        }\n+        out.add(\"System.out.println(\\\"Success\\\");\");\n+        out.add(\"}\");\n+        out.add(\"}\");\n+        return out;\n+    }\n+\n+    public static String[] listAppClasses() {\n+        String[] res = new String[NUM_CLASSES * NUM_NESTED_CLASSES];\n+        for (int c = 0; c < NUM_CLASSES; c++) {\n+            for (int sc = 0; sc < NUM_NESTED_CLASSES; sc++) {\n+                res[c * NUM_NESTED_CLASSES + sc] = TOP_CLASS_NAME + c + \"$\" + NESTED_CLASS_NAME + sc;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Step 1. Generate classes and build the JAR with them.\n+        {\n+            SRC_DIR.toFile().mkdirs();\n+\n+            for (int i = 0; i < NUM_CLASSES; i++) {\n+                Path file = SRC_DIR.resolve(TOP_CLASS_NAME + i + \".java\");\n+                Files.write(file, generateClass(i));\n+            }\n+\n+            Path mainFile = SRC_DIR.resolve(MAIN_CLASS_NAME + \".java\");\n+            Files.write(mainFile, generateMainClass());\n+\n+            CDSJarUtils.buildFromSourceDirectory(\n+                APP_JAR.toString(),\n+                SRC_DIR.toString()\n+            );\n+        }\n+\n+        \/\/ Step 2. Try to dump the archive.\n+        {\n+            OutputAnalyzer output = TestCommon.createArchive(\n+                APP_JAR.toString(),\n+                listAppClasses(),\n+                MAIN_CLASS_NAME\n+            );\n+            TestCommon.checkDump(output);\n+        }\n+\n+        \/\/ Step 3. Try to run, touching every class.\n+        {\n+            TestCommon.run(\n+                \/\/ Verifying dependencies for lots of classes slows down the test.\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-VerifyDependencies\",\n+                \"-Xlog:cds\",\n+                \"-cp\", APP_JAR.toString(),\n+                MAIN_CLASS_NAME).\n+                    assertNormalExit(\"Success\");\n+        }\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfSyntheticClasses.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary This is a test case for creating an AOT cache using the setup_aot\/TestSetupAOT.java program, which\n+ *          is used for running HotSpot tests in the \"AOT mode\"\n+ *          (E.g., make test JTREG=AOT_JDK=true TEST=open\/test\/hotspot\/jtreg\/runtime\/invokedynamic)\n+ * @requires vm.cds\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/lib \/test\/setup_aot\n+ * @build TestSetupAOTTest JavacBenchApp TestSetupAOT\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller\n+ *                 TestSetupAOT\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 TestSetupAOT\n+ *                 TestSetupAOT$ToolOutput\n+ *                 JavacBenchApp\n+ *                 JavacBenchApp$ClassFile\n+ *                 JavacBenchApp$FileManager\n+ *                 JavacBenchApp$SourceFile\n+ * @run driver TestSetupAOTTest\n+ *\/\n+\n+import jdk.test.lib.cds.SimpleCDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestSetupAOTTest {\n+    public static void main(String... args) throws Exception {\n+        SimpleCDSAppTester.of(\"TestSetupAOT\")\n+            .classpath(\"app.jar\")\n+            .appCommandLine(\"TestSetupAOT\", \".\")\n+            .runAOTWorkflow();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/TestSetupAOTTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test various test cases for archived WeakReference objects.\n+ * @requires vm.cds.write.archived.java.heap\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.debug\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build WeakReferenceTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar weakref.jar\n+ *             WeakReferenceTestApp WeakReferenceTestApp$Inner ShouldNotBeAOTInited ShouldNotBeArchived SharedQueue\n+ *             WeakReferenceTestBadApp1 WeakReferenceTestBadApp2\n+ * @run driver WeakReferenceTest AOT\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import java.lang.ref.ReferenceQueue;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jtreg.SkippedException;\n+\n+public class WeakReferenceTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"weakref.jar\");\n+\n+    static final String goodApp = \"WeakReferenceTestApp\";\n+    static final String badApp1 = \"WeakReferenceTestBadApp1\";\n+    static final String badApp2 = \"WeakReferenceTestBadApp2\";\n+\n+    public static void main(String[] args) throws Exception {\n+        new Tester(goodApp).run(args);\n+\n+        runBadApp(badApp1, args);\n+        runBadApp(badApp2, args);\n+    }\n+\n+    static void runBadApp(String badApp, String[] args) throws Exception {\n+        try {\n+            new Tester(badApp).run(args);\n+            throw new RuntimeException(badApp + \" did not fail in assembly phase as expected\");\n+        } catch (SkippedException e) {\n+            System.out.println(\"Negative test: expected SkippedException\");\n+        }\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        String mainClass;\n+        public Tester(String mainClass) {\n+            super(mainClass);\n+            this.mainClass = mainClass;\n+\n+            if (mainClass != goodApp) {\n+                setCheckExitValue(false);\n+            }\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                return new String[] {\n+                    \"-Xlog:gc,cds+class=debug\",\n+                    \"-XX:AOTInitTestClass=\" + mainClass,\n+                    \"-Xlog:cds+map,cds+map+oops=trace:file=cds.oops.txt:none:filesize=0\",\n+                };\n+            } else {\n+                return new String[] {\n+                    \"-Xlog:gc\",\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+                runMode.toString(),\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (runMode == RunMode.ASSEMBLY && mainClass != goodApp) {\n+                out.shouldNotHaveExitValue(0);\n+                out.shouldMatch(\"Cannot archive reference object .* of class java.lang.ref.WeakReference\");\n+                if (mainClass == badApp1) {\n+                    out.shouldContain(\"referent cannot be null\");\n+                } else {\n+                    out.shouldContain(\"referent is not registered with CDS.keepAlive()\");\n+                }\n+                throw new SkippedException(\"Assembly phase expected to fail\");\n+            }\n+\n+            out.shouldHaveExitValue(0);\n+            out.shouldNotContain(\"Unexpected exception:\");\n+        }\n+    }\n+}\n+\n+class WeakReferenceTestApp {\n+    static class Inner { \/\/ This class is NOT aot-initialized\n+        static boolean WeakReferenceTestApp_clinit_executed;\n+    }\n+\n+    static {\n+        Inner.WeakReferenceTestApp_clinit_executed = true;\n+\n+        \/\/ This static {} block is executed the training run (which uses no AOT cache).\n+        \/\/\n+        \/\/ During the assembly phase, this static {} block of is also executed\n+        \/\/ (triggered by the -XX:AOTInitTestClass=WeakReferenceTestApp flag).\n+        \/\/ It runs the aot_init_for_testXXX() method to set up the aot-initialized data structures\n+        \/\/ that are used by  each testXXX() function.\n+        \/\/\n+        \/\/ This block is NOT executed during the production run, because WeakReferenceTestApp\n+        \/\/ is aot-initialized.\n+\n+        aot_init_for_testCollectedInAssembly();\n+        aot_init_for_testWeakReferenceCollection();\n+    }\n+\n+    public static void main(String[] args) {\n+        try {\n+            runTests(args);\n+        } catch (Throwable t) {\n+            System.err.println(\"Unexpected exception:\");\n+            t.printStackTrace();\n+            System.exit(1);\n+        }\n+    }\n+\n+    static void runTests(String[] args) throws Exception {\n+        boolean isProduction = args[0].equals(\"PRODUCTION\");\n+\n+        if (isProduction && Inner.WeakReferenceTestApp_clinit_executed) {\n+            throw new RuntimeException(\"WeakReferenceTestApp should have been aot-inited\");\n+        }\n+\n+        if (isProduction) {\n+            \/\/ A GC should have happened before the heap objects are written into\n+            \/\/ the AOT cache. So any unreachable referents should have been collected.\n+        } else {\n+            \/\/ We are in the training run. Simulate the GC mentioned in the above comment,\n+            \/\/ so the test cases should observe the same states as in the production run.\n+            System.gc();\n+        }\n+\n+        testCollectedInAssembly(isProduction);\n+        testWeakReferenceCollection(isProduction);\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Set up for testCollectedInAssembly()\n+    static WeakReference refToCollectedObj;\n+\n+    static void aot_init_for_testCollectedInAssembly() {\n+        \/\/ The referent will be GC-ed in the assembly run when the JVM forces a full GC.\n+        refToCollectedObj = new WeakReference(new String(\"collected in assembly\"));\n+    }\n+\n+    \/\/ [TEST CASE] Test the storage of a WeakReference whose referent has been collected during the assembly phase.\n+    static void testCollectedInAssembly(boolean isProduction) {\n+        System.out.println(\"refToCollectedObj.get() = \" + refToCollectedObj.get());\n+\n+        if (refToCollectedObj.get() != null) {\n+            throw new RuntimeException(\"refToCollectedObj.get() should have been GC'ed\");\n+        }\n+    }\n+\n+    \/\/----------------------------------------------------------------------\n+    \/\/ Set up for testWeakReferenceCollection()\n+    static Object root;\n+    static WeakReference ref;\n+\n+    static void aot_init_for_testWeakReferenceCollection() {\n+        root = new String(\"to be collected in production\");\n+        ref = makeRef();\n+    }\n+\n+    static WeakReference makeRef() {\n+        System.out.println(\"WeakReferenceTestApp::makeRef() is executed\");\n+        WeakReference r = new WeakReference(root);\n+        System.out.println(\"r.get() = \" + r.get());\n+\n+        ShouldNotBeAOTInited.doit();\n+        return r;\n+    }\n+\n+    static WeakReference makeRef2() {\n+        return new WeakReference(new String(\"to be collected in production\"));\n+    }\n+\n+\n+    \/\/ [TEST CASE] A WeakReference allocated in assembly phase should be collectable in the production run\n+    static void testWeakReferenceCollection(boolean isProduction) {\n+        WeakReference ref2 = makeRef2();\n+        System.out.println(\"ref.get() = \" + ref.get());   \/\/ created during assembly phase\n+        System.out.println(\"ref2.get() = \" + ref2.get()); \/\/ created during production run\n+\n+        if (ref.get() == null) {\n+            throw new RuntimeException(\"ref.get() should not be null\");\n+        }\n+\n+        System.out.println(\"... running GC ...\");\n+        root = null; \/\/ make ref.referent() eligible for collection\n+        System.gc();\n+\n+        System.out.println(\"ref.get() = \" + ref.get());\n+        System.out.println(\"ref2.get() = \" + ref2.get());\n+\n+        if (ref.get() != null) {\n+            throw new RuntimeException(\"ref.get() should be null\");\n+        }\n+        if (ref2.get() != null) {\n+            throw new RuntimeException(\"ref2.get() should be null\");\n+        }\n+\n+        System.out.println(\"ShouldNotBeAOTInited.doit_executed = \" + ShouldNotBeAOTInited.doit_executed);\n+        if (isProduction && ShouldNotBeAOTInited.doit_executed) {\n+            throw new RuntimeException(\"ShouldNotBeAOTInited should not have been aot-inited\");\n+        }\n+    }\n+}\n+\n+class ShouldNotBeAOTInited {\n+    static WeakReference ref;\n+    static boolean doit_executed;\n+    static {\n+        System.out.println(\"ShouldNotBeAOTInited.<clinit> called\");\n+    }\n+    static void doit() {\n+        System.out.println(\"ShouldNotBeAOTInited.doit()> called\");\n+        doit_executed = true;\n+        ref = new WeakReference(new ShouldNotBeAOTInited());\n+    }\n+}\n+\n+class ShouldNotBeArchived {\n+    static ShouldNotBeArchived instance = new ShouldNotBeArchived();\n+    static WeakReference ref;\n+    static int state = 1;\n+}\n+\n+class SharedQueue {\n+    static SharedQueue sharedQueueInstance = new SharedQueue();\n+    private ReferenceQueue<Object> theQueue = new ReferenceQueue<Object>();\n+\n+    static ReferenceQueue<Object> queue() {\n+        return sharedQueueInstance.theQueue;\n+    }\n+}\n+\n+class WeakReferenceTestBadApp1 {\n+    static WeakReference refWithQueue;\n+    static SharedQueue sharedQueueInstance;\n+\n+    static {\n+        \/\/ See comments in aotReferenceObjSupport.cpp: group [2] references cannot have null referent.\n+        sharedQueueInstance = SharedQueue.sharedQueueInstance;\n+        refWithQueue = new WeakReference(String.class, SharedQueue.queue());\n+        refWithQueue.clear();\n+    }\n+\n+    public static void main(String args[]) {}\n+}\n+\n+class WeakReferenceTestBadApp2 {\n+    static WeakReference refWithQueue;\n+    static SharedQueue sharedQueueInstance;\n+\n+    static {\n+        \/\/ See comments in aotReferenceObjSupport.cpp: group [2] references must be registered with CDS.keepAlive()\n+        sharedQueueInstance = SharedQueue.sharedQueueInstance;\n+        refWithQueue = new WeakReference(String.class, SharedQueue.queue());\n+    }\n+\n+    public static void main(String args[]) {}\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/WeakReferenceTest.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"},{"patch":"@@ -42,0 +42,4 @@\n+        new Option(\"--add-opens\",\n+                   \"jdk.module.addopens\",\n+                   \"java.base\/java.util.concurrent.regex=ALL-UNNAMED\",\n+                   \"java.base\/sun.security.x509=ALL-UNNAMED\"),\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/ExactOptionMatch.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8352003\n+ * @summary Test handling of the --add-opens option.\n+ * @requires vm.cds.write.archived.java.heap\n+ * @requires vm.flagless\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI AddopensOption\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AddopensOption {\n+\n+    public static void main(String[] args) throws Exception {\n+        final String moduleOption = \"jdk.httpserver\/sun.net.httpserver.simpleserver.Main\";\n+        final String addOpensNio = \"java.base\/java.nio=ALL-UNNAMED\";\n+        final String addOpensTimeFormat = \"java.base\/java.time.format=ALL-UNNAMED\";\n+        final String loggingOption = \"-Xlog:cds=debug,cds+module=debug,cds+heap=info,module=trace\";\n+        final String versionPattern = \"java.[0-9][0-9].*\";\n+        final String subgraphCannotBeUsed = \"subgraph jdk.internal.module.ArchivedBootLayer cannot be used because full module graph is disabled\";\n+        final String warningIncubator = \"WARNING: Using incubator modules: jdk.incubator.vector\";\n+        String archiveName = TestCommon.getNewArchiveName(\"addopens-option\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+\n+        \/\/ dump a base archive with --add-opens jdk.java.base\/java.time.format -m jdk.httpserver\n+        OutputAnalyzer oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"--add-opens\", addOpensTimeFormat,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0);\n+\n+        \/\/ same modules specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"--add-opens\", addOpensTimeFormat,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          \/\/ version of the jdk.httpserver module, e.g. java 22-ea\n+          .shouldMatch(versionPattern)\n+          .shouldMatch(\"cds,module.*Restored from archive: entry.0x.*name jdk.httpserver\");\n+\n+        \/\/ different --add-opens specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"--add-opens\", addOpensNio,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Mismatched values for property jdk.module.addopens\")\n+          .shouldContain(\"runtime java.base\/java.nio=ALL-UNNAMED dump time java.base\/java.time.format=ALL-UNNAMED\")\n+          .shouldContain(subgraphCannotBeUsed);\n+\n+        \/\/ no module specified during runtime\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"jdk.httpserver specified during dump time but not during runtime\")\n+          .shouldContain(subgraphCannotBeUsed);\n+\n+        \/\/ dump an archive without the --add-opens option\n+        archiveName = TestCommon.getNewArchiveName(\"no-addopens-option\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+        oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0);\n+\n+        \/\/ run with --add-opens option\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"--add-opens\", addOpensTimeFormat,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"java.base\/java.time.format=ALL-UNNAMED specified during runtime but not during dump time\")\n+          \/\/ version of the jdk.httpserver module, e.g. java 22-ea\n+          .shouldMatch(versionPattern)\n+          .shouldContain(subgraphCannotBeUsed);\n+\n+        \/\/ dump an archive with -add-opens java.base\/java.nio=ALL-UNNAMED\n+        archiveName = TestCommon.getNewArchiveName(\"addopens-java-nio\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+        oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"--add-opens\", addOpensNio,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldContain(\"Full module graph = enabled\");\n+\n+        \/\/ run with the same --add-opens\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"--add-opens\", addOpensNio,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldContain(\"optimized module handling: enabled\")\n+          .shouldHaveExitValue(0);\n+\n+        \/\/ dump an archive with multiple --add-modules args\n+        archiveName = TestCommon.getNewArchiveName(\"muti-addopens\");\n+        TestCommon.setCurrentArchiveName(archiveName);\n+        oa = TestCommon.dumpBaseArchive(\n+            archiveName,\n+            loggingOption,\n+            \"--add-opens\", addOpensNio,\n+            \"--add-opens\", addOpensTimeFormat,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0);\n+\n+        \/\/ run with the same multiple --add-modules args with a duplicate --add-opens entry\n+        oa = TestCommon.execCommon(\n+            loggingOption,\n+            \"--add-opens\", addOpensTimeFormat,\n+            \"--add-opens\", addOpensNio,\n+            \"--add-opens\", addOpensTimeFormat,\n+            \"-m\", moduleOption,\n+            \"-version\");\n+        oa.shouldHaveExitValue(0)\n+          .shouldMatch(\"cds,module.*Restored from archive: entry.0x.*name jdk.httpserver\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/addopens\/AddopensOption.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,9 @@\n+    private static String addOpensArg = \"java.base\/java.lang=\" + TEST_MODULE1;\n+    private static String addOpensAllUnnamed = \"java.base\/java.lang=ALL-UNNAMED\";\n+    private static String extraOpts[][] =\n+        {{\"-Xlog:cds\", \"-Xlog:cds\"},\n+         {\"--add-opens\", addOpensArg}};\n+    private static String expectedOutput[] =\n+        { \"[class,load] com.simple.Main source: shared objects file\",\n+          \"method.setAccessible succeeded!\"};\n+\n@@ -82,7 +91,32 @@\n-        \/\/ create an archive with both -cp and --module-path in the command line.\n-        \/\/ Only the class in the modular jar in the --module-path will be archived;\n-        \/\/ the class in the modular jar in the -cp won't be archived.\n-        OutputAnalyzer output = TestCommon.createArchive(\n-                                        destJar.toString(), appClasses,\n-                                        \"--module-path\", moduleDir.toString(),\n-                                        \"-m\", TEST_MODULE1);\n+        OutputAnalyzer output;\n+\n+        for (int i = 0; i < 2; i++) {\n+            \/\/ create an archive with both -cp and --module-path, and with the\n+            \/\/ --add-opens option if i == 1, in the command line.\n+            \/\/ Only the class in the modular jar in the --module-path will be archived;\n+            \/\/ the class in the modular jar in the -cp won't be archived.\n+            output = TestCommon.createArchive(\n+                             destJar.toString(), appClasses,\n+                             extraOpts[i][0], extraOpts[i][1],\n+                             \"--module-path\", moduleDir.toString(),\n+                             \"-m\", TEST_MODULE1);\n+            TestCommon.checkDump(output);\n+\n+            \/\/ run with the archive using the same command line as in dump time\n+            \/\/ plus the \"--add-opens java.base\/java.lang=com.simple\" option.\n+            \/\/ The main class should be loaded from the archive.\n+            \/\/ The setaccessible(true) on the ClassLoader.defineClass method should\n+            \/\/ be successful.\n+            TestCommon.run( \"-Xlog:class+load=trace\",\n+                            \"-cp\", destJar.toString(),\n+                            \"--add-opens\", addOpensArg,\n+                            \"--module-path\", moduleDir.toString(),\n+                            \"-m\", TEST_MODULE1, \"with_add_opens\")\n+                    .assertNormalExit(expectedOutput[0], expectedOutput[1]);\n+        }\n+\n+        \/\/ Test --add-opens to ALL-UNNAMED modules\n+        output = TestCommon.createArchive(\n+                         destJar.toString(), appClasses,\n+                         \"--add-opens\", addOpensAllUnnamed,\n+                         MAIN_CLASS);\n@@ -91,5 +125,0 @@\n-        \/\/ run with the archive using the same command line as in dump time\n-        \/\/ plus the \"--add-opens java.base\/java.lang=com.simple\" option.\n-        \/\/ The main class should be loaded from the archive.\n-        \/\/ The setaccessible(true) on the ClassLoader.defineClass method should\n-        \/\/ be successful.\n@@ -98,6 +127,3 @@\n-                        \"--add-opens\", \"java.base\/java.lang=\" + TEST_MODULE1,\n-                        \"--module-path\", moduleDir.toString(),\n-                        \"-m\", TEST_MODULE1, \"with_add_opens\")\n-            .assertNormalExit(\n-                \"[class,load] com.simple.Main source: shared objects file\",\n-                \"method.setAccessible succeeded!\");\n+                        \"--add-opens\", addOpensAllUnnamed,\n+                        MAIN_CLASS, \"with_add_opens\")\n+                .assertNormalExit(expectedOutput[0], expectedOutput[1]);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/AddOpens.java","additions":45,"deletions":19,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @test\n- * @summary Dump time resolution of constant pool entries.\n+ * @test id=static\n+ * @summary Dump time resolution of constant pool entries (Static CDS archive).\n@@ -39,1 +39,20 @@\n- * @run driver ResolvedConstants\n+ * @run driver ResolvedConstants STATIC\n+ *\/\n+\n+\/*\n+ * @test id=dynamic\n+ * @summary Dump time resolution of constant pool entries (Dynamic CDS archive)\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/\n+ * @build OldProvider OldClass OldConsumer StringConcatTestOld\n+ * @build ResolvedConstants\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 ResolvedConstantsApp ResolvedConstantsFoo ResolvedConstantsBar\n+ *                 MyInterface InterfaceWithClinit NormalClass\n+ *                 OldProvider OldClass OldConsumer SubOfOldClass\n+ *                 StringConcatTest StringConcatTestOld\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Dcds.app.tester.workflow=DYNAMIC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. ResolvedConstants DYNAMIC\n@@ -45,0 +64,1 @@\n+import jdk.test.lib.cds.SimpleCDSAppTester;\n@@ -55,2 +75,2 @@\n-        test(false);\n-        test(true);\n+        test(args, false);\n+        test(args, true);\n@@ -59,1 +79,1 @@\n-    static void test(boolean testMode) throws Exception {\n+    static void test(String[] args, boolean testMode) throws Exception {\n@@ -61,15 +81,0 @@\n-        CDSTestUtils.dumpClassList(classList, \"-cp\", appJar, mainClass)\n-            .assertNormalExit(output -> {\n-                output.shouldContain(\"Hello ResolvedConstantsApp\");\n-            });\n-\n-        CDSOptions opts = (new CDSOptions())\n-            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n-                       \"-cp\", appJar,\n-                       \"-Xlog:cds+resolve=trace\",\n-                       \"-Xlog:cds+class=debug\");\n-        if (aotClassLinking) {\n-            opts.addPrefix(\"-XX:+AOTClassLinking\");\n-        } else {\n-            opts.addPrefix(\"-XX:-AOTClassLinking\");\n-        }\n@@ -77,2 +82,14 @@\n-        OutputAnalyzer out = CDSTestUtils.createArchiveAndCheck(opts);\n-          \/\/ Class References ---\n+        SimpleCDSAppTester.of(\"ResolvedConstantsApp\" + (aotClassLinking ? \"1\" : \"0\"))\n+            .addVmArgs(aotClassLinking ? \"-XX:+AOTClassLinking\" : \"-XX:-AOTClassLinking\",\n+                       \"-Xlog:cds+resolve=trace\",\n+                       \"-Xlog:cds+class=debug\")\n+            .classpath(appJar)\n+            .appCommandLine(mainClass)\n+            .setAssemblyChecker((OutputAnalyzer out) -> {\n+                    checkAssemblyOutput(args, out);\n+                })\n+            .setProductionChecker((OutputAnalyzer out) -> {\n+                    out.shouldContain(\"Hello ResolvedConstantsApp\");\n+                })\n+            .run(args);\n+    }\n@@ -80,0 +97,2 @@\n+    static void checkAssemblyOutput(String args[], OutputAnalyzer out) {\n+        testGroup(\"Class References\", out)\n@@ -81,1 +100,1 @@\n-        out.shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => ResolvedConstantsApp app\"))\n+            .shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => ResolvedConstantsApp app\"))\n@@ -95,3 +114,1 @@\n-            .shouldMatch(AOTLINK_ONLY(\"klass.* ResolvedConstantsApp .*java\/lang\/System\"))\n-\n-          \/\/ Field References ---\n+            .shouldMatch(AOTLINK_ONLY(\"klass.* ResolvedConstantsApp .*java\/lang\/System\"));\n@@ -99,0 +116,1 @@\n+        testGroup(\"Field References\", out)\n@@ -111,1 +129,1 @@\n-            .shouldMatch(AOTLINK_ONLY(\"field.* ResolvedConstantsApp => ResolvedConstantsBar.b:I\"))\n+            .shouldMatch(AOTLINK_ONLY(\"field.* ResolvedConstantsApp => ResolvedConstantsBar.b:I\"));\n@@ -113,1 +131,4 @@\n-          \/\/ Method References ---\n+        if (args[0].equals(\"DYNAMIC\")) {\n+            \/\/ AOT resolution of CP methods\/indy references is not implemeted\n+            return;\n+        }\n@@ -115,0 +136,1 @@\n+        testGroup(\"Method References\", out)\n@@ -151,1 +173,2 @@\n-            out.shouldContain(\"Cannot aot-resolve Lambda proxy because OldConsumer is excluded\")\n+            testGroup(\"Indy References\", out)\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldConsumer is excluded\")\n@@ -173,0 +196,5 @@\n+\n+    static OutputAnalyzer testGroup(String name, OutputAnalyzer out) {\n+        System.out.println(\"Checking for: \" + name);\n+        return out;\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":59,"deletions":31,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng TestAvailableProcessors\n+ * @run testng\/othervm\/native TestAvailableProcessors\n@@ -38,3 +38,0 @@\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n@@ -45,1 +42,0 @@\n-import jdk.test.lib.Utils;\n@@ -175,6 +171,2 @@\n-        \/\/ Launch GetProcessorInfo.exe to gather processor counts\n-        Path nativeGetProcessorInfo = Paths.get(Utils.TEST_NATIVE_PATH)\n-            .resolve(\"GetProcessorInfo.exe\")\n-            .toAbsolutePath();\n-\n-        var processBuilder = new ProcessBuilder(nativeGetProcessorInfo.toString());\n+        \/\/ Launch \"<nativepath>\/GetProcessorInfo.exe\" to gather processor counts\n+        var processBuilder = new ProcessBuilder(\"GetProcessorInfo.exe\");\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/windows\/TestAvailableProcessors.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,5 @@\n-                expStrMap.put(\"pmap\", List.of(\"jvm\", \"java\", \"jli\", \"jimage\"));\n+                if (Platform.isStatic()) {\n+                    expStrMap.put(\"pmap\", List.of(\"java\"));\n+                } else {\n+                    expStrMap.put(\"pmap\", List.of(\"jvm\", \"java\", \"jli\", \"jimage\"));\n+                }\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbPmap.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.test.lib.Platform;\n@@ -68,1 +69,6 @@\n-            out.shouldMatch(\"^0x[0-9a-f]+.+libjvm\\\\.so$\"); \/\/ Find libjvm from output\n+            if (Platform.isStatic()) {\n+                out.shouldMatch(\"java\"); \/\/ Find launcher\n+                out.shouldNotMatch(\"^0x[0-9a-f]+.+libjvm\\\\.so$\"); \/\/ No libjvm from output\n+            } else {\n+                out.shouldMatch(\"^0x[0-9a-f]+.+libjvm\\\\.so$\"); \/\/ Find libjvm from output\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/PmapOnDebugdTest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.test.lib.Platform;\n@@ -78,1 +79,6 @@\n-            out.shouldMatch(\"^0x[0-9a-f]+: .+\/libjvm\\\\.(so|dylib) \\\\+ 0x[0-9a-f]+$\");\n+            if (Platform.isStatic()) {\n+                out.shouldMatch(\"java\");\n+                out.shouldNotMatch(\"^0x[0-9a-f]+: .+\/libjvm\\\\.(so|dylib) \\\\+ 0x[0-9a-f]+$\");\n+            } else {\n+                out.shouldMatch(\"^0x[0-9a-f]+: .+\/libjvm\\\\.(so|dylib) \\\\+ 0x[0-9a-f]+$\");\n+            }\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/RunCommandOnServerTest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-        disableDowncasts = optionResolver.addBooleanOption(\"disable-downcasts\", \"Disable downcasting of objects\");\n+        disableDowncasts = optionResolver.addBooleanOption(null, \"disable-downcasts\", true, \"Disable downcasting of objects\");\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/ProductionParams.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,2 +111,1 @@\n-        debugee = Debugee.prepareDebugee(argsHandler, logHandler,\n-                debugeeName + (argsHandler.verbose() ? \" -vbs\" : \"\"));\n+        debugee = Debugee.prepareDebugee(argsHandler, logHandler, debugeeName);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/Accessible\/isPackagePrivate\/accipp001.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-            breakpointForCommunication();\n+            breakpointForCommunication(debuggeeName);\n@@ -330,24 +330,0 @@\n-    protected void breakpointForCommunication()\n-            throws JDITestRuntimeException {\n-        log2(\"breakpointForCommunication\");\n-\n-        do {\n-            getEventSet();\n-\n-            Event event = eventIterator.nextEvent();\n-            if (event instanceof BreakpointEvent)\n-                return;\n-\n-            log2(\"      received: \" + event);\n-\n-            if (EventFilters.filtered(event, debuggeeName)) {\n-                eventSet.resume();\n-            }\n-            else {\n-                break;\n-            }\n-        } while (true);\n-\n-        throw new JDITestRuntimeException(\"** event IS NOT a breakpoint **\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassPrepareRequest\/addClassExclusionFilter\/filter003.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-            breakpointForCommunication();\n+            breakpointForCommunication(debuggeeName);\n@@ -337,24 +337,0 @@\n-    protected void breakpointForCommunication()\n-            throws JDITestRuntimeException {\n-        log2(\"breakpointForCommunication\");\n-\n-        do {\n-            getEventSet();\n-\n-            Event event = eventIterator.nextEvent();\n-            if (event instanceof BreakpointEvent)\n-                return;\n-\n-            log2(\"      received: \" + event);\n-\n-            if (EventFilters.filtered(event, debuggeeName)) {\n-                eventSet.resume();\n-            }\n-            else {\n-                break;\n-            }\n-        } while (true);\n-\n-        throw new JDITestRuntimeException(\"** event IS NOT a breakpoint **\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassPrepareRequest\/addClassFilter_rt\/filter_rt002.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-            breakpointForCommunication();\n+            breakpointForCommunication(debuggeeName);\n@@ -335,23 +335,0 @@\n-    protected void breakpointForCommunication()\n-            throws JDITestRuntimeException {\n-        log2(\"breakpointForCommunication\");\n-\n-        do {\n-            getEventSet();\n-\n-            Event event = eventIterator.nextEvent();\n-            if (event instanceof BreakpointEvent)\n-                return;\n-\n-            log2(\"      received: \" + event);\n-\n-            if (EventFilters.filtered(event, debuggeeName)) {\n-                eventSet.resume();\n-            }\n-            else {\n-                break;\n-            }\n-        } while (true);\n-\n-        throw new JDITestRuntimeException(\"** event IS NOT a breakpoint **\");\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassPrepareRequest\/addClassFilter_s\/filter_s002.java","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/addCountFilter\/addcountfilter001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,14 +79,1 @@\n-public class disable001 {\n-\n-    \/\/----------------------------------------------------- templete section\n-    static final int PASSED = 0;\n-    static final int FAILED = 2;\n-    static final int PASS_BASE = 95;\n-\n-    \/\/----------------------------------------------------- templete parameters\n-    static final String\n-    sHeader1 = \"\\n==> nsk\/jdi\/EventRequest\/disable\/disable001 \",\n-    sHeader2 = \"--> debugger: \",\n-    sHeader3 = \"##> debugger: \";\n-\n-    \/\/----------------------------------------------------- main method\n+public class disable001 extends JDIBase {\n@@ -113,14 +100,0 @@\n-    \/\/--------------------------------------------------   log procedures\n-\n-    private static Log  logHandler;\n-\n-    private static void log1(String message) {\n-        logHandler.display(sHeader1 + message);\n-    }\n-    private static void log2(String message) {\n-        logHandler.display(sHeader2 + message);\n-    }\n-    private static void log3(String message) {\n-        logHandler.complain(sHeader3 + message);\n-    }\n-\n@@ -135,2 +108,0 @@\n-    Location location = null;               \/\/ !!!!!!!!!!!!! see settingBreakpoint\n-\n@@ -138,19 +109,0 @@\n-    \/\/------------------------------------------------------ common section\n-\n-    static Debugee          debuggee;\n-    static ArgumentHandler  argsHandler;\n-\n-    static int waitTime;\n-\n-    static VirtualMachine      vm            = null;\n-    static EventRequestManager eventRManager = null;\n-    static EventQueue          eventQueue    = null;\n-    static EventSet            eventSet      = null;\n-    static EventIterator       eventIterator = null;\n-\n-    static ReferenceType       debuggeeClass = null;\n-\n-    static int  testExitCode = PASSED;\n-\n-\n-    \/\/------------------------------------------------------ methods\n@@ -295,8 +247,6 @@\n-        String bPointMethod = \"methodForCommunication\";\n-        String lineForComm  = \"lineForComm\";\n-\n-        ThreadReference   mainThread = debuggee.threadByNameOrThrow(\"main\");\n-\n-        BreakpointRequest bpRequest = settingBreakpoint(mainThread,\n-                                             debuggeeClass,\n-                                            bPointMethod, lineForComm, \"zero\");\n+        BreakpointRequest bpRequest =\n+            setupBreakpointForCommunication(debuggeeClass);\n+        \/\/ setupBreakpointForCommunication() defaults to SUSPEND_EVENT_THREAD. We need\n+        \/\/ to change this to SUSPEND_ALL.\n+        bpRequest.disable();\n+        bpRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n@@ -342,1 +292,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n@@ -408,1 +358,1 @@\n-                     eventRequest1 = eventRManager.createBreakpointRequest(location);\n+                     eventRequest1 = eventRManager.createBreakpointRequest(breakpLocation);\n@@ -437,95 +387,0 @@\n-   \/*\n-    * private BreakpointRequest settingBreakpoint(ThreadReference, ReferenceType,\n-    *                                             String, String, String)\n-    *\n-    * It sets up a breakpoint at given line number within a given method in a given class\n-    * for a given thread.\n-    *\n-    * Return value: BreakpointRequest object  in case of success\n-    *\n-    * JDITestRuntimeException   in case of an Exception thrown within the method\n-    *\/\n-\n-    private BreakpointRequest settingBreakpoint ( ThreadReference thread,\n-                                                  ReferenceType testedClass,\n-                                                  String methodName,\n-                                                  String bpLine,\n-                                                  String property)\n-            throws JDITestRuntimeException {\n-\n-        log2(\"......setting up a breakpoint:\");\n-        log2(\"       thread: \" + thread + \"; class: \" + testedClass +\n-                        \"; method: \" + methodName + \"; line: \" + bpLine);\n-\n-        List              alllineLocations = null;\n-        Location          lineLocation     = null;\n-        BreakpointRequest breakpRequest    = null;\n-\n-        try {\n-            Method  method  = (Method) testedClass.methodsByName(methodName).get(0);\n-\n-            alllineLocations = method.allLineLocations();\n-\n-            int n =\n-                ( (IntegerValue) testedClass.getValue(testedClass.fieldByName(bpLine) ) ).value();\n-            if (n > alllineLocations.size()) {\n-                log3(\"ERROR:  TEST_ERROR_IN_settingBreakpoint(): number is out of bound of method's lines\");\n-            } else {\n-                lineLocation = (Location) alllineLocations.get(n);\n-\n-\/\/ this is only for this test to get Location object\n-location = lineLocation;\n-\n-                try {\n-                    breakpRequest = eventRManager.createBreakpointRequest(lineLocation);\n-                    breakpRequest.putProperty(\"number\", property);\n-                    breakpRequest.addThreadFilter(thread);\n-                    breakpRequest.setSuspendPolicy( EventRequest.SUSPEND_ALL);\n-                } catch ( Exception e1 ) {\n-                    log3(\"ERROR: inner Exception within settingBreakpoint() : \" + e1);\n-                    breakpRequest    = null;\n-                }\n-            }\n-        } catch ( Exception e2 ) {\n-            log3(\"ERROR: ATTENTION:  outer Exception within settingBreakpoint() : \" + e2);\n-            breakpRequest    = null;\n-        }\n-\n-        if (breakpRequest == null) {\n-            log2(\"      A BREAKPOINT HAS NOT BEEN SET UP\");\n-            throw new JDITestRuntimeException(\"**FAILURE to set up a breakpoint**\");\n-        }\n-\n-        log2(\"      a breakpoint has been set up\");\n-        return breakpRequest;\n-    }\n-\n-\n-    private void getEventSet()\n-                 throws JDITestRuntimeException {\n-        try {\n-\/\/            log2(\"       eventSet = eventQueue.remove(waitTime);\");\n-            eventSet = eventQueue.remove(waitTime);\n-            if (eventSet == null) {\n-                throw new JDITestRuntimeException(\"** TIMEOUT while waiting for event **\");\n-            }\n-\/\/            log2(\"       eventIterator = eventSet.eventIterator;\");\n-            eventIterator = eventSet.eventIterator();\n-        } catch ( Exception e ) {\n-            throw new JDITestRuntimeException(\"** EXCEPTION while waiting for event ** : \" + e);\n-        }\n-    }\n-\n-\n-    private void breakpointForCommunication()\n-                 throws JDITestRuntimeException {\n-\n-        log2(\"breakpointForCommunication\");\n-        getEventSet();\n-\n-        if (eventIterator.nextEvent() instanceof BreakpointEvent)\n-            return;\n-\n-        throw new JDITestRuntimeException(\"** event IS NOT a breakpoint **\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/disable\/disable001.java","additions":10,"deletions":155,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -286,2 +286,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n-\n+                  thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/disable\/disable002.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/enable\/enable001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/enable\/enable002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/getProperty\/getproperty001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-                       ThreadReference thread = debuggee.threadByNameOrThrow(methodName);\n+                       ThreadReference thread = debuggee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/hashCode\/hashcode001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/isEnabled\/isenabled001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/putProperty\/putproperty001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/setEnabled\/setenabled001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/setEnabled\/setenabled002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/setSuspendPolicy\/setsuspendpolicy001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequest\/suspendPolicy\/suspendpolicy001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        ThreadReference thread = debugee.threadByName(\"main\");\n+        ThreadReference thread = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/_bounds_\/requests001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-            breakpointForCommunication();\n+            breakpointForCommunication(debuggeeName);\n@@ -369,24 +369,0 @@\n-    protected void breakpointForCommunication()\n-            throws JDITestRuntimeException {\n-        log2(\"breakpointForCommunication\");\n-\n-        do {\n-            getEventSet();\n-\n-            Event event = eventIterator.nextEvent();\n-            if (event instanceof BreakpointEvent)\n-                return;\n-\n-            log2(\"      received: \" + event);\n-\n-            if (EventFilters.filtered(event, debuggeeName)) {\n-                eventSet.resume();\n-            }\n-            else {\n-                break;\n-            }\n-        } while (true);\n-\n-        throw new JDITestRuntimeException(\"** event IS NOT a breakpoint **\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/classPrepareRequests\/clsprepreq002.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-            thread = debuggee.threadByNameOrThrow(threadName);\n+            thread = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/createStepRequest\/crstepreq002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,2 +80,2 @@\n-    static final int lineForBreakInThread    = 137;\n-    static final int[] checkedLines = { 138, 138, 178 };\n+    static final int lineForBreakInThread    = 141;\n+    static final int[] checkedLines = { 142, 142, 182 };\n@@ -250,1 +250,1 @@\n-        ThreadReference thread = debuggee.threadByNameOrThrow(threadName);\n+        ThreadReference thread = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/createStepRequest\/crstepreq003.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,4 @@\n+    static Thread thread0;\n+    static Thread thread1;\n+    static Thread thread2;\n+\n@@ -75,1 +79,1 @@\n-                    Thread thread0 = JDIThreadFactory.newThread(new Thread0crstepreq003a(\"thread0\"));\n+                    thread0 = JDIThreadFactory.newThread(new Thread0crstepreq003a(\"thread0\"));\n@@ -82,1 +86,1 @@\n-                    Thread thread1 = JDIThreadFactory.newThread(new Thread0crstepreq003a(\"thread1\"));\n+                    thread1 = JDIThreadFactory.newThread(new Thread0crstepreq003a(\"thread1\"));\n@@ -89,1 +93,1 @@\n-                    Thread thread2 = JDIThreadFactory.newThread(new Thread0crstepreq003a(\"thread2\"));\n+                    thread2 = JDIThreadFactory.newThread(new Thread0crstepreq003a(\"thread2\"));\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/createStepRequest\/crstepreq003a.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,3 +80,3 @@\n-    static final int lineForBreakInThread = 146;\n-    static final int[] checkedLines = { 160, 160, 193 };\n-    static final int[] checkedLinesAlt = { 161, 161, 193 };\n+    static final int lineForBreakInThread = 149;\n+    static final int[] checkedLines = { 163, 163, 196 };\n+    static final int[] checkedLinesAlt = { 164, 164, 196 };\n@@ -251,1 +251,1 @@\n-        ThreadReference thread = debuggee.threadByNameOrThrow(threadName);\n+        ThreadReference thread = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/createStepRequest\/crstepreq004.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,3 @@\n+    static Thread thread1;\n+    static Thread thread2;\n+\n@@ -98,2 +101,2 @@\n-        Thread thread1 = JDIThreadFactory.newThread(new Thread1crstepreq004a(\"thread1\"));\n-        Thread thread2 = JDIThreadFactory.newThread(new Thread2crstepreq004a(\"thread2\"));\n+        thread1 = JDIThreadFactory.newThread(new Thread1crstepreq004a(\"thread1\"));\n+        thread2 = JDIThreadFactory.newThread(new Thread2crstepreq004a(\"thread2\"));\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/createStepRequest\/crstepreq004a.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-            breakpointForCommunication();\n+            breakpointForCommunication(debuggeeName);\n@@ -363,24 +363,0 @@\n-    protected void breakpointForCommunication()\n-                 throws JDITestRuntimeException {\n-        log2(\"breakpointForCommunication\");\n-\n-        do {\n-            getEventSet();\n-\n-            Event event = eventIterator.nextEvent();\n-            if (event instanceof BreakpointEvent)\n-                return;\n-\n-            log2(\"      received: \" + event);\n-\n-            if (EventFilters.filtered(event, debuggeeName)) {\n-                eventSet.resume();\n-            }\n-            else {\n-                break;\n-            }\n-        } while (true);\n-\n-        throw new JDITestRuntimeException(\"** event IS NOT a breakpoint **\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/methodExitRequests\/methexitreq002.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -253,0 +253,1 @@\n+        debuggee.setMainThread(event.thread());\n@@ -260,1 +261,1 @@\n-        ThreadReference mainThread = debuggee.threadByNameOrThrow(\"main\");\n+        ThreadReference mainThread = debuggee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/suspendPolicy\/suspendpolicy001.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-        ThreadReference mainThread = debuggee.threadByName(\"main\");\n+        ThreadReference mainThread = debuggee.mainThread();\n@@ -459,0 +459,1 @@\n+        debuggee.setMainThread(event.thread());\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/Method\/isObsolete\/isobsolete003.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,3 @@\n+        ClassPrepareEvent cpEvent = debuggee.waitForClassPrepare(DEBUGGEE_NAME);\n+        debuggee.setMainThread(cpEvent.thread());\n+\n@@ -138,1 +141,1 @@\n-            checkedThread = debuggee.threadByName(\"main\");\n+            checkedThread = debuggee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/MethodEntryEvent\/method\/method002.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-            breakpointForCommunication();\n+            breakpointForCommunication(debuggeeName);\n@@ -334,26 +334,0 @@\n-    protected void breakpointForCommunication()\n-                 throws JDITestRuntimeException {\n-        log2(\"breakpointForCommunication\");\n-\n-        do {\n-            getEventSet();\n-\n-            Event event = eventIterator.nextEvent();\n-            if (event instanceof BreakpointEvent)\n-                return;\n-\n-            log2(\"      received: \" + event);\n-\n-            if (EventFilters.filtered(event, debuggeeName)) {\n-                eventSet.resume();\n-            }\n-            else {\n-                break;\n-            }\n-        } while (true);\n-\n-        throw new JDITestRuntimeException(\"** event IS NOT a breakpoint **\");\n-    }\n-\n-\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/MethodEntryRequest\/addClassExclusionFilter\/filter002.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,0 +113,3 @@\n+        ClassPrepareEvent cpEvent = debuggee.waitForClassPrepare(DEBUGGEE_NAME);\n+        debuggee.setMainThread(cpEvent.thread());\n+\n@@ -134,1 +137,1 @@\n-            checkedThread = debuggee.threadByName(\"main\");\n+            checkedThread = debuggee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/MethodExitEvent\/method\/method001.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,0 +117,3 @@\n+        ClassPrepareEvent cpEvent = debuggee.waitForClassPrepare(DEBUGGEE_NAME);\n+        debuggee.setMainThread(cpEvent.thread());\n+\n@@ -139,1 +142,1 @@\n-            checkedThread = debuggee.threadByName(\"main\");\n+            checkedThread = debuggee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/MethodExitEvent\/method\/method002.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-            breakpointForCommunication();\n+            breakpointForCommunication(debuggeeName);\n@@ -334,24 +334,0 @@\n-    protected void breakpointForCommunication()\n-                   throws JDITestRuntimeException {\n-        log2(\"breakpointForCommunication\");\n-\n-        do {\n-            getEventSet();\n-\n-            Event event = eventIterator.nextEvent();\n-            if (event instanceof BreakpointEvent)\n-                return;\n-\n-            log2(\"      received: \" + event);\n-\n-            if (EventFilters.filtered(event, debuggeeName)) {\n-                eventSet.resume();\n-            }\n-            else {\n-                break;\n-            }\n-        } while (true);\n-\n-        throw new JDITestRuntimeException(\"** event IS NOT a breakpoint **\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/MethodExitRequest\/addClassExclusionFilter\/filter002.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-        ThreadReference mainThread = debuggee.threadByName(\"main\");\n+        ThreadReference mainThread = debuggee.mainThread();\n@@ -296,0 +296,2 @@\n+        debuggee.setMainThread(event.thread()); \/\/ Needed so debuggee.mainThread() will work\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/entryCount\/entrycount002.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-        ThreadReference mainThread = debuggee.threadByName(\"main\");\n+        ThreadReference mainThread = debuggee.mainThread();\n@@ -310,0 +310,2 @@\n+        debuggee.setMainThread(event.thread()); \/\/ Needed so debuggee.mainThread() will work\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/owningThread\/owningthread002.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        ThreadReference thread = debugee.threadByName(\"main\");\n+        ThreadReference thread = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StackFrame\/_bounds_\/bounds002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-        ThreadReference thread = debugee.threadByName(\"main\");\n+        ThreadReference thread = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepRequest\/_bounds_\/filters001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepRequest\/addClassFilter_rt\/filter_rt002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-                     ThreadReference thread1 = debuggee.threadByNameOrThrow(\"thread1\");\n+                     ThreadReference thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, \"thread1\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepRequest\/addClassFilter_s\/filter_s002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                    thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepRequest\/depth\/depth001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepRequest\/depth\/depth002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepRequest\/depth\/depth003.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepRequest\/size\/size001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepRequest\/size\/size002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-                     thread1 = debuggee.threadByNameOrThrow(threadName1);\n+                     thread1 = debuggee.threadByFieldNameOrThrow(debuggeeClass, threadName1);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepRequest\/thread\/thread001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-        ThreadReference thread = debugee.threadByName(\"main\");\n+        ThreadReference thread = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/_bounds_\/bounds001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-            ThreadReference thread2Ref = debuggee.threadByNameOrThrow(thread2Name);\n+            ThreadReference thread2Ref = debuggee.threadByFieldNameOrThrow(debuggeeClass, thread2Name);\n@@ -314,1 +314,1 @@\n-                breakpointRequest = settingBreakpoint(debuggee.threadByNameOrThrow(thread2Name),\n+                breakpointRequest = settingBreakpoint(thread2Ref,\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-            ThreadReference thread2Ref = debuggee.threadByNameOrThrow(thread2Name);\n+            ThreadReference thread2Ref = debuggee.threadByFieldNameOrThrow(debuggeeClass, thread2Name);\n@@ -276,1 +276,1 @@\n-            ThreadReference thread3Ref = debuggee.threadByNameOrThrow(thread3Name);\n+            ThreadReference thread3Ref = debuggee.threadByFieldNameOrThrow(debuggeeClass, thread3Name);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-        ThreadReference thread2Ref = debuggee.threadByNameOrThrow(thread2Name);\n+        ThreadReference thread2Ref = debuggee.threadByFieldNameOrThrow(debuggeeClass, thread2Name);\n@@ -289,1 +289,1 @@\n-        ThreadReference thread3Ref = debuggee.threadByNameOrThrow(thread3Name);\n+        ThreadReference thread3Ref = debuggee.threadByFieldNameOrThrow(debuggeeClass, thread3Name);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes003.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-            ThreadReference thread2Ref = debuggee.threadByNameOrThrow(thread2Name);\n+            ThreadReference thread2Ref = debuggee.threadByFieldNameOrThrow(debuggeeClass, thread2Name);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes004.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-            ThreadReference thread2Ref = debuggee.threadByNameOrThrow(thread2Name);\n+            ThreadReference thread2Ref = debuggee.threadByFieldNameOrThrow(debuggeeClass, thread2Name);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/popFrames\/popframes005.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,14 +78,1 @@\n-public class addthreadfilter002 {\n-\n-    \/\/----------------------------------------------------- templete section\n-    static final int PASSED = 0;\n-    static final int FAILED = 2;\n-    static final int PASS_BASE = 95;\n-\n-    \/\/----------------------------------------------------- templete parameters\n-    static final String\n-    sHeader1 = \"\\n==> nsk\/jdi\/ThreadStartRequest\/addThreadFilter\/addthreadfilter002 \",\n-    sHeader2 = \"--> debugger: \",\n-    sHeader3 = \"##> debugger: \";\n-\n-    \/\/----------------------------------------------------- main method\n+public class addthreadfilter002 extends JDIBase {\n@@ -112,14 +99,0 @@\n-    \/\/--------------------------------------------------   log procedures\n-\n-    private static Log  logHandler;\n-\n-    private static void log1(String message) {\n-        logHandler.display(sHeader1 + message);\n-    }\n-    private static void log2(String message) {\n-        logHandler.display(sHeader2 + message);\n-    }\n-    private static void log3(String message) {\n-        logHandler.complain(sHeader3 + message);\n-    }\n-\n@@ -132,17 +105,0 @@\n-    \/\/------------------------------------------------------ common section\n-\n-    static Debugee          debuggee;\n-    static ArgumentHandler  argsHandler;\n-\n-    static int waitTime;\n-\n-    static VirtualMachine      vm            = null;\n-    static EventRequestManager eventRManager = null;\n-    static EventQueue          eventQueue    = null;\n-    static EventSet            eventSet      = null;\n-    static EventIterator       eventIterator = null;\n-\n-    static ReferenceType       debuggeeClass = null;\n-\n-    static int  testExitCode = PASSED;\n-\n@@ -290,10 +246,1 @@\n-        String bPointMethod = \"methodForCommunication\";\n-        String lineForComm  = \"lineForComm\";\n-        BreakpointRequest bpRequest;\n-\n-        ThreadReference mainThread = debuggee.threadByNameOrThrow(\"main\");\n-\n-        bpRequest = settingBreakpoint(mainThread,\n-                                      debuggeeClass,\n-                                      bPointMethod, lineForComm, \"zero\");\n-        bpRequest.enable();\n+        setupBreakpointForCommunication(debuggeeClass);\n@@ -310,0 +257,1 @@\n+            ThreadReference mainThread = bpEvent.thread(); \/\/ bpEvent saved by breakpointForCommunication()\n@@ -381,104 +329,0 @@\n-   \/*\n-    * private BreakpointRequest settingBreakpoint(ThreadReference, ReferenceType,\n-    *                                             String, String, String)\n-    *\n-    * It sets up a breakpoint at given line number within a given method in a given class\n-    * for a given thread.\n-    *\n-    * Return value: BreakpointRequest object  in case of success\n-    *\n-    * JDITestRuntimeException   in case of an Exception thrown within the method\n-    *\/\n-\n-    private BreakpointRequest settingBreakpoint ( ThreadReference thread,\n-                                                  ReferenceType testedClass,\n-                                                  String methodName,\n-                                                  String bpLine,\n-                                                  String property)\n-            throws JDITestRuntimeException {\n-\n-        log2(\"......setting up a breakpoint:\");\n-        log2(\"       thread: \" + thread + \"; class: \" + testedClass +\n-                        \"; method: \" + methodName + \"; line: \" + bpLine);\n-\n-        List              alllineLocations = null;\n-        Location          lineLocation     = null;\n-        BreakpointRequest breakpRequest    = null;\n-\n-        try {\n-            Method  method  = (Method) testedClass.methodsByName(methodName).get(0);\n-\n-            alllineLocations = method.allLineLocations();\n-\n-            int n =\n-                ( (IntegerValue) testedClass.getValue(testedClass.fieldByName(bpLine) ) ).value();\n-            if (n > alllineLocations.size()) {\n-                log3(\"ERROR:  TEST_ERROR_IN_settingBreakpoint(): number is out of bound of method's lines\");\n-            } else {\n-                lineLocation = (Location) alllineLocations.get(n);\n-                try {\n-                    breakpRequest = eventRManager.createBreakpointRequest(lineLocation);\n-                    breakpRequest.putProperty(\"number\", property);\n-                    breakpRequest.addThreadFilter(thread);\n-                    breakpRequest.setSuspendPolicy( EventRequest.SUSPEND_EVENT_THREAD);\n-                } catch ( Exception e1 ) {\n-                    log3(\"ERROR: inner Exception within settingBreakpoint() : \" + e1);\n-                    breakpRequest    = null;\n-                }\n-            }\n-        } catch ( Exception e2 ) {\n-            log3(\"ERROR: ATTENTION:  outer Exception within settingBreakpoint() : \" + e2);\n-            breakpRequest    = null;\n-        }\n-\n-        if (breakpRequest == null) {\n-            log2(\"      A BREAKPOINT HAS NOT BEEN SET UP\");\n-            throw new JDITestRuntimeException(\"**FAILURE to set up a breakpoint**\");\n-        }\n-\n-        log2(\"      a breakpoint has been set up\");\n-        return breakpRequest;\n-    }\n-\n-\n-    private void getEventSet()\n-                 throws JDITestRuntimeException {\n-        try {\n-\/\/            log2(\"       eventSet = eventQueue.remove(waitTime);\");\n-            eventSet = eventQueue.remove(waitTime);\n-            if (eventSet == null) {\n-                throw new JDITestRuntimeException(\"** TIMEOUT while waiting for event **\");\n-            }\n-\/\/            log2(\"       eventIterator = eventSet.eventIterator;\");\n-            eventIterator = eventSet.eventIterator();\n-        } catch ( Exception e ) {\n-            throw new JDITestRuntimeException(\"** EXCEPTION while waiting for event ** : \" + e);\n-        }\n-    }\n-\n-\n-    private void breakpointForCommunication()\n-                 throws JDITestRuntimeException {\n-\n-        log2(\"breakpointForCommunication\");\n-        while (true) {\n-            getEventSet();\n-            while (eventIterator.hasNext()) {\n-                Event event = eventIterator.nextEvent();\n-                if (event instanceof BreakpointEvent) {\n-                    return;\n-                } else if (event instanceof ThreadStartEvent) {\n-                    \/\/ It might be the case that while the thread start request was enabled\n-                    \/\/ some threads not related to the test ( e.g. JVMCI threads) were started\n-                    \/\/ and generated thread start events. We ignore these thread start events\n-                    \/\/ and keep waiting for a breakpoint event.\n-                    ThreadStartEvent tse = (ThreadStartEvent) event;\n-                    log2(\"ThreadStartEvent is received while waiting for a breakpoint\" +\n-                            \" event, thread: : \" + tse.thread().name());\n-                    continue;\n-                }\n-                throw new JDITestRuntimeException(\"** event IS NOT a breakpoint or a thread start **\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadStartRequest\/addThreadFilter\/addthreadfilter002.java","additions":4,"deletions":160,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -170,1 +170,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses004.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -168,1 +168,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses005.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -170,1 +170,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses006.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -177,1 +177,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses007.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,1 +165,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -175,1 +175,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses008.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -167,1 +167,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses009.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,1 +159,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -169,1 +169,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses010.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -171,1 +171,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses011.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -167,1 +167,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses012.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,1 +164,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -174,1 +174,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses013.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,1 +165,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -175,1 +175,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses014.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -185,1 +185,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -195,1 +195,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses015.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,1 +166,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n@@ -176,1 +176,0 @@\n-        thrd = debugee.threadByName(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses016.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses020.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,1 +236,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses021.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -237,1 +237,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses022.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,1 +295,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses024.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses025.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,1 +209,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses026.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +268,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses027.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses028.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -234,1 +234,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses030.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses031.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-        ThreadReference thrd = debugee.threadByName(\"main\");\n+        ThreadReference thrd = debugee.mainThread();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/redefineClasses\/redefineclasses032.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * In addition to the general abities to control of debugee VM process,\n+ * In addition to the general abilities to control the debugee VM process\n@@ -45,1 +45,1 @@\n- * handling events, and so on.).\n+ * handling events, and so on).\n@@ -64,0 +64,6 @@\n+    \/** wait time in ms. *\/\n+    protected long waitTime;\n+\n+    \/** Stashed ThreadReference for debuggee \"main\" thread. Not always setup. *\/\n+    protected ThreadReference mainThread;\n+\n@@ -69,0 +75,1 @@\n+        this.waitTime = argumentHandler.getWaitTime() * 60000;\n@@ -76,0 +83,1 @@\n+        this.waitTime = argumentHandler.getWaitTime() * 60000;\n@@ -267,0 +275,42 @@\n+    public void setMainThread(ThreadReference thread) {\n+        String threadName = thread.name();\n+        if (!threadName.equals(\"main\")) {\n+            throw new TestBug(\"Thread is not \\\"main\\\" thread: \" + threadName);\n+        }\n+        mainThread = thread;\n+    }\n+\n+    public ThreadReference mainThread() {\n+        if (mainThread == null) {\n+            throw new JDITestRuntimeException(\"** mainThrad has not been set **\");\n+        }\n+        return mainThread;\n+    }\n+\n+    \/**\n+     * Return a debuggee thread by fetching it from a static field in the debuggee.\n+     *\/\n+    public ThreadReference threadByFieldNameOrThrow(ReferenceType debuggeeClass,\n+                                                    String threadFieldName)\n+            throws JDITestRuntimeException {\n+\n+        Field field = debuggeeClass.fieldByName(threadFieldName);\n+        if (field == null) {\n+            throw new JDITestRuntimeException(\"** Thread field not found ** : \"\n+                                              + threadFieldName);\n+        }\n+\n+        ThreadReference thread = (ThreadReference)debuggeeClass.getValue(field);\n+        if (thread == null) {\n+            throw new JDITestRuntimeException(\"** Thread field is null ** : \"\n+                                              + threadFieldName);\n+        }\n+\n+        if (!thread.name().equals(threadFieldName)) {\n+            throw new JDITestRuntimeException(\"** Thread names do not match ** : \"\n+                                              + threadFieldName + \" vs. \" + thread.name());\n+        }\n+\n+        return thread;\n+    }\n+\n@@ -440,2 +490,1 @@\n-     * @param request non-null value for events generated by this\n-     * event request; null value for <code>VMStartEvent<\/code>.\n+     * @param request non-null value for events generated by this event request;\n@@ -464,1 +513,1 @@\n-                continue;\n+                return null;\n@@ -553,1 +602,0 @@\n-\n@@ -555,0 +603,6 @@\n+\n+        \/\/ Get the ClassPrepareEvent for the main class for the sole purpose\n+        \/\/ of using it to get the ThreadReference for the \"main\" thread.\n+        ClassPrepareEvent cpEvent = debugee.waitForClassPrepare(mainClassName);\n+        debugee.setMainThread(cpEvent.thread());\n+\n@@ -562,0 +616,31 @@\n+    public ClassPrepareEvent waitForClassPrepare(String classname) {\n+        Event event;\n+        EventRequestManager eventRManager = getEventRequestManager();\n+        ClassPrepareRequest cpRequest = eventRManager.createClassPrepareRequest();\n+        cpRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n+        cpRequest.addClassFilter(classname);\n+        cpRequest.addCountFilter(1);\n+\n+        cpRequest.enable();\n+        vm.resume();\n+        try {\n+            event = (ClassPrepareEvent)waitingEvent(cpRequest, waitTime);\n+        } catch (InterruptedException e) {\n+            throw new Failure(\"Thread interrupted while waiting for ClassPrepareEvent: \" + e);\n+        }\n+        cpRequest.disable();\n+\n+        if (!(event instanceof ClassPrepareEvent)) {\n+            throw new Failure(\"Unexpected Event: \" + event);\n+        }\n+\n+        ClassPrepareEvent cpEvent = (ClassPrepareEvent)event;\n+        ReferenceType cls = cpEvent.referenceType();\n+        if (!cls.name().equals(classname)) {\n+            throw new Failure(\"Unexpected ClassName for ClassPrepareEvent: \" + cls.name());\n+        }\n+\n+        display(\"received: ClassPrepareEvent for class: \" + classname);\n+        return cpEvent;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/Debugee.java","additions":92,"deletions":7,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,0 +344,1 @@\n+                \"CompilerThread\",\n@@ -348,1 +349,1 @@\n-                if (tname.startsWith(s)) {\n+                if (tname.indexOf(s) != -1) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/EventFilters.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -242,0 +242,3 @@\n+                ThreadStartEvent tse = (ThreadStartEvent) event;\n+                log2(\"ThreadStartEvent is received while waiting for a breakpoint\" +\n+                     \" event, thread: : \" + tse.thread().name());\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/JDIBase.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -192,0 +192,3 @@\n+java\/awt\/datatransfer\/ClipboardPerformanceTest.java 8029022 windows-all\n+java\/awt\/datatransfer\/HTMLTransferConsoleOutputTest.java 8237254 macosx-all\n+java\/awt\/datatransfer\/ImageTransferCrashTest.java 8237253 macosx-all\n@@ -749,1 +752,0 @@\n-java\/util\/logging\/LoggingDeadlock5.java       8354424 generic-all\n@@ -849,0 +851,1 @@\n+jdk\/classfile\/AdvancedTransformationsTest.java 8364095 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key headful\n+ * @bug 8344697\n+ * @summary Default button in AquaRootPaneUI should paint special background color\n+ * @requires (os.family == \"mac\")\n+ * @run main RootPaneDefaultButtonTest\n+ *\/\n+\n+import javax.swing.*;\n+import javax.swing.border.*;\n+import java.awt.*;\n+import java.awt.event.*;\n+\n+\/**\n+ * This presents two dialogs, each with two possible default buttons. The\n+ * background color of the default button should change based on which radio\n+ * button is selected.\n+ * <p>\n+ * Note we've never expected this test to fail. This test was introduced\n+ * because the resolution to JDK-8344697 involved removing code, and we wanted\n+ * to double-check that the removed code didn't negatively affect how default\n+ * buttons are repainted.\n+ *\/\n+public class RootPaneDefaultButtonTest extends JDialog {\n+\n+    record ButtonRenderingExpectation(JButton button,\n+                                      boolean appearAsDefault) {}\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!System.getProperty(\"os.name\").contains(\"OS X\")) {\n+            System.out.println(\"This test is for MacOS only.\");\n+            return;\n+        }\n+\n+        RootPaneDefaultButtonTest window1 = new RootPaneDefaultButtonTest();\n+        RootPaneDefaultButtonTest window2 = new RootPaneDefaultButtonTest();\n+\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                Rectangle r1 = new Rectangle(0, 20,\n+                        window1.getWidth(), window1.getHeight());\n+                window1.setBounds(r1);\n+\n+                Rectangle r2 = new Rectangle((int) (r1.getMaxX() + 10), 20,\n+                        window2.getWidth(), window2.getHeight());\n+                window2.setBounds(r2);\n+\n+                window1.setVisible(true);\n+                window2.setVisible(true);\n+            }\n+        });\n+\n+        Robot robot = new Robot();\n+\n+        test(robot, window1.radioButton1,\n+                new ButtonRenderingExpectation(window1.button1, true),\n+                new ButtonRenderingExpectation(window1.button2, false),\n+                new ButtonRenderingExpectation(window2.button1, false),\n+                new ButtonRenderingExpectation(window2.button2, false));\n+\n+        test(robot, window1.radioButton2,\n+                new ButtonRenderingExpectation(window1.button1, false),\n+                new ButtonRenderingExpectation(window1.button2, true),\n+                new ButtonRenderingExpectation(window2.button1, false),\n+                new ButtonRenderingExpectation(window2.button2, false));\n+\n+        test(robot, window1.radioButton3,\n+                new ButtonRenderingExpectation(window1.button1, false),\n+                new ButtonRenderingExpectation(window1.button2, false),\n+                new ButtonRenderingExpectation(window2.button1, false),\n+                new ButtonRenderingExpectation(window2.button2, false));\n+\n+        test(robot, window2.radioButton1,\n+                new ButtonRenderingExpectation(window1.button1, false),\n+                new ButtonRenderingExpectation(window1.button2, false),\n+                new ButtonRenderingExpectation(window2.button1, true),\n+                new ButtonRenderingExpectation(window2.button2, false));\n+\n+        test(robot, window2.radioButton2,\n+                new ButtonRenderingExpectation(window1.button1, false),\n+                new ButtonRenderingExpectation(window1.button2, false),\n+                new ButtonRenderingExpectation(window2.button1, false),\n+                new ButtonRenderingExpectation(window2.button2, true));\n+\n+        test(robot, window2.radioButton3,\n+                new ButtonRenderingExpectation(window1.button1, false),\n+                new ButtonRenderingExpectation(window1.button2, false),\n+                new ButtonRenderingExpectation(window2.button1, false),\n+                new ButtonRenderingExpectation(window2.button2, false));\n+\n+        System.out.println(\"Test passed successfully\");\n+    }\n+\n+    private static void test(Robot robot, AbstractButton buttonToClick,\n+                             ButtonRenderingExpectation... expectations)\n+            throws Exception {\n+        robot.delay(100);\n+\n+        Point mouseLoc = buttonToClick.getLocationOnScreen();\n+        robot.mouseMove(mouseLoc.x + buttonToClick.getSize().width \/ 2,\n+                mouseLoc.y + buttonToClick.getSize().height \/ 2);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(20);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        robot.delay(100);\n+\n+        \/\/ the colors may change depending on your system's appearance.\n+        \/\/ Depending on how you've configured \"Appearance\" in the\n+        \/\/ System Settings app: the default button may be blue (the default),\n+        \/\/ red, purple, etc. So instead of checking for a specific color: we'll\n+        \/\/ make sure 3-4 are the same color, and one is significantly\n+        \/\/ different.\n+        Color defaultColor = null;\n+        Color nonDefaultColor = null;\n+\n+        for (ButtonRenderingExpectation expectation : expectations) {\n+            int x = expectation.button.getLocationOnScreen().x + 20;\n+            int y = expectation.button.getLocationOnScreen().y + 10;\n+\n+            \/\/ this mouseMove is optional, but it helps debug this test to see\n+            \/\/ where we're sampling the pixel color from:\n+            robot.mouseMove(x, y);\n+\n+            Color c = robot.getPixelColor(x, y);\n+            if (expectation.appearAsDefault) {\n+                if (defaultColor == null) {\n+                    defaultColor = c;\n+                } else {\n+                    throw new IllegalStateException(\n+                            \"there should only be at most 1 default button\");\n+                }\n+            } else {\n+                if (nonDefaultColor == null) {\n+                    nonDefaultColor = c;\n+                } else if (!isSimilar(nonDefaultColor, c)) {\n+                    throw new IllegalStateException(\n+                            \"these two colors should match: \" + c + \", \" +\n+                                    nonDefaultColor);\n+                }\n+            }\n+        }\n+\n+        if (defaultColor != null && isSimilar(defaultColor, nonDefaultColor)) {\n+            throw new IllegalStateException(\n+                    \"The default button and non-default buttons should \" +\n+                            \"look different: \" + defaultColor + \" matches \" +\n+                            nonDefaultColor);\n+        }\n+    }\n+\n+    private static boolean isSimilar(Color c1, Color c2) {\n+        if (Math.abs(c1.getRed() - c2.getRed()) > 15) {\n+            return false;\n+        }\n+        if (Math.abs(c1.getGreen() - c2.getGreen()) > 15) {\n+            return false;\n+        }\n+        if (Math.abs(c1.getBlue() - c2.getBlue()) > 15) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    JRadioButton radioButton1 = new JRadioButton(\n+            \"\\\"Button 1\\\" is the default button\");\n+    JRadioButton radioButton2 = new JRadioButton(\n+            \"\\\"Button 2\\\" is the default button\");\n+    JRadioButton radioButton3 = new JRadioButton(\"No default button\");\n+\n+    JButton button1 = new JButton(\"Button 1\");\n+    JButton button2 = new JButton(\"Button 2\");\n+\n+    public RootPaneDefaultButtonTest() {\n+        getContentPane().setLayout(new BorderLayout());\n+        getContentPane().add(createRadioButtonPanel(), BorderLayout.NORTH);\n+        getContentPane().add(createPushButtonRow(), BorderLayout.SOUTH);\n+        pack();\n+\n+        radioButton1.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                getRootPane().setDefaultButton(button1);\n+            }\n+        });\n+\n+        radioButton2.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                getRootPane().setDefaultButton(button2);\n+            }\n+        });\n+\n+        radioButton3.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                getRootPane().setDefaultButton(null);\n+            }\n+        });\n+\n+        ButtonGroup g = new ButtonGroup();\n+        g.add(radioButton1);\n+        g.add(radioButton2);\n+        g.add(radioButton3);\n+        radioButton1.doClick();\n+    }\n+\n+    private JPanel createPushButtonRow() {\n+        JPanel p = new JPanel(new GridLayout(1, 2));\n+        p.add(button1);\n+        p.add(button2);\n+        p.setBorder(new EmptyBorder(5,5,5,5));\n+        return p;\n+    }\n+\n+    private JPanel createRadioButtonPanel() {\n+        JPanel p = new JPanel(new GridLayout(3, 1));\n+        p.add(radioButton1);\n+        p.add(radioButton2);\n+        p.add(radioButton3);\n+        p.setBorder(new EmptyBorder(5,5,5,5));\n+        return p;\n+    }\n+}\n","filename":"test\/jdk\/com\/apple\/laf\/RootPane\/RootPaneDefaultButtonTest.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame jtreg.SkippedException\n@@ -39,0 +39,2 @@\n+import jtreg.SkippedException;\n+\n@@ -50,6 +52,0 @@\n-        if (!Desktop.isDesktopSupported()) {\n-            PassFailJFrame.log(\"Class java.awt.Desktop is not supported on \" +\n-                    \"current platform. Farther testing will not be performed\");\n-            PassFailJFrame.forcePass();\n-        }\n-\n@@ -80,0 +76,5 @@\n+        if (!Desktop.isDesktopSupported()) {\n+            throw new SkippedException(\"Class java.awt.Desktop is not supported \" +\n+                    \"on current platform. Further testing will not be performed\");\n+        }\n+\n","filename":"test\/jdk\/java\/awt\/Desktop\/BrowseTest.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame jtreg.SkippedException\n@@ -43,0 +43,2 @@\n+import jtreg.SkippedException;\n+\n@@ -52,13 +54,1 @@\n-    public EditAndPrintTest() {\n-        if (!Desktop.isDesktopSupported()) {\n-            PassFailJFrame.log(\"Class java.awt.Desktop is not supported on \" +\n-                    \"current platform. Further testing will not be performed\");\n-            PassFailJFrame.forcePass();\n-        }\n-\n-        Desktop desktop = Desktop.getDesktop();\n-\n-        if (!desktop.isSupported(Action.PRINT) && !desktop.isSupported(Action.EDIT)) {\n-            PassFailJFrame.log(\"Neither EDIT nor PRINT actions are supported. Nothing to test.\");\n-            PassFailJFrame.forcePass();\n-        }\n+    static Desktop desktop;\n@@ -66,0 +56,1 @@\n+    public EditAndPrintTest() {\n@@ -114,1 +105,1 @@\n-        } catch (java.io.IOException ioe){\n+        } catch (IOException ioe){\n@@ -142,0 +133,10 @@\n+        if (!Desktop.isDesktopSupported()) {\n+            throw new SkippedException(\"Class java.awt.Desktop is not supported \" +\n+                    \"on current platform. Further testing will not be performed\");\n+        }\n+\n+        desktop = Desktop.getDesktop();\n+        if (!desktop.isSupported(Action.PRINT) && !desktop.isSupported(Action.EDIT)) {\n+            throw new SkippedException(\"Neither EDIT nor PRINT actions are supported. Nothing to test.\");\n+        }\n+\n","filename":"test\/jdk\/java\/awt\/Desktop\/EditAndPrintTest\/EditAndPrintTest.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame jtreg.SkippedException\n@@ -39,0 +39,2 @@\n+import jtreg.SkippedException;\n+\n@@ -51,6 +53,0 @@\n-        if (!Desktop.isDesktopSupported()) {\n-            PassFailJFrame.log(\"Class java.awt.Desktop is not supported on \" +\n-                    \"current platform. Further testing will not be performed\");\n-            PassFailJFrame.forcePass();\n-        }\n-\n@@ -88,1 +84,1 @@\n-        } catch (java.io.IOException ioe) {\n+        } catch (IOException ioe) {\n@@ -104,0 +100,5 @@\n+        if (!Desktop.isDesktopSupported()) {\n+            throw new SkippedException(\"Class java.awt.Desktop is not supported \" +\n+                    \"on current platform. Further testing will not be performed\");\n+        }\n+\n","filename":"test\/jdk\/java\/awt\/Desktop\/OpenTest.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4463560\n+ * @requires (os.family == \"windows\")\n+ * @summary Tests that datatransfer doesn't take too much time to complete\n+ * @key headful\n+ * @library \/test\/lib\n+ * @run main\/timeout=300 ClipboardPerformanceTest\n+ *\/\n+\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ClipboardPerformanceTest {\n+    public static final int CODE_FAILURE = 1;\n+    public static final int CODE_OTHER_FAILURE = 2;\n+    static String eoln;\n+    static char[] text;\n+    public static final int ARRAY_SIZE = 100000;\n+    public static final int RATIO_THRESHOLD = 10;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            ClipboardPerformanceTest clipboardPerformanceTest = new ClipboardPerformanceTest();\n+            clipboardPerformanceTest.initialize();\n+            return;\n+        }\n+\n+        long before, after, oldTime, newTime;\n+        float ratio;\n+\n+        try {\n+            Transferable t = Toolkit.getDefaultToolkit().getSystemClipboard().getContents(null);\n+            before = System.currentTimeMillis();\n+            String ss = (String) t.getTransferData(new DataFlavor(\"text\/plain; class=java.lang.String\"));\n+            after = System.currentTimeMillis();\n+\n+            System.err.println(\"Size: \" + ss.length());\n+            newTime = after - before;\n+            System.err.println(\"Time consumed: \" + newTime);\n+\n+            initArray();\n+\n+            StringBuffer buf = new StringBuffer(new String(text));\n+            int eoln_len = eoln.length();\n+            before = System.currentTimeMillis();\n+\n+            for (int i = 0; i + eoln_len <= buf.length(); i++) {\n+                if (eoln.equals(buf.substring(i, i + eoln_len))) {\n+                    buf.replace(i, i + eoln_len, \"\\n\");\n+                }\n+            }\n+\n+            after = System.currentTimeMillis();\n+            oldTime = after - before;\n+            System.err.println(\"Old algorithm: \" + oldTime);\n+            ratio = oldTime \/ newTime;\n+            System.err.println(\"Ratio: \" + ratio);\n+\n+            if (ratio < RATIO_THRESHOLD) {\n+                System.out.println(\"Time ratio failure!!\");\n+                System.exit(CODE_FAILURE);\n+            }\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            System.exit(CODE_OTHER_FAILURE);\n+        }\n+        System.out.println(\"Test Pass!\");\n+    }\n+\n+    public static void initArray() {\n+        text = new char[ARRAY_SIZE + 2];\n+\n+        for (int i = 0; i < ARRAY_SIZE; i += 3) {\n+            text[i] = '\\r';\n+            text[i + 1] = '\\n';\n+            text[i + 2] = 'a';\n+        }\n+        eoln = \"\\r\\n\";\n+    }\n+\n+    public void initialize() throws Exception {\n+        initArray();\n+        Clipboard cb = Toolkit.getDefaultToolkit().getSystemClipboard();\n+        cb.setContents(new StringSelection(new String(text)), null);\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                ClipboardPerformanceTest.class.getName(),\n+                \"child\"\n+        );\n+\n+        Process process = ProcessTools.startProcess(\"Child\", pb);\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(process);\n+\n+        if (!process.waitFor(15, TimeUnit.SECONDS)) {\n+            process.destroyForcibly();\n+            throw new TimeoutException(\"Timed out waiting for Child\");\n+        }\n+\n+        outputAnalyzer.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/datatransfer\/ClipboardPerformanceTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4638351\n+ * @summary tests that HTML transfer doesn't cause console output\n+ * @key headful\n+ * @library \/test\/lib\n+ * @run main HTMLTransferConsoleOutputTest\n+ *\/\n+\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.ClipboardOwner;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class HTMLTransferConsoleOutputTest implements ClipboardOwner {\n+    static final Clipboard clipboard =\n+            Toolkit.getDefaultToolkit().getSystemClipboard();\n+    static final DataFlavor dataFlavor =\n+            new DataFlavor(\"text\/html; class=java.lang.String\", null);\n+    static final String magic = \"TESTMAGICSTRING\";\n+    static final Transferable transferable = new Transferable() {\n+        final DataFlavor[] flavors = new DataFlavor[]{dataFlavor};\n+        final String data = \"<html><body>\" + magic + \"<\/html><\/body>\";\n+\n+        public DataFlavor[] getTransferDataFlavors() {\n+            return flavors;\n+        }\n+\n+        public boolean isDataFlavorSupported(DataFlavor df) {\n+            return dataFlavor.equals(df);\n+        }\n+\n+        public Object getTransferData(DataFlavor df)\n+                throws UnsupportedFlavorException {\n+            if (!isDataFlavorSupported(df)) {\n+                throw new UnsupportedFlavorException(df);\n+            }\n+            return data;\n+        }\n+    };\n+    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    public static final int CLIPBOARD_DELAY = 1000;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            HTMLTransferConsoleOutputTest htmlTransferConsoleOutputTest = new HTMLTransferConsoleOutputTest();\n+            htmlTransferConsoleOutputTest.initialize();\n+            return;\n+        }\n+        final ClipboardOwner clipboardOwner = new ClipboardOwner() {\n+            public void lostOwnership(Clipboard clip,\n+                                      Transferable contents) {\n+                System.exit(0);\n+            }\n+        };\n+        clipboard.setContents(transferable, clipboardOwner);\n+        final Object o = new Object();\n+        synchronized (o) {\n+            try {\n+                o.wait();\n+            } catch (InterruptedException ie) {\n+                ie.printStackTrace();\n+            }\n+        }\n+        System.out.println(\"Test Pass!\");\n+    }\n+\n+    public void initialize() throws Exception {\n+        clipboard.setContents(transferable, this);\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                HTMLTransferConsoleOutputTest.class.getName(),\n+                \"child\"\n+        );\n+\n+        Process process = ProcessTools.startProcess(\"Child\", pb);\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(process);\n+\n+        if (!process.waitFor(15, TimeUnit.SECONDS)) {\n+            process.destroyForcibly();\n+            throw new TimeoutException(\"Timed out waiting for Child\");\n+        }\n+\n+        byte[] bytes = baos.toByteArray();\n+        String string = null;\n+        try {\n+            string = new String(bytes, \"ASCII\");\n+        } catch (UnsupportedEncodingException uee) {\n+            uee.printStackTrace();\n+        }\n+        if (string.lastIndexOf(magic) != -1) {\n+            throw new RuntimeException(\"Test failed. Output contains:\" +\n+                    string);\n+        }\n+\n+        outputAnalyzer.shouldHaveExitValue(0);\n+    }\n+\n+\n+    static class ForkOutputStream extends OutputStream {\n+        final OutputStream outputStream1;\n+        final OutputStream outputStream2;\n+\n+        public ForkOutputStream(OutputStream os1, OutputStream os2) {\n+            outputStream1 = os1;\n+            outputStream2 = os2;\n+        }\n+\n+        public void write(int b) throws IOException {\n+            outputStream1.write(b);\n+            outputStream2.write(b);\n+        }\n+\n+        public void flush() throws IOException {\n+            outputStream1.flush();\n+            outputStream2.flush();\n+        }\n+\n+        public void close() throws IOException {\n+            outputStream1.close();\n+            outputStream2.close();\n+        }\n+    }\n+\n+    public void lostOwnership(Clipboard clip, Transferable contents) {\n+        final Runnable r = () -> {\n+            try {\n+                Thread.sleep(CLIPBOARD_DELAY);\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            final PrintStream oldOut = System.out;\n+            final PrintStream newOut =\n+                    new PrintStream(new ForkOutputStream(oldOut, baos));\n+            Transferable t = clipboard.getContents(null);\n+            try {\n+                System.setOut(newOut);\n+                t.getTransferData(dataFlavor);\n+                System.setOut(oldOut);\n+            } catch (IOException | UnsupportedFlavorException ioe) {\n+                ioe.printStackTrace();\n+            }\n+            clipboard.setContents(transferable, null);\n+        };\n+        final Thread t = new Thread(r);\n+        t.start();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/datatransfer\/HTMLTransferConsoleOutputTest.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4513976\n+ * @summary tests that inter-JVM image transfer doesn't cause crash\n+ * @key headful\n+ * @library \/test\/lib\n+ * @run main ImageTransferCrashTest\n+ *\/\n+\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.ClipboardOwner;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.WritableRaster;\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ImageTransferCrashTest implements ClipboardOwner {\n+    static final Clipboard clipboard =\n+            Toolkit.getDefaultToolkit().getSystemClipboard();\n+    final Transferable textTransferable = new StringSelection(\"TEXT\");\n+    public static final int CLIPBOARD_DELAY = 10;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            ImageTransferCrashTest imageTransferCrashTest = new ImageTransferCrashTest();\n+            imageTransferCrashTest.initialize();\n+            return;\n+        }\n+        final ClipboardOwner clipboardOwner = (clip, contents) -> System.exit(0);\n+        final int width = 100;\n+        final int height = 100;\n+        final BufferedImage bufferedImage =\n+                new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n+        final WritableRaster writableRaster =\n+                bufferedImage.getWritableTile(0, 0);\n+        final int[] color = new int[]{0x80, 0x80, 0x80};\n+        for (int i = 0; i < width; i++) {\n+            for (int j = 0; j < height; j++) {\n+                writableRaster.setPixel(i, j, color);\n+            }\n+        }\n+        bufferedImage.releaseWritableTile(0, 0);\n+\n+        final Transferable imageTransferable = new Transferable() {\n+            final DataFlavor[] flavors = new DataFlavor[]{\n+                    DataFlavor.imageFlavor};\n+\n+            public DataFlavor[] getTransferDataFlavors() {\n+                return flavors;\n+            }\n+\n+            public boolean isDataFlavorSupported(DataFlavor df) {\n+                return DataFlavor.imageFlavor.equals(df);\n+            }\n+\n+            public Object getTransferData(DataFlavor df)\n+                    throws UnsupportedFlavorException {\n+                if (!isDataFlavorSupported(df)) {\n+                    throw new UnsupportedFlavorException(df);\n+                }\n+                return bufferedImage;\n+            }\n+        };\n+        clipboard.setContents(imageTransferable, clipboardOwner);\n+        final Object o = new Object();\n+        synchronized (o) {\n+            try {\n+                o.wait();\n+            } catch (InterruptedException ie) {\n+                ie.printStackTrace();\n+            }\n+        }\n+        System.out.println(\"Test Pass!\");\n+    }\n+\n+    public void initialize() throws Exception {\n+        clipboard.setContents(textTransferable, this);\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                ImageTransferCrashTest.class.getName(),\n+                \"child\"\n+        );\n+\n+        Process process = ProcessTools.startProcess(\"Child\", pb);\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(process);\n+\n+        if (!process.waitFor(15, TimeUnit.SECONDS)) {\n+            process.destroyForcibly();\n+            throw new TimeoutException(\"Timed out waiting for Child\");\n+        }\n+\n+        outputAnalyzer.shouldHaveExitValue(0);\n+    }\n+\n+    public void lostOwnership(Clipboard clip, Transferable contents) {\n+        final Runnable r = () -> {\n+            while (true) {\n+                try {\n+                    Thread.sleep(CLIPBOARD_DELAY);\n+                    Transferable t = clipboard.getContents(null);\n+                    t.getTransferData(DataFlavor.imageFlavor);\n+                } catch (IllegalStateException e) {\n+                    e.printStackTrace();\n+                    System.err.println(\"clipboard is not prepared yet\");\n+                    continue;\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+                break;\n+            }\n+            clipboard.setContents(textTransferable, null);\n+        };\n+        final Thread t = new Thread(r);\n+        t.start();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/datatransfer\/ImageTransferCrashTest.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -1297,8 +1297,10 @@\n-     * <p>The sample usage:\n-     * <pre><code>\n-     *      PrinterJob pj = PrinterJob.getPrinterJob();\n-     *      if (pj == null || pj.getPrintService() == null) {\n-     *          System.out.println(\"\"Printer not configured or available.\");\n-     *          PassFailJFrame.forcePass();\n-     *      }\n-     * <\/code><\/pre>\n+     * <p>\n+     * Use this method in semi-automatic tests when\n+     * the test determines that all the conditions for passing the test are met.\n+     * <p>\n+     * <strong>Do not use<\/strong> this method in cases where a resource is unavailable or a\n+     * feature isn't supported, throw {@code jtreg.SkippedException} instead.\n+     *\n+     * <p>A sample usage can be found in\n+     * <a href=\"https:\/\/github.com\/openjdk\/jdk\/blob\/7283c8b\/test\/jdk\/java\/awt\/FileDialog\/SaveFileNameOverrideTest.java#L84\">{@code\n+     * SaveFileNameOverrideTest.java}<\/a>\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/PassFailJFrame.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8168127\n+ * @bug 8168127 8354053\n@@ -29,1 +29,1 @@\n- * @modules java.base\/sun.security.util\n+ * @modules java.base\/java.io:open\n@@ -35,1 +35,0 @@\n-import sun.security.util.FilePermCompat;\n@@ -37,0 +36,1 @@\n+import java.lang.reflect.Method;\n@@ -38,0 +38,1 @@\n+\n@@ -40,0 +41,1 @@\n+@SuppressWarnings(\"removal\")\n@@ -53,1 +55,1 @@\n-    static void test(String arg) {\n+    static void test(String arg) throws Exception {\n@@ -55,0 +57,11 @@\n+        Method altPathMethod;\n+        Method plusAltPathMethod;\n+        try {\n+            altPathMethod = FilePermission.class.getDeclaredMethod(\"newPermUsingAltPath\");\n+            altPathMethod.setAccessible(true);\n+            plusAltPathMethod = FilePermission.class.getDeclaredMethod(\"newPermPlusAltPath\");\n+            plusAltPathMethod.setAccessible(true);\n+        } catch (Exception ex) {\n+            System.err.println(\"File permission compatibility initialization failed\");\n+            throw ex;\n+        }\n@@ -56,4 +69,2 @@\n-        FilePermission fp2 = (FilePermission)\n-                FilePermCompat.newPermUsingAltPath(fp1);\n-        FilePermission fp3 = (FilePermission)\n-                FilePermCompat.newPermPlusAltPath(fp1);\n+        FilePermission fp2 = (FilePermission) altPathMethod.invoke(fp1);\n+        FilePermission fp3 = (FilePermission) plusAltPathMethod.invoke(fp1);\n","filename":"test\/jdk\/java\/io\/FilePermission\/FilePermissionCollectionMerge.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+   @library \/test\/lib\n@@ -31,1 +32,6 @@\n-import java.io.*;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import jtreg.SkippedException;\n@@ -50,2 +56,5 @@\n-        String enc = System.getProperty(\"file.encoding\");\n-        if ((enc == null) || !enc.equals(\"SJIS\")) return;\n+        String enc = System.getProperty(\"native.encoding\");\n+        if ((enc == null) || !enc.equals(\"MS932\")) {\n+            throw new SkippedException(\n+                \"native.encoding(%s) is not MS932\".formatted(enc));\n+        }\n","filename":"test\/jdk\/java\/io\/pathNames\/win32\/SJIS.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableFunction methods\n+ * @enablePreview\n+ * @run junit StableFunctionTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableFunctionTest {\n+\n+    enum Value {\n+        \/\/ Zero is here so that we have enums with ordinals before the first one\n+        \/\/ actually used in input sets (i.e. ZERO is not in the input set)\n+        ZERO(0),\n+        ILLEGAL_BEFORE(-1),\n+        \/\/ Valid values\n+        THIRTEEN(13),\n+        ILLEGAL_BETWEEN(-2),\n+        FORTY_TWO(42),\n+        \/\/ Illegal values (not in the input set)\n+        ILLEGAL_AFTER(-3);\n+\n+        final int intValue;\n+\n+        Value(int intValue) {\n+            this.intValue = intValue;\n+        }\n+\n+        int asInt() {\n+            return intValue;\n+        }\n+\n+    }\n+\n+    private static final Function<Value, Integer> MAPPER = Value::asInt;\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void factoryInvariants(Set<Value> inputs) {\n+        assertThrows(NullPointerException.class, () -> StableValue.function(null, MAPPER));\n+        assertThrows(NullPointerException.class, () -> StableValue.function(inputs, null));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void basic(Set<Value> inputs) {\n+        basic(inputs, MAPPER);\n+        toStringTest(inputs, MAPPER);\n+        basic(inputs, _ -> null);\n+        toStringTest(inputs, _ -> null);\n+    }\n+\n+    void basic(Set<Value> inputs, Function<Value, Integer> mapper) {\n+        StableTestUtil.CountingFunction<Value, Integer> cif = new StableTestUtil.CountingFunction<>(mapper);\n+        var cached = StableValue.function(inputs, cif);\n+        assertEquals(mapper.apply(Value.FORTY_TWO), cached.apply(Value.FORTY_TWO));\n+        assertEquals(1, cif.cnt());\n+        assertEquals(mapper.apply(Value.FORTY_TWO), cached.apply(Value.FORTY_TWO));\n+        assertEquals(1, cif.cnt());\n+        var x0 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_BEFORE));\n+        assertEquals(\"Input not allowed: ILLEGAL_BEFORE\", x0.getMessage());\n+        var x1 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_BETWEEN));\n+        assertEquals(\"Input not allowed: ILLEGAL_BETWEEN\", x1.getMessage());\n+        var x2 = assertThrows(IllegalArgumentException.class, () -> cached.apply(Value.ILLEGAL_AFTER));\n+        assertEquals(\"Input not allowed: ILLEGAL_AFTER\", x2.getMessage());\n+    }\n+\n+    void toStringTest(Set<Value> inputs, Function<Value, Integer> mapper) {\n+        var cached = StableValue.function(inputs, mapper);\n+        cached.apply(Value.FORTY_TWO);\n+        var toString = cached.toString();\n+        assertTrue(toString.startsWith(\"{\"));\n+        \/\/ Key order is unspecified\n+        assertTrue(toString.contains(Value.THIRTEEN + \"=.unset\"));\n+        assertTrue(toString.contains(Value.FORTY_TWO + \"=\" + mapper.apply(Value.FORTY_TWO)));\n+        assertTrue(toString.endsWith(\"}\"));\n+        \/\/ One between the values\n+        assertEquals(1L, toString.chars().filter(ch -> ch == ',').count());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"emptySets\")\n+    void empty(Set<Value> inputs) {\n+        Function<Value, Integer> f0 = StableValue.function(inputs, Value::asInt);\n+        Function<Value, Integer> f1 = StableValue.function(inputs, Value::asInt);\n+        assertEquals(\"{}\", f0.toString());\n+        assertThrows(NullPointerException.class, () -> f0.apply(null));\n+        assertNotEquals(f0, f1);\n+        assertNotEquals(null, f0);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void exception(Set<Value> inputs) {\n+        StableTestUtil.CountingFunction<Value, Integer> cif = new StableTestUtil.CountingFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var cached = StableValue.function(inputs, cif);\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(Value.FORTY_TWO));\n+        assertEquals(1, cif.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(Value.FORTY_TWO));\n+        assertEquals(2, cif.cnt());\n+        var toString = cached.toString();\n+        assertTrue(toString.startsWith(\"{\"));\n+        \/\/ Key order is unspecified\n+        assertTrue(toString.contains(Value.THIRTEEN + \"=.unset\"));\n+        assertTrue(toString.contains(Value.FORTY_TWO + \"=.unset\"));\n+        assertTrue(toString.endsWith(\"}\"));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void circular(Set<Value> inputs) {\n+        final AtomicReference<Function<?, ?>> ref = new AtomicReference<>();\n+        Function<Value, Function<?, ?>> cached = StableValue.function(inputs, _ -> ref.get());\n+        ref.set(cached);\n+        cached.apply(Value.FORTY_TWO);\n+        var toString = cached.toString();\n+        assertTrue(toString.contains(\"FORTY_TWO=(this StableFunction)\"), toString);\n+        assertDoesNotThrow(cached::hashCode);\n+        assertDoesNotThrow((() -> cached.equals(cached)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void equality(Set<Value> inputs) {\n+        Function<Value, Integer> mapper = Value::asInt;\n+        Function<Value, Integer> f0 = StableValue.function(inputs, mapper);\n+        Function<Value, Integer> f1 = StableValue.function(inputs, mapper);\n+        \/\/ No function is equal to another function\n+        assertNotEquals(f0, f1);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"allSets\")\n+    void hashCodeStable(Set<Value> inputs) {\n+        Function<Value, Integer> f0 = StableValue.function(inputs, Value::asInt);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        if (!inputs.isEmpty()) {\n+            f0.apply(Value.FORTY_TWO);\n+            assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        }\n+    }\n+\n+    @Test\n+    void nullKeys() {\n+        Set<Value> inputs = new HashSet<>();\n+        inputs.add(Value.FORTY_TWO);\n+        inputs.add(null);\n+        assertThrows(NullPointerException.class, () -> StableValue.function(inputs, MAPPER));\n+    }\n+\n+    @Test\n+    void usesOptimizedVersion() {\n+        Function<Value, Integer> enumFunction = StableValue.function(EnumSet.of(Value.FORTY_TWO), Value::asInt);\n+        assertEquals(\"jdk.internal.lang.stable.StableEnumFunction\", enumFunction.getClass().getName());\n+        Function<Value, Integer> emptyFunction = StableValue.function(Set.of(), Value::asInt);\n+        assertEquals(\"jdk.internal.lang.stable.StableFunction\", emptyFunction.getClass().getName());\n+    }\n+\n+    private static Stream<Set<Value>> nonEmptySets() {\n+        return Stream.of(\n+                Set.of(Value.FORTY_TWO, Value.THIRTEEN),\n+                linkedHashSet(Value.THIRTEEN, Value.FORTY_TWO),\n+                treeSet(Value.FORTY_TWO, Value.THIRTEEN),\n+                EnumSet.of(Value.FORTY_TWO, Value.THIRTEEN)\n+        );\n+    }\n+\n+    private static Stream<Set<Value>> emptySets() {\n+        return Stream.of(\n+                Set.of(),\n+                linkedHashSet(),\n+                treeSet(),\n+                EnumSet.noneOf(Value.class)\n+        );\n+    }\n+\n+    private static Stream<Set<Value>> allSets() {\n+        return Stream.concat(\n+                nonEmptySets(),\n+                emptySets()\n+        );\n+    }\n+\n+    static Set<Value> treeSet(Value... values) {\n+        return populate(new TreeSet<>(Comparator.comparingInt(Value::asInt).reversed()),values);\n+    }\n+\n+    static Set<Value> linkedHashSet(Value... values) {\n+        return populate(new LinkedHashSet<>(), values);\n+    }\n+\n+    static Set<Value> populate(Set<Value> set, Value... values) {\n+        set.addAll(Arrays.asList(values));\n+        return set;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFunctionTest.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableIntFunction methods\n+ * @enablePreview\n+ * @run junit StableIntFunctionTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.IntFunction;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableIntFunctionTest {\n+\n+    private static final int SIZE = 2;\n+    private static final IntFunction<Integer> MAPPER = i -> i;\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(IllegalArgumentException.class, () -> StableValue.intFunction(-1, MAPPER));\n+        assertThrows(NullPointerException.class, () -> StableValue.intFunction(SIZE, null));\n+    }\n+\n+    @Test\n+    void basic() {\n+        basic(MAPPER);\n+        basic(i -> null);\n+    }\n+\n+    void basic(IntFunction<Integer> mapper) {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(mapper);\n+        var cached = StableValue.intFunction(SIZE, cif);\n+        assertEquals(\"[.unset, .unset]\", cached.toString());\n+        assertEquals(mapper.apply(1), cached.apply(1));\n+        assertEquals(1, cif.cnt());\n+        assertEquals(mapper.apply(1), cached.apply(1));\n+        assertEquals(1, cif.cnt());\n+        assertEquals(\"[.unset, \" + mapper.apply(1) + \"]\", cached.toString());\n+        assertThrows(IllegalArgumentException.class, () -> cached.apply(SIZE));\n+        assertThrows(IllegalArgumentException.class, () -> cached.apply(-1));\n+        assertThrows(IllegalArgumentException.class, () -> cached.apply(1_000_000));\n+    }\n+\n+    @Test\n+    void exception() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var cached = StableValue.intFunction(SIZE, cif);\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(1));\n+        assertEquals(1, cif.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> cached.apply(1));\n+        assertEquals(2, cif.cnt());\n+        assertEquals(\"[.unset, .unset]\", cached.toString());\n+    }\n+\n+    @Test\n+    void circular() {\n+        final AtomicReference<IntFunction<?>> ref = new AtomicReference<>();\n+        IntFunction<IntFunction<?>> cached = StableValue.intFunction(SIZE, _ -> ref.get());\n+        ref.set(cached);\n+        cached.apply(0);\n+        String toString = cached.toString();\n+        assertEquals(\"[(this StableIntFunction), .unset]\", toString);\n+        assertDoesNotThrow(cached::hashCode);\n+        assertDoesNotThrow((() -> cached.equals(cached)));\n+    }\n+\n+    @Test\n+    void equality() {\n+        IntFunction<Integer> f0 = StableValue.intFunction(8, MAPPER);\n+        IntFunction<Integer> f1 = StableValue.intFunction(8, MAPPER);\n+        \/\/ No function is equal to another function\n+        assertNotEquals(f0, f1);\n+    }\n+\n+    @Test\n+    void hashCodeStable() {\n+        IntFunction<Integer> f0 = StableValue.intFunction(8, MAPPER);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        f0.apply(4);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableIntFunctionTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,436 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableList methods\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @enablePreview\n+ * @run junit StableListTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.RandomAccess;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.IntFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableListTest {\n+\n+    private static final int ZERO = 0;\n+    private static final int INDEX = 7;\n+    private static final int SIZE = 31;\n+    private static final IntFunction<Integer> IDENTITY = i -> i;\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(NullPointerException.class, () -> StableValue.list(SIZE, null));\n+        assertThrows(IllegalArgumentException.class, () -> StableValue.list(-1, IDENTITY));\n+    }\n+\n+    @Test\n+    void isEmpty() {\n+        assertFalse(newList().isEmpty());\n+        assertTrue(newEmptyList().isEmpty());\n+    }\n+\n+    @Test\n+    void size() {\n+        assertEquals(SIZE, newList().size());\n+        assertEquals(ZERO, newEmptyList().size());\n+    }\n+\n+    @Test\n+    void get() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(IDENTITY);\n+        var lazy = StableValue.list(SIZE, cif);\n+        for (int i = 0; i < SIZE; i++) {\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(i + 1, cif.cnt());\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(i + 1, cif.cnt());\n+        }\n+    }\n+\n+    @Test\n+    void getException() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var lazy = StableValue.list(SIZE, cif);\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(INDEX));\n+        assertEquals(1, cif.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(INDEX));\n+        assertEquals(2, cif.cnt());\n+    }\n+\n+    @Test\n+    void toArray() {\n+        assertArrayEquals(new Object[ZERO], newEmptyList().toArray());\n+        assertArrayEquals(newRegularList().toArray(), newList().toArray());\n+    }\n+\n+    @Test\n+    void toArrayWithArrayLarger() {\n+        Integer[] actual = new Integer[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            actual[INDEX] = 100 + i;\n+        }\n+        var list = StableValue.list(INDEX, IDENTITY);\n+        assertSame(actual, list.toArray(actual));\n+        Integer[] expected = IntStream.range(0, SIZE)\n+                .mapToObj(i -> i < INDEX ? i : null)\n+                .toArray(Integer[]::new);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void toArrayWithArraySmaller() {\n+        Integer[] arr = new Integer[INDEX];\n+        Integer[] actual = newList().toArray(arr);\n+        assertNotSame(arr, actual);\n+        Integer[] expected = newRegularList().toArray(new Integer[0]);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void toArrayWithGenerator() {\n+        Integer[] expected = newRegularList().toArray(Integer[]::new);\n+        Integer[] actual = newList().toArray(Integer[]::new);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void firstIndex() {\n+        var lazy = newList();\n+        for (int i = INDEX; i < SIZE; i++) {\n+            assertEquals(i, lazy.indexOf(i));\n+        }\n+        assertEquals(-1, lazy.indexOf(SIZE + 1));\n+    }\n+\n+    @Test\n+    void lastIndex() {\n+        var lazy = newList();\n+        for (int i = INDEX; i < SIZE; i++) {\n+            assertEquals(i, lazy.lastIndexOf(i));\n+        }\n+        assertEquals(-1, lazy.lastIndexOf(SIZE + 1));\n+    }\n+\n+    @Test\n+    void toStringTest() {\n+        assertEquals(\"[]\", newEmptyList().toString());\n+        var list = StableValue.list(2, IDENTITY);\n+        assertEquals(\"[.unset, .unset]\", list.toString());\n+        list.get(0);\n+        assertEquals(\"[0, .unset]\", list.toString());\n+        list.get(1);\n+        assertEquals(\"[0, 1]\", list.toString());\n+    }\n+\n+    @Test\n+    void hashCodeTest() {\n+        assertEquals(List.of().hashCode(), newEmptyList().hashCode());\n+        assertEquals(newRegularList().hashCode(), newList().hashCode());\n+    }\n+\n+    @Test\n+    void equalsTest() {\n+        assertTrue(newEmptyList().equals(List.of()));\n+        assertTrue(List.of().equals(newEmptyList()));\n+        assertTrue(newList().equals(newRegularList()));\n+        assertTrue(newRegularList().equals(newList()));\n+        assertFalse(newList().equals(\"A\"));\n+    }\n+\n+    @Test\n+    void equalsPartialEvaluationTest() {\n+        var list = StableValue.list(2, IDENTITY);\n+        assertFalse(list.equals(List.of(0)));\n+        assertEquals(\"[0, .unset]\", list.toString());\n+        assertTrue(list.equals(List.of(0, 1)));\n+        assertEquals(\"[0, 1]\", list.toString());\n+    }\n+\n+    @Test\n+    void iteratorTotal() {\n+        var iterator = newList().iterator();\n+        for (int i = 0; i < SIZE; i++) {\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertEquals(i, iterator.next());\n+        }\n+        assertFalse(iterator.hasNext());\n+        assertThrows(NoSuchElementException.class, iterator::next);\n+        AtomicInteger cnt = new AtomicInteger();\n+        iterator.forEachRemaining(_ -> cnt.incrementAndGet());\n+        assertEquals(0, cnt.get());\n+    }\n+\n+    @Test\n+    void iteratorPartial() {\n+        var iterator = newList().iterator();\n+        for (int i = 0; i < INDEX; i++) {\n+            assertTrue(iterator.hasNext());\n+            assertTrue(iterator.hasNext());\n+            assertEquals(i, iterator.next());\n+        }\n+        assertTrue(iterator.hasNext());\n+        AtomicInteger cnt = new AtomicInteger();\n+        iterator.forEachRemaining(_ -> cnt.incrementAndGet());\n+        assertEquals(SIZE - INDEX, cnt.get());\n+        assertFalse(iterator.hasNext());\n+        assertThrows(NoSuchElementException.class, iterator::next);\n+    }\n+\n+    @Test\n+    void subList() {\n+        var lazy = newList();\n+        var lazySubList = lazy.subList(1, SIZE);\n+        assertInstanceOf(RandomAccess.class, lazySubList);\n+        var regularList = newRegularList();\n+        var regularSubList = regularList.subList(1, SIZE);\n+        assertEquals(regularSubList, lazySubList);\n+    }\n+\n+    @Test\n+    void subList2() {\n+        var lazy = newList();\n+        var lazySubList = lazy.subList(1, SIZE);\n+        lazySubList.get(0);\n+        var eq = newList();\n+        eq.get(1);\n+        assertEquals(eq.toString(), lazy.toString());\n+    }\n+\n+    @Test\n+    void subListToString() {\n+        subListToString0(newList());\n+        subListToString0(newList().subList(1, SIZE));\n+        subListToString0(newList().subList(1, SIZE).subList(0, SIZE - 2));\n+    }\n+\n+    void subListToString0(List<Integer> subList) {\n+        assertEquals(asString(\".unset\", subList), subList.toString());\n+\n+        var first = subList.getFirst();\n+        assertEquals(asString(first.toString(), subList), subList.toString());\n+    }\n+\n+    @Test\n+    void reversed() {\n+        var reversed = newList().reversed();\n+        assertInstanceOf(RandomAccess.class, reversed);\n+        assertEquals(SIZE - 1, reversed.getFirst());\n+        assertEquals(0, reversed.getLast());\n+\n+        var reversed2 = reversed.reversed();\n+        assertInstanceOf(RandomAccess.class, reversed2);\n+        assertEquals(0, reversed2.getFirst());\n+        assertEquals(SIZE - 1, reversed2.getLast());\n+        \/\/ Make sure we get back a non-reversed implementation\n+        assertEquals(\"java.util.ImmutableCollections$StableList\", reversed2.getClass().getName());\n+    }\n+\n+    @Test\n+    void reversedToString() {\n+        var reversed = newList().reversed();\n+        subListToString0(reversed);\n+    }\n+\n+    @Test\n+    void subListReversedToString() {\n+        var list = newList().subList(1, SIZE - 1).reversed();\n+        \/\/ This combination is not lazy. There has to be a limit somewhere.\n+        var regularList = newRegularList().subList(1, SIZE - 1).reversed();\n+        assertEquals(regularList.toString(), list.toString());\n+    }\n+\n+    @Test\n+    void recursiveCall() {\n+        AtomicReference<IntFunction<Integer>> ref = new AtomicReference<>();\n+        var lazy = StableValue.list(SIZE, i -> ref.get().apply(i));\n+        ref.set(lazy::get);\n+        var x = assertThrows(IllegalStateException.class, () -> lazy.get(INDEX));\n+        assertEquals(\"Recursive initialization of a stable value is illegal\", x.getMessage());\n+    }\n+\n+    \/\/ Immutability\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unsupportedOperations\")\n+    void unsupported(Operation operation) {\n+        assertThrowsForOperation(UnsupportedOperationException.class, operation);\n+    }\n+\n+    \/\/ Method parameter invariant checking\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullAverseOperations\")\n+    void nullAverse(Operation operation) {\n+        assertThrowsForOperation(NullPointerException.class, operation);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"outOfBoundsOperations\")\n+    void outOfBounds(Operation operation) {\n+        assertThrowsForOperation(IndexOutOfBoundsException.class, operation);\n+    }\n+\n+    static <T extends Throwable> void assertThrowsForOperation(Class<T> expectedType, Operation operation) {\n+        var lazy = newList();\n+        assertThrows(expectedType, () -> operation.accept(lazy));\n+        var sub = lazy.subList(1, SIZE \/ 2);\n+        assertThrows(expectedType, () -> operation.accept(sub));\n+        var subSub = sub.subList(1, sub.size() \/ 2);\n+        assertThrows(expectedType, () -> operation.accept(subSub));\n+    }\n+\n+    \/\/ Implementing interfaces\n+\n+    @Test\n+    void serializable() {\n+        serializable(newList());\n+        serializable(newEmptyList());\n+    }\n+\n+    void serializable(List<Integer> list) {\n+        assertFalse(list instanceof Serializable);\n+        if (list.size()>INDEX) {\n+            assertFalse(newList().subList(1, INDEX) instanceof Serializable);\n+        }\n+        assertFalse(list.iterator() instanceof Serializable);\n+        assertFalse(list.reversed() instanceof Serializable);\n+        assertFalse(list.spliterator() instanceof Serializable);\n+    }\n+\n+    @Test\n+    void randomAccess() {\n+        assertInstanceOf(RandomAccess.class, newList());\n+        assertInstanceOf(RandomAccess.class, newEmptyList());\n+        assertInstanceOf(RandomAccess.class, newList().subList(1, INDEX));\n+    }\n+\n+    @Test\n+    void distinct() {\n+        StableValueImpl<Integer>[] array = StableUtil.array(SIZE);\n+        assertEquals(SIZE, array.length);\n+        \/\/ Check, every StableValue is distinct\n+        Map<StableValue<Integer>, Boolean> idMap = new IdentityHashMap<>();\n+        for (var e: array) {\n+            idMap.put(e, true);\n+        }\n+        assertEquals(SIZE, idMap.size());\n+    }\n+\n+    \/\/ Support constructs\n+\n+    record Operation(String name,\n+                     Consumer<List<Integer>> consumer) implements Consumer<List<Integer>> {\n+        @Override public void   accept(List<Integer> list) { consumer.accept(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    static Stream<Operation> nullAverseOperations() {\n+        return Stream.of(\n+                new Operation(\"forEach\",     l -> l.forEach(null)),\n+                new Operation(\"containsAll\", l -> l.containsAll(null)),\n+                new Operation(\"toArray\",     l -> l.toArray((Integer[]) null)),\n+                new Operation(\"toArray\",     l -> l.toArray((IntFunction<Integer[]>) null))\n+        );\n+    }\n+\n+    static Stream<Operation> outOfBoundsOperations() {\n+        return Stream.of(\n+                new Operation(\"get(-1)\",        l -> l.get(-1)),\n+                new Operation(\"get(size)\",      l -> l.get(l.size())),\n+                new Operation(\"sublist(-1,)\",   l -> l.subList(-1, INDEX)),\n+                new Operation(\"sublist(,size)\", l -> l.subList(0, l.size() + 1)),\n+                new Operation(\"listIter(-1)\",   l -> l.listIterator(-1)),\n+                new Operation(\"listIter(size)\", l -> l.listIterator(l.size() + 1))\n+        );\n+    }\n+\n+    static Stream<Operation> unsupportedOperations() {\n+        final Set<Integer> SET = Set.of(0, 1);\n+        return Stream.of(\n+                new Operation(\"add(0)\",            l -> l.add(0)),\n+                new Operation(\"add(0, 1)\",         l -> l.add(0, 1)),\n+                new Operation(\"addAll(col)\",       l -> l.addAll(SET)),\n+                new Operation(\"addAll(1, coll)\",   l -> l.addAll(1, SET)),\n+                new Operation(\"addFirst(0)\",       l -> l.addFirst(0)),\n+                new Operation(\"addLast(0)\",        l -> l.addLast(0)),\n+                new Operation(\"clear\",             List::clear),\n+                new Operation(\"remove(Obj)\",       l -> l.remove((Object)1)),\n+                new Operation(\"remove(1)\",         l -> l.remove(1)),\n+                new Operation(\"removeAll\",         l -> l.removeAll(SET)),\n+                new Operation(\"removeFirst\",       List::removeFirst),\n+                new Operation(\"removeLast\",        List::removeLast),\n+                new Operation(\"removeIf\",          l -> l.removeIf(i -> i % 2 == 0)),\n+                new Operation(\"replaceAll\",        l -> l.replaceAll(i -> i + 1)),\n+                new Operation(\"sort\",              l -> l.sort(Comparator.naturalOrder())),\n+                new Operation(\"iterator().remove\", l -> l.iterator().remove()),\n+                new Operation(\"listIter().remove\", l -> l.listIterator().remove()),\n+                new Operation(\"listIter().add\",    l -> l.listIterator().add(1)),\n+                new Operation(\"listIter().set\",    l -> l.listIterator().set(1))\n+        );\n+    }\n+\n+    static List<Integer> newList() {\n+        return StableValue.list(SIZE, IDENTITY);\n+    }\n+\n+    static List<Integer> newEmptyList() {\n+        return StableValue.list(ZERO, IDENTITY);\n+    }\n+\n+    static List<Integer> newRegularList() {\n+        return IntStream.range(0, SIZE).boxed().toList();\n+    }\n+\n+    static String asString(String first, List<Integer> list) {\n+        return \"[\" + first + \", \" + Stream.generate(() -> \".unset\")\n+                .limit(list.size() - 1)\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":436,"deletions":0,"binary":false,"changes":436,"status":"added"},{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableMap methods\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @enablePreview\n+ * @run junit StableMapTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableUtil;\n+import jdk.internal.lang.stable.StableValueImpl;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.Serializable;\n+import java.util.AbstractMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableMapTest {\n+\n+    private static final int NOT_PRESENT = 147;\n+    private static final int KEY = 7;\n+    private static final Set<Integer> KEYS = Set.of(0, KEY, 13);\n+    private static final Set<Integer> EMPTY = Set.of();\n+    private static final Function<Integer, Integer> IDENTITY = Function.identity();\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(NullPointerException.class, () -> StableValue.map(KEYS, null));\n+        assertThrows(NullPointerException.class, () -> StableValue.map(null, IDENTITY));\n+    }\n+\n+    @Test\n+    void isEmpty() {\n+        assertFalse(newMap().isEmpty());\n+        assertTrue(newEmptyMap().isEmpty());\n+    }\n+\n+    @Test\n+    void size() {\n+        assertEquals(KEYS.size(), newMap().size());\n+        assertEquals(EMPTY.size(), newEmptyMap().size());\n+    }\n+\n+    @Test\n+    void get() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cf = new StableTestUtil.CountingFunction<>(IDENTITY);\n+        var lazy = StableValue.map(KEYS, cf);\n+        int cnt = 1;\n+        for (int i : KEYS) {\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(cnt, cf.cnt());\n+            assertEquals(i, lazy.get(i));\n+            assertEquals(cnt++, cf.cnt());\n+        }\n+        assertNull(lazy.get(NOT_PRESENT));\n+    }\n+\n+    @Test\n+    void getException() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cf = new StableTestUtil.CountingFunction<>(_ -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var lazy = StableValue.map(KEYS, cf);\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(KEY));\n+        assertEquals(1, cf.cnt());\n+        assertThrows(UnsupportedOperationException.class, () -> lazy.get(KEY));\n+        assertEquals(2, cf.cnt());\n+    }\n+\n+    @Test\n+    void containsKey() {\n+        var lazy = newMap();\n+        for (int i : KEYS) {\n+            assertTrue(lazy.containsKey(i));\n+        }\n+        assertFalse(lazy.containsKey(NOT_PRESENT));\n+    }\n+\n+    @Test\n+    void containsValue() {\n+        var lazy = newMap();\n+        for (int i : KEYS) {\n+            assertTrue(lazy.containsValue(i));\n+        }\n+        assertFalse(lazy.containsValue(NOT_PRESENT));\n+    }\n+\n+    @Test\n+    void forEach() {\n+        var lazy = newMap();\n+        Set<Map.Entry<Integer, Integer>> expected = KEYS.stream()\n+                .map(i -> new AbstractMap.SimpleImmutableEntry<>(i , i))\n+                .collect(Collectors.toSet());\n+        Set<Map.Entry<Integer, Integer>> actual = new HashSet<>();\n+        lazy.forEach((k, v) -> actual.add(new AbstractMap.SimpleImmutableEntry<>(k , v)));\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    void toStringTest() {\n+        assertEquals(\"{}\", newEmptyMap().toString());\n+        var map = StableValue.map(Set.of(KEY), IDENTITY);\n+        assertEquals(\"{\" + KEY + \"=.unset}\", map.toString());\n+        map.get(KEY);\n+        assertEquals(\"{\" + KEY + \"=\" + KEY + \"}\", map.toString());\n+        String actual = newMap().toString();\n+        assertTrue(actual.startsWith(\"{\"));\n+        for (int key : KEYS) {\n+            assertTrue(actual.contains(key + \"=.unset\"));\n+        }\n+        assertTrue(actual.endsWith(\"}\"));\n+    }\n+\n+    @Test\n+    void hashCodeTest() {\n+        assertEquals(Map.of().hashCode(), newEmptyMap().hashCode());\n+        assertEquals(newRegularMap().hashCode(), newMap().hashCode());\n+    }\n+\n+    @Test\n+    void equalsTest() {\n+        assertTrue(newEmptyMap().equals(Map.of()));\n+        assertTrue(Map.of().equals(newEmptyMap()));\n+        assertTrue(newMap().equals(newRegularMap()));\n+        assertTrue(newRegularMap().equals(newMap()));\n+        assertFalse(newMap().equals(\"A\"));\n+    }\n+\n+    @Test\n+    void entrySet() {\n+        var regular = newRegularMap().entrySet();\n+        var actual = newMap().entrySet();\n+        assertTrue(regular.equals(actual));\n+        assertTrue(actual.equals(regular));\n+        assertTrue(regular.equals(actual));\n+    }\n+\n+    @Test\n+    void entrySetToString() {\n+        var map = newMap();\n+        var entrySet = map.entrySet();\n+        var toString = entrySet.toString();\n+        for (var key : KEYS) {\n+            assertTrue(toString.contains(key + \"=.unset\"));\n+        }\n+        assertTrue(toString.startsWith(\"[\"));\n+        assertTrue(toString.endsWith(\"]\"));\n+\n+        map.get(KEY);\n+        for (var key : KEYS) {\n+            if (key.equals(KEY)) {\n+                continue;\n+            }\n+            assertTrue(entrySet.toString().contains(key + \"=.unset\"));\n+        }\n+        assertTrue(entrySet.toString().contains(KEY + \"=\" + KEY));\n+    }\n+\n+    @Test\n+    void values() {\n+        var map = newMap();\n+        var values = map.values();\n+        \/\/ Look at one of the elements\n+        var val = values.stream().iterator().next();\n+        var toString = map.toString();\n+        for (var key : KEYS) {\n+            if (key.equals(val)) {\n+                assertTrue(toString.contains(key + \"=\" + key));\n+            } else {\n+                assertTrue(toString.contains(key + \"=.unset\"));\n+            }\n+        }\n+\n+        \/\/ Mod ops\n+        assertThrows(UnsupportedOperationException.class, () -> values.remove(KEY));\n+        assertThrows(UnsupportedOperationException.class, () -> values.add(KEY));\n+        assertThrows(UnsupportedOperationException.class, values::clear);\n+        assertThrows(UnsupportedOperationException.class, () -> values.addAll(Set.of(1)));\n+        assertThrows(UnsupportedOperationException.class, () -> values.removeIf(i -> true));\n+        assertThrows(UnsupportedOperationException.class, () -> values.retainAll(Set.of(KEY)));\n+    }\n+\n+    @Test\n+    void valuesToString() {\n+        var map = newMap();\n+        var values = map.values();\n+        assertEquals(\"[.unset, .unset, .unset]\", values.toString());\n+        map.get(KEY);\n+        var afterGet = values.toString();\n+        assertTrue(afterGet.contains(Integer.toString(KEY)), afterGet);\n+    }\n+\n+    @Test\n+    void iteratorNext() {\n+        Set<Integer> encountered = new HashSet<>();\n+        var iterator = newMap().entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            var entry = iterator.next();\n+            assertEquals(entry.getKey(), entry.getValue());\n+            encountered.add(entry.getValue());\n+        }\n+        assertEquals(KEYS, encountered);\n+    }\n+\n+    @Test\n+    void iteratorForEachRemaining() {\n+        Set<Integer> encountered = new HashSet<>();\n+        var iterator = newMap().entrySet().iterator();\n+        var entry = iterator.next();\n+        assertEquals(entry.getKey(), entry.getValue());\n+        encountered.add(entry.getValue());\n+        iterator.forEachRemaining(e -> {\n+            assertEquals(e.getKey(), e.getValue());\n+            encountered.add(e.getValue());\n+        });\n+        assertEquals(KEYS, encountered);\n+    }\n+\n+    \/\/ Immutability\n+    @ParameterizedTest\n+    @MethodSource(\"unsupportedOperations\")\n+    void unsupported(Operation operation) {\n+        assertThrowsForOperation(UnsupportedOperationException.class, operation);\n+    }\n+\n+    \/\/ Method parameter invariant checking\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullAverseOperations\")\n+    void nullAverse(Operation operation) {\n+        assertThrowsForOperation(NullPointerException.class, operation);\n+    }\n+\n+    static <T extends Throwable> void assertThrowsForOperation(Class<T> expectedType, Operation operation) {\n+        var lazy = newMap();\n+        assertThrows(expectedType, () -> operation.accept(lazy));\n+    }\n+\n+    \/\/ Implementing interfaces\n+\n+    @Test\n+    void serializable() {\n+        serializable(newMap());\n+        serializable(newEmptyMap());\n+    }\n+\n+    void serializable(Map<Integer, Integer> map) {\n+        assertFalse(map instanceof Serializable);\n+        assertFalse(map.entrySet() instanceof Serializable);\n+        assertFalse(map.keySet() instanceof Serializable);\n+        assertFalse(map.values() instanceof Serializable);\n+    }\n+\n+    @Test\n+    void distinct() {\n+        Map<Integer, StableValueImpl<Integer>> map = StableUtil.map(Set.of(1, 2, 3));\n+        assertEquals(3, map.size());\n+        \/\/ Check, every StableValue is distinct\n+        Map<StableValue<Integer>, Boolean> idMap = new IdentityHashMap<>();\n+        map.forEach((k, v) -> idMap.put(v, true));\n+        assertEquals(3, idMap.size());\n+    }\n+\n+    @Test\n+    void nullResult() {\n+        var map = StableValue.map(Set.of(0), _ -> null);\n+        assertNull(map.getOrDefault(0, 1));;\n+        assertTrue(map.containsKey(0));\n+        assertNull(map.get(0));\n+    }\n+\n+    @Test\n+    void nullKeys() {\n+        Set<Integer> inputs = new HashSet<>();\n+        inputs.add(0);\n+        inputs.add(null);\n+        assertThrows(NullPointerException.class, () -> StableValue.map(inputs, IDENTITY));\n+    }\n+\n+    \/\/ Support constructs\n+\n+    record Operation(String name,\n+                     Consumer<Map<Integer, Integer>> consumer) implements Consumer<Map<Integer, Integer>> {\n+        @java.lang.Override\n+        public void accept(Map<Integer, Integer> map) { consumer.accept(map); }\n+        @java.lang.Override\n+        public String toString() { return name; }\n+    }\n+\n+    static Stream<Operation> nullAverseOperations() {\n+        return Stream.of(\n+            new Operation(\"forEach\",     m -> m.forEach(null))\n+        );\n+    }\n+\n+    static Stream<Operation> unsupportedOperations() {\n+        return Stream.of(\n+            new Operation(\"clear\",             Map::clear),\n+            new Operation(\"compute\",           m -> m.compute(KEY, (_, _) -> 1)),\n+            new Operation(\"computeIfAbsent\",   m -> m.computeIfAbsent(KEY, _ -> 1)),\n+            new Operation(\"computeIfPresent\",  m -> m.computeIfPresent(KEY, (_, _) -> 1)),\n+            new Operation(\"merge\",             m -> m.merge(KEY, KEY, (a, _) -> a)),\n+            new Operation(\"put\",               m -> m.put(0, 0)),\n+            new Operation(\"putAll\",            m -> m.putAll(Map.of())),\n+            new Operation(\"remove1\",           m -> m.remove(KEY)),\n+            new Operation(\"remove2\",           m -> m.remove(KEY, KEY)),\n+            new Operation(\"replace2\",          m -> m.replace(KEY, 1)),\n+            new Operation(\"replace3\",          m -> m.replace(KEY, KEY, 1)),\n+            new Operation(\"replaceAll\",        m -> m.replaceAll((a, _) -> a))\n+        );\n+    }\n+\n+    static Map<Integer, Integer> newMap() {\n+        return StableValue.map(KEYS, IDENTITY);\n+    }\n+\n+    static Map<Integer, Integer> newEmptyMap() {\n+        return StableValue.map(EMPTY, IDENTITY);\n+    }\n+\n+    static Map<Integer, Integer> newRegularMap() {\n+        return KEYS.stream().collect(Collectors.toMap(IDENTITY, IDENTITY));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableMapTest.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableSupplier methods\n+ * @enablePreview\n+ * @run junit StableSupplierTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableSupplierTest {\n+\n+    private static final Supplier<Integer> SUPPLIER = () -> 42;\n+\n+    @Test\n+    void factoryInvariants() {\n+        assertThrows(NullPointerException.class, () -> StableValue.supplier(null));\n+    }\n+\n+    @Test\n+    void basic() {\n+        basic(SUPPLIER);\n+        basic(() -> null);\n+    }\n+\n+    void basic(Supplier<Integer> supplier) {\n+        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(supplier);\n+        var cached = StableValue.supplier(cs);\n+        assertEquals(\".unset\", cached.toString());\n+        assertEquals(supplier.get(), cached.get());\n+        assertEquals(1, cs.cnt());\n+        assertEquals(supplier.get(), cached.get());\n+        assertEquals(1, cs.cnt());\n+        assertEquals(Objects.toString(supplier.get()), cached.toString());\n+    }\n+\n+    @Test\n+    void exception() {\n+        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(() -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var cached = StableValue.supplier(cs);\n+        assertThrows(UnsupportedOperationException.class, cached::get);\n+        assertEquals(1, cs.cnt());\n+        assertThrows(UnsupportedOperationException.class, cached::get);\n+        assertEquals(2, cs.cnt());\n+        assertEquals(\".unset\", cached.toString());\n+    }\n+\n+    @Test\n+    void circular() {\n+        final AtomicReference<Supplier<?>> ref = new AtomicReference<>();\n+        Supplier<Supplier<?>> cached = StableValue.supplier(ref::get);\n+        ref.set(cached);\n+        cached.get();\n+        String toString = cached.toString();\n+        assertTrue(toString.startsWith(\"(this StableSupplier)\"));\n+        assertDoesNotThrow(cached::hashCode);\n+    }\n+\n+    @Test\n+    void equality() {\n+        Supplier<Integer> f0 = StableValue.supplier(SUPPLIER);\n+        Supplier<Integer> f1 = StableValue.supplier(SUPPLIER);\n+        \/\/ No function is equal to another function\n+        assertNotEquals(f0, f1);\n+    }\n+\n+    @Test\n+    void hashCodeStable() {\n+        Supplier<Integer> f0 = StableValue.supplier(SUPPLIER);\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+        f0.get();\n+        assertEquals(System.identityHashCode(f0), f0.hashCode());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableSupplierTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+final class StableTestUtil {\n+\n+    private StableTestUtil() {}\n+\n+    public static final class CountingSupplier<T>\n+            extends AbstractCounting<Supplier<T>>\n+            implements Supplier<T> {\n+\n+        public CountingSupplier(Supplier<T> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public T get() {\n+            incrementCounter();\n+            return delegate.get();\n+        }\n+\n+    }\n+\n+    public static final class CountingIntFunction<R>\n+            extends AbstractCounting<IntFunction<R>>\n+            implements IntFunction<R> {\n+\n+        public CountingIntFunction(IntFunction<R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(int value) {\n+            incrementCounter();\n+            return delegate.apply(value);\n+        }\n+\n+    }\n+\n+    public static final class CountingFunction<T, R>\n+            extends AbstractCounting<Function<T, R>>\n+            implements Function<T, R> {\n+\n+        public CountingFunction(Function<T, R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(T t) {\n+            incrementCounter();\n+            return delegate.apply(t);\n+        }\n+\n+    }\n+\n+    public static final class CountingBiFunction<T, U, R>\n+            extends AbstractCounting<BiFunction<T, U, R>>\n+            implements BiFunction<T, U, R> {\n+\n+        public CountingBiFunction(BiFunction<T, U, R> delegate) {\n+            super(delegate);\n+        }\n+\n+        @Override\n+        public R apply(T t, U u) {\n+            incrementCounter();\n+            return delegate.apply(t, u);\n+        }\n+    }\n+\n+    abstract static class AbstractCounting<D> {\n+\n+        private final AtomicInteger cnt = new AtomicInteger();\n+        protected final D delegate;\n+\n+        protected AbstractCounting(D delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        protected final void incrementCounter() {\n+            cnt.incrementAndGet();\n+        }\n+\n+        public final int cnt() {\n+            return cnt.get();\n+        }\n+\n+        @Override\n+        public final String toString() {\n+            return cnt.toString();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableTestUtil.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableValue factory implementations\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @enablePreview\n+ * @run junit StableValueFactoriesTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableUtil;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableValueFactoriesTest {\n+\n+    @Test\n+    void array() {\n+        assertThrows(IllegalArgumentException.class, () -> StableUtil.array(-1));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueFactoriesTest.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,389 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableValue implementations\n+ * @enablePreview\n+ * @run junit StableValueTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.IntStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+final class StableValueTest {\n+\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 13;\n+\n+    @Test\n+    void trySet() {\n+        trySet(VALUE);\n+        trySet(null);\n+    }\n+\n+    @Test\n+    void preSet() {\n+        StableValue<Integer> stable = StableValue.of(VALUE);\n+        assertTrue(stable.isSet());\n+        assertEquals(VALUE, stable.orElseThrow());\n+        assertEquals(VALUE, stable.orElse(VALUE2));\n+        assertEquals(VALUE, stable.orElseSet(() -> VALUE2));\n+        assertFalse(stable.trySet(VALUE2));\n+        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(VALUE2));\n+        assertEquals(\n+                \"The contents is already set\",\n+                e.getMessage());\n+    }\n+\n+    void trySet(Integer initial) {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertTrue(stable.trySet(initial));\n+        assertFalse(stable.trySet(null));\n+        assertFalse(stable.trySet(VALUE));\n+        assertFalse(stable.trySet(VALUE2));\n+        assertEquals(initial, stable.orElseThrow());\n+    }\n+\n+    @Test\n+    void setOrThrowValue() {\n+        StableValue<Integer> stable = StableValue.of();\n+        stable.setOrThrow(VALUE);\n+        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(VALUE2));\n+        assertEquals(\"The contents is already set\", e.getMessage());\n+    }\n+\n+    @Test\n+    void setOrThrowNull() {\n+        StableValue<Integer> stable = StableValue.of();\n+        stable.setOrThrow(null);\n+        var e = assertThrows(IllegalStateException.class, () -> stable.setOrThrow(null));\n+        assertEquals(\"The contents is already set\", e.getMessage());\n+    }\n+\n+    @Test\n+    void orElse() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertEquals(VALUE, stable.orElse(VALUE));\n+        assertNull(stable.orElse(null));\n+        stable.trySet(VALUE);\n+        assertEquals(VALUE, stable.orElse(VALUE2));\n+    }\n+\n+    @Test\n+    void orElseThrow() {\n+        StableValue<Integer> stable = StableValue.of();\n+        var e = assertThrows(NoSuchElementException.class, stable::orElseThrow);\n+        assertEquals(\"No contents set\", e.getMessage());\n+        stable.trySet(VALUE);\n+        assertEquals(VALUE, stable.orElseThrow());\n+    }\n+\n+    @Test\n+    void isSet() {\n+        isSet(VALUE);\n+        isSet(null);\n+   }\n+\n+    void isSet(Integer initial) {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertFalse(stable.isSet());\n+        stable.trySet(initial);\n+        assertTrue(stable.isSet());\n+    }\n+\n+   @Test\n+   void testOrElseSetSupplier() {\n+       StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(() -> VALUE);\n+       StableValue<Integer> stable = StableValue.of();\n+       assertThrows(NullPointerException.class, () -> stable.orElseSet(null));\n+       assertEquals(VALUE, stable.orElseSet(cs));\n+       assertEquals(1, cs.cnt());\n+       assertEquals(VALUE, stable.orElseSet(cs));\n+       assertEquals(1, cs.cnt());\n+   }\n+\n+    @Test\n+    void testHashCode() {\n+        StableValue<Integer> stableValue = StableValue.of();\n+        \/\/ Should be Object::hashCode\n+        assertEquals(System.identityHashCode(stableValue), stableValue.hashCode());\n+    }\n+\n+    @Test\n+    void testEquals() {\n+        StableValue<Integer> s0 = StableValue.of();\n+        assertNotEquals(null, s0);\n+        StableValue<Integer> s1 = StableValue.of();\n+        assertNotEquals(s0, s1); \/\/ Identity based\n+        s0.setOrThrow(42);\n+        s1.setOrThrow(42);\n+        assertNotEquals(s0, s1);\n+        assertNotEquals(\"a\", s0);\n+        StableValue<Integer> null0 = StableValue.of();\n+        StableValue<Integer> null1 = StableValue.of();\n+        null0.setOrThrow(null);\n+        null1.setOrThrow(null);\n+        assertNotEquals(null0, null1);\n+    }\n+\n+    @Test\n+    void toStringUnset() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertEquals(\".unset\", stable.toString());\n+    }\n+\n+    @Test\n+    void toStringNull() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertTrue(stable.trySet(null));\n+        assertEquals(\"null\", stable.toString());\n+    }\n+\n+    @Test\n+    void toStringNonNull() {\n+        StableValue<Integer> stable = StableValue.of();\n+        assertTrue(stable.trySet(VALUE));\n+        assertEquals(Objects.toString(VALUE), stable.toString());\n+    }\n+\n+    @Test\n+    void toStringCircular() {\n+        StableValue<StableValue<?>> stable = StableValue.of();\n+        stable.trySet(stable);\n+        String toString = assertDoesNotThrow(stable::toString);\n+        assertEquals(\"(this StableValue)\", toString);\n+        assertDoesNotThrow(stable::hashCode);\n+        assertDoesNotThrow((() -> stable.equals(stable)));\n+    }\n+\n+    @Test\n+    void recursiveCall() {\n+        StableValue<Integer> stable = StableValue.of();\n+        AtomicReference<StableValue<Integer>> ref = new AtomicReference<>(stable);\n+        assertThrows(IllegalStateException.class, () ->\n+                stable.orElseSet(() -> {\n+                    ref.get().trySet(1);\n+                    return 1;\n+                })\n+        );\n+        assertThrows(IllegalStateException.class, () ->\n+                stable.orElseSet(() -> {\n+                    ref.get().orElseSet(() -> 1);\n+                    return 1;\n+                })\n+        );\n+    }\n+\n+    @Test\n+    void intFunctionExample() {\n+        final class SqrtUtil {\n+\n+            private SqrtUtil() {}\n+\n+            private static final int CACHED_SIZE = 10;\n+\n+            private static final IntFunction<Double> SQRT =\n+                    \/\/ @link substring=\"intFunction\" target=\"#intFunction(int,IntFunction)\" :\n+                    StableValue.intFunction(CACHED_SIZE, StrictMath::sqrt);\n+\n+            public static double sqrt(int a) {\n+                return SQRT.apply(a);\n+            }\n+        }\n+\n+        double sqrt9 = SqrtUtil.sqrt(9);   \/\/ May eventually constant fold to 3.0 at runtime\n+\n+        assertEquals(3, sqrt9);\n+        assertThrows(IllegalArgumentException.class, () -> SqrtUtil.sqrt(16));\n+    }\n+\n+    @Test\n+    void intFunctionExample2() {\n+        final class PowerOf2Util {\n+\n+            private PowerOf2Util() {}\n+\n+            private static final int SIZE = 6;\n+            private static final IntFunction<Integer> ORIGINAL_POWER_OF_TWO =\n+                    v -> 1 << v;\n+\n+            private static final IntFunction<Integer> POWER_OF_TWO =\n+                    \/\/ @link substring=\"intFunction\" target=\"#intFunction(int,IntFunction)\" :\n+                    StableValue.intFunction(SIZE, ORIGINAL_POWER_OF_TWO);\n+\n+            public static int powerOfTwo(int a) {\n+                return POWER_OF_TWO.apply(a);\n+            }\n+        }\n+\n+        int pwr4 = PowerOf2Util.powerOfTwo(4);   \/\/ May eventually constant fold to 16 at runtime\n+\n+        assertEquals(16, pwr4);\n+        assertEquals(1, PowerOf2Util.powerOfTwo(0));\n+        assertEquals(8, PowerOf2Util.powerOfTwo(3));\n+        assertEquals(32, PowerOf2Util.powerOfTwo(5));\n+        assertThrows(IllegalArgumentException.class, () -> PowerOf2Util.powerOfTwo(10));\n+    }\n+\n+    @Test\n+    void functionExample() {\n+\n+        class Log2Util {\n+\n+            private Log2Util() {}\n+\n+            private static final Set<Integer> CACHED_KEYS =\n+                    Set.of(1, 2, 4, 8, 16, 32);\n+            private static final UnaryOperator<Integer> LOG2_ORIGINAL =\n+                    i -> 31 - Integer.numberOfLeadingZeros(i);\n+\n+            private static final Function<Integer, Integer> LOG2_CACHED =\n+                    \/\/ @link substring=\"function\" target=\"#function(Set,Function)\" :\n+                    StableValue.function(CACHED_KEYS, LOG2_ORIGINAL);\n+\n+            public static double log2(int a) {\n+                if (CACHED_KEYS.contains(a)) {\n+                    return LOG2_CACHED.apply(a);\n+                } else {\n+                    return LOG2_ORIGINAL.apply(a);\n+                }\n+            }\n+\n+        }\n+\n+        double log16 = Log2Util.log2(16); \/\/ May eventually constant fold to 4.0 at runtime\n+        double log256 = Log2Util.log2(256); \/\/ Will not constant fold\n+\n+        assertEquals(4, log16);\n+        assertEquals(8, log256);\n+    }\n+\n+    @Test\n+    void functionExample2() {\n+\n+        class Log2Util {\n+\n+            private Log2Util() {}\n+\n+            private static final Set<Integer> KEYS =\n+                    Set.of(1, 2, 4, 8);\n+            private static final UnaryOperator<Integer> LOG2_ORIGINAL =\n+                    i -> 31 - Integer.numberOfLeadingZeros(i);\n+\n+            private static final Function<Integer, Integer> LOG2 =\n+                    \/\/ @link substring=\"function\" target=\"#function(Set,Function)\" :\n+                    StableValue.function(KEYS, LOG2_ORIGINAL);\n+\n+            public static double log2(int a) {\n+                return LOG2.apply(a);\n+            }\n+\n+        }\n+\n+        double log16 = Log2Util.log2(8); \/\/ May eventually constant fold to 3.0 at runtime\n+\n+        assertEquals(3, log16);\n+        assertThrows(IllegalArgumentException.class, () -> Log2Util.log2(3));\n+    }\n+\n+    private static final BiPredicate<StableValue<Integer>, Integer> TRY_SET = StableValue::trySet;\n+    private static final BiPredicate<StableValue<Integer>, Integer> SET_OR_THROW = (s, i) -> {\n+        try {\n+            s.setOrThrow(i);\n+            return true;\n+        } catch (IllegalStateException e) {\n+            return false;\n+        }\n+    };\n+\n+    @Test\n+    void raceTrySet() {\n+        race(TRY_SET);\n+    }\n+\n+    @Test\n+    void raceSetOrThrow() {\n+        race(SET_OR_THROW);\n+    }\n+\n+    @Test\n+    void raceMixed() {\n+        race((s, i) -> switch (i % 2) {\n+            case 0 -> TRY_SET.test(s, i);\n+            case 1 -> SET_OR_THROW.test(s, i);\n+            default -> fail(\"should not reach here\");\n+        });\n+    }\n+\n+    void race(BiPredicate<StableValue<Integer>, Integer> winnerPredicate) {\n+        int noThreads = 10;\n+        CountDownLatch starter = new CountDownLatch(1);\n+        StableValue<Integer> stable = StableValue.of();\n+        Map<Integer, Boolean> winners = new ConcurrentHashMap<>();\n+        List<Thread> threads = IntStream.range(0, noThreads).mapToObj(i -> new Thread(() -> {\n+                    try {\n+                        \/\/ Ready, set ...\n+                        starter.await();\n+                        \/\/ Here we go!\n+                        winners.put(i, winnerPredicate.test(stable, i));\n+                    } catch (Throwable t) {\n+                        fail(t);\n+                    }\n+                }))\n+                .toList();\n+        threads.forEach(Thread::start);\n+        LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(1));\n+        \/\/ Start the race\n+        starter.countDown();\n+        threads.forEach(StableValueTest::join);\n+        \/\/ There can only be one winner\n+        assertEquals(1, winners.values().stream().filter(b -> b).count());\n+    }\n+\n+    private static void join(Thread thread) {\n+        try {\n+            thread.join();\n+        } catch (InterruptedException e) {\n+            fail(e);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueTest.java","additions":389,"deletions":0,"binary":false,"changes":389,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for making sure StableValue publishes values safely\n+ * @modules java.base\/jdk.internal.misc\n+ * @enablePreview\n+ * @run junit StableValuesSafePublicationTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableValuesSafePublicationTest {\n+\n+    private static final int SIZE = 100_000;\n+    private static final int THREADS = Runtime.getRuntime().availableProcessors();\n+    private static final StableValue<Holder>[] STABLES = stables();\n+\n+    static StableValue<Holder>[] stables() {\n+        @SuppressWarnings(\"unchecked\")\n+        StableValue<Holder>[] stables = (StableValue<Holder>[]) new StableValue[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            stables[i] = StableValue.of();\n+        }\n+        return stables;\n+    }\n+\n+    static final class Holder {\n+        \/\/ These are non-final fields but should be seen\n+        \/\/ fully initialized thanks to the HB properties of StableValue.\n+        int a, b, c, d, e;\n+\n+        Holder() {\n+            a = b = c = d = e = 1;\n+        }\n+    }\n+\n+    static final class Consumer implements Runnable {\n+\n+        final int[] observations = new int[SIZE];\n+        final StableValue<Holder>[] stables = STABLES;\n+        int i = 0;\n+\n+        @Override\n+        public void run() {\n+            for (; i < SIZE; i++) {\n+                StableValue<Holder> s = stables[i];\n+                Holder h;\n+                \/\/ Wait until the StableValue has a holder value\n+                while ((h = s.orElse(null)) == null) {}\n+                int a = h.a;\n+                int b = h.b;\n+                int c = h.c;\n+                int d = h.d;\n+                int e = h.e;\n+                observations[i] = a + (b << 1) + (c << 2) + (c << 3) + (d << 4) + (e << 5);\n+            }\n+        }\n+    }\n+\n+    static final class Producer implements Runnable {\n+\n+        final StableValue<Holder>[] stables = STABLES;\n+\n+        @Override\n+        public void run() {\n+            StableValue<Holder> s;\n+            long deadlineNs = System.nanoTime();\n+            for (int i = 0; i < SIZE; i++) {\n+                s = stables[i];\n+                s.trySet(new Holder());\n+                deadlineNs += 1000;\n+                while (System.nanoTime() < deadlineNs) {\n+                    Thread.onSpinWait();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void main() {\n+        List<Consumer> consumers = IntStream.range(0, THREADS)\n+                .mapToObj(_ -> new Consumer())\n+                .toList();\n+\n+        List<Thread> consumersThreads = IntStream.range(0, THREADS)\n+                .mapToObj(i -> Thread.ofPlatform()\n+                        .name(\"Consumer Thread \" + i)\n+                        .start(consumers.get(i)))\n+                .toList();\n+\n+        Producer producer = new Producer();\n+\n+        Thread producerThread = Thread.ofPlatform()\n+                .name(\"Producer Thread\")\n+                .start(producer);\n+\n+        join(consumers, producerThread);\n+        join(consumers, consumersThreads.toArray(Thread[]::new));\n+\n+        int[] histogram = new int[64];\n+        for (Consumer consumer : consumers) {\n+            for (int i = 0; i < SIZE; i++) {\n+                histogram[consumer.observations[i]]++;\n+            }\n+        }\n+\n+        \/\/ unless a = 1, ..., e = 1, zero observations should be seen\n+        for (int i = 0; i < 63; i++) {\n+            assertEquals(0, histogram[i]);\n+        }\n+        \/\/ a = 1, ..., e = 1 : index 2^5-1 = 63\n+        \/\/ All observations should end up in this bucket\n+        assertEquals(THREADS * SIZE, histogram[63]);\n+    }\n+\n+    static void join(List<Consumer> consumers, Thread... threads) {\n+        try {\n+            for (Thread t:threads) {\n+                long deadline = System.nanoTime() + TimeUnit.MINUTES.toNanos(1);\n+                while (t.isAlive()) {\n+                    t.join(TimeUnit.SECONDS.toMillis(10));\n+                    if (t.isAlive()) {\n+                        String stack = Arrays.stream(t.getStackTrace())\n+                                .map(Objects::toString)\n+                                .collect(Collectors.joining(System.lineSeparator()));\n+                        System.err.println(t + \": \" + stack);\n+                        for (int i = 0; i < consumers.size(); i++) {\n+                            System.err.println(\"Consumer \" + i + \": \" + consumers.get(i).i);\n+                        }\n+                    }\n+                    if (System.nanoTime() > deadline) {\n+                        long nonNulls = CompletableFuture.supplyAsync(() ->\n+                                Stream.of(STABLES)\n+                                        .map(s -> s.orElse(null))\n+                                        .filter(Objects::nonNull)\n+                                        .count(), Executors.newSingleThreadExecutor()).join();\n+                        fail(\"Giving up! Set stables seen by a new thread: \" + nonNulls);\n+                    }\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            fail(ie);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValuesSafePublicationTest.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for TrustedFieldType implementations\n+ * @modules jdk.unsupported\/sun.misc\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @modules java.base\/jdk.internal.misc\n+ * @enablePreview\n+ * @run junit\/othervm --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED -Dopens=true TrustedFieldTypeTest\n+ * @run junit\/othervm -Dopens=false TrustedFieldTypeTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableValueImpl;\n+import jdk.internal.misc.Unsafe;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InaccessibleObjectException;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TrustedFieldTypeTest {\n+\n+    @Test\n+    void varHandle() throws NoSuchFieldException, IllegalAccessException {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+        StableValue<Integer> originalValue = StableValue.of();\n+        @SuppressWarnings(\"unchecked\")\n+        StableValue<Integer>[] originalArrayValue = new StableValue[10];\n+\n+        final class Holder {\n+            private final StableValue<Integer> value = originalValue;\n+        }\n+        final class ArrayHolder {\n+            private final StableValue<Integer>[] array = originalArrayValue;\n+        }\n+\n+\n+        VarHandle valueVarHandle = lookup.findVarHandle(Holder.class, \"value\", StableValue.class);\n+        Holder holder = new Holder();\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                valueVarHandle.set(holder, StableValue.of())\n+        );\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                valueVarHandle.compareAndSet(holder, originalValue, StableValue.of())\n+        );\n+\n+        VarHandle arrayVarHandle = lookup.findVarHandle(ArrayHolder.class, \"array\", StableValue[].class);\n+        ArrayHolder arrayHolder = new ArrayHolder();\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                arrayVarHandle.set(arrayHolder, new StableValue[1])\n+        );\n+\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                arrayVarHandle.compareAndSet(arrayHolder, originalArrayValue, new StableValue[1])\n+        );\n+\n+    }\n+\n+    @Test\n+    void updateStableValueContentVia_j_i_m_Unsafe() {\n+        StableValue<Integer> stableValue = StableValue.of();\n+        stableValue.trySet(42);\n+        jdk.internal.misc.Unsafe unsafe = Unsafe.getUnsafe();\n+\n+        long offset = unsafe.objectFieldOffset(stableValue.getClass(), \"contents\");\n+        assertTrue(offset > 0);\n+\n+        \/\/ Unfortunately, it is possible to update the underlying data via jdk.internal.misc.Unsafe\n+        Object oldData = unsafe.getAndSetReference(stableValue, offset, 13);\n+        assertEquals(42, oldData);\n+        assertEquals(13, stableValue.orElseThrow());\n+    }\n+\n+    @Test\n+    void updateStableValueContentViaSetAccessible() throws NoSuchFieldException, IllegalAccessException {\n+\n+        if (Boolean.getBoolean(\"opens\")) {\n+            \/\/ Unfortunately, add-opens allows direct access to the `value` field\n+            Field field = StableValueImpl.class.getDeclaredField(\"contents\");\n+            field.setAccessible(true);\n+\n+            StableValue<Integer> stableValue = StableValue.of();\n+            stableValue.trySet(42);\n+\n+            Object oldData = field.get(stableValue);\n+            assertEquals(42, oldData);\n+\n+            field.set(stableValue, 13);\n+            assertEquals(13, stableValue.orElseThrow());\n+        } else {\n+            Field field = StableValueImpl.class.getDeclaredField(\"contents\");\n+            assertThrows(InaccessibleObjectException.class, ()-> field.setAccessible(true));\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/TrustedFieldTypeTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test multi-threaded use of StringBuilder\n+ * @compile --release 8 RacingSBThreads.java\n+ * @run main\/othervm -esa RacingSBThreads read\n+ * @run main\/othervm -esa RacingSBThreads insert\n+ * @run main\/othervm -esa RacingSBThreads append\n+ * @run main\/othervm -Xcomp RacingSBThreads\n+ *\/\n+\n+import java.nio.CharBuffer;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n+\n+\/**\n+ * Test racing accesses in StringBuilder.\n+ * Test source code should be compatible with JDK 8 to allow testing on older versions.\n+ *\/\n+public class RacingSBThreads {\n+\n+    private static final int TIMEOUT_SEC = 1;   \/\/ Duration to run each test case\n+    private static final int N = 10_000_000;    \/\/ static number of iterations for writes and modifies\n+    private static final int LEN = 100_000;     \/\/ Length of initial SB\n+\n+    \/\/ Strings available to be used as the initial contents of a StringBuilder\n+    private static final String UTF16_CHARS = initString('\\u1000', LEN);\n+    private static final String LATIN1_CHARS = initString('a', LEN);\n+\n+    \/\/ Cache jtreg timeout factor to allow test to be run as a standalone main()\n+    private static final double TIMEOUT_FACTOR = Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n+\n+    \/\/ Constant arguments available to be passed to StringBuilder operations\n+    private static final StringBuilder otherSB = new StringBuilder(\"ab\\uFF21\\uFF22\");\n+    private static final StringBuilder otherLongerSB = new StringBuilder(\"abcde\\uFF21\\uFF22\\uFF23\\uFF24\\uFF25\");\n+\n+    \/\/ Create a String with a repeated character\n+    private static String initString(char c, int len) {\n+        char[] chars = new char[len];\n+        Arrays.fill(chars, c);\n+        return new String(chars);\n+    }\n+\n+    \/\/ Plain unsynchronized reference to a StringBuilder\n+    \/\/ Updated by the writer thread\n+    \/\/ Read by the reader thread\n+    private StringBuilder buf;\n+\n+    \/\/ The current stress test case\n+    private final StressKind stressKind;\n+\n+    \/\/ Count of faults, zero if no faults found\n+    private final AtomicInteger faultCount = new AtomicInteger(0);\n+\n+    \/**\n+     * Run the stress cases indicated by command line arguments or run all cases.\n+     * Running each for TIMEOUT_SEC seconds or until a failure.\n+     * The timeout\/test duration can be scaled by setting System property\n+     * `test.timeout.factor` to a double value, for example, `-Dtest.timeout.factor=2.0`\n+     * @param args command line arguments\n+     *\/\n+    public static void main(String[] args) {\n+        Duration duration = Duration.ofSeconds((long)(TIMEOUT_SEC * TIMEOUT_FACTOR));\n+\n+        StressKind[] kinds = StressKind.values();\n+        if (args.length > 0) {\n+            \/\/ Parse explicitly supplied StressKind arguments\n+            try {\n+                 kinds = Arrays.stream(args)\n+                         .map((s) -> StressKind.valueOf(s.toUpperCase(Locale.ROOT)))\n+                         .toArray(StressKind[]::new);\n+            } catch (Exception ex) {\n+                System.out.println(\"Invalid StressKind arguments: \" + Arrays.toString(args));\n+                return;\n+            }\n+        }\n+\n+        \/\/ Run each kind for the duration\n+        int totalFaults = 0;\n+        for (StressKind sk : kinds) {\n+            Instant end = Instant.now().plus(duration); \/\/ note clock time, not runtime\n+            while (Instant.now().isBefore(end)) {\n+                int faultCount = new RacingSBThreads(sk).stress();\n+                if (faultCount > 0) {\n+                    System.out.printf(\"ERROR: Test case %s, %d faults%n\", sk, faultCount);\n+                }\n+                totalFaults += faultCount;\n+            }\n+        }\n+        if (totalFaults > 0) {\n+            throw new AssertionError(\"Total faults: \" + totalFaults);\n+        }\n+    }\n+\n+    \/\/ Enum of the various test cases with a lambda to invoke for each\n+    enum StressKind {\n+        \/**\n+         * Reading characters should always be one of the known values being written to the destination\n+         *\/\n+        READ(LATIN1_CHARS, (sb,  chr) -> {\n+            char ch = sb.charAt(LEN * 4 \/ 5);\n+            if (ch != chr & ch != (chr & 0xff) & ch != chr >> 8) {\n+                throw new AssertionError(\"Unexpected characters in buffer: 0x\" + Integer.toHexString(ch));\n+            }\n+        }),\n+        \/**\n+         * Insert another StringBuilder; in the face of racy changes to the destination\n+         *\/\n+        INSERT(LATIN1_CHARS, (sb, C) -> {\n+            sb.insert(sb.length() - 1, otherLongerSB, 0, otherLongerSB.length());\n+        }),\n+        \/**\n+         * Appending a StringBuilder in the face of racy changes to the destination\n+         *\/\n+        APPEND(LATIN1_CHARS, (sb, C) -> {\n+            sb.append(otherSB, 0, otherSB.length());\n+        }),\n+        ;\n+\n+        private final BiConsumer<StringBuilder,Character> func;\n+        private final String sbInitString;\n+\n+        \/**\n+         * Defines a test case.\n+         * @param sbInitString the initial contents of the StringBuilder; chooses the coder\n+         * @param func the test BiConsumer to apply to the StringBuilder\n+         *\/\n+        private StressKind(String sbInitString, BiConsumer<StringBuilder,Character> func) {\n+            this.func = func;\n+            this.sbInitString = sbInitString;\n+        }\n+    }\n+\n+    public RacingSBThreads(StressKind stressKind) {\n+        this.stressKind = stressKind;\n+    }\n+\n+    \/**\n+     * Run the stress case.\n+     * One thread continuously creates a StringBuilder and fills it before trimming it to zero.\n+     * The other thread performs the test case on the same StringBuilder (without any synchronization)\n+     * @return the count of faults\n+     *\/\n+    private int stress() {\n+        PokeBuilder r = new PokeBuilder(this, N);\n+        Writer w = new Writer(this, N);\n+\n+        Thread writer = new Thread(w::createShrink);\n+        Thread reader = new Thread(r::readModify);\n+        writer.start();\n+        reader.start();\n+        join(reader);\n+        System.out.println(r);\n+        writer.interrupt();\n+        join(writer);\n+        System.out.println(w);\n+        return r.racing.faultCount.get();\n+    }\n+\n+    \/**\n+     * Wait for a thread to terminate.\n+     * @param thread a thread to wait for\n+     *\/\n+    private void join(Thread thread) {\n+        do {\n+            try {\n+                thread.join();\n+                break;\n+            } catch (InterruptedException ie) {\n+                \/\/ ignore and retry\n+            }\n+        } while (true);\n+    }\n+\n+    \/**\n+     * Run a StressKind case in a loop keeping track of exceptions.\n+     * The StringBuilder under test is shared with the writer task without benefit of synchronization.\n+     *\/\n+    private static class PokeBuilder {\n+        private final RacingSBThreads racing;\n+        private final int iterations;\n+        private int nulls;\n+        private int bounds;\n+        private int pokeCycles;\n+        private int bufChanges;\n+\n+        public PokeBuilder(RacingSBThreads racing, int iterations) {\n+            this.racing = racing;\n+            this.iterations = iterations;\n+            nulls = 0;\n+            bounds = 0;\n+            pokeCycles = 0;\n+            bufChanges = 0;\n+        }\n+\n+        \/\/ Repeatedly change the racy StringBuilder, ignoring and counting exceptions\n+        private void readModify() {\n+            System.out.println(\"Starting \" + racing.stressKind);\n+            sleep(100);\n+            for (int i = 0; i < iterations; ++i) {\n+                pokeCycles++;\n+                StringBuilder sb = racing.buf;  \/\/ read once\n+                try {\n+                    if (sb.length() > Integer.MAX_VALUE \/ 4) {\n+                        sb.setLength(Integer.MAX_VALUE \/ 4);\n+                    }\n+                    \/\/ Invoke the test case\n+                    racing.stressKind.func.accept(sb, racing.stressKind.sbInitString.charAt(0));\n+                    if (sb != racing.buf) {\n+                        bufChanges++;\n+                    }\n+                } catch (NullPointerException e) {\n+                    ++nulls;\n+                } catch (IndexOutOfBoundsException e) {\n+                    ++bounds;\n+                } catch (AssertionError ae) {\n+                    racing.faultCount.incrementAndGet();\n+                    throw ae;\n+                }\n+            }\n+        }\n+\n+        private static void sleep(int i) {\n+            try {\n+                Thread.sleep(i);\n+            } catch (InterruptedException ignored) {\n+            }\n+        }\n+\n+        public String toString() {\n+            return String.format(\"pokeCycles:%d, bounds:%d, bufChanges:%d, nulls=%d\",\n+                    pokeCycles, bounds, bufChanges, nulls);\n+        }\n+    }\n+\n+    \/**\n+     * Repeatedly create and append strings to a StringBuilder shared through fields of RacingSBThreads.\n+     * The StringBuilder is created new on each iteration and truncated at the end of each iteration.\n+     * Exceptions are counted and reported.\n+     *\/\n+    private static class Writer {\n+        private final RacingSBThreads racing;\n+        private final int iterations;\n+        private int sumWriter;\n+        private int writeCycles;\n+        private int putBounds;\n+\n+        public Writer(RacingSBThreads racing, int iterations) {\n+            this.racing = racing;\n+            this.iterations = iterations;\n+        }\n+\n+        private void createShrink() {\n+            for (int i = 0; i < iterations; ++i) {\n+                if (i % 100_000 == 0) {\n+                    if (Thread.interrupted()) {\n+                        break;\n+                    }\n+                }\n+                try {\n+                    ++writeCycles;\n+                    racing.buf = new StringBuilder(racing.stressKind.sbInitString);\n+                    racing.buf.append(UTF16_CHARS);\n+                    sumWriter += racing.buf.length();\n+                    racing.buf.setLength(0);\n+                    racing.buf.trimToSize();\n+                } catch (Exception ex) {\n+                    ++putBounds;\n+                }\n+            }\n+        }\n+\n+        public String toString() {\n+            return String.format(\"writeCycles:%d, bounds:%d, sumWriter=%d\", writeCycles, putBounds, sumWriter);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/RacingSBThreads.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -84,0 +84,1 @@\n+                {\"stdin.encoding\"},\n","filename":"test\/jdk\/java\/lang\/System\/PropertyTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+\n+\/*\n+ * @test\n+ * @bug 8297727\n+ * @summary MethodHandle field access fails with bytecode compilation disabled\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames\n+ *     -Djava.lang.invoke.MethodHandle.COMPILE_THRESHOLD=-1\n+ *     ReflectionInInterpretTest\n+ *\/\n+public class ReflectionInInterpretTest {\n+    private static Integer f; \/\/ non-Object type is required to find a non-compiled form\n+\n+    public static void main(String... args) throws Throwable {\n+        MethodHandle mh = MethodHandles.lookup().findStaticGetter(ReflectionInInterpretTest.class, \"f\", Integer.class);\n+        var _ = (Integer) mh.invokeExact();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/LFInterpret\/ReflectionInInterpretTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,0 +171,15 @@\n+\n+        for (var location : AccessFlag.Location.values()) {\n+            try {\n+                location.flags(null);\n+                throw new RuntimeException(\"Did not get NPE on \" + location + \".flags(null)\");\n+            } catch (NullPointerException npe ) {\n+                ; \/\/ Expected\n+            }\n+            try {\n+                location.flagsMask(null);\n+                throw new RuntimeException(\"Did not get NPE on \" + location + \".flagsMask(null)\");\n+            } catch (NullPointerException npe ) {\n+                ; \/\/ Expected\n+            }\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+import static java.lang.reflect.AccessFlag.*;\n+\n@@ -59,1 +61,1 @@\n-@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER]\")\n+@ExpectedClassFlags({PUBLIC, FINAL, SUPER})\n@@ -91,2 +93,4 @@\n-            String actual = clazz.accessFlags().toString();\n-            if (!expected.value().equals(actual)) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = clazz.accessFlags();\n+            if (!base.equals(actual)) {\n@@ -94,1 +98,1 @@\n-                                           \" expected \" + expected.value() +\n+                                           \" expected \" + base +\n@@ -113,1 +117,1 @@\n-        var expected = Set.of(AccessFlag.PUBLIC,\n+        var expected = Set.of(PUBLIC,\n@@ -142,2 +146,2 @@\n-            if (flags.contains(AccessFlag.PUBLIC))\n-                accessLevel = AccessFlag.PUBLIC;\n+            if (flags.contains(PUBLIC))\n+                accessLevel = PUBLIC;\n@@ -160,1 +164,1 @@\n-                                Set.of(AccessFlag.PUBLIC,\n+                                Set.of(PUBLIC,\n@@ -176,1 +180,1 @@\n-    @ExpectedClassFlags(\"[PUBLIC, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PUBLIC, STATIC, INTERFACE, ABSTRACT})\n@@ -178,1 +182,1 @@\n-    @ExpectedClassFlags(\"[PROTECTED, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PROTECTED, STATIC, INTERFACE, ABSTRACT})\n@@ -180,1 +184,1 @@\n-    @ExpectedClassFlags(\"[PRIVATE, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PRIVATE, STATIC, INTERFACE, ABSTRACT})\n@@ -182,1 +186,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT})\n@@ -185,1 +189,1 @@\n-    @ExpectedClassFlags(\"[FINAL]\")\n+    @ExpectedClassFlags({FINAL})\n@@ -188,1 +192,1 @@\n-    @ExpectedClassFlags(\"[ABSTRACT]\")\n+    @ExpectedClassFlags({ABSTRACT})\n@@ -191,1 +195,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT, ANNOTATION]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT, ANNOTATION})\n@@ -194,1 +198,1 @@\n-    @ExpectedClassFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+    @ExpectedClassFlags({PUBLIC, STATIC, FINAL, ENUM})\n@@ -201,1 +205,1 @@\n-    @ExpectedClassFlags(\"[PROTECTED, STATIC, ABSTRACT, ENUM]\")\n+    @ExpectedClassFlags({PROTECTED, STATIC, ABSTRACT, ENUM})\n@@ -210,1 +214,1 @@\n-    @ExpectedClassFlags(\"[PRIVATE, ABSTRACT]\")\n+    @ExpectedClassFlags({PRIVATE, ABSTRACT})\n@@ -213,1 +217,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT})\n@@ -218,1 +222,1 @@\n-@ExpectedClassFlags(\"[INTERFACE, ABSTRACT, ANNOTATION]\")\n+@ExpectedClassFlags({INTERFACE, ABSTRACT, ANNOTATION})\n@@ -220,1 +224,1 @@\n-    String value();\n+    AccessFlag[] value();\n@@ -223,1 +227,1 @@\n-@ExpectedClassFlags(\"[INTERFACE, ABSTRACT]\")\n+@ExpectedClassFlags({INTERFACE, ABSTRACT})\n@@ -227,1 +231,1 @@\n-@ExpectedClassFlags(\"[FINAL, SUPER, ENUM]\")\n+@ExpectedClassFlags({FINAL, SUPER, ENUM})\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":28,"deletions":24,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,5 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+import static java.lang.reflect.AccessFlag.*;\n@@ -57,2 +62,4 @@\n-            String actual = field.accessFlags().toString();\n-            if (!expected.value().equals(actual)) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = field.accessFlags();\n+            if (!base.equals(actual)) {\n@@ -60,2 +67,2 @@\n-                                           \" expected \" + expected.value() +\n-                                           \" got \" + actual);\n+                        \" expected \" + base +\n+                        \" got \" + actual);\n@@ -67,1 +74,1 @@\n-    @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL]\")\n+    @ExpectedFieldFlags({PUBLIC, STATIC, FINAL})\n@@ -70,1 +77,1 @@\n-    @ExpectedFieldFlags(\"[PRIVATE, VOLATILE, TRANSIENT]\")\n+    @ExpectedFieldFlags({PRIVATE, VOLATILE, TRANSIENT})\n@@ -73,1 +80,1 @@\n-    @ExpectedFieldFlags(\"[PROTECTED]\")\n+    @ExpectedFieldFlags({PROTECTED})\n@@ -78,1 +85,1 @@\n-        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        @ExpectedFieldFlags({PUBLIC, STATIC, FINAL, ENUM})\n@@ -81,1 +88,1 @@\n-        @ExpectedFieldFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+        @ExpectedFieldFlags({PUBLIC, STATIC, FINAL, ENUM})\n@@ -84,1 +91,1 @@\n-        @ExpectedFieldFlags(\"[PRIVATE]\") \/\/ no \"ENUM\"\n+        @ExpectedFieldFlags({PRIVATE}) \/\/ no \"ENUM\"\n@@ -90,1 +97,1 @@\n-        String value();\n+        AccessFlag[] value();\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/FieldAccessFlagTest.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,5 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+import static java.lang.reflect.AccessFlag.*;\n@@ -52,1 +57,1 @@\n-    @ExpectedMethodFlags(\"[PUBLIC, STATIC, VARARGS]\")\n+    @ExpectedMethodFlags({PUBLIC, STATIC, VARARGS})\n@@ -139,1 +144,1 @@\n-        ExpectedMethodFlags emf =\n+        ExpectedMethodFlags expected =\n@@ -141,3 +146,9 @@\n-        if (emf != null) {\n-            String actual = method.accessFlags().toString();\n-            checkString(method.toString(), emf.value(), actual);\n+        if (expected != null) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = method.accessFlags();\n+            if (!base.equals(actual)) {\n+                throw new RuntimeException(\"On \" + method +\n+                        \" expected \" + base +\n+                        \" got \" + actual);\n+            }\n@@ -158,1 +169,1 @@\n-    @ExpectedMethodFlags(\"[PUBLIC]\")\n+    @ExpectedMethodFlags({PUBLIC})\n@@ -161,1 +172,1 @@\n-    @ExpectedMethodFlags(\"[PROTECTED]\")\n+    @ExpectedMethodFlags({PROTECTED})\n@@ -164,1 +175,1 @@\n-    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    @ExpectedMethodFlags({PRIVATE})\n@@ -168,1 +179,1 @@\n-    @ExpectedMethodFlags(\"[PROTECTED, SYNCHRONIZED]\")\n+    @ExpectedMethodFlags({PROTECTED, SYNCHRONIZED})\n@@ -171,1 +182,1 @@\n-    @ExpectedMethodFlags(\"[PRIVATE]\")\n+    @ExpectedMethodFlags({PRIVATE})\n@@ -174,1 +185,1 @@\n-    @ExpectedMethodFlags(\"[ABSTRACT]\")\n+    @ExpectedMethodFlags({ABSTRACT})\n@@ -177,1 +188,1 @@\n-    @ExpectedMethodFlags(\"[PUBLIC, FINAL]\")\n+    @ExpectedMethodFlags({PUBLIC, FINAL})\n@@ -180,1 +191,1 @@\n-    @ExpectedMethodFlags(\"[NATIVE]\")\n+    @ExpectedMethodFlags({NATIVE})\n@@ -185,1 +196,1 @@\n-        String value();\n+        AccessFlag[] value();\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/MethodAccessFlagTest.java","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,5 @@\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+\n+import static java.lang.reflect.AccessFlag.*;\n@@ -45,1 +50,1 @@\n-    @ExpectedFlags(\"[PUBLIC, STATIC, VARARGS, STRICT]\")\n+    @ExpectedFlags({PUBLIC, STATIC, VARARGS, STRICT})\n@@ -62,2 +67,4 @@\n-            String actual = method.accessFlags().toString();\n-            if (!expected.value().equals(actual)) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = method.accessFlags();\n+            if (!base.equals(actual)) {\n@@ -65,2 +72,2 @@\n-                                           \" expected \" + expected.value() +\n-                                           \" got \" + actual);\n+                        \" expected \" + base +\n+                        \" got \" + actual);\n@@ -72,1 +79,1 @@\n-    @ExpectedFlags(\"[PUBLIC, STRICT]\")\n+    @ExpectedFlags({PUBLIC, STRICT})\n@@ -77,1 +84,1 @@\n-        String value();\n+        AccessFlag[] value();\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/StrictAccessFlagTest.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @summary Tests of AccessFlag.locations(ClassFileFormatVersion)\n+ * @summary Tests of AccessFlag.locations(ClassFileFormatVersion) and\n+ *          accessors on AccessFlag.Location\n@@ -82,0 +83,2 @@\n+        testFlagVersionConsistency();\n+        testLocationMaskFlagConsistency();\n@@ -248,1 +251,1 @@\n-            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_6) <= 0) {\n+            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) < 0) {\n@@ -253,1 +256,2 @@\n-                        case RELEASE_7 -> Set.of(Location.CLASS, Location.FIELD,\n+                        case RELEASE_5, RELEASE_6,\n+                             RELEASE_7 -> Set.of(Location.CLASS, Location.FIELD,\n@@ -292,0 +296,43 @@\n+    private static void testFlagVersionConsistency() {\n+        for (var flag : AccessFlag.values()) {\n+            for (var location : AccessFlag.Location.values()) {\n+                if (location.flags().contains(flag) != flag.locations().contains(location)) {\n+                    throw new RuntimeException(String.format(\"AccessFlag and Location inconsistency:\" +\n+                            \"flag %s and location %s are inconsistent for the latest version\", flag, location));\n+                }\n+            }\n+        }\n+        for (var cffv : ClassFileFormatVersion.values()) {\n+            for (var flag : AccessFlag.values()) {\n+                for (var location : AccessFlag.Location.values()) {\n+                    if (location.flags(cffv).contains(flag) != flag.locations(cffv).contains(location)) {\n+                        throw new RuntimeException(String.format(\"AccessFlag and Location inconsistency:\" +\n+                                \"flag %s and location %s are inconsistent for class file version %s\", flag, location, cffv));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void testLocationMaskFlagConsistency() {\n+        for (var location : AccessFlag.Location.values()) {\n+            if (!flagsAndMaskMatch(location.flags(), location.flagsMask())) {\n+                throw new RuntimeException(String.format(\"Flags and mask mismatch for %s\", location));\n+            }\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                if (!flagsAndMaskMatch(location.flags(cffv), location.flagsMask(cffv))) {\n+                    throw new RuntimeException(String.format(\"Flags and mask mismatch for %s in %s\", location, cffv));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean flagsAndMaskMatch(Set<AccessFlag> flags, int mask) {\n+        for (var flag : flags) {\n+            int bit = flag.mask();\n+            if (((mask & bit) == 0))\n+                return false;\n+            mask &= ~bit;\n+        }\n+        return mask == 0;\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java","additions":51,"deletions":4,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @modules java.base\/sun.net.www.protocol.file\n+ * @library \/test\/lib\n@@ -29,1 +31,0 @@\n- * @run main UNCTest file:\/\/jdk\/LOCAL-JAVA\/jdk1.4\/win\/README.txt\n@@ -32,0 +33,6 @@\n+import jtreg.SkippedException;\n+import sun.net.www.protocol.file.FileURLConnection;\n+\n+import java.io.File;\n+import java.net.InetAddress;\n+import java.net.URI;\n@@ -36,2 +43,16 @@\n-    public static void main(String args[]) throws Exception {\n-        URL url = new URL( args[0] );\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Get the \"computer name\" for this host\n+        String hostName = InetAddress.getLocalHost().getHostName();\n+\n+        \/\/ UNC path which always exists with Administrative Shares enabled\n+        String path = \"\\\\\\\\\" + hostName + \"\\\\C$\\\\Windows\";\n+\n+        \/\/ Skip test if Administrative Shares is disabled\n+        if (! new File(path).exists()) {\n+            throw new SkippedException(\"Administrative Shares not enabled\");\n+        }\n+\n+        \/\/ File URL for the UNC path\n+        URL url = new URI(\"file:\/\/\" + hostName + \"\/C$\/Windows\").toURL();\n+\n+        \/\/ Should open a FileURLConnection for the UNC path\n@@ -39,0 +60,8 @@\n+\n+        \/\/ Sanity check that the connection is a FileURLConnection\n+        if (! (conn instanceof FileURLConnection)) {\n+            throw new Exception(\"Expected FileURLConnection, instead got \"\n+                    + conn.getClass().getName());\n+        }\n+\n+        \/\/ Verify that the connection is not in an already connected state\n","filename":"test\/jdk\/java\/net\/URLConnection\/UNCTest.java","additions":33,"deletions":4,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -768,1 +768,1 @@\n-    public static abstract class HttpTestServer {\n+    abstract class HttpTestServer implements AutoCloseable {\n@@ -785,0 +785,5 @@\n+        @Override\n+        public void close() throws Exception {\n+            stop();\n+        }\n+\n@@ -974,0 +979,7 @@\n+\n+            @Override\n+            public void close() throws Exception {\n+                System.out.println(\"Http2TestServerImpl: close\");\n+                impl.close();\n+            }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+\n@@ -67,10 +68,4 @@\n-    private static ThreadFactory defaultThreadFac =\n-        (Runnable r) -> {\n-            Thread t = new Thread(r);\n-            t.setName(\"Test-server-pool\");\n-            return t;\n-        };\n-\n-\n-    private static ExecutorService getDefaultExecutor() {\n-        return Executors.newCachedThreadPool(defaultThreadFac);\n+    private static ExecutorService createExecutor(String name) {\n+        String threadNamePrefix = \"%s-pool\".formatted(name);\n+        ThreadFactory threadFactory = Thread.ofPlatform().name(threadNamePrefix, 0).factory();\n+        return Executors.newCachedThreadPool(threadFactory);\n@@ -80,1 +75,1 @@\n-        this(serverName, secure, port, getDefaultExecutor(), 50, null, null);\n+        this(serverName, secure, port, null, 50, null, null);\n@@ -84,1 +79,1 @@\n-        this(null, secure, port, getDefaultExecutor(), 50, null, null);\n+        this(null, secure, port, null, 50, null, null);\n@@ -200,1 +195,1 @@\n-        this.exec = exec == null ? getDefaultExecutor() : exec;\n+        this.exec = exec == null ? createExecutor(name) : exec;\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServer.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8351113\n+ * @summary check for negative offset\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import javax.crypto.spec.RC2ParameterSpec;\n+\n+public class InvalidArrayIndex {\n+\n+    public static void main(String[] args) throws Exception {\n+        Utils.runAndCheckException(() -> new RC2ParameterSpec(0, new byte[20],\n+                Integer.MIN_VALUE), ArrayIndexOutOfBoundsException.class);\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/spec\/RC2ParameterSpec\/InvalidArrayIndex.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @enablePreview\n@@ -141,0 +142,2 @@\n+        testImmutableSet(AccessFlag.maskToAccessFlags(0, AccessFlag.Location.CLASS), AccessFlag.ABSTRACT);\n+        testImmutableSet(AccessFlag.maskToAccessFlags(Modifier.PUBLIC | Modifier.STATIC | Modifier.SYNCHRONIZED, AccessFlag.Location.METHOD), AccessFlag.ABSTRACT);\n@@ -220,0 +223,2 @@\n+        testEmptyList(StableValue.list(0, i -> i));\n+        testEmptyList(StableValue.list(3, i -> i).subList(0, 0));\n@@ -222,0 +227,1 @@\n+        testListMutatorsAlwaysThrow(StableValue.list(0, i -> i));\n@@ -224,0 +230,2 @@\n+        testEmptyListMutatorsAlwaysThrow(StableValue.list(0, i -> i));\n+        testEmptyListMutatorsAlwaysThrow(StableValue.list(3, i -> i).subList(0, 0));\n@@ -245,1 +253,4 @@\n-                Stream.of(1, null, 3, 4).toList())) {\n+                Stream.of(1, null, 3, 4).toList(),\n+                StableValue.list(0, i -> i),\n+                StableValue.list(3, i -> i),\n+                StableValue.list(10, i -> i))) {\n@@ -357,0 +368,3 @@\n+        testEmptyMap(StableValue.map(Set.of(), k -> k));\n+        testMapMutatorsAlwaysThrow(StableValue.map(Set.of(), k -> k));\n+        testEmptyMapMutatorsAlwaysThrow(StableValue.map(Set.of(), k -> k));\n@@ -369,1 +383,4 @@\n-                Map.ofEntries(ea))) {\n+                Map.ofEntries(ea),\n+                StableValue.map(Set.<Integer>of(), k -> k),\n+                StableValue.map(Set.of(1), k -> k),\n+                StableValue.map(Set.of(1, 2, 3), k -> k))) {\n@@ -481,0 +498,2 @@\n+        } else {\n+            testEmptyIterator(c.iterator());\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -33,0 +34,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -118,1 +121,7 @@\n-        private final static Duration JOIN_WAIT = Duration.ofMillis(500);\n+        \/\/ Since this is used to self-test for an expected deadlock, it will\n+        \/\/ delay the test by at least this duration (so being overly large is\n+        \/\/ a potential issue). The deadlock is set up so it should occur almost\n+        \/\/ immediately (if it occurs), but tests are run under very high loads\n+        \/\/ in higher tiers, so it's necessary to be a bit pessimistic here.\n+        private final static Duration JOIN_WAIT =\n+                Duration.ofMillis(Utils.adjustTimeout(2000));\n","filename":"test\/jdk\/java\/util\/logging\/LoggingDeadlock5.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import javax.print.PrintService;\n+import javax.print.PrintServiceLookup;\n+import javax.print.attribute.HashPrintRequestAttributeSet;\n+import javax.print.attribute.PrintRequestAttributeSet;\n+import javax.print.attribute.Size2DSyntax;\n+import javax.print.attribute.standard.Chromaticity;\n+import javax.print.attribute.standard.MediaSize;\n+import javax.print.attribute.standard.MediaSizeName;\n+import javax.swing.JButton;\n+import javax.swing.JComboBox;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JPanel;\n+import javax.swing.ListCellRenderer;\n+import javax.swing.border.EmptyBorder;\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GridLayout;\n+import java.awt.LinearGradientPaint;\n+import java.awt.MultipleGradientPaint;\n+import java.awt.Paint;\n+import java.awt.RadialGradientPaint;\n+import java.awt.Window;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.image.BufferedImage;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @bug 8315113\n+ * @key printer\n+ * @requires (os.family == \"mac\")\n+ * @summary javax.print: Support monochrome printing\n+ * @run main\/manual MonochromePrintTest\n+ *\/\n+\n+public class MonochromePrintTest {\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+           This test checks availability of the monochrome printing\n+           on color printers.\n+           To be able to run this test it is required to have a color\n+           printer configured in your user environment.\n+           Test's steps:\n+             - Choose a printer.\n+             - Press 'Print' button.\n+           Visual inspection of the printed pages is needed.\n+           A passing test will print two pages with\n+           color and grayscale appearances\n+           \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PrintService[] availablePrintServices = getTestablePrintServices();\n+        if (availablePrintServices.length == 0) {\n+            System.out.println(\"Available print services not found\");\n+            return;\n+        }\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(300)\n+                .title(\"Monochrome printing\")\n+                .testUI(createTestWindow(availablePrintServices))\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Window createTestWindow(final PrintService[] availablePrintServices) {\n+        Window frame = new JFrame(\"Choose service to test\");\n+        JPanel pnlMain = new JPanel();\n+        pnlMain.setBorder(new EmptyBorder(5,5,5,5));\n+        pnlMain.setLayout(new GridLayout(3, 1, 5, 5));\n+        JLabel lblServices = new JLabel(\"Available services\");\n+        JComboBox<PrintService> cbServices = new JComboBox<>();\n+        JButton btnPrint = new JButton(\"Print\");\n+        btnPrint.setEnabled(false);\n+        cbServices.setRenderer(new ListCellRenderer<PrintService>() {\n+            @Override\n+            public Component getListCellRendererComponent(JList<? extends PrintService> list, PrintService value,\n+                                                          int index, boolean isSelected, boolean cellHasFocus) {\n+                return new JLabel(value == null ? \"\" : value.getName());\n+            }\n+        });\n+        cbServices.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                btnPrint.setEnabled(cbServices.getSelectedItem() != null);\n+            }\n+        });\n+        for (PrintService ps : availablePrintServices) {\n+            cbServices.addItem(ps);\n+        }\n+        lblServices.setLabelFor(cbServices);\n+        btnPrint.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent e) {\n+                PrintService printService = (PrintService) cbServices.getSelectedItem();\n+                if (printService != null) {\n+                    cbServices.setEnabled(false);\n+                    btnPrint.setEnabled(false);\n+                    test(printService);\n+                }\n+            }\n+        });\n+        pnlMain.add(lblServices);\n+        pnlMain.add(cbServices);\n+        pnlMain.add(btnPrint);\n+        frame.add(pnlMain);\n+        frame.pack();\n+        return frame;\n+    }\n+\n+    private static PrintService[] getTestablePrintServices() {\n+        List<PrintService> testablePrintServices = new ArrayList<>();\n+        for (PrintService ps : PrintServiceLookup.lookupPrintServices(null,null)) {\n+            if (ps.isAttributeValueSupported(Chromaticity.MONOCHROME, null, null) &&\n+                    ps.isAttributeValueSupported(Chromaticity.COLOR, null, null)) {\n+                testablePrintServices.add(ps);\n+            }\n+        }\n+        return testablePrintServices.toArray(new PrintService[0]);\n+    }\n+\n+    private static void test(PrintService printService) {\n+        try {\n+            print(printService, Chromaticity.COLOR);\n+            print(printService, Chromaticity.MONOCHROME);\n+        } catch (PrinterException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static void print(PrintService printService, Chromaticity chromaticity)\n+            throws PrinterException {\n+        PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();\n+        attr.add(chromaticity);\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        job.setPrintService(printService);\n+        job.setJobName(\"Print with \" + chromaticity);\n+        job.setPrintable(new ChromaticityAttributePrintable(chromaticity));\n+        job.print(attr);\n+    }\n+\n+    private static class ChromaticityAttributePrintable implements Printable {\n+\n+        private final Chromaticity chromaticity;\n+\n+        public ChromaticityAttributePrintable(Chromaticity chromaticity) {\n+            this.chromaticity = chromaticity;\n+        }\n+\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n+\n+            if (pageIndex != 0) {\n+                return NO_SUCH_PAGE;\n+            }\n+\n+            final int sx = (int) Math.ceil(pageFormat.getImageableX());\n+            final int sy = (int) Math.ceil(pageFormat.getImageableY());\n+\n+            Graphics2D g = (Graphics2D) graphics;\n+\n+            BufferedImage bufferdImage = getBufferedImage((int) Math.ceil(pageFormat.getImageableWidth() \/ 3),\n+                    (int) Math.ceil(pageFormat.getImageableHeight() \/ 7));\n+            g.drawImage(bufferdImage, null, sx, sy);\n+\n+            double defaultMediaSizeWidth = MediaSize.getMediaSizeForName(MediaSizeName.ISO_A4)\n+                    .getX(Size2DSyntax.INCH) * 72;\n+            double scale = pageFormat.getWidth() \/ defaultMediaSizeWidth;\n+\n+            final int squareSideLenngth = (int)(50 * scale);\n+            final int offset = (int)(10 * scale);\n+            int imh = sy + (int) Math.ceil(pageFormat.getImageableHeight() \/ 7) + offset;\n+\n+            g.setColor(Color.ORANGE);\n+            g.drawRect(sx, imh, squareSideLenngth, squareSideLenngth);\n+            imh = imh + squareSideLenngth + offset;\n+\n+            g.setColor(Color.BLUE);\n+            g.fillOval(sx, imh, squareSideLenngth, squareSideLenngth);\n+            imh = imh + squareSideLenngth + offset;\n+\n+            Paint paint = new LinearGradientPaint(0, 0,\n+                    squareSideLenngth>>1, offset>>1, new float[]{0.0f, 0.2f, 1.0f},\n+                    new Color[]{Color.RED, Color.GREEN, Color.CYAN}, MultipleGradientPaint.CycleMethod.REPEAT);\n+            g.setPaint(paint);\n+            g.setStroke(new BasicStroke(squareSideLenngth));\n+            g.fillRect(sx, imh + offset, squareSideLenngth, squareSideLenngth);\n+            imh = imh + squareSideLenngth + offset;\n+\n+            paint = new RadialGradientPaint(offset, offset, offset>>1, new float[]{0.0f, 0.5f, 1.0f},\n+                    new Color[]{Color.RED, Color.GREEN, Color.CYAN}, MultipleGradientPaint.CycleMethod.REPEAT);\n+            g.setPaint(paint);\n+            g.fillRect(sx, imh + offset, squareSideLenngth, squareSideLenngth);\n+            imh = imh + squareSideLenngth + offset;\n+\n+            g.setStroke(new BasicStroke(offset>>1));\n+            g.setColor(Color.PINK);\n+            g.drawString(\"This page should be \" + chromaticity, sx, imh + squareSideLenngth);\n+\n+            return PAGE_EXISTS;\n+        }\n+\n+        private BufferedImage getBufferedImage(int width, int height) {\n+            Color[] colors = new Color[]{\n+                    Color.RED, Color.ORANGE, Color.BLUE,\n+                    Color.CYAN, Color.MAGENTA, Color.GREEN\n+            };\n+            BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n+            final int secondSquareOffset = width \/ 3;\n+            final int thirdSquareOffset = secondSquareOffset * 2;\n+            final int squareHeight = height \/ 2;\n+\n+            int offset = 0;\n+            Color color;\n+            for (int y = 0; y < height; y++) {\n+                if (y > squareHeight) {\n+                    offset = 3;\n+                }\n+                for (int x = 0; x < width; x++) {\n+                    if (x >= thirdSquareOffset) {\n+                        color = colors[offset + 2];\n+                    } else if (x >= secondSquareOffset) {\n+                        color = colors[offset + 1];\n+                    } else {\n+                        color = colors[offset];\n+                    }\n+                    bufferedImage.setRGB(x, y, color.getRGB());\n+                }\n+            }\n+            return bufferedImage;\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/print\/attribute\/MonochromePrintTest.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n-import javax.swing.BoxLayout;\n+import javax.swing.Box;\n@@ -42,1 +42,0 @@\n-import javax.swing.JPanel;\n@@ -58,0 +57,1 @@\n+    private static KeyboardFocusManager focusManager;\n@@ -62,1 +62,3 @@\n-        \/\/ Get all installed Look and Feels\n+        SwingUtilities.invokeAndWait(() ->\n+                focusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager());\n+\n@@ -100,1 +102,2 @@\n-            \/\/ tab from radio button in group to next component in the middle of button group layout\n+            \/\/ tab from radio button in group to next component in the middle of\n+            \/\/ button group layout\n@@ -104,1 +107,2 @@\n-            \/\/ tab to radio button in group from component in the middle of button group layout\n+            \/\/ tab to radio button in group from component in the middle of\n+            \/\/ button group layout\n@@ -112,1 +116,2 @@\n-            \/\/ Verify that ActionListener is called when a RadioButton is selected using arrow key.\n+            \/\/ Verify that ActionListener is called when a RadioButton is\n+            \/\/ selected using arrow key\n@@ -116,1 +121,4 @@\n-            throw new RuntimeException(\"Error testing LaF: \" + laf.getName(), e);\n+            Throwable cause = e.getCause();\n+            throw new RuntimeException(\"Error testing LaF: \" + laf.getName()\n+                    + (cause != null ? \" - \" + cause.getMessage() : \"\"),\n+                    e);\n@@ -138,1 +146,1 @@\n-        mainFrame = new JFrame(\"Bug 8033699 - 8 Tests for Grouped\/Non Group Radio Buttons\");\n+        mainFrame = new JFrame(\"Radio Button Focus Tests\");\n@@ -143,2 +151,1 @@\n-        JPanel box = new JPanel();\n-        box.setLayout(new BoxLayout(box, BoxLayout.Y_AXIS));\n+        Box box = Box.createVerticalBox();\n@@ -164,4 +171,5 @@\n-        mainFrame.getContentPane().add(btnStart);\n-        mainFrame.getContentPane().add(box);\n-        mainFrame.getContentPane().add(radioBtnSingle);\n-        mainFrame.getContentPane().add(btnEnd);\n+        Box mainBox = Box.createVerticalBox();\n+        mainBox.add(btnStart);\n+        mainBox.add(box);\n+        mainBox.add(radioBtnSingle);\n+        mainBox.add(btnEnd);\n@@ -169,0 +177,1 @@\n+        mainFrame.add(mainBox);\n@@ -173,1 +182,0 @@\n-        mainFrame.setLayout(new BoxLayout(mainFrame.getContentPane(), BoxLayout.Y_AXIS));\n@@ -188,3 +196,5 @@\n-            if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() != radioBtnSingle) {\n-                System.out.println(\"Radio Button Group Go To Next Component through Tab Key failed\");\n-                throw new RuntimeException(\"Focus is not on Radio Button Single as Expected\");\n+            if (focusManager.getFocusOwner() != radioBtnSingle) {\n+                System.out.println(\"Radio Button Group Go To \"\n+                                   + \"Next Component through Tab Key failed\");\n+                throw new RuntimeException(\"Focus is not on \"\n+                                           + \"Radio Button Single as Expected\");\n@@ -195,1 +205,2 @@\n-    \/\/ Non-Grouped Radio button as a single component when traversing through tab key\n+    \/\/ Non-Grouped Radio button as a single component when traversing through\n+    \/\/ tab key\n@@ -199,3 +210,5 @@\n-            if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() != btnEnd) {\n-                System.out.println(\"Non Grouped Radio Button Go To Next Component through Tab Key failed\");\n-                throw new RuntimeException(\"Focus is not on Button End as Expected\");\n+            if (focusManager.getFocusOwner() != btnEnd) {\n+                System.out.println(\"Non Grouped Radio Button Go To \"\n+                                   + \"Next Component through Tab Key failed\");\n+                throw new RuntimeException(\"Focus is not on Button End \"\n+                                            + \"as Expected\");\n@@ -206,1 +219,2 @@\n-    \/\/ Non-Grouped Radio button and Group Radio button as a single component when traversing through shift-tab key\n+    \/\/ Non-Grouped Radio button and Group Radio button as a single component\n+    \/\/ when traversing through shift-tab key\n@@ -212,3 +226,5 @@\n-            if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() != radioBtn1) {\n-                System.out.println(\"Radio button Group\/Non Grouped Radio Button SHIFT-Tab Key Test failed\");\n-                throw new RuntimeException(\"Focus is not on Radio Button A as Expected\");\n+            if (focusManager.getFocusOwner() != radioBtn1) {\n+                System.out.println(\"Radio button Group\/Non Grouped \"\n+                                   + \"Radio Button SHIFT-Tab Key Test failed\");\n+                throw new RuntimeException(\"Focus is not on Radio Button A \"\n+                                           + \"as Expected\");\n@@ -224,3 +240,5 @@\n-            if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() != radioBtn3) {\n-                System.out.println(\"Radio button Group UP\/LEFT Arrow Key Move Focus Failed\");\n-                throw new RuntimeException(\"Focus is not on Radio Button C as Expected\");\n+            if (focusManager.getFocusOwner() != radioBtn3) {\n+                System.out.println(\"Radio button Group UP\/LEFT Arrow Key \"\n+                                   + \"Move Focus Failed\");\n+                throw new RuntimeException(\"Focus is not on Radio Button C \"\n+                                           + \"as Expected\");\n@@ -235,3 +253,5 @@\n-            if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() != radioBtn1) {\n-                System.out.println(\"Radio button Group Left\/Up Arrow Key Move Focus Failed\");\n-                throw new RuntimeException(\"Focus is not on Radio Button A as Expected\");\n+            if (focusManager.getFocusOwner() != radioBtn1) {\n+                System.out.println(\"Radio button Group Left\/Up Arrow Key \"\n+                                   + \"Move Focus Failed\");\n+                throw new RuntimeException(\"Focus is not on Radio Button A \"\n+                                           + \"as Expected\");\n@@ -246,3 +266,5 @@\n-            if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() != radioBtn2) {\n-                System.out.println(\"Radio button Group Circle Back To First Button Test\");\n-                throw new RuntimeException(\"Focus is not on Radio Button B as Expected\");\n+            if (focusManager.getFocusOwner() != radioBtn2) {\n+                System.out.println(\"Radio button Group Circle Back To \"\n+                                   + \"First Button Test\");\n+                throw new RuntimeException(\"Focus is not on Radio Button B \"\n+                                           + \"as Expected\");\n@@ -256,3 +278,5 @@\n-            if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() != btnMiddle) {\n-                System.out.println(\"Separate Component added in button group layout\");\n-                throw new RuntimeException(\"Focus is not on Middle Button as Expected\");\n+            if (focusManager.getFocusOwner() != btnMiddle) {\n+                System.out.println(\"Separate Component added in\"\n+                                   + \" button group layout\");\n+                throw new RuntimeException(\"Focus is not on Middle Button\"\n+                                           + \" as Expected\");\n@@ -266,3 +290,5 @@\n-            if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() != radioBtnSingle) {\n-                System.out.println(\"Separate Component added in button group layout\");\n-                throw new RuntimeException(\"Focus is not on Radio Button Single as Expected\");\n+            if (focusManager.getFocusOwner() != radioBtnSingle) {\n+                System.out.println(\"Separate Component added in\"\n+                                   + \" button group layout\");\n+                throw new RuntimeException(\"Focus is not on Radio Button Single\"\n+                                           + \" as Expected\");\n@@ -273,3 +299,3 @@\n-    private static boolean actRB1 = false;\n-    private static boolean actRB2 = false;\n-    private static boolean actRB3 = false;\n+    private static volatile boolean actRB1 = false;\n+    private static volatile boolean actRB2 = false;\n+    private static volatile boolean actRB3 = false;\n@@ -277,1 +303,2 @@\n-    \/\/ JDK-8226892: Verify that ActionListener is called when a RadioButton is selected using arrow key.\n+    \/\/ JDK-8226892: Verify that ActionListener is called when a RadioButton\n+    \/\/ is selected using arrow key\n@@ -288,3 +315,6 @@\n-        radioBtn1.addActionListener(actLrRB1);\n-        radioBtn2.addActionListener(actLrRB2);\n-        radioBtn3.addActionListener(actLrRB3);\n+        \/\/ Adding Action Listeners\n+        SwingUtilities.invokeAndWait(() -> {\n+            radioBtn1.addActionListener(actLrRB1);\n+            radioBtn2.addActionListener(actLrRB2);\n+            radioBtn3.addActionListener(actLrRB3);\n+        });\n@@ -296,1 +326,2 @@\n-        String failMessage = \"ActionListener not invoked when selected using arrow key.\";\n+        String failMessage = \"ActionListener not invoked when selected using \"\n+                             + \"arrow key.\";\n@@ -307,3 +338,6 @@\n-        radioBtn1.removeActionListener(actLrRB1);\n-        radioBtn2.removeActionListener(actLrRB2);\n-        radioBtn3.removeActionListener(actLrRB3);\n+        \/\/ Removing Action Listeners\n+        SwingUtilities.invokeAndWait(() -> {\n+            radioBtn1.removeActionListener(actLrRB1);\n+            radioBtn2.removeActionListener(actLrRB2);\n+            radioBtn3.removeActionListener(actLrRB3);\n+        });\n","filename":"test\/jdk\/javax\/swing\/JRadioButton\/8033699\/bug8033699.java","additions":86,"deletions":52,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,5 +33,2 @@\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.constant.*;\n@@ -40,0 +37,5 @@\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n@@ -44,1 +46,1 @@\n-import jdk.internal.classfile.impl.AbstractPoolEntry;\n+import jdk.internal.classfile.impl.Util;\n@@ -49,0 +51,1 @@\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -91,1 +94,2 @@\n-        record CondyBoot(MethodHandles.Lookup lookup, String name, Class<?> type) {}\n+        record CondyBoot(MethodHandles.Lookup lookup, String name, Class<?> type) {\n+        }\n@@ -168,0 +172,212 @@\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalityCases\")\n+    <T, P extends PoolEntry> void testAsSymbolEquality(ValidSymbolCase<T, P> validSymbolCase, String entryState, P p) {\n+        var asSymbol = validSymbolCase.translator.extractor.apply(p);\n+        assertEquals(validSymbolCase.sym, asSymbol, \"asSym vs sym\");\n+        assertEquals(validSymbolCase.other, asSymbol, \"asSym vs other sym\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalityCases\")\n+    <T, P extends PoolEntry> void testMatchesOriginalEquality(ValidSymbolCase<T, P> validSymbolCase, String entryState, P p) {\n+        assertTrue(validSymbolCase.translator.tester.test(p, validSymbolCase.sym));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalityCases\")\n+    <T, P extends PoolEntry> void testMatchesEquivalentEquality(ValidSymbolCase<T, P> validSymbolCase, String entryState, P p) {\n+        assertTrue(validSymbolCase.translator.tester.test(p, validSymbolCase.other));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inequalityCases\")\n+    <T, P extends PoolEntry> void testAsSymbolInequality(ValidSymbolCase<T, P> validSymbolCase, String stateName, P p) {\n+        var asSymbol = validSymbolCase.translator.extractor.apply(p);\n+        assertEquals(validSymbolCase.sym, asSymbol, \"asSymbol vs original\");\n+        assertNotEquals(validSymbolCase.other, asSymbol, \"asSymbol vs inequal\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inequalityCases\")\n+    <T, P extends PoolEntry> void testMatchesOriginalInequality(ValidSymbolCase<T, P> validSymbolCase, String stateName, P p) {\n+        assertTrue(validSymbolCase.translator.tester.test(p, validSymbolCase.sym));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inequalityCases\")\n+    <T, P extends PoolEntry> void testMatchesNonEquivalentInequality(ValidSymbolCase<T, P> validSymbolCase, String stateName, P p) {\n+        assertFalse(validSymbolCase.translator.tester.test(p, validSymbolCase.other));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"malformedCases\")\n+    <T, P extends PoolEntry> void testAsSymbolMalformed(InvalidSymbolCase<T, P> baseCase, String entryState, P p) {\n+        assertThrows(IllegalArgumentException.class, () -> baseCase.translator.extractor.apply(p));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"malformedCases\")\n+    <T, P extends PoolEntry> void testMatchesMalformed(InvalidSymbolCase<T, P> baseCase, String entryState, P p) {\n+        assertFalse(baseCase.translator.tester.test(p, baseCase.target));\n+    }\n+\n+    \/\/ Support for complex pool entry creation with different inflation states.\n+    \/\/ Inflation states include:\n+    \/\/   - bound\/unbound,\n+    \/\/   - asSymbol()\n+    \/\/   - matches() resulting in match\n+    \/\/   - matches() resulting in mismatch\n+\n+    \/\/ a pool entry, suitable for testing lazy behaviors and has descriptive name\n+    record StatefulPoolEntry<P>(String desc, Supplier<P> factory) {\n+    }\n+\n+    \/\/ Test pool entry <-> nominal descriptor, also the equals methods\n+    record SymbolicTranslator<T, P extends PoolEntry>(String name, BiFunction<ConstantPoolBuilder, T, P> writer,\n+                                                      BiPredicate<P, T> tester, Function<P, T> extractor) {\n+        private P createUnboundEntry(T symbol) {\n+            ConstantPoolBuilder cpb = ConstantPoolBuilder.of(); \/\/ Temp pool does not support some entries\n+            return writer.apply(cpb, symbol);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private P toBoundEntry(P unboundEntry) {\n+            ConstantPoolBuilder cpb = (ConstantPoolBuilder) unboundEntry.constantPool();\n+            int index = unboundEntry.index();\n+            var bytes = ClassFile.of().build(cpb.classEntry(ClassDesc.of(\"Test\")), cpb, _ -> {\n+            });\n+            return (P) ClassFile.of().parse(bytes).constantPool().entryByIndex(index);\n+        }\n+\n+        \/\/ Spawn entries to test from a nominal descriptor\n+        public Stream<StatefulPoolEntry<P>> entriesSpawner(T original) {\n+            return spawnBounded(() -> this.createUnboundEntry(original));\n+        }\n+\n+        \/\/ Spawn additional bound entries to test from an initial unbound entry\n+        public Stream<StatefulPoolEntry<P>> spawnBounded(Supplier<P> original) {\n+            return Stream.of(new StatefulPoolEntry<>(original.get().toString(), original))\n+                    .mapMulti((s, sink) -> {\n+                        sink.accept(s); \/\/ unbound\n+                        sink.accept(new StatefulPoolEntry<>(s.desc + \"+lazy\", () -> toBoundEntry(s.factory.get()))); \/\/ bound\n+                    });\n+        }\n+\n+        \/\/ Add extra stage of entry spawn to \"inflate\" entries via positive\/negative tests\n+        public StatefulPoolEntry<P> inflateByMatching(StatefulPoolEntry<P> last, T arg, String msg) {\n+            return new StatefulPoolEntry<>(\"+matches(\" + msg + \")\", () -> {\n+                var ret = last.factory.get();\n+                tester.test(ret, arg);\n+                return ret;\n+            });\n+        }\n+\n+        \/\/ Add extra stage of entry spawn to \"inflate\" entries via descriptor computation\n+        \/\/ This should not be used if the pool entry may be invalid (i.e. throws IAE)\n+        public StatefulPoolEntry<P> inflateByComputeSymbol(StatefulPoolEntry<P> last) {\n+            return new StatefulPoolEntry<>(last.desc + \"+asSymbol()\", () -> {\n+                var ret = last.factory.get();\n+                extractor.apply(ret);\n+                return ret;\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name; \/\/ don't include lambda garbage in failure reports\n+        }\n+    }\n+\n+    \/\/ A case testing valid symbol sym; other is another symbol that may match or mismatch.\n+    record ValidSymbolCase<T, P extends PoolEntry>(SymbolicTranslator<T, P> translator, T sym, T other) {\n+    }\n+\n+    \/\/ Current supported conversions\n+    static final SymbolicTranslator<String, Utf8Entry> UTF8_STRING_TRANSLATOR = new SymbolicTranslator<>(\"Utf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::equalsString, Utf8Entry::stringValue);\n+    static final SymbolicTranslator<ClassDesc, Utf8Entry> UTF8_CLASS_TRANSLATOR = new SymbolicTranslator<>(\"FieldTypeUtf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::isFieldType, Util::fieldTypeSymbol);\n+    static final SymbolicTranslator<MethodTypeDesc, Utf8Entry> UTF8_METHOD_TYPE_TRANSLATOR = new SymbolicTranslator<>(\"MethodTypeUtf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::isMethodType, Util::methodTypeSymbol);\n+    static final SymbolicTranslator<ClassDesc, ClassEntry> CLASS_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"ClassEntry\", ConstantPoolBuilder::classEntry, ClassEntry::matches, ClassEntry::asSymbol);\n+    static final SymbolicTranslator<MethodTypeDesc, MethodTypeEntry> METHOD_TYPE_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"MethodTypeEntry\", ConstantPoolBuilder::methodTypeEntry, MethodTypeEntry::matches, MethodTypeEntry::asSymbol);\n+    static final SymbolicTranslator<String, StringEntry> STRING_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"StringEntry\", ConstantPoolBuilder::stringEntry, StringEntry::equalsString, StringEntry::stringValue);\n+    static final SymbolicTranslator<PackageDesc, PackageEntry> PACKAGE_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"PackageEntry\", ConstantPoolBuilder::packageEntry, PackageEntry::matches, PackageEntry::asSymbol);\n+    static final SymbolicTranslator<ModuleDesc, ModuleEntry> MODULE_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"ModuleEntry\", ConstantPoolBuilder::moduleEntry, ModuleEntry::matches, ModuleEntry::asSymbol);\n+\n+    \/\/ Create arguments of tuple (ValidSymbolCase, entryState, PoolEntry) to verify symbolic behavior of pool entries\n+    \/\/ with particular inflation states\n+    static <T, P extends PoolEntry> void specializeInflation(ValidSymbolCase<T, P> validSymbolCase, Consumer<Arguments> callArgs) {\n+        validSymbolCase.translator.entriesSpawner(validSymbolCase.sym)\n+                .<StatefulPoolEntry<P>>mapMulti((src, sink) -> {\n+                    sink.accept(src);\n+                    sink.accept(validSymbolCase.translator.inflateByMatching(src, validSymbolCase.sym, \"same symbol\"));\n+                    sink.accept(validSymbolCase.translator.inflateByMatching(src, validSymbolCase.other, \"another symbol\"));\n+                    sink.accept(validSymbolCase.translator.inflateByComputeSymbol(src));\n+                })\n+                .forEach(stateful -> callArgs.accept(Arguments.of(validSymbolCase, stateful.desc, stateful.factory.get())));\n+    }\n+\n+    static Stream<Arguments> equalityCases() {\n+        return Stream.of(\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/Object\")), \/\/ class or interface\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/Object;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_int, ClassDesc.ofDescriptor(\"I\")), \/\/ primitive\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/Object\")), \/\/ class or interface\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/Object;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_STRING_TRANSLATOR, \"Ab\\u0000c\", \"Ab\\u0000c\"),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MTD_void, MethodTypeDesc.ofDescriptor(\"()V\")),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MethodTypeDesc.of(CD_int, CD_Long), MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Long;)I\")),\n+                new ValidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, MethodTypeDesc.of(CD_Object), MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/Object;\")),\n+                new ValidSymbolCase<>(STRING_ENTRY_TRANSLATOR, \"Ape\", new String(\"Ape\".getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8)),\n+                new ValidSymbolCase<>(PACKAGE_ENTRY_TRANSLATOR, PackageDesc.of(\"java.lang\"), PackageDesc.ofInternalName(\"java\/lang\")),\n+                new ValidSymbolCase<>(MODULE_ENTRY_TRANSLATOR, ModuleDesc.of(\"java.base\"), ModuleDesc.of(new String(\"java.base\".getBytes(StandardCharsets.US_ASCII), StandardCharsets.US_ASCII)))\n+        ).mapMulti(ConstantDescSymbolsTest::specializeInflation);\n+    }\n+\n+    static Stream<Arguments> inequalityCases() {\n+        return Stream.of(\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/io\/Object\")), \/\/ class or interface\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/String;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_int, ClassDesc.ofDescriptor(\"S\")), \/\/ primitive\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/String\")), \/\/ class or interface\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/System;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_STRING_TRANSLATOR, \"Ab\\u0000c\", \"Abdc\"),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MTD_void, MethodTypeDesc.ofDescriptor(\"()I\")),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MethodTypeDesc.of(CD_int, CD_Short), MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Long;)I\")),\n+                new ValidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, MethodTypeDesc.of(CD_String), MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/Object;\")),\n+                new ValidSymbolCase<>(STRING_ENTRY_TRANSLATOR, \"Cat\", new String(\"Ape\".getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8)),\n+                new ValidSymbolCase<>(PACKAGE_ENTRY_TRANSLATOR, PackageDesc.of(\"java.lang\"), PackageDesc.ofInternalName(\"java\/util\")),\n+                new ValidSymbolCase<>(MODULE_ENTRY_TRANSLATOR, ModuleDesc.of(\"java.base\"), ModuleDesc.of(new String(\"java.desktop\".getBytes(StandardCharsets.US_ASCII), StandardCharsets.US_ASCII)))\n+        ).mapMulti(ConstantDescSymbolsTest::specializeInflation);\n+    }\n+\n+    record InvalidSymbolCase<T, P extends PoolEntry>(SymbolicTranslator<T, P> translator, Supplier<P> factory, T target) {\n+    }\n+\n+    \/\/ Type hint function\n+    private static <P extends PoolEntry> Supplier<P> badFactory(Function<ConstantPoolBuilder, P> func) {\n+        return () -> func.apply(ConstantPoolBuilder.of());\n+    }\n+\n+    static <T, P extends PoolEntry> void specializeInflation(InvalidSymbolCase<T, P> invalidSymbolCase, Consumer<Arguments> callArgs) {\n+        invalidSymbolCase.translator.spawnBounded(invalidSymbolCase.factory)\n+                .<StatefulPoolEntry<P>>mapMulti((src, sink) -> {\n+                    sink.accept(src);\n+                    sink.accept(invalidSymbolCase.translator.inflateByMatching(src, invalidSymbolCase.target, \"target\"));\n+                })\n+                .forEach(stateful -> callArgs.accept(Arguments.of(invalidSymbolCase, stateful.desc, stateful.factory.get())));\n+    }\n+\n+    static Stream<Arguments> malformedCases() {\n+        return Stream.of(\n+                new InvalidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, badFactory(b -> b.classEntry(b.utf8Entry(\"java.lang.Object\"))), CD_Object), \/\/ class or interface\n+                new InvalidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, badFactory(b -> b.classEntry(b.utf8Entry(\"[Ljava\/lang\/String\"))), CD_String.arrayType()), \/\/ array\n+                new InvalidSymbolCase<>(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"int\")), ClassDesc.ofDescriptor(\"I\")), \/\/ primitive\n+                new InvalidSymbolCase<>(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"Ljava\/lang\/String\")), CD_String), \/\/ class or interface\n+                new InvalidSymbolCase<>(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"[Ljava\/lang\/String\")), CD_String.arrayType()), \/\/ array\n+                new InvalidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, badFactory(b -> b.methodTypeEntry(b.utf8Entry(\"()\"))), MTD_void),\n+                new InvalidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, badFactory(b -> b.methodTypeEntry(b.utf8Entry(\"(V)\"))), MTD_void),\n+                new InvalidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, badFactory(b -> b.utf8Entry(\"()Ljava\/lang\/String\")), MethodTypeDesc.of(CD_String)),\n+                new InvalidSymbolCase<>(PACKAGE_ENTRY_TRANSLATOR, badFactory(b -> b.packageEntry(b.utf8Entry(\"java.lang\"))), PackageDesc.of(\"java.lang\")),\n+                new InvalidSymbolCase<>(MODULE_ENTRY_TRANSLATOR, badFactory(b -> b.moduleEntry(b.utf8Entry(\"java@base\"))), ModuleDesc.of(\"java.base\"))\n+        ).mapMulti(ConstantDescSymbolsTest::specializeInflation);\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":224,"deletions":8,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+    private static final int ARGS_ATTEMPTS = 10;\n@@ -178,2 +179,0 @@\n-        private static final int ARGS_ATTEMPTS = 3;\n-\n@@ -207,1 +206,4 @@\n-                    System.out.println(\"hasMainArgs(\" + id + \"): \" + e);\n+                    \/\/ Only log if something else, to avoid filling log:\n+                    if (!e.getMessage().contains(\"Could not attach\")) {\n+                        System.out.println(\"hasMainArgs(\" + id + \"): \" + e);\n+                    }\n@@ -252,3 +254,0 @@\n-            String timeoutFactorText = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-            double timeoutFactor = Double.parseDouble(timeoutFactorText);\n-            long timeoutNanos = 1000_000_000L*(long)(1000*timeoutFactor);\n@@ -256,0 +255,1 @@\n+            System.out.println(\"Waiting for \" + path + \" to be removed\");\n@@ -259,1 +259,0 @@\n-                System.out.println(\"Waiting for \" + path + \" to be removed, \" + waited + \" ns\");\n@@ -261,0 +260,1 @@\n+                    System.out.println(\"waitForRemoval: \" + path + \" has been removed in \" + waited + \" ns\");\n@@ -263,6 +263,0 @@\n-                if (waited > timeoutNanos) {\n-                    System.out.println(\"Start: \" + start);\n-                    System.out.println(\"Now: \" + now);\n-                    System.out.println(\"Process timed out after \" + waited + \" ns. Abort.\");\n-                    System.exit(1);\n-                }\n","filename":"test\/jdk\/sun\/jvmstat\/monitor\/MonitoredVm\/MonitorVmStartTerminate.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *      8321408 8316138 8341057 8303770\n+ *      8321408 8316138 8341057 8303770 8350498\n@@ -50,1 +50,1 @@\n-    private static final int COUNT = 111;\n+    private static final int COUNT = 109;\n@@ -55,1 +55,1 @@\n-            = \"F1:A9:C7:FE:48:ED:D7:AF:84:C8:9D:C3:88:8D:A3:C8:45:E5:37:4D:B9:18:86:97:AE:CF:6D:41:E6:0E:FB:1B\";\n+            = \"BD:6B:AB:BB:17:87:0D:D5:8D:53:D3:63:A5:DD:70:57:0F:4E:D3:57:4F:E5:FB:05:41:1C:A9:6E:B0:BF:79:38\";\n@@ -72,4 +72,0 @@\n-            put(\"camerfirmachambersignca [jdk]\",\n-                    \"13:63:35:43:93:34:A7:69:80:16:A0:D3:24:DE:72:28:4E:07:9D:7B:52:20:BB:8F:BD:74:78:16:EE:BE:BA:CA\");\n-            put(\"camerfirmachamberscommerceca [jdk]\",\n-                    \"0C:25:8A:12:A5:67:4A:EF:25:F2:8B:A7:DC:FA:EC:EE:A3:48:E5:41:E6:F5:CC:4E:E6:3B:71:B3:61:60:6A:C3\");\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8350582\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n+ * @summary Correct the parsing of the ssl value in javax.net.debug\n+ * @run junit DebugPropertyValuesTest\n+ *\/\n+\n+\/\/ A test to verify debug output for different javax.net.debug scenarios\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class DebugPropertyValuesTest extends SSLSocketTemplate {\n+\n+    private static final Path LOG_FILE = Path.of(\"logging.conf\");\n+    private static final HashMap<String, List<String>> debugMessages = new HashMap<>();\n+\n+    static {\n+        debugMessages.put(\"handshake\",\n+                List.of(\"Produced ClientHello handshake message\",\n+                        \"supported_versions\"));\n+        debugMessages.put(\"keymanager\", List.of(\"choosing key:\"));\n+        debugMessages.put(\"packet\", List.of(\"Raw write\"));\n+        debugMessages.put(\"plaintext\", List.of(\"Plaintext before ENCRYPTION\"));\n+        debugMessages.put(\"record\", List.of(\"handshake, length =\", \"WRITE:\"));\n+        debugMessages.put(\"session\", List.of(\"Session initialized:\"));\n+        debugMessages.put(\"sslctx\", List.of(\"trigger seeding of SecureRandom\"));\n+        debugMessages.put(\"ssl\", List.of(\"jdk.tls.keyLimits:\"));\n+        debugMessages.put(\"trustmanager\", List.of(\"adding as trusted certificates\"));\n+        debugMessages.put(\"verbose\", List.of(\"Ignore unsupported cipher suite:\"));\n+        debugMessages.put(\"handshake-expand\",\n+                List.of(\"\\\"logger\\\".*: \\\"javax.net.ssl\\\",\",\n+                        \"\\\"message\\\".*: \\\"Produced ClientHello handshake message\"));\n+        debugMessages.put(\"record-expand\",\n+                List.of(\"\\\"logger\\\".*: \\\"javax.net.ssl\\\",\",\n+                        \"\\\"message\\\".*: \\\"READ: TLSv1.2 application_data\"));\n+        debugMessages.put(\"help\",\n+                List.of(\"print the help messages\",\n+                        \"debugging can be widened with:\"));\n+        debugMessages.put(\"javax.net.debug\",\n+                List.of(\"properties: Initial security property:\",\n+                        \"certpath: Cert path validation succeeded\"));\n+        debugMessages.put(\"logger\",\n+                List.of(\"FINE: adding as trusted certificates\",\n+                        \"FINE: WRITE: TLSv1.3 application_data\"));\n+    }\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        Files.writeString(LOG_FILE, \".level = ALL\\n\" +\n+                \"handlers= java.util.logging.ConsoleHandler\\n\" +\n+                \"java.util.logging.ConsoleHandler.level = ALL\\n\");\n+    }\n+\n+    private static Stream<Arguments> patternMatches() {\n+        return Stream.of(\n+                \/\/ all should print everything\n+                Arguments.of(List.of(\"-Djavax.net.debug=all\"),\n+                        List.of(\"handshake\", \"keymanager\", \"packet\",\n+                                \"plaintext\", \"record\", \"session\", \"ssl\",\n+                                \"sslctx\", \"trustmanager\", \"verbose\")),\n+                \/\/ ssl should print most details except verbose details\n+                Arguments.of(List.of(\"-Djavax.net.debug=ssl\"),\n+                        List.of(\"handshake\", \"keymanager\",\n+                                \"record\", \"session\", \"ssl\",\n+                                \"sslctx\", \"trustmanager\", \"verbose\")),\n+                \/\/ allow expand option for more verbose output\n+                Arguments.of(List.of(\"-Djavax.net.debug=ssl,handshake,expand\"),\n+                        List.of(\"handshake\", \"handshake-expand\", \"keymanager\",\n+                                \"record\", \"session\", \"record-expand\", \"ssl\",\n+                                \"sslctx\", \"trustmanager\", \"verbose\")),\n+                \/\/ filtering on record option, with expand\n+                Arguments.of(List.of(\"-Djavax.net.debug=ssl:record,expand\"),\n+                        List.of(\"handshake\", \"handshake-expand\", \"keymanager\",\n+                                \"record\", \"record-expand\", \"session\", \"ssl\",\n+                                \"sslctx\", \"trustmanager\", \"verbose\")),\n+                \/\/ this test is equivalent to ssl:record mode\n+                Arguments.of(List.of(\"-Djavax.net.debug=ssl,record\"),\n+                        List.of(\"handshake\", \"keymanager\", \"record\",\n+                                \"session\", \"ssl\", \"sslctx\",\n+                                \"trustmanager\", \"verbose\")),\n+                \/\/ example of test where no \"ssl\" value is passed\n+                \/\/ handshake debugging with verbose mode\n+                \/\/ only verbose gets printed. Needs fixing (JDK-8044609)\n+                Arguments.of(List.of(\"-Djavax.net.debug=handshake:verbose\"),\n+                        List.of(\"verbose\")),\n+                \/\/ another example of test where no \"ssl\" value is passed\n+                Arguments.of(List.of(\"-Djavax.net.debug=record\"),\n+                        List.of(\"record\")),\n+                \/\/ ignore bad sub-option. treat like \"ssl\"\n+                Arguments.of(List.of(\"-Djavax.net.debug=ssl,typo\"),\n+                        List.of(\"handshake\", \"keymanager\",\n+                                \"record\", \"session\", \"ssl\",\n+                                \"sslctx\", \"trustmanager\", \"verbose\")),\n+                \/\/ ssltypo contains \"ssl\". Treat like \"ssl\"\n+                Arguments.of(List.of(\"-Djavax.net.debug=ssltypo\"),\n+                        List.of(\"handshake\", \"keymanager\",\n+                                \"record\", \"session\", \"ssl\",\n+                                \"sslctx\", \"trustmanager\", \"verbose\")),\n+                \/\/ plaintext is valid for record option\n+                Arguments.of(List.of(\"-Djavax.net.debug=ssl:record:plaintext\"),\n+                        List.of(\"handshake\", \"keymanager\", \"plaintext\",\n+                                \"record\", \"session\", \"ssl\",\n+                                \"sslctx\", \"trustmanager\", \"verbose\")),\n+                Arguments.of(List.of(\"-Djavax.net.debug=ssl:trustmanager\"),\n+                        List.of(\"handshake\", \"keymanager\", \"record\", \"session\",\n+                                \"ssl\", \"sslctx\", \"trustmanager\", \"verbose\")),\n+                Arguments.of(List.of(\"-Djavax.net.debug=ssl:sslctx\"),\n+                        List.of(\"handshake\", \"keymanager\", \"record\", \"session\",\n+                                \"ssl\", \"sslctx\", \"trustmanager\", \"verbose\")),\n+                \/\/ help message test. Should exit without running test\n+                Arguments.of(List.of(\"-Djavax.net.debug=help\"),\n+                        List.of(\"help\")),\n+                \/\/ add in javax.net.debug sanity test\n+                Arguments.of(List.of(\"-Djavax.net.debug=ssl:trustmanager\",\n+                                \"-Djava.security.debug=all\"),\n+                        List.of(\"handshake\", \"javax.net.debug\", \"keymanager\",\n+                                \"record\", \"session\", \"ssl\", \"sslctx\",\n+                                \"trustmanager\", \"verbose\")),\n+                \/\/ empty invokes System.Logger use\n+                Arguments.of(List.of(\"-Djavax.net.debug\",\n+                        \"-Djava.util.logging.config.file=\" + LOG_FILE),\n+                        List.of(\"handshake\", \"keymanager\", \"logger\", \"packet\",\n+                                \"plaintext\", \"record\", \"session\", \"ssl\",\n+                                \"sslctx\", \"trustmanager\", \"verbose\"))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"patternMatches\")\n+    public void checkDebugOutput(List<String> params,\n+                                 List<String> expected) throws Exception {\n+\n+        List<String> args = new ArrayList<>(params);\n+        args.add(\"DebugPropertyValuesTest\");\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(args);\n+        outputAnalyzer.shouldHaveExitValue(0);\n+        for (String s : debugMessages.keySet()) {\n+            for (String output : debugMessages.get(s)) {\n+                if (expected.contains(s)) {\n+                    outputAnalyzer.shouldMatch(output);\n+                } else {\n+                    outputAnalyzer.shouldNotMatch(output);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLLogger\/DebugPropertyValuesTest.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @bug 8274736 8277970\n+ * @bug 8274736 8277970 8355262\n@@ -288,1 +288,1 @@\n-        \/\/ Try to accept a connection in 5 seconds.\n+        \/\/ Try to accept a connection in 10 seconds.\n@@ -354,1 +354,1 @@\n-            socket.setSoTimeout(5000);\n+            socket.setSoTimeout(10000);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/NoInvalidateSocketException.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import javax.net.ssl.X509TrustManager;\n@@ -26,3 +27,4 @@\n-import java.time.*;\n-import java.util.*;\n-import javax.net.ssl.*;\n+import java.time.LocalDate;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n@@ -30,1 +32,1 @@\n-\/**\n+\/*\n@@ -32,1 +34,1 @@\n- * @bug 8346587\n+ * @bug 8346587 8350498\n@@ -34,1 +36,1 @@\n- *          Camerfirma roots are invalid\n+ *          Camerfirma root are invalid\n@@ -45,1 +47,1 @@\n-    private static final String certPath = \"chains\" + File.separator + \"camerfirma\";\n+    private static final String CERT_PATH = \"chains\" + File.separator + \"camerfirma\";\n@@ -49,3 +51,1 @@\n-    private static String[] rootsToTest = new String[] {\n-            \"camerfirmachamberscommerceca\", \"camerfirmachambersca\",\n-            \"camerfirmachambersignca\"};\n+    private static final String ROOT_TO_TEST = \"camerfirmachambersca\";\n@@ -59,1 +59,1 @@\n-        \/\/ All of the test certificates are signed with SHA-1 so we need\n+        \/\/ All the test certificates are signed with SHA-1, so we need\n@@ -73,1 +73,1 @@\n-        distrust.testCertificateChain(certPath, notBefore, tms, rootsToTest);\n+        distrust.testCertificateChain(CERT_PATH, notBefore, tms, ROOT_TO_TEST);\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/Camerfirma.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-Owner:   CN=AC Camerfirma Certificados Camerales,\n-         O=AC Camerfirma SA, SERIALNUMBER=A82743287,\n-         L=Madrid (see current address at www.camerfirma.com\/address),\n-         EMAILADDRESS=ac_camerfirma_cc@camerfirma.com, C=ES\n-Issuer:  CN=Chambers of Commerce Root, OU=http:\/\/www.chambersign.org,\n-         O=AC Camerfirma SA CIF A82743287, C=EU\n-Serial number: 5\n-Valid from: Mon Feb 09 07:42:47 PST 2004 until: Thu Feb 09 07:42:47 PST 2034\n-Certificate fingerprints:\n-         SHA1: 9F:36:B4:BE:9D:AF:1C:91:01:B2:D7:61:58:FB:95:CB:53:82:01:10\n-         SHA256: C7:D8:43:81:E1:1F:7C:57:46:77:1A:F5:B0:50:DC:51:FC:6F:DA:D6:F6:F3:5B:B5:3A:3D:E9:13:82:2E:A0:9E\n-Signature algorithm name: SHA1withRSA (weak)\n-Subject Public Key Algorithm: 2048-bit RSA key\n-Version: 3\n-\n------BEGIN CERTIFICATE-----\n-MIIFwDCCBKigAwIBAgIBBTANBgkqhkiG9w0BAQUFADB\/MQswCQYDVQQGEwJFVTEn\n-MCUGA1UEChMeQUMgQ2FtZXJmaXJtYSBTQSBDSUYgQTgyNzQzMjg3MSMwIQYDVQQL\n-ExpodHRwOi8vd3d3LmNoYW1iZXJzaWduLm9yZzEiMCAGA1UEAxMZQ2hhbWJlcnMg\n-b2YgQ29tbWVyY2UgUm9vdDAeFw0wNDAyMDkxNTQyNDdaFw0zNDAyMDkxNTQyNDda\n-MIHgMQswCQYDVQQGEwJFUzEuMCwGCSqGSIb3DQEJARYfYWNfY2FtZXJmaXJtYV9j\n-Y0BjYW1lcmZpcm1hLmNvbTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3VycmVudCBh\n-ZGRyZXNzIGF0IHd3dy5jYW1lcmZpcm1hLmNvbS9hZGRyZXNzKTESMBAGA1UEBRMJ\n-QTgyNzQzMjg3MRkwFwYDVQQKExBBQyBDYW1lcmZpcm1hIFNBMS0wKwYDVQQDEyRB\n-QyBDYW1lcmZpcm1hIENlcnRpZmljYWRvcyBDYW1lcmFsZXMwggEgMA0GCSqGSIb3\n-DQEBAQUAA4IBDQAwggEIAoIBAQCjxnvvj01f36lgGhihRYVf1fAPEXsTJKrY4aLQ\n-cEUSh5szZE7VTtGiyMTMc2uCmnaXafjYHK8Lgmy6T9xxGEZ5OS4x6rgtuPyy13AP\n-tu3X3Y2kPVLu7ZMw5HoQC64wBj6YcnxTnBwmVW05DjzRXp6OyBIEKEaAB9vv2qEl\n-fh\/Y234FG6Wd\/ut1s0ScRZAo+6CSMNQxaY+ryXKD11uWkzWXJa9UZOasG7z4uPqc\n-Gr4\/Hz2\/CTLDTgp0xkMJYuzOztpUvOACrxlkS2utKUwVlAikJnboNwf\/en94RbHN\n-zkKc5t0SAbzCf57ueawbzxSdPa+SAC25FNur64FKkfdq5PPjAgEDo4IB5TCCAeEw\n-EgYDVR0TAQH\/BAgwBgEB\/wIBCzA8BgNVHR8ENTAzMDGgL6AthitodHRwOi8vY3Js\n-LmNoYW1iZXJzaWduLm9yZy9jaGFtYmVyc3Jvb3QuY3JsMB0GA1UdDgQWBBS2H06d\n-HGiRLjdyYOFGj1qlKjExuTCBqwYDVR0jBIGjMIGggBTjlPWxTenboSlbV4tNdgZ2\n-4dGiiqGBhKSBgTB\/MQswCQYDVQQGEwJFVTEnMCUGA1UEChMeQUMgQ2FtZXJmaXJt\n-YSBTQSBDSUYgQTgyNzQzMjg3MSMwIQYDVQQLExpodHRwOi8vd3d3LmNoYW1iZXJz\n-aWduLm9yZzEiMCAGA1UEAxMZQ2hhbWJlcnMgb2YgQ29tbWVyY2UgUm9vdIIBADAO\n-BgNVHQ8BAf8EBAMCAYYwKgYDVR0RBCMwIYEfYWNfY2FtZXJmaXJtYV9jY0BjYW1l\n-cmZpcm1hLmNvbTAnBgNVHRIEIDAegRxjaGFtYmVyc3Jvb3RAY2hhbWJlcnNpZ24u\n-b3JnMFsGA1UdIARUMFIwUAYLKwYBBAGBhy4KCQEwQTA\/BggrBgEFBQcCARYzaHR0\n-cDovL2Nwcy5jYW1lcmZpcm1hLmNvbS9jcHMvYWNfY2FtZXJmaXJtYV9jYy5odG1s\n-MA0GCSqGSIb3DQEBBQUAA4IBAQBl8KoPBYL\/\/EBonqQWS0N+hLfxImP1eQ6nac+v\n-R5QfF\/0w+VCTkShfKwHaa6V\/W1dPlVwXSECuvXHkX6DYrtxFGGFB6qxuP1rkIpRs\n-sTkAlpvOx3REiFjIkhsijKd\/ijvqxjbMbuYU+EFACK\/jQIRoj+LEEZ+haiqbALZB\n-Iqq\/26HTqX0itDosBj6M94YWcIpbTDefQNWCGsSnZcw2+k+az\/wAOZT6xAxlnEim\n-HpDDlgRsmaLrHpDPDoIRYOih0gbJTnn4mKex9Wgr0sZ+XFl03j+bvcXL1tiuQnwb\n-9dMRDe\/OdXABT35W4ZzLbpost65ZW3Tx+oi\/bLbmu6pbKCgs\n------END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/camerfirma\/camerfirmachamberscommerceca-chain.pem","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-Owner:   CN=AC Camerfirma - 2009,\n-         L=Madrid (see current address at https:\/\/www.camerfirma.com\/address),\n-         SERIALNUMBER=A82743287, O=AC Camerfirma S.A., C=ES\n-Issuer:  CN=Global Chambersign Root - 2008,\n-         O=AC Camerfirma S.A., SERIALNUMBER=A82743287,\n-         L=Madrid (see current address at www.camerfirma.com\/address), C=EU\n-Serial number: 2\n-Valid from: Mon Mar 16 10:16:25 PDT 2009 until: Sun Mar 11 10:16:25 PDT 2029\n-Certificate fingerprints:\n-         SHA1: BA:BA:69:CF:D5:CC:C9:4D:05:6B:5B:E7:80:5F:E2:03:CB:EB:5C:57\n-         SHA256: B6:8D:5D:9B:4E:A6:35:95:7C:0C:32:15:C2:0D:35:B2:21:7B:69:E3:49:C7:A3:04:C4:F9:7F:20:C4:08:1F:88\n-Signature algorithm name: SHA1withRSA (weak)\n-Subject Public Key Algorithm: 4096-bit RSA key\n-Version: 3\n-\n------BEGIN CERTIFICATE-----\n-MIIIPzCCBiegAwIBAgIBAjANBgkqhkiG9w0BAQUFADCBrDELMAkGA1UEBhMCRVUx\n-QzBBBgNVBAcTOk1hZHJpZCAoc2VlIGN1cnJlbnQgYWRkcmVzcyBhdCB3d3cuY2Ft\n-ZXJmaXJtYS5jb20vYWRkcmVzcykxEjAQBgNVBAUTCUE4Mjc0MzI4NzEbMBkGA1UE\n-ChMSQUMgQ2FtZXJmaXJtYSBTLkEuMScwJQYDVQQDEx5HbG9iYWwgQ2hhbWJlcnNp\n-Z24gUm9vdCAtIDIwMDgwHhcNMDkwMzE2MTcxNjI1WhcNMjkwMzExMTcxNjI1WjCB\n-qjELMAkGA1UEBhMCRVMxGzAZBgNVBAoTEkFDIENhbWVyZmlybWEgUy5BLjESMBAG\n-A1UEBRMJQTgyNzQzMjg3MUswSQYDVQQHE0JNYWRyaWQgKHNlZSBjdXJyZW50IGFk\n-ZHJlc3MgYXQgaHR0cHM6Ly93d3cuY2FtZXJmaXJtYS5jb20vYWRkcmVzcykxHTAb\n-BgNVBAMTFEFDIENhbWVyZmlybWEgLSAyMDA5MIICIjANBgkqhkiG9w0BAQEFAAOC\n-Ag8AMIICCgKCAgEAmbHxFEYTJmMdPcYiPlWUGZu2+tQo4voohYi3dwCwoVuGdHSp\n-kyoqs1B3YGx4u5KT4n0A7+Bb8YQ\/QzbNy7UQ4JXAK+rT8JpNeKIvfN4lHnQJaChE\n-4fdn0KpvHWymaNq2k+EbQClquZB6OsTLvsivwSuSnyLcUw5rbajj53wq77fwB12y\n-phMjwz2AnD1BvHZd3vLOaH1jRQP3zzNmyjT\/Oj6+jdux7SBKlJWgQEaKflwcvYyc\n-DPFPhGM4KPwEGX61PCrS+l8Lw0Kdy6K4lE+GrfgJrXM5m1Ey1R0c9McYQQPAtYcm\n-cOnHHgkJdEAFVDa76T9C+lcMP6DNckbJIyc\/ENrmM2v4rq\/JnsJKEEx0VLyLizQx\n-cGU3gp4ckg0ImQ9hV3H\/DLWEqfrPuD++zaV81gpstnc9+pLg0Jibvwg3qvIr7nS5\n-acc\/\/qqxH0iJGYoStHW5J5HoM9HcBvhACq5rjzjrNLPYSJqbPJwBHKcql\/uUjQ6S\n-SVWe3\/CeJp6\/vGuY1aRXAk9c\/8oO0ZDrLKE8LsUgZesTLnWGd1LQcyQf6UMG1nb9\n-5C3eZRkCVpKma6Hl\/SUQNukerlbLOU9InFGNPdeEVq1Jo62XeEi8KMbTPdXou6Yl\n-rpe99dFnOUjVOdY7gfBGSgIVJjORqf\/V70jwsxcYz7j6PKl0XulJs06vpSECAwEA\n-AaOCAmowggJmMBIGA1UdEwEB\/wQIMAYBAf8CAQIwHQYDVR0OBBYEFMgAD\/zGUvyf\n-2ztkLjK5bi5x82V5MIHhBgNVHSMEgdkwgdaAFLkJypwe29NsOmuu7VTxW5MGNS5e\n-oYGypIGvMIGsMQswCQYDVQQGEwJFVTFDMEEGA1UEBxM6TWFkcmlkIChzZWUgY3Vy\n-cmVudCBhZGRyZXNzIGF0IHd3dy5jYW1lcmZpcm1hLmNvbS9hZGRyZXNzKTESMBAG\n-A1UEBRMJQTgyNzQzMjg3MRswGQYDVQQKExJBQyBDYW1lcmZpcm1hIFMuQS4xJzAl\n-BgNVBAMTHkdsb2JhbCBDaGFtYmVyc2lnbiBSb290IC0gMjAwOIIJAMnN0+nVfSPO\n-MH0GCCsGAQUFBwEBBHEwbzBFBggrBgEFBQcwAoY5aHR0cDovL3d3dy5jYW1lcmZp\n-cm1hLmNvbS9jZXJ0cy9yb290X2NoYW1iZXJzaWduLTIwMDguY3J0MCYGCCsGAQUF\n-BzABhhpodHRwOi8vb2NzcC5jYW1lcmZpcm1hLmNvbTAOBgNVHQ8BAf8EBAMCAQYw\n-PgYDVR0gBDcwNTAzBgRVHSAAMCswKQYIKwYBBQUHAgEWHWh0dHBzOi8vcG9saWN5\n-LmNhbWVyZmlybWEuY29tMH4GA1UdHwR3MHUwOKA2oDSGMmh0dHA6Ly9jcmwuY2Ft\n-ZXJmaXJtYS5jb20vY2hhbWJlcnNpZ25yb290LTIwMDguY3JsMDmgN6A1hjNodHRw\n-Oi8vY3JsMS5jYW1lcmZpcm1hLmNvbS9jaGFtYmVyc2lnbnJvb3QtMjAwOC5jcmww\n-DQYJKoZIhvcNAQEFBQADggIBABNYG4jBwoI7e8pCuUyDc6rwpE9H6AgrUdL7O1xK\n-TgTjDGBrMOBK+ZPS4Si8J3yZngvSrL694a1HmiiblJ+CmCdNGli2nBBM+OPK3tQB\n-4TW6hgkIe3vSNg\/9o9y6+MAJcm8Kn0nPCBkSRME87NwvpehtekuF1G2ng1KDVwAn\n-F+eCXfNanEwY++vWbJAuPE69Z\/0+rCgNyH1PzihiNu6vrUlSlLWKaG34O1DEttX+\n-SsWTpEbpH9w5y9Vmw6WQ\/B5nfhPM551HaMbiGgSxT9jHmf8APYQ3iT8EktcdTAdw\n-m1miiyxfKG+WjPT7P\/x8Np1spJZw+sNIDTLdZ0T1XQ6obVkBTFUDSULKW8949HDu\n-VSwdl9Hu9lkDzzh9tyVYwwjEWVFZOiD\/4TPVLfphf4ZEiyHt5YpNd9kZJIGGDxdc\n-CdtzPm2dQODFpv72LnPQHbuBQPJ71zkoAmyeM\/1Qj0DlrFsPcYnbRasck1VmYgDc\n-Xc0+is0wcgCd7Gpx1zpEeVqwMD96am2xZPzd6nsbXvo+6TzsKLRMJo6nOERwrzuI\n-F+\/eq3WXxYMt2UenJsHqwSgPJRMdl3SFz0+SZN0viHeLuwb7qaHN74qC6GP8yHGp\n-2xe6Z11mJDPLDSrQQ2dOceSJ1LurJgLP7amYmFlWwVnmM7LnfShhMWMV+MDrICnL\n-2ksL\n------END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/camerfirma\/camerfirmachambersignca-chain.pem","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,6 @@\n- *@bug 4848242\n- *@summary Make sure that MET time zone is not misinterpreted in euro locales.\n- *         Display the MET and MEST TZ human-readable name in all euro locales.\n+ *@bug 4848242 8342886\n+ *@summary Verifies that sampled European locales use consistent short time zone names.\n+ *         Originally assumed all European locales had the same short names,\n+ *         but due to changes in time zone data and locale handling, that is no longer guaranteed.\n+ *         This test now verifies that a representative sample of locales (e.g., fr, it)\n+ *         still use the same short names (CET\/CEST).\n","filename":"test\/jdk\/sun\/util\/resources\/TimeZone\/Bug4848242.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        assertFunc = MethodCallConfig.build(\"assertEquals\", String.class, String.class, String.class);\n+        assertFunc = MethodCallConfig.build(\"assertEquals\", Object.class, Object.class, String.class);\n@@ -71,1 +71,1 @@\n-        assertFunc = MethodCallConfig.build(\"assertNotEquals\", String.class, String.class, String.class);\n+        assertFunc = MethodCallConfig.build(\"assertNotEquals\", Object.class, Object.class, String.class);\n@@ -283,1 +283,1 @@\n-        final static class Builder {\n+        static final class Builder {\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/TKitTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,5 @@\n-        return new Comm<T>(common, unique1, unique2);\n+        return new Comm<>(common, unique1, unique2);\n+    }\n+\n+    public boolean uniqueEmpty() {\n+        return unique1.isEmpty() && unique2.isEmpty();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Comm.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,435 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.XmlUtils;\n+\n+public enum JPackageUserScript {\n+    POST_IMAGE(\"post-image\"),\n+    POST_MSI(\"post-msi\");\n+\n+    JPackageUserScript(String suffix) {\n+        if (TKit.isWindows()) {\n+            this.suffix = suffix + \".wsf\";\n+        } else {\n+            this.suffix = suffix + \".sh\";\n+        }\n+    }\n+\n+    public enum WinGlobals {\n+        JS_SHELL(\"var shell = new ActiveXObject('WScript.Shell')\"),\n+        JS_FS(\"var fs = new ActiveXObject('Scripting.FileSystemObject')\");\n+\n+        WinGlobals(String expr) {\n+            this.expr = expr;\n+        }\n+\n+        public String expr() {\n+            return expr;\n+        }\n+\n+        private final String expr;\n+    }\n+\n+    public void create(JPackageCommand cmd, List<String> script) {\n+        create(scriptPath(cmd), script);\n+    }\n+\n+    public static class PackagingDirectoryVerifierBuilder {\n+\n+        public PackagingDirectoryVerifierBuilder withUnchangedDirectory(Path v) {\n+            unchangedDirectories.add(verifyPath(v));\n+            return this;\n+        }\n+\n+        public PackagingDirectoryVerifierBuilder withUnchangedDirectory(String v) {\n+            return withUnchangedDirectory(Path.of(v));\n+        }\n+\n+        public PackagingDirectoryVerifierBuilder withEmptyDirectory(Path v) {\n+            emptyDirectories.add(verifyPath(v));\n+            return this;\n+        }\n+\n+        public PackagingDirectoryVerifierBuilder withEmptyDirectory(String v) {\n+            return withEmptyDirectory(Path.of(v));\n+        }\n+\n+        public PackagingDirectoryVerifierBuilder withNonexistantPath(Path v) {\n+            nonexistantPaths.add(verifyPath(v));\n+            return this;\n+        }\n+\n+        public PackagingDirectoryVerifierBuilder withNonexistantPath(String v) {\n+            return withNonexistantPath(Path.of(v));\n+        }\n+\n+        public PackageTest apply(PackageTest test) {\n+            return verifyPackagingDirectories(test, unchangedDirectories, emptyDirectories, nonexistantPaths);\n+        }\n+\n+        private Path verifyPath(Path v) {\n+            if (v.isAbsolute() ) {\n+                throw new IllegalArgumentException();\n+            }\n+            return v;\n+        }\n+\n+        private final List<Path> unchangedDirectories = new ArrayList<>();\n+        private final List<Path> emptyDirectories = new ArrayList<>();\n+        private final List<Path> nonexistantPaths = new ArrayList<>();\n+    }\n+\n+    public static PackagingDirectoryVerifierBuilder verifyPackagingDirectories() {\n+        return new PackagingDirectoryVerifierBuilder();\n+    }\n+\n+    public static PackageTest verifyPackagingDirectories(PackageTest test) {\n+        return new PackagingDirectoryVerifierBuilder().apply(test);\n+    }\n+\n+    public interface EnvVarVerifier {\n+        boolean isEmpty();\n+        List<String> createScript();\n+        void verify(Map<String, Object> envVarsWithExpectedValues);\n+    }\n+\n+    public interface ExpectedEnvVarValue {\n+        Object fromString(String v);\n+        Object value();\n+\n+        static ExpectedEnvVarValue create(Object expectedValue, Function<String, Object> conv) {\n+            Objects.requireNonNull(expectedValue);\n+            Objects.requireNonNull(conv);\n+            return new ExpectedEnvVarValue() {\n+\n+                @Override\n+                public Object fromString(String v) {\n+                    return conv.apply(v);\n+                }\n+\n+                @Override\n+                public Object value() {\n+                    return expectedValue;\n+                }\n+            };\n+        }\n+    }\n+\n+    public static final class EnvVarVerifierBuilder {\n+\n+        public EnvVarVerifierBuilder outputDir(Path v) {\n+            outputDir = v;\n+            return this;\n+        }\n+\n+        public EnvVarVerifierBuilder envVar(String v) {\n+            envVarNames.add(v);\n+            return this;\n+        }\n+\n+        public EnvVarVerifier create() {\n+            return new DefaultEnvVarVerifier(envVarNames, Optional.ofNullable(outputDir).orElseGet(() -> {\n+                return TKit.createTempDirectory(\"env-vars\");\n+            }).toAbsolutePath());\n+        }\n+\n+        private final Set<String> envVarNames = new HashSet<>();\n+        private Path outputDir;\n+    }\n+\n+    public static EnvVarVerifierBuilder verifyEnvVariables() {\n+        return new EnvVarVerifierBuilder();\n+    }\n+\n+    private record DefaultEnvVarVerifier(Set<String> envVarNames, Path outputDir) implements EnvVarVerifier {\n+        DefaultEnvVarVerifier {\n+            Objects.requireNonNull(envVarNames);\n+            Objects.requireNonNull(outputDir);\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return envVarNames.isEmpty();\n+        }\n+\n+        @Override\n+        public List<String> createScript() {\n+            final List<String> script = new ArrayList<>();\n+\n+            if (TKit.isWindows()) {\n+                script.add(WinGlobals.JS_SHELL.expr());\n+                script.add(WinGlobals.JS_FS.expr());\n+            }\n+\n+            script.addAll(envVarNames.stream().sorted().map(envVarName -> {\n+                final var outputFile = outputDir.resolve(envVarName);\n+                if (TKit.isWindows()) {\n+                    return Stream.of(\n+                            String.format(\"WScript.Echo('Env var: %s')\", envVarName),\n+                            \"{\",\n+                            String.format(\"    var o = fs.CreateTextFile('%s', true)\", outputFile.toString().replace('\\\\', '\/')),\n+                            String.format(\"    o.Write(shell.ExpandEnvironmentStrings('%%%s%%'))\", envVarName),\n+                            \"    o.Close()\",\n+                            \"}\"\n+                    );\n+                } else {\n+                    return Stream.of(\n+                            String.format(\"printf 'Env var: %%s\\\\n' '%s'\", envVarName),\n+                            String.format(\"printf '%%s' \\\"${%s}\\\" > '%s'\", envVarName, outputFile)\n+                    );\n+                }\n+            }).flatMap(x -> x).toList());\n+\n+            return script;\n+        }\n+\n+        @Override\n+        public void verify(Map<String, Object> envVarsWithExpectedValues) {\n+            if (!Comm.compare(envVarNames, envVarsWithExpectedValues.keySet()).uniqueEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+            try {\n+                for (final var envVarName : envVarNames.stream().sorted().toList()) {\n+                    Object actualValue = Files.readString(outputDir.resolve(envVarName));\n+                    Object expetedValue = envVarsWithExpectedValues.get(envVarName);\n+                    if (expetedValue instanceof ExpectedEnvVarValue ext) {\n+                        actualValue = ext.fromString((String)actualValue);\n+                        expetedValue = ext.value();\n+                    }\n+                    TKit.assertEquals(expetedValue, actualValue, String.format(\"Check value of [%s] environment variable\", envVarName));\n+                }\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+    }\n+\n+    private void create(Path scriptFilePath, List<String> script) {\n+        try {\n+            if (TKit.isWindows()) {\n+                XmlUtils.createXml(scriptFilePath, xml -> {\n+                    xml.writeStartElement(\"job\");\n+                    xml.writeAttribute(\"id\", \"main\");\n+                    xml.writeStartElement(\"script\");\n+                    xml.writeAttribute(\"language\", \"JScript\");\n+                    xml.writeCData(\"\\n\" + String.join(\"\\n\", script) + \"\\n\");\n+                    xml.writeEndElement();\n+                    xml.writeEndElement();\n+                });\n+            } else {\n+                Files.write(scriptFilePath, script);\n+            }\n+            TKit.traceFileContents(scriptFilePath, String.format(\"[%s] script\", name()));\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private Path scriptPath(JPackageCommand cmd) {\n+        return Path.of(cmd.getArgumentValue(\"--resource-dir\"), String.format(\"%s-%s\", cmd.name(), suffix));\n+    }\n+\n+    private static PackageTest verifyPackagingDirectories(PackageTest test,\n+            List<Path> additionalUnchangedDirectories, List<Path> additionalEmptyDirectories, List<Path> additionalNonexistantPaths) {\n+\n+        final Map<PackageType, Path> capturedConfigDirs = new HashMap<>();\n+        final Map<PackageType, Path> capturedAppImageDirs = new HashMap<>();\n+        final var capturedAdditionalDirs = Stream.generate(() -> {\n+            return new HashMap<PackageType, Path>();\n+        }).limit(additionalUnchangedDirectories.size()).toList();\n+\n+        return test.addInitializer(cmd -> {\n+            setupDirectory(cmd, \"temp\", \"--temp\");\n+            setupDirectory(cmd, \"resources\", \"--resource-dir\");\n+\n+            final var configDirContets = TKit.createTempFile(addPkgTypeSuffix(\"config-listing\", cmd) + \".txt\").toAbsolutePath();\n+            capturedConfigDirs.put(cmd.packageType(), configDirContets);\n+\n+            final var appImageDirContets = TKit.createTempFile(addPkgTypeSuffix(\"app-image-listing\", cmd) + \".txt\").toAbsolutePath();\n+            capturedAppImageDirs.put(cmd.packageType(), appImageDirContets);\n+\n+            final var additionalDirContets = IntStream.range(0, additionalUnchangedDirectories.size()).mapToObj(i -> {\n+                return String.format(\"additional-dir-%d\", i);\n+            }).map(name -> {\n+                return addPkgTypeSuffix(name, cmd) + \".txt\";\n+            }).map(TKit::createTempFile).map(Path::toAbsolutePath).toList();\n+            for (int i = 0; i != additionalUnchangedDirectories.size(); i++) {\n+                capturedAdditionalDirs.get(i).put(cmd.packageType(), additionalDirContets.get(i));\n+            }\n+\n+            final List<String> script = new ArrayList<>();\n+            if (TKit.isWindows()) {\n+                script.addAll(List.of(\n+                        \"function listDir (dir) {\",\n+                        \"    o.WriteLine(dir.Path)\",\n+                        \"    for(var e = new Enumerator(dir.Files); !e.atEnd(); e.moveNext()) {\",\n+                        \"        o.WriteLine(e.item().Path)\",\n+                        \"    }\",\n+                        \"    for(var e = new Enumerator(dir.SubFolders); !e.atEnd(); e.moveNext()) {\",\n+                        \"        listDir(e.item())\",\n+                        \"    }\",\n+                        \"}\",\n+                        WinGlobals.JS_FS.expr(),\n+                        WinGlobals.JS_SHELL.expr(),\n+                        String.format(\"var o = fs.CreateTextFile('%s', true)\", configDirContets.toString().replace('\\\\', '\/')),\n+                        \"var configDir = fs.GetFolder(fs.GetParentFolderName(WScript.ScriptFullName))\",\n+                        \"listDir(configDir)\",\n+                        \"o.Close()\",\n+                        String.format(\"o = fs.CreateTextFile('%s', true)\", appImageDirContets.toString().replace('\\\\', '\/')),\n+                        \"listDir(fs.GetFolder(shell.CurrentDirectory))\",\n+                        \"o.Close()\"\n+                ));\n+            } else {\n+                script.addAll(List.of(\n+                        \"set -e\",\n+                        String.format(\"find \\\"${0%%\/*}\\\" >> '%s'\", configDirContets),\n+                        String.format(\"find \\\"$PWD\\\" >> '%s'\", appImageDirContets)\n+                ));\n+            }\n+\n+            script.addAll(IntStream.range(0, additionalUnchangedDirectories.size()).mapToObj(i -> {\n+                final var dirAsStr = additionalPathInScript(additionalUnchangedDirectories.get(i));\n+                final var captureFile = additionalDirContets.get(i);\n+                if (TKit.isWindows()) {\n+                    return Stream.of(\n+                            String.format(\"WScript.Echo('Save directory listing: ' + %s)\", dirAsStr),\n+                            String.format(\"o = fs.CreateTextFile('%s', true)\", captureFile.toString().replace('\\\\', '\/')),\n+                            String.format(\"listDir(fs.GetFolder(%s))\", dirAsStr),\n+                            \"o.Close()\"\n+                    );\n+                } else {\n+                    return Stream.of(\n+                            String.format(\"printf 'Save directory listing: %%s\\\\n' %s\", dirAsStr),\n+                            String.format(\"find %s >> '%s'\", dirAsStr, captureFile)\n+                    );\n+                }\n+            }).flatMap(x -> x).toList());\n+\n+            script.addAll(additionalEmptyDirectories.stream().map(JPackageUserScript::additionalPathInScript).map(dirAsStr -> {\n+                if (TKit.isWindows()) {\n+                    return Stream.of(\n+                            String.format(\"WScript.Echo('Check directory: ' + %s)\", dirAsStr),\n+                            \"{\",\n+                            \"    WScript.Echo('  exists')\",\n+                            String.format(\"    var f = fs.GetFolder(%s)\", dirAsStr),\n+                            \"    WScript.Echo('  is empty')\",\n+                            \"    if (f.SubFolders.Count != 0 || f.Files.Count != 0) WScript.Quit(1)\",\n+                            \"}\"\n+                    );\n+                } else {\n+                    return Stream.of(\n+                            String.format(\"printf 'Check directory: %%s\\\\n' %s\", dirAsStr),\n+                            \"echo '  exists'\",\n+                            String.format(\"[ -d %s ]\", dirAsStr),\n+                            \"echo '  is empty'\",\n+                            \"exec 3>&1\",\n+                            String.format(\"[ -z \\\"$(find %s -mindepth 1 -maxdepth 1 3>&- | tee \/dev\/fd\/3)\\\" ]\", dirAsStr),\n+                            \"exec 3>&-\"\n+                    );\n+                }\n+            }).flatMap(x -> x).toList());\n+\n+            script.addAll(additionalNonexistantPaths.stream().map(JPackageUserScript::additionalPathInScript).map(pathAsStr -> {\n+                if (TKit.isWindows()) {\n+                    return Stream.of(\n+                            String.format(\"WScript.Echo('Check nonexistant: ' + %s)\", pathAsStr),\n+                            String.format(\"if (fs.FileExists(%s) || fs.FolderExists(%s)) WScript.Quit(1)\", pathAsStr, pathAsStr)\n+                    );\n+                } else {\n+                    return Stream.of(\n+                            String.format(\"printf 'Check nonexistant: %%s\\\\n' %s\", pathAsStr),\n+                            String.format(\"[ ! -e %s ]\", pathAsStr)\n+                    );\n+                }\n+            }).flatMap(x -> x).toList());\n+\n+            POST_IMAGE.create(cmd, script);\n+        }).addBundleVerifier(cmd -> {\n+            final var configDir = verifyDirectoryContents(capturedConfigDirs.get(cmd.packageType()));\n+            verifyDirectoryContents(capturedAppImageDirs.get(cmd.packageType()));\n+            for (final var v : capturedAdditionalDirs) {\n+                verifyDirectoryContents(v.get(cmd.packageType()));\n+            }\n+            additionalNonexistantPaths.forEach(path -> {\n+                TKit.assertPathExists(configDir.resolve(path), true);\n+            });\n+            additionalEmptyDirectories.forEach(path -> {\n+                TKit.assertDirectoryNotEmpty(configDir.resolve(path));\n+            });\n+        });\n+    }\n+\n+    private static String additionalPathInScript(Path path) {\n+        path = path.normalize();\n+        if (TKit.isWindows()) {\n+            return String.format(\"configDir.Path + '\/%s'\", path.toString().replace('\\\\', '\/'));\n+        } else {\n+            return String.format(\"\\\"${0%%\/*}\\\"'\/%s'\", path);\n+        }\n+    }\n+\n+    private static Path verifyDirectoryContents(Path fileWithExpectedDirContents) throws IOException {\n+        TKit.trace(String.format(\"Process [%s] file...\", fileWithExpectedDirContents));\n+\n+        final var data = Files.readAllLines(fileWithExpectedDirContents);\n+        final var dir = Path.of(data.getFirst());\n+        final var capturedDirContents = data.stream().skip(1).map(Path::of).map(dir::relativize).toList();\n+\n+        \/\/ Verify new files are not created in the \"config\" directory after the script execution.\n+        TKit.assertDirectoryContentRecursive(dir).removeAll(capturedDirContents).match();\n+\n+        return dir;\n+    }\n+\n+    private static Path setupDirectory(JPackageCommand cmd, String role, String argName) {\n+        if (!cmd.hasArgument(argName)) {\n+            cmd.setArgumentValue(argName, TKit.createTempDirectory(addPkgTypeSuffix(role, cmd)));\n+        }\n+\n+        return Path.of(cmd.getArgumentValue(argName));\n+    }\n+\n+    private static String addPkgTypeSuffix(String str, JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.NATIVE);\n+        Objects.requireNonNull(str);\n+        return String.format(\"%s-%s\", str, cmd.packageType().getType());\n+    }\n+\n+    private final String suffix;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageUserScript.java","additions":435,"deletions":0,"binary":false,"changes":435,"status":"added"},{"patch":"@@ -312,1 +312,1 @@\n-        Long packageSize = LinuxHelper.getInstalledPackageSizeKB(cmd);\n+        long packageSize = LinuxHelper.getInstalledPackageSizeKB(cmd);\n@@ -314,1 +314,1 @@\n-        TKit.assertNotEquals(0L, packageSize, String.format(\n+        TKit.assertNotEquals(0, packageSize, String.format(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -659,1 +659,1 @@\n-    public static void assertEquals(String expected, String actual, String msg) {\n+    public static void assertEquals(Object expected, Object actual, String msg) {\n@@ -671,1 +671,1 @@\n-    public static void assertNotEquals(String expected, String actual, String msg) {\n+    public static void assertNotEquals(Object expected, Object actual, String msg) {\n@@ -763,1 +763,1 @@\n-                        TKit.assertTrue(actualIsEmpty, String.format(\"Check [%s] is not an empty directory\", path));\n+                        TKit.assertTrue(actualIsEmpty, String.format(\"Check [%s] is an empty directory\", path));\n@@ -765,1 +765,1 @@\n-                        TKit.assertTrue(!actualIsEmpty, String.format(\"Check [%s] is an empty directory\", path));\n+                        TKit.assertTrue(!actualIsEmpty, String.format(\"Check [%s] is not an empty directory\", path));\n@@ -806,1 +806,5 @@\n-        return new DirectoryContentVerifier(dir);\n+        return new DirectoryContentVerifier(dir, ThrowingSupplier.toSupplier(() -> {\n+            try (var files = Files.list(dir)) {\n+                return files.map(Path::getFileName).collect(toSet());\n+            }\n+        }).get());\n@@ -809,8 +813,7 @@\n-    public static final class DirectoryContentVerifier {\n-        public DirectoryContentVerifier(Path baseDir) {\n-            this(baseDir, ThrowingSupplier.toSupplier(() -> {\n-                try (var files = Files.list(baseDir)) {\n-                    return files.map(Path::getFileName).collect(toSet());\n-                }\n-            }).get());\n-        }\n+    public static DirectoryContentVerifier assertDirectoryContentRecursive(Path dir) {\n+        return new DirectoryContentVerifier(dir, ThrowingSupplier.toSupplier(() -> {\n+            try (var files = Files.walk(dir).skip(1)) {\n+                return files.map(dir::relativize).collect(toSet());\n+            }\n+        }).get());\n+    }\n@@ -818,0 +821,1 @@\n+    public static final class DirectoryContentVerifier {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-        TKit.assertNotEquals(0, countStrings.apply(List.of(expectedPrefix)),\n+        TKit.assertNotEquals(0, countStrings.apply(List.of(expectedPrefix)).longValue(),\n@@ -174,1 +174,1 @@\n-        TKit.assertEquals(0, countStrings.apply(unexpectedPrefixes),\n+        TKit.assertEquals(0, countStrings.apply(unexpectedPrefixes).longValue(),\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,276 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.internal.util.OperatingSystem.LINUX;\n+import static jdk.internal.util.OperatingSystem.MACOS;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.ApplicationLayout;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JPackageUserScript;\n+import jdk.jpackage.test.JPackageUserScript.WinGlobals;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary jpackage with user-supplied post app image script\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror PostImageScriptTest.java\n+ * @run main\/othervm\/timeout=720 -Xmx512m\n+ *  jdk.jpackage.test.Main\n+ *  --jpt-run=PostImageScriptTest\n+ *\/\n+\n+public class PostImageScriptTest {\n+\n+    public enum Mode {\n+        APP,\n+        RUNTIME,\n+        EXTERNAL_APP_IMAGE\n+    }\n+\n+    public record TestSpec(Mode mode, boolean verifyAppImageContents) {\n+\n+        public TestSpec {\n+            Objects.requireNonNull(mode);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final var sb = new StringBuilder();\n+            sb.append(mode);\n+            if (verifyAppImageContents) {\n+                sb.append(\"; verifyAppImageContents\");\n+            }\n+            return sb.toString();\n+        }\n+\n+        static PackageTest createTest(Mode mode, PackageType... types) {\n+            if (types.length > 0 && Stream.of(types).allMatch(Predicate.not(PackageType::isEnabled))) {\n+                throw TKit.throwSkippedException(String.format(\"All native packagers from %s list are disabled\", List.of(types)));\n+            }\n+\n+            final var test = new PackageTest().forTypes(types);\n+\n+            final var appImageCmd = JPackageCommand.helloAppImage()\n+                    .setFakeRuntime().setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n+\n+            appImageCmd.execute();\n+\n+            switch (mode) {\n+                case APP -> {\n+                    test.configureHelloApp();\n+                    test.addInitializer(cmd -> {\n+                        cmd.addArguments(\"--runtime-image\", appImageCmd.appRuntimeDirectory());\n+                    });\n+                }\n+                case RUNTIME -> {\n+                    test.addInitializer(cmd -> {\n+                        cmd.removeArgumentWithValue(\"--input\");\n+                        cmd.addArguments(\"--runtime-image\", appImageCmd.appRuntimeDirectory());\n+                    });\n+                }\n+                case EXTERNAL_APP_IMAGE -> {\n+                    test.addInitializer(cmd -> {\n+                        cmd.removeArgumentWithValue(\"--input\");\n+                        cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n+                    });\n+                }\n+            }\n+\n+            test.addInitializer(cmd -> {\n+                cmd.setArgumentValue(\"--resource-dir\", TKit.createTempDirectory(\"resources\"));\n+            });\n+\n+            return test;\n+        }\n+\n+        PackageTest createTest() {\n+            return createTest(mode);\n+        }\n+\n+        PackageTest initTest() {\n+            return initTest(createTest());\n+        }\n+\n+        PackageTest initTest(PackageTest test) {\n+            if (verifyAppImageContents) {\n+                test.addInitializer(cmd -> {\n+                    final Path runtimeDir;\n+                    if (TKit.isLinux()) {\n+                        runtimeDir = Path.of(\"\/\").relativize(cmd.appRuntimeDirectory());\n+                    } else if (!cmd.isRuntime()) {\n+                        runtimeDir = ApplicationLayout.platformAppImage().runtimeHomeDirectory();\n+                    } else if (TKit.isOSX()) {\n+                        runtimeDir = Path.of(\"Contents\/Home\");\n+                    } else {\n+                        runtimeDir = Path.of(\"\");\n+                    }\n+\n+                    final Path runtimeBinDir = runtimeDir.resolve(\"bin\");\n+\n+                    if (TKit.isWindows()) {\n+                        JPackageUserScript.POST_IMAGE.create(cmd, List.of(\n+                                WinGlobals.JS_SHELL.expr(),\n+                                WinGlobals.JS_FS.expr(),\n+                                \"WScript.Echo('PWD: ' + fs.GetFolder(shell.CurrentDirectory).Path)\",\n+                                String.format(\"WScript.Echo('Probe directory: %s')\", runtimeBinDir),\n+                                String.format(\"fs.GetFolder('%s')\", runtimeBinDir.toString().replace('\\\\', '\/'))\n+                        ));\n+                    } else {\n+                        JPackageUserScript.POST_IMAGE.create(cmd, List.of(\n+                                \"set -e\",\n+                                \"printf 'PWD: %s\\\\n' \\\"$PWD\\\"\",\n+                                String.format(\"printf 'Probe directory: %%s\\\\n' '%s'\", runtimeBinDir),\n+                                String.format(\"[ -d '%s' ]\", runtimeBinDir)\n+                        ));\n+                    }\n+                });\n+            } else {\n+                JPackageUserScript.verifyPackagingDirectories(test);\n+            }\n+\n+            return test;\n+        }\n+    }\n+\n+    @Test\n+    @ParameterSupplier(value=\"createVerifyAppImageContentsTestSpecs\")\n+    @ParameterSupplier(value=\"createVerifyNoNewFilesInDirectoriesTestSpecs\")\n+    public static void test(TestSpec spec) {\n+        spec.initTest().run(Action.CREATE);\n+    }\n+\n+    public static Collection<Object[]> createVerifyAppImageContentsTestSpecs() {\n+        return createModeTestSpecs(true);\n+    }\n+\n+    public static Collection<Object[]> createVerifyNoNewFilesInDirectoriesTestSpecs() {\n+        return createModeTestSpecs(false);\n+    }\n+\n+    @Test(ifOS = LINUX)\n+    @ParameterSupplier(value=\"createVerifyAppImageContentsTestSpecs\")\n+    public static void testWithInstallDir(TestSpec spec) {\n+        spec.initTest(spec.createTest().addInitializer(cmd -> {\n+            cmd.addArguments(\"--install-dir\", \"\/usr\");\n+        })).run(Action.CREATE);\n+    }\n+\n+    @Test(ifOS = MACOS)\n+    @Parameter(\"APP\")\n+    public static void testWithServices(Mode mode) {\n+        final var test = TestSpec.createTest(mode, PackageType.MAC_PKG).addInitializer(cmd -> {\n+            cmd.addArgument(\"--launcher-as-service\");\n+        });\n+\n+        JPackageUserScript.verifyPackagingDirectories()\n+                .withUnchangedDirectory(\"..\/services\")\n+                .withUnchangedDirectory(\"..\/support\")\n+                .withEmptyDirectory(\"..\/packages\")\n+                .apply(test).run(Action.CREATE);\n+    }\n+\n+    @Test\n+    public static void testEnvVars() {\n+        final Map<PackageType, JPackageUserScript.EnvVarVerifier> verifiers = new HashMap<>();\n+\n+        final var imageDirOutputPrefix = \"image-dir=\";\n+\n+        TestSpec.createTest(Mode.APP).addInitializer(cmd -> {\n+            final var verifier = JPackageUserScript.verifyEnvVariables().envVar(\"JpAppImageDir\").create();\n+            verifiers.put(cmd.packageType(), verifier);\n+\n+            final List<String> script = new ArrayList<>();\n+            script.addAll(verifier.createScript());\n+            if (TKit.isWindows()) {\n+                script.add(\"WScript.Echo('\" + imageDirOutputPrefix + \"' + fs.GetFolder(shell.CurrentDirectory).Path)\");\n+            } else {\n+                script.add(\"printf '\" + imageDirOutputPrefix + \"%s\\\\n' \\\"$PWD\\\"\");\n+            }\n+\n+            JPackageUserScript.POST_IMAGE.create(cmd, script);\n+\n+            cmd.saveConsoleOutput(true);\n+\n+        }).addBundleVerifier((cmd, result) -> {\n+            final var imageDir = result.stdout().getOutput().stream().map(String::stripLeading).filter(str -> {\n+                return str.startsWith(imageDirOutputPrefix);\n+            }).map(str -> {\n+                return str.substring(imageDirOutputPrefix.length());\n+            }).findFirst().orElseThrow();\n+            final var verifier = verifiers.get(cmd.packageType());\n+            \/\/ On macOS, the path to app image set from jpackage starts with \"\/var\"\n+            \/\/ and the value of `PWD` variable in the \"post-image\" script is a path\n+            \/\/ starting with \"\/private\/var\", which is a target of \"\/var\" symlink.\n+            \/\/\n+            \/\/ Can't use Path.toRealPath() to resolve symlinks because the app image directory is gone.\n+            \/\/\n+            \/\/ Instead, the workaround is to strip all leading path components\n+            \/\/ before the path component starting with \"jdk.jpackage\" substring.\n+            verifier.verify(Map.of(\"JpAppImageDir\", JPackageUserScript.ExpectedEnvVarValue.create(\n+                    stripLeadingNonJPackagePathComponents(imageDir),\n+                    PostImageScriptTest::stripLeadingNonJPackagePathComponents)));\n+        }).run(Action.CREATE);\n+    }\n+\n+    private static Collection<Object[]> createModeTestSpecs(boolean verifyAppImageContents) {\n+        return Stream.of(Mode.values()).map(mode -> {\n+            return new TestSpec(mode, verifyAppImageContents);\n+        }).map(spec -> {\n+            return new Object[] {spec};\n+        }).toList();\n+    }\n+\n+    private static Path stripLeadingNonJPackagePathComponents(String path) {\n+        if (!Path.of(path).isAbsolute()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        final var m = JPACKAGE_TEMP_DIR_REGEXP.matcher(path);\n+        if (!m.find()) {\n+            TKit.assertUnexpected(String.format(\"jpackage temp directory not foind in [%s] path\", path));\n+        }\n+\n+        return Path.of(m.group());\n+    }\n+\n+    private static final Pattern JPACKAGE_TEMP_DIR_REGEXP = Pattern.compile(\"[\\\\\\\\\/]jdk\\\\.jpackage.+$\",\n+            TKit.isWindows() ? 0 : Pattern.CASE_INSENSITIVE);\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/PostImageScriptTest.java","additions":276,"deletions":0,"binary":false,"changes":276,"status":"added"},{"patch":"@@ -27,5 +27,0 @@\n-import jdk.jpackage.internal.util.XmlUtils;\n-import jdk.jpackage.test.TKit;\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.PackageType;\n-import jdk.jpackage.test.Annotations.Test;\n@@ -34,0 +29,1 @@\n+import jdk.jpackage.test.Annotations.Test;\n@@ -35,0 +31,5 @@\n+import jdk.jpackage.test.JPackageUserScript;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+import jdk.jpackage.test.TKit;\n@@ -110,1 +111,1 @@\n-        test.run();\n+        test.run(Action.CREATE);\n@@ -118,1 +119,1 @@\n-                scriptSuffixName = \"post-image\";\n+                script = JPackageUserScript.POST_IMAGE;\n@@ -122,1 +123,1 @@\n-                scriptSuffixName = \"post-msi\";\n+                script = JPackageUserScript.POST_MSI;\n@@ -152,7 +153,1 @@\n-           XmlUtils.createXml(Path.of(cmd.getArgumentValue(\"--resource-dir\"),\n-                    String.format(\"%s-%s.wsf\", cmd.name(), scriptSuffixName)), xml -> {\n-                xml.writeStartElement(\"job\");\n-                xml.writeAttribute(\"id\", \"main\");\n-                xml.writeStartElement(\"script\");\n-                xml.writeAttribute(\"language\", \"JScript\");\n-                xml.writeCData(String.join(\"\\n\", List.of(\n+            script.create(cmd, List.of(\n@@ -164,4 +159,1 @@\n-                )));\n-                xml.writeEndElement();\n-                xml.writeEndElement();\n-            });\n+            ));\n@@ -171,1 +163,1 @@\n-        private final String scriptSuffixName;\n+        private final JPackageUserScript script;\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinScriptTest.java","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+tools\/javap\/T4975569.java                                                       8364095    generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8348282\n+ * @summary Add option for syntax highlighting in javadoc snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestSyntaxHighlightOption\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestSyntaxHighlightOption extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestSyntaxHighlightOption();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+    Path src = Path.of(\"src\");\n+\n+\n+    TestSyntaxHighlightOption() throws IOException {\n+        tb.writeJavaFiles(src, \"\"\"\n+                    package p;\n+                    \/** Class C. *\/\n+                    public class C {\n+                        \/**\n+                         * Method m.\n+                         *\/\n+                        public void m() {\n+                        }\n+                    }\n+                    \"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testSyntaxHighlightOption(Path base) {\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--syntax-highlight\",\n+                \"p\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"resource-files\/highlight.css\", true, \"Syntax highlight style sheet\");\n+        checkOutput(\"script-files\/highlight.js\", true, \"Highlight.js v11.11.1 (git: 08cb242e7d)\");\n+        checkOutput(\"index-all.html\", true, \"\"\"\n+                <link rel=\"stylesheet\" type=\"text\/css\" href=\"resource-files\/highlight.css\">\n+                <script type=\"text\/javascript\" src=\"script-files\/highlight.js\"><\/script>\"\"\");\n+        checkOutput(\"p\/package-summary.html\", true, \"\"\"\n+                <link rel=\"stylesheet\" type=\"text\/css\" href=\"..\/resource-files\/highlight.css\">\n+                <script type=\"text\/javascript\" src=\"..\/script-files\/highlight.js\"><\/script>\"\"\");\n+        checkOutput(\"p\/C.html\", true, \"\"\"\n+                <link rel=\"stylesheet\" type=\"text\/css\" href=\"..\/resource-files\/highlight.css\">\n+                <script type=\"text\/javascript\" src=\"..\/script-files\/highlight.js\"><\/script>\"\"\");\n+    }\n+\n+    @Test\n+    public void testNoSyntaxHighlightOption(Path base) {\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+        checkFiles(false, \"resource-files\/highlight.css\", \"script-files\/highlight.js\");\n+        checkOutput(\"index-all.html\", false, \"highlight.css\", \"highlight.js\");\n+        checkOutput(\"p\/package-summary.html\", false, \"highlight.css\", \"highlight.js\");\n+        checkOutput(\"p\/C.html\", false, \"highlight.css\", \"highlight.js\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSyntaxHighlightOption\/TestSyntaxHighlightOption.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2025, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8355065\n+ * @summary ConcurrentModificationException in RichDiagnosticFormatter\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.main jdk.compiler\/com.sun.tools.javac.api\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RichFormatterWithTypeAnnotationsTest\n+ *\/\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class RichFormatterWithTypeAnnotationsTest extends TestRunner {\n+    ToolBox tb;\n+\n+    public RichFormatterWithTypeAnnotationsTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new RichFormatterWithTypeAnnotationsTest()\n+                .runTests(m -> new Object[] {Paths.get(m.getName())});\n+    }\n+\n+    @Test\n+    public void test(Path base) throws Exception {\n+        Path libClasses = base.resolve(\"libclasses\");\n+        Files.createDirectories(libClasses);\n+        new JavacTask(tb)\n+                .outdir(libClasses)\n+                .sources(\n+                        \"\"\"\n+                        package lib;\n+                        enum Bar {\n+                          BAZ\n+                        }\n+                        \"\"\",\n+                        \"\"\"\n+                        package lib;\n+                        import java.lang.annotation.ElementType;\n+                        import java.lang.annotation.Retention;\n+                        import java.lang.annotation.RetentionPolicy;\n+                        import java.lang.annotation.Target;\n+\n+                        @Retention(RetentionPolicy.RUNTIME)\n+                        @interface Foo {\n+                          Bar value();\n+                        }\n+                        \"\"\",\n+                        \"\"\"\n+                        package lib;\n+                        import java.lang.annotation.ElementType;\n+                        import java.lang.annotation.Retention;\n+                        import java.lang.annotation.RetentionPolicy;\n+                        import java.lang.annotation.Target;\n+\n+                        @Retention(RetentionPolicy.RUNTIME)\n+                        @Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+                        @Foo(Bar.BAZ)\n+                        @interface A {}\n+                        \"\"\",\n+                        \"\"\"\n+                        package lib;\n+                        public interface M<K, V> {\n+                          @A\n+                          V f(K k, V v);\n+                        }\n+                        \"\"\")\n+                .options()\n+                .run()\n+                .writeAll();\n+        Files.delete(libClasses.resolve(\"lib\").resolve(\"Bar.class\"));\n+        String code =\n+                \"\"\"\n+                import lib.M;\n+                class T {\n+                  protected M m;\n+\n+                  public void f() {\n+                    m.f(null, 0);\n+                  }\n+                }\n+                \"\"\";\n+        List<String> output =\n+                new JavacTask(tb)\n+                        .classpath(libClasses)\n+                        .sources(code)\n+                        .options(\"-Xlint:all\", \"-Werror\", \"-XDrawDiagnostics\")\n+                        .run(Task.Expect.FAIL)\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+        List<String> expected =\n+                Arrays.asList(\n+                        \"T.java:3:13: compiler.warn.raw.class.use: lib.M, lib.M<K,V>\",\n+                        \"T.java:6:8: compiler.warn.unchecked.call.mbr.of.raw.type: f(K,V), lib.M\",\n+                        \"- compiler.err.warnings.and.werror\",\n+                        \"1 error\",\n+                        \"2 warnings\");\n+        tb.checkEqual(expected, output);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/RichFormatterWithTypeAnnotationsTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,2 @@\n- * @test 8333748\n+ * @test\n+ * @bug 8333748 8349536\n","filename":"test\/langtools\/tools\/javap\/UndefinedAccessFlagTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * @test\n+ * @summary Test WhiteBox.waitForReferenceProcessing\n+ * @bug 8305186 8355632\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @modules java.base\/java.lang.ref:open\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -ea -esa\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+WhiteBoxAPI\n+ *      WaitForRefProcTest\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class WaitForRefProcTest {\n+\n+    public static void main(String[] args) {\n+        WhiteBox.getWhiteBox().fullGC();\n+        try {\n+            boolean ret = WhiteBox.getWhiteBox().waitForReferenceProcessing();\n+            System.out.println(\"wFRP returned \" + ret);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"test caught InterruptedException\");\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/WaitForRefProcTest.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -176,0 +176,5 @@\n+\n+    public SimpleCDSAppTester run(String args[])  throws Exception {\n+        (new Tester(name)).run(args);\n+        return this;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/SimpleCDSAppTester.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.ref.Reference;\n@@ -28,0 +29,3 @@\n+import java.lang.reflect.InaccessibleObjectException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -573,0 +577,47 @@\n+  \/\/ Infrastructure for waitForReferenceProcessing()\n+  private static volatile Method waitForReferenceProcessingMethod = null;\n+\n+  private static Method getWaitForReferenceProcessingMethod() {\n+    Method wfrp = waitForReferenceProcessingMethod;\n+    if (wfrp == null) {\n+      try {\n+        wfrp = Reference.class.getDeclaredMethod(\"waitForReferenceProcessing\");\n+        wfrp.setAccessible(true);\n+        assert wfrp.getReturnType().equals(boolean.class);\n+        Class<?>[] ev = wfrp.getExceptionTypes();\n+        assert ev.length == 1;\n+        assert ev[0] == InterruptedException.class;\n+        waitForReferenceProcessingMethod = wfrp;\n+      } catch (InaccessibleObjectException e) {\n+        throw new RuntimeException(\"Need to add @modules java.base\/java.lang.ref:open to test?\", e);\n+      } catch (NoSuchMethodException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+    return wfrp;\n+  }\n+\n+  \/**\n+   * Wait for reference processing, via Reference.waitForReferenceProcessing().\n+   * Callers of this method will need the\n+   * @modules java.base\/java.lang.ref:open\n+   * jtreg tag.\n+   *\n+   * This method should usually be called after a call to WhiteBox.fullGC().\n+   *\/\n+  public boolean waitForReferenceProcessing() throws InterruptedException {\n+    try {\n+      Method wfrp = getWaitForReferenceProcessingMethod();\n+      return (Boolean) wfrp.invoke(null);\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(\"Shouldn't happen, we call setAccessible()\", e);\n+    } catch (InvocationTargetException e) {\n+      Throwable cause = e.getCause();\n+      if (cause instanceof InterruptedException) {\n+        throw (InterruptedException) cause;\n+      } else {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(100)\n+public class StableFunctionBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final Set<Integer> SET = IntStream.range(0, SIZE).boxed().collect(Collectors.toSet());\n+\n+    private static final Map<Integer, Integer> MAP = StableValue.map(SET, Function.identity());\n+    private static final Function<Integer, Integer> FUNCTION = StableValue.function(SET, Function.identity());\n+\n+    private final Map<Integer, Integer> map = StableValue.map(SET, Function.identity());\n+    private final Function<Integer, Integer> function = StableValue.function(SET, Function.identity());\n+\n+    @Benchmark\n+    public int map() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += map.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int function() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += function.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticSMap() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += MAP.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += FUNCTION.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableFunctionBenchmark.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableFunctionSingleBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final Set<Integer> SET = IntStream.range(0, SIZE).boxed().collect(Collectors.toSet());\n+\n+    private static final Map<Integer, Integer> MAP = StableValue.map(SET, Function.identity());\n+    private static final Function<Integer, Integer> FUNCTION = StableValue.function(SET, Function.identity());\n+\n+    private final Map<Integer, Integer> map = StableValue.map(SET, Function.identity());\n+    private final Function<Integer, Integer> function = StableValue.function(SET, Function.identity());\n+\n+    @Benchmark\n+    public int map() {\n+        return map.get(1);\n+    }\n+\n+    @Benchmark\n+    public int function() {\n+        return function.apply(1);\n+    }\n+\n+    @Benchmark\n+    public int staticSMap() {\n+        return MAP.get(1);\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        return FUNCTION.apply(1);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableFunctionSingleBenchmark.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(100)\n+public class StableIntFunctionBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final IntFunction<Integer> IDENTITY = i -> i;\n+\n+    private static final List<Integer> LIST = StableValue.list(SIZE, IDENTITY);\n+    private static final IntFunction<Integer> INT_FUNCTION = StableValue.intFunction(SIZE, IDENTITY);\n+\n+    private final List<Integer> list = StableValue.list(SIZE, IDENTITY);\n+    private final IntFunction<Integer> intFunction = StableValue.intFunction(SIZE, IDENTITY);\n+\n+    @Benchmark\n+    public int list() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += list.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int intFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += intFunction.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticList() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += LIST.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += INT_FUNCTION.apply(i);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableIntFunctionBenchmark.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableIntFunctionSingleBenchmark {\n+\n+    private static final int SIZE = 100;\n+    private static final IntFunction<Integer> IDENTITY = i -> i;\n+\n+    private static final List<Integer> STABLE = StableValue.list(SIZE, IDENTITY);\n+    private static final IntFunction<Integer> INT_FUNCTION = StableValue.intFunction(SIZE, IDENTITY);\n+\n+    private final List<Integer> stable = StableValue.list(SIZE, IDENTITY);\n+    private final IntFunction<Integer> intFunction = StableValue.intFunction(SIZE, IDENTITY);\n+\n+    @Benchmark\n+    public int list() {\n+        return stable.get(1);\n+    }\n+\n+    @Benchmark\n+    public int intFunction() {\n+        return intFunction.apply(1);\n+    }\n+\n+    @Benchmark\n+    public int staticList() {\n+        return STABLE.get(1);\n+    }\n+\n+    @Benchmark\n+    public int staticIntFunction() {\n+        return INT_FUNCTION.apply(1);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableIntFunctionSingleBenchmark.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.bench.java.lang.stable.StableValueBenchmark.Dcl;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableMethodHandleBenchmark {\n+\n+    private static final MethodHandle FINAL_MH = identityHandle();\n+    private static final StableValue<MethodHandle> STABLE_MH;\n+    private static MethodHandle mh = identityHandle();\n+    private static final Dcl<MethodHandle> DCL = new Dcl<>(StableMethodHandleBenchmark::identityHandle);\n+    private static final AtomicReference<MethodHandle> ATOMIC_REFERENCE = new AtomicReference<>(identityHandle());\n+    private static final Map<String, MethodHandle> MAP = new ConcurrentHashMap<>();\n+    private static final Map<String, MethodHandle> STABLE_MAP = StableValue.map(Set.of(\"identityHandle\"), _ -> identityHandle());\n+\n+    static {\n+        STABLE_MH = StableValue.of();\n+        STABLE_MH.setOrThrow(identityHandle());\n+        MAP.put(\"identityHandle\", identityHandle());\n+    }\n+\n+    @Benchmark\n+    public int atomic() throws Throwable {\n+        return (int) ATOMIC_REFERENCE.get().invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int dcl() throws Throwable {\n+        return (int) DCL.get().invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int finalMh() throws Throwable {\n+        return (int) FINAL_MH.invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int map() throws Throwable {\n+        return (int) MAP.get(\"identityHandle\").invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int nonFinalMh() throws Throwable {\n+        return (int) mh.invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int stableMap() throws Throwable {\n+        return (int) STABLE_MAP.get(\"identityHandle\").invokeExact(1);\n+    }\n+\n+    @Benchmark\n+    public int stableMh() throws Throwable {\n+        return (int) STABLE_MH.orElseThrow().invokeExact(1);\n+    }\n+\n+    Object cp() {\n+        CodeBuilder cob = null;\n+        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n+        cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA), List.of()),\n+                cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle)));\n+        return null;\n+    }\n+\n+    static MethodHandle identityHandle() {\n+        var lookup = MethodHandles.lookup();\n+        try {\n+            return lookup.findStatic(StableMethodHandleBenchmark.class, \"identity\", MethodType.methodType(int.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static int identity(int value) {\n+        return value;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableMethodHandleBenchmark.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(2)\n+public class StableSupplierBenchmark {\n+\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 23;\n+\n+    private static final StableValue<Integer> STABLE = init(StableValue.of(), VALUE);\n+    private static final StableValue<Integer> STABLE2 = init(StableValue.of(), VALUE2);\n+    private static final Supplier<Integer> SUPPLIER = StableValue.supplier(() -> VALUE);\n+    private static final Supplier<Integer> SUPPLIER2 = StableValue.supplier(() -> VALUE);\n+\n+    private final StableValue<Integer> stable = init(StableValue.of(), VALUE);\n+    private final StableValue<Integer> stable2 = init(StableValue.of(), VALUE2);\n+    private final Supplier<Integer> supplier = StableValue.supplier(() -> VALUE);\n+    private final Supplier<Integer> supplier2 = StableValue.supplier(() -> VALUE2);\n+\n+    @Benchmark\n+    public int stable() {\n+        return stable.orElseThrow() + stable2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int supplier() {\n+        return supplier.get() + supplier2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticStable() {\n+        return STABLE.orElseThrow() + STABLE2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int staticSupplier() {\n+        return SUPPLIER.get() + SUPPLIER2.get();\n+    }\n+\n+    private static StableValue<Integer> init(StableValue<Integer> m, Integer value) {\n+        m.trySet(value);\n+        return m;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableSupplierBenchmark.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgsAppend = {\n+        \"--enable-preview\"\n+})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+@OperationsPerInvocation(2)\n+public class StableValueBenchmark {\n+\n+    private static final int VALUE = 42;\n+    private static final int VALUE2 = 23;\n+\n+    private static final StableValue<Integer> STABLE = init(StableValue.of(), VALUE);\n+    private static final StableValue<Integer> STABLE2 = init(StableValue.of(), VALUE2);\n+    private static final StableValue<Integer> DCL = init(StableValue.of(), VALUE);\n+    private static final StableValue<Integer> DCL2 = init(StableValue.of(), VALUE2);\n+    private static final AtomicReference<Integer> ATOMIC = new AtomicReference<>(VALUE);\n+    private static final AtomicReference<Integer> ATOMIC2 = new AtomicReference<>(VALUE2);\n+    private static final Holder HOLDER = new Holder(VALUE);\n+    private static final Holder HOLDER2 = new Holder(VALUE2);\n+    private static final RecordHolder RECORD_HOLDER = new RecordHolder(VALUE);\n+    private static final RecordHolder RECORD_HOLDER2 = new RecordHolder(VALUE2);\n+\n+    private final StableValue<Integer> stable = init(StableValue.of(), VALUE);\n+    private final StableValue<Integer> stable2 = init(StableValue.of(), VALUE2);\n+    private final StableValue<Integer> stableNull = StableValue.of();\n+    private final StableValue<Integer> stableNull2 = StableValue.of();\n+    private final Supplier<Integer> dcl = new Dcl<>(() -> VALUE);\n+    private final Supplier<Integer> dcl2 = new Dcl<>(() -> VALUE2);\n+    private final AtomicReference<Integer> atomic = new AtomicReference<>(VALUE);\n+    private final AtomicReference<Integer> atomic2 = new AtomicReference<>(VALUE2);\n+    private final Supplier<Integer> supplier = () -> VALUE;\n+    private final Supplier<Integer> supplier2 = () -> VALUE2;\n+\n+\n+    @Setup\n+    public void setup() {\n+        stableNull.trySet(null);\n+        stableNull2.trySet(null);\n+    }\n+\n+    @Benchmark\n+    public int atomic() {\n+        return atomic.get() + atomic2.get();\n+    }\n+\n+    @Benchmark\n+    public int dcl() {\n+        return dcl.get() + dcl2.get();\n+    }\n+\n+    @Benchmark\n+    public int stable() {\n+        return stable.orElseThrow() + stable2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int stableNull() {\n+        return (stableNull.orElseThrow() == null ? VALUE : VALUE2) + (stableNull2.orElseThrow() == null ? VALUE : VALUE2);\n+    }\n+\n+    \/\/ Reference case\n+    @Benchmark\n+    public int refSupplier() {\n+        return supplier.get() + supplier2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticAtomic() {\n+        return ATOMIC.get() + ATOMIC2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticDcl() {\n+        return DCL.orElseThrow() + DCL2.orElseThrow();\n+    }\n+\n+    @Benchmark\n+    public int staticHolder() {\n+        return HOLDER.get() + HOLDER2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticRecordHolder() {\n+        return RECORD_HOLDER.get() + RECORD_HOLDER2.get();\n+    }\n+\n+    @Benchmark\n+    public int staticStable() {\n+        return STABLE.orElseThrow() + STABLE2.orElseThrow();\n+    }\n+\n+\n+    private static StableValue<Integer> init(StableValue<Integer> m, Integer value) {\n+        m.trySet(value);\n+        return m;\n+    }\n+\n+    private static final class Holder {\n+\n+        private final StableValue<Integer> delegate = StableValue.of();\n+\n+        Holder(int value) {\n+            delegate.setOrThrow(value);\n+        }\n+\n+        int get() {\n+            return delegate.orElseThrow();\n+        }\n+\n+    }\n+\n+    private record RecordHolder(StableValue<Integer> delegate) {\n+\n+        RecordHolder(int value) {\n+            this(StableValue.of());\n+            delegate.setOrThrow(value);\n+        }\n+\n+        int get() {\n+            return delegate.orElseThrow();\n+        }\n+\n+    }\n+\n+\n+    \/\/ Handles null values\n+    public static class Dcl<V> implements Supplier<V> {\n+\n+        private final Supplier<V> supplier;\n+\n+        private volatile V value;\n+        private boolean bound;\n+\n+        public Dcl(Supplier<V> supplier) {\n+            this.supplier = supplier;\n+        }\n+\n+        @Override\n+        public V get() {\n+            V v = value;\n+            if (v == null) {\n+                if (!bound) {\n+                    synchronized (this) {\n+                        v = value;\n+                        if (v == null) {\n+                            if (!bound) {\n+                                value = v = supplier.get();\n+                                bound = true;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableValueBenchmark.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.util.concurrent.TimeUnit.*;\n+\n+@Warmup(iterations = 5, time = 5, timeUnit = SECONDS)\n+@Measurement(iterations = 5, time = 5, timeUnit = SECONDS)\n+@Fork(value = 1, jvmArgs = { \"--enable-preview\" })\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(NANOSECONDS)\n+@State(Scope.Benchmark)\n+public class VarHandleHolderBenchmark {\n+\n+    private static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+            ValueLayout.JAVA_INT.withName(\"x\"),\n+            ValueLayout.JAVA_INT.withName(\"y\")\n+    );\n+\n+    private static final long SIZEOF = LAYOUT.byteSize();\n+    private static final long OFFSET_X = LAYOUT.byteOffset(MemoryLayout.PathElement.groupElement(\"x\"));\n+    private static final long OFFSET_Y = LAYOUT.byteOffset(groupElement(\"y\"));\n+\n+    static final class MyVarHandleLookup implements Function<String, VarHandle> {\n+        @Override\n+        public VarHandle apply(String name) {\n+            return LAYOUT.arrayElementVarHandle(groupElement(name)).withInvokeExactBehavior();\n+        }\n+    }\n+\n+    private static final Function<String, VarHandle> VAR_HANDLE_FUNCTION = new MyVarHandleLookup();\n+\n+    private static final VarHandle VH_X = VAR_HANDLE_FUNCTION.apply(\"x\");\n+    private static final VarHandle VH_Y = VAR_HANDLE_FUNCTION.apply(\"y\");\n+\n+    private static final Supplier<VarHandle> SV_X = StableValue.supplier(() -> VAR_HANDLE_FUNCTION.apply(\"x\"));\n+    private static final Supplier<VarHandle> SV_Y = StableValue.supplier(() -> VAR_HANDLE_FUNCTION.apply(\"y\"));\n+\n+    private static final Map<String, VarHandle> U_MAP = Map.of(\n+            \"x\", VH_X,\n+            \"y\", VH_Y);\n+\n+    private static final Map<String, VarHandle> U_MAP_ELEMENT = Map.of(\n+            \"x\", LAYOUT.varHandle(groupElement(\"x\")),\n+            \"y\", LAYOUT.varHandle(groupElement(\"y\")));\n+\n+    private static final Map<String, VarHandle> S_MAP = StableValue.map(\n+            Set.of(\"x\", \"y\"),\n+            VAR_HANDLE_FUNCTION);\n+\n+    private static final Function<String, VarHandle> S_FUN = StableValue.function(\n+            Set.of(\"x\", \"y\"),\n+            VAR_HANDLE_FUNCTION);\n+\n+    private static final MemorySegment confined;\n+    static {\n+        var array = new int[512 * (int) SIZEOF \/ (int) ValueLayout.JAVA_INT.byteSize()];\n+        var heap = MemorySegment.ofArray(array);\n+        for(var i = 0; i < 512; i++) {\n+            heap.set(ValueLayout.JAVA_INT, i * SIZEOF + OFFSET_X, i);\n+            heap.set(ValueLayout.JAVA_INT, i * SIZEOF + OFFSET_Y, i);\n+        }\n+        confined = Arena.ofConfined().allocate(LAYOUT, 512);\n+        confined.copyFrom(heap);\n+    }\n+\n+    @Benchmark\n+    public int confinedVarHandleLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) VH_X.get(confined, 0L, (long) i);\n+            var y = (int) VH_Y.get(confined, 0L, (long) i);\n+            sum += x \/*+y*\/;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int confinedStableValueLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) SV_X.get().get(confined, 0L, (long) i);\n+            var y = (int) SV_Y.get().get(confined, 0L, (long) i);\n+            sum += x + y;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int confinedStableMapLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) S_MAP.get(\"x\").get(confined, 0L, (long) i);\n+            var y = (int) S_MAP.get(\"y\").get(confined, 0L, (long) i);\n+            sum += x + y;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int confinedStableMapElementLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) U_MAP_ELEMENT.get(\"x\").get(confined, i * 8L);\n+            var y = (int) U_MAP_ELEMENT.get(\"y\").get(confined, i * 8L);\n+            sum += x + y;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int confinedUnmodifiableMapLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) U_MAP.get(\"x\").get(confined, 0L, (long) i);\n+            var y = (int) U_MAP.get(\"y\").get(confined, 0L, (long) i);\n+            sum += x + y;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int confinedStableFunctionLoop() {\n+        var sum = 0;\n+        for (var i = 0; i < 512; i++) {\n+            var x = (int) S_FUN.apply(\"x\").get(confined, 0L, (long) i);\n+            var y = (int) S_FUN.apply(\"y\").get(confined, 0L, (long) i);\n+            sum += x + y;\n+        }\n+        return sum;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/VarHandleHolderBenchmark.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -27,0 +28,2 @@\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n@@ -32,0 +35,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -63,0 +68,36 @@\n+    static class ToolOutput {\n+        ByteArrayOutputStream baos;\n+        PrintStream ps;\n+        String output;\n+\n+        ToolOutput() throws Exception {\n+            baos = new ByteArrayOutputStream();\n+            ps = new PrintStream(baos, true, StandardCharsets.UTF_8.name());\n+        }\n+        void finish() throws Exception {\n+            output = baos.toString(StandardCharsets.UTF_8.name());\n+            System.out.println(output);\n+        }\n+\n+        ToolOutput shouldContain(String... substrings) {\n+            for (String s : substrings) {\n+                if (!output.contains(s)) {\n+                    throw new RuntimeException(\"\\\"\" + s + \"\\\" missing from tool output\");\n+                }\n+            }\n+\n+            return this;\n+        }\n+\n+        ToolOutput shouldMatch(String... regexps) {\n+            for (String regexp : regexps) {\n+                Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);\n+                if (!pattern.matcher(output).find()) {\n+                    throw new RuntimeException(\"Pattern \\\"\" + regexp + \"\\\" missing from tool output\");\n+                }\n+            }\n+\n+            return this;\n+        }\n+    }\n+\n@@ -71,1 +112,2 @@\n-        execTool(\"javac\", \"--help\");\n+        execTool(\"javac\", \"--help\")\n+            .shouldContain(\"Usage: javac <options> <source files>\");\n@@ -78,1 +120,2 @@\n-        execTool(\"javap\", \"--help\");\n+        execTool(\"javap\", \"--help\")\n+            .shouldContain(\"Show package\/protected\/public classes\");\n@@ -82,1 +125,3 @@\n-                 \"jdk.internal.module.ModuleBootstrap\");\n+                 \"jdk.internal.module.ModuleBootstrap\")\n+            .shouldContain(\"Compiled from \\\"System.java\\\"\",\n+                           \"public static java.io.Console console()\");\n@@ -89,2 +134,5 @@\n-        execTool(\"jlink\", \"--help\");\n-        execTool(\"jlink\", \"--list-plugins\");\n+        execTool(\"jlink\", \"--help\")\n+            .shouldContain(\"Compression to use in compressing resources\");\n+        execTool(\"jlink\", \"--list-plugins\")\n+            .shouldContain(\"List of available plugins\",\n+                           \"--generate-cds-archive \");\n@@ -101,1 +149,2 @@\n-        execTool(\"jar\", \"--help\");\n+        execTool(\"jar\", \"--help\")\n+            .shouldContain(\"--main-class=CLASSNAME\");\n@@ -104,4 +153,8 @@\n-        execTool(\"jar\", \"cvf\", jarOutput, \"TestSetupAOT.class\");\n-        execTool(\"jar\", \"uvf\", jarOutput, \"TestSetupAOT.class\");\n-        execTool(\"jar\", \"tvf\", jarOutput);\n-        execTool(\"jar\", \"--describe-module\", \"--file=\" + jarOutput);\n+        execTool(\"jar\", \"cvf\", jarOutput, \"TestSetupAOT.class\")\n+            .shouldContain(\"adding: TestSetupAOT.class\");\n+        execTool(\"jar\", \"uvf\", jarOutput, \"TestSetupAOT.class\")\n+            .shouldContain(\"adding: TestSetupAOT.class\");\n+        execTool(\"jar\", \"tvf\", jarOutput)\n+            .shouldContain(\"META-INF\/MANIFEST.MF\");\n+        execTool(\"jar\", \"--describe-module\", \"--file=\" + jarOutput)\n+            .shouldMatch(\"Unable to derive module descriptor for: .*tmp.jar\");\n@@ -113,2 +166,4 @@\n-        execTool(\"jdeps\", \"--help\");\n-        execTool(\"jdeps\", \"-v\", \"TestSetupAOT.class\");\n+        execTool(\"jdeps\", \"--help\")\n+            .shouldContain(\"--ignore-missing-deps\");\n+        execTool(\"jdeps\", \"-v\", \"TestSetupAOT.class\")\n+            .shouldContain(\"-> JavacBenchApp\");\n@@ -132,1 +187,1 @@\n-    static void execTool(String tool, String... args) throws Throwable {\n+    static ToolOutput execTool(String tool, String... args) throws Throwable {\n@@ -141,0 +196,1 @@\n+        ToolOutput output = new ToolOutput();\n@@ -143,1 +199,4 @@\n-        t.run(System.out, System.out, args);\n+        t.run(output.ps, output.ps, args);\n+\n+        output.finish();\n+        return output;\n","filename":"test\/setup_aot\/TestSetupAOT.java","additions":73,"deletions":14,"binary":false,"changes":87,"status":"modified"}]}