{"files":[{"patch":"@@ -99,0 +99,4 @@\n+ifeq ($(JLINK_PRODUCE_LINKABLE_RUNTIME), true)\n+  JLINK_JDK_EXTRA_OPTS += --generate-linkable-runtime\n+endif\n+\n@@ -135,1 +139,1 @@\n-# Param2 - _nocoops, or empty\n+# Param2 - _nocoops, _coh, _nocoops_coh, or empty\n@@ -138,2 +142,8 @@\n-  $1_$2_$3_DUMP_EXTRA_ARG := $(if $(filter _nocoops, $2), -XX:-UseCompressedOops,) $(if $(filter _valhalla, $3), --enable-preview,)\n-  $1_$2_$3_DUMP_TYPE      := $(if $(filter _nocoops, $2), -NOCOOPS,)$(if $(filter _valhalla, $3), -VALHALLA,)\n+  $1_$2_COOPS_OPTION := $(if $(findstring _nocoops, $2),-XX:-UseCompressedOops)\n+  # enable and also explicitly disable coh as needed.\n+  ifeq ($(call isTargetCpuBits, 64), true)\n+    $1_$2_COH_OPTION := -XX:+UnlockExperimentalVMOptions \\\n+                        $(if $(findstring _coh, $2),-XX:+UseCompactObjectHeaders,-XX:-UseCompactObjectHeaders)\n+  endif\n+  $1_$2_$3_DUMP_EXTRA_ARG := $$($1_$2_COOPS_OPTION) $$($1_$2_COH_OPTION) $(if $(findstring _valhalla, $3), --enable-preview,)\n+  $1_$2_$3_DUMP_TYPE      := $(if $(findstring _nocoops, $2),-NOCOOPS,)$(if $(findstring _coh, $2),-COH,)$(if $(findstring _valhalla, $3), -VALHALLA,)\n@@ -196,0 +206,8 @@\n+    ifeq ($(BUILD_CDS_ARCHIVE_COH), true)\n+      $(foreach v, $(JVM_VARIANTS), \\\n+        $(eval $(call CreateCDSArchive,$v,_coh)) \\\n+      )\n+      $(foreach v, $(JVM_VARIANTS), \\\n+        $(eval $(call CreateCDSArchive,$v,_nocoops_coh)) \\\n+      )\n+    endif\n","filename":"make\/Images.gmk","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -589,1 +589,0 @@\n-# We always keep packaged modules in JDK image.\n@@ -593,1 +592,30 @@\n-  UTIL_ARG_ENABLE(NAME: keep-packaged-modules, DEFAULT: true,\n+\n+  ################################################################################\n+  #\n+  # Configure option for building a JDK that is suitable for linking from the\n+  # run-time image without JMODs.\n+  #\n+  # Determines whether or not a suitable run-time image is being produced from\n+  # packaged modules. If set to 'true, changes the *default* of packaged\n+  # modules to 'false'.\n+  #\n+  UTIL_ARG_ENABLE(NAME: linkable-runtime, DEFAULT: false,\n+      RESULT: JLINK_PRODUCE_LINKABLE_RUNTIME,\n+      DESC: [enable a JDK build suitable for linking from the run-time image],\n+      CHECKING_MSG: [whether or not a JDK suitable for linking from the run-time image should be produced])\n+  AC_SUBST(JLINK_PRODUCE_LINKABLE_RUNTIME)\n+\n+  if test \"x$JLINK_PRODUCE_LINKABLE_RUNTIME\" = xtrue; then\n+    DEFAULT_PACKAGED_MODULES=false\n+  else\n+    DEFAULT_PACKAGED_MODULES=true\n+  fi\n+\n+  ################################################################################\n+  #\n+  # Configure option for packaged modules\n+  #\n+  # We keep packaged modules in the JDK image unless --enable-linkable-runtime is\n+  # requested.\n+  #\n+  UTIL_ARG_ENABLE(NAME: keep-packaged-modules, DEFAULT: $DEFAULT_PACKAGED_MODULES,\n@@ -596,0 +624,1 @@\n+      DEFAULT_DESC: [enabled by default unless --enable-linkable-runtime is set],\n@@ -641,1 +670,1 @@\n-# Optionally disable man pages\n+# Optionally disable man pages (deprecated)\n@@ -645,4 +674,1 @@\n-  UTIL_ARG_ENABLE(NAME: manpages, DEFAULT: true, RESULT: BUILD_MANPAGES,\n-      DESC: [enable copying of static man pages],\n-      CHECKING_MSG: [if static man pages should be copied])\n-  AC_SUBST(BUILD_MANPAGES)\n+  UTIL_DEPRECATED_ARG_ENABLE(manpages)\n@@ -676,0 +702,33 @@\n+################################################################################\n+#\n+# Enable or disable the default CDS archive generation for Compact Object Headers\n+#\n+# Default disabled within Valhalla until support added (JDK-8348568)\n+#\n+AC_DEFUN([JDKOPT_ENABLE_DISABLE_CDS_ARCHIVE_COH],\n+[\n+  UTIL_ARG_ENABLE(NAME: cds-archive-coh, DEFAULT: false, RESULT: BUILD_CDS_ARCHIVE_COH,\n+      DESC: [enable generation of default CDS archives for compact object headers (requires --enable-cds-archive)],\n+      DEFAULT_DESC: [auto],\n+      CHECKING_MSG: [if default CDS archives for compact object headers should be generated],\n+      CHECK_AVAILABLE: [\n+        AC_MSG_CHECKING([if CDS archive with compact object headers is available])\n+        if test \"x$BUILD_CDS_ARCHIVE\" = \"xfalse\"; then\n+          AC_MSG_RESULT([no (CDS default archive generation is disabled)])\n+          AVAILABLE=false\n+        elif test \"x$OPENJDK_TARGET_CPU\" != \"xx86_64\" &&\n+             test \"x$OPENJDK_TARGET_CPU\" != \"xaarch64\" &&\n+             test \"x$OPENJDK_TARGET_CPU\" != \"xppc64\" &&\n+             test \"x$OPENJDK_TARGET_CPU\" != \"xppc64le\" &&\n+             test \"x$OPENJDK_TARGET_CPU\" != \"xriscv64\" &&\n+             test \"x$OPENJDK_TARGET_CPU\" != \"xs390x\"; then\n+          AC_MSG_RESULT([no (compact object headers not supported for this platform)])\n+          AVAILABLE=false\n+        else\n+          AC_MSG_RESULT([yes])\n+          AVAILABLE=true\n+        fi\n+      ])\n+  AC_SUBST(BUILD_CDS_ARCHIVE_COH)\n+])\n+\n","filename":"make\/autoconf\/jdk-options.m4","additions":66,"deletions":7,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -255,1 +255,0 @@\n-            \"--disable-manpages\",\n","filename":"make\/conf\/jib-profiles.js","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1651,0 +1651,1 @@\n+  \/\/   str(rscratch2, Address(rthread, JavaThread::last_Java_pc_offset()));\n@@ -1652,1 +1653,0 @@\n-  \/\/   stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)))\n@@ -3722,0 +3722,1 @@\n+      \/\/ Make the anchor frame walkable\n@@ -3723,0 +3724,1 @@\n+      __ str(rscratch2, Address(rthread, JavaThread::last_Java_pc_offset()));\n@@ -3724,2 +3726,0 @@\n-      \/\/ Leave a breadcrumb for JavaFrameAnchor::capture_last_Java_pc()\n-      __ stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)));\n@@ -3729,1 +3729,0 @@\n-      __ add(sp, sp, 2 * wordSize);\n@@ -5782,0 +5781,4 @@\n+opclass memory_noindex(indirect,\n+                       indOffI1, indOffL1,indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,\n+                       indirectN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n+\n@@ -6708,1 +6711,1 @@\n-  predicate(!needs_acquiring_load(n));\n+  predicate(!needs_acquiring_load(n) && !UseCompactObjectHeaders);\n@@ -6718,0 +6721,14 @@\n+instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory_noindex mem)\n+%{\n+  match(Set dst (LoadNKlass mem));\n+  predicate(!needs_acquiring_load(n) && UseCompactObjectHeaders);\n+\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"load_narrow_klass_compact  $dst, $mem\\t# compressed class ptr\" %}\n+  ins_encode %{\n+    assert($mem$$index$$Register == noreg, \"must not have indexed address\");\n+    __ load_narrow_klass_compact_c2($dst$$Register, $mem$$base$$Register, $mem$$disp);\n+  %}\n+  ins_pipe(iload_reg_mem);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2429,2 +2429,0 @@\n-  Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());\n-  Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());\n@@ -2491,9 +2489,1 @@\n-      if (UseCompressedClassPointers) {\n-        __ ldrw(tmp, src_klass_addr);\n-        __ ldrw(rscratch1, dst_klass_addr);\n-        __ cmpw(tmp, rscratch1);\n-      } else {\n-        __ ldr(tmp, src_klass_addr);\n-        __ ldr(rscratch1, dst_klass_addr);\n-        __ cmp(tmp, rscratch1);\n-      }\n+      __ cmp_klasses_from_objects(src, dst, tmp, rscratch1);\n@@ -2621,3 +2611,0 @@\n-    if (UseCompressedClassPointers) {\n-      __ encode_klass_not_null(tmp);\n-    }\n@@ -2626,8 +2613,1 @@\n-\n-      if (UseCompressedClassPointers) {\n-        __ ldrw(rscratch1, dst_klass_addr);\n-        __ cmpw(tmp, rscratch1);\n-      } else {\n-        __ ldr(rscratch1, dst_klass_addr);\n-        __ cmp(tmp, rscratch1);\n-      }\n+      __ cmp_klass(dst, tmp, rscratch1);\n@@ -2635,7 +2615,1 @@\n-      if (UseCompressedClassPointers) {\n-        __ ldrw(rscratch1, src_klass_addr);\n-        __ cmpw(tmp, rscratch1);\n-      } else {\n-        __ ldr(rscratch1, src_klass_addr);\n-        __ cmp(tmp, rscratch1);\n-      }\n+      __ cmp_klass(src, tmp, rscratch1);\n@@ -2644,7 +2618,1 @@\n-      if (UseCompressedClassPointers) {\n-        __ ldrw(rscratch1, dst_klass_addr);\n-        __ cmpw(tmp, rscratch1);\n-      } else {\n-        __ ldr(rscratch1, dst_klass_addr);\n-        __ cmp(tmp, rscratch1);\n-      }\n+      __ cmp_klass(dst, tmp, rscratch1);\n@@ -2733,6 +2701,1 @@\n-  if (UseCompressedClassPointers) {\n-    __ ldrw(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n-    __ decode_klass_not_null(result);\n-  } else {\n-    __ ldr(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n-  }\n+  __ load_klass(result, obj);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":5,"deletions":42,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+    inc_held_monitor_count(rscratch1);\n@@ -131,1 +132,0 @@\n-  increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -170,0 +170,1 @@\n+    dec_held_monitor_count(rscratch1);\n@@ -171,1 +172,0 @@\n-  decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -186,3 +186,2 @@\n-  if (EnableValhalla) {\n-    \/\/ Need to copy markWord::prototype header for klass\n-    assert_different_registers(obj, klass, len, t1, t2);\n+\n+  if (UseCompactObjectHeaders || EnableValhalla) {\n@@ -190,0 +189,1 @@\n+    str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n@@ -191,2 +191,2 @@\n-    \/\/ This assumes that all prototype bits fit in an int32_t\n-    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n+    mov(t1, checked_cast<int32_t>(markWord::prototype().value()));\n+    str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n@@ -194,1 +194,0 @@\n-  str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n@@ -196,5 +195,7 @@\n-  if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n-    encode_klass_not_null(t1, klass);\n-    strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));\n-  } else {\n-    str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  if (!UseCompactObjectHeaders) {\n+    if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n+      encode_klass_not_null(t1, klass);\n+      strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    } else {\n+      str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    }\n@@ -211,1 +212,1 @@\n-  } else if (UseCompressedClassPointers) {\n+  } else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  does_not_return, requires_return\n+  does_not_return, requires_return, requires_pop_epilogue_return\n@@ -166,1 +166,0 @@\n-\n@@ -172,1 +171,1 @@\n-  bool _return_state;\n+  return_state_t _return_state;\n@@ -186,2 +185,11 @@\n-void StubAssembler::epilogue() {\n-  leave();\n+void StubAssembler::epilogue(bool use_pop) {\n+  \/\/ Avoid using a leave instruction when this frame may\n+  \/\/ have been frozen, since the current value of rfp\n+  \/\/ restored from the stub would be invalid. We still\n+  \/\/ must restore the rfp value saved on enter though.\n+  if (use_pop) {\n+    ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n+    authenticate_return_address();\n+  } else {\n+    leave();\n+  }\n@@ -206,3 +214,1 @@\n-  if (_return_state == requires_return) {\n-    __ epilogue();\n-  } else {\n+  if (_return_state == does_not_return) {\n@@ -210,0 +216,2 @@\n+  } else {\n+    __ epilogue(_return_state == requires_pop_epilogue_return);\n@@ -255,1 +263,1 @@\n-    if (i <= 18 && i != rscratch1->encoding() && i != rscratch2->encoding()) {\n+    if (r == rthread || (i <= 18 && i != rscratch1->encoding() && i != rscratch2->encoding())) {\n@@ -340,0 +348,9 @@\n+\/\/ return: offset in 64-bit words.\n+uint Runtime1::runtime_blob_current_thread_offset(frame f) {\n+  CodeBlob* cb = f.cb();\n+  assert(cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n+         cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id), \"must be\");\n+  assert(cb != nullptr && cb->is_runtime_stub(), \"invalid frame\");\n+  int offset = cpu_reg_save_offsets[rthread->encoding()];\n+  return offset \/ 2;   \/\/ SP offsets are in halfwords\n+}\n@@ -991,1 +1008,1 @@\n-        StubFrame f(sasm, \"monitorenter\", dont_gc_arguments);\n+        StubFrame f(sasm, \"monitorenter\", dont_gc_arguments, requires_pop_epilogue_return);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-  assert_different_registers(oop, box, tmp, disp_hdr);\n+  assert_different_registers(oop, box, tmp, disp_hdr, rscratch2);\n@@ -237,4 +237,2 @@\n-  \/\/ The object's monitor m is unlocked iff m->owner == nullptr,\n-  \/\/ otherwise m->owner may contain a thread or a stack address.\n-  \/\/\n-  \/\/ Try to CAS m->owner from null to current thread.\n+  \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n+  ldr(rscratch2, Address(rthread, JavaThread::lock_id_offset()));\n@@ -242,1 +240,1 @@\n-  cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+  cmpxchg(tmp, zr, rscratch2, Assembler::xword, \/*acquire*\/ true,\n@@ -254,1 +252,1 @@\n-  cmp(tmp3Reg, rthread);\n+  cmp(tmp3Reg, rscratch2);\n@@ -267,1 +265,3 @@\n-  increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n+  if (LockingMode == LM_LEGACY) {\n+    inc_held_monitor_count(rscratch1);\n+  }\n@@ -374,1 +374,3 @@\n-  decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n+  if (LockingMode == LM_LEGACY) {\n+    dec_held_monitor_count(rscratch1);\n+  }\n@@ -382,1 +384,1 @@\n-  assert_different_registers(obj, box, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3, rscratch2);\n@@ -498,2 +500,3 @@\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchg(t2_owner_addr, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n+    ldr(rscratch2, Address(rthread, JavaThread::lock_id_offset()));\n+    cmpxchg(t2_owner_addr, zr, rscratch2, Assembler::xword, \/*acquire*\/ true,\n@@ -504,1 +507,1 @@\n-    cmp(t3_owner, rthread);\n+    cmp(t3_owner, rscratch2);\n@@ -517,1 +520,0 @@\n-  increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -686,1 +688,0 @@\n-  decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -2720,0 +2721,9 @@\n+\n+void C2_MacroAssembler::load_narrow_klass_compact_c2(Register dst, Register obj, int disp) {\n+  \/\/ Note: Don't clobber obj anywhere in that method!\n+\n+  \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n+  \/\/ obj-start, so that we can load from the object's mark-word instead.\n+  ldr(dst, Address(obj, disp - oopDesc::klass_offset_in_bytes()));\n+  lsr(dst, dst, markWord::klass_shift);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -191,0 +191,2 @@\n+  void load_narrow_klass_compact_c2(Register dst, Register obj, int disp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -426,0 +426,30 @@\n+#if defined(ASSERT)\n+static address get_register_address_in_stub(const frame& stub_fr, VMReg reg) {\n+  RegisterMap map(nullptr,\n+                  RegisterMap::UpdateMap::include,\n+                  RegisterMap::ProcessFrames::skip,\n+                  RegisterMap::WalkContinuation::skip);\n+  stub_fr.oop_map()->update_register_map(&stub_fr, &map);\n+  return map.location(reg, stub_fr.sp());\n+}\n+#endif\n+\n+JavaThread** frame::saved_thread_address(const frame& f) {\n+  CodeBlob* cb = f.cb();\n+  assert(cb != nullptr && cb->is_runtime_stub(), \"invalid frame\");\n+\n+  JavaThread** thread_addr;\n+#ifdef COMPILER1\n+  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n+      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n+    thread_addr = (JavaThread**)(f.sp() + Runtime1::runtime_blob_current_thread_offset(f));\n+  } else\n+#endif\n+  {\n+    \/\/ c2 only saves rbp in the stub frame so nothing to do.\n+    thread_addr = nullptr;\n+  }\n+  assert(get_register_address_in_stub(f, SharedRuntime::thread_register()) == (address)thread_addr, \"wrong thread address\");\n+  return thread_addr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -76,1 +76,2 @@\n-    interpreter_frame_oop_temp_offset                =  3, \/\/ for native calls only\n+    interpreter_frame_result_handler_offset          =  3, \/\/ for native calls only\n+    interpreter_frame_oop_temp_offset                =  2, \/\/ for native calls only\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -765,1 +765,1 @@\n-    call_VM(noreg,\n+    call_VM_preemptable(noreg,\n@@ -796,1 +796,1 @@\n-      b(count);\n+      b(done);\n@@ -850,1 +850,5 @@\n-      br(Assembler::EQ, count);\n+      br(Assembler::NE, slow_case);\n+\n+      bind(count);\n+      inc_held_monitor_count(rscratch1);\n+      b(done);\n@@ -855,1 +859,1 @@\n-    call_VM(noreg,\n+    call_VM_preemptable(noreg,\n@@ -858,4 +862,0 @@\n-    b(done);\n-\n-    bind(count);\n-    increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -907,0 +907,1 @@\n+    Label slow_case;\n@@ -908,3 +909,1 @@\n-      Label slow_case;\n-      b(count);\n-      bind(slow_case);\n+      b(done);\n@@ -921,1 +920,5 @@\n-      cmpxchg_obj_header(swap_reg, header_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n+      cmpxchg_obj_header(swap_reg, header_reg, obj_reg, rscratch1, count, &slow_case);\n+\n+      bind(count);\n+      dec_held_monitor_count(rscratch1);\n+      b(done);\n@@ -923,0 +926,2 @@\n+\n+    bind(slow_case);\n@@ -926,5 +931,0 @@\n-    b(done);\n-\n-    bind(count);\n-    decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n@@ -1748,0 +1748,49 @@\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                                    address entry_point,\n+                                                    Register arg_1) {\n+  assert(arg_1 == c_rarg1, \"\");\n+  Label resume_pc, not_preempted;\n+\n+#ifdef ASSERT\n+  {\n+    Label L;\n+    ldr(rscratch1, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+    cbz(rscratch1, L);\n+    stop(\"Should not have alternate return address set\");\n+    bind(L);\n+  }\n+#endif \/* ASSERT *\/\n+\n+  \/\/ Force freeze slow path.\n+  push_cont_fastpath();\n+\n+  \/\/ Make VM call. In case of preemption set last_pc to the one we want to resume to.\n+  adr(rscratch1, resume_pc);\n+  str(rscratch1, Address(rthread, JavaThread::last_Java_pc_offset()));\n+  call_VM_base(oop_result, noreg, noreg, entry_point, 1, false \/*check_exceptions*\/);\n+\n+  pop_cont_fastpath();\n+\n+  \/\/ Check if preempted.\n+  ldr(rscratch1, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+  cbz(rscratch1, not_preempted);\n+  str(zr, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+  br(rscratch1);\n+\n+  \/\/ In case of preemption, this is where we will resume once we finally acquire the monitor.\n+  bind(resume_pc);\n+  restore_after_resume(false \/* is_native *\/);\n+\n+  bind(not_preempted);\n+}\n+\n+void InterpreterMacroAssembler::restore_after_resume(bool is_native) {\n+  lea(rscratch1, ExternalAddress(Interpreter::cont_resume_interpreter_adapter()));\n+  blr(rscratch1);\n+  if (is_native) {\n+    \/\/ On resume we need to set up stack as expected\n+    push(dtos);\n+    push(ltos);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":66,"deletions":17,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -61,0 +61,5 @@\n+  void call_VM_preemptable(Register oop_result,\n+                           address entry_point,\n+                           Register arg_1);\n+  void restore_after_resume(bool is_native);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"interpreter\/interpreterRuntime.hpp\"\n@@ -782,0 +783,4 @@\n+static bool is_preemptable(address entry_point) {\n+  return entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter);\n+}\n+\n@@ -817,1 +822,6 @@\n-  set_last_Java_frame(last_java_sp, rfp, l, rscratch1);\n+  if (is_preemptable(entry_point)) {\n+    \/\/ skip setting last_pc since we already set it to desired value.\n+    set_last_Java_frame(last_java_sp, rfp, noreg, rscratch1);\n+  } else {\n+    set_last_Java_frame(last_java_sp, rfp, l, rscratch1);\n+  }\n@@ -1009,0 +1019,1 @@\n+  int extra_instructions = UseCompactObjectHeaders ? 1 : 0;\n@@ -1010,1 +1021,1 @@\n-    return NativeInstruction::instruction_size * 7;\n+    return NativeInstruction::instruction_size * (7 + extra_instructions);\n@@ -1012,1 +1023,1 @@\n-    return NativeInstruction::instruction_size * 5;\n+    return NativeInstruction::instruction_size * (5 + extra_instructions);\n@@ -1030,1 +1041,5 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(tmp1, receiver);\n+    ldrw(tmp2, Address(data, CompiledICData::speculated_klass_offset()));\n+    cmpw(tmp1, tmp2);\n+  } else if (UseCompressedClassPointers) {\n@@ -2279,1 +2294,2 @@\n-  andr(markword, markword, markWord::inline_type_mask_in_place);\n+  mov(rscratch2, markWord::inline_type_mask_in_place);\n+  andr(markword, markword, rscratch2);\n@@ -5170,1 +5186,3 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(dst, src);\n+  } else if (UseCompressedClassPointers) {\n@@ -5177,0 +5195,11 @@\n+\/\/ Loads the obj's Klass* into dst.\n+\/\/ Preserves all registers (incl src, rscratch1 and rscratch2).\n+\/\/ Input:\n+\/\/ src - the oop we want to load the klass from.\n+\/\/ dst - output narrow klass.\n+void MacroAssembler::load_narrow_klass_compact(Register dst, Register src) {\n+  assert(UseCompactObjectHeaders, \"expects UseCompactObjectHeaders\");\n+  ldr(dst, Address(src, oopDesc::mark_offset_in_bytes()));\n+  lsr(dst, dst, markWord::klass_shift);\n+}\n+\n@@ -5178,1 +5207,4 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(dst, src);\n+    decode_klass_not_null(dst);\n+  } else if (UseCompressedClassPointers) {\n@@ -5233,1 +5265,2 @@\n-void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {\n+void MacroAssembler::cmp_klass(Register obj, Register klass, Register tmp) {\n+  assert_different_registers(obj, klass, tmp);\n@@ -5235,1 +5268,5 @@\n-    ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n+    if (UseCompactObjectHeaders) {\n+      load_narrow_klass_compact(tmp, obj);\n+    } else {\n+      ldrw(tmp, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    }\n@@ -5237,1 +5274,1 @@\n-      cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());\n+      cmp(klass, tmp, LSL, CompressedKlassPointers::shift());\n@@ -5242,1 +5279,1 @@\n-      cmpw(trial_klass, tmp);\n+      cmpw(klass, tmp);\n@@ -5247,1 +5284,18 @@\n-    ldr(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n+    ldr(tmp, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  }\n+  cmp(klass, tmp);\n+}\n+\n+void MacroAssembler::cmp_klasses_from_objects(Register obj1, Register obj2, Register tmp1, Register tmp2) {\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(tmp1, obj1);\n+    load_narrow_klass_compact(tmp2,  obj2);\n+    cmpw(tmp1, tmp2);\n+  } else if (UseCompressedClassPointers) {\n+    ldrw(tmp1, Address(obj1, oopDesc::klass_offset_in_bytes()));\n+    ldrw(tmp2, Address(obj2, oopDesc::klass_offset_in_bytes()));\n+    cmpw(tmp1, tmp2);\n+  } else {\n+    ldr(tmp1, Address(obj1, oopDesc::klass_offset_in_bytes()));\n+    ldr(tmp2, Address(obj2, oopDesc::klass_offset_in_bytes()));\n+    cmp(tmp1, tmp2);\n@@ -5249,1 +5303,0 @@\n-  cmp(trial_klass, tmp);\n@@ -5260,0 +5313,1 @@\n+  assert(!UseCompactObjectHeaders, \"not with compact headers\");\n@@ -5269,0 +5323,1 @@\n+  assert(!UseCompactObjectHeaders, \"not with compact headers\");\n@@ -5419,3 +5474,0 @@\n-  assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift()\n-         || 0 == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-\n@@ -5447,1 +5499,1 @@\n-      lsr(dst, src, LogKlassAlignmentInBytes);\n+      lsr(dst, src, CompressedKlassPointers::shift());\n@@ -5456,1 +5508,1 @@\n-      lsr(dst, dst, LogKlassAlignmentInBytes);\n+      lsr(dst, dst, CompressedKlassPointers::shift());\n@@ -5464,1 +5516,1 @@\n-      ubfx(dst, src, LogKlassAlignmentInBytes, 32);\n+      ubfx(dst, src, CompressedKlassPointers::shift(), 32);\n@@ -5486,1 +5538,1 @@\n-      lsl(dst, src, LogKlassAlignmentInBytes);\n+      lsl(dst, src, CompressedKlassPointers::shift());\n@@ -5494,1 +5546,1 @@\n-      lsl(dst, src, LogKlassAlignmentInBytes);\n+      lsl(dst, src, CompressedKlassPointers::shift());\n@@ -5509,1 +5561,1 @@\n-      lsl(dst, dst, LogKlassAlignmentInBytes);\n+      lsl(dst, dst, CompressedKlassPointers::shift());\n@@ -5739,1 +5791,3 @@\n-      subs(layout_size, layout_size, sizeof(oopDesc));\n+      int header_size = oopDesc::header_size() * HeapWordSize;\n+      assert(is_aligned(header_size, BytesPerLong), \"oop header size must be 8-byte-aligned\");\n+      subs(layout_size, layout_size, header_size);\n@@ -5764,1 +5818,1 @@\n-        str(zr, Address(rscratch1, sizeof(oopDesc) - 1*oopSize));\n+        str(zr, Address(rscratch1, header_size - 1*oopSize));\n@@ -5774,6 +5828,12 @@\n-    ldr(mark_word, Address(klass, Klass::prototype_header_offset()));\n-    str(mark_word, Address(new_obj, oopDesc::mark_offset_in_bytes ()));\n-    store_klass_gap(new_obj, zr);  \/\/ zero klass gap for compressed oops\n-    mov(t2, klass);         \/\/ preserve klass\n-    store_klass(new_obj, t2);  \/\/ src klass reg is potentially compressed\n-\n+    if (UseCompactObjectHeaders || EnableValhalla) {\n+      ldr(mark_word, Address(klass, Klass::prototype_header_offset()));\n+      str(mark_word, Address(new_obj, oopDesc::mark_offset_in_bytes()));\n+    } else {\n+      mov(mark_word, (intptr_t)markWord::prototype().value());\n+      str(mark_word, Address(new_obj, oopDesc::mark_offset_in_bytes()));\n+    }\n+    if (!UseCompactObjectHeaders) {\n+      store_klass_gap(new_obj, zr);  \/\/ zero klass gap for compressed oops\n+      mov(t2, klass);                \/\/ preserve klass\n+      store_klass(new_obj, t2);      \/\/ src klass reg is potentially compressed\n+    }\n@@ -5806,0 +5866,32 @@\n+void MacroAssembler::inc_held_monitor_count(Register tmp) {\n+  Address dst(rthread, JavaThread::held_monitor_count_offset());\n+#ifdef ASSERT\n+  ldr(tmp, dst);\n+  increment(tmp);\n+  str(tmp, dst);\n+  Label ok;\n+  tbz(tmp, 63, ok);\n+  STOP(\"assert(held monitor count underflow)\");\n+  should_not_reach_here();\n+  bind(ok);\n+#else\n+  increment(dst);\n+#endif\n+}\n+\n+void MacroAssembler::dec_held_monitor_count(Register tmp) {\n+  Address dst(rthread, JavaThread::held_monitor_count_offset());\n+#ifdef ASSERT\n+  ldr(tmp, dst);\n+  decrement(tmp);\n+  str(tmp, dst);\n+  Label ok;\n+  tbz(tmp, 63, ok);\n+  STOP(\"assert(held monitor count underflow)\");\n+  should_not_reach_here();\n+  bind(ok);\n+#else\n+  decrement(dst);\n+#endif\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":122,"deletions":30,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -915,0 +915,1 @@\n+  void load_narrow_klass_compact(Register dst, Register src);\n@@ -917,1 +918,2 @@\n-  void cmp_klass(Register oop, Register trial_klass, Register tmp);\n+  void cmp_klass(Register obj, Register klass, Register tmp);\n+  void cmp_klasses_from_objects(Register obj1, Register obj2, Register tmp1, Register tmp2);\n@@ -989,2 +991,5 @@\n-  void push_cont_fastpath(Register java_thread);\n-  void pop_cont_fastpath(Register java_thread);\n+  void push_cont_fastpath(Register java_thread = rthread);\n+  void pop_cont_fastpath(Register java_thread = rthread);\n+\n+  void inc_held_monitor_count(Register tmp);\n+  void dec_held_monitor_count(Register tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1457,0 +1457,1 @@\n+  ContinuationEntry::_thaw_call_pc_offset = __ pc() - start;\n@@ -1463,0 +1464,1 @@\n+  ContinuationEntry::_cleanup_offset = __ pc() - start;\n@@ -1559,0 +1561,4 @@\n+void SharedRuntime::continuation_enter_cleanup(MacroAssembler* masm) {\n+  ::continuation_enter_cleanup(masm);\n+}\n+\n@@ -2025,2 +2031,3 @@\n-  \/\/ be pushed on the stack when we do a stack traversal).\n-  \/\/ We use the same pc\/oopMap repeatedly when we call out\n+  \/\/ be pushed on the stack when we do a stack traversal). It is enough that the pc()\n+  \/\/ points into the right code segment. It does not have to be the correct return pc.\n+  \/\/ We use the same pc\/oopMap repeatedly when we call out.\n@@ -2029,1 +2036,9 @@\n-  __ set_last_Java_frame(sp, noreg, native_return, rscratch1);\n+  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+    \/\/ For convenience we use the pc we want to resume to in case of preemption on Object.wait.\n+    __ set_last_Java_frame(sp, noreg, native_return, rscratch1);\n+  } else {\n+    intptr_t the_pc = (intptr_t) __ pc();\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    __ set_last_Java_frame(sp, noreg, __ pc(), rscratch1);\n+  }\n@@ -2111,0 +2126,3 @@\n+\n+      __ bind(count);\n+      __ inc_held_monitor_count(rscratch1);\n@@ -2115,2 +2133,0 @@\n-    __ bind(count);\n-    __ increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -2135,5 +2151,0 @@\n-  __ bind(native_return);\n-\n-  intptr_t return_pc = (intptr_t) __ pc();\n-  oop_maps->add_gc_map(return_pc - start, map);\n-\n@@ -2198,0 +2209,12 @@\n+  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+    \/\/ Check preemption for Object.wait()\n+    __ ldr(rscratch1, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+    __ cbz(rscratch1, native_return);\n+    __ str(zr, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+    __ br(rscratch1);\n+    __ bind(native_return);\n+\n+    intptr_t the_pc = (intptr_t) __ pc();\n+    oop_maps->add_gc_map(the_pc - start, map);\n+  }\n+\n@@ -2221,1 +2244,1 @@\n-      __ decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n+      __ dec_held_monitor_count(rscratch1);\n@@ -2244,1 +2267,1 @@\n-      __ decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n+      __ dec_held_monitor_count(rscratch1);\n@@ -2248,1 +2271,0 @@\n-      __ decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -2315,1 +2337,6 @@\n-    \/\/ Not a leaf but we have last_Java_frame setup as we want\n+    \/\/ Not a leaf but we have last_Java_frame setup as we want.\n+    \/\/ We don't want to unmount in case of contention since that would complicate preserving\n+    \/\/ the arguments that had already been marshalled into the native convention. So we force\n+    \/\/ the freeze slow path to find this native wrapper frame (see recurse_freeze_native_frame())\n+    \/\/ and pin the vthread. Otherwise the fast path won't find it since we don't walk the stack.\n+    __ push_cont_fastpath();\n@@ -2317,0 +2344,1 @@\n+    __ pop_cont_fastpath();\n@@ -2857,0 +2885,4 @@\n+VMReg SharedRuntime::thread_register() {\n+  return rthread->as_VMReg();\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":46,"deletions":14,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -7491,0 +7491,31 @@\n+  address generate_cont_preempt_stub() {\n+    if (!Continuations::enabled()) return nullptr;\n+    StubCodeMark mark(this, \"StubRoutines\",\"Continuation preempt stub\");\n+    address start = __ pc();\n+\n+    __ reset_last_Java_frame(true);\n+\n+    \/\/ Set sp to enterSpecial frame, i.e. remove all frames copied into the heap.\n+    __ ldr(rscratch2, Address(rthread, JavaThread::cont_entry_offset()));\n+    __ mov(sp, rscratch2);\n+\n+    Label preemption_cancelled;\n+    __ ldrb(rscratch1, Address(rthread, JavaThread::preemption_cancelled_offset()));\n+    __ cbnz(rscratch1, preemption_cancelled);\n+\n+    \/\/ Remove enterSpecial frame from the stack and return to Continuation.run() to unmount.\n+    SharedRuntime::continuation_enter_cleanup(_masm);\n+    __ leave();\n+    __ ret(lr);\n+\n+    \/\/ We acquired the monitor after freezing the frames so call thaw to continue execution.\n+    __ bind(preemption_cancelled);\n+    __ strb(zr, Address(rthread, JavaThread::preemption_cancelled_offset()));\n+    __ lea(rfp, Address(sp, checked_cast<int32_t>(ContinuationEntry::size())));\n+    __ lea(rscratch1, ExternalAddress(ContinuationEntry::thaw_call_pc_address()));\n+    __ ldr(rscratch1, Address(rscratch1));\n+    __ br(rscratch1);\n+\n+    return start;\n+  }\n+\n@@ -8781,0 +8812,1 @@\n+    StubRoutines::_cont_preempt_stub = generate_cont_preempt_stub();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -616,0 +616,34 @@\n+address TemplateInterpreterGenerator::generate_cont_resume_interpreter_adapter() {\n+  if (!Continuations::enabled()) return nullptr;\n+  address start = __ pc();\n+\n+  __ restore_bcp();\n+  __ restore_locals();\n+\n+  \/\/ Restore constant pool cache\n+  __ ldr(rcpool, Address(rfp, frame::interpreter_frame_cache_offset * wordSize));\n+\n+  \/\/ Restore Java expression stack pointer\n+  __ ldr(rscratch1, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));\n+  __ lea(esp, Address(rfp, rscratch1, Address::lsl(Interpreter::logStackElementSize)));\n+  \/\/ and NULL it as marker that esp is now tos until next java call\n+  __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));\n+\n+  \/\/ Restore machine SP\n+  __ ldr(rscratch1, Address(rfp, frame::interpreter_frame_extended_sp_offset * wordSize));\n+  __ lea(sp, Address(rfp, rscratch1, Address::lsl(LogBytesPerWord)));\n+\n+  \/\/ Restore method\n+  __ ldr(rmethod, Address(rfp, frame::interpreter_frame_method_offset * wordSize));\n+\n+  \/\/ Restore dispatch\n+  uint64_t offset;\n+  __ adrp(rdispatch, ExternalAddress((address)Interpreter::dispatch_table()), offset);\n+  __ add(rdispatch, rdispatch, offset);\n+\n+  __ ret(lr);\n+\n+  return start;\n+}\n+\n+\n@@ -1323,0 +1357,3 @@\n+  \/\/ Save it in the frame in case of preemption; we cannot rely on callee saved registers.\n+  __ str(r0, Address(rfp, frame::interpreter_frame_result_handler_offset * wordSize));\n+\n@@ -1358,3 +1395,4 @@\n-  \/\/ Set the last Java PC in the frame anchor to be the return address from\n-  \/\/ the call to the native method: this will allow the debugger to\n-  \/\/ generate an accurate stack trace.\n+  \/\/ It is enough that the pc() points into the right code\n+  \/\/ segment. It does not have to be the correct return pc.\n+  \/\/ For convenience we use the pc we want to resume to in\n+  \/\/ case of preemption on Object.wait.\n@@ -1381,0 +1419,2 @@\n+  __ push_cont_fastpath();\n+\n@@ -1383,1 +1423,3 @@\n-  __ bind(native_return);\n+\n+  __ pop_cont_fastpath();\n+\n@@ -1441,0 +1483,17 @@\n+  if (LockingMode != LM_LEGACY) {\n+    \/\/ Check preemption for Object.wait()\n+    Label not_preempted;\n+    __ ldr(rscratch1, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+    __ cbz(rscratch1, not_preempted);\n+    __ str(zr, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+    __ br(rscratch1);\n+    __ bind(native_return);\n+    __ restore_after_resume(true \/* is_native *\/);\n+    \/\/ reload result_handler\n+    __ ldr(result_handler, Address(rfp, frame::interpreter_frame_result_handler_offset*wordSize));\n+    __ bind(not_preempted);\n+  } else {\n+    \/\/ any pc will do so just use this one for LM_LEGACY to keep code together.\n+    __ bind(native_return);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":63,"deletions":4,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1999,10 +1999,1 @@\n-      if (UseCompressedClassPointers) {\n-        \/\/ We don't need decode because we just need to compare.\n-        __ lwz(tmp, oopDesc::klass_offset_in_bytes(), src);\n-        __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);\n-        __ cmpw(CCR0, tmp, tmp2);\n-      } else {\n-        __ ld(tmp, oopDesc::klass_offset_in_bytes(), src);\n-        __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);\n-        __ cmpd(CCR0, tmp, tmp2);\n-      }\n+      __ cmp_klasses_from_objects(CCR0, src, dst, tmp, tmp2);\n@@ -2131,19 +2122,5 @@\n-    if (UseCompressedClassPointers) {\n-      \/\/ Tmp holds the default type. It currently comes uncompressed after the\n-      \/\/ load of a constant, so encode it.\n-      __ encode_klass_not_null(tmp);\n-      \/\/ Load the raw value of the dst klass, since we will be comparing\n-      \/\/ uncompressed values directly.\n-      __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);\n-      __ cmpw(CCR0, tmp, tmp2);\n-      if (basic_type != T_OBJECT) {\n-        __ bne(CCR0, halt);\n-        \/\/ Load the raw value of the src klass.\n-        __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), src);\n-        __ cmpw(CCR0, tmp, tmp2);\n-        __ beq(CCR0, known_ok);\n-      } else {\n-        __ beq(CCR0, known_ok);\n-        __ cmpw(CCR0, src, dst);\n-        __ beq(CCR0, known_ok);\n-      }\n+    __ cmp_klass(CCR0, dst, tmp, R11_scratch1, R12_scratch2);\n+    if (basic_type != T_OBJECT) {\n+      __ bne(CCR0, halt);\n+      __ cmp_klass(CCR0, src, tmp, R11_scratch1, R12_scratch2);\n+      __ beq(CCR0, known_ok);\n@@ -2151,13 +2128,3 @@\n-      __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);\n-      __ cmpd(CCR0, tmp, tmp2);\n-      if (basic_type != T_OBJECT) {\n-        __ bne(CCR0, halt);\n-        \/\/ Load the raw value of the src klass.\n-        __ ld(tmp2, oopDesc::klass_offset_in_bytes(), src);\n-        __ cmpd(CCR0, tmp, tmp2);\n-        __ beq(CCR0, known_ok);\n-      } else {\n-        __ beq(CCR0, known_ok);\n-        __ cmpd(CCR0, src, dst);\n-        __ beq(CCR0, known_ok);\n-      }\n+      __ beq(CCR0, known_ok);\n+      __ cmpw(CCR0, src, dst);\n+      __ beq(CCR0, known_ok);\n@@ -2741,6 +2708,1 @@\n-  if (UseCompressedClassPointers) {\n-    __ lwz(result, oopDesc::klass_offset_in_bytes(), obj);\n-    __ decode_klass_not_null(result);\n-  } else {\n-    __ ld(result, oopDesc::klass_offset_in_bytes(), obj);\n-  }\n+  __ load_klass(result, obj);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":10,"deletions":48,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -935,1 +935,1 @@\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n+    call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n@@ -956,2 +956,1 @@\n-    Label count_locking, done;\n-    Label cas_failed, slow_case;\n+    Label count_locking, done, slow_case, cas_failed;\n@@ -972,1 +971,1 @@\n-      b(count_locking);\n+      b(done);\n@@ -1038,2 +1037,1 @@\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    b(done);\n+    call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n@@ -1041,3 +1039,7 @@\n-    align(32, 12);\n-    bind(count_locking);\n-    inc_held_monitor_count(current_header \/*tmp*\/);\n+\n+    if (LockingMode == LM_LEGACY) {\n+      b(done);\n+      align(32, 12);\n+      bind(count_locking);\n+      inc_held_monitor_count(current_header \/*tmp*\/);\n+    }\n@@ -1140,1 +1142,3 @@\n-    dec_held_monitor_count(current_header \/*tmp*\/);\n+    if (LockingMode == LM_LEGACY) {\n+      dec_held_monitor_count(current_header \/*tmp*\/);\n+    }\n@@ -2136,1 +2140,1 @@\n-void InterpreterMacroAssembler::call_VM(Register oop_result, address entry_point, bool check_exceptions) {\n+void InterpreterMacroAssembler::call_VM(Register oop_result, address entry_point, bool check_exceptions, Label* last_java_pc) {\n@@ -2139,1 +2143,1 @@\n-  MacroAssembler::call_VM(oop_result, entry_point, false);\n+  MacroAssembler::call_VM(oop_result, entry_point, false \/*check_exceptions*\/, last_java_pc);\n@@ -2158,0 +2162,68 @@\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result, address entry_point,\n+                                        Register arg_1, bool check_exceptions) {\n+  if (!Continuations::enabled()) {\n+    call_VM(oop_result, entry_point, arg_1, check_exceptions);\n+    return;\n+  }\n+\n+  Label resume_pc, not_preempted;\n+\n+  DEBUG_ONLY(ld(R0, in_bytes(JavaThread::preempt_alternate_return_offset()), R16_thread));\n+  DEBUG_ONLY(cmpdi(CCR0, R0, 0));\n+  asm_assert_eq(\"Should not have alternate return address set\");\n+\n+  \/\/ Preserve 2 registers\n+  assert(nonvolatile_accross_vthread_preemtion(R31) && nonvolatile_accross_vthread_preemtion(R22), \"\");\n+  ld(R3_ARG1, _abi0(callers_sp), R1_SP); \/\/ load FP\n+  std(R31, _ijava_state_neg(lresult), R3_ARG1);\n+  std(R22, _ijava_state_neg(fresult), R3_ARG1);\n+\n+  \/\/ We set resume_pc as last java pc. It will be saved if the vthread gets preempted.\n+  \/\/ Later execution will continue right there.\n+  mr_if_needed(R4_ARG2, arg_1);\n+  push_cont_fastpath();\n+  call_VM(oop_result, entry_point, false \/*check_exceptions*\/, &resume_pc \/* last_java_pc *\/);\n+  pop_cont_fastpath();\n+\n+  \/\/ Jump to handler if the call was preempted\n+  ld(R0, in_bytes(JavaThread::preempt_alternate_return_offset()), R16_thread);\n+  cmpdi(CCR0, R0, 0);\n+  beq(CCR0, not_preempted);\n+  mtlr(R0);\n+  li(R0, 0);\n+  std(R0, in_bytes(JavaThread::preempt_alternate_return_offset()), R16_thread);\n+  blr();\n+\n+  bind(resume_pc); \/\/ Location to resume execution\n+  restore_after_resume(noreg \/* fp *\/);\n+  bind(not_preempted);\n+}\n+\n+void InterpreterMacroAssembler::restore_after_resume(Register fp) {\n+  if (!Continuations::enabled()) return;\n+\n+  const address resume_adapter = TemplateInterpreter::cont_resume_interpreter_adapter();\n+  add_const_optimized(R31, R29_TOC, MacroAssembler::offset_to_global_toc(resume_adapter));\n+  mtctr(R31);\n+  bctrl();\n+  \/\/ Restore registers that are preserved across vthread preemption\n+  assert(nonvolatile_accross_vthread_preemtion(R31) && nonvolatile_accross_vthread_preemtion(R22), \"\");\n+  ld(R3_ARG1, _abi0(callers_sp), R1_SP); \/\/ load FP\n+  ld(R31, _ijava_state_neg(lresult), R3_ARG1);\n+  ld(R22, _ijava_state_neg(fresult), R3_ARG1);\n+#ifdef ASSERT\n+  \/\/ Assert FP is in R11_scratch1 (see generate_cont_resume_interpreter_adapter())\n+  {\n+    Label ok;\n+    ld(R12_scratch2, 0, R1_SP);  \/\/ load fp\n+    cmpd(CCR0, R12_scratch2, R11_scratch1);\n+    beq(CCR0, ok);\n+    stop(FILE_AND_LINE \": FP is expected in R11_scratch1\");\n+    bind(ok);\n+  }\n+#endif\n+  if (fp != noreg && fp != R11_scratch1) {\n+    mr(fp, R11_scratch1);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":84,"deletions":12,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2050,2 +2050,0 @@\n-  Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());\n-  Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());\n@@ -2115,7 +2113,1 @@\n-      if (UseCompressedClassPointers) {\n-        __ z_l(tmp, src_klass_addr);\n-        __ z_c(tmp, dst_klass_addr);\n-      } else {\n-        __ z_lg(tmp, src_klass_addr);\n-        __ z_cg(tmp, dst_klass_addr);\n-      }\n+      __ cmp_klasses_from_objects(src, dst, tmp, Z_R1_scratch);\n@@ -2255,2 +2247,1 @@\n-      if (UseCompressedClassPointers)         { __ z_c (tmp, dst_klass_addr); }\n-      else                                    { __ z_cg(tmp, dst_klass_addr); }\n+      __ cmp_klass(tmp, dst, Z_R1_scratch);\n@@ -2258,2 +2249,2 @@\n-      if (UseCompressedClassPointers)         { __ z_c (tmp, src_klass_addr); }\n-      else                                    { __ z_cg(tmp, src_klass_addr); }\n+\n+      __ cmp_klass(tmp, src, Z_R1_scratch);\n@@ -2262,2 +2253,1 @@\n-      if (UseCompressedClassPointers)         { __ z_c (tmp, dst_klass_addr); }\n-      else                                    { __ z_cg(tmp, dst_klass_addr); }\n+      __ cmp_klass(tmp, dst, Z_R1_scratch);\n@@ -2758,6 +2748,1 @@\n-  if (UseCompressedClassPointers) {\n-    __ z_llgf(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n-    __ decode_klass_not_null(result);\n-  } else {\n-    __ z_lg(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n-  }\n+  __ load_klass(result, obj);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3218,0 +3218,1 @@\n+  Register tmp2 = UseCompactObjectHeaders ? rscratch2 : noreg;\n@@ -3356,2 +3357,0 @@\n-  Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());\n-  Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());\n@@ -3423,7 +3422,1 @@\n-      if (UseCompressedClassPointers) {\n-        __ movl(tmp, src_klass_addr);\n-        __ cmpl(tmp, dst_klass_addr);\n-      } else {\n-        __ movptr(tmp, src_klass_addr);\n-        __ cmpptr(tmp, dst_klass_addr);\n-      }\n+      __ cmp_klasses_from_objects(src, dst, tmp, tmp2);\n@@ -3488,0 +3481,1 @@\n+       Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());\n@@ -3591,3 +3585,1 @@\n-\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);\n-      else                   __ cmpptr(tmp, dst_klass_addr);\n+      __ cmp_klass(tmp, dst, tmp2);\n@@ -3595,2 +3587,1 @@\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);\n-      else                   __ cmpptr(tmp, src_klass_addr);\n+      __ cmp_klass(tmp, src, tmp2);\n@@ -3599,2 +3590,1 @@\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);\n-      else                   __ cmpptr(tmp, dst_klass_addr);\n+      __ cmp_klass(tmp, dst, tmp2);\n@@ -3697,7 +3687,1 @@\n-#ifdef _LP64\n-  if (UseCompressedClassPointers) {\n-    __ movl(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n-    __ decode_klass_not_null(result, rscratch1);\n-  } else\n-#endif\n-    __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  __ load_klass(result, obj, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+    inc_held_monitor_count();\n@@ -119,2 +120,0 @@\n-  inc_held_monitor_count();\n-\n@@ -161,0 +160,2 @@\n+    bind(done);\n+    dec_held_monitor_count();\n@@ -162,2 +163,0 @@\n-  bind(done);\n-  dec_held_monitor_count();\n@@ -178,4 +177,2 @@\n-  assert_different_registers(obj, klass, len);\n-  if (EnableValhalla) {\n-    \/\/ Need to copy markWord::prototype header for klass\n-    assert_different_registers(obj, klass, len, t1, t2);\n+  assert_different_registers(obj, klass, len, t1, t2);\n+  if (UseCompactObjectHeaders || EnableValhalla) {\n@@ -185,1 +182,0 @@\n-    \/\/ This assumes that all prototype bits fit in an int32_t\n@@ -193,1 +189,1 @@\n-  } else\n+  } else if (!UseCompactObjectHeaders)\n@@ -212,1 +208,1 @@\n-  else if (UseCompressedClassPointers) {\n+  else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n@@ -246,1 +242,3 @@\n-\n+  if (UseCompactObjectHeaders) {\n+    assert(hdr_size_in_bytes == 8, \"check object headers size\");\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -209,0 +209,1 @@\n+  bool _use_pop_on_epilog;\n@@ -211,1 +212,1 @@\n-  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments);\n+  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, bool use_pop_on_epilog = false);\n@@ -222,2 +223,6 @@\n-void StubAssembler::epilogue() {\n-  leave();\n+void StubAssembler::epilogue(bool use_pop) {\n+  \/\/ Avoid using a leave instruction when this frame may\n+  \/\/ have been frozen, since the current value of rbp\n+  \/\/ restored from the stub would be invalid. We still\n+  \/\/ must restore the rbp value saved on enter though.\n+  use_pop ? pop(rbp) : leave();\n@@ -229,1 +234,1 @@\n-StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments) {\n+StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, bool use_pop_on_epilog) {\n@@ -231,0 +236,1 @@\n+  _use_pop_on_epilog = use_pop_on_epilog;\n@@ -242,1 +248,1 @@\n-  __ epilogue();\n+  __ epilogue(_use_pop_on_epilog);\n@@ -635,0 +641,9 @@\n+\/\/ return: offset in 64-bit words.\n+uint Runtime1::runtime_blob_current_thread_offset(frame f) {\n+#ifdef _LP64\n+  return r15_off \/ 2;  \/\/ rsp offsets are in halfwords\n+#else\n+  Unimplemented();\n+  return 0;\n+#endif\n+}\n@@ -1423,1 +1438,1 @@\n-        StubFrame f(sasm, \"monitorenter\", dont_gc_arguments);\n+        StubFrame f(sasm, \"monitorenter\", dont_gc_arguments, true \/* use_pop_on_epilog *\/);\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -343,43 +343,7 @@\n-  \/\/ The object is inflated.\n-\n-  \/\/ boxReg refers to the on-stack BasicLock in the current frame.\n-  \/\/ We'd like to write:\n-  \/\/   set box->_displaced_header = markWord::unused_mark().  Any non-0 value suffices.\n-  \/\/ This is convenient but results a ST-before-CAS penalty.  The following CAS suffers\n-  \/\/ additional latency as we have another ST in the store buffer that must drain.\n-\n-  \/\/ avoid ST-before-CAS\n-  \/\/ register juggle because we need tmpReg for cmpxchgptr below\n-  movptr(scrReg, boxReg);\n-  movptr(boxReg, tmpReg);                   \/\/ consider: LEA box, [tmp-2]\n-\n-  \/\/ Optimistic form: consider XORL tmpReg,tmpReg\n-  movptr(tmpReg, NULL_WORD);\n-\n-  \/\/ Appears unlocked - try to swing _owner from null to non-null.\n-  \/\/ Ideally, I'd manifest \"Self\" with get_thread and then attempt\n-  \/\/ to CAS the register containing Self into m->Owner.\n-  \/\/ But we don't have enough registers, so instead we can either try to CAS\n-  \/\/ rsp or the address of the box (in scr) into &m->owner.  If the CAS succeeds\n-  \/\/ we later store \"Self\" into m->Owner.  Transiently storing a stack address\n-  \/\/ (rsp or the address of the box) into  m->owner is harmless.\n-  \/\/ Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.\n-  lock();\n-  cmpxchgptr(scrReg, Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-  movptr(Address(scrReg, 0), 3);          \/\/ box->_displaced_header = 3\n-  \/\/ If we weren't able to swing _owner from null to the BasicLock\n-  \/\/ then take the slow path.\n-  jccb  (Assembler::notZero, NO_COUNT);\n-  \/\/ update _owner from BasicLock to thread\n-  get_thread (scrReg);                    \/\/ beware: clobbers ICCs\n-  movptr(Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), scrReg);\n-  xorptr(boxReg, boxReg);                 \/\/ set icc.ZFlag = 1 to indicate success\n-\n-  \/\/ If the CAS fails we can either retry or pass control to the slow path.\n-  \/\/ We use the latter tactic.\n-  \/\/ Pass the CAS result in the icc.ZFlag into DONE_LABEL\n-  \/\/ If the CAS was successful ...\n-  \/\/   Self has acquired the lock\n-  \/\/   Invariant: m->_recursions should already be 0, so we don't need to explicitly set it.\n-  \/\/ Intentional fall-through into DONE_LABEL ...\n-#else \/\/ _LP64\n+  \/\/ Just take slow path to avoid dealing with 64 bit atomic instructions here.\n+  orl(boxReg, 1);  \/\/ set ICC.ZF=0 to indicate failure\n+#else\n+  \/\/ Unconditionally set box->_displaced_header = markWord::unused_mark().\n+  \/\/ Without cast to int32_t this style of movptr will destroy r10 which is typically obj.\n+  movptr(Address(boxReg, 0), checked_cast<int32_t>(markWord::unused_mark().value()));\n+\n@@ -387,0 +351,1 @@\n+  movptr(boxReg, Address(r15_thread, JavaThread::lock_id_offset()));\n@@ -390,4 +355,2 @@\n-  cmpxchgptr(thread, Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-  \/\/ Unconditionally set box->_displaced_header = markWord::unused_mark().\n-  \/\/ Without cast to int32_t this style of movptr will destroy r10 which is typically obj.\n-  movptr(Address(boxReg, 0), checked_cast<int32_t>(markWord::unused_mark().value()));\n+  cmpxchgptr(boxReg, Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+\n@@ -395,1 +358,1 @@\n-  jccb(Assembler::equal, COUNT);          \/\/ CAS above succeeded; propagate ZF = 1 (success)\n+  jccb(Assembler::equal, COUNT);    \/\/ CAS above succeeded; propagate ZF = 1 (success)\n@@ -397,1 +360,1 @@\n-  cmpptr(thread, rax);                \/\/ Check if we are already the owner (recursive lock)\n+  cmpptr(boxReg, rax);                \/\/ Check if we are already the owner (recursive lock)\n@@ -409,3 +372,6 @@\n-  \/\/ Count monitors in fast path\n-  increment(Address(thread, JavaThread::held_monitor_count_offset()));\n-\n+  if (LockingMode == LM_LEGACY) {\n+#ifdef _LP64\n+    \/\/ Count monitors in fast path\n+    increment(Address(thread, JavaThread::held_monitor_count_offset()));\n+#endif\n+  }\n@@ -473,0 +439,5 @@\n+#ifndef _LP64\n+  \/\/ Just take slow path to avoid dealing with 64 bit atomic instructions here.\n+  orl(boxReg, 1);  \/\/ set ICC.ZF=0 to indicate failure\n+  jmpb(DONE_LABEL);\n+#else\n@@ -521,5 +492,0 @@\n-#ifndef _LP64\n-  get_thread(boxReg);\n-  movptr(Address(boxReg, JavaThread::unlocked_inflated_monitor_offset()), tmpReg);\n-#else \/\/ _LP64\n-#endif\n@@ -534,0 +500,1 @@\n+#endif  \/\/ _LP64\n@@ -550,6 +517,5 @@\n-  \/\/ Count monitors in fast path\n-#ifndef _LP64\n-  get_thread(tmpReg);\n-  decrementl(Address(tmpReg, JavaThread::held_monitor_count_offset()));\n-#else \/\/ _LP64\n-  decrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n+\n+  if (LockingMode == LM_LEGACY) {\n+    \/\/ Count monitors in fast path\n+#ifdef _LP64\n+    decrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n@@ -557,0 +523,1 @@\n+  }\n@@ -634,0 +601,5 @@\n+#ifndef _LP64\n+    \/\/ Just take slow path to avoid dealing with 64 bit atomic instructions here.\n+    orl(box, 1);  \/\/ set ICC.ZF=0 to indicate failure\n+    jmpb(slow_path);\n+#else\n@@ -679,1 +651,7 @@\n-    \/\/ CAS owner (null => current thread).\n+    if (UseObjectMonitorTable) {\n+      \/\/ Cache the monitor for unlock before trashing box. On failure to acquire\n+      \/\/ the lock, the slow path will reset the entry accordingly (see CacheSetter).\n+      movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), monitor);\n+    }\n+\n+    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n@@ -681,1 +659,2 @@\n-    lock(); cmpxchgptr(thread, owner_address);\n+    movptr(box, Address(thread, JavaThread::lock_id_offset()));\n+    lock(); cmpxchgptr(box, owner_address);\n@@ -685,1 +664,1 @@\n-    cmpptr(thread, rax_reg);\n+    cmpptr(box, rax_reg);\n@@ -692,4 +671,1 @@\n-    if (UseObjectMonitorTable) {\n-      \/\/ Cache the monitor for unlock\n-      movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), monitor);\n-    }\n+#endif  \/\/ _LP64\n@@ -699,1 +675,0 @@\n-  increment(Address(thread, JavaThread::held_monitor_count_offset()));\n@@ -809,0 +784,5 @@\n+#ifndef _LP64\n+    \/\/ Just take slow path to avoid dealing with 64 bit atomic instructions here.\n+    orl(t, 1);  \/\/ set ICC.ZF=0 to indicate failure\n+    jmpb(slow_path);\n+#else\n@@ -860,0 +840,1 @@\n+#endif  \/\/ _LP64\n@@ -863,1 +844,0 @@\n-  decrement(Address(thread, JavaThread::held_monitor_count_offset()));\n@@ -7125,0 +7105,10 @@\n+\n+#ifdef _LP64\n+void C2_MacroAssembler::load_narrow_klass_compact_c2(Register dst, Address src) {\n+  \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n+  \/\/ obj-start, so that we can load from the object's mark-word instead. Usually the address\n+  \/\/ comes as obj-start in obj and klass_offset_in_bytes in disp.\n+  movq(dst, src.plus_disp(-oopDesc::klass_offset_in_bytes()));\n+  shrq(dst, markWord::klass_shift);\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":62,"deletions":72,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -587,0 +587,4 @@\n+#ifdef _LP64\n+  void load_narrow_klass_compact_c2(Register dst, Address src);\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -415,0 +415,30 @@\n+#if defined(ASSERT)\n+static address get_register_address_in_stub(const frame& stub_fr, VMReg reg) {\n+  RegisterMap map(nullptr,\n+                  RegisterMap::UpdateMap::include,\n+                  RegisterMap::ProcessFrames::skip,\n+                  RegisterMap::WalkContinuation::skip);\n+  stub_fr.oop_map()->update_register_map(&stub_fr, &map);\n+  return map.location(reg, stub_fr.sp());\n+}\n+#endif\n+\n+JavaThread** frame::saved_thread_address(const frame& f) {\n+  CodeBlob* cb = f.cb();\n+  assert(cb != nullptr && cb->is_runtime_stub(), \"invalid frame\");\n+\n+  JavaThread** thread_addr;\n+#ifdef COMPILER1\n+  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n+      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n+    thread_addr = (JavaThread**)(f.sp() + Runtime1::runtime_blob_current_thread_offset(f));\n+  } else\n+#endif\n+  {\n+    \/\/ c2 only saves rbp in the stub frame so nothing to do.\n+    thread_addr = nullptr;\n+  }\n+  assert(get_register_address_in_stub(f, SharedRuntime::thread_register()) == (address)thread_addr, \"wrong thread address\");\n+  return thread_addr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -341,0 +341,60 @@\n+#ifdef _LP64\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                                    address entry_point,\n+                                                    Register arg_1) {\n+  assert(arg_1 == c_rarg1, \"\");\n+  Label resume_pc, not_preempted;\n+\n+#ifdef ASSERT\n+  {\n+    Label L;\n+    cmpptr(Address(r15_thread, JavaThread::preempt_alternate_return_offset()), NULL_WORD);\n+    jcc(Assembler::equal, L);\n+    stop(\"Should not have alternate return address set\");\n+    bind(L);\n+  }\n+#endif \/* ASSERT *\/\n+\n+  \/\/ Force freeze slow path.\n+  push_cont_fastpath();\n+\n+  \/\/ Make VM call. In case of preemption set last_pc to the one we want to resume to.\n+  \/\/ Note: call_VM_helper requires last_Java_pc for anchor to be at the top of the stack.\n+  lea(rscratch1, resume_pc);\n+  push(rscratch1);\n+  MacroAssembler::call_VM_helper(oop_result, entry_point, 1, false \/*check_exceptions*\/);\n+  pop(rscratch1);\n+\n+  pop_cont_fastpath();\n+\n+  \/\/ Check if preempted.\n+  movptr(rscratch1, Address(r15_thread, JavaThread::preempt_alternate_return_offset()));\n+  cmpptr(rscratch1, NULL_WORD);\n+  jccb(Assembler::zero, not_preempted);\n+  movptr(Address(r15_thread, JavaThread::preempt_alternate_return_offset()), NULL_WORD);\n+  jmp(rscratch1);\n+\n+  \/\/ In case of preemption, this is where we will resume once we finally acquire the monitor.\n+  bind(resume_pc);\n+  restore_after_resume(false \/* is_native *\/);\n+\n+  bind(not_preempted);\n+}\n+\n+void InterpreterMacroAssembler::restore_after_resume(bool is_native) {\n+  lea(rscratch1, ExternalAddress(Interpreter::cont_resume_interpreter_adapter()));\n+  call(rscratch1);\n+  if (is_native) {\n+    \/\/ On resume we need to set up stack as expected.\n+    push(dtos);\n+    push(ltos);\n+  }\n+}\n+#else\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                         address entry_point,\n+                         Register arg_1) {\n+  MacroAssembler::call_VM(oop_result, entry_point, arg_1);\n+}\n+#endif  \/\/ _LP64\n+\n@@ -1261,1 +1321,1 @@\n-    call_VM(noreg,\n+    call_VM_preemptable(noreg,\n@@ -1352,0 +1412,1 @@\n+      inc_held_monitor_count();\n@@ -1353,1 +1414,0 @@\n-    inc_held_monitor_count();\n@@ -1359,1 +1419,1 @@\n-    call_VM(noreg,\n+    call_VM_preemptable(noreg,\n@@ -1432,0 +1492,1 @@\n+      dec_held_monitor_count();\n@@ -1433,1 +1494,0 @@\n-    dec_held_monitor_count();\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":64,"deletions":4,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+  void call_VM_preemptable(Register oop_result,\n+                           address entry_point,\n+                           Register arg_1);\n+  void restore_after_resume(bool is_native);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"interpreter\/interpreterRuntime.hpp\"\n@@ -538,1 +539,0 @@\n-\n@@ -1360,1 +1360,2 @@\n-  return LP64_ONLY(14) NOT_LP64(12);\n+  return\n+      LP64_ONLY(UseCompactObjectHeaders ? 17 : 14) NOT_LP64(12);\n@@ -1376,0 +1377,6 @@\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(temp, receiver);\n+    cmpl(temp, Address(data, CompiledICData::speculated_klass_offset()));\n+  } else\n+#endif\n@@ -1386,1 +1393,1 @@\n-  assert((offset() % end_alignment) == 0, \"Misaligned verified entry point\");\n+  assert((offset() % end_alignment) == 0, \"Misaligned verified entry point (%d, %d, %d)\", uep_offset, offset(), end_alignment);\n@@ -3172,7 +3179,1 @@\n-#ifndef _LP64\n-  Register thread = rax;\n-  push(thread);\n-  get_thread(thread);\n-  incrementl(Address(thread, JavaThread::held_monitor_count_offset()));\n-  pop(thread);\n-#else \/\/ LP64\n+#ifdef _LP64\n@@ -3184,7 +3185,1 @@\n-#ifndef _LP64\n-  Register thread = rax;\n-  push(thread);\n-  get_thread(thread);\n-  decrementl(Address(thread, JavaThread::held_monitor_count_offset()));\n-  pop(thread);\n-#else \/\/ LP64\n+#ifdef _LP64\n@@ -3287,0 +3282,11 @@\n+#ifdef _LP64\n+void MacroAssembler::set_last_Java_frame(Register last_java_sp,\n+                                         Register last_java_fp,\n+                                         Label &L,\n+                                         Register scratch) {\n+  lea(scratch, L);\n+  movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), scratch);\n+  set_last_Java_frame(r15_thread, last_java_sp, last_java_fp, nullptr, scratch);\n+}\n+#endif\n+\n@@ -4276,1 +4282,6 @@\n-      decrement(layout_size, sizeof(oopDesc));\n+      if (UseCompactObjectHeaders) {\n+        assert(is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong), \"oop base offset must be 8-byte-aligned\");\n+        decrement(layout_size, oopDesc::base_offset_in_bytes());\n+      } else {\n+        decrement(layout_size, sizeof(oopDesc));\n+      }\n@@ -4299,2 +4310,4 @@\n-        movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 1*oopSize), zero);\n-        NOT_LP64(movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 2*oopSize), zero));\n+        int header_size_bytes = oopDesc::header_size() * HeapWordSize;\n+        assert(is_aligned(header_size_bytes, BytesPerLong), \"oop header size must be 8-byte-aligned\");\n+        movptr(Address(new_obj, layout_size, Address::times_8, header_size_bytes - 1*oopSize), zero);\n+        NOT_LP64(movptr(Address(new_obj, layout_size, Address::times_8, header_size_bytes - 2*oopSize), zero));\n@@ -4308,4 +4321,11 @@\n-    pop(klass);\n-    Register mark_word = t2;\n-    movptr(mark_word, Address(klass, Klass::prototype_header_offset()));\n-    movptr(Address(new_obj, oopDesc::mark_offset_in_bytes ()), mark_word);\n+    if (UseCompactObjectHeaders || EnableValhalla) {\n+      pop(klass);\n+      Register mark_word = t2;\n+      movptr(mark_word, Address(klass, Klass::prototype_header_offset()));\n+      movptr(Address(new_obj, oopDesc::mark_offset_in_bytes ()), mark_word);\n+    } else {\n+     movptr(Address(new_obj, oopDesc::mark_offset_in_bytes()),\n+            (intptr_t)markWord::prototype().value()); \/\/ header\n+     pop(klass);   \/\/ get saved klass back in the register.\n+    }\n+    if (!UseCompactObjectHeaders) {\n@@ -4313,2 +4333,2 @@\n-    xorl(rsi, rsi);                 \/\/ use zero reg to clear memory (shorter code)\n-    store_klass_gap(new_obj, rsi);  \/\/ zero klass gap for compressed oops\n+      xorl(rsi, rsi);                 \/\/ use zero reg to clear memory (shorter code)\n+      store_klass_gap(new_obj, rsi);  \/\/ zero klass gap for compressed oops\n@@ -4316,3 +4336,3 @@\n-    movptr(t2, klass);         \/\/ preserve klass\n-    store_klass(new_obj, t2, rscratch1);  \/\/ src klass reg is potentially compressed\n-\n+      movptr(t2, klass);         \/\/ preserve klass\n+      store_klass(new_obj, t2, rscratch1);  \/\/ src klass reg is potentially compressed\n+    }\n@@ -4345,1 +4365,1 @@\n-#ifndef WINDOWS\n+#ifndef _WINDOWS\n@@ -4362,1 +4382,1 @@\n-#if defined(WINDOWS) && defined(_LP64)\n+#if defined(_WINDOWS)\n@@ -6273,1 +6293,4 @@\n-  if (UseCompressedClassPointers) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(dst, src);\n+  } else if (UseCompressedClassPointers) {\n@@ -6275,1 +6298,3 @@\n-  } else {\n+  } else\n+#endif\n+  {\n@@ -6280,0 +6305,8 @@\n+#ifdef _LP64\n+void MacroAssembler::load_narrow_klass_compact(Register dst, Register src) {\n+  assert(UseCompactObjectHeaders, \"expect compact object headers\");\n+  movq(dst, Address(src, oopDesc::mark_offset_in_bytes()));\n+  shrq(dst, markWord::klass_shift);\n+}\n+#endif\n+\n@@ -6284,1 +6317,4 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(dst, src);\n+    decode_klass_not_null(dst, tmp);\n+  } else if (UseCompressedClassPointers) {\n@@ -6289,1 +6325,3 @@\n-  movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  {\n+    movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  }\n@@ -6298,0 +6336,1 @@\n+  assert(!UseCompactObjectHeaders, \"not with compact headers\");\n@@ -6309,0 +6348,35 @@\n+void MacroAssembler::cmp_klass(Register klass, Register obj, Register tmp) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    assert(tmp != noreg, \"need tmp\");\n+    assert_different_registers(klass, obj, tmp);\n+    load_narrow_klass_compact(tmp, obj);\n+    cmpl(klass, tmp);\n+  } else if (UseCompressedClassPointers) {\n+    cmpl(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  } else\n+#endif\n+  {\n+    cmpptr(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n+void MacroAssembler::cmp_klasses_from_objects(Register obj1, Register obj2, Register tmp1, Register tmp2) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    assert(tmp2 != noreg, \"need tmp2\");\n+    assert_different_registers(obj1, obj2, tmp1, tmp2);\n+    load_narrow_klass_compact(tmp1, obj1);\n+    load_narrow_klass_compact(tmp2, obj2);\n+    cmpl(tmp1, tmp2);\n+  } else if (UseCompressedClassPointers) {\n+    movl(tmp1, Address(obj1, oopDesc::klass_offset_in_bytes()));\n+    cmpl(tmp1, Address(obj2, oopDesc::klass_offset_in_bytes()));\n+  } else\n+#endif\n+  {\n+    movptr(tmp1, Address(obj1, oopDesc::klass_offset_in_bytes()));\n+    cmpptr(tmp1, Address(obj2, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n@@ -6396,0 +6470,1 @@\n+  assert(!UseCompactObjectHeaders, \"Don't use with compact headers\");\n@@ -6560,2 +6635,1 @@\n-    assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-    shrq(r, LogKlassAlignmentInBytes);\n+    shrq(r, CompressedKlassPointers::shift());\n@@ -6574,2 +6648,1 @@\n-    assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-    shrq(dst, LogKlassAlignmentInBytes);\n+    shrq(dst, CompressedKlassPointers::shift());\n@@ -6587,2 +6660,1 @@\n-    assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-    shlq(r, LogKlassAlignmentInBytes);\n+    shlq(r, CompressedKlassPointers::shift());\n@@ -6610,9 +6682,12 @@\n-    if (CompressedKlassPointers::base() != nullptr) {\n-      mov64(dst, (int64_t)CompressedKlassPointers::base());\n-    } else {\n-      xorq(dst, dst);\n-    }\n-    if (CompressedKlassPointers::shift() != 0) {\n-      assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-      assert(LogKlassAlignmentInBytes == Address::times_8, \"klass not aligned on 64bits?\");\n-      leaq(dst, Address(dst, src, Address::times_8, 0));\n+    if (CompressedKlassPointers::shift() <= Address::times_8) {\n+      if (CompressedKlassPointers::base() != nullptr) {\n+        mov64(dst, (int64_t)CompressedKlassPointers::base());\n+      } else {\n+        xorq(dst, dst);\n+      }\n+      if (CompressedKlassPointers::shift() != 0) {\n+        assert(CompressedKlassPointers::shift() == Address::times_8, \"klass not aligned on 64bits?\");\n+        leaq(dst, Address(dst, src, Address::times_8, 0));\n+      } else {\n+        addq(dst, src);\n+      }\n@@ -6620,0 +6695,7 @@\n+      if (CompressedKlassPointers::base() != nullptr) {\n+        const uint64_t base_right_shifted =\n+            (uint64_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n+        mov64(dst, base_right_shifted);\n+      } else {\n+        xorq(dst, dst);\n+      }\n@@ -6621,0 +6703,1 @@\n+      shlq(dst, CompressedKlassPointers::shift());\n@@ -11337,4 +11420,0 @@\n-\/\/ 32-bit Windows has its own fast-path implementation\n-\/\/ of get_thread\n-#if !defined(WIN32) || defined(_LP64)\n-\n@@ -11375,3 +11454,0 @@\n-\n-#endif \/\/ !WIN32 || _LP64\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":133,"deletions":57,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -147,1 +147,2 @@\n-        (op == 0xC7 && branch[1] == 0xF8) \/* xbegin *\/,\n+        (op == 0xC7 && branch[1] == 0xF8) \/* xbegin *\/ ||\n+        (op == 0x8D) \/* lea *\/,\n@@ -158,1 +159,1 @@\n-      int* disp = (int*) &branch[(op == 0x0F || op == 0xC7)? 2: 1];\n+      int* disp = (int*) &branch[(op == 0x0F || op == 0xC7 || op == 0x8D) ? 2 : 1];\n@@ -371,0 +372,7 @@\n+#ifdef _LP64\n+  void set_last_Java_frame(Register last_java_sp,\n+                           Register last_java_fp,\n+                           Label &last_java_pc,\n+                           Register scratch);\n+#endif\n+\n@@ -399,0 +407,2 @@\n+\n+  \/\/ Load oopDesc._metadata without decode (useful for direct Klass* compare from oops)\n@@ -400,0 +410,3 @@\n+#ifdef _LP64\n+  void load_narrow_klass_compact(Register dst, Register src);\n+#endif\n@@ -403,0 +416,8 @@\n+  \/\/ Compares the Klass pointer of an object to a given Klass (which might be narrow,\n+  \/\/ depending on UseCompressedClassPointers).\n+  void cmp_klass(Register klass, Register obj, Register tmp);\n+\n+  \/\/ Compares the Klass pointer of two objects obj1 and obj2. Result is in the condition flags.\n+  \/\/ Uses tmp1 and tmp2 as temporary registers.\n+  void cmp_klasses_from_objects(Register obj1, Register obj2, Register tmp1, Register tmp2);\n+\n@@ -1006,1 +1027,1 @@\n-  void lea(Register dst, Address        adr) { Assembler::lea(dst, adr); }\n+  using Assembler::lea;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2074,0 +2074,5 @@\n+VMReg SharedRuntime::thread_register() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+  static int r15_offset_in_bytes(void)    { return BytesPerInt * r15_off; }\n@@ -1693,1 +1694,1 @@\n-void static continuation_enter_cleanup(MacroAssembler* masm) {\n+static void continuation_enter_cleanup(MacroAssembler* masm) {\n@@ -1883,0 +1884,1 @@\n+  ContinuationEntry::_thaw_call_pc_offset = __ pc() - start;\n@@ -1892,1 +1894,1 @@\n-\n+  ContinuationEntry::_cleanup_offset = __ pc() - start;\n@@ -1985,0 +1987,4 @@\n+void SharedRuntime::continuation_enter_cleanup(MacroAssembler* masm) {\n+  ::continuation_enter_cleanup(masm);\n+}\n+\n@@ -2453,4 +2459,7 @@\n-  intptr_t the_pc = (intptr_t) __ pc();\n-  oop_maps->add_gc_map(the_pc - start, map);\n-\n-  __ set_last_Java_frame(rsp, noreg, (address)the_pc, rscratch1);\n+  Label native_return;\n+  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+    \/\/ For convenience we use the pc we want to resume to in case of preemption on Object.wait.\n+    __ set_last_Java_frame(rsp, noreg, native_return, rscratch1);\n+  } else {\n+    intptr_t the_pc = (intptr_t) __ pc();\n+    oop_maps->add_gc_map(the_pc - start, map);\n@@ -2458,0 +2467,2 @@\n+    __ set_last_Java_frame(rsp, noreg, __ pc(), rscratch1);\n+  }\n@@ -2548,0 +2559,3 @@\n+\n+      __ bind(count_mon);\n+      __ inc_held_monitor_count();\n@@ -2552,2 +2566,0 @@\n-    __ bind(count_mon);\n-    __ inc_held_monitor_count();\n@@ -2644,0 +2656,14 @@\n+  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+    \/\/ Check preemption for Object.wait()\n+    __ movptr(rscratch1, Address(r15_thread, JavaThread::preempt_alternate_return_offset()));\n+    __ cmpptr(rscratch1, NULL_WORD);\n+    __ jccb(Assembler::equal, native_return);\n+    __ movptr(Address(r15_thread, JavaThread::preempt_alternate_return_offset()), NULL_WORD);\n+    __ jmp(rscratch1);\n+    __ bind(native_return);\n+\n+    intptr_t the_pc = (intptr_t) __ pc();\n+    oop_maps->add_gc_map(the_pc - start, map);\n+  }\n+\n+\n@@ -2693,1 +2719,0 @@\n-      __ dec_held_monitor_count();\n@@ -2767,1 +2792,6 @@\n-    \/\/ Not a leaf but we have last_Java_frame setup as we want\n+    \/\/ Not a leaf but we have last_Java_frame setup as we want.\n+    \/\/ We don't want to unmount in case of contention since that would complicate preserving\n+    \/\/ the arguments that had already been marshalled into the native convention. So we force\n+    \/\/ the freeze slow path to find this native wrapper frame (see recurse_freeze_native_frame())\n+    \/\/ and pin the vthread. Otherwise the fast path won't find it since we don't walk the stack.\n+    __ push_cont_fastpath();\n@@ -2769,0 +2799,1 @@\n+    __ pop_cont_fastpath();\n@@ -2883,0 +2914,4 @@\n+VMReg SharedRuntime::thread_register() {\n+  return r15_thread->as_VMReg();\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":45,"deletions":10,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -3800,0 +3801,30 @@\n+address StubGenerator::generate_cont_preempt_stub() {\n+  if (!Continuations::enabled()) return nullptr;\n+  StubCodeMark mark(this, \"StubRoutines\",\"Continuation preempt stub\");\n+  address start = __ pc();\n+\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ Set rsp to enterSpecial frame, i.e. remove all frames copied into the heap.\n+  __ movptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset()));\n+\n+  Label preemption_cancelled;\n+  __ movbool(rscratch1, Address(r15_thread, JavaThread::preemption_cancelled_offset()));\n+  __ testbool(rscratch1);\n+  __ jcc(Assembler::notZero, preemption_cancelled);\n+\n+  \/\/ Remove enterSpecial frame from the stack and return to Continuation.run() to unmount.\n+  SharedRuntime::continuation_enter_cleanup(_masm);\n+  __ pop(rbp);\n+  __ ret(0);\n+\n+  \/\/ We acquired the monitor after freezing the frames so call thaw to continue execution.\n+  __ bind(preemption_cancelled);\n+  __ movbool(Address(r15_thread, JavaThread::preemption_cancelled_offset()), false);\n+  __ lea(rbp, Address(rsp, checked_cast<int32_t>(ContinuationEntry::size())));\n+  __ movptr(rscratch1, ExternalAddress(ContinuationEntry::thaw_call_pc_address()));\n+  __ jmp(rscratch1);\n+\n+  return start;\n+}\n+\n@@ -4126,0 +4157,1 @@\n+  StubRoutines::_cont_preempt_stub = generate_cont_preempt_stub();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -605,0 +605,2 @@\n+  address generate_cont_preempt_stub();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -395,0 +395,20 @@\n+address TemplateInterpreterGenerator::generate_cont_resume_interpreter_adapter() {\n+  if (!Continuations::enabled()) return nullptr;\n+  address start = __ pc();\n+\n+  __ restore_bcp();\n+  __ restore_locals();\n+\n+  \/\/ Get return address before adjusting rsp\n+  __ movptr(rax, Address(rsp, 0));\n+\n+  \/\/ Restore stack bottom\n+  __ movptr(rcx, Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize));\n+  __ lea(rsp, Address(rbp, rcx, Address::times_ptr));\n+  \/\/ and NULL it as marker that esp is now tos until next java call\n+  __ movptr(Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize), NULL_WORD);\n+\n+  __ jmp(rax);\n+\n+  return start;\n+}\n@@ -1037,1 +1057,4 @@\n-   __ set_last_Java_frame(rsp, rbp, (address) __ pc(), rscratch1);\n+   \/\/ For convenience we use the pc we want to resume to in\n+   \/\/ case of preemption on Object.wait.\n+   Label native_return;\n+   __ set_last_Java_frame(rsp, rbp, native_return, rscratch1);\n@@ -1057,0 +1080,2 @@\n+  __ push_cont_fastpath();\n+\n@@ -1062,0 +1087,2 @@\n+  __ pop_cont_fastpath();\n+\n@@ -1085,1 +1112,1 @@\n-    __ cmpptr(Address(rbp, (frame::interpreter_frame_oop_temp_offset + 1)*wordSize),\n+    __ cmpptr(Address(rbp, (frame::interpreter_frame_result_handler_offset)*wordSize),\n@@ -1088,1 +1115,1 @@\n-    __ cmpptr(Address(rbp, (frame::interpreter_frame_oop_temp_offset + 1)*wordSize),\n+    __ cmpptr(Address(rbp, (frame::interpreter_frame_result_handler_offset)*wordSize),\n@@ -1158,0 +1185,18 @@\n+#ifdef _LP64\n+  if (LockingMode != LM_LEGACY) {\n+    \/\/ Check preemption for Object.wait()\n+    Label not_preempted;\n+    __ movptr(rscratch1, Address(r15_thread, JavaThread::preempt_alternate_return_offset()));\n+    __ cmpptr(rscratch1, NULL_WORD);\n+    __ jccb(Assembler::equal, not_preempted);\n+    __ movptr(Address(r15_thread, JavaThread::preempt_alternate_return_offset()), NULL_WORD);\n+    __ jmp(rscratch1);\n+    __ bind(native_return);\n+    __ restore_after_resume(true \/* is_native *\/);\n+    __ bind(not_preempted);\n+  } else {\n+    \/\/ any pc will do so just use this one for LM_LEGACY to keep code together.\n+    __ bind(native_return);\n+  }\n+#endif \/\/ _LP64\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -520,1 +520,0 @@\n-#ifdef _LP64\n@@ -525,1 +524,0 @@\n-#endif \/\/ _LP64\n@@ -549,1 +547,0 @@\n-#ifdef _LP64\n@@ -554,1 +551,0 @@\n-#endif \/\/ _LP64\n@@ -614,1 +610,0 @@\n-#ifdef _LP64\n@@ -619,1 +614,0 @@\n-#endif \/\/ _LP64\n@@ -644,1 +638,0 @@\n-#ifdef _LP64\n@@ -649,1 +642,0 @@\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4379,0 +4379,1 @@\n+  predicate(!UseCompactObjectHeaders);\n@@ -4389,0 +4390,13 @@\n+instruct loadNKlassCompactHeaders(rRegN dst, memory mem, rFlagsReg cr)\n+%{\n+  predicate(UseCompactObjectHeaders);\n+  match(Set dst (LoadNKlass mem));\n+  effect(KILL cr);\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"load_narrow_klass_compact    $dst, $mem\\t# compressed klass ptr\" %}\n+  ins_encode %{\n+    __ load_narrow_klass_compact_c2($dst$$Register, $mem$$Address);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n@@ -11919,0 +11933,1 @@\n+  predicate(!UseCompactObjectHeaders);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -111,0 +111,5 @@\n+VMReg SharedRuntime::thread_register() {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -495,1 +495,0 @@\n-#if !defined(_WIN32) || defined(_WIN64)\n@@ -499,1 +498,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -410,1 +410,0 @@\n-  set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())->is_object());\n@@ -423,2 +422,0 @@\n-  set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)->is_object()));\n-  set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)->is_object()));\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -370,1 +370,0 @@\n-    IsEliminatedFlag,\n@@ -373,2 +372,0 @@\n-    NeedsStoreCheckFlag,\n-    NeedsWriteBarrierFlag,\n@@ -385,1 +382,0 @@\n-    InWorkListFlag,\n@@ -876,1 +872,0 @@\n-  bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }\n@@ -1047,2 +1042,0 @@\n-  bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }\n-  bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-  void epilogue();\n+  void epilogue(bool use_pop = false);\n","filename":"src\/hotspot\/share\/c1\/c1_MacroAssembler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,0 +156,3 @@\n+  \/\/ return offset in words\n+  static uint runtime_blob_current_thread_offset(frame f);\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -189,2 +189,6 @@\n-  oopDesc::set_mark(mem, markWord::prototype());\n-  oopDesc::release_set_klass(mem, Universe::objectArrayKlass());\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, Universe::objectArrayKlass()->prototype_header());\n+  } else {\n+    oopDesc::set_mark(mem, markWord::prototype());\n+    oopDesc::release_set_klass(mem, Universe::objectArrayKlass());\n+  }\n@@ -353,2 +357,6 @@\n-  oopDesc::set_mark(mem, markWord::prototype());\n-  cast_to_oop(mem)->set_narrow_klass(nk);\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, markWord::prototype().set_narrow_klass(nk));\n+  } else {\n+    oopDesc::set_mark(mem, markWord::prototype());\n+    cast_to_oop(mem)->set_narrow_klass(nk);\n+  }\n@@ -559,1 +567,5 @@\n-  fake_oop->set_narrow_klass(nk);\n+  if (UseCompactObjectHeaders) {\n+    fake_oop->set_mark(markWord::prototype().set_narrow_klass(nk));\n+  } else {\n+    fake_oop->set_narrow_klass(nk);\n+  }\n@@ -568,1 +580,7 @@\n-    fake_oop->set_mark(src_klass->prototype_header().copy_set_hash(src_hash));\n+    if (UseCompactObjectHeaders) {\n+      fake_oop->set_mark(markWord::prototype().set_narrow_klass(nk).copy_set_hash(src_hash));\n+    } else if (EnableValhalla) {\n+      fake_oop->set_mark(src_klass->prototype_header().copy_set_hash(src_hash));\n+    } else {\n+      fake_oop->set_mark(markWord::prototype().copy_set_hash(src_hash));\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -94,11 +94,17 @@\n-    size_t jvm_path_len = strlen(jvm_path);\n-    size_t file_sep_len = strlen(os::file_separator());\n-    const size_t len = jvm_path_len + file_sep_len + strlen(\"classes_nocoops_valhalla.jsa\") + 1;\n-    _default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);\n-    LP64_ONLY(bool nocoops = !UseCompressedOops);\n-    NOT_LP64(bool nocoops = false);\n-    bool valhalla = is_valhalla_preview();\n-    jio_snprintf(_default_archive_path, len, \"%s%sclasses%s%s.jsa\",\n-                jvm_path, os::file_separator(),\n-                 nocoops ? \"_nocoops\" : \"\",\n-                 valhalla ? \"_valhalla\" : \"\");\n+    stringStream tmp;\n+    tmp.print(\"%s%sclasses\", jvm_path, os::file_separator());\n+#ifdef _LP64\n+    if (!UseCompressedOops) {\n+      tmp.print_raw(\"_nocoops\");\n+    }\n+    if (UseCompactObjectHeaders) {\n+      \/\/ Note that generation of xxx_coh.jsa variants require\n+      \/\/ --enable-cds-archive-coh at build time\n+      tmp.print_raw(\"_coh\");\n+    }\n+#endif\n+    if (is_valhalla_preview()) {\n+      tmp.print_raw(\"_valhalla\");\n+    }\n+    tmp.print_raw(\".jsa\");\n+    _default_archive_path = os::strdup(tmp.base());\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n@@ -272,0 +273,1 @@\n+  _compact_headers = UseCompactObjectHeaders;\n@@ -279,0 +281,8 @@\n+  if (UseCompressedClassPointers) {\n+#ifdef _LP64\n+    _narrow_klass_pointer_bits = CompressedKlassPointers::narrow_klass_pointer_bits();\n+    _narrow_klass_shift = ArchiveBuilder::precomputed_narrow_klass_shift();\n+#endif\n+  } else {\n+    _narrow_klass_pointer_bits = _narrow_klass_shift = -1;\n+  }\n@@ -338,0 +348,1 @@\n+  st->print_cr(\"- compact_headers:                %d\", _compact_headers);\n@@ -342,0 +353,2 @@\n+  st->print_cr(\"- narrow_klass_pointer_bits:      %d\", _narrow_klass_pointer_bits);\n+  st->print_cr(\"- narrow_klass_shift:             %d\", _narrow_klass_shift);\n@@ -343,0 +356,1 @@\n+  st->print_cr(\"- early_serialized_data_offset:   \" SIZE_FORMAT_X, _early_serialized_data_offset);\n@@ -2157,1 +2171,1 @@\n-  \/\/ ArchiveHeapWriter::precomputed_narrow_klass_shift. We enforce this encoding at runtime (see\n+  \/\/ ArchiveBuilder::precomputed_narrow_klass_shift. We enforce this encoding at runtime (see\n@@ -2161,1 +2175,2 @@\n-  const int archive_narrow_klass_shift = ArchiveHeapWriter::precomputed_narrow_klass_shift;\n+  const int archive_narrow_klass_pointer_bits = header()->narrow_klass_pointer_bits();\n+  const int archive_narrow_klass_shift = header()->narrow_klass_shift();\n@@ -2165,2 +2180,2 @@\n-  log_info(cds)(\"    narrow_klass_base at mapping start address, narrow_klass_shift = %d\",\n-                archive_narrow_klass_shift);\n+  log_info(cds)(\"    narrow_klass_base at mapping start address, narrow_klass_pointer_bits = %d, narrow_klass_shift = %d\",\n+                archive_narrow_klass_pointer_bits, archive_narrow_klass_shift);\n@@ -2171,2 +2186,2 @@\n-  log_info(cds)(\"    narrow_klass_base = \" PTR_FORMAT \", narrow_klass_shift = %d\",\n-                p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());\n+  log_info(cds)(\"    narrow_klass_base = \" PTR_FORMAT \", arrow_klass_pointer_bits = %d, narrow_klass_shift = %d\",\n+                p2i(CompressedKlassPointers::base()), CompressedKlassPointers::narrow_klass_pointer_bits(), CompressedKlassPointers::shift());\n@@ -2181,4 +2196,29 @@\n-  assert(archive_narrow_klass_base == CompressedKlassPointers::base(), \"Unexpected encoding base encountered \"\n-         \"(\" PTR_FORMAT \", expected \" PTR_FORMAT \")\", p2i(CompressedKlassPointers::base()), p2i(archive_narrow_klass_base));\n-  assert(archive_narrow_klass_shift == CompressedKlassPointers::shift(), \"Unexpected encoding shift encountered \"\n-         \"(%d, expected %d)\", CompressedKlassPointers::shift(), archive_narrow_klass_shift);\n+  int err = 0;\n+  if ( archive_narrow_klass_base != CompressedKlassPointers::base() ||\n+       (err = 1, archive_narrow_klass_pointer_bits != CompressedKlassPointers::narrow_klass_pointer_bits()) ||\n+       (err = 2, archive_narrow_klass_shift != CompressedKlassPointers::shift()) ) {\n+    stringStream ss;\n+    switch (err) {\n+    case 0:\n+      ss.print(\"Unexpected encoding base encountered (\" PTR_FORMAT \", expected \" PTR_FORMAT \")\",\n+               p2i(CompressedKlassPointers::base()), p2i(archive_narrow_klass_base));\n+      break;\n+    case 1:\n+      ss.print(\"Unexpected narrow Klass bit length encountered (%d, expected %d)\",\n+               CompressedKlassPointers::narrow_klass_pointer_bits(), archive_narrow_klass_pointer_bits);\n+      break;\n+    case 2:\n+      ss.print(\"Unexpected narrow Klass shift encountered (%d, expected %d)\",\n+               CompressedKlassPointers::shift(), archive_narrow_klass_shift);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    };\n+    LogTarget(Info, cds) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ls.print_raw(ss.base());\n+      header()->print(&ls);\n+    }\n+    assert(false, \"%s\", ss.base());\n+  }\n@@ -2556,2 +2596,2 @@\n-  log_info(cds)(\"Archive was created with UseCompressedOops = %d, UseCompressedClassPointers = %d\",\n-                          compressed_oops(), compressed_class_pointers());\n+  log_info(cds)(\"Archive was created with UseCompressedOops = %d, UseCompressedClassPointers = %d, UseCompactObjectHeaders = %d\",\n+                          compressed_oops(), compressed_class_pointers(), compact_headers());\n@@ -2559,1 +2599,1 @@\n-    log_info(cds)(\"Unable to use shared archive.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n+    log_warning(cds)(\"Unable to use shared archive.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n@@ -2582,0 +2622,8 @@\n+  if (compact_headers() != UseCompactObjectHeaders) {\n+    log_warning(cds)(\"Unable to use shared archive.\\nThe shared archive file's UseCompactObjectHeaders setting (%s)\"\n+                     \" does not equal the current UseCompactObjectHeaders setting (%s).\",\n+                     _compact_headers          ? \"enabled\" : \"disabled\",\n+                     UseCompactObjectHeaders   ? \"enabled\" : \"disabled\");\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":61,"deletions":13,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -222,0 +222,1 @@\n+  bool   _compact_headers;                        \/\/ value of UseCompactObjectHeaders\n@@ -226,0 +227,2 @@\n+  int     _narrow_klass_pointer_bits;             \/\/ save number of bits in narrowKlass\n+  int     _narrow_klass_shift;                    \/\/ save shift width used to pre-compute narrowKlass IDs in archived heap objects\n@@ -227,0 +230,1 @@\n+  size_t  _early_serialized_data_offset;          \/\/ Data accessed using {ReadClosure,WriteClosure}::serialize()\n@@ -294,0 +298,1 @@\n+  bool compact_headers()                   const { return _compact_headers; }\n@@ -297,0 +302,1 @@\n+  char* early_serialized_data()            const { return from_mapped_offset(_early_serialized_data_offset); }\n@@ -305,0 +311,2 @@\n+  int narrow_klass_pointer_bits()          const { return _narrow_klass_pointer_bits; }\n+  int narrow_klass_shift()                 const { return _narrow_klass_shift; }\n@@ -319,0 +327,1 @@\n+  void set_early_serialized_data(char* p)        { set_as_offset(p, &_early_serialized_data_offset); }\n@@ -436,0 +445,2 @@\n+  char* early_serialized_data()               const { return header()->early_serialized_data(); }\n+  void  set_early_serialized_data(char* p)    const { header()->set_early_serialized_data(p); }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -364,2 +365,37 @@\n-\/\/ Read\/write a data stream for restoring\/preserving metadata pointers and\n-\/\/ miscellaneous data from\/to the shared archive file.\n+\/\/ About \"serialize\" --\n+\/\/\n+\/\/ This is (probably a badly named) way to read\/write a data stream of pointers and\n+\/\/ miscellaneous data from\/to the shared archive file. The usual code looks like this:\n+\/\/\n+\/\/     \/\/ These two global C++ variables are initialized during dump time.\n+\/\/     static int _archived_int;\n+\/\/     static MetaspaceObj* archived_ptr;\n+\/\/\n+\/\/     void MyClass::serialize(SerializeClosure* soc) {\n+\/\/         soc->do_int(&_archived_int);\n+\/\/         soc->do_int(&_archived_ptr);\n+\/\/     }\n+\/\/\n+\/\/     At dumptime, these two variables are stored into the CDS archive.\n+\/\/     At runtime, these two variables are loaded from the CDS archive.\n+\/\/     In addition, the pointer is relocated as necessary.\n+\/\/\n+\/\/ Some of the xxx::serialize() functions may have side effects and assume that\n+\/\/ the archive is already mapped. For example, SymbolTable::serialize_shared_table_header()\n+\/\/ unconditionally makes the set of archived symbols available. Therefore, we put most\n+\/\/ of these xxx::serialize() functions inside MetaspaceShared::serialize(), which\n+\/\/ is called AFTER we made the decision to map the archive.\n+\/\/\n+\/\/ However, some of the \"serialized\" data are used to decide whether an archive should\n+\/\/ be mapped or not (e.g., for checking if the -Djdk.module.main property is compatible\n+\/\/ with the archive). The xxx::serialize() functions for these data must be put inside\n+\/\/ MetaspaceShared::early_serialize(). Such functions must not produce side effects that\n+\/\/ assume we will always decides to map the archive.\n+\n+void MetaspaceShared::early_serialize(SerializeClosure* soc) {\n+  int tag = 0;\n+  soc->do_tag(--tag);\n+  CDS_JAVA_HEAP_ONLY(Modules::serialize(soc);)\n+  CDS_JAVA_HEAP_ONLY(Modules::serialize_addmods_names(soc);)\n+  soc->do_tag(666);\n+}\n@@ -407,2 +443,0 @@\n-  CDS_JAVA_HEAP_ONLY(Modules::serialize(soc);)\n-  CDS_JAVA_HEAP_ONLY(Modules::serialize_addmods_names(soc);)\n@@ -460,0 +494,1 @@\n+  char* dump_early_read_only_tables();\n@@ -499,0 +534,15 @@\n+char* VM_PopulateDumpSharedSpace::dump_early_read_only_tables() {\n+  ArchiveBuilder::OtherROAllocMark mark;\n+\n+  \/\/ Write module name into archive\n+  CDS_JAVA_HEAP_ONLY(Modules::dump_main_module_name();)\n+  \/\/ Write module names from --add-modules into archive\n+  CDS_JAVA_HEAP_ONLY(Modules::dump_addmods_names();)\n+\n+  DumpRegion* ro_region = ArchiveBuilder::current()->ro_region();\n+  char* start = ro_region->top();\n+  WriteClosure wc(ro_region);\n+  MetaspaceShared::early_serialize(&wc);\n+  return start;\n+}\n+\n@@ -506,4 +556,1 @@\n-  \/\/ Write module name into archive\n-  CDS_JAVA_HEAP_ONLY(Modules::dump_main_module_name();)\n-  \/\/ Write module names from --add-modules into archive\n-  CDS_JAVA_HEAP_ONLY(Modules::dump_addmods_names();)\n+\n@@ -548,0 +595,1 @@\n+  char* early_serialized_data = dump_early_read_only_tables();\n@@ -561,0 +609,1 @@\n+  _map_info->set_early_serialized_data(early_serialized_data);\n@@ -1208,11 +1257,12 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-          \/\/ We archived objects with pre-computed narrow Klass id. Set up encoding such that these Ids stay valid.\n-          address precomputed_narrow_klass_base = cds_base;\n-          const int precomputed_narrow_klass_shift = ArchiveHeapWriter::precomputed_narrow_klass_shift;\n-          CompressedKlassPointers::initialize_for_given_encoding(\n-            cds_base, ccs_end - cds_base, \/\/ Klass range\n-            precomputed_narrow_klass_base, precomputed_narrow_klass_shift \/\/ precomputed encoding, see ArchiveHeapWriter\n-            );\n-#else\n-          CompressedKlassPointers::initialize (\n-            cds_base, ccs_end - cds_base \/\/ Klass range\n+          if (INCLUDE_CDS_JAVA_HEAP || UseCompactObjectHeaders) {\n+            \/\/ The CDS archive may contain narrow Klass IDs that were precomputed at archive generation time:\n+            \/\/ - every archived java object header (only if INCLUDE_CDS_JAVA_HEAP)\n+            \/\/ - every archived Klass' prototype   (only if +UseCompactObjectHeaders)\n+            \/\/\n+            \/\/ In order for those IDs to still be valid, we need to dictate base and shift: base should be the\n+            \/\/ mapping start, shift the shift used at archive generation time.\n+            address precomputed_narrow_klass_base = cds_base;\n+            const int precomputed_narrow_klass_shift = ArchiveBuilder::precomputed_narrow_klass_shift();\n+            CompressedKlassPointers::initialize_for_given_encoding(\n+              cds_base, ccs_end - cds_base, \/\/ Klass range\n+              precomputed_narrow_klass_base, precomputed_narrow_klass_shift \/\/ precomputed encoding, see ArchiveBuilder\n@@ -1220,1 +1270,6 @@\n-#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+          } else {\n+            \/\/ Let JVM freely chose encoding base and shift\n+            CompressedKlassPointers::initialize (\n+              cds_base, ccs_end - cds_base \/\/ Klass range\n+              );\n+          }\n@@ -1275,1 +1330,1 @@\n-\/\/  encoding, the range [Base, End) not surpass KlassEncodingMetaspaceMax.\n+\/\/  encoding, the range [Base, End) and not surpass the max. range for that encoding.\n@@ -1396,1 +1451,1 @@\n-      \/\/ encoding base since the archived heap objects contain nKlass IDs pre-calculated toward the start\n+      \/\/ encoding base since the archived heap objects contain narrow Klass IDs pre-calculated toward the start\n@@ -1482,0 +1537,8 @@\n+  if (mapinfo->is_static()) {\n+    \/\/ Currently, only static archive uses early serialized data.\n+    char* buffer = mapinfo->early_serialized_data();\n+    intptr_t* array = (intptr_t*)buffer;\n+    ReadClosure rc(&array, (intptr_t)mapped_base_address);\n+    early_serialize(&rc);\n+  }\n+\n@@ -1518,1 +1581,1 @@\n-  ReadClosure rc(&array);\n+  ReadClosure rc(&array, (intptr_t)SharedBaseAddress);\n@@ -1535,1 +1598,1 @@\n-    ReadClosure rc(&buffer);\n+    ReadClosure rc(&buffer, (intptr_t)SharedBaseAddress);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":87,"deletions":24,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+  static void early_serialize(SerializeClosure* sc) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -270,0 +270,20 @@\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciKlass::prototype_header_offset\n+juint ciKlass::prototype_header_offset() {\n+  assert(is_loaded(), \"must be loaded\");\n+\n+  VM_ENTRY_MARK;\n+  Klass* this_klass = get_Klass();\n+  return in_bytes(this_klass->prototype_header_offset());\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciKlass::prototype_header\n+uintptr_t ciKlass::prototype_header() {\n+  assert(is_loaded(), \"must be loaded\");\n+\n+  VM_ENTRY_MARK;\n+  Klass* this_klass = get_Klass();\n+  return (uintptr_t)this_klass->prototype_header().to_pointer();\n+}\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -154,0 +154,3 @@\n+\n+  juint prototype_header_offset();\n+  uintptr_t prototype_header();\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6341,0 +6341,9 @@\n+\/\/ Returns true if the future Klass will need to be addressable with a narrow Klass ID.\n+bool ClassFileParser::klass_needs_narrow_id() const {\n+  \/\/ Classes that are never instantiated need no narrow Klass Id, since the\n+  \/\/ only point of having a narrow id is to put it into an object header. Keeping\n+  \/\/ never instantiated classes out of class space lessens the class space pressure.\n+  \/\/ For more details, see JDK-8338526.\n+  return !is_interface() && !is_abstract();\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -562,0 +562,4 @@\n+  \/\/ Returns true if the Klass to be generated will need to be addressable\n+  \/\/ with a narrow Klass ID.\n+  bool klass_needs_narrow_id() const;\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1264,1 +1264,1 @@\n-    return (char) strtol(hex, NULL, 16);\n+    return (char) strtol(hex, nullptr, 16);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -417,6 +417,0 @@\n-#if defined(_WIN32) && !defined(_WIN64)\n-    if (_to_java_string_fn == nullptr) {\n-      \/\/ On 32 bit Windows, also try __stdcall decorated name\n-      _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, \"_JNU_NewStringPlatform@8\"));\n-    }\n-#endif\n@@ -1620,1 +1614,0 @@\n-int java_lang_Thread::_inheritedAccessControlContext_offset;\n@@ -1637,1 +1630,0 @@\n-  macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \\\n@@ -1707,0 +1699,1 @@\n+  assert(is_in_VTMS_transition(java_thread) != val, \"already %s transition\", val ? \"inside\" : \"outside\");\n@@ -1814,4 +1807,0 @@\n-oop java_lang_Thread::inherited_access_control_context(oop java_thread) {\n-  return java_thread->obj_field(_inheritedAccessControlContext_offset);\n-}\n-\n@@ -2042,0 +2031,4 @@\n+int java_lang_VirtualThread::_next_offset;\n+int java_lang_VirtualThread::_onWaitingList_offset;\n+int java_lang_VirtualThread::_notified_offset;\n+int java_lang_VirtualThread::_timeout_offset;\n@@ -2047,1 +2040,5 @@\n-  macro(_state_offset,                     k, \"state\",              int_signature,               false)\n+  macro(_state_offset,                     k, \"state\",              int_signature,               false); \\\n+  macro(_next_offset,                      k, \"next\",               vthread_signature,           false); \\\n+  macro(_onWaitingList_offset,             k, \"onWaitingList\",      bool_signature,              false); \\\n+  macro(_notified_offset,                  k, \"notified\",           bool_signature,              false); \\\n+  macro(_timeout_offset,                   k, \"timeout\",            long_signature,              false);\n@@ -2073,0 +2070,50 @@\n+void java_lang_VirtualThread::set_state(oop vthread, int state) {\n+  vthread->release_int_field_put(_state_offset, state);\n+}\n+\n+int java_lang_VirtualThread::cmpxchg_state(oop vthread, int old_state, int new_state) {\n+  jint* addr = vthread->field_addr<jint>(_state_offset);\n+  int res = Atomic::cmpxchg(addr, old_state, new_state);\n+  return res;\n+}\n+\n+oop java_lang_VirtualThread::next(oop vthread) {\n+  return vthread->obj_field(_next_offset);\n+}\n+\n+void java_lang_VirtualThread::set_next(oop vthread, oop next_vthread) {\n+  vthread->obj_field_put(_next_offset, next_vthread);\n+}\n+\n+\/\/ Add vthread to the waiting list if it's not already in it. Multiple threads\n+\/\/ could be trying to add vthread to the list at the same time, so we control\n+\/\/ access with a cmpxchg on onWaitingList. The winner adds vthread to the list.\n+\/\/ Method returns true if we added vthread to the list, false otherwise.\n+bool java_lang_VirtualThread::set_onWaitingList(oop vthread, OopHandle& list_head) {\n+  jboolean* addr = vthread->field_addr<jboolean>(_onWaitingList_offset);\n+  jboolean vthread_on_list = Atomic::load(addr);\n+  if (!vthread_on_list) {\n+    vthread_on_list = Atomic::cmpxchg(addr, (jboolean)JNI_FALSE, (jboolean)JNI_TRUE);\n+    if (!vthread_on_list) {\n+      for (;;) {\n+        oop head = list_head.resolve();\n+        java_lang_VirtualThread::set_next(vthread, head);\n+        if (list_head.cmpxchg(head, vthread) == head) return true;\n+      }\n+    }\n+  }\n+  return false; \/\/ already on waiting list\n+}\n+\n+void java_lang_VirtualThread::set_notified(oop vthread, jboolean value) {\n+  vthread->bool_field_put_volatile(_notified_offset, value);\n+}\n+\n+jlong java_lang_VirtualThread::timeout(oop vthread) {\n+  return vthread->long_field(_timeout_offset);\n+}\n+\n+void java_lang_VirtualThread::set_timeout(oop vthread, jlong value) {\n+  vthread->long_field_put(_timeout_offset, value);\n+}\n+\n@@ -2086,0 +2133,3 @@\n+    case UNBLOCKED:\n+    case WAITING:\n+    case TIMED_WAITING:\n@@ -2096,0 +2146,10 @@\n+    case BLOCKING:\n+    case BLOCKED:\n+      status = JavaThreadStatus::BLOCKED_ON_MONITOR_ENTER;\n+      break;\n+    case WAIT:\n+      status = JavaThreadStatus::IN_OBJECT_WAIT;\n+      break;\n+    case TIMED_WAIT:\n+      status = JavaThreadStatus::IN_OBJECT_WAIT_TIMED;\n+      break;\n@@ -2105,0 +2165,7 @@\n+bool java_lang_VirtualThread::is_preempted(oop vthread) {\n+  oop continuation = java_lang_VirtualThread::continuation(vthread);\n+  assert(continuation != nullptr, \"vthread with no continuation\");\n+  stackChunkOop chunk = jdk_internal_vm_Continuation::tail(continuation);\n+  return chunk != nullptr && chunk->preempted();\n+}\n+\n@@ -4803,3 +4870,0 @@\n-int java_lang_System::_static_security_offset;\n-int java_lang_System::_static_allow_security_offset;\n-int java_lang_System::_static_never_offset;\n@@ -4810,4 +4874,1 @@\n-  macro(_static_err_offset, k, \"err\", print_stream_signature, true); \\\n-  macro(_static_security_offset, k, \"security\", security_manager_signature, true); \\\n-  macro(_static_allow_security_offset, k, \"allowSecurityManager\", int_signature, true); \\\n-  macro(_static_never_offset, k, \"NEVER\", int_signature, true)\n+  macro(_static_err_offset, k, \"err\", print_stream_signature, true);\n@@ -4823,9 +4884,1 @@\n-  static int initialized = false;\n-  static bool allowed = true; \/\/ default\n-  if (!initialized) {\n-    oop base = vmClasses::System_klass()->static_field_base_raw();\n-    int never = base->int_field(_static_never_offset);\n-    allowed = (base->int_field(_static_allow_security_offset) != never);\n-    initialized = true;\n-  }\n-  return allowed;\n+  return false;\n@@ -4836,2 +4889,1 @@\n-  oop base = vmClasses::System_klass()->static_field_base_raw();\n-  return base->obj_field(_static_security_offset) != nullptr;\n+  return false;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":83,"deletions":31,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -363,1 +363,0 @@\n-  static int _inheritedAccessControlContext_offset;\n@@ -410,2 +409,0 @@\n-  \/\/ Control context\n-  static oop inherited_access_control_context(oop java_thread);\n@@ -535,0 +532,5 @@\n+  static int _next_offset;\n+  static int _onWaitingList_offset;\n+  static int _notified_offset;\n+  static int _recheckInterval_offset;\n+  static int _timeout_offset;\n@@ -550,0 +552,7 @@\n+    BLOCKING      = 12,\n+    BLOCKED       = 13,\n+    UNBLOCKED     = 14,\n+    WAITING       = 15,\n+    WAIT          = 16,  \/\/ waiting in Object.wait\n+    TIMED_WAITING = 17,\n+    TIMED_WAIT    = 18,  \/\/ waiting in timed-Object.wait\n@@ -569,0 +578,9 @@\n+  static void set_state(oop vthread, int state);\n+  static int cmpxchg_state(oop vthread, int old_state, int new_state);\n+  static oop next(oop vthread);\n+  static void set_next(oop vthread, oop next_vthread);\n+  static bool set_onWaitingList(oop vthread, OopHandle& list_head);\n+  static jlong timeout(oop vthread);\n+  static void set_timeout(oop vthread, jlong value);\n+  static void set_notified(oop vthread, jboolean value);\n+  static bool is_preempted(oop vthread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -446,1 +446,0 @@\n-  template(inheritedAccessControlContext_name,        \"inheritedAccessControlContext\")            \\\n@@ -449,1 +448,0 @@\n-  template(checkPackageAccess_name,                   \"checkPackageAccess\")                       \\\n@@ -526,0 +524,2 @@\n+  template(lockStackSize_name,                        \"lockStackSize\")                            \\\n+  template(objectWaiter_name,                         \"objectWaiter\")                             \\\n@@ -574,0 +574,1 @@\n+  template(vthread_signature,                         \"Ljava\/lang\/VirtualThread;\")                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -391,1 +391,1 @@\n-    st->print(\"nullptr\");\n+    st->print(\"null\");\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -711,1 +711,2 @@\n-  if (thread->has_last_Java_frame() && fr.sp() == thread->last_Java_sp()) {\n+  if ((thread->has_last_Java_frame() && fr.sp() == thread->last_Java_sp())\n+      JVMTI_ONLY(|| (method()->is_continuation_enter_intrinsic() && thread->on_monitor_waited_event()))) {\n@@ -1316,1 +1317,1 @@\n-    _num_stack_arg_slots     = _method->constMethod()->num_stack_arg_slots();\n+    _num_stack_arg_slots     = 0;\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"gc\/shared\/preservedMarks.inline.hpp\"\n@@ -62,1 +61,0 @@\n-                                           PreservedMarks* preserved_marks,\n@@ -93,1 +91,0 @@\n-    _preserved_marks(preserved_marks),\n@@ -219,1 +216,1 @@\n-    obj = m.forwardee();\n+    obj = obj->forwardee(m);\n@@ -235,1 +232,0 @@\n-  assert(from_obj->is_objArray(), \"must be obj array\");\n@@ -268,1 +264,0 @@\n-  assert(from_obj->is_objArray(), \"precondition\");\n@@ -404,1 +399,1 @@\n-                                                  oop const old, size_t word_sz, uint age,\n+                                                  Klass* klass, size_t word_sz, uint age,\n@@ -408,1 +403,1 @@\n-    _g1h->gc_tracer_stw()->report_promotion_in_new_plab_event(old->klass(), word_sz * HeapWordSize, age,\n+    _g1h->gc_tracer_stw()->report_promotion_in_new_plab_event(klass, word_sz * HeapWordSize, age,\n@@ -412,1 +407,1 @@\n-    _g1h->gc_tracer_stw()->report_promotion_outside_plab_event(old->klass(), word_sz * HeapWordSize, age,\n+    _g1h->gc_tracer_stw()->report_promotion_outside_plab_event(klass, word_sz * HeapWordSize, age,\n@@ -419,1 +414,1 @@\n-                                                   oop old,\n+                                                   Klass* klass,\n@@ -442,1 +437,1 @@\n-      report_promotion_event(*dest_attr, old, word_sz, age, obj_ptr, node_index);\n+      report_promotion_event(*dest_attr, klass, word_sz, age, obj_ptr, node_index);\n@@ -477,3 +472,11 @@\n-  \/\/ Get the klass once.  We'll need it again later, and this avoids\n-  \/\/ re-decoding when it's compressed.\n-  Klass* klass = old->klass();\n+  \/\/ NOTE: With compact headers, it is not safe to load the Klass* from old, because\n+  \/\/ that would access the mark-word, that might change at any time by concurrent\n+  \/\/ workers.\n+  \/\/ This mark word would refer to a forwardee, which may not yet have completed\n+  \/\/ copying. Therefore we must load the Klass* from the mark-word that we already\n+  \/\/ loaded. This is safe, because we only enter here if not yet forwarded.\n+  assert(!old_mark.is_forwarded(), \"precondition\");\n+  Klass* klass = UseCompactObjectHeaders\n+      ? old_mark.klass()\n+      : old->klass();\n+\n@@ -497,1 +500,1 @@\n-    obj_ptr = allocate_copy_slow(&dest_attr, old, word_sz, age, node_index);\n+    obj_ptr = allocate_copy_slow(&dest_attr, klass, word_sz, age, node_index);\n@@ -599,1 +602,0 @@\n-                               _preserved_marks_set.get(worker_id),\n@@ -659,1 +661,1 @@\n-  oop forward_ptr = old->forward_to_atomic(old, m, memory_order_relaxed);\n+  oop forward_ptr = old->forward_to_self_atomic(m, memory_order_relaxed);\n@@ -672,2 +674,0 @@\n-    _preserved_marks->push_if_necessary(old, m);\n-\n@@ -731,1 +731,0 @@\n-    _preserved_marks_set(true \/* in_c_heap *\/),\n@@ -740,1 +739,0 @@\n-  _preserved_marks_set.init(num_workers);\n@@ -753,1 +751,0 @@\n-  _preserved_marks_set.reclaim();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":19,"deletions":22,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"gc\/shared\/fullGCForwarding.inline.hpp\"\n@@ -131,0 +132,20 @@\n+bool ParallelCompactData::RegionData::is_clear() {\n+  return (_destination == nullptr) &&\n+         (_source_region == 0) &&\n+         (_partial_obj_addr == nullptr) &&\n+         (_partial_obj_size == 0) &&\n+         (_dc_and_los == 0) &&\n+         (_shadow_state == 0);\n+}\n+\n+#ifdef ASSERT\n+void ParallelCompactData::RegionData::verify_clear() {\n+  assert(_destination == nullptr, \"inv\");\n+  assert(_source_region == 0, \"inv\");\n+  assert(_partial_obj_addr == nullptr, \"inv\");\n+  assert(_partial_obj_size == 0, \"inv\");\n+  assert(_dc_and_los == 0, \"inv\");\n+  assert(_shadow_state == 0, \"inv\");\n+}\n+#endif\n+\n@@ -136,10 +157,2 @@\n-void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,\n-                       HeapWord* destination)\n-{\n-  assert(src_region_idx != 0, \"invalid src_region_idx\");\n-  assert(partial_obj_size != 0, \"invalid partial_obj_size argument\");\n-  assert(destination != nullptr, \"invalid destination argument\");\n-\n-  _src_region_idx = src_region_idx;\n-  _partial_obj_size = partial_obj_size;\n-  _destination = destination;\n+void SplitInfo::record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words) {\n+  assert(split_region_idx != 0, \"precondition\");\n@@ -147,3 +160,2 @@\n-  \/\/ These fields may not be updated below, so make sure they're clear.\n-  assert(_dest_region_addr == nullptr, \"should have been cleared\");\n-  assert(_first_src_addr == nullptr, \"should have been cleared\");\n+  \/\/ Obj denoted by split_point will be deferred to the next space.\n+  assert(split_point != nullptr, \"precondition\");\n@@ -151,14 +163,11 @@\n-  \/\/ Determine the number of destination regions for the partial object.\n-  HeapWord* const last_word = destination + partial_obj_size - 1;\n-  HeapWord* const beg_region_addr = sd.region_align_down(destination);\n-  HeapWord* const end_region_addr = sd.region_align_down(last_word);\n-\n-  if (beg_region_addr == end_region_addr) {\n-    \/\/ One destination region.\n-    _destination_count = 1;\n-    if (end_region_addr == destination) {\n-      \/\/ The destination falls on a region boundary, thus the first word of the\n-      \/\/ partial object will be the first word copied to the destination region.\n-      _dest_region_addr = end_region_addr;\n-      _first_src_addr = sd.region_to_addr(src_region_idx);\n-    }\n+\n+  PSParallelCompact::RegionData* split_region_ptr = sd.region(split_region_idx);\n+  assert(preceding_live_words < split_region_ptr->data_size(), \"inv\");\n+\n+  HeapWord* preceding_destination = split_region_ptr->destination();\n+  assert(preceding_destination != nullptr, \"inv\");\n+\n+  \/\/ How many regions does the preceding part occupy\n+  uint preceding_destination_count;\n+  if (preceding_live_words == 0) {\n+    preceding_destination_count = 0;\n@@ -167,8 +176,7 @@\n-    \/\/ Two destination regions.  When copied, the partial object will cross a\n-    \/\/ destination region boundary, so a word somewhere within the partial\n-    \/\/ object will be the first word copied to the second destination region.\n-    _destination_count = 2;\n-    _dest_region_addr = end_region_addr;\n-    const size_t ofs = pointer_delta(end_region_addr, destination);\n-    assert(ofs < _partial_obj_size, \"sanity\");\n-    _first_src_addr = sd.region_to_addr(src_region_idx) + ofs;\n+    \/\/ -1 so that the ending address doesn't fall on the region-boundary\n+    if (sd.region_align_down(preceding_destination) ==\n+        sd.region_align_down(preceding_destination + preceding_live_words - 1)) {\n+      preceding_destination_count = 1;\n+    } else {\n+      preceding_destination_count = 2;\n+    }\n@@ -176,0 +184,6 @@\n+\n+  _split_region_idx = split_region_idx;\n+  _split_point = split_point;\n+  _preceding_live_words = preceding_live_words;\n+  _preceding_destination = preceding_destination;\n+  _preceding_destination_count = preceding_destination_count;\n@@ -180,6 +194,5 @@\n-  _src_region_idx = 0;\n-  _partial_obj_size = 0;\n-  _destination = nullptr;\n-  _destination_count = 0;\n-  _dest_region_addr = nullptr;\n-  _first_src_addr = nullptr;\n+  _split_region_idx = 0;\n+  _split_point = nullptr;\n+  _preceding_live_words = 0;\n+  _preceding_destination = nullptr;\n+  _preceding_destination_count = 0;\n@@ -192,6 +205,5 @@\n-  assert(_src_region_idx == 0, \"not clear\");\n-  assert(_partial_obj_size == 0, \"not clear\");\n-  assert(_destination == nullptr, \"not clear\");\n-  assert(_destination_count == 0, \"not clear\");\n-  assert(_dest_region_addr == nullptr, \"not clear\");\n-  assert(_first_src_addr == nullptr, \"not clear\");\n+  assert(_split_region_idx == 0, \"not clear\");\n+  assert(_split_point == nullptr, \"not clear\");\n+  assert(_preceding_live_words == 0, \"not clear\");\n+  assert(_preceding_destination == nullptr, \"not clear\");\n+  assert(_preceding_destination_count == 0, \"not clear\");\n@@ -300,23 +312,8 @@\n-\/\/ Find the point at which a space can be split and, if necessary, record the\n-\/\/ split point.\n-\/\/\n-\/\/ If the current src region (which overflowed the destination space) doesn't\n-\/\/ have a partial object, the split point is at the beginning of the current src\n-\/\/ region (an \"easy\" split, no extra bookkeeping required).\n-\/\/\n-\/\/ If the current src region has a partial object, the split point is in the\n-\/\/ region where that partial object starts (call it the split_region).  If\n-\/\/ split_region has a partial object, then the split point is just after that\n-\/\/ partial object (a \"hard\" split where we have to record the split data and\n-\/\/ zero the partial_obj_size field).  With a \"hard\" split, we know that the\n-\/\/ partial_obj ends within split_region because the partial object that caused\n-\/\/ the overflow starts in split_region.  If split_region doesn't have a partial\n-\/\/ obj, then the split is at the beginning of split_region (another \"easy\"\n-\/\/ split).\n-HeapWord*\n-ParallelCompactData::summarize_split_space(size_t src_region,\n-                                           SplitInfo& split_info,\n-                                           HeapWord* destination,\n-                                           HeapWord* target_end,\n-                                           HeapWord** target_next)\n-{\n+\/\/ The total live words on src_region would overflow the target space, so find\n+\/\/ the overflowing object and record the split point. The invariant is that an\n+\/\/ obj should not cross space boundary.\n+HeapWord* ParallelCompactData::summarize_split_space(size_t src_region,\n+                                                     SplitInfo& split_info,\n+                                                     HeapWord* const destination,\n+                                                     HeapWord* const target_end,\n+                                                     HeapWord** target_next) {\n@@ -328,2 +325,0 @@\n-  size_t split_region = src_region;\n-  HeapWord* split_destination = destination;\n@@ -333,3 +328,2 @@\n-    \/\/ The split point is just after the partial object (if any) in the\n-    \/\/ src_region that contains the start of the object that overflowed the\n-    \/\/ destination space.\n+    assert(partial_obj_size > 0, \"inv\");\n+    \/\/ The overflowing obj is from a previous region.\n@@ -337,8 +331,1 @@\n-    \/\/ Find the start of the \"overflow\" object and set split_region to the\n-    \/\/ region containing it.\n-    HeapWord* const overflow_obj = _region_data[src_region].partial_obj_addr();\n-    split_region = addr_to_region_idx(overflow_obj);\n-\n-    \/\/ Clear the source_region field of all destination regions whose first word\n-    \/\/ came from data after the split point (a non-null source_region field\n-    \/\/ implies a region must be filled).\n+    \/\/ source-regions:\n@@ -346,4 +333,5 @@\n-    \/\/ An alternative to the simple loop below:  clear during post_compact(),\n-    \/\/ which uses memcpy instead of individual stores, and is easy to\n-    \/\/ parallelize.  (The downside is that it clears the entire RegionData\n-    \/\/ object as opposed to just one field.)\n+    \/\/ ***************\n+    \/\/ |     A|AA    |\n+    \/\/ ***************\n+    \/\/       ^\n+    \/\/       | split-point\n@@ -351,2 +339,1 @@\n-    \/\/ post_compact() would have to clear the summary data up to the highest\n-    \/\/ address that was written during the summary phase, which would be\n+    \/\/ dest-region:\n@@ -354,1 +341,7 @@\n-    \/\/         max(top, max(new_top, clear_top))\n+    \/\/ ********\n+    \/\/ |~~~~A |\n+    \/\/ ********\n+    \/\/       ^^\n+    \/\/       || target-space-end\n+    \/\/       |\n+    \/\/       | destination\n@@ -356,7 +349,4 @@\n-    \/\/ where clear_top is a new field in SpaceInfo.  Would have to set clear_top\n-    \/\/ to target_end.\n-    const RegionData* const sr = region(split_region);\n-    const size_t beg_idx =\n-      addr_to_region_idx(region_align_up(sr->destination() +\n-                                         sr->partial_obj_size()));\n-    const size_t end_idx = addr_to_region_idx(target_end);\n+    \/\/ AAA would overflow target-space.\n+    \/\/\n+    HeapWord* overflowing_obj = _region_data[src_region].partial_obj_addr();\n+    size_t split_region = addr_to_region_idx(overflowing_obj);\n@@ -364,3 +354,8 @@\n-    log_develop_trace(gc, compaction)(\"split:  clearing source_region field in [\" SIZE_FORMAT \", \" SIZE_FORMAT \")\", beg_idx, end_idx);\n-    for (size_t idx = beg_idx; idx < end_idx; ++idx) {\n-      _region_data[idx].set_source_region(0);\n+    \/\/ The number of live words before the overflowing object on this split region\n+    size_t preceding_live_words;\n+    if (is_region_aligned(overflowing_obj)) {\n+      preceding_live_words = 0;\n+    } else {\n+      \/\/ Words accounted by the overflowing object on the split region\n+      size_t overflowing_size = pointer_delta(region_align_up(overflowing_obj), overflowing_obj);\n+      preceding_live_words = region(split_region)->data_size() - overflowing_size;\n@@ -369,4 +364,19 @@\n-    \/\/ Set split_destination and partial_obj_size to reflect the split region.\n-    split_destination = sr->destination();\n-    partial_obj_size = sr->partial_obj_size();\n-  }\n+    split_info.record(split_region, overflowing_obj, preceding_live_words);\n+\n+    HeapWord* src_region_start = region_to_addr(src_region);\n+    HeapWord* new_top = destination - pointer_delta(src_region_start, overflowing_obj);\n+\n+    \/\/ If the overflowing obj was relocated to its original destination,\n+    \/\/ those destination regions would have their source_region set. Now that\n+    \/\/ this overflowing obj is relocated somewhere else, reset the\n+    \/\/ source_region.\n+    {\n+      size_t range_start = addr_to_region_idx(region_align_up(new_top));\n+      size_t range_end = addr_to_region_idx(region_align_up(destination));\n+      for (size_t i = range_start; i < range_end; ++i) {\n+        region(i)->set_source_region(0);\n+      }\n+    }\n+\n+    \/\/ Update new top of target space\n+    *target_next = new_top;\n@@ -374,4 +384,1 @@\n-  \/\/ The split is recorded only if a partial object extends onto the region.\n-  if (partial_obj_size != 0) {\n-    _region_data[split_region].set_partial_obj_size(0);\n-    split_info.record(split_region, partial_obj_size, split_destination);\n+    return overflowing_obj;\n@@ -380,3 +387,5 @@\n-  \/\/ Setup the continuation addresses.\n-  *target_next = split_destination + partial_obj_size;\n-  HeapWord* const source_next = region_to_addr(split_region) + partial_obj_size;\n+  \/\/ Obj-iteration to locate the overflowing obj\n+  HeapWord* region_start = region_to_addr(src_region);\n+  HeapWord* region_end = region_start + RegionSize;\n+  HeapWord* cur_addr = region_start + partial_obj_size;\n+  size_t live_words = partial_obj_size;\n@@ -384,8 +393,5 @@\n-  if (log_develop_is_enabled(Trace, gc, compaction)) {\n-    const char * split_type = partial_obj_size == 0 ? \"easy\" : \"hard\";\n-    log_develop_trace(gc, compaction)(\"%s split:  src=\" PTR_FORMAT \" src_c=\" SIZE_FORMAT \" pos=\" SIZE_FORMAT,\n-                                      split_type, p2i(source_next), split_region, partial_obj_size);\n-    log_develop_trace(gc, compaction)(\"%s split:  dst=\" PTR_FORMAT \" dst_c=\" SIZE_FORMAT \" tn=\" PTR_FORMAT,\n-                                      split_type, p2i(split_destination),\n-                                      addr_to_region_idx(split_destination),\n-                                      p2i(*target_next));\n+  while (true) {\n+    assert(cur_addr < region_end, \"inv\");\n+    cur_addr = PSParallelCompact::mark_bitmap()->find_obj_beg(cur_addr, region_end);\n+    \/\/ There must be an overflowing obj in this region\n+    assert(cur_addr < region_end, \"inv\");\n@@ -393,7 +399,7 @@\n-    if (partial_obj_size != 0) {\n-      HeapWord* const po_beg = split_info.destination();\n-      HeapWord* const po_end = po_beg + split_info.partial_obj_size();\n-      log_develop_trace(gc, compaction)(\"%s split:  po_beg=\" PTR_FORMAT \" \" SIZE_FORMAT \" po_end=\" PTR_FORMAT \" \" SIZE_FORMAT,\n-                                        split_type,\n-                                        p2i(po_beg), addr_to_region_idx(po_beg),\n-                                        p2i(po_end), addr_to_region_idx(po_end));\n+    oop obj = cast_to_oop(cur_addr);\n+    size_t obj_size = obj->size();\n+    if (destination + live_words + obj_size > target_end) {\n+      \/\/ Found the overflowing obj\n+      split_info.record(src_region, cur_addr, live_words);\n+      *target_next = destination + live_words;\n+      return cur_addr;\n@@ -401,2 +407,3 @@\n-  }\n-  return source_next;\n+    live_words += obj_size;\n+    cur_addr += obj_size;\n+  }\n@@ -455,2 +462,13 @@\n-  while (cur_region < end_region) {\n-    \/\/ The destination must be set even if the region has no data.\n+  for (\/* empty *\/; cur_region < end_region; cur_region++) {\n+    size_t words = _region_data[cur_region].data_size();\n+\n+    \/\/ Skip empty ones\n+    if (words == 0) {\n+      continue;\n+    }\n+\n+    if (split_info.is_split(cur_region)) {\n+      assert(words > split_info.preceding_live_words(), \"inv\");\n+      words -= split_info.preceding_live_words();\n+    }\n+\n@@ -459,11 +477,9 @@\n-    size_t words = _region_data[cur_region].data_size();\n-    if (words > 0) {\n-      \/\/ If cur_region does not fit entirely into the target space, find a point\n-      \/\/ at which the source space can be 'split' so that part is copied to the\n-      \/\/ target space and the rest is copied elsewhere.\n-      if (dest_addr + words > target_end) {\n-        assert(source_next != nullptr, \"source_next is null when splitting\");\n-        *source_next = summarize_split_space(cur_region, split_info, dest_addr,\n-                                             target_end, target_next);\n-        return false;\n-      }\n+    \/\/ If cur_region does not fit entirely into the target space, find a point\n+    \/\/ at which the source space can be 'split' so that part is copied to the\n+    \/\/ target space and the rest is copied elsewhere.\n+    if (dest_addr + words > target_end) {\n+      assert(source_next != nullptr, \"source_next is null when splitting\");\n+      *source_next = summarize_split_space(cur_region, split_info, dest_addr,\n+                                           target_end, target_next);\n+      return false;\n+    }\n@@ -471,22 +487,3 @@\n-      \/\/ Compute the destination_count for cur_region, and if necessary, update\n-      \/\/ source_region for a destination region.  The source_region field is\n-      \/\/ updated if cur_region is the first (left-most) region to be copied to a\n-      \/\/ destination region.\n-      \/\/\n-      \/\/ The destination_count calculation is a bit subtle.  A region that has\n-      \/\/ data that compacts into itself does not count itself as a destination.\n-      \/\/ This maintains the invariant that a zero count means the region is\n-      \/\/ available and can be claimed and then filled.\n-      uint destination_count = 0;\n-      if (split_info.is_split(cur_region)) {\n-        \/\/ The current region has been split:  the partial object will be copied\n-        \/\/ to one destination space and the remaining data will be copied to\n-        \/\/ another destination space.  Adjust the initial destination_count and,\n-        \/\/ if necessary, set the source_region field if the partial object will\n-        \/\/ cross a destination region boundary.\n-        destination_count = split_info.destination_count();\n-        if (destination_count == 2) {\n-          size_t dest_idx = addr_to_region_idx(split_info.dest_region_addr());\n-          _region_data[dest_idx].set_source_region(cur_region);\n-        }\n-      }\n+    uint destination_count = split_info.is_split(cur_region)\n+                             ? split_info.preceding_destination_count()\n+                             : 0;\n@@ -494,19 +491,3 @@\n-      HeapWord* const last_addr = dest_addr + words - 1;\n-      const size_t dest_region_1 = addr_to_region_idx(dest_addr);\n-      const size_t dest_region_2 = addr_to_region_idx(last_addr);\n-\n-      \/\/ Initially assume that the destination regions will be the same and\n-      \/\/ adjust the value below if necessary.  Under this assumption, if\n-      \/\/ cur_region == dest_region_2, then cur_region will be compacted\n-      \/\/ completely into itself.\n-      destination_count += cur_region == dest_region_2 ? 0 : 1;\n-      if (dest_region_1 != dest_region_2) {\n-        \/\/ Destination regions differ; adjust destination_count.\n-        destination_count += 1;\n-        \/\/ Data from cur_region will be copied to the start of dest_region_2.\n-        _region_data[dest_region_2].set_source_region(cur_region);\n-      } else if (is_region_aligned(dest_addr)) {\n-        \/\/ Data from cur_region will be copied to the start of the destination\n-        \/\/ region.\n-        _region_data[dest_region_1].set_source_region(cur_region);\n-      }\n+    HeapWord* const last_addr = dest_addr + words - 1;\n+    const size_t dest_region_1 = addr_to_region_idx(dest_addr);\n+    const size_t dest_region_2 = addr_to_region_idx(last_addr);\n@@ -514,2 +495,14 @@\n-      _region_data[cur_region].set_destination_count(destination_count);\n-      dest_addr += words;\n+    \/\/ Initially assume that the destination regions will be the same and\n+    \/\/ adjust the value below if necessary.  Under this assumption, if\n+    \/\/ cur_region == dest_region_2, then cur_region will be compacted\n+    \/\/ completely into itself.\n+    destination_count += cur_region == dest_region_2 ? 0 : 1;\n+    if (dest_region_1 != dest_region_2) {\n+      \/\/ Destination regions differ; adjust destination_count.\n+      destination_count += 1;\n+      \/\/ Data from cur_region will be copied to the start of dest_region_2.\n+      _region_data[dest_region_2].set_source_region(cur_region);\n+    } else if (is_region_aligned(dest_addr)) {\n+      \/\/ Data from cur_region will be copied to the start of the destination\n+      \/\/ region.\n+      _region_data[dest_region_1].set_source_region(cur_region);\n@@ -518,1 +511,2 @@\n-    ++cur_region;\n+    _region_data[cur_region].set_destination_count(destination_count);\n+    dest_addr += words;\n@@ -526,6 +520,6 @@\n-void ParallelCompactData::verify_clear()\n-{\n-  const size_t* const beg = (const size_t*) _region_vspace->committed_low_addr();\n-  const size_t* const end = (const size_t*) _region_vspace->committed_high_addr();\n-  for (const size_t* p = beg; p < end; ++p) {\n-    assert(*p == 0, \"not zero\");\n+void ParallelCompactData::verify_clear() {\n+  for (uint cur_idx = 0; cur_idx < region_count(); ++cur_idx) {\n+    if (!region(cur_idx)->is_clear()) {\n+      log_warning(gc)(\"Uncleared Region: %u\", cur_idx);\n+      region(cur_idx)->verify_clear();\n+    }\n@@ -698,0 +692,7 @@\n+#ifdef ASSERT\n+  {\n+    mark_bitmap()->verify_clear();\n+    summary_data().verify_clear();\n+  }\n+#endif\n+\n@@ -777,0 +778,2 @@\n+  \/\/ With +UseCompactObjectHeaders, the minimum filler size is only one word,\n+  \/\/ because the Klass* gets encoded in the mark-word.\n@@ -784,8 +787,1 @@\n-  \/\/ Note: If min-fill-size decreases to 1, this whole method becomes redundant.\n-  assert(CollectedHeap::min_fill_size() >= 2, \"inv\");\n-#ifndef _LP64\n-  \/\/ In 32-bit system, each heap word is 4 bytes, so MinObjAlignment == 2.\n-  \/\/ The gap is always equal to min-fill-size, so nothing to do.\n-  return;\n-#endif\n-  if (MinObjAlignment > 1) {\n+  if (MinObjAlignment >= checked_cast<int>(CollectedHeap::min_fill_size())) {\n@@ -794,0 +790,2 @@\n+\n+  assert(!UseCompactObjectHeaders, \"Compact headers can allocate small objects\");\n@@ -884,4 +882,4 @@\n-    HeapWord* dense_prefix_end =\n-      maximum_compaction ? full_region_prefix_end\n-                         : compute_dense_prefix_for_old_space(old_space,\n-                                                              full_region_prefix_end);\n+    HeapWord* dense_prefix_end = maximum_compaction\n+                                 ? full_region_prefix_end\n+                                 : compute_dense_prefix_for_old_space(old_space,\n+                                                                      full_region_prefix_end);\n@@ -895,0 +893,2 @@\n+\n+    \/\/ Compacting objs inn [dense_prefix_end, old_space->top())\n@@ -1554,0 +1554,24 @@\n+    static void forward_objs_in_range(ParCompactionManager* cm,\n+                                      HeapWord* start,\n+                                      HeapWord* end,\n+                                      HeapWord* destination) {\n+      HeapWord* cur_addr = start;\n+      HeapWord* new_addr = destination;\n+\n+      while (cur_addr < end) {\n+        cur_addr = mark_bitmap()->find_obj_beg(cur_addr, end);\n+        if (cur_addr >= end) {\n+          return;\n+        }\n+        assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n+        oop obj = cast_to_oop(cur_addr);\n+        if (new_addr != cur_addr) {\n+          cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n+          FullGCForwarding::forward_to(obj, cast_to_oop(new_addr));\n+        }\n+        size_t obj_size = obj->size();\n+        new_addr += obj_size;\n+        cur_addr += obj_size;\n+      }\n+    }\n+\n@@ -1565,0 +1589,2 @@\n+        const SplitInfo& split_info = _space_info[SpaceId(id)].split_info();\n+\n@@ -1584,18 +1610,13 @@\n-          HeapWord* cur_addr = region_start + live_words;\n-\n-          HeapWord* destination = region_ptr->destination();\n-          while (cur_addr < region_end) {\n-            cur_addr = mark_bitmap()->find_obj_beg(cur_addr, region_end);\n-            if (cur_addr >= region_end) {\n-              break;\n-            }\n-            assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n-            HeapWord* new_addr = destination + live_words;\n-            oop obj = cast_to_oop(cur_addr);\n-            if (new_addr != cur_addr) {\n-              cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n-              obj->forward_to(cast_to_oop(new_addr));\n-            }\n-            size_t obj_size = obj->size();\n-            live_words += obj_size;\n-            cur_addr += obj_size;\n+\n+          if (split_info.is_split(cur_region)) {\n+            \/\/ Part 1: will be relocated to space-1\n+            HeapWord* preceding_destination = split_info.preceding_destination();\n+            HeapWord* split_point = split_info.split_point();\n+            forward_objs_in_range(cm, region_start + live_words, split_point, preceding_destination + live_words);\n+\n+            \/\/ Part 2: will be relocated to space-2\n+            HeapWord* destination = region_ptr->destination();\n+            forward_objs_in_range(cm, split_point, region_end, destination);\n+          } else {\n+            HeapWord* destination = region_ptr->destination();\n+            forward_objs_in_range(cm, region_start + live_words, region_end, destination + live_words);\n@@ -1633,0 +1654,1 @@\n+      assert(bump_ptr <= _space_info[bump_ptr_space].new_top(), \"inv\");\n@@ -1639,2 +1661,4 @@\n-      if (cur_addr != bump_ptr) {\n-        assert(obj->forwardee() == cast_to_oop(bump_ptr), \"inv\");\n+      if (cur_addr == bump_ptr) {\n+        assert(!FullGCForwarding::is_forwarded(obj), \"inv\");\n+      } else {\n+        assert(FullGCForwarding::forwardee(obj) == cast_to_oop(bump_ptr), \"inv\");\n@@ -1894,1 +1918,1 @@\n-      Klass* k = cast_to_oop(cur_addr)->klass_without_asserts();\n+      Klass* k = cast_to_oop(cur_addr)->klass();\n@@ -1945,6 +1969,3 @@\n-\/\/ next live word.  Unless marked, the word corresponding to beg is assumed to\n-\/\/ be dead.  Callers must either ensure beg does not correspond to the middle of\n-\/\/ an object, or account for those live words in some other way.  Callers must\n-\/\/ also ensure that there are enough live words in the range [beg, end) to skip.\n-HeapWord*\n-PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)\n+\/\/ next live word. Callers must also ensure that there are enough live words in\n+\/\/ the range [beg, end) to skip.\n+HeapWord* PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)\n@@ -1952,2 +1973,0 @@\n-  assert(count > 0, \"sanity\");\n-\n@@ -1969,0 +1988,39 @@\n+\/\/ On filling a destination region (dest-region), we need to know the location\n+\/\/ of the word that will be at the start of the dest-region after compaction.\n+\/\/ A dest-region can have one or more source regions, but only the first\n+\/\/ source-region contains this location. This location is retrieved by calling\n+\/\/ `first_src_addr` on a dest-region.\n+\/\/ Conversely, a source-region has a dest-region which holds the destination of\n+\/\/ the first live word on this source-region, based on which the destination\n+\/\/ for the rest of live words can be derived.\n+\/\/\n+\/\/ Note:\n+\/\/ There is some complication due to space-boundary-fragmentation (an obj can't\n+\/\/ cross space-boundary) -- a source-region may be split and behave like two\n+\/\/ distinct regions with their own dest-region, as depicted below.\n+\/\/\n+\/\/ source-region: region-n\n+\/\/\n+\/\/ **********************\n+\/\/ |     A|A~~~~B|B     |\n+\/\/ **********************\n+\/\/    n-1     n     n+1\n+\/\/\n+\/\/ AA, BB denote two live objs. ~~~~ denotes unknown number of live objs.\n+\/\/\n+\/\/ Assuming the dest-region for region-n is the final region before\n+\/\/ old-space-end and its first-live-word is the middle of AA, the heap content\n+\/\/ will look like the following after compaction:\n+\/\/\n+\/\/ **************                  *************\n+\/\/      A|A~~~~ |                  |BB    |\n+\/\/ **************                  *************\n+\/\/              ^                  ^\n+\/\/              | old-space-end    | eden-space-start\n+\/\/\n+\/\/ Therefore, in this example, region-n will have two dest-regions, one for\n+\/\/ the final region in old-space and the other for the first region in\n+\/\/ eden-space.\n+\/\/ To handle this special case, we introduce the concept of split-region, whose\n+\/\/ contents are relocated to two spaces. `SplitInfo` captures all necessary\n+\/\/ info about the split, the first part, spliting-point, and the second part.\n@@ -1973,11 +2031,2 @@\n-  assert(summary_data().is_region_aligned(dest_addr), \"not aligned\");\n-\n-  const SplitInfo& split_info = _space_info[src_space_id].split_info();\n-  if (split_info.dest_region_addr() == dest_addr) {\n-    \/\/ The partial object ending at the split point contains the first word to\n-    \/\/ be copied to dest_addr.\n-    return split_info.first_src_addr();\n-  }\n-\n-  const ParallelCompactData& sd = summary_data();\n-  ParMarkBitMap* const bitmap = mark_bitmap();\n+  const ParallelCompactData& sd = summary_data();\n+  assert(sd.is_region_aligned(dest_addr), \"precondition\");\n@@ -1986,1 +2035,2 @@\n-  assert(sd.is_region_aligned(dest_addr), \"not aligned\");\n+  assert(src_region_ptr->data_size() > 0, \"src region cannot be empty\");\n+\n@@ -1991,5 +2041,2 @@\n-  assert(dest_addr >= src_region_destination, \"wrong src region\");\n-  assert(src_region_ptr->data_size() > 0, \"src region cannot be empty\");\n-\n-  HeapWord* const src_region_beg = sd.region_to_addr(src_region_idx);\n-  HeapWord* const src_region_end = src_region_beg + RegionSize;\n+  HeapWord* const region_start = sd.region_to_addr(src_region_idx);\n+  HeapWord* const region_end = sd.region_to_addr(src_region_idx) + RegionSize;\n@@ -1997,6 +2044,8 @@\n-  HeapWord* addr = src_region_beg;\n-  if (dest_addr == src_region_destination) {\n-    \/\/ Return the first live word in the source region.\n-    if (partial_obj_size == 0) {\n-      addr = bitmap->find_obj_beg(addr, src_region_end);\n-      assert(addr < src_region_end, \"no objects start in src region\");\n+  \/\/ Identify the actual destination for the first live words on this region,\n+  \/\/ taking split-region into account.\n+  HeapWord* region_start_destination;\n+  const SplitInfo& split_info = _space_info[src_space_id].split_info();\n+  if (split_info.is_split(src_region_idx)) {\n+    \/\/ The second part of this split region; use the recorded split point.\n+    if (dest_addr == src_region_destination) {\n+      return split_info.split_point();\n@@ -2004,1 +2053,3 @@\n-    return addr;\n+    region_start_destination = split_info.preceding_destination();\n+  } else {\n+    region_start_destination = src_region_destination;\n@@ -2007,3 +2058,2 @@\n-  \/\/ Must skip some live data.\n-  size_t words_to_skip = dest_addr - src_region_destination;\n-  assert(src_region_ptr->data_size() > words_to_skip, \"wrong src region\");\n+  \/\/ Calculate the offset to be skipped\n+  size_t words_to_skip = pointer_delta(dest_addr, region_start_destination);\n@@ -2011,9 +2061,6 @@\n-  if (partial_obj_size >= words_to_skip) {\n-    \/\/ All the live words to skip are part of the partial object.\n-    addr += words_to_skip;\n-    if (partial_obj_size == words_to_skip) {\n-      \/\/ Find the first live word past the partial object.\n-      addr = bitmap->find_obj_beg(addr, src_region_end);\n-      assert(addr < src_region_end, \"wrong src region\");\n-    }\n-    return addr;\n+  HeapWord* result;\n+  if (partial_obj_size > words_to_skip) {\n+    result = region_start + words_to_skip;\n+  } else {\n+    words_to_skip -= partial_obj_size;\n+    result = skip_live_words(region_start + partial_obj_size, region_end, words_to_skip);\n@@ -2022,4 +2069,4 @@\n-  \/\/ Skip over the partial object (if any).\n-  if (partial_obj_size != 0) {\n-    words_to_skip -= partial_obj_size;\n-    addr += partial_obj_size;\n+  if (split_info.is_split(src_region_idx)) {\n+    assert(result < split_info.split_point(), \"postcondition\");\n+  } else {\n+    assert(result < region_end, \"postcondition\");\n@@ -2028,4 +2075,1 @@\n-  \/\/ Skip over live words due to objects that start in the region.\n-  addr = skip_live_words(addr, src_region_end, words_to_skip);\n-  assert(addr < src_region_end, \"wrong src region\");\n-  return addr;\n+  return result;\n@@ -2082,3 +2126,0 @@\n-  typedef ParallelCompactData::RegionData RegionData;\n-\n-  const size_t region_size = ParallelCompactData::RegionSize;\n@@ -2093,2 +2134,2 @@\n-  const RegionData* const top_region_ptr =\n-    sd.addr_to_region_ptr(top_aligned_up);\n+  const RegionData* const top_region_ptr = sd.addr_to_region_ptr(top_aligned_up);\n+\n@@ -2111,1 +2152,1 @@\n-  unsigned int space_id = src_space_id + 1;\n+  uint space_id = src_space_id + 1;\n@@ -2114,28 +2155,24 @@\n-  HeapWord* const destination = closure.destination();\n-\n-  do {\n-    MutableSpace* space = _space_info[space_id].space();\n-    HeapWord* const bottom = space->bottom();\n-    const RegionData* const bottom_cp = sd.addr_to_region_ptr(bottom);\n-\n-    \/\/ Iterate over the spaces that do not compact into themselves.\n-    if (bottom_cp->destination() != bottom) {\n-      HeapWord* const top_aligned_up = sd.region_align_up(space->top());\n-      const RegionData* const top_cp = sd.addr_to_region_ptr(top_aligned_up);\n-\n-      for (const RegionData* src_cp = bottom_cp; src_cp < top_cp; ++src_cp) {\n-        if (src_cp->live_obj_size() > 0) {\n-          \/\/ Found it.\n-          assert(src_cp->destination() == destination,\n-                 \"first live obj in the space must match the destination\");\n-          assert(src_cp->partial_obj_size() == 0,\n-                 \"a space cannot begin with a partial obj\");\n-\n-          src_space_id = SpaceId(space_id);\n-          src_space_top = space->top();\n-          const size_t src_region_idx = sd.region(src_cp);\n-          closure.set_source(sd.region_to_addr(src_region_idx));\n-          return src_region_idx;\n-        } else {\n-          assert(src_cp->data_size() == 0, \"sanity\");\n-        }\n+  for (\/* empty *\/; space_id < last_space_id; ++space_id) {\n+    HeapWord* bottom = _space_info[space_id].space()->bottom();\n+    HeapWord* top = _space_info[space_id].space()->top();\n+    \/\/ Skip empty space\n+    if (bottom == top) {\n+      continue;\n+    }\n+\n+    \/\/ Identify the first region that contains live words in this space\n+    size_t cur_region = sd.addr_to_region_idx(bottom);\n+    size_t end_region = sd.addr_to_region_idx(sd.region_align_up(top));\n+\n+    for (\/* empty *\/ ; cur_region < end_region; ++cur_region) {\n+      RegionData* cur = sd.region(cur_region);\n+      if (cur->live_obj_size() > 0) {\n+        HeapWord* region_start_addr = sd.region_to_addr(cur_region);\n+        HeapWord* region_end_addr = region_start_addr + ParallelCompactData::RegionSize;\n+        HeapWord* first_live_word = mark_bitmap()->find_obj_beg(region_start_addr, region_end_addr);\n+        assert(first_live_word < region_end_addr, \"inv\");\n+\n+        src_space_id = SpaceId(space_id);\n+        src_space_top = top;\n+        closure.set_source(first_live_word);\n+        return cur_region;\n@@ -2144,1 +2181,1 @@\n-  } while (++space_id < last_space_id);\n+  }\n@@ -2146,2 +2183,1 @@\n-  assert(false, \"no source region was found\");\n-  return 0;\n+  ShouldNotReachHere();\n@@ -2154,2 +2190,2 @@\n-  \/\/ Use per-region partial_obj_size to locate the end of the obj, that extends to region_start_addr.\n-  SplitInfo& split_info = _space_info[space_id(region_start_addr)].split_info();\n+  \/\/ Use per-region partial_obj_size to locate the end of the obj, that extends\n+  \/\/ to region_start_addr.\n@@ -2160,4 +2196,0 @@\n-    if (split_info.is_split(region_idx)) {\n-      accumulated_size += split_info.partial_obj_size();\n-      break;\n-    }\n@@ -2173,0 +2205,2 @@\n+\/\/ Use region_idx as the destination region, and evacuate all live objs on its\n+\/\/ source regions to this destination region.\n@@ -2193,0 +2227,18 @@\n+  \/\/ source-region:\n+  \/\/\n+  \/\/ **********\n+  \/\/ |   ~~~  |\n+  \/\/ **********\n+  \/\/      ^\n+  \/\/      |-- closure.source() \/ first_src_addr\n+  \/\/\n+  \/\/\n+  \/\/ ~~~ : live words\n+  \/\/\n+  \/\/ destination-region:\n+  \/\/\n+  \/\/ **********\n+  \/\/ |        |\n+  \/\/ **********\n+  \/\/ ^\n+  \/\/ |-- region-start\n@@ -2194,3 +2246,3 @@\n-    \/\/ The first source word is in the middle of an object; copy the remainder\n-    \/\/ of the object or as much as will fit.  The fact that pointer updates were\n-    \/\/ deferred will be noted when the object header is processed.\n+    \/\/ An object overflows the previous destination region, so this\n+    \/\/ destination region should copy the remainder of the object or as much as\n+    \/\/ will fit.\n@@ -2202,1 +2254,4 @@\n-      if (bitmap->is_marked(obj_start)) {\n+      if (obj_start != closure.source()) {\n+        assert(bitmap->is_marked(obj_start), \"inv\");\n+        \/\/ Found the actual obj-start, try to find the obj-end using either\n+        \/\/ size() if this obj is completely contained in the current region.\n@@ -2207,0 +2262,2 @@\n+        \/\/ This obj extends to next region iff partial_obj_addr of the *next*\n+        \/\/ region is the same as obj-start.\n@@ -2223,2 +2280,1 @@\n-      decrement_destination_counts(cm, src_space_id, src_region_idx,\n-                                   closure.source());\n+      decrement_destination_counts(cm, src_space_id, src_region_idx, closure.source());\n@@ -2229,0 +2285,1 @@\n+    \/\/ Finished copying without using up the current destination-region\n@@ -2231,0 +2288,1 @@\n+      assert(sd.region_align_up(old_src_addr) == end_addr, \"only one region\");\n@@ -2236,2 +2294,1 @@\n-      src_region_idx = next_src_region(closure, src_space_id, src_space_top,\n-                                       end_addr);\n+      src_region_idx = next_src_region(closure, src_space_id, src_space_top, end_addr);\n@@ -2241,0 +2298,1 @@\n+  \/\/ Handle the rest obj-by-obj, where we know obj-start.\n@@ -2245,1 +2303,2 @@\n-    HeapWord* partial_obj_start = (end_addr == src_space_top)\n+    \/\/ To handle the case where the final obj in source region extends to next region.\n+    HeapWord* final_obj_start = (end_addr == src_space_top)\n@@ -2248,1 +2307,1 @@\n-    \/\/ apply closure on objs inside [cur_addr, end_addr)\n+    \/\/ Apply closure on objs inside [cur_addr, end_addr)\n@@ -2255,1 +2314,1 @@\n-      if (partial_obj_start == cur_addr) {\n+      if (final_obj_start == cur_addr) {\n@@ -2266,2 +2325,1 @@\n-      decrement_destination_counts(cm, src_space_id, src_region_idx,\n-                                   closure.source());\n+      decrement_destination_counts(cm, src_space_id, src_region_idx, closure.source());\n@@ -2276,2 +2334,1 @@\n-    src_region_idx = next_src_region(closure, src_space_id, src_space_top,\n-                                     end_addr);\n+    src_region_idx = next_src_region(closure, src_space_id, src_space_top, end_addr);\n@@ -2399,2 +2456,2 @@\n-    assert(cast_to_oop(source())->is_forwarded(), \"inv\");\n-    assert(cast_to_oop(source())->forwardee() == cast_to_oop(destination()), \"inv\");\n+    assert(FullGCForwarding::is_forwarded(cast_to_oop(source())), \"inv\");\n+    assert(FullGCForwarding::forwardee(cast_to_oop(source())) == cast_to_oop(destination()), \"inv\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":393,"deletions":336,"binary":false,"changes":729,"status":"modified"},{"patch":"@@ -325,1 +325,0 @@\n-  assert(old_obj->is_objArray(), \"precondition\");\n@@ -361,1 +360,1 @@\n-  if (obj->forward_to_atomic(obj, obj_mark) == nullptr) {\n+  if (obj->forward_to_self_atomic(obj_mark) == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,2 +163,2 @@\n-                                 access.addr().type(), mo, requires_atomic_access, unaligned,\n-                                 mismatched, unsafe, access.barrier_data());\n+                                 mo, requires_atomic_access, unaligned, mismatched,\n+                                 unsafe, access.barrier_data());\n@@ -224,1 +224,1 @@\n-      load = kit->make_load(control, adr, val_type, access.type(), adr_type, mo,\n+      load = kit->make_load(control, adr, val_type, access.type(), mo,\n@@ -717,1 +717,1 @@\n-  \/\/ 8  - 32-bit VM\n+  \/\/ 8  - 32-bit VM or 64-bit VM, compact headers\n@@ -722,0 +722,1 @@\n+    assert(!UseCompactObjectHeaders, \"\");\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-    C2AccessValue(node, reinterpret_cast<const Type*>(type)) {}\n+    C2AccessValue(node, type) {}\n@@ -97,1 +97,1 @@\n-  const TypePtr* type() const { return reinterpret_cast<const TypePtr*>(_type); }\n+  const TypePtr* type() const { return _type->is_ptr(); }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-  static constexpr size_t min_dummy_object_size() {\n+  static size_t min_dummy_object_size() {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -364,1 +364,3 @@\n-  oopDesc::set_klass_gap(mem, 0);\n+  if (oopDesc::has_klass_gap()) {\n+    oopDesc::set_klass_gap(mem, 0);\n+  }\n@@ -370,1 +372,0 @@\n-  oopDesc::set_mark(mem, Klass::default_prototype_header(_klass));\n@@ -374,1 +375,10 @@\n-  oopDesc::release_set_klass(mem, _klass);\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, Klass::default_prototype_header(_klass));\n+  } else {\n+    if (EnableValhalla) {\n+      oopDesc::set_mark(mem, Klass::default_prototype_header(_klass));\n+    } else {\n+      oopDesc::set_mark(mem, markWord::prototype());\n+    }\n+    oopDesc::release_set_klass(mem, _klass);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -448,1 +448,1 @@\n-        assert(!UseCompressedClassPointers, \"should only happen without compressed class pointers\");\n+        assert(!UseCompressedClassPointers || UseCompactObjectHeaders, \"should only happen without compressed class pointers\");\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,2 +67,10 @@\n-  arrayOopDesc::set_mark(mem, Klass::default_prototype_header(_klass).set_marked());\n-  arrayOopDesc::release_set_klass(mem, _klass);\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header().set_marked());\n+  } else {\n+    if (EnableValhalla) {\n+      arrayOopDesc::set_mark(mem, Klass::default_prototype_header(_klass).set_marked());\n+    } else {\n+      arrayOopDesc::set_mark(mem, markWord::prototype().set_marked());\n+    }\n+    arrayOopDesc::release_set_klass(mem, _klass);\n+  }\n@@ -156,1 +164,5 @@\n-  oopDesc::release_set_mark(mem, Klass::default_prototype_header(_klass));\n+  if (UseCompactObjectHeaders || EnableValhalla) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header());\n+  } else {\n+    oopDesc::release_set_mark(mem, markWord::prototype());\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -425,1 +425,1 @@\n- * Find a class from a boot class loader. Returns nullptr if class not found.\n+ * Find a class from a boot class loader. Returns null if class not found.\n@@ -735,7 +735,0 @@\n-\/*\n- * java.security.*\n- *\/\n-\n-JNIEXPORT jobject JNICALL\n-JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls);\n-\n@@ -753,3 +746,0 @@\n-JNIEXPORT jobject JNICALL\n-JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls);\n-\n@@ -1172,0 +1162,6 @@\n+JNIEXPORT void JNICALL\n+JVM_VirtualThreadPinnedEvent(JNIEnv* env, jclass clazz, jstring op);\n+\n+JNIEXPORT jobject JNICALL\n+JVM_TakeVirtualThreadListToUnblock(JNIEnv* env, jclass ignored);\n+\n@@ -1184,0 +1180,7 @@\n+#define JNI_ONLOAD_SYMBOLS   {\"JNI_OnLoad\"}\n+#define JNI_ONUNLOAD_SYMBOLS {\"JNI_OnUnload\"}\n+#define JVM_ONLOAD_SYMBOLS      {\"JVM_OnLoad\"}\n+#define AGENT_ONLOAD_SYMBOLS    {\"Agent_OnLoad\"}\n+#define AGENT_ONUNLOAD_SYMBOLS  {\"Agent_OnUnload\"}\n+#define AGENT_ONATTACH_SYMBOLS  {\"Agent_OnAttach\"}\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -904,1 +904,1 @@\n-  current->last_frame().interpreter_frame_verify_monitor(elem);\n+  if (!current->preempting()) current->last_frame().interpreter_frame_verify_monitor(elem);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -237,0 +237,1 @@\n+  int         _num_oops;\n@@ -239,0 +240,1 @@\n+    _num_oops++;\n@@ -256,0 +258,1 @@\n+    _num_oops = 0;\n@@ -264,0 +267,2 @@\n+\n+  int num_oops() { return _num_oops; }\n@@ -322,0 +327,1 @@\n+  _num_oops = mf.num_oops();\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1385,1 +1385,2 @@\n-    method_data->initialize();\n+    CompilerThreadCanCallJava canCallJava(THREAD, true);\n+    method_data->reinitialize();\n@@ -2580,2 +2581,0 @@\n-      os::print_jni_name_prefix_on(&st, args_size);\n-      os::print_jni_name_suffix_on(&st, args_size);\n@@ -2591,1 +2590,0 @@\n-        os::print_jni_name_prefix_on(&st, args_size);\n@@ -2594,1 +2592,0 @@\n-        os::print_jni_name_suffix_on(&st, args_size);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+  static_field(CompilerToVM::Data,             oopDesc_klass_offset_in_bytes,          int)                                          \\\n+  static_field(CompilerToVM::Data,             arrayOopDesc_length_offset_in_bytes,    int)                                          \\\n+                                                                                                                                     \\\n@@ -227,0 +230,1 @@\n+  nonstatic_field(JavaThread,                  _lock_id,                                      int64_t)                               \\\n@@ -278,0 +282,1 @@\n+  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -326,1 +331,1 @@\n-  unchecked_nonstatic_field(ObjectMonitor,     _owner,                                        sizeof(void *)) \/* NOTE: no type *\/    \\\n+  volatile_nonstatic_field(ObjectMonitor,      _owner,                                        int64_t)                               \\\n@@ -330,1 +335,2 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _succ,                                         JavaThread*)                           \\\n+  volatile_nonstatic_field(ObjectMonitor,      _succ,                                         int64_t)                               \\\n+  volatile_nonstatic_field(ObjectMonitor,      _stack_locker,                                 BasicLock*)                            \\\n@@ -483,1 +489,0 @@\n-  declare_constant(LogKlassAlignmentInBytes)                              \\\n@@ -782,0 +787,1 @@\n+  declare_constant(ObjectMonitor::NO_OWNER)                               \\\n@@ -783,0 +789,1 @@\n+  declare_constant(ObjectMonitor::DEFLATER_MARKER)                        \\\n@@ -802,0 +809,1 @@\n+  declare_constant(markWord::klass_shift)                                 \\\n@@ -811,0 +819,1 @@\n+  declare_constant(markWord::marked_value)                                \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -402,2 +402,7 @@\n-  assert(oopDesc::klass_offset_in_bytes() < static_cast<intptr_t>(os::vm_page_size()),\n-         \"Klass offset is expected to be less than the page size\");\n+  if (UseCompactObjectHeaders) {\n+    assert(oopDesc::mark_offset_in_bytes() < static_cast<intptr_t>(os::vm_page_size()),\n+           \"Mark offset is expected to be less than the page size\");\n+  } else {\n+    assert(oopDesc::klass_offset_in_bytes() < static_cast<intptr_t>(os::vm_page_size()),\n+           \"Klass offset is expected to be less than the page size\");\n+  }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -86,2 +86,3 @@\n-  \/\/ declared nonstatic fields in arrayOopDesc if not compressed, otherwise\n-  \/\/ it occupies the second half of the _klass field in oopDesc.\n+  \/\/ mark-word when using compact headers (+UseCompactObjectHeaders), otherwise\n+  \/\/ after the compressed Klass* when running with compressed class-pointers\n+  \/\/ (+UseCompressedClassPointers), or else after the full Klass*.\n@@ -89,2 +90,1 @@\n-    return UseCompressedClassPointers ? klass_gap_offset_in_bytes() :\n-                               (int)sizeof(arrayOopDesc);\n+    return oopDesc::base_offset_in_bytes();\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -481,1 +481,1 @@\n-    \/\/ has cleared the resolved_klasses()->at(...) pointer to NULL. Thus, we\n+    \/\/ has cleared the resolved_klasses()->at(...) pointer to null. Thus, we\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-  const bool use_class_space = !parser.is_interface() && !parser.is_abstract();\n+  const bool use_class_space = parser.klass_needs_narrow_id();\n@@ -501,0 +501,5 @@\n+  if (ik != nullptr && UseCompressedClassPointers && use_class_space) {\n+    assert(CompressedKlassPointers::is_encodable(ik),\n+           \"Klass \" PTR_FORMAT \"needs a narrow Klass ID, but is not encodable\", p2i(ik));\n+  }\n+\n@@ -1841,0 +1846,1 @@\n+    ThreadInClassInitializer ticl(THREAD, this); \/\/ Track class being initialized\n@@ -2899,2 +2905,7 @@\n-    vtable().initialize_vtable();\n-    itable().initialize_itable();\n+    if (verified_at_dump_time()) {\n+      \/\/ Initialize vtable and itable for classes which can be verified at dump time.\n+      \/\/ Unlinked classes such as old classes with major version < 50 cannot be verified\n+      \/\/ at dump time.\n+      vtable().initialize_vtable();\n+      itable().initialize_itable();\n+    }\n@@ -2902,1 +2913,1 @@\n-#endif\n+#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n@@ -277,0 +278,17 @@\n+static markWord make_prototype(const Klass* kls) {\n+  markWord prototype = markWord::prototype();\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    \/\/ With compact object headers, the narrow Klass ID is part of the mark word.\n+    \/\/ We therfore seed the mark word with the narrow Klass ID.\n+    \/\/ Note that only those Klass that can be instantiated have a narrow Klass ID.\n+    \/\/ For those who don't, we leave the klass bits empty and assert if someone\n+    \/\/ tries to use those.\n+    const narrowKlass nk = CompressedKlassPointers::is_encodable(kls) ?\n+        CompressedKlassPointers::encode(const_cast<Klass*>(kls)) : 0;\n+    prototype = prototype.set_narrow_klass(nk);\n+  }\n+#endif\n+  return prototype;\n+}\n+\n@@ -286,1 +304,1 @@\n-                               _prototype_header(markWord::prototype()),\n+                               _prototype_header(make_prototype(this)),\n@@ -1013,1 +1031,8 @@\n-  assert(Metaspace::contains((address)this), \"Should be\");\n+#ifdef ASSERT\n+  if (UseCompressedClassPointers && needs_narrow_id()) {\n+    \/\/ Stricter checks for both correct alignment and placement\n+    CompressedKlassPointers::check_encodable(this);\n+  } else {\n+    assert(Metaspace::contains((address)this), \"Should be\");\n+  }\n+#endif \/\/ ASSERT\n@@ -1041,0 +1066,2 @@\n+\/\/ Note: this function is called with an address that may or may not be a Klass.\n+\/\/ The point is not to assert it is but to check if it could be.\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -170,0 +170,2 @@\n+  markWord _prototype_header;   \/\/ Used to initialize objects' header\n+\n@@ -180,1 +182,0 @@\n-  markWord _prototype_header;  \/\/ inline type and inline array mark patterns\n@@ -605,0 +606,2 @@\n+  inline void keep_alive() const;\n+\n@@ -734,8 +737,1 @@\n-  \/\/ inline types and inline type array patterns\n-  markWord prototype_header() const {\n-    return _prototype_header;\n-  }\n-  static inline markWord default_prototype_header(Klass* k) {\n-    return (k == nullptr) ? markWord::prototype() : k->prototype_header();\n-  }\n-\n+  inline markWord prototype_header() const;\n@@ -744,0 +740,1 @@\n+  static inline markWord default_prototype_header(Klass* k);\n@@ -799,0 +796,4 @@\n+\n+  \/\/ Returns true if this Klass needs to be addressable via narrow Klass ID.\n+  inline bool needs_narrow_id() const;\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,0 +40,7 @@\n+inline void Klass::keep_alive() const {\n+  \/\/ Resolving the holder (a WeakHandle) will keep the klass alive until the next safepoint.\n+  \/\/ Making the klass's CLD handle oops (e.g. the java_mirror), safe to store in the object\n+  \/\/ graph and its roots (e.g. Handles).\n+  static_cast<void>(klass_holder());\n+}\n+\n@@ -56,3 +63,5 @@\n-  assert(!is_inline_klass() || header.is_inline_type(), \"Unexpected prototype\");\n-  assert(_prototype_header.value() == 0 || _prototype_header == markWord::prototype(),\n-         \"Prototype already set\");\n+#ifdef ASSERT\n+  if (EnableValhalla && !UseCompactObjectHeaders) {\n+    assert(!is_inline_klass() || header.is_inline_type(), \"Unexpected prototype\");\n+    assert(_prototype_header.value() == 0 || _prototype_header == markWord::prototype(),\n+           \"Prototype already set\");\n@@ -70,0 +79,2 @@\n+  }\n+#endif \/\/ ASSERT\n@@ -73,0 +84,15 @@\n+inline markWord Klass::prototype_header() const {\n+  \/\/ You only need prototypes for allocating objects. If the class is not instantiable, it won't live in\n+  \/\/ class space and have no narrow Klass ID. But in that case we should not need the prototype.\n+  assert(!UseCompactObjectHeaders || _prototype_header.narrow_klass() > 0, \"Klass \" PTR_FORMAT \": invalid prototype (\" PTR_FORMAT \")\",\n+         p2i(this), _prototype_header.value());\n+  return _prototype_header;\n+}\n+\n+\/\/ May no longer be required (was used to avoid a bootstrapping problem...\n+inline markWord Klass::default_prototype_header(Klass* k) {\n+  return (k == nullptr) ? markWord::prototype() : k->prototype_header();\n+}\n+\n+\n+\/\/ Loading the java_mirror does not keep its holder alive. See Klass::keep_alive().\n@@ -165,0 +191,9 @@\n+\/\/ Returns true if this Klass needs to be addressable via narrow Klass ID.\n+inline bool Klass::needs_narrow_id() const {\n+  \/\/ Classes that are never instantiated need no narrow Klass Id, since the\n+  \/\/ only point of having a narrow id is to put it into an object header. Keeping\n+  \/\/ never instantiated classes out of class space lessens the class space pressure.\n+  \/\/ For more details, see JDK-8338526.\n+  \/\/ Note: don't call this function before access flags are initialized.\n+  return !is_abstract() && !is_interface();\n+}\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -32,0 +32,6 @@\n+#ifdef _LP64\n+STATIC_ASSERT(markWord::klass_shift + markWord::klass_bits == 64);\n+\/\/ The hash (preceding klass bits) shall be a direct neighbor but not interleave\n+STATIC_ASSERT(markWord::klass_shift == markWord::hash_bits + markWord::hash_shift);\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n@@ -42,1 +43,1 @@\n-\/\/             hash:25 ------------>| age:4  unused_gap:1  lock:2 (normal object)\n+\/\/             hash:25 ------------>| age:4  self-fwd:1  lock:2 (normal object)\n@@ -46,1 +47,5 @@\n-\/\/  unused:25 hash:31 -->| unused_gap:1  age:4  unused_gap:1  lock:2 (normal object)\n+\/\/  unused:22 hash:31 -->| unused_gap:4  age:4  self-fwd:1  lock:2 (normal object)\n+\/\/\n+\/\/  64 bits (with compact headers):\n+\/\/  -------------------------------\n+\/\/  klass:22  hash:31 -->| unused_gap:4  age:4  self-fwd:1  lock:2 (normal object)\n@@ -112,0 +117,1 @@\n+\/\/  klass:22  hash:31 -->| larval:1 age:4 flat_array:1 null_free_array:1 inline_type:1 self-fwd:1 lock:2 (normal object)\n@@ -120,0 +126,6 @@\n+\/\/  Note the position of 'self-fwd' is not by accident. When forwarding an\n+\/\/  object to a new heap position, HeapWord alignment guarantees the lower\n+\/\/  bits, including 'self-fwd' are 0. \"is_self_forwarded()\" will be correctly\n+\/\/  set to false. Otherwise encode_pointer_as_mark() may have 'self-fwd' set.\n+\/\/\n+\/\/\n@@ -173,1 +185,1 @@\n-  static const int first_unused_gap_bits          = 1; \/\/ When !EnableValhalla\n+  static const int self_fwd_bits                  = 1;\n@@ -181,1 +193,1 @@\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - inline_type_bits - larval_bits - flat_array_bits - null_free_array_bits;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - inline_type_bits - larval_bits - flat_array_bits - null_free_array_bits - self_fwd_bits;\n@@ -183,1 +195,0 @@\n-  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0); \/\/ !EnableValhalla: unused\n@@ -186,1 +197,2 @@\n-  static const int inline_type_shift              = lock_bits;\n+  static const int self_fwd_shift                 = lock_bits ;\n+  static const int inline_type_shift              = self_fwd_shift + self_fwd_bits;\n@@ -190,1 +202,0 @@\n-  static const int unused_gap_shift               = age_shift + age_bits; \/\/ !EnableValhalla: unused\n@@ -192,1 +203,1 @@\n-  static const int hash_shift                     = LP64_ONLY(32) NOT_LP64(larval_shift + larval_bits);\n+  static const int hash_shift                     = larval_shift + larval_bits;\n@@ -196,2 +207,2 @@\n-  static const uintptr_t inline_type_mask         = right_n_bits(lock_bits + inline_type_bits);\n-  static const uintptr_t inline_type_mask_in_place = inline_type_mask << lock_shift;\n+  static const uintptr_t self_fwd_mask            = right_n_bits(self_fwd_bits);\n+  static const uintptr_t self_fwd_mask_in_place   = self_fwd_mask << self_fwd_shift;\n@@ -199,0 +210,2 @@\n+  static const uintptr_t inline_type_mask         = inline_type_bit_in_place + lock_mask;\n+  static const uintptr_t inline_type_mask_in_place = inline_type_mask << lock_shift;\n@@ -205,1 +218,0 @@\n-\n@@ -216,0 +228,12 @@\n+#ifdef _LP64\n+  \/\/ Used only with compact headers:\n+  \/\/ We store the (narrow) Klass* in the bits 43 to 64.\n+\n+  \/\/ These are for bit-precise extraction of the narrow Klass* from the 64-bit Markword\n+  static constexpr int klass_shift                = hash_shift + hash_bits;\n+  static constexpr int klass_bits                 = 22;\n+  static constexpr uintptr_t klass_mask           = right_n_bits(klass_bits);\n+  static constexpr uintptr_t klass_mask_in_place  = klass_mask << klass_shift;\n+#endif\n+\n+\n@@ -263,2 +287,3 @@\n-  bool is_forwarded()   const {\n-    return (mask_bits(value(), lock_mask_in_place) == marked_value);\n+  bool is_forwarded() const {\n+    \/\/ Returns true for normal forwarded (0b011) and self-forwarded (0b1xx).\n+    return mask_bits(value(), lock_mask_in_place | self_fwd_mask_in_place) >= static_cast<intptr_t>(marked_value);\n@@ -407,0 +432,6 @@\n+  inline Klass* klass() const;\n+  inline Klass* klass_or_null() const;\n+  inline Klass* klass_without_asserts() const;\n+  inline narrowKlass narrow_klass() const;\n+  inline markWord set_narrow_klass(narrowKlass narrow_klass) const;\n+\n@@ -436,0 +467,15 @@\n+  inline bool is_self_forwarded() const {\n+    NOT_LP64(assert(LockingMode != LM_LEGACY, \"incorrect with LM_LEGACY on 32 bit\");)\n+    return mask_bits(value(), self_fwd_mask_in_place) != 0;\n+  }\n+\n+  inline markWord set_self_forwarded() const {\n+    NOT_LP64(assert(LockingMode != LM_LEGACY, \"incorrect with LM_LEGACY on 32 bit\");)\n+    return markWord(value() | self_fwd_mask_in_place);\n+  }\n+\n+  inline markWord unset_self_forwarded() const {\n+    NOT_LP64(assert(LockingMode != LM_LEGACY, \"incorrect with LM_LEGACY on 32 bit\");)\n+    return markWord(value() & ~self_fwd_mask_in_place);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":59,"deletions":13,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -904,0 +904,5 @@\n+bool Method::is_object_wait0() const {\n+  return klass_name() == vmSymbols::java_lang_Object()\n+         && name() == vmSymbols::wait_name();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -600,0 +600,3 @@\n+  \/\/ returns true if the method name is wait0\n+  bool is_object_wait0() const;\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,3 +62,8 @@\n-  _header._bits = (intptr_t)0;\n-  _header._struct._tag = tag;\n-  _header._struct._bci = bci;\n+  DataLayout temp;\n+  temp._header._bits = (intptr_t)0;\n+  temp._header._struct._tag = tag;\n+  temp._header._struct._bci = bci;\n+  \/\/ Write the header using a single intptr_t write.  This ensures that if the layout is\n+  \/\/ reinitialized readers will never see the transient state where the header is 0.\n+  _header = temp._header;\n+\n@@ -1294,0 +1299,22 @@\n+\/\/ Reinitialize the storage of an existing MDO at a safepoint.  Doing it this way will ensure it's\n+\/\/ not being accessed while the contents are being rewritten.\n+class VM_ReinitializeMDO: public VM_Operation {\n+ private:\n+  MethodData* _mdo;\n+ public:\n+  VM_ReinitializeMDO(MethodData* mdo): _mdo(mdo) {}\n+  VMOp_Type type() const                         { return VMOp_ReinitializeMDO; }\n+  void doit() {\n+    \/\/ The extra data is being zero'd, we'd like to acquire the extra_data_lock but it can't be held\n+    \/\/ over a safepoint.  This means that we don't actually need to acquire the lock.\n+    _mdo->initialize();\n+  }\n+  bool allow_nested_vm_operations() const        { return true; }\n+};\n+\n+void MethodData::reinitialize() {\n+  VM_ReinitializeMDO op(this);\n+  VMThread::execute(&op);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2184,0 +2184,1 @@\n+  friend class VM_ReinitializeMDO;\n@@ -2200,0 +2201,3 @@\n+\n+  void initialize();\n+\n@@ -2204,1 +2208,5 @@\n-  void initialize();\n+\n+  \/\/ Safely reinitialize the data in the MDO.  This is intended as a testing facility as the\n+  \/\/ reinitialization is performed at a safepoint so it's isn't cheap and it doesn't ensure that all\n+  \/\/ readers will see consistent profile data.\n+  void reinitialize();\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -150,1 +150,4 @@\n-  assert(obj->is_objArray(), \"must be object array\");\n+  \/\/ In this assert, we cannot safely access the Klass* with compact headers,\n+  \/\/ because size_given_klass() calls oop_size() on objects that might be\n+  \/\/ concurrently forwarded, which would overwrite the Klass*.\n+  assert(UseCompactObjectHeaders || obj->is_objArray(), \"must be object array\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,2 +158,1 @@\n-  \/\/ Only has a klass gap when compressed class pointers are used.\n-  return UseCompressedClassPointers;\n+  return UseCompressedClassPointers && !UseCompactObjectHeaders;\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,2 @@\n+  inline oop cas_set_forwardee(markWord new_mark, markWord old_mark, atomic_memory_order order);\n+\n@@ -91,0 +93,3 @@\n+  \/\/ Returns the prototype mark that should be used for this object.\n+  inline markWord prototype_mark() const;\n+\n@@ -108,2 +113,8 @@\n-  \/\/ size of object header, aligned to platform wordSize\n-  static constexpr int header_size() { return sizeof(oopDesc)\/HeapWordSize; }\n+  \/\/ Size of object header, aligned to platform wordSize\n+  static int header_size() {\n+    if (UseCompactObjectHeaders) {\n+      return sizeof(markWord) \/ HeapWordSize;\n+    } else {\n+      return sizeof(oopDesc)  \/ HeapWordSize;\n+    }\n+  }\n@@ -276,0 +287,1 @@\n+  inline bool is_self_forwarded() const;\n@@ -278,0 +290,1 @@\n+  inline void forward_to_self();\n@@ -284,0 +297,1 @@\n+  inline oop forward_to_self_atomic(markWord compare, atomic_memory_order order = memory_order_conservative);\n@@ -286,0 +300,3 @@\n+  inline oop forwardee(markWord header) const;\n+\n+  inline void unset_self_forwarded();\n@@ -329,1 +346,16 @@\n-  static int klass_offset_in_bytes()     { return (int)offset_of(oopDesc, _metadata._klass); }\n+  static int klass_offset_in_bytes()     {\n+#ifdef _LP64\n+    if (UseCompactObjectHeaders) {\n+      \/\/ NOTE: The only places where this is used with compact headers are the C2\n+      \/\/ compiler and JVMCI, and even there we don't use it to access the (narrow)Klass*\n+      \/\/ directly. It is used only as a placeholder to identify the special memory slice\n+      \/\/ containing Klass* info. This value could be any value that is not a valid\n+      \/\/ field offset. Use an offset halfway into the markWord, as the markWord is never\n+      \/\/ partially loaded from C2 and JVMCI.\n+      return mark_offset_in_bytes() + 4;\n+    } else\n+#endif\n+    {\n+      return (int)offset_of(oopDesc, _metadata._klass);\n+    }\n+  }\n@@ -335,0 +367,12 @@\n+  static int base_offset_in_bytes() {\n+    if (UseCompactObjectHeaders) {\n+      \/\/ With compact headers, the Klass* field is not used for the Klass*\n+      \/\/ and is used for the object fields instead.\n+      return sizeof(markWord);\n+    } else if (UseCompressedClassPointers) {\n+      return sizeof(markWord) + sizeof(narrowKlass);\n+    } else {\n+      return sizeof(markWord) + sizeof(Klass*);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"oops\/markWord.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -85,0 +85,8 @@\n+markWord oopDesc::prototype_mark() const {\n+  if (UseCompactObjectHeaders || EnableValhalla) {\n+    return klass()->prototype_header();\n+  } else {\n+    return markWord::prototype();\n+  }\n+}\n+\n@@ -86,1 +94,1 @@\n-  set_mark(Klass::default_prototype_header(klass()));\n+  set_mark(prototype_mark());\n@@ -90,2 +98,4 @@\n-  if (UseCompressedClassPointers) {\n-    return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);\n+  if (UseCompactObjectHeaders) {\n+    return mark().klass();\n+  } else if (UseCompressedClassPointers) {\n+     return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);\n@@ -98,1 +108,3 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    return mark().klass_or_null();\n+  } else if (UseCompressedClassPointers) {\n@@ -106,3 +118,5 @@\n-  if (UseCompressedClassPointers) {\n-    narrowKlass nklass = Atomic::load_acquire(&_metadata._compressed_klass);\n-    return CompressedKlassPointers::decode(nklass);\n+  if (UseCompactObjectHeaders) {\n+    return mark_acquire().klass();\n+  } else if (UseCompressedClassPointers) {\n+    narrowKlass narrow_klass = Atomic::load_acquire(&_metadata._compressed_klass);\n+    return CompressedKlassPointers::decode(narrow_klass);\n@@ -115,1 +129,3 @@\n-  if (UseCompressedClassPointers) {\n+  if (UseCompactObjectHeaders) {\n+    return mark().klass_without_asserts();\n+  } else if (UseCompressedClassPointers) {\n@@ -124,0 +140,1 @@\n+  assert(!UseCompactObjectHeaders, \"don't set Klass* with compact headers\");\n@@ -133,0 +150,1 @@\n+  assert(!UseCompactObjectHeaders, \"don't set Klass* with compact headers\");\n@@ -143,3 +161,2 @@\n-  if (UseCompressedClassPointers) {\n-    *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;\n-  }\n+  assert(has_klass_gap(), \"precondition\");\n+  *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;\n@@ -285,0 +302,4 @@\n+bool oopDesc::is_self_forwarded() const {\n+  return mark().is_self_forwarded();\n+}\n+\n@@ -287,0 +308,2 @@\n+  assert(cast_from_oop<oopDesc*>(p) != this,\n+         \"must not be used for self-forwarding, use forward_to_self() instead\");\n@@ -292,4 +315,6 @@\n-oop oopDesc::forward_to_atomic(oop p, markWord compare, atomic_memory_order order) {\n-  markWord m = markWord::encode_pointer_as_mark(p);\n-  assert(m.decode_pointer() == p, \"encoding must be reversible\");\n-  markWord old_mark = cas_set_mark(m, compare, order);\n+void oopDesc::forward_to_self() {\n+  set_mark(mark().set_self_forwarded());\n+}\n+\n+oop oopDesc::cas_set_forwardee(markWord new_mark, markWord compare, atomic_memory_order order) {\n+  markWord old_mark = cas_set_mark(new_mark, compare, order);\n@@ -299,1 +324,25 @@\n-    return cast_to_oop(old_mark.decode_pointer());\n+    assert(old_mark.is_forwarded(), \"must be forwarded here\");\n+    return forwardee(old_mark);\n+  }\n+}\n+\n+oop oopDesc::forward_to_atomic(oop p, markWord compare, atomic_memory_order order) {\n+  assert(cast_from_oop<oopDesc*>(p) != this,\n+         \"must not be used for self-forwarding, use forward_to_self_atomic() instead\");\n+  markWord m = markWord::encode_pointer_as_mark(p);\n+  assert(forwardee(m) == p, \"encoding must be reversible\");\n+  return cas_set_forwardee(m, compare, order);\n+}\n+\n+oop oopDesc::forward_to_self_atomic(markWord old_mark, atomic_memory_order order) {\n+  markWord new_mark = old_mark.set_self_forwarded();\n+  assert(forwardee(new_mark) == cast_to_oop(this), \"encoding must be reversible\");\n+  return cas_set_forwardee(new_mark, old_mark, order);\n+}\n+\n+oop oopDesc::forwardee(markWord mark) const {\n+  assert(mark.is_forwarded(), \"only decode when actually forwarded\");\n+  if (mark.is_self_forwarded()) {\n+    return cast_to_oop(this);\n+  } else {\n+    return mark.forwardee();\n@@ -307,1 +356,5 @@\n-  return mark().forwardee();\n+  return forwardee(mark());\n+}\n+\n+void oopDesc::unset_self_forwarded() {\n+  set_mark(mark().unset_self_forwarded());\n@@ -364,0 +417,1 @@\n+  \/\/ In this assert, we cannot safely access the Klass* with compact headers.\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":72,"deletions":18,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,1 +173,2 @@\n-  assert(obj->is_typeArray(),\"must be a type array\");\n+  \/\/ In this assert, we cannot safely access the Klass* with compact headers.\n+  assert(UseCompactObjectHeaders || obj->is_typeArray(),\"must be a type array\");\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1561,1 +1561,1 @@\n-  return TypeLong::make(MIN2(r0->_lo, r1->_lo), MIN2(r0->_hi, r1->_hi), MIN2(r0->_widen, r1->_widen));\n+  return TypeLong::make(MIN2(r0->_lo, r1->_lo), MIN2(r0->_hi, r1->_hi), MAX2(r0->_widen, r1->_widen));\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -231,0 +231,4 @@\n+    assert(phase->C->get_alias_index(adr_type) == phase->C->get_alias_index(phase->type(next_src)->isa_ptr()),\n+      \"slice of address and input slice don't match\");\n+    assert(phase->C->get_alias_index(adr_type) == phase->C->get_alias_index(phase->type(next_dest)->isa_ptr()),\n+      \"slice of address and input slice don't match\");\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -604,1 +604,1 @@\n-  Compile::TracePhase tp(\"bldOopMaps\", &timers[_t_buildOopMaps]);\n+  Compile::TracePhase tp(_t_buildOopMaps);\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-          range(5, 43)                                                      \\\n+          range(5, max_jint)                                                \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1832,1 +1832,1 @@\n-  if (EnableValhalla) {\n+  if (UseCompactObjectHeaders || EnableValhalla) {\n@@ -1836,0 +1836,6 @@\n+    if (EnableValhalla) {\n+        mark_node = phase->transform(mark_node);\n+        \/\/ Avoid returning a constant (old node) here because this method is used by LoadNode::Ideal\n+        mark_node = new OrXNode(mark_node, phase->MakeConX(_larval ? markWord::larval_bit_in_place : 0));\n+    }\n+    return mark_node;\n@@ -1837,1 +1843,1 @@\n-    mark_node = phase->MakeConX(markWord::prototype().value());\n+    return phase->MakeConX(markWord::prototype().value());\n@@ -1839,3 +1845,0 @@\n-  mark_node = phase->transform(mark_node);\n-  \/\/ Avoid returning a constant (old node) here because this method is used by LoadNode::Ideal\n-  return new OrXNode(mark_node, phase->MakeConX(_larval ? markWord::larval_bit_in_place : 0));\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-  NOT_PRODUCT(AssertionPredicateType _assertion_predicate_type;)\n+  AssertionPredicateType _assertion_predicate_type;\n@@ -439,1 +439,1 @@\n-  NOT_PRODUCT(IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);)\n+  IfNode(Node* control, Node* bol, float p, float fcnt, AssertionPredicateType assertion_predicate_type);\n@@ -463,1 +463,0 @@\n-#ifndef PRODUCT\n@@ -468,0 +467,1 @@\n+#ifndef PRODUCT\n@@ -483,1 +483,0 @@\n-#ifndef PRODUCT\n@@ -488,1 +487,0 @@\n-#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-  Compile::TracePhase tp(\"ctorChaitin\", &timers[_t_ctorChaitin]);\n+  Compile::TracePhase tp(_t_ctorChaitin);\n@@ -324,1 +324,1 @@\n-  Compile::TracePhase tp(\"chaitinCompact\", &timers[_t_chaitinCompact]);\n+  Compile::TracePhase tp(_t_chaitinCompact);\n@@ -400,1 +400,1 @@\n-    Compile::TracePhase tp(\"computeLive\", &timers[_t_computeLive]);\n+    Compile::TracePhase tp(_t_computeLive);\n@@ -417,1 +417,1 @@\n-    Compile::TracePhase tp(\"computeLive (sbplr)\", &timers[_t_computeLive]);\n+    Compile::TracePhase tp(\"computeLive (sbplr)\", _t_computeLive);\n@@ -442,1 +442,1 @@\n-    Compile::TracePhase tp(\"chaitinCoalesce1\", &timers[_t_chaitinCoalesce1]);\n+    Compile::TracePhase tp(_t_chaitinCoalesce1);\n@@ -457,1 +457,1 @@\n-    Compile::TracePhase tp(\"computeLive\", &timers[_t_computeLive]);\n+    Compile::TracePhase tp(_t_computeLive);\n@@ -498,1 +498,1 @@\n-      Compile::TracePhase tp(\"computeLive\", &timers[_t_computeLive]);\n+      Compile::TracePhase tp(_t_computeLive);\n@@ -512,1 +512,1 @@\n-      Compile::TracePhase tp(\"chaitinCoalesce2\", &timers[_t_chaitinCoalesce2]);\n+      Compile::TracePhase tp(_t_chaitinCoalesce2);\n@@ -571,1 +571,1 @@\n-      Compile::TracePhase tp(\"computeLive\", &timers[_t_computeLive]);\n+      Compile::TracePhase tp(_t_computeLive);\n@@ -589,1 +589,1 @@\n-      Compile::TracePhase tp(\"chaitinCoalesce3\", &timers[_t_chaitinCoalesce3]);\n+      Compile::TracePhase tp(_t_chaitinCoalesce3);\n@@ -1186,1 +1186,1 @@\n-  Compile::TracePhase tp(\"chaitinCacheLRG\", &timers[_t_chaitinCacheLRG]);\n+  Compile::TracePhase tp(_t_chaitinCacheLRG);\n@@ -1220,1 +1220,1 @@\n-  Compile::TracePhase tp(\"chaitinSimplify\", &timers[_t_chaitinSimplify]);\n+  Compile::TracePhase tp(_t_chaitinSimplify);\n@@ -1519,1 +1519,1 @@\n-  Compile::TracePhase tp(\"chaitinSelect\", &timers[_t_chaitinSelect]);\n+  Compile::TracePhase tp(_t_chaitinSelect);\n@@ -1707,1 +1707,1 @@\n-  Compile::TracePhase tp(\"fixupSpills\", &timers[_t_fixupSpills]);\n+  Compile::TracePhase tp(_t_fixupSpills);\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -764,1 +764,1 @@\n-    TracePhase tp(\"parse\", &timers[_t_parser]);\n+    TracePhase tp(_t_parser);\n@@ -1760,0 +1760,4 @@\n+      if (UseCompactObjectHeaders) {\n+        if (flat->offset() == in_bytes(Klass::prototype_header_offset()))\n+          alias_type(idx)->set_rewritable(false);\n+      }\n@@ -2498,1 +2502,1 @@\n-  TracePhase tp(\"incrementalInline_inline\", &timers[_t_incrInline_inline]);\n+  TracePhase tp(_t_incrInline_inline);\n@@ -2539,1 +2543,1 @@\n-    TracePhase tp(\"incrementalInline_pru\", &timers[_t_incrInline_pru]);\n+    TracePhase tp(_t_incrInline_pru);\n@@ -2544,1 +2548,1 @@\n-    TracePhase tp(\"incrementalInline_igvn\", &timers[_t_incrInline_igvn]);\n+    TracePhase tp(_t_incrInline_igvn);\n@@ -2554,1 +2558,1 @@\n-  TracePhase tp(\"incrementalInline\", &timers[_t_incrInline]);\n+  TracePhase tp(_t_incrInline);\n@@ -2562,1 +2566,1 @@\n-        TracePhase tp(\"incrementalInline_ideal\", &timers[_t_incrInline_ideal]);\n+        TracePhase tp(_t_incrInline_ideal);\n@@ -2650,1 +2654,1 @@\n-      TracePhase tp(\"idealLoop\", &timers[_t_idealLoop]);\n+      TracePhase tp(_t_idealLoop);\n@@ -2688,1 +2692,1 @@\n-  TracePhase tp(\"optimizer\", &timers[_t_optimizer]);\n+  TracePhase tp(_t_optimizer);\n@@ -2718,1 +2722,1 @@\n-    TracePhase tp(\"iterGVN\", &timers[_t_iterGVN]);\n+    TracePhase tp(_t_iterGVN);\n@@ -2767,1 +2771,1 @@\n-    TracePhase tp(\"\", &timers[_t_vector]);\n+    TracePhase tp(_t_vector);\n@@ -2776,1 +2780,1 @@\n-    Compile::TracePhase tp(\"\", &timers[_t_renumberLive]);\n+    Compile::TracePhase tp(_t_renumberLive);\n@@ -2802,1 +2806,1 @@\n-      TracePhase tp(\"idealLoop\", &timers[_t_idealLoop]);\n+      TracePhase tp(_t_idealLoop);\n@@ -2822,1 +2826,1 @@\n-        TracePhase tp(\"macroEliminate\", &timers[_t_macroEliminate]);\n+        TracePhase tp(_t_macroEliminate);\n@@ -2851,1 +2855,1 @@\n-      TracePhase tp(\"idealLoop\", &timers[_t_idealLoop]);\n+      TracePhase tp(_t_idealLoop);\n@@ -2859,1 +2863,1 @@\n-      TracePhase tp(\"idealLoop\", &timers[_t_idealLoop]);\n+      TracePhase tp(_t_idealLoop);\n@@ -2867,1 +2871,1 @@\n-      TracePhase tp(\"idealLoop\", &timers[_t_idealLoop]);\n+      TracePhase tp(_t_idealLoop);\n@@ -2884,1 +2888,1 @@\n-    TracePhase tp(\"ccp\", &timers[_t_ccp]);\n+    TracePhase tp(_t_ccp);\n@@ -2893,1 +2897,1 @@\n-    TracePhase tp(\"iterGVN2\", &timers[_t_iterGVN2]);\n+    TracePhase tp(_t_iterGVN2);\n@@ -2928,1 +2932,1 @@\n-    TracePhase tp(\"macroExpand\", &timers[_t_macroExpand]);\n+    TracePhase tp(_t_macroExpand);\n@@ -2943,1 +2947,1 @@\n-    TracePhase tp(\"barrierExpand\", &timers[_t_barrierExpand]);\n+    TracePhase tp(_t_barrierExpand);\n@@ -2973,1 +2977,1 @@\n-   TracePhase tp(\"graphReshape\", &timers[_t_graphReshaping]);\n+   TracePhase tp(_t_graphReshaping);\n@@ -3415,1 +3419,1 @@\n-    TracePhase tp(\"matcher\", &timers[_t_matcher]);\n+    TracePhase tp(_t_matcher);\n@@ -3440,1 +3444,1 @@\n-    TracePhase tp(\"scheduler\", &timers[_t_scheduler]);\n+    TracePhase tp(_t_scheduler);\n@@ -3454,1 +3458,1 @@\n-    TracePhase tp(\"regalloc\", &timers[_t_registerAllocation]);\n+    TracePhase tp(_t_registerAllocation);\n@@ -3473,1 +3477,1 @@\n-    TracePhase tp(\"blockOrdering\", &timers[_t_blockOrdering]);\n+    TracePhase tp(_t_blockOrdering);\n@@ -3488,1 +3492,1 @@\n-    TracePhase tp(\"peephole\", &timers[_t_peephole]);\n+    TracePhase tp(_t_peephole);\n@@ -3496,1 +3500,1 @@\n-    TracePhase tp(\"postalloc_expand\", &timers[_t_postalloc_expand]);\n+    TracePhase tp(_t_postalloc_expand);\n@@ -3503,1 +3507,1 @@\n-    TracePhase tp(\"output\", &timers[_t_output]);\n+    TracePhase tp(_t_output);\n@@ -4799,2 +4803,2 @@\n-Compile::TracePhase::TracePhase(const char* name, elapsedTimer* accumulator)\n-  : TraceTime(name, accumulator, CITime, CITimeVerbose),\n+Compile::TracePhase::TracePhase(const char* name, PhaseTraceId id)\n+  : TraceTime(name, &Phase::timers[id], CITime, CITimeVerbose),\n@@ -4803,1 +4807,0 @@\n-    _phase_name(name),\n@@ -4811,1 +4814,1 @@\n-    _log->begin_head(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, _compile->unique(), _compile->live_nodes());\n+    _log->begin_head(\"phase name='%s' nodes='%d' live='%d'\", phase_name(), _compile->unique(), _compile->live_nodes());\n@@ -4817,0 +4820,3 @@\n+Compile::TracePhase::TracePhase(PhaseTraceId id)\n+  : TracePhase(Phase::get_phase_trace_id_text(id), id) {}\n+\n@@ -4824,1 +4830,1 @@\n-                  _phase_name, _compile->unique(), _compile->live_nodes(), _compile->count_live_nodes_by_graph_walk());\n+                  phase_name(), _compile->unique(), _compile->live_nodes(), _compile->count_live_nodes_by_graph_walk());\n@@ -4833,1 +4839,1 @@\n-    _log->done(\"phase name='%s' nodes='%d' live='%d'\", _phase_name, _compile->unique(), _compile->live_nodes());\n+    _log->done(\"phase name='%s' nodes='%d' live='%d'\", phase_name(), _compile->unique(), _compile->live_nodes());\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":40,"deletions":34,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -244,1 +244,0 @@\n-    const char* _phase_name;\n@@ -247,1 +246,2 @@\n-    TracePhase(const char* name, elapsedTimer* accumulator);\n+    TracePhase(PhaseTraceId phaseTraceId);\n+    TracePhase(const char* name, PhaseTraceId phaseTraceId);\n@@ -249,0 +249,1 @@\n+    const char* phase_name() const { return title(); }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-  Compile::TracePhase tp(\"escapeAnalysis\", &Phase::timers[Phase::_t_escapeAnalysis]);\n+  Compile::TracePhase tp(Phase::_t_escapeAnalysis);\n@@ -153,1 +153,1 @@\n-  { Compile::TracePhase tp(\"connectionGraph\", &Phase::timers[Phase::_t_connectionGraph]);\n+  { Compile::TracePhase tp(Phase::_t_connectionGraph);\n@@ -659,1 +659,1 @@\n-\/\/ against the NULL constant, otherwise it will be against the constant input of\n+\/\/ against the null constant, otherwise it will be against the constant input of\n@@ -687,1 +687,1 @@\n-\/\/ against NULL.\n+\/\/ against null.\n@@ -821,1 +821,1 @@\n-\/\/ juse use a CmpP\/N against the NULL constant.\n+\/\/ juse use a CmpP\/N against the null constant.\n@@ -824,1 +824,1 @@\n-\/\/ splitted cast was not nullable (or if it was the NULL constant) then we don't\n+\/\/ splitted cast was not nullable (or if it was the null constant) then we don't\n@@ -852,1 +852,1 @@\n-\/\/                         Call  NULL\n+\/\/                         Call  Null\n@@ -888,1 +888,1 @@\n-  \/\/  - nullptr:    Meaning that the base is actually the NULL constant and therefore\n+  \/\/  - nullptr:    Meaning that the base is actually the null constant and therefore\n@@ -905,1 +905,1 @@\n-        \/\/ Nothing todo as bases_for_loads[i] is already nullptr\n+        \/\/ Nothing todo as bases_for_loads[i] is already null\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1684,1 +1684,1 @@\n-    Compile::TracePhase tp(\"computeLive\", &timers[_t_computeLive]);\n+    Compile::TracePhase tp(_t_computeLive);\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  store_to_memory(control(), adr_sp, last_sp, T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_sp, last_sp, T_ADDRESS, MemNode::unordered);\n@@ -224,1 +224,1 @@\n-  store_to_memory(control(), adr_sp, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_sp, null(), T_ADDRESS, MemNode::unordered);\n@@ -226,1 +226,1 @@\n-  store_to_memory(control(), adr_last_Java_pc, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_last_Java_pc, null(), T_ADDRESS, MemNode::unordered);\n@@ -229,1 +229,1 @@\n-  store_to_memory(control(), adr_last_Java_fp, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_last_Java_fp, null(), T_ADDRESS, MemNode::unordered);\n@@ -237,1 +237,1 @@\n-    Node* vm_result = make_load(nullptr, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);\n+    Node* vm_result = make_load(nullptr, adr, TypeOopPtr::BOTTOM, T_OBJECT, MemNode::unordered);\n@@ -240,1 +240,1 @@\n-    store_to_memory(control(), adr, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+    store_to_memory(control(), adr, null(), T_ADDRESS, MemNode::unordered);\n@@ -246,1 +246,1 @@\n-  Node* pending = make_load(nullptr, adr, TypeOopPtr::BOTTOM, T_OBJECT, NoAlias, MemNode::unordered);\n+  Node* pending = make_load(nullptr, adr, TypeOopPtr::BOTTOM, T_OBJECT, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -525,1 +525,1 @@\n-    Node* should_post_flag = make_load(control(), adr, TypeInt::INT, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+    Node* should_post_flag = make_load(control(), adr, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -1616,1 +1616,0 @@\n-                          int adr_idx,\n@@ -1624,2 +1623,1 @@\n-  \/\/ Fix 8344108 and renable the commented assert\n-  \/\/assert(adr_idx == C->get_alias_index(_gvn.type(adr)->isa_ptr()), \"slice of address and input slice don't match\");\n+  int adr_idx = C->get_alias_index(_gvn.type(adr)->isa_ptr());\n@@ -1648,1 +1646,0 @@\n-                                int adr_idx,\n@@ -1655,0 +1652,1 @@\n+  int adr_idx = C->get_alias_index(_gvn.type(adr)->isa_ptr());\n@@ -1656,2 +1654,0 @@\n-  \/\/ Fix 8344108 and renable the commented assert\n-  \/\/assert(adr_idx == C->get_alias_index(_gvn.type(adr)->isa_ptr()), \"slice of address and input slice don't match\");\n@@ -2223,2 +2219,1 @@\n-  int adr_type = Compile::AliasIdxRaw;\n-  Node* cnt  = make_load(ctrl, counter_addr, TypeLong::LONG, T_LONG, adr_type, MemNode::unordered);\n+  Node* cnt  = make_load(ctrl, counter_addr, TypeLong::LONG, T_LONG, MemNode::unordered);\n@@ -2227,1 +2222,1 @@\n-  store_to_memory(ctrl, counter_addr, incr, T_LONG, adr_type, MemNode::unordered);\n+  store_to_memory(ctrl, counter_addr, incr, T_LONG, MemNode::unordered);\n@@ -4729,2 +4724,2 @@\n-                             AndI(ch, intcon(0xff)), T_CHAR, TypeAryPtr::BYTES, MemNode::unordered,\n-                             false, false, true \/* mismatched *\/);\n+                             AndI(ch, intcon(0xff)), T_CHAR, MemNode::unordered, false,\n+                             false, true \/* mismatched *\/);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -554,20 +554,0 @@\n-                  MemNode::MemOrd mo, LoadNode::ControlDependency control_dependency = LoadNode::DependsOnlyOnTest,\n-                  bool require_atomic_access = false, bool unaligned = false,\n-                  bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0) {\n-    \/\/ This version computes alias_index from bottom_type\n-    return make_load(ctl, adr, t, bt, adr->bottom_type()->is_ptr(),\n-                     mo, control_dependency, require_atomic_access,\n-                     unaligned, mismatched, unsafe, barrier_data);\n-  }\n-  Node* make_load(Node* ctl, Node* adr, const Type* t, BasicType bt, const TypePtr* adr_type,\n-                  MemNode::MemOrd mo, LoadNode::ControlDependency control_dependency = LoadNode::DependsOnlyOnTest,\n-                  bool require_atomic_access = false, bool unaligned = false,\n-                  bool mismatched = false, bool unsafe = false, uint8_t barrier_data = 0) {\n-    \/\/ This version computes alias_index from an address type\n-    assert(adr_type != nullptr, \"use other make_load factory\");\n-    return make_load(ctl, adr, t, bt, C->get_alias_index(adr_type),\n-                     mo, control_dependency, require_atomic_access,\n-                     unaligned, mismatched, unsafe, barrier_data);\n-  }\n-  \/\/ This is the base version which is given an alias index.\n-  Node* make_load(Node* ctl, Node* adr, const Type* t, BasicType bt, int adr_idx,\n@@ -586,17 +566,0 @@\n-  Node* store_to_memory(Node* ctl, Node* adr, Node* val, BasicType bt,\n-                        const TypePtr* adr_type,\n-                        MemNode::MemOrd mo,\n-                        bool require_atomic_access = false,\n-                        bool unaligned = false,\n-                        bool mismatched = false,\n-                        bool unsafe = false,\n-                        int barrier_data = 0) {\n-    \/\/ This version computes alias_index from an address type\n-    assert(adr_type != nullptr, \"use other store_to_memory factory\");\n-    return store_to_memory(ctl, adr, val, bt,\n-                           C->get_alias_index(adr_type),\n-                           mo, require_atomic_access,\n-                           unaligned, mismatched, unsafe,\n-                           barrier_data);\n-  }\n-  \/\/ This is the base version which is given alias index\n@@ -605,1 +568,0 @@\n-                        int adr_idx,\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-      _fcnt(fcnt)\n-      NOT_PRODUCT(COMMA _assertion_predicate_type(AssertionPredicateType::None)) {\n+      _fcnt(fcnt),\n+      _assertion_predicate_type(AssertionPredicateType::None) {\n@@ -58,1 +58,0 @@\n-#ifndef PRODUCT\n@@ -66,1 +65,0 @@\n-#endif \/\/ NOT_PRODUCT\n@@ -1544,0 +1542,8 @@\n+    \/\/ Dominating CountedLoopEnd (left over from some now dead loop) will become the new loop exit. Outer strip mined\n+    \/\/ loop will go away. Mark this loop as no longer strip mined.\n+    if (is_CountedLoopEnd()) {\n+      CountedLoopNode* counted_loop_node = as_CountedLoopEnd()->loopnode();\n+      if (counted_loop_node != nullptr) {\n+        counted_loop_node->clear_strip_mined();\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-  kit->store_to_memory(kit->control(), mark_addr, mark, TypeX_X->basic_type(), kit->gvn().type(mark_addr)->is_ptr(), MemNode::unordered);\n+  kit->store_to_memory(kit->control(), mark_addr, mark, TypeX_X->basic_type(), MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,2 +278,2 @@\n-        if ((UseCompressedOops || UseCompressedClassPointers) &&\n-            (CompressedOops::shift() == 0 || CompressedKlassPointers::shift() == 0)) {\n+        if ((UseCompressedOops && CompressedOops::shift() == 0) ||\n+            (UseCompressedClassPointers && CompressedKlassPointers::shift() == 0)) {\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1298,1 +1298,0 @@\n-    assert(arrayOopDesc::base_offset_in_bytes(T_BYTE) >= 16, \"Needed for indexOf\");\n@@ -3316,1 +3315,1 @@\n-  Node* notified_reset_memory = store_to_memory(control(), notified_offset, _gvn.intcon(0), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::unordered);\n+  Node* notified_reset_memory = store_to_memory(control(), notified_offset, _gvn.intcon(0), T_BOOLEAN, MemNode::unordered);\n@@ -3336,1 +3335,1 @@\n-  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_LONG, Compile::AliasIdxRaw, MemNode::release);\n+  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_LONG, MemNode::release);\n@@ -3338,1 +3337,1 @@\n-  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_INT, Compile::AliasIdxRaw, MemNode::release);\n+  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_INT, MemNode::release);\n@@ -3655,1 +3654,0 @@\n-  const TypePtr* event_writer_tid_field_type = _gvn.type(event_writer_tid_field)->isa_ptr();\n@@ -3658,1 +3656,0 @@\n-  const TypePtr* event_writer_excluded_field_type = _gvn.type(event_writer_excluded_field)->isa_ptr();\n@@ -3661,1 +3658,0 @@\n-  const TypePtr* event_writer_pin_field_type = _gvn.type(event_writer_pin_field)->isa_ptr();\n@@ -3683,1 +3679,1 @@\n-  store_to_memory(tid_is_not_equal, event_writer_pin_field, _gvn.transform(pinVirtualThread), T_BOOLEAN, event_writer_pin_field_type, MemNode::unordered);\n+  store_to_memory(tid_is_not_equal, event_writer_pin_field, _gvn.transform(pinVirtualThread), T_BOOLEAN, MemNode::unordered);\n@@ -3686,1 +3682,1 @@\n-  store_to_memory(tid_is_not_equal, event_writer_excluded_field, _gvn.transform(exclusion), T_BOOLEAN, event_writer_excluded_field_type, MemNode::unordered);\n+  store_to_memory(tid_is_not_equal, event_writer_excluded_field, _gvn.transform(exclusion), T_BOOLEAN, MemNode::unordered);\n@@ -3689,1 +3685,1 @@\n-  store_to_memory(tid_is_not_equal, event_writer_tid_field, tid, T_LONG, event_writer_tid_field_type, MemNode::unordered);\n+  store_to_memory(tid_is_not_equal, event_writer_tid_field, tid, T_LONG, MemNode::unordered);\n@@ -3768,1 +3764,1 @@\n-  Node* vthread_false_memory = store_to_memory(thread_equal_carrierThread, vthread_offset, _gvn.intcon(0), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::release, true);\n+  Node* vthread_false_memory = store_to_memory(thread_equal_carrierThread, vthread_offset, _gvn.intcon(0), T_BOOLEAN, MemNode::release, true);\n@@ -3789,1 +3785,1 @@\n-  Node* tid_memory = store_to_memory(control(), thread_id_offset, tid, T_LONG, Compile::AliasIdxRaw, MemNode::unordered, true);\n+  Node* tid_memory = store_to_memory(control(), thread_id_offset, tid, T_LONG, MemNode::unordered, true);\n@@ -3811,1 +3807,1 @@\n-  Node* included_memory = store_to_memory(control(), vthread_epoch_offset, epoch, T_CHAR, Compile::AliasIdxRaw, MemNode::unordered, true);\n+  Node* included_memory = store_to_memory(control(), vthread_epoch_offset, epoch, T_CHAR, MemNode::unordered, true);\n@@ -3834,1 +3830,1 @@\n-  store_to_memory(control(), thread_local_excluded_offset, _gvn.transform(exclusion), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::unordered, true);\n+  store_to_memory(control(), thread_local_excluded_offset, _gvn.transform(exclusion), T_BOOLEAN, MemNode::unordered, true);\n@@ -3837,1 +3833,1 @@\n-  Node * vthread_true_memory = store_to_memory(control(), vthread_offset, _gvn.intcon(1), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::release, true);\n+  Node * vthread_true_memory = store_to_memory(control(), vthread_offset, _gvn.intcon(1), T_BOOLEAN, MemNode::release, true);\n@@ -3885,0 +3881,6 @@\n+\n+  \/\/ Change the lock_id of the JavaThread\n+  Node* tid = load_field_from_object(arr, \"tid\", \"J\");\n+  Node* thread_id_offset = basic_plus_adr(thread, in_bytes(JavaThread::lock_id_offset()));\n+  Node* tid_memory = store_to_memory(control(), thread_id_offset, tid, T_LONG, MemNode::unordered, true);\n+\n@@ -3987,1 +3989,1 @@\n-  Node* updated_pin_count_memory = store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+  Node* updated_pin_count_memory = store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, MemNode::unordered);\n@@ -5378,1 +5380,1 @@\n-  store_to_memory(control(), doing_unsafe_access_addr, intcon(1), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);\n+  store_to_memory(control(), doing_unsafe_access_addr, intcon(1), doing_unsafe_access_bt, MemNode::unordered);\n@@ -5403,1 +5405,1 @@\n-  store_to_memory(control(), doing_unsafe_access_addr, intcon(0), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);\n+  store_to_memory(control(), doing_unsafe_access_addr, intcon(0), doing_unsafe_access_bt, MemNode::unordered);\n@@ -5433,1 +5435,1 @@\n-  store_to_memory(control(), doing_unsafe_access_addr, intcon(1), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);\n+  store_to_memory(control(), doing_unsafe_access_addr, intcon(1), doing_unsafe_access_bt, MemNode::unordered);\n@@ -5454,1 +5456,1 @@\n-  store_to_memory(control(), doing_unsafe_access_addr, intcon(0), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);\n+  store_to_memory(control(), doing_unsafe_access_addr, intcon(0), doing_unsafe_access_bt, MemNode::unordered);\n@@ -7408,0 +7410,2 @@\n+  assert(C->get_alias_index(adr_type) == C->get_alias_index(_gvn.type(adr)->isa_ptr()),\n+    \"slice of address and input slice don't match\");\n@@ -8141,1 +8145,1 @@\n-  assert(a_start, \"a array is NULL\");\n+  assert(a_start, \"a array is null\");\n@@ -8143,1 +8147,1 @@\n-  assert(b_start, \"b array is NULL\");\n+  assert(b_start, \"b array is null\");\n@@ -8145,1 +8149,1 @@\n-  assert(r_start, \"r array is NULL\");\n+  assert(r_start, \"r array is null\");\n@@ -8170,1 +8174,1 @@\n-  assert(a_start, \"a array is NULL\");\n+  assert(a_start, \"a array is null\");\n@@ -8172,1 +8176,1 @@\n-  assert(b_start, \"b array is NULL\");\n+  assert(b_start, \"b array is null\");\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":29,"deletions":25,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -955,2 +955,2 @@\n-  static void get_assertion_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque = false);\n-  void update_main_loop_assertion_predicates(Node* ctrl, CountedLoopNode* loop_head, Node* init, int stride_con);\n+  static void get_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, bool get_opaque = false);\n+  void update_main_loop_assertion_predicates(CountedLoopNode* main_loop_head);\n@@ -1204,1 +1204,1 @@\n-    Compile::TracePhase tp(\"idealLoopVerify\", &timers[_t_idealLoopVerify]);\n+    Compile::TracePhase tp(_t_idealLoopVerify);\n@@ -1360,2 +1360,2 @@\n-      bool rewire_uncommon_proj_phi_inputs = false\n-      NOT_PRODUCT (COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n+      bool rewire_uncommon_proj_phi_inputs = false,\n+      AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None);\n@@ -1684,1 +1684,1 @@\n-                                                     Deoptimization::DeoptReason reason, IfProjNode* old_predicate_proj,\n+                                                     Deoptimization::DeoptReason reason, ParsePredicateSuccessProj* old_parse_predicate_proj,\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1884,1 +1884,3 @@\n-  rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+  if (!UseCompactObjectHeaders) {\n+    rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+  }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -469,1 +469,1 @@\n-    Compile::TracePhase tp(\"postselect_cleanup\", &timers[_t_postselect_cleanup]);\n+    Compile::TracePhase tp(_t_postselect_cleanup);\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2001,0 +2001,2 @@\n+  assert(!UseCompactObjectHeaders || tkls->offset() != in_bytes(Klass::prototype_header_offset()),\n+         \"must not happen\");\n@@ -2184,0 +2186,7 @@\n+      if (UseCompactObjectHeaders) { \/\/ TODO: Should EnableValhalla also take this path ?\n+        if (tkls->offset() == in_bytes(Klass::prototype_header_offset())) {\n+          \/\/ The field is Klass::_prototype_header. Return its (constant) value.\n+          assert(this->Opcode() == Op_LoadX, \"must load a proper type from _prototype_header\");\n+          return TypeX::make(klass->prototype_header());\n+        }\n+      }\n@@ -2272,8 +2281,12 @@\n-  Node* alloc = is_new_object_mark_load();\n-  if (alloc != nullptr) {\n-    if (EnableValhalla) {\n-      \/\/ The mark word may contain property bits (inline, flat, null-free)\n-      Node* klass_node = alloc->in(AllocateNode::KlassNode);\n-      const TypeKlassPtr* tkls = phase->type(klass_node)->isa_klassptr();\n-      if (tkls != nullptr && tkls->is_loaded() && tkls->klass_is_exact()) {\n-        return TypeX::make(tkls->exact_klass()->prototype_header().value());\n+  if (!UseCompactObjectHeaders) {\n+    Node* alloc = is_new_object_mark_load();\n+    if (alloc != nullptr) {\n+      if (EnableValhalla) {\n+        \/\/ The mark word may contain property bits (inline, flat, null-free)\n+        Node* klass_node = alloc->in(AllocateNode::KlassNode);\n+        const TypeKlassPtr* tkls = phase->type(klass_node)->isa_klassptr();\n+        if (tkls != nullptr && tkls->is_loaded() && tkls->klass_is_exact()) {\n+          return TypeX::make(tkls->exact_klass()->prototype_header());\n+        }\n+      } else {\n+        return TypeX::make(markWord::prototype().value());\n@@ -2281,2 +2294,0 @@\n-    } else {\n-      return TypeX::make(markWord::prototype().value());\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-  Compile::TracePhase tp(\"shorten branches\", &timers[_t_shortenBranches]);\n+  Compile::TracePhase tp(_t_shortenBranches);\n@@ -1488,1 +1488,1 @@\n-  Compile::TracePhase tp(\"fill buffer\", &timers[_t_fillBuffer]);\n+  Compile::TracePhase tp(_t_fillBuffer);\n@@ -2233,1 +2233,1 @@\n-  Compile::TracePhase tp(\"isched\", &timers[_t_instrSched]);\n+  Compile::TracePhase tp(_t_instrSched);\n@@ -3533,1 +3533,1 @@\n-    Compile::TracePhase tp(\"install_code\", &timers[_t_registerMethod]);\n+    Compile::TracePhase tp(_t_registerMethod);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-    store_to_memory(control(), box, displaced_hdr, T_ADDRESS, Compile::AliasIdxRaw, MemNode::unordered);\n+    store_to_memory(control(), box, displaced_hdr, T_ADDRESS, MemNode::unordered);\n@@ -2457,1 +2457,1 @@\n-  polladr = make_load(control(), polling_page_load_addr, TypeRawPtr::BOTTOM, T_ADDRESS, Compile::AliasIdxRaw, MemNode::unordered);\n+  polladr = make_load(control(), polling_page_load_addr, TypeRawPtr::BOTTOM, T_ADDRESS, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1799,1 +1799,1 @@\n-  counter = make_load(control(), counter_addr, TypeInt::INT, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+  counter = make_load(control(), counter_addr, TypeInt::INT, T_INT, MemNode::unordered);\n@@ -1801,1 +1801,1 @@\n-  incr_store = store_to_memory(control(), counter_addr, counter, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+  incr_store = store_to_memory(control(), counter_addr, counter, T_INT, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -537,1 +537,1 @@\n-        store_to_memory(control(), dims_elem, length[j], T_INT, TypeAryPtr::INTS, MemNode::unordered);\n+        store_to_memory(control(), dims_elem, length[j], T_INT, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/addnode.hpp\"\n@@ -1669,2 +1670,6 @@\n-  \/\/ If changed AddP inputs, check Stores for loop invariant\n-  if( use_op == Op_AddP ) {\n+  \/\/ If changed AddP inputs:\n+  \/\/ - check Stores for loop invariant, and\n+  \/\/ - if the changed input is the offset, check constant-offset AddP users for\n+  \/\/   address expression flattening.\n+  if (use_op == Op_AddP) {\n+    bool offset_changed = n == use->in(AddPNode::Offset);\n@@ -1673,1 +1678,1 @@\n-      if (u->is_Mem())\n+      if (u->is_Mem()) {\n@@ -1675,0 +1680,3 @@\n+      } else if (offset_changed && u->is_AddP() && u->in(AddPNode::Offset)->is_Con()) {\n+        worklist.push(u);\n+      }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1328,1 +1328,1 @@\n-                                ch, bt, byte_adr_idx, MemNode::unordered, false \/* require_atomic_access *\/,\n+                                ch, bt, MemNode::unordered, false \/* require_atomic_access *\/,\n@@ -1367,2 +1367,2 @@\n-                            sign, bt, byte_adr_idx, MemNode::unordered, false \/* require_atomic_access *\/,\n-                            false \/* unaligned *\/, (bt != T_BYTE) \/* mismatched *\/);\n+                            sign, bt, MemNode::unordered, false \/* require_atomic_access *\/, false \/* unaligned *\/,\n+                            (bt != T_BYTE) \/* mismatched *\/);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  Compile::TracePhase tp(\"vector_elimination\", &timers[_t_vector_elimination]);\n+  Compile::TracePhase tp(_t_vector_elimination);\n@@ -69,1 +69,1 @@\n-    Compile::TracePhase tp(\"vector_pru\", &timers[_t_vector_pru]);\n+    Compile::TracePhase tp(_t_vector_pru);\n@@ -75,1 +75,1 @@\n-    Compile::TracePhase tp(\"incrementalInline_igvn\", &timers[_t_vector_igvn]);\n+    Compile::TracePhase tp(_t_vector_igvn);\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-#if defined(_LP64) || defined(_WIN64)\n+#if defined(_LP64)\n@@ -1398,81 +1398,0 @@\n-\/\/ Returns the inherited_access_control_context field of the running thread.\n-JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))\n-  oop result = java_lang_Thread::inherited_access_control_context(thread->threadObj());\n-  return JNIHandles::make_local(THREAD, result);\n-JVM_END\n-\n-JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))\n-  if (!UsePrivilegedStack) return nullptr;\n-\n-  ResourceMark rm(THREAD);\n-  GrowableArray<Handle>* local_array = new GrowableArray<Handle>(12);\n-  JvmtiVMObjectAllocEventCollector oam;\n-\n-  \/\/ count the protection domains on the execution stack. We collapse\n-  \/\/ duplicate consecutive protection domains into a single one, as\n-  \/\/ well as stopping when we hit a privileged frame.\n-\n-  oop previous_protection_domain = nullptr;\n-  Handle privileged_context(thread, nullptr);\n-  bool is_privileged = false;\n-  oop protection_domain = nullptr;\n-\n-  \/\/ Iterate through Java frames\n-  vframeStream vfst(thread);\n-  for(; !vfst.at_end(); vfst.next()) {\n-    \/\/ get method of frame\n-    Method* method = vfst.method();\n-\n-    \/\/ stop at the first privileged frame\n-    if (method->method_holder() == vmClasses::AccessController_klass() &&\n-      method->name() == vmSymbols::executePrivileged_name())\n-    {\n-      \/\/ this frame is privileged\n-      is_privileged = true;\n-\n-      javaVFrame *priv = vfst.asJavaVFrame();       \/\/ executePrivileged\n-\n-      StackValueCollection* locals = priv->locals();\n-      StackValue* ctx_sv = locals->at(1); \/\/ AccessControlContext context\n-      StackValue* clr_sv = locals->at(2); \/\/ Class<?> caller\n-      assert(!ctx_sv->obj_is_scalar_replaced(), \"found scalar-replaced object\");\n-      assert(!clr_sv->obj_is_scalar_replaced(), \"found scalar-replaced object\");\n-      privileged_context    = ctx_sv->get_obj();\n-      Handle caller         = clr_sv->get_obj();\n-\n-      Klass *caller_klass = java_lang_Class::as_Klass(caller());\n-      protection_domain  = caller_klass->protection_domain();\n-    } else {\n-      protection_domain = method->method_holder()->protection_domain();\n-    }\n-\n-    if ((previous_protection_domain != protection_domain) && (protection_domain != nullptr)) {\n-      local_array->push(Handle(thread, protection_domain));\n-      previous_protection_domain = protection_domain;\n-    }\n-\n-    if (is_privileged) break;\n-  }\n-\n-\n-  \/\/ either all the domains on the stack were system domains, or\n-  \/\/ we had a privileged system domain\n-  if (local_array->is_empty()) {\n-    if (is_privileged && privileged_context.is_null()) return nullptr;\n-\n-    oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);\n-    return JNIHandles::make_local(THREAD, result);\n-  }\n-\n-  objArrayOop context = oopFactory::new_objArray(vmClasses::ProtectionDomain_klass(),\n-                                                 local_array->length(), CHECK_NULL);\n-  objArrayHandle h_context(thread, context);\n-  for (int index = 0; index < local_array->length(); index++) {\n-    h_context->obj_at_put(index, local_array->at(index)());\n-  }\n-\n-  oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);\n-\n-  return JNIHandles::make_local(THREAD, result);\n-JVM_END\n-\n@@ -3255,0 +3174,4 @@\n+\n+  \/\/ Set lock id of new current Thread\n+  thread->set_lock_id(java_lang_Thread::thread_id(threadObj));\n+\n@@ -4125,0 +4048,33 @@\n+JVM_ENTRY(void, JVM_VirtualThreadPinnedEvent(JNIEnv* env, jclass ignored, jstring op))\n+#if INCLUDE_JFR\n+  freeze_result result = THREAD->last_freeze_fail_result();\n+  assert(result != freeze_ok, \"sanity check\");\n+  EventVirtualThreadPinned event(UNTIMED);\n+  event.set_starttime(THREAD->last_freeze_fail_time());\n+  if (event.should_commit()) {\n+    ResourceMark rm(THREAD);\n+    const char *str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(op));\n+    THREAD->post_vthread_pinned_event(&event, str, result);\n+  }\n+#endif\n+JVM_END\n+\n+JVM_ENTRY(jobject, JVM_TakeVirtualThreadListToUnblock(JNIEnv* env, jclass ignored))\n+  ParkEvent* parkEvent = ObjectMonitor::vthread_unparker_ParkEvent();\n+  assert(parkEvent != nullptr, \"not initialized\");\n+\n+  OopHandle& list_head = ObjectMonitor::vthread_cxq_head();\n+  oop vthread_head = nullptr;\n+  while (true) {\n+    if (list_head.peek() != nullptr) {\n+      for (;;) {\n+        oop head = list_head.resolve();\n+        if (list_head.cmpxchg(head, nullptr) == head) {\n+          return JNIHandles::make_local(THREAD, head);\n+        }\n+      }\n+    }\n+    ThreadBlockInVM tbivm(THREAD);\n+    parkEvent->park();\n+  }\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":38,"deletions":82,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -1353,4 +1353,0 @@\n-  \/\/ growable array of jvmti monitors info on the C-heap\n-  GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =\n-      new (mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n-\n@@ -1364,1 +1360,0 @@\n-    delete owned_monitors_list;\n@@ -1368,11 +1363,14 @@\n-  if (java_thread != nullptr) {\n-    Handle thread_handle(calling_thread, thread_oop);\n-    EscapeBarrier eb(true, calling_thread, java_thread);\n-    if (!eb.deoptimize_objects(MaxJavaStackTraceDepth)) {\n-      delete owned_monitors_list;\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-    \/\/ get owned monitors info with handshake\n-    GetOwnedMonitorInfoClosure op(this, calling_thread, owned_monitors_list);\n-    JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n-    err = op.result();\n+  if (LockingMode == LM_LEGACY && java_thread == nullptr) {\n+    *owned_monitor_count_ptr = 0;\n+    return JVMTI_ERROR_NONE;\n+  }\n+\n+  \/\/ growable array of jvmti monitors info on the C-heap\n+  GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =\n+      new (mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n+\n+  Handle thread_handle(calling_thread, thread_oop);\n+  EscapeBarrier eb(java_thread != nullptr, calling_thread, java_thread);\n+  if (!eb.deoptimize_objects(MaxJavaStackTraceDepth)) {\n+    delete owned_monitors_list;\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n@@ -1380,0 +1378,4 @@\n+  \/\/ get owned monitors info with handshake\n+  GetOwnedMonitorInfoClosure op(this, calling_thread, owned_monitors_list);\n+  JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n+  err = op.result();\n@@ -1411,4 +1413,0 @@\n-  \/\/ growable array of jvmti monitors info on the C-heap\n-  GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =\n-         new (mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n-\n@@ -1422,1 +1420,0 @@\n-    delete owned_monitors_list;\n@@ -1426,11 +1423,14 @@\n-  if (java_thread != nullptr) {\n-    Handle thread_handle(calling_thread, thread_oop);\n-    EscapeBarrier eb(true, calling_thread, java_thread);\n-    if (!eb.deoptimize_objects(MaxJavaStackTraceDepth)) {\n-      delete owned_monitors_list;\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-    \/\/ get owned monitors info with handshake\n-    GetOwnedMonitorInfoClosure op(this, calling_thread, owned_monitors_list);\n-    JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n-    err = op.result();\n+  if (LockingMode == LM_LEGACY && java_thread == nullptr) {\n+    *monitor_info_count_ptr = 0;\n+    return JVMTI_ERROR_NONE;\n+  }\n+\n+  \/\/ growable array of jvmti monitors info on the C-heap\n+  GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =\n+      new (mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n+\n+  Handle thread_handle(calling_thread, thread_oop);\n+  EscapeBarrier eb(java_thread != nullptr, calling_thread, java_thread);\n+  if (!eb.deoptimize_objects(MaxJavaStackTraceDepth)) {\n+    delete owned_monitors_list;\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n@@ -1438,0 +1438,4 @@\n+  \/\/ get owned monitors info with handshake\n+  GetOwnedMonitorInfoClosure op(this, calling_thread, owned_monitors_list);\n+  JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n+  err = op.result();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":36,"deletions":32,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -1729,0 +1729,4 @@\n+  assert(is_aligned(commit_limit, BytesPerWord),\n+         \"WB_CreateMetaspaceTestContext: commit_limit is not a multiple of the system word byte size\");\n+  assert(is_aligned(reserve_limit, BytesPerWord),\n+         \"WB_CreateMetaspaceTestContext: reserve_limit is not a multiple of the system word byte size\");\n@@ -1730,1 +1734,2 @@\n-      new metaspace::MetaspaceTestContext(\"whitebox-metaspace-context\", (size_t) commit_limit, (size_t) reserve_limit);\n+      new metaspace::MetaspaceTestContext(\"whitebox-metaspace-context\", (size_t) commit_limit \/ BytesPerWord,\n+                                          (size_t) reserve_limit \/ BytesPerWord);\n@@ -1748,1 +1753,1 @@\n-WB_ENTRY(jlong, WB_GetTotalCommittedWordsInMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))\n+WB_ENTRY(jlong, WB_GetTotalCommittedBytesInMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))\n@@ -1750,1 +1755,1 @@\n-  return context0->committed_words();\n+  return (jlong)context0->committed_words() * BytesPerWord;\n@@ -1753,1 +1758,1 @@\n-WB_ENTRY(jlong, WB_GetTotalUsedWordsInMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))\n+WB_ENTRY(jlong, WB_GetTotalUsedBytesInMetaspaceTestContext(JNIEnv* env, jobject wb, jlong context))\n@@ -1755,1 +1760,1 @@\n-  return context0->used_words();\n+  return (jlong)context0->used_words() * BytesPerWord;\n@@ -1768,3 +1773,5 @@\n-WB_ENTRY(jlong, WB_AllocateFromMetaspaceTestArena(JNIEnv* env, jobject wb, jlong arena, jlong word_size))\n-  metaspace::MetaspaceTestArena* arena0 = (metaspace::MetaspaceTestArena*) arena;\n-  MetaWord* p = arena0->allocate((size_t) word_size);\n+WB_ENTRY(jlong, WB_AllocateFromMetaspaceTestArena(JNIEnv* env, jobject wb, jlong arena, jlong size))\n+  assert(is_aligned(size, BytesPerWord),\n+         \"WB_AllocateFromMetaspaceTestArena: size is not a multiple of the system word byte size\");\n+  metaspace::MetaspaceTestArena *arena0 = (metaspace::MetaspaceTestArena *)arena;\n+  MetaWord *p = arena0->allocate((size_t) size \/ BytesPerWord);\n@@ -1774,1 +1781,3 @@\n-WB_ENTRY(void, WB_DeallocateToMetaspaceTestArena(JNIEnv* env, jobject wb, jlong arena, jlong p, jlong word_size))\n+WB_ENTRY(void, WB_DeallocateToMetaspaceTestArena(JNIEnv* env, jobject wb, jlong arena, jlong p, jlong size))\n+  assert(is_aligned(size, BytesPerWord),\n+         \"WB_DeallocateToMetaspaceTestArena: size is not a multiple of the system word byte size\");\n@@ -1776,1 +1785,1 @@\n-  arena0->deallocate((MetaWord*)p, (size_t) word_size);\n+  arena0->deallocate((MetaWord*)p, (size_t) size \/ BytesPerWord);\n@@ -1783,0 +1792,8 @@\n+WB_ENTRY(jlong, WB_WordSize(JNIEnv* env))\n+  return (jlong)BytesPerWord;\n+WB_END\n+\n+WB_ENTRY(jlong, WB_RootChunkWordSize(JNIEnv* env))\n+  return (jlong)Metaspace::reserve_alignment_words();\n+WB_END\n+\n@@ -3073,2 +3090,2 @@\n-  {CC\"getTotalCommittedWordsInMetaspaceTestContext\", CC\"(J)J\",(void*)&WB_GetTotalCommittedWordsInMetaspaceTestContext},\n-  {CC\"getTotalUsedWordsInMetaspaceTestContext\", CC\"(J)J\", (void*)&WB_GetTotalUsedWordsInMetaspaceTestContext},\n+  {CC\"getTotalCommittedBytesInMetaspaceTestContext\", CC\"(J)J\",(void*)&WB_GetTotalCommittedBytesInMetaspaceTestContext},\n+  {CC\"getTotalUsedBytesInMetaspaceTestContext\", CC\"(J)J\", (void*)&WB_GetTotalUsedBytesInMetaspaceTestContext},\n@@ -3094,0 +3111,2 @@\n+  {CC\"wordSize\", CC\"()J\",                             (void*)&WB_WordSize},\n+  {CC\"rootChunkWordSize\", CC\"()J\",                    (void*)&WB_RootChunkWordSize}\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1433,7 +1433,0 @@\n-void Arguments::set_use_compressed_klass_ptrs() {\n-#ifdef _LP64\n-  assert(!UseCompressedClassPointers || CompressedClassSpaceSize <= KlassEncodingMetaspaceMax,\n-         \"CompressedClassSpaceSize is too large for UseCompressedClassPointers\");\n-#endif \/\/ _LP64\n-}\n-\n@@ -1458,1 +1451,0 @@\n-  set_use_compressed_klass_ptrs();\n@@ -1828,0 +1820,9 @@\n+#ifndef _LP64\n+  if (LockingMode == LM_LEGACY) {\n+    FLAG_SET_CMDLINE(LockingMode, LM_LIGHTWEIGHT);\n+    \/\/ Self-forwarding in bit 3 of the mark-word conflicts\n+    \/\/ with 4-byte-aligned stack-locks.\n+    warning(\"Legacy locking not supported on this platform\");\n+  }\n+#endif\n+\n@@ -3731,0 +3732,26 @@\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders && FLAG_IS_CMDLINE(UseCompressedClassPointers) && !UseCompressedClassPointers) {\n+    warning(\"Compact object headers require compressed class pointers. Disabling compact object headers.\");\n+    FLAG_SET_DEFAULT(UseCompactObjectHeaders, false);\n+  }\n+  if (UseCompactObjectHeaders && LockingMode != LM_LIGHTWEIGHT) {\n+    FLAG_SET_DEFAULT(LockingMode, LM_LIGHTWEIGHT);\n+  }\n+  if (UseCompactObjectHeaders && !UseObjectMonitorTable) {\n+    \/\/ If UseCompactObjectHeaders is on the command line, turn on UseObjectMonitorTable.\n+    if (FLAG_IS_CMDLINE(UseCompactObjectHeaders)) {\n+      FLAG_SET_DEFAULT(UseObjectMonitorTable, true);\n+\n+    \/\/ If UseObjectMonitorTable is on the command line, turn off UseCompactObjectHeaders.\n+    } else if (FLAG_IS_CMDLINE(UseObjectMonitorTable)) {\n+      FLAG_SET_DEFAULT(UseCompactObjectHeaders, false);\n+    \/\/ If neither on the command line, the defaults are incompatible, but turn on UseObjectMonitorTable.\n+    } else {\n+      FLAG_SET_DEFAULT(UseObjectMonitorTable, true);\n+    }\n+  }\n+  if (UseCompactObjectHeaders && !UseCompressedClassPointers) {\n+    FLAG_SET_DEFAULT(UseCompressedClassPointers, true);\n+  }\n+#endif\n+\n@@ -3744,0 +3771,4 @@\n+  if (UseCompressedClassPointers) {\n+    CompressedKlassPointers::pre_initialize();\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":39,"deletions":8,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -267,1 +267,0 @@\n-  static void set_use_compressed_klass_ptrs();\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,0 +128,4 @@\n+  if (!nm->can_be_deoptimized()) {\n+    return;\n+  }\n+\n@@ -1759,1 +1763,1 @@\n-          assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->owner() == deoptee_thread, \"must be\");\n+          assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->has_owner(deoptee_thread), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -523,1 +523,0 @@\n-\n@@ -603,1 +602,10 @@\n-    if (current->obj() != nullptr) current->obj()->print_value_on(st);\n+    oop obj = current->obj();\n+    if (obj != nullptr) {\n+      if (!is_heap_frame()) {\n+        obj->print_value_on(st);\n+      } else {\n+        \/\/ Might be an invalid oop. We don't have the\n+        \/\/ stackChunk to correct it so just print address.\n+        st->print(INTPTR_FORMAT, p2i(obj));\n+      }\n+    }\n@@ -606,1 +614,3 @@\n-    current->lock()->print_on(st, current->obj());\n+    if (!is_heap_frame()) {\n+      current->lock()->print_on(st, obj);\n+    }\n@@ -1129,1 +1139,1 @@\n-BasicLock* frame::get_native_monitor() {\n+BasicLock* frame::get_native_monitor() const {\n@@ -1138,1 +1148,1 @@\n-oop frame::get_native_receiver() {\n+oop frame::get_native_receiver() const {\n@@ -1384,1 +1394,1 @@\n-void frame::describe(FrameValues& values, int frame_no, const RegisterMap* reg_map) {\n+void frame::describe(FrameValues& values, int frame_no, const RegisterMap* reg_map, bool top) {\n@@ -1387,0 +1397,5 @@\n+  if (top) {\n+    values.describe(-1, sp() - 1, err_msg(\"sp[-1] for #%d\", frame_no), 0);\n+    values.describe(-1, sp() - 2, err_msg(\"sp[-2] for #%d\", frame_no), 0);\n+  }\n+\n@@ -1458,1 +1473,1 @@\n-  } else if (cb()->is_nmethod()) {\n+  } else if (is_compiled_frame()) {\n@@ -1561,5 +1576,0 @@\n-\n-    if (nm->method()->is_continuation_enter_intrinsic()) {\n-      ContinuationEntry* ce = Continuation::get_continuation_entry_for_entry_frame(reg_map->thread(), *this); \/\/ (ContinuationEntry*)unextended_sp();\n-      ce->describe(values, frame_no);\n-    }\n@@ -1572,0 +1582,4 @@\n+    if (nm->method()->is_continuation_enter_intrinsic()) {\n+      ContinuationEntry* ce = Continuation::get_continuation_entry_for_entry_frame(reg_map->thread(), *this); \/\/ (ContinuationEntry*)unextended_sp();\n+      ce->describe(values, frame_no);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -340,2 +340,2 @@\n-  BasicLock* get_native_monitor();\n-  oop        get_native_receiver();\n+  BasicLock* get_native_monitor() const;\n+  oop        get_native_receiver() const;\n@@ -429,0 +429,2 @@\n+  static JavaThread** saved_thread_address(const frame& f);\n+\n@@ -445,1 +447,1 @@\n-  void describe(FrameValues& values, int frame_no, const RegisterMap* reg_map=nullptr);\n+  void describe(FrameValues& values, int frame_no, const RegisterMap* reg_map=nullptr, bool top = false);\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -131,0 +131,3 @@\n+  product(bool, UseCompactObjectHeaders, false, EXPERIMENTAL,               \\\n+          \"Use compact 64-bit object headers in 64-bit VM\")                 \\\n+                                                                            \\\n@@ -147,0 +150,1 @@\n+const bool UseCompactObjectHeaders = false;\n@@ -680,3 +684,0 @@\n-  develop(bool, UsePrivilegedStack, true,                                   \\\n-          \"Enable the security JVM functions\")                              \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+#include \"runtime\/threadIdentifier.hpp\"\n@@ -239,0 +240,2 @@\n+  \/\/ Set the lock_id to the next thread_id temporarily while initialization runs.\n+  set_lock_id(ThreadIdentifier::next());\n@@ -264,0 +267,3 @@\n+  \/\/ Update the lock_id with the tid value.\n+  set_lock_id(java_lang_Thread::thread_id(thread_oop()));\n+\n@@ -433,0 +439,1 @@\n+  _lock_id(0),\n@@ -452,0 +459,2 @@\n+  _on_monitor_waited_event(false),\n+  _contended_entered_monitor(nullptr),\n@@ -492,0 +501,4 @@\n+  _preempt_alternate_return(nullptr),\n+  _preemption_cancelled(false),\n+  _pending_interrupted_exception(false),\n+\n@@ -505,0 +518,1 @@\n+  _class_being_initialized(nullptr),\n@@ -1166,0 +1180,1 @@\n+  assert(is_in_VTMS_transition() != val, \"already %s transition\", val ? \"inside\" : \"outside\");\n@@ -1529,3 +1544,2 @@\n-      oop vt = vthread();\n-      assert(vt != nullptr, \"\");\n-      st->print_cr(\"   Carrying virtual thread #\" INT64_FORMAT, (int64_t)java_lang_Thread::thread_id(vt));\n+      \/\/ _lock_id is the thread ID of the mounted virtual thread\n+      st->print_cr(\"   Carrying virtual thread #\" INT64_FORMAT, lock_id());\n@@ -1715,0 +1729,1 @@\n+  set_lock_id(java_lang_Thread::thread_id(thread_oop()));\n@@ -1994,0 +2009,8 @@\n+\n+  if (LockingMode != LM_LEGACY) {\n+    \/\/ Nothing to do. Just do some sanity check.\n+    assert(_held_monitor_count == 0, \"counter should not be used\");\n+    assert(_jni_monitor_count == 0, \"counter should not be used\");\n+    return;\n+  }\n+\n@@ -2002,1 +2025,1 @@\n-#endif\n+#endif \/\/ SUPPORT_MONITOR_COUNT\n@@ -2009,0 +2032,8 @@\n+\n+  if (LockingMode != LM_LEGACY) {\n+    \/\/ Nothing to do. Just do some sanity check.\n+    assert(_held_monitor_count == 0, \"counter should not be used\");\n+    assert(_jni_monitor_count == 0, \"counter should not be used\");\n+    return;\n+  }\n+\n@@ -2010,1 +2041,1 @@\n-  assert(_held_monitor_count >= 0, \"Must always be greater than 0: \" INTX_FORMAT, _held_monitor_count);\n+  assert(_held_monitor_count >= 0, \"Must always be non-negative: \" INTX_FORMAT, _held_monitor_count);\n@@ -2013,1 +2044,1 @@\n-    assert(_jni_monitor_count >= 0, \"Must always be greater than 0: \" INTX_FORMAT, _jni_monitor_count);\n+    assert(_jni_monitor_count >= 0, \"Must always be non-negative: \" INTX_FORMAT, _jni_monitor_count);\n@@ -2021,1 +2052,1 @@\n-#endif\n+#endif \/\/ SUPPORT_MONITOR_COUNT\n@@ -2203,0 +2234,1 @@\n+  target->set_lock_id(java_lang_Thread::thread_id(thread_oop()));\n@@ -2299,0 +2331,35 @@\n+\n+#if INCLUDE_JFR\n+void JavaThread::set_last_freeze_fail_result(freeze_result result) {\n+  assert(result != freeze_ok, \"sanity check\");\n+  _last_freeze_fail_result = result;\n+  _last_freeze_fail_time = Ticks::now();\n+}\n+\n+\/\/ Post jdk.VirtualThreadPinned event\n+void JavaThread::post_vthread_pinned_event(EventVirtualThreadPinned* event, const char* op, freeze_result result) {\n+  assert(result != freeze_ok, \"sanity check\");\n+  if (event->should_commit()) {\n+    char reason[256];\n+    if (class_to_be_initialized() != nullptr) {\n+      ResourceMark rm(this);\n+      jio_snprintf(reason, sizeof reason, \"Waited for initialization of %s by another thread\",\n+                   class_to_be_initialized()->external_name());\n+      event->set_pinnedReason(reason);\n+    } else if (class_being_initialized() != nullptr) {\n+      ResourceMark rm(this);\n+      jio_snprintf(reason, sizeof(reason), \"VM call to %s.<clinit> on stack\",\n+                   class_being_initialized()->external_name());\n+      event->set_pinnedReason(reason);\n+    } else if (result == freeze_pinned_native) {\n+      event->set_pinnedReason(\"Native or VM frame on stack\");\n+    } else {\n+      jio_snprintf(reason, sizeof(reason), \"Freeze or preempt failed (%d)\", result);\n+      event->set_pinnedReason(reason);\n+    }\n+    event->set_blockingOperation(op);\n+    event->set_carrierThread(JFR_JVM_THREAD_ID(this));\n+    event->commit();\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":74,"deletions":7,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -44,0 +45,1 @@\n+#include \"runtime\/threadIdentifier.hpp\"\n@@ -50,0 +52,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -53,1 +56,0 @@\n-class ContinuationEntry;\n@@ -80,0 +82,2 @@\n+class EventVirtualThreadPinned;\n+\n@@ -163,0 +167,5 @@\n+  \/\/ ID used as owner for inflated monitors. Same as the j.l.Thread.tid of the\n+  \/\/ current _vthread object, except during creation of the primordial and JNI\n+  \/\/ attached thread cases where this field can have a temporary value.\n+  int64_t _lock_id;\n+\n@@ -164,0 +173,6 @@\n+  void set_lock_id(int64_t tid) {\n+    assert(tid >= ThreadIdentifier::initial() && tid < ThreadIdentifier::current(), \"invalid tid\");\n+    _lock_id = tid;\n+  }\n+  int64_t lock_id() const { return _lock_id; }\n+\n@@ -317,0 +332,2 @@\n+  bool                  _on_monitor_waited_event;        \/\/ Avoid callee arg processing for enterSpecial when posting waited event\n+  ObjectMonitor*        _contended_entered_monitor;      \/\/ Monitor for pending monitor_contended_entered callback\n@@ -458,2 +475,2 @@\n-  intptr_t* _cont_fastpath; \/\/ the sp of the oldest known interpreted\/call_stub frame inside the\n-                            \/\/ continuation that we know about\n+  intptr_t* _cont_fastpath; \/\/ the sp of the oldest known interpreted\/call_stub\/upcall_stub\/native_wrapper\n+                            \/\/ frame inside the continuation that we know about\n@@ -467,0 +484,22 @@\n+  \/\/ This is the field we poke in the interpreter and native\n+  \/\/ wrapper (Object.wait) to check for preemption.\n+  address _preempt_alternate_return;\n+  \/\/ When preempting on monitorenter we could have acquired the\n+  \/\/ monitor after freezing all vthread frames. In that case we\n+  \/\/ set this field so that in the preempt stub we call thaw again\n+  \/\/ instead of unmounting.\n+  bool _preemption_cancelled;\n+  \/\/ For Object.wait() we set this field to know if we need to\n+  \/\/ throw IE at the end of thawing before returning to Java.\n+  bool _pending_interrupted_exception;\n+\n+ public:\n+  bool preemption_cancelled()           { return _preemption_cancelled; }\n+  void set_preemption_cancelled(bool b) { _preemption_cancelled = b; }\n+\n+  bool pending_interrupted_exception()           { return _pending_interrupted_exception; }\n+  void set_pending_interrupted_exception(bool b) { _pending_interrupted_exception = b; }\n+\n+  bool preempting()           { return _preempt_alternate_return != nullptr; }\n+  void set_preempt_alternate_return(address val) { _preempt_alternate_return = val; }\n+\n@@ -631,1 +670,1 @@\n-  void clear_jni_monitor_count() { _jni_monitor_count = 0;   }\n+  void clear_jni_monitor_count() { _jni_monitor_count = 0; }\n@@ -686,0 +725,5 @@\n+  bool on_monitor_waited_event()             { return _on_monitor_waited_event; }\n+  void set_on_monitor_waited_event(bool val) { _on_monitor_waited_event = val; }\n+\n+  bool pending_contended_entered_event()         { return _contended_entered_monitor != nullptr; }\n+  ObjectMonitor* contended_entered_monitor()     { return _contended_entered_monitor; }\n@@ -692,0 +736,2 @@\n+  void set_contended_entered_monitor(ObjectMonitor* val) NOT_JVMTI_RETURN JVMTI_ONLY({ _contended_entered_monitor = val; })\n+\n@@ -846,0 +892,2 @@\n+  static ByteSize lock_id_offset()            { return byte_offset_of(JavaThread, _lock_id); }\n+\n@@ -850,0 +898,2 @@\n+  static ByteSize preemption_cancelled_offset()  { return byte_offset_of(JavaThread, _preemption_cancelled); }\n+  static ByteSize preempt_alternate_return_offset() { return byte_offset_of(JavaThread, _preempt_alternate_return); }\n@@ -1169,0 +1219,4 @@\n+  \/\/ Track executing class initializer, see ThreadInClassInitializer\n+  void set_class_being_initialized(InstanceKlass* k);\n+  InstanceKlass* class_being_initialized() const;\n+\n@@ -1171,0 +1225,1 @@\n+  InstanceKlass* _class_being_initialized;\n@@ -1174,0 +1229,7 @@\n+\n+#if INCLUDE_JFR\n+  \/\/ Support for jdk.VirtualThreadPinned event\n+  freeze_result _last_freeze_fail_result;\n+  Ticks _last_freeze_fail_time;\n+#endif\n+\n@@ -1182,0 +1244,9 @@\n+#if INCLUDE_JFR\n+  \/\/ Support for jdk.VirtualThreadPinned event\n+  freeze_result last_freeze_fail_result() { return _last_freeze_fail_result; }\n+  Ticks& last_freeze_fail_time() { return _last_freeze_fail_time; }\n+  void set_last_freeze_fail_result(freeze_result result);\n+#endif\n+  void post_vthread_pinned_event(EventVirtualThreadPinned* event, const char* op, freeze_result result) NOT_JFR_RETURN();\n+\n+\n@@ -1269,0 +1340,32 @@\n+class NoPreemptMark {\n+  ContinuationEntry* _ce;\n+  bool _unpin;\n+ public:\n+  NoPreemptMark(JavaThread* thread) : _ce(thread->last_continuation()), _unpin(false) {\n+    if (_ce != nullptr) _unpin = _ce->pin();\n+  }\n+  ~NoPreemptMark() { if (_unpin) _ce->unpin(); }\n+};\n+\n+class ThreadOnMonitorWaitedEvent {\n+  JavaThread* _thread;\n+ public:\n+  ThreadOnMonitorWaitedEvent(JavaThread* thread) : _thread(thread) {\n+    JVMTI_ONLY(_thread->set_on_monitor_waited_event(true);)\n+  }\n+  ~ThreadOnMonitorWaitedEvent() { JVMTI_ONLY(_thread->set_on_monitor_waited_event(false);) }\n+};\n+\n+class ThreadInClassInitializer : public StackObj {\n+  JavaThread* _thread;\n+  InstanceKlass* _previous;\n+ public:\n+  ThreadInClassInitializer(JavaThread* thread, InstanceKlass* ik) : _thread(thread) {\n+    _previous = _thread->class_being_initialized();\n+    _thread->set_class_being_initialized(ik);\n+  }\n+  ~ThreadInClassInitializer() {\n+    _thread->set_class_being_initialized(_previous);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":107,"deletions":4,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2068,1 +2068,1 @@\n-    assert(m->owner_raw() != current, \"must be\");\n+    assert(!m->has_owner(current), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -532,0 +532,4 @@\n+  static VMReg thread_register();\n+\n+  static void continuation_enter_cleanup(MacroAssembler* masm);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -300,1 +300,1 @@\n-BasicLock* StackValue::resolve_monitor_lock(const frame* fr, Location location) {\n+BasicLock* StackValue::resolve_monitor_lock(const frame& fr, Location location) {\n@@ -311,1 +311,1 @@\n-  return (BasicLock*) (fr->unextended_sp() + word_offset);\n+  return (BasicLock*) (fr.unextended_sp() + word_offset);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -192,0 +192,1 @@\n+address StubRoutines::_cont_preempt_stub = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -295,0 +295,1 @@\n+  static address _cont_preempt_stub;\n@@ -507,0 +508,1 @@\n+  static address cont_preempt_stub()   { return _cont_preempt_stub; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-    if (mon->owner() != current) return false;  \/\/ slow-path for IMS exception\n+    if (!mon->has_owner(current)) return false;  \/\/ slow-path for IMS exception\n@@ -445,1 +445,0 @@\n-    JavaThread* const owner = static_cast<JavaThread*>(m->owner_raw());\n@@ -452,1 +451,1 @@\n-    if (owner == current) {\n+    if (m->has_owner(current)) {\n@@ -469,1 +468,1 @@\n-    if (owner == nullptr && m->try_set_owner_from(nullptr, current) == nullptr) {\n+    if (!m->has_owner() && m->try_set_owner(current)) {\n@@ -685,1 +684,1 @@\n-  assert(!monitor->is_owner_anonymous(), \"must not be\");\n+  assert(!monitor->has_anonymous_owner(), \"must not be\");\n@@ -694,0 +693,4 @@\n+  \/\/ Top native frames in the stack will not be seen if we attempt\n+  \/\/ preemption, since we start walking from the last Java anchor.\n+  NoPreemptMark npm(current);\n+\n@@ -756,1 +759,1 @@\n-ObjectLocker::ObjectLocker(Handle obj, JavaThread* thread) {\n+ObjectLocker::ObjectLocker(Handle obj, JavaThread* thread) : _npm(thread) {\n@@ -1214,1 +1217,1 @@\n-    return Threads::owning_thread_from_monitor_owner(t_list, (address) mark.locker());\n+    return Threads::owning_thread_from_stacklock(t_list, (address) mark.locker());\n@@ -1278,1 +1281,1 @@\n-    if (monitor->has_owner() && filter(monitor->owner_raw())) {\n+    if (monitor->has_owner() && filter(monitor)) {\n@@ -1289,1 +1292,8 @@\n-  auto thread_filter = [&](void* owner) { return owner == thread; };\n+  int64_t key = ObjectMonitor::owner_from(thread);\n+  auto thread_filter = [&](ObjectMonitor* monitor) { return monitor->owner() == key; };\n+  return owned_monitors_iterate_filtered(closure, thread_filter);\n+}\n+\n+void ObjectSynchronizer::owned_monitors_iterate(MonitorClosure* closure, oop vthread) {\n+  int64_t key = ObjectMonitor::owner_from(vthread);\n+  auto thread_filter = [&](ObjectMonitor* monitor) { return monitor->owner() == key; };\n@@ -1295,1 +1305,1 @@\n-  auto all_filter = [&](void* owner) { return true; };\n+  auto all_filter = [&](ObjectMonitor* monitor) { return true; };\n@@ -1467,1 +1477,1 @@\n-  return inflate_impl(obj, cause);\n+  return inflate_impl(current->is_Java_thread() ? JavaThread::cast(current) : nullptr, obj, cause);\n@@ -1473,1 +1483,1 @@\n-  return inflate_impl(obj, cause);\n+  return inflate_impl(thread, obj, cause);\n@@ -1476,1 +1486,1 @@\n-ObjectMonitor* ObjectSynchronizer::inflate_impl(oop object, const InflateCause cause) {\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* locking_thread, oop object, const InflateCause cause) {\n@@ -1480,0 +1490,6 @@\n+  \/\/ The JavaThread* locking_thread requires that the locking_thread == Thread::current() or\n+  \/\/ is suspended throughout the call by some other mechanism.\n+  \/\/ The thread might be nullptr when called from a non JavaThread. (As may still be\n+  \/\/ the case from FastHashCode). However it is only important for correctness that the\n+  \/\/ thread is set when called from ObjectSynchronizer::enter from the owning thread,\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n@@ -1487,1 +1503,3 @@\n-    \/\/ *  inflated     - Just return it.\n+    \/\/ *  inflated     - If the ObjectMonitor owner is anonymous and the\n+    \/\/                   locking_thread owns the object lock, then we\n+    \/\/                   make the locking_thread the ObjectMonitor owner.\n@@ -1498,0 +1516,7 @@\n+      if (inf->has_anonymous_owner() && locking_thread != nullptr) {\n+        assert(LockingMode == LM_LEGACY, \"invariant\");\n+        if (locking_thread->is_lock_owned((address)inf->stack_locker())) {\n+          inf->set_stack_locker(nullptr);\n+          inf->set_owner_from_anonymous(locking_thread);\n+        }\n+      }\n@@ -1574,2 +1599,0 @@\n-      \/\/ Optimization: if the mark.locker stack address is associated\n-      \/\/ with this thread we could simply set m->_owner = current.\n@@ -1579,1 +1602,8 @@\n-      m->set_owner_from(nullptr, mark.locker());\n+      if (locking_thread != nullptr && locking_thread->is_lock_owned((address)mark.locker())) {\n+        m->set_owner(locking_thread);\n+      } else {\n+        \/\/ Use ANONYMOUS_OWNER to indicate that the owner is the BasicLock on the stack,\n+        \/\/ and set the stack locker field in the monitor.\n+        m->set_stack_locker(mark.locker());\n+        m->set_anonymous_owner();\n+      }\n@@ -2102,1 +2132,1 @@\n-                   monitor->is_busy(), hash != 0, monitor->owner() != nullptr,\n+                   monitor->is_busy(), hash != 0, monitor->has_owner(),\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -169,2 +169,4 @@\n-  JFR_ONLY(assert(JFR_JVM_THREAD_ID(thread) == static_cast<traceid>(java_lang_Thread::thread_id(thread_oop())),\n-             \"initial tid mismatch\");)\n+  DEBUG_ONLY(int64_t main_thread_tid = java_lang_Thread::thread_id(thread_oop());)\n+  assert(main_thread_tid == ThreadIdentifier::initial(), \"\");\n+  assert(main_thread_tid == thread->lock_id(), \"\");\n+  JFR_ONLY(assert(JFR_JVM_THREAD_ID(thread) == static_cast<traceid>(main_thread_tid), \"initial tid mismatch\");)\n@@ -539,0 +541,4 @@\n+  \/\/ Set the lock_id now since we will run Java code before the Thread instance\n+  \/\/ is even created. The same value will be assigned to the Thread instance on init.\n+  main_thread->set_lock_id(ThreadIdentifier::next());\n+\n@@ -590,0 +596,2 @@\n+  ObjectMonitor::Initialize2();\n+\n@@ -1235,10 +1243,2 @@\n-JavaThread *Threads::owning_thread_from_monitor_owner(ThreadsList * t_list,\n-                                                      address owner) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Not with new lightweight locking\");\n-  \/\/ null owner means not locked so we can skip the search\n-  if (owner == nullptr) return nullptr;\n-\n-  for (JavaThread* p : *t_list) {\n-    \/\/ first, see if owner is the address of a Java thread\n-    if (owner == (address)p) return p;\n-  }\n+JavaThread *Threads::owning_thread_from_stacklock(ThreadsList * t_list, address basicLock) {\n+  assert(LockingMode == LM_LEGACY, \"Not with new lightweight locking\");\n@@ -1246,9 +1246,0 @@\n-  \/\/ Cannot assert on lack of success here since this function may be\n-  \/\/ used by code that is trying to report useful problem information\n-  \/\/ like deadlock detection.\n-  if (LockingMode == LM_MONITOR) return nullptr;\n-\n-  \/\/ If we didn't find a matching Java thread and we didn't force use of\n-  \/\/ heavyweight monitors, then the owner is the stack address of the\n-  \/\/ Lock Word in the owning Java thread's stack.\n-  \/\/\n@@ -1257,1 +1248,1 @@\n-    if (q->is_lock_owned(owner)) {\n+    if (q->is_lock_owned(basicLock)) {\n@@ -1262,2 +1253,0 @@\n-\n-  \/\/ cannot assert on lack of success here; see above comment\n@@ -1284,2 +1273,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    if (monitor->is_owner_anonymous()) {\n+  if (monitor->has_anonymous_owner()) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -1288,3 +1277,2 @@\n-      Thread* owner = reinterpret_cast<Thread*>(monitor->owner());\n-      assert(owner == nullptr || owner->is_Java_thread(), \"only JavaThreads own monitors\");\n-      return reinterpret_cast<JavaThread*>(owner);\n+      assert(LockingMode == LM_LEGACY, \"invariant\");\n+      return owning_thread_from_stacklock(t_list, (address)monitor->stack_locker());\n@@ -1293,2 +1281,8 @@\n-    address owner = (address)monitor->owner();\n-    return owning_thread_from_monitor_owner(t_list, owner);\n+    JavaThread* the_owner = nullptr;\n+    for (JavaThread* q : *t_list) {\n+      if (monitor->has_owner(q)) {\n+        the_owner = q;\n+        break;\n+      }\n+    }\n+    return the_owner;\n@@ -1346,11 +1340,4 @@\n-        const oop thread_oop = p->threadObj();\n-        if (thread_oop != nullptr) {\n-          if (p->is_vthread_mounted()) {\n-            const oop vt = p->vthread();\n-            assert(vt != nullptr, \"vthread should not be null when vthread is mounted\");\n-            \/\/ JavaThread._vthread can refer to the carrier thread. Print only if _vthread refers to a virtual thread.\n-            if (vt != thread_oop) {\n-              st->print_cr(\"   Mounted virtual thread #\" INT64_FORMAT, (int64_t)java_lang_Thread::thread_id(vt));\n-              p->print_vthread_stack_on(st);\n-            }\n-          }\n+        if (p->is_vthread_mounted()) {\n+          \/\/ _lock_id is the thread ID of the mounted virtual thread\n+          st->print_cr(\"   Mounted virtual thread #\" INT64_FORMAT, p->lock_id());\n+          p->print_vthread_stack_on(st);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":29,"deletions":42,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-  template(RendezvousGCThreads)\n+  template(RendezvousGCThreads)                   \\\n+  template(ReinitializeMDO)\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-\/\/ Hash table of void* to a list of ObjectMonitor* owned by the JavaThread.\n+\/\/ Hash table of int64_t to a list of ObjectMonitor* owned by the JavaThread.\n@@ -280,1 +280,1 @@\n-\/\/ address in the JavaThread so we use \"void*\".\n+\/\/ address in the JavaThread so we use \"int64_t\".\n@@ -284,1 +284,1 @@\n-  static unsigned int ptr_hash(void* const& s1) {\n+  static unsigned int ptr_hash(int64_t const& s1) {\n@@ -297,1 +297,1 @@\n-  typedef ResourceHashtable<void*, ObjectMonitorLinkedList*, 1031, AnyObj::C_HEAP, mtThread,\n+  typedef ResourceHashtable<int64_t, ObjectMonitorLinkedList*, 1031, AnyObj::C_HEAP, mtThread,\n@@ -303,1 +303,1 @@\n-  void add_list(void* key, ObjectMonitorLinkedList* list) {\n+  void add_list(int64_t key, ObjectMonitorLinkedList* list) {\n@@ -308,1 +308,1 @@\n-  ObjectMonitorLinkedList* get_list(void* key) {\n+  ObjectMonitorLinkedList* get_list(int64_t key) {\n@@ -314,1 +314,1 @@\n-    void* key = monitor->owner();\n+    int64_t key = monitor->owner();\n@@ -338,1 +338,1 @@\n-      bool do_entry(void*& key, ObjectMonitorLinkedList*& list) {\n+      bool do_entry(int64_t& key, ObjectMonitorLinkedList*& list) {\n@@ -353,1 +353,1 @@\n-    if (monitor->is_owner_anonymous()) {\n+    if (monitor->has_anonymous_owner()) {\n@@ -371,1 +371,2 @@\n-    ObjectMonitorLinkedList* list = get_list(thread);\n+    int64_t key = ObjectMonitor::owner_from(thread);\n+    ObjectMonitorLinkedList* list = get_list(key);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -670,0 +670,1 @@\n+  nonstatic_field(JavaThread,                  _lock_id,                                      int64_t)                               \\\n@@ -790,1 +791,2 @@\n-  unchecked_nonstatic_field(ObjectMonitor,     _owner,                                        sizeof(void *)) \/* NOTE: no type *\/    \\\n+  volatile_nonstatic_field(ObjectMonitor,      _owner,                                        int64_t)                               \\\n+  volatile_nonstatic_field(ObjectMonitor,      _stack_locker,                                 BasicLock*)                            \\\n@@ -2012,2 +2014,0 @@\n-  declare_constant(LogKlassAlignmentInBytes)                              \\\n-                                                                          \\\n@@ -2518,0 +2518,1 @@\n+  LP64_ONLY(declare_constant(markWord::klass_shift))                      \\\n@@ -2541,0 +2542,1 @@\n+  declare_constant(ObjectMonitor::NO_OWNER)                               \\\n@@ -2542,0 +2544,1 @@\n+  declare_constant(ObjectMonitor::DEFLATER_MARKER)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2379,3 +2379,6 @@\n-          \/\/ JNI locals for the top frame.\n-          assert(_java_thread != nullptr, \"impossible for unmounted vthread\");\n-          _java_thread->active_handles()->oops_do(&blk);\n+          \/\/ JNI locals for the top frame if mounted\n+          assert(_java_thread != nullptr || jvf->method()->is_synchronized()\n+                 || jvf->method()->is_object_wait0(), \"impossible for unmounted vthread\");\n+          if (_java_thread != nullptr) {\n+            _java_thread->active_handles()->oops_do(&blk);\n+          }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -397,6 +397,0 @@\n-     * <p>If a security manager is installed, this constructor will check for\n-     * the \"enableSubclassImplementation\" SerializablePermission when invoked\n-     * directly or indirectly by the constructor of a subclass which overrides\n-     * the ObjectInputStream.readFields or ObjectInputStream.readUnshared\n-     * methods.\n-     *\n@@ -406,2 +400,0 @@\n-     * @throws  SecurityException if untrusted subclass illegally overrides\n-     *          security-sensitive methods\n@@ -442,8 +434,0 @@\n-     * <p>If there is a security manager installed, this method first calls the\n-     * security manager's {@code checkPermission} method with the\n-     * {@code SerializablePermission(\"enableSubclassImplementation\")}\n-     * permission to ensure it's ok to enable subclassing.\n-     *\n-     * @throws  SecurityException if a security manager exists and its\n-     *          {@code checkPermission} method denies enabling\n-     *          subclassing.\n@@ -453,3 +437,1 @@\n-     * @see SecurityManager#checkPermission\n-     * @see java.io.SerializablePermission\n-    protected ObjectInputStream() throws IOException, SecurityException {\n+    protected ObjectInputStream() throws IOException {\n@@ -630,9 +612,0 @@\n-     * <p>Serialization and deserialization of value classes is described in\n-     * {@linkplain ObjectOutputStream##valueclass-serialization value class serialization}.\n-     *\n-     * <p>ObjectInputStream subclasses which override this method can only be\n-     * constructed in security contexts possessing the\n-     * \"enableSubclassImplementation\" SerializablePermission; any attempt to\n-     * instantiate such a subclass without this permission will cause a\n-     * SecurityException to be thrown.\n-     *\n@@ -957,8 +930,0 @@\n-     * <p>If object replacement is currently not enabled, and\n-     * {@code enable} is true, and there is a security manager installed,\n-     * this method first calls the security manager's\n-     * {@code checkPermission} method with the\n-     * {@code SerializablePermission(\"enableSubstitution\")} permission to\n-     * ensure that the caller is permitted to enable the stream to do replacement\n-     * of objects read from the stream.\n-     *\n@@ -968,8 +933,1 @@\n-     * @throws  SecurityException if a security manager exists and its\n-     *          {@code checkPermission} method denies enabling the stream\n-     *          to do replacement of objects read from the stream.\n-     * @see SecurityManager#checkPermission\n-     * @see java.io.SerializablePermission\n-    protected boolean enableResolveObject(boolean enable)\n-        throws SecurityException\n-    {\n+    protected boolean enableResolveObject(boolean enable) {\n@@ -1375,2 +1333,0 @@\n-     * @throws SecurityException if there is security manager and the\n-     *       {@code SerializablePermission(\"serialFilter\")} is not granted\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":2,"deletions":46,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -275,6 +275,0 @@\n-     * <p>If a security manager is installed, this constructor will check for\n-     * the \"enableSubclassImplementation\" SerializablePermission when invoked\n-     * directly or indirectly by the constructor of a subclass which overrides\n-     * the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared\n-     * methods.\n-     *\n@@ -283,2 +277,0 @@\n-     * @throws  SecurityException if untrusted subclass illegally overrides\n-     *          security-sensitive methods\n@@ -312,11 +304,1 @@\n-     * <p>If there is a security manager installed, this method first calls the\n-     * security manager's {@code checkPermission} method with a\n-     * {@code SerializablePermission(\"enableSubclassImplementation\")}\n-     * permission to ensure it's ok to enable subclassing.\n-     *\n-     * @throws  SecurityException if a security manager exists and its\n-     *          {@code checkPermission} method denies enabling\n-     *          subclassing.\n-     * @see SecurityManager#checkPermission\n-     * @see java.io.SerializablePermission\n-    protected ObjectOutputStream() throws IOException, SecurityException {\n+    protected ObjectOutputStream() throws IOException {\n@@ -455,9 +437,0 @@\n-     * <p>Serialization and deserialization of value classes is described in\n-     * {@linkplain ObjectOutputStream##valueclass-serialization value class serialization}.\n-     *\n-     * <p>ObjectOutputStream subclasses which override this method can only be\n-     * constructed in security contexts possessing the\n-     * \"enableSubclassImplementation\" SerializablePermission; any attempt to\n-     * instantiate such a subclass without this permission will cause a\n-     * SecurityException to be thrown.\n-     *\n@@ -655,8 +628,0 @@\n-     * <p>If object replacement is currently not enabled, and\n-     * {@code enable} is true, and there is a security manager installed,\n-     * this method first calls the security manager's\n-     * {@code checkPermission} method with the\n-     * {@code SerializablePermission(\"enableSubstitution\")} permission to\n-     * ensure that the caller is permitted to enable the stream to do replacement\n-     * of objects written to the stream.\n-     *\n@@ -666,8 +631,1 @@\n-     * @throws  SecurityException if a security manager exists and its\n-     *          {@code checkPermission} method denies enabling the stream\n-     *          to do replacement of objects written to the stream.\n-     * @see SecurityManager#checkPermission\n-     * @see java.io.SerializablePermission\n-    protected boolean enableReplaceObject(boolean enable)\n-        throws SecurityException\n-    {\n+    protected boolean enableReplaceObject(boolean enable) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":2,"deletions":44,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -281,2 +281,0 @@\n-     * @throws  SecurityException for the same reasons as\n-     *          {@link System#getProperty(String) System.getProperty}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Boolean.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -539,5 +539,0 @@\n-     * @throws    SecurityException\n-     *            if a security manager is present, and the {@code loader} is\n-     *            {@code null}, and the caller's class loader is not\n-     *            {@code null}, and the caller does not have the\n-     *            {@link RuntimePermission}{@code (\"getClassLoader\")}\n@@ -619,2 +614,0 @@\n-     * The security check is a stack-based permission check if the caller\n-     * loads a class in another module.\n@@ -632,10 +625,0 @@\n-     * @throws SecurityException\n-     *         <ul>\n-     *         <li> if the caller is not the specified module and\n-     *         {@code RuntimePermission(\"getClassLoader\")} permission is denied; or<\/li>\n-     *         <li> access to the module content is denied. For example,\n-     *         permission check will be performed when a class loader calls\n-     *         {@link ModuleReader#open(String)} to read the bytes of a class file\n-     *         in a module.<\/li>\n-     *         <\/ul>\n-     *\n@@ -798,7 +781,0 @@\n-     * @throws  SecurityException\n-     *          If a security manager, <i>s<\/i>, is present and\n-     *          the caller's class loader is not the same as or an\n-     *          ancestor of the class loader for the current class and\n-     *          invocation of {@link SecurityManager#checkPackageAccess\n-     *          s.checkPackageAccess()} denies access to the package\n-     *          of this class.\n@@ -1099,8 +1075,0 @@\n-     * @throws  SecurityException\n-     *          if a security manager is present, and the caller's class loader\n-     *          is not {@code null} and is not the same as or an ancestor of the\n-     *          class loader for the class whose class loader is requested,\n-     *          and the caller does not have the\n-     *          {@link RuntimePermission}{@code (\"getClassLoader\")}\n-     * @see SecurityManager#checkPermission\n-     * @see java.lang.RuntimePermission\n@@ -1594,20 +1562,0 @@\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and any of the\n-     *         following conditions is met:\n-     *\n-     *         <ul>\n-     *\n-     *         <li> the caller's class loader is not the same as the\n-     *         class loader of the enclosing class and invocation of\n-     *         {@link SecurityManager#checkPermission\n-     *         s.checkPermission} method with\n-     *         {@code RuntimePermission(\"accessDeclaredMembers\")}\n-     *         denies access to the methods within the enclosing class\n-     *\n-     *         <li> the caller's class loader is not the same as or an\n-     *         ancestor of the class loader for the enclosing class and\n-     *         invocation of {@link SecurityManager#checkPackageAccess\n-     *         s.checkPackageAccess()} denies access to the package\n-     *         of the enclosing class\n-     *\n-     *         <\/ul>\n@@ -1617,1 +1565,1 @@\n-    public Method getEnclosingMethod() throws SecurityException {\n+    public Method getEnclosingMethod() {\n@@ -1750,20 +1698,1 @@\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and any of the\n-     *         following conditions is met:\n-     *\n-     *         <ul>\n-     *\n-     *         <li> the caller's class loader is not the same as the\n-     *         class loader of the enclosing class and invocation of\n-     *         {@link SecurityManager#checkPermission\n-     *         s.checkPermission} method with\n-     *         {@code RuntimePermission(\"accessDeclaredMembers\")}\n-     *         denies access to the constructors within the enclosing class\n-     *\n-     *         <li> the caller's class loader is not the same as or an\n-     *         ancestor of the class loader for the enclosing class and\n-     *         invocation of {@link SecurityManager#checkPackageAccess\n-     *         s.checkPackageAccess()} denies access to the package\n-     *         of the enclosing class\n-     *\n-     *         <\/ul>\n+     *\n@@ -1773,1 +1702,1 @@\n-    public Constructor<?> getEnclosingConstructor() throws SecurityException {\n+    public Constructor<?> getEnclosingConstructor() {\n@@ -1830,6 +1759,0 @@\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and the caller's\n-     *         class loader is not the same as or an ancestor of the class\n-     *         loader for the declaring class and invocation of {@link\n-     *         SecurityManager#checkPackageAccess s.checkPackageAccess()}\n-     *         denies access to the package of the declaring class\n@@ -1839,1 +1762,1 @@\n-    public Class<?> getDeclaringClass() throws SecurityException {\n+    public Class<?> getDeclaringClass() {\n@@ -1861,6 +1784,0 @@\n-     * @throws     SecurityException\n-     *             If a security manager, <i>s<\/i>, is present and the caller's\n-     *             class loader is not the same as or an ancestor of the class\n-     *             loader for the enclosing class and invocation of {@link\n-     *             SecurityManager#checkPackageAccess s.checkPackageAccess()}\n-     *             denies access to the package of the enclosing class\n@@ -1870,1 +1787,1 @@\n-    public Class<?> getEnclosingClass() throws SecurityException {\n+    public Class<?> getEnclosingClass() {\n@@ -2125,8 +2042,0 @@\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and\n-     *         the caller's class loader is not the same as or an\n-     *         ancestor of the class loader for the current class and\n-     *         invocation of {@link SecurityManager#checkPackageAccess\n-     *         s.checkPackageAccess()} denies access to the package\n-     *         of this class.\n-     *\n@@ -2193,7 +2102,0 @@\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and\n-     *         the caller's class loader is not the same as or an\n-     *         ancestor of the class loader for the current class and\n-     *         invocation of {@link SecurityManager#checkPackageAccess\n-     *         s.checkPackageAccess()} denies access to the package\n-     *         of this class.\n@@ -2206,1 +2108,1 @@\n-    public Field[] getFields() throws SecurityException {\n+    public Field[] getFields() {\n@@ -2284,7 +2186,0 @@\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and\n-     *         the caller's class loader is not the same as or an\n-     *         ancestor of the class loader for the current class and\n-     *         invocation of {@link SecurityManager#checkPackageAccess\n-     *         s.checkPackageAccess()} denies access to the package\n-     *         of this class.\n@@ -2297,1 +2192,1 @@\n-    public Method[] getMethods() throws SecurityException {\n+    public Method[] getMethods() {\n@@ -2327,7 +2222,0 @@\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and\n-     *         the caller's class loader is not the same as or an\n-     *         ancestor of the class loader for the current class and\n-     *         invocation of {@link SecurityManager#checkPackageAccess\n-     *         s.checkPackageAccess()} denies access to the package\n-     *         of this class.\n@@ -2339,1 +2227,1 @@\n-    public Constructor<?>[] getConstructors() throws SecurityException {\n+    public Constructor<?>[] getConstructors() {\n@@ -2379,7 +2267,0 @@\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and\n-     *         the caller's class loader is not the same as or an\n-     *         ancestor of the class loader for the current class and\n-     *         invocation of {@link SecurityManager#checkPackageAccess\n-     *         s.checkPackageAccess()} denies access to the package\n-     *         of this class.\n@@ -2392,2 +2273,1 @@\n-    public Field getField(String name)\n-        throws NoSuchFieldException, SecurityException {\n+    public Field getField(String name) throws NoSuchFieldException {\n@@ -2490,7 +2370,0 @@\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and\n-     *         the caller's class loader is not the same as or an\n-     *         ancestor of the class loader for the current class and\n-     *         invocation of {@link SecurityManager#checkPackageAccess\n-     *         s.checkPackageAccess()} denies access to the package\n-     *         of this class.\n@@ -2504,1 +2377,1 @@\n-        throws NoSuchMethodException, SecurityException {\n+            throws NoSuchMethodException {\n@@ -2539,9 +2412,2 @@\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and\n-     *         the caller's class loader is not the same as or an\n-     *         ancestor of the class loader for the current class and\n-     *         invocation of {@link SecurityManager#checkPackageAccess\n-     *         s.checkPackageAccess()} denies access to the package\n-     *         of this class.\n-     *\n-     * @see #getDeclaredConstructor(Class<?>[])\n+     *\n+     * @see #getDeclaredConstructor(Class[])\n@@ -2552,2 +2418,1 @@\n-        throws NoSuchMethodException, SecurityException\n-    {\n+            throws NoSuchMethodException {\n@@ -2576,20 +2441,0 @@\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and any of the\n-     *         following conditions is met:\n-     *\n-     *         <ul>\n-     *\n-     *         <li> the caller's class loader is not the same as the\n-     *         class loader of this class and invocation of\n-     *         {@link SecurityManager#checkPermission\n-     *         s.checkPermission} method with\n-     *         {@code RuntimePermission(\"accessDeclaredMembers\")}\n-     *         denies access to the declared classes within this class\n-     *\n-     *         <li> the caller's class loader is not the same as or an\n-     *         ancestor of the class loader for the current class and\n-     *         invocation of {@link SecurityManager#checkPackageAccess\n-     *         s.checkPackageAccess()} denies access to the package\n-     *         of this class\n-     *\n-     *         <\/ul>\n@@ -2601,1 +2446,1 @@\n-    public Class<?>[] getDeclaredClasses() throws SecurityException {\n+    public Class<?>[] getDeclaredClasses() {\n@@ -2628,20 +2473,0 @@\n-     * @throws  SecurityException\n-     *          If a security manager, <i>s<\/i>, is present and any of the\n-     *          following conditions is met:\n-     *\n-     *          <ul>\n-     *\n-     *          <li> the caller's class loader is not the same as the\n-     *          class loader of this class and invocation of\n-     *          {@link SecurityManager#checkPermission\n-     *          s.checkPermission} method with\n-     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n-     *          denies access to the declared fields within this class\n-     *\n-     *          <li> the caller's class loader is not the same as or an\n-     *          ancestor of the class loader for the current class and\n-     *          invocation of {@link SecurityManager#checkPackageAccess\n-     *          s.checkPackageAccess()} denies access to the package\n-     *          of this class\n-     *\n-     *          <\/ul>\n@@ -2654,1 +2479,1 @@\n-    public Field[] getDeclaredFields() throws SecurityException {\n+    public Field[] getDeclaredFields() {\n@@ -2691,20 +2516,0 @@\n-     * @throws  SecurityException\n-     *          If a security manager, <i>s<\/i>, is present and any of the\n-     *          following conditions is met:\n-     *\n-     *          <ul>\n-     *\n-     *          <li> the caller's class loader is not the same as the\n-     *          class loader of this class and invocation of\n-     *          {@link SecurityManager#checkPermission\n-     *          s.checkPermission} method with\n-     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n-     *          denies access to the declared methods within this class\n-     *\n-     *          <li> the caller's class loader is not the same as or an\n-     *          ancestor of the class loader for the current class and\n-     *          invocation of {@link SecurityManager#checkPackageAccess\n-     *          s.checkPackageAccess()} denies access to the package\n-     *          of this class\n-     *\n-     *          <\/ul>\n@@ -2759,20 +2564,0 @@\n-     * @throws  SecurityException\n-     *          If a security manager, <i>s<\/i>, is present and any of the\n-     *          following conditions is met:\n-     *\n-     *          <ul>\n-     *\n-     *          <li> the caller's class loader is not the same as the\n-     *          class loader of this class and invocation of\n-     *          {@link SecurityManager#checkPermission\n-     *          s.checkPermission} method with\n-     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n-     *          denies access to the declared methods within this class\n-     *\n-     *          <li> the caller's class loader is not the same as or an\n-     *          ancestor of the class loader for the current class and\n-     *          invocation of {@link SecurityManager#checkPackageAccess\n-     *          s.checkPackageAccess()} denies access to the package\n-     *          of this class\n-     *\n-     *          <\/ul>\n@@ -2788,1 +2573,1 @@\n-    public Method[] getDeclaredMethods() throws SecurityException {\n+    public Method[] getDeclaredMethods() {\n@@ -2813,20 +2598,0 @@\n-     * @throws  SecurityException\n-     *          If a security manager, <i>s<\/i>, is present and any of the\n-     *          following conditions is met:\n-     *\n-     *          <ul>\n-     *\n-     *          <li> the caller's class loader is not the same as the\n-     *          class loader of this class and invocation of\n-     *          {@link SecurityManager#checkPermission\n-     *          s.checkPermission} method with\n-     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n-     *          denies access to the declared constructors within this class\n-     *\n-     *          <li> the caller's class loader is not the same as or an\n-     *          ancestor of the class loader for the current class and\n-     *          invocation of {@link SecurityManager#checkPackageAccess\n-     *          s.checkPackageAccess()} denies access to the package\n-     *          of this class\n-     *\n-     *          <\/ul>\n@@ -2839,1 +2604,1 @@\n-    public Constructor<?>[] getDeclaredConstructors() throws SecurityException {\n+    public Constructor<?>[] getDeclaredConstructors() {\n@@ -2864,20 +2629,0 @@\n-     * @throws  SecurityException\n-     *          If a security manager, <i>s<\/i>, is present and any of the\n-     *          following conditions is met:\n-     *\n-     *          <ul>\n-     *\n-     *          <li> the caller's class loader is not the same as the\n-     *          class loader of this class and invocation of\n-     *          {@link SecurityManager#checkPermission\n-     *          s.checkPermission} method with\n-     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n-     *          denies access to the declared field\n-     *\n-     *          <li> the caller's class loader is not the same as or an\n-     *          ancestor of the class loader for the current class and\n-     *          invocation of {@link SecurityManager#checkPackageAccess\n-     *          s.checkPackageAccess()} denies access to the package\n-     *          of this class\n-     *\n-     *          <\/ul>\n@@ -2890,2 +2635,1 @@\n-    public Field getDeclaredField(String name)\n-        throws NoSuchFieldException, SecurityException {\n+    public Field getDeclaredField(String name) throws NoSuchFieldException {\n@@ -2930,20 +2674,0 @@\n-     * @throws  SecurityException\n-     *          If a security manager, <i>s<\/i>, is present and any of the\n-     *          following conditions is met:\n-     *\n-     *          <ul>\n-     *\n-     *          <li> the caller's class loader is not the same as the\n-     *          class loader of this class and invocation of\n-     *          {@link SecurityManager#checkPermission\n-     *          s.checkPermission} method with\n-     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n-     *          denies access to the declared method\n-     *\n-     *          <li> the caller's class loader is not the same as or an\n-     *          ancestor of the class loader for the current class and\n-     *          invocation of {@link SecurityManager#checkPackageAccess\n-     *          s.checkPackageAccess()} denies access to the package\n-     *          of this class\n-     *\n-     *          <\/ul>\n@@ -2957,1 +2681,1 @@\n-        throws NoSuchMethodException, SecurityException {\n+            throws NoSuchMethodException {\n@@ -3028,21 +2752,1 @@\n-     * @throws  SecurityException\n-     *          If a security manager, <i>s<\/i>, is present and any of the\n-     *          following conditions is met:\n-     *\n-     *          <ul>\n-     *\n-     *          <li> the caller's class loader is not the same as the\n-     *          class loader of this class and invocation of\n-     *          {@link SecurityManager#checkPermission\n-     *          s.checkPermission} method with\n-     *          {@code RuntimePermission(\"accessDeclaredMembers\")}\n-     *          denies access to the declared constructor\n-     *\n-     *          <li> the caller's class loader is not the same as or an\n-     *          ancestor of the class loader for the current class and\n-     *          invocation of {@link SecurityManager#checkPackageAccess\n-     *          s.checkPackageAccess()} denies access to the package\n-     *          of this class\n-     *          <\/ul>\n-     *\n-     * @see #getConstructor(Class<?>[])\n+     * @see #getConstructor(Class[])\n@@ -3054,2 +2758,1 @@\n-        throws NoSuchMethodException, SecurityException\n-    {\n+            throws NoSuchMethodException {\n@@ -3111,1 +2814,1 @@\n-     *          resource with this name is found, the resource is in a package\n+     *          resource with this name is found, or the resource is in a package\n@@ -3113,2 +2816,1 @@\n-     *          least the caller module, or access to the resource is denied\n-     *          by the security manager.\n+     *          least the caller module.\n@@ -3207,1 +2909,1 @@\n-     *         this name is found, the resource cannot be located by a URL, the\n+     *         this name is found, the resource cannot be located by a URL, or the\n@@ -3210,2 +2912,1 @@\n-     *         module, or access to the resource is denied by the security\n-     *         manager.\n+     *         module.\n@@ -3277,6 +2978,1 @@\n-     * Returns the {@code ProtectionDomain} of this class.  If there is a\n-     * security manager installed, this method first calls the security\n-     * manager's {@code checkPermission} method with a\n-     * {@code RuntimePermission(\"getProtectionDomain\")} permission to\n-     * ensure it's ok to get the\n-     * {@code ProtectionDomain}.\n+     * Returns the {@code ProtectionDomain} of this class.\n@@ -3286,7 +2982,0 @@\n-     * @throws SecurityException\n-     *        if a security manager exists and its\n-     *        {@code checkPermission} method doesn't allow\n-     *        getting the ProtectionDomain.\n-     *\n-     * @see SecurityManager#checkPermission\n-     * @see java.lang.RuntimePermission\n@@ -4519,7 +4208,0 @@\n-     * @throws SecurityException\n-     *         If the returned class is not the current class, and\n-     *         if a security manager, <i>s<\/i>, is present and the caller's\n-     *         class loader is not the same as or an ancestor of the class\n-     *         loader for the returned class and invocation of {@link\n-     *         SecurityManager#checkPackageAccess s.checkPackageAccess()}\n-     *         denies access to the package of the returned class\n@@ -4610,8 +4292,0 @@\n-     * @throws SecurityException\n-     * If any returned class is not the current class, and\n-     * if a security manager, <i>s<\/i>, is present and the caller's\n-     * class loader is not the same as or an ancestor of the class\n-     * loader for that returned class and invocation of {@link\n-     * SecurityManager#checkPackageAccess s.checkPackageAccess()}\n-     * denies access to the package of that returned class\n-     *\n@@ -4804,9 +4478,2 @@\n-     * @return an array of {@code Class} objects of the permitted subclasses of this class or interface,\n-     *         or {@code null} if this class or interface is not sealed.\n-     *\n-     * @throws SecurityException\n-     *         If a security manager, <i>s<\/i>, is present and the caller's\n-     *         class loader is not the same as or an ancestor of the class\n-     *         loader for that returned class and invocation of {@link\n-     *         SecurityManager#checkPackageAccess s.checkPackageAccess()}\n-     *         denies access to the package of any class in the returned array.\n+     * @return an array of {@code Class} objects of the permitted subclasses of this class\n+     *         or interface, or {@code null} if this class or interface is not sealed.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":28,"deletions":361,"binary":false,"changes":389,"status":"modified"},{"patch":"@@ -388,3 +388,3 @@\n-     * A constant holding a Not-a-Number (NaN) value of type\n-     * {@code double}. It is equivalent to the value returned by\n-     * {@code Double.longBitsToDouble(0x7ff8000000000000L)}.\n+     * A constant holding a Not-a-Number (NaN) value of type {@code double}.\n+     * It is {@linkplain Double##equivalenceRelation equivalent} to the\n+     * value returned by {@code Double.longBitsToDouble(0x7ff8000000000000L)}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,3 +106,3 @@\n-     * A constant holding a Not-a-Number (NaN) value of type\n-     * {@code float}.  It is equivalent to the value returned by\n-     * {@code Float.intBitsToFloat(0x7fc00000)}.\n+     * A constant holding a Not-a-Number (NaN) value of type {@code float}.\n+     * It is {@linkplain Double##equivalenceRelation equivalent}\n+     * to the value returned by{@code Float.intBitsToFloat(0x7fc00000)}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1201,2 +1201,0 @@\n-     * @throws  SecurityException for the same reasons as\n-     *          {@link System#getProperty(String) System.getProperty}\n@@ -1247,2 +1245,0 @@\n-     * @throws  SecurityException for the same reasons as\n-     *          {@link System#getProperty(String) System.getProperty}\n@@ -1289,2 +1285,0 @@\n-     * @throws  SecurityException for the same reasons as\n-     *          {@link System#getProperty(String) System.getProperty}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1291,2 +1291,0 @@\n-     * @throws  SecurityException for the same reasons as\n-     *          {@link System#getProperty(String) System.getProperty}\n@@ -1336,2 +1334,0 @@\n-     * @throws  SecurityException for the same reasons as\n-     *          {@link System#getProperty(String) System.getProperty}\n@@ -1385,2 +1381,0 @@\n-     * @throws  SecurityException for the same reasons as\n-     *          {@link System#getProperty(String) System.getProperty}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -412,3 +411,2 @@\n-        if (!Thread.currentThread().isVirtual()) {\n-            wait0(timeoutMillis);\n-            return;\n+        if (timeoutMillis < 0) {\n+            throw new IllegalArgumentException(\"timeout value is negative\");\n@@ -417,3 +415,9 @@\n-        \/\/ virtual thread waiting\n-        boolean attempted = Blocker.begin();\n-        try {\n+        if (Thread.currentThread() instanceof VirtualThread vthread) {\n+            try {\n+                wait0(timeoutMillis);\n+            } catch (InterruptedException e) {\n+                \/\/ virtual thread's interrupt status needs to be cleared\n+                vthread.getAndClearInterrupt();\n+                throw e;\n+            }\n+        } else {\n@@ -421,6 +425,0 @@\n-        } catch (InterruptedException e) {\n-            \/\/ virtual thread's interrupt status needs to be cleared\n-            Thread.currentThread().getAndClearInterrupt();\n-            throw e;\n-        } finally {\n-            Blocker.end(attempted);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.lang.invoke.StringConcatFactory;\n@@ -43,1 +42,0 @@\n-import java.lang.reflect.Constructor;\n@@ -47,1 +45,0 @@\n-import java.lang.reflect.Modifier;\n@@ -54,1 +51,0 @@\n-import java.security.AccessControlContext;\n@@ -79,1 +75,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -98,1 +93,0 @@\n-import sun.nio.fs.DefaultFileSystemProvider;\n@@ -197,9 +191,0 @@\n-    \/\/ indicates if a security manager is possible\n-    private static final int NEVER = 1;\n-    private static final int MAYBE = 2;\n-    private static @Stable int allowSecurityManager;\n-\n-    \/\/ current security manager\n-    @SuppressWarnings(\"removal\")\n-    private static volatile SecurityManager security;   \/\/ read by VM\n-\n@@ -211,5 +196,0 @@\n-    \/\/ return true if a security manager is allowed\n-    private static boolean allowSecurityManager() {\n-        return (allowSecurityManager != NEVER);\n-    }\n-\n@@ -219,4 +199,0 @@\n-     * First, if there is a security manager, its {@code checkPermission}\n-     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n-     *  to see if it's ok to reassign the \"standard\" input stream.\n-     *\n@@ -225,8 +201,0 @@\n-     * @throws SecurityException\n-     *        if a security manager exists and its\n-     *        {@code checkPermission} method doesn't allow\n-     *        reassigning of the standard input stream.\n-     *\n-     * @see SecurityManager#checkPermission\n-     * @see java.lang.RuntimePermission\n-     *\n@@ -243,4 +211,0 @@\n-     * First, if there is a security manager, its {@code checkPermission}\n-     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n-     *  to see if it's ok to reassign the \"standard\" output stream.\n-     *\n@@ -249,8 +213,0 @@\n-     * @throws SecurityException\n-     *        if a security manager exists and its\n-     *        {@code checkPermission} method doesn't allow\n-     *        reassigning of the standard output stream.\n-     *\n-     * @see SecurityManager#checkPermission\n-     * @see java.lang.RuntimePermission\n-     *\n@@ -267,4 +223,0 @@\n-     * First, if there is a security manager, its {@code checkPermission}\n-     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n-     *  to see if it's ok to reassign the \"standard\" error output stream.\n-     *\n@@ -273,8 +225,0 @@\n-     * @throws SecurityException\n-     *        if a security manager exists and its\n-     *        {@code checkPermission} method doesn't allow\n-     *        reassigning of the standard error output stream.\n-     *\n-     * @see SecurityManager#checkPermission\n-     * @see java.lang.RuntimePermission\n-     *\n@@ -329,4 +273,0 @@\n-     * @throws  SecurityException\n-     *          If a security manager is present and it does not\n-     *          permit access to the channel.\n-     *\n@@ -366,28 +306,5 @@\n-     * Sets the system-wide security manager.\n-     *\n-     * If there is a security manager already installed, this method first\n-     * calls the security manager's {@code checkPermission} method\n-     * with a {@code RuntimePermission(\"setSecurityManager\")}\n-     * permission to ensure it's ok to replace the existing\n-     * security manager.\n-     * This may result in throwing a {@code SecurityException}.\n-     *\n-     * <p> Otherwise, the argument is established as the current\n-     * security manager. If the argument is {@code null} and no\n-     * security manager has been established, then no action is taken and\n-     * the method simply returns.\n-     *\n-     * @implNote In the JDK implementation, if the Java virtual machine is\n-     * started with the system property {@code java.security.manager} not set or set to\n-     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n-     * method cannot be used to set a security manager. See the following\n-     * <a href=\"SecurityManager.html#set-security-manager\">section of the\n-     * {@code SecurityManager} class specification<\/a> for more details.\n-     *\n-     * @param  sm the security manager or {@code null}\n-     * @throws SecurityException\n-     *         if the security manager has already been set and its {@code\n-     *         checkPermission} method doesn't allow it to be replaced\n-     * @throws UnsupportedOperationException\n-     *         if {@code sm} is non-null and a security manager is not allowed\n-     *         to be set dynamically\n+     * Throws {@code UnsupportedOperationException}. Setting a security manager\n+     * is not supported.\n+     *\n+     * @param  sm ignored\n+     * @throws UnsupportedOperationException always\n@@ -395,8 +312,4 @@\n-     * @see SecurityManager#checkPermission\n-     * @see java.lang.RuntimePermission\n-     * @deprecated This method is only useful in conjunction with\n-     *       {@linkplain SecurityManager the Security Manager}, which is\n-     *       deprecated and subject to removal in a future release.\n-     *       Consequently, this method is also deprecated and subject to\n-     *       removal. There is no replacement for the Security Manager or this\n-     *       method.\n+     * @deprecated This method originally set\n+     *       {@linkplain SecurityManager the system-wide Security Manager}.\n+     *       Setting a Security Manager is no longer supported. There is no\n+     *       replacement for the Security Manager or this method.\n@@ -405,77 +318,2 @@\n-    @CallerSensitive\n-        if (allowSecurityManager()) {\n-            var callerClass = Reflection.getCallerClass();\n-            if (CallersHolder.callers.putIfAbsent(callerClass, true) == null) {\n-                URL url = codeSource(callerClass);\n-                final String source;\n-                if (url == null) {\n-                    source = callerClass.getName();\n-                } else {\n-                    source = callerClass.getName() + \" (\" + url + \")\";\n-                }\n-                initialErr.printf(\"\"\"\n-                        WARNING: A terminally deprecated method in java.lang.System has been called\n-                        WARNING: System::setSecurityManager has been called by %s\n-                        WARNING: Please consider reporting this to the maintainers of %s\n-                        WARNING: System::setSecurityManager will be removed in a future release\n-                        \"\"\", source, callerClass.getName());\n-            }\n-            implSetSecurityManager(sm);\n-        } else {\n-            \/\/ security manager not allowed\n-            if (sm != null) {\n-                throw new UnsupportedOperationException(\n-                    \"The Security Manager is deprecated and will be removed in a future release\");\n-            }\n-        }\n-    }\n-\n-    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n-        if (security == null) {\n-            \/\/ ensure image reader is initialized\n-            Object.class.getResource(\"java\/lang\/ANY\");\n-            \/\/ ensure the default file system is initialized\n-            DefaultFileSystemProvider.theFileSystem();\n-        }\n-        if (sm != null) {\n-            try {\n-                \/\/ pre-populates the SecurityManager.packageAccess cache\n-                \/\/ to avoid recursive permission checking issues with custom\n-                \/\/ SecurityManager implementations\n-                sm.checkPackageAccess(\"java.lang\");\n-            } catch (Exception e) {\n-                \/\/ no-op\n-            }\n-        }\n-        setSecurityManager0(sm);\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static synchronized\n-    void setSecurityManager0(final SecurityManager s) {\n-        SecurityManager sm = getSecurityManager();\n-        if (sm != null) {\n-            \/\/ ask the currently installed security manager if we\n-            \/\/ can replace it.\n-            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n-        }\n-\n-        if ((s != null) && (s.getClass().getClassLoader() != null)) {\n-            \/\/ New security manager class is not on bootstrap classpath.\n-            \/\/ Force policy to get initialized before we install the new\n-            \/\/ security manager, in order to prevent infinite loops when\n-            \/\/ trying to initialize the policy (which usually involves\n-            \/\/ accessing some security and\/or system properties, which in turn\n-            \/\/ calls the installed security manager's checkPermission method\n-            \/\/ which will loop infinitely if there is a non-system class\n-            \/\/ (in this case: the new security manager class) on the stack).\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Object run() {\n-                    s.getClass().getProtectionDomain().implies\n-                        (SecurityConstants.ALL_PERMISSION);\n-                    return null;\n-                }\n-            });\n-        }\n-\n-        security = s;\n+        throw new UnsupportedOperationException(\n+                 \"Setting a Security Manager is not supported\");\n@@ -486,1 +324,1 @@\n-     * Gets the system-wide security manager.\n+     * Returns {@code null}. Setting a security manager is not supported.\n@@ -488,3 +326,1 @@\n-     * @return  if a security manager has already been established for the\n-     *          current application, then that security manager is returned;\n-     *          otherwise, {@code null} is returned.\n+     * @return  {@code null}\n@@ -492,6 +328,4 @@\n-     * @deprecated This method is only useful in conjunction with\n-     *       {@linkplain SecurityManager the Security Manager}, which is\n-     *       deprecated and subject to removal in a future release.\n-     *       Consequently, this method is also deprecated and subject to\n-     *       removal. There is no replacement for the Security Manager or this\n-     *       method.\n+     * @deprecated This method originally returned\n+     *       {@linkplain SecurityManager the system-wide Security Manager}.\n+     *       Setting a Security Manager is no longer supported. There is no\n+     *       replacement for the Security Manager or this method.\n@@ -502,5 +336,1 @@\n-        if (allowSecurityManager()) {\n-            return security;\n-        } else {\n-            return null;\n-        }\n+        return null;\n@@ -694,4 +524,0 @@\n-     *\n-     * First, if there is a security manager, its\n-     * {@code checkPropertiesAccess} method is called with no\n-     * arguments. This may result in a security exception.\n@@ -812,4 +638,0 @@\n-     * Note that even if the security manager does not permit the\n-     * {@code getProperties} operation, it may choose to permit the\n-     * {@link #getProperty(String)} operation.\n-     * <p>\n@@ -859,5 +681,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPropertiesAccess} method doesn't allow access\n-     *             to the system properties.\n-     * @see        java.lang.SecurityException\n-     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n@@ -896,4 +713,0 @@\n-     *\n-     * First, if there is a security manager, its\n-     * {@code checkPropertiesAccess} method is called with no\n-     * arguments. This may result in a security exception.\n@@ -912,3 +725,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPropertiesAccess} method doesn't allow access\n-     *             to the system properties.\n@@ -917,2 +727,0 @@\n-     * @see        java.lang.SecurityException\n-     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n@@ -937,4 +745,0 @@\n-     *\n-     * First, if there is a security manager, its\n-     * {@code checkPropertyAccess} method is called with the key as\n-     * its argument. This may result in a SecurityException.\n@@ -955,3 +759,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPropertyAccess} method doesn't allow\n-     *             access to the specified system property.\n@@ -961,2 +762,0 @@\n-     * @see        java.lang.SecurityException\n-     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n@@ -978,4 +777,0 @@\n-     *\n-     * First, if there is a security manager, its\n-     * {@code checkPropertyAccess} method is called with the\n-     * {@code key} as its argument.\n@@ -992,3 +787,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPropertyAccess} method doesn't allow\n-     *             access to the specified system property.\n@@ -998,1 +790,0 @@\n-     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n@@ -1015,7 +806,0 @@\n-     * First, if a security manager exists, its\n-     * {@code SecurityManager.checkPermission} method\n-     * is called with a {@code PropertyPermission(key, \"write\")}\n-     * permission. This may result in a SecurityException being thrown.\n-     * If no exception is thrown, the specified property is set to the given\n-     * value.\n-     *\n@@ -1032,3 +816,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPermission} method doesn't allow\n-     *             setting of the specified property.\n@@ -1041,2 +822,0 @@\n-     * @see        java.util.PropertyPermission\n-     * @see        SecurityManager#checkPermission\n@@ -1060,6 +839,0 @@\n-     * First, if a security manager exists, its\n-     * {@code SecurityManager.checkPermission} method\n-     * is called with a {@code PropertyPermission(key, \"write\")}\n-     * permission. This may result in a SecurityException being thrown.\n-     * If no exception is thrown, the specified property is removed.\n-     *\n@@ -1075,3 +848,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPropertyAccess} method doesn't allow\n-     *              access to the specified system property.\n@@ -1083,2 +853,0 @@\n-     * @see        java.lang.SecurityException\n-     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n@@ -1112,8 +880,0 @@\n-     * <p>If a security manager exists, its\n-     * {@link SecurityManager#checkPermission checkPermission}\n-     * method is called with a\n-     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n-     * permission.  This may result in a {@link SecurityException}\n-     * being thrown.  If no exception is thrown the value of the\n-     * variable {@code name} is returned.\n-     *\n@@ -1145,5 +905,0 @@\n-     * @throws SecurityException\n-     *         if a security manager exists and its\n-     *         {@link SecurityManager#checkPermission checkPermission}\n-     *         method doesn't allow access to the environment variable\n-     *         {@code name}\n@@ -1184,6 +939,0 @@\n-     * <p>If a security manager exists, its\n-     * {@link SecurityManager#checkPermission checkPermission}\n-     * method is called with a\n-     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n-     * This may result in a {@link SecurityException} being thrown.\n-     *\n@@ -1195,4 +944,0 @@\n-     * @throws SecurityException\n-     *         if a security manager exists and its\n-     *         {@link SecurityManager#checkPermission checkPermission}\n-     *         method doesn't allow access to the process environment\n@@ -1618,10 +1363,0 @@\n-     * In addition, when a security manager is present, loggers provided to\n-     * system classes should not be directly configurable through the logging\n-     * backend without requiring permissions.\n-     * <br>\n-     * It is the responsibility of the provider of\n-     * the concrete {@code LoggerFinder} implementation to ensure that\n-     * these loggers are not configured by untrusted code without proper\n-     * permission checks, as configuration performed on such loggers usually\n-     * affects all applications in the same Java Runtime.\n-     * <p>\n@@ -1660,4 +1395,0 @@\n-         *\n-         * @throws SecurityException if a security manager is present and its\n-         *         {@code checkPermission} method doesn't allow the\n-         *         {@code RuntimePermission(\"loggerFinder\")}.\n@@ -1693,3 +1424,0 @@\n-         * @throws SecurityException if a security manager is present and its\n-         *         {@code checkPermission} method doesn't allow the\n-         *         {@code RuntimePermission(\"loggerFinder\")}.\n@@ -1736,3 +1464,0 @@\n-         * @throws SecurityException if a security manager is present and its\n-         *         {@code checkPermission} method doesn't allow the\n-         *         {@code RuntimePermission(\"loggerFinder\")}.\n@@ -1753,3 +1478,0 @@\n-         * @throws SecurityException if a security manager is present and its\n-         *         {@code checkPermission} method doesn't allow the\n-         *         {@code RuntimePermission(\"loggerFinder\")}.\n@@ -1900,4 +1622,4 @@\n-     * Initiates the {@linkplain Runtime##shutdown shutdown sequence} of the Java Virtual Machine.\n-     * Unless the security manager denies exiting, this method initiates the shutdown sequence\n-     * (if it is not already initiated) and then blocks indefinitely. This method neither returns\n-     * nor throws an exception; that is, it does not complete either normally or abruptly.\n+     * Initiates the {@linkplain Runtime##shutdown shutdown sequence} of the Java Virtual\n+     * Machine. This method initiates the shutdown sequence (if it is not already initiated)\n+     * and then blocks indefinitely. This method neither returns nor throws an exception;\n+     * that is, it does not complete either normally or abruptly.\n@@ -1917,3 +1639,0 @@\n-     * @throws SecurityException\n-     *         if a security manager exists and its {@code checkExit} method\n-     *         doesn't allow exit with the specified status.\n@@ -2013,3 +1732,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkLink} method doesn't allow\n-     *             loading of the specified dynamic library\n@@ -2026,1 +1742,0 @@\n-     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n@@ -2056,3 +1771,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkLink} method doesn't allow\n-     *             loading of the specified dynamic library\n@@ -2069,1 +1781,0 @@\n-     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n@@ -2338,5 +2049,2 @@\n-     * 1. eagerly initialize bootstrap method factories that might interact\n-     *    negatively with custom security managers and custom class loaders\n-     * 2. set security manager\n-     * 3. set system class loader\n-     * 4. set TCCL\n+     * 1. set system class loader\n+     * 2. set TCCL\n@@ -2345,3 +2053,0 @@\n-     * The security manager and system class loader may be a custom class from\n-     * the application classpath or modulepath.\n-    @SuppressWarnings(\"removal\")\n@@ -2351,5 +2056,0 @@\n-        \/\/ Initialize the StringConcatFactory eagerly to avoid potential\n-        \/\/ bootstrap circularity issues that could be caused by a custom\n-        \/\/ SecurityManager\n-        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n-\n@@ -2363,1 +2063,0 @@\n-        boolean needWarning = false;\n@@ -2367,1 +2066,0 @@\n-                    allowSecurityManager = NEVER;\n@@ -2370,2 +2068,0 @@\n-                    allowSecurityManager = MAYBE;\n-                    break;\n@@ -2374,25 +2070,2 @@\n-                    implSetSecurityManager(new SecurityManager());\n-                    allowSecurityManager = MAYBE;\n-                    needWarning = true;\n-                    break;\n-                    try {\n-                        ClassLoader cl = ClassLoader.getBuiltinAppClassLoader();\n-                        Class<?> c = Class.forName(smProp, false, cl);\n-                        Constructor<?> ctor = c.getConstructor();\n-                        \/\/ Must be a public subclass of SecurityManager with\n-                        \/\/ a public no-arg constructor\n-                        if (!SecurityManager.class.isAssignableFrom(c) ||\n-                            !Modifier.isPublic(c.getModifiers()) ||\n-                            !Modifier.isPublic(ctor.getModifiers())) {\n-                            throw new Error(\"Could not create SecurityManager: \"\n-                                             + ctor.toString());\n-                        }\n-                        \/\/ custom security manager may be in non-exported package\n-                        ctor.setAccessible(true);\n-                        SecurityManager sm = (SecurityManager) ctor.newInstance();\n-                        implSetSecurityManager(sm);\n-                        needWarning = true;\n-                    } catch (Exception e) {\n-                        throw new InternalError(\"Could not create SecurityManager\", e);\n-                    }\n-                    allowSecurityManager = MAYBE;\n+                    throw new Error(\"A command line option has attempted to allow or enable the Security Manager.\"\n+                            + \" Enabling a Security Manager is not supported.\");\n@@ -2401,8 +2074,0 @@\n-        } else {\n-            allowSecurityManager = NEVER;\n-        }\n-\n-        if (needWarning) {\n-            System.err.println(\"\"\"\n-                    WARNING: A command line option has enabled the Security Manager\n-                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n@@ -2472,3 +2137,0 @@\n-            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n-                return new Thread(target, acc);\n-            }\n@@ -2495,8 +2157,0 @@\n-            @SuppressWarnings(\"removal\")\n-            public void addNonExportedPackages(ModuleLayer layer) {\n-                SecurityManager.addNonExportedPackages(layer);\n-            }\n-            @SuppressWarnings(\"removal\")\n-            public void invalidatePackageAccessCache() {\n-                SecurityManager.invalidatePackageAccessCache();\n-            }\n@@ -2799,5 +2453,0 @@\n-\n-            @Override\n-            public boolean allowSecurityManager() {\n-                return System.allowSecurityManager();\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":26,"deletions":377,"binary":false,"changes":403,"status":"modified"},{"patch":"@@ -151,5 +151,0 @@\n-     * <p>\n-     * If a security manager is installed, this method is caller sensitive.\n-     * During any invocation of the target method handle via the returned wrapper,\n-     * the original creator of the wrapper (the caller) will be visible\n-     * to context checks requested by the security manager.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -168,2 +168,0 @@\n-     * A public lookup object is always subject to\n-     * <a href=\"MethodHandles.Lookup.html#secmgr\">security manager checks<\/a>.\n@@ -189,3 +187,0 @@\n-     * <li>If there is a security manager, its {@code checkPermission} method is\n-     * called to check {@code ReflectPermission(\"suppressAccessChecks\")} and\n-     * that must return normally.\n@@ -241,1 +236,0 @@\n-     * @throws SecurityException if denied by the security manager\n@@ -462,3 +456,0 @@\n-     * <p>\n-     * If there is a security manager, its {@code checkPermission} method\n-     * is called with a {@code ReflectPermission(\"suppressAccessChecks\")} permission.\n@@ -469,1 +460,0 @@\n-     * @throws    SecurityException if the caller is not privileged to call {@code setAccessible}\n@@ -619,4 +609,0 @@\n-     * <li>If there is a security manager installed, it can forbid the lookup\n-     * on various grounds (<a href=\"MethodHandles.Lookup.html#secmgr\">see below<\/a>).\n-     * By contrast, the {@code ldc} instruction on a {@code CONSTANT_MethodHandle}\n-     * constant is not subject to security manager checks.\n@@ -1320,68 +1306,0 @@\n-     * <h2><a id=\"secmgr\"><\/a>Security manager interactions<\/h2>\n-     * Although bytecode instructions can only refer to classes in\n-     * a related class loader, this API can search for methods in any\n-     * class, as long as a reference to its {@code Class} object is\n-     * available.  Such cross-loader references are also possible with the\n-     * Core Reflection API, and are impossible to bytecode instructions\n-     * such as {@code invokestatic} or {@code getfield}.\n-     * There is a {@linkplain java.lang.SecurityManager security manager API}\n-     * to allow applications to check such cross-loader references.\n-     * These checks apply to both the {@code MethodHandles.Lookup} API\n-     * and the Core Reflection API\n-     * (as found on {@link java.lang.Class Class}).\n-     * <p>\n-     * If a security manager is present, member and class lookups are subject to\n-     * additional checks.\n-     * From one to three calls are made to the security manager.\n-     * Any of these calls can refuse access by throwing a\n-     * {@link java.lang.SecurityException SecurityException}.\n-     * Define {@code smgr} as the security manager,\n-     * {@code lookc} as the lookup class of the current lookup object,\n-     * {@code refc} as the containing class in which the member\n-     * is being sought, and {@code defc} as the class in which the\n-     * member is actually defined.\n-     * (If a class or other type is being accessed,\n-     * the {@code refc} and {@code defc} values are the class itself.)\n-     * The value {@code lookc} is defined as <em>not present<\/em>\n-     * if the current lookup object does not have\n-     * {@linkplain #hasFullPrivilegeAccess() full privilege access}.\n-     * The calls are made according to the following rules:\n-     * <ul>\n-     * <li><b>Step 1:<\/b>\n-     *     If {@code lookc} is not present, or if its class loader is not\n-     *     the same as or an ancestor of the class loader of {@code refc},\n-     *     then {@link SecurityManager#checkPackageAccess\n-     *     smgr.checkPackageAccess(refcPkg)} is called,\n-     *     where {@code refcPkg} is the package of {@code refc}.\n-     * <li><b>Step 2a:<\/b>\n-     *     If the retrieved member is not public and\n-     *     {@code lookc} is not present, then\n-     *     {@link SecurityManager#checkPermission smgr.checkPermission}\n-     *     with {@code RuntimePermission(\"accessDeclaredMembers\")} is called.\n-     * <li><b>Step 2b:<\/b>\n-     *     If the retrieved class has a {@code null} class loader,\n-     *     and {@code lookc} is not present, then\n-     *     {@link SecurityManager#checkPermission smgr.checkPermission}\n-     *     with {@code RuntimePermission(\"getClassLoader\")} is called.\n-     * <li><b>Step 3:<\/b>\n-     *     If the retrieved member is not public,\n-     *     and if {@code lookc} is not present,\n-     *     and if {@code defc} and {@code refc} are different,\n-     *     then {@link SecurityManager#checkPackageAccess\n-     *     smgr.checkPackageAccess(defcPkg)} is called,\n-     *     where {@code defcPkg} is the package of {@code defc}.\n-     * <\/ul>\n-     * Security checks are performed after other access checks have passed.\n-     * Therefore, the above rules presuppose a member or class that is public,\n-     * or else that is being accessed from a lookup class that has\n-     * rights to access the member or class.\n-     * <p>\n-     * If a security manager is present and the current lookup object does not have\n-     * {@linkplain #hasFullPrivilegeAccess() full privilege access}, then\n-     * {@link #defineClass(byte[]) defineClass},\n-     * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass},\n-     * {@link #defineHiddenClassWithClassData(byte[], Object, boolean, ClassOption...)\n-     * defineHiddenClassWithClassData}\n-     * calls {@link SecurityManager#checkPermission smgr.checkPermission}\n-     * with {@code RuntimePermission(\"defineClass\")}.\n-     *\n@@ -1828,4 +1746,0 @@\n-         * <p> If there is a security manager and this lookup does not have {@linkplain\n-         * #hasFullPrivilegeAccess() full privilege access}, its {@code checkPermission} method\n-         * is first called to check {@code RuntimePermission(\"defineClass\")}. <\/p>\n-         *\n@@ -1841,2 +1755,0 @@\n-         * @throws SecurityException if a security manager is present and it\n-         *                           <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -2100,2 +2012,0 @@\n-         * @throws SecurityException if a security manager is present and it\n-         * <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -2183,2 +2093,0 @@\n-         * @throws SecurityException if a security manager is present and it\n-         * <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -2634,2 +2542,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -2718,2 +2624,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -2794,2 +2698,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -2827,2 +2729,0 @@\n-         * @throws SecurityException if a security manager is present and it\n-         *                           <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -2864,2 +2764,0 @@\n-         * @throws  SecurityException if a security manager is present and it\n-         *          <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -2974,2 +2872,0 @@\n-         * @throws SecurityException if a security manager is present and it\n-         *                           <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -3058,2 +2954,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -3083,2 +2977,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -3107,2 +2999,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -3180,2 +3070,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -3206,2 +3094,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -3231,2 +3117,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -3305,2 +3189,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -3359,2 +3241,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -3693,2 +3573,0 @@\n-         * @throws    SecurityException if a security manager is present and it\n-         *                              <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n@@ -4663,1 +4541,1 @@\n-     * This method throws no reflective or security exceptions.\n+     * This method throws no reflective exceptions.\n@@ -4709,1 +4587,1 @@\n-     * This method throws no reflective or security exceptions.\n+     * This method throws no reflective exceptions.\n@@ -4747,1 +4625,1 @@\n-     * This method throws no reflective or security exceptions.\n+     * This method throws no reflective exceptions.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":3,"deletions":125,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,1 +230,1 @@\n-        ReferencedKeySet.create(false, true, new Supplier<>() {\n+        ReferencedKeySet.create(false, new Supplier<>() {\n@@ -1177,3 +1177,0 @@\n-     * @throws SecurityException if the security manager is present and\n-     *         {@code loader} is {@code null} and the caller does not have the\n-     *         {@link RuntimePermission}{@code (\"getClassLoader\")}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -343,5 +343,0 @@\n-\n-            @Override\n-            public <T> ReferenceQueue<T> newNativeReferenceQueue() {\n-                return new NativeReferenceQueue<T>();\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-     * array of reflected objects with a single security check (for efficiency).\n+     * array of reflected objects.\n@@ -103,5 +103,1 @@\n-     * <p>If there is a security manager, its\n-     * {@code checkPermission} method is first called with a\n-     * {@code ReflectPermission(\"suppressAccessChecks\")} permission.\n-     *\n-     * <p>A {@code SecurityException} is also thrown if any of the elements of\n+     * <p>A {@code SecurityException} is thrown if any of the elements of\n@@ -116,2 +112,1 @@\n-     * @throws SecurityException if the request is denied by the security manager\n-     *         or an element in the array is a constructor for {@code\n+     * @throws SecurityException if an element in the array is a constructor for {@code\n@@ -119,2 +114,0 @@\n-     * @see SecurityManager#checkPermission\n-     * @see ReflectPermission\n@@ -198,4 +191,0 @@\n-     * <p> If there is a security manager, its\n-     * {@code checkPermission} method is first called with a\n-     * {@code ReflectPermission(\"suppressAccessChecks\")} permission.\n-     *\n@@ -204,1 +193,0 @@\n-     * @throws SecurityException if the request is denied by the security manager\n@@ -264,4 +252,0 @@\n-     * <p> If there is a security manager, its {@code checkPermission} method\n-     * is first called with a {@code ReflectPermission(\"suppressAccessChecks\")}\n-     * permission. <\/p>\n-     *\n@@ -270,1 +254,0 @@\n-     * @throws SecurityException if the request is denied by the security manager\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -169,1 +169,0 @@\n-     * @throws SecurityException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,3 +120,1 @@\n- * loader, such as {@code java.lang.Object}, because the code for a\n- * proxy class is generated by trusted system code.  This protection\n- * domain will typically be granted {@code java.security.AllPermission}.\n+ * loader, such as {@code java.lang.Object}.\n@@ -357,15 +355,0 @@\n-     * @throws  SecurityException if a security manager, <em>s<\/em>, is present\n-     *          and any of the following conditions is met:\n-     *          <ul>\n-     *             <li> the given {@code loader} is {@code null} and\n-     *             the caller's class loader is not {@code null} and the\n-     *             invocation of {@link SecurityManager#checkPermission\n-     *             s.checkPermission} with\n-     *             {@code RuntimePermission(\"getClassLoader\")} permission\n-     *             denies access.<\/li>\n-     *             <li> for each proxy interface, {@code intf},\n-     *             the caller's class loader is not the same as or an\n-     *             ancestor of the class loader for {@code intf} and\n-     *             invocation of {@link SecurityManager#checkPackageAccess\n-     *             s.checkPackageAccess()} denies access to {@code intf}.<\/li>\n-     *          <\/ul>\n@@ -992,21 +975,0 @@\n-     * @throws  SecurityException if a security manager, <em>s<\/em>, is present\n-     *          and any of the following conditions is met:\n-     *          <ul>\n-     *          <li> the given {@code loader} is {@code null} and\n-     *               the caller's class loader is not {@code null} and the\n-     *               invocation of {@link SecurityManager#checkPermission\n-     *               s.checkPermission} with\n-     *               {@code RuntimePermission(\"getClassLoader\")} permission\n-     *               denies access;<\/li>\n-     *          <li> for each proxy interface, {@code intf},\n-     *               the caller's class loader is not the same as or an\n-     *               ancestor of the class loader for {@code intf} and\n-     *               invocation of {@link SecurityManager#checkPackageAccess\n-     *               s.checkPackageAccess()} denies access to {@code intf};<\/li>\n-     *          <li> any of the given proxy interfaces is non-public and the\n-     *               caller class is not in the same {@linkplain Package runtime package}\n-     *               as the non-public interface and the invocation of\n-     *               {@link SecurityManager#checkPermission s.checkPermission} with\n-     *               {@code ReflectPermission(\"newProxyInPackage.{package name}\")}\n-     *               permission denies access.<\/li>\n-     *          <\/ul>\n@@ -1115,6 +1077,0 @@\n-     * @throws  SecurityException if a security manager, <em>s<\/em>, is present\n-     *          and the caller's class loader is not the same as or an\n-     *          ancestor of the class loader for the invocation handler\n-     *          and invocation of {@link SecurityManager#checkPackageAccess\n-     *          s.checkPackageAccess()} denies access to the invocation\n-     *          handler's class.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":2,"deletions":46,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -148,6 +148,0 @@\n-    \/**\n-     * Returns a new Thread with the given Runnable and an\n-     * inherited AccessControlContext.\n-     *\/\n-    Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc);\n-\n@@ -188,10 +182,0 @@\n-    \/**\n-     * Record the non-exported packages of the modules in the given layer\n-     *\/\n-    void addNonExportedPackages(ModuleLayer layer);\n-\n-    \/**\n-     * Invalidate package access cache\n-     *\/\n-    void invalidatePackageAccessCache();\n-\n@@ -643,6 +627,0 @@\n-\n-    \/**\n-     * Is a security manager already set or allowed to be set\n-     * (using -Djava.security.manager=allow)?\n-     *\/\n-    boolean allowSecurityManager();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-        @JEP(number=473, title=\"Stream Gatherers\", status=\"Second Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -146,23 +146,1 @@\n-        return create(isSoft, false, supplier);\n-    }\n-\n-    \/**\n-     * Create a new {@link ReferencedKeyMap} map.\n-     *\n-     * @param isSoft          true if {@link SoftReference} keys are to\n-     *                        be used, {@link WeakReference} otherwise.\n-     * @param useNativeQueue  true if uses NativeReferenceQueue\n-     *                        otherwise use {@link ReferenceQueue}.\n-     * @param supplier        {@link Supplier} of the backing map\n-     *\n-     * @return a new map with {@link Reference} keys\n-     *\n-     * @param <K> the type of keys maintained by the new map\n-     * @param <V> the type of mapped values\n-     *\/\n-    public static <K, V> ReferencedKeyMap<K, V>\n-    create(boolean isSoft, boolean useNativeQueue, Supplier<Map<ReferenceKey<K>, V>> supplier) {\n-        return new ReferencedKeyMap<K, V>(isSoft, supplier.get(),\n-                useNativeQueue ? SharedSecrets.getJavaLangRefAccess().newNativeReferenceQueue()\n-                               : new ReferenceQueue<>()\n-                );\n+        return new ReferencedKeyMap<K, V>(isSoft, supplier.get(), new ReferenceQueue<>());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -167,2 +167,0 @@\n-        java.management.rmi,\n-        java.naming,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-     * @since 18\n+     * @since Valhalla\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,0 +280,1 @@\n+        ERASE_POLY_SIG_RETURN_TYPE(JDK24),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1680,0 +1680,6 @@\n+            \/* there are three cases for ts and ss:\n+             *   - one is a class and the other one is an interface (case I)\n+             *   - both are classes                                 (case II)\n+             *   - both are interfaces                              (case III)\n+             * all those cases are covered in JLS 23, section: \"5.1.6.1 Allowed Narrowing Reference Conversion\"\n+             *\/\n@@ -1687,23 +1693,24 @@\n-                if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n-                    return false;\n-                }\n-                \/\/ if both are classes or both are interfaces, shortcut\n-                if (ts.isInterface() == ss.isInterface() && isSubtype(erasure(ss.type), erasure(ts.type))) {\n-                    return false;\n-                }\n-                if (ts.isInterface() && !ss.isInterface()) {\n-                    \/* so ts is interface but ss is a class\n-                     * an interface is disjoint from a class if the class is disjoint form the interface\n-                     *\/\n-                    return areDisjoint(ss, ts);\n-                }\n-                \/\/ a final class that is not subtype of ss is disjoint\n-                if (!ts.isInterface() && ts.isFinal()) {\n-                    return true;\n-                }\n-                \/\/ if at least one is sealed\n-                if (ts.isSealed() || ss.isSealed()) {\n-                    \/\/ permitted subtypes have to be disjoint with the other symbol\n-                    ClassSymbol sealedOne = ts.isSealed() ? ts : ss;\n-                    ClassSymbol other = sealedOne == ts ? ss : ts;\n-                    return sealedOne.getPermittedSubclasses().stream().allMatch(type -> areDisjoint((ClassSymbol)type.tsym, other));\n+\n+                if (ts.isInterface() != ss.isInterface()) { \/\/ case I: one is a class and the other one is an interface\n+                    ClassSymbol isym = ts.isInterface() ? ts : ss; \/\/ isym is the interface and csym the class\n+                    ClassSymbol csym = isym == ts ? ss : ts;\n+                    if (!isSubtype(erasure(csym.type), erasure(isym.type))) {\n+                        if (csym.isFinal()) {\n+                            return true;\n+                        } else if (csym.isSealed()) {\n+                            return areDisjoint(isym, csym.getPermittedSubclasses());\n+                        } else if (isym.isSealed()) {\n+                            \/\/ if the class is not final and not sealed then it has to be freely extensible\n+                            return areDisjoint(csym, isym.getPermittedSubclasses());\n+                        }\n+                    } \/\/ now both are classes or both are interfaces\n+                } else if (!ts.isInterface()) {              \/\/ case II: both are classes\n+                    return !isSubtype(erasure(ss.type), erasure(ts.type)) && !isSubtype(erasure(ts.type), erasure(ss.type));\n+                } else {                                     \/\/ case III: both are interfaces\n+                    if (!isSubtype(erasure(ts.type), erasure(ss.type)) && !isSubtype(erasure(ss.type), erasure(ts.type))) {\n+                        if (ts.isSealed()) {\n+                            return areDisjoint(ss, ts.getPermittedSubclasses());\n+                        } else if (ss.isSealed()) {\n+                            return areDisjoint(ts, ss.getPermittedSubclasses());\n+                        }\n+                    }\n@@ -1711,0 +1718,1 @@\n+                \/\/ at this point we haven't been able to statically prove that the classes or interfaces are disjoint\n@@ -1713,0 +1721,4 @@\n+\n+            boolean areDisjoint(ClassSymbol csym, List<Type> permittedSubtypes) {\n+                return permittedSubtypes.stream().allMatch(psubtype -> areDisjoint(csym, (ClassSymbol) psubtype.tsym));\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":35,"deletions":23,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -653,0 +653,1 @@\n+            checkAnnotationArraySizeInternal(p);\n@@ -658,0 +659,7 @@\n+    private void checkAnnotationArraySizeInternal(Pair<Symbol.MethodSymbol, Attribute> p) {\n+        if (p.snd instanceof Attribute.Array arrAttr &&\n+                arrAttr.values.length > ClassFile.MAX_ANNOTATIONS) {\n+            log.error(Errors.AnnotationArrayTooLarge(p.fst.owner));\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -890,0 +890,4 @@\n+# 0: symbol\n+compiler.err.annotation.array.too.large=\\\n+    Annotation array element too large in \\\"{0}\\\"\n+\n@@ -2244,0 +2248,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    final int hubOffset = getFieldOffset(\"oopDesc::_metadata._klass\", Integer.class, \"Klass*\");\n+    final int klassOffsetInBytes = getFieldValue(\"CompilerToVM::Data::oopDesc_klass_offset_in_bytes\", Integer.class, \"int\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,0 +118,7 @@\n+runtime\/Dictionary\/CleanProtectionDomain.java 8341916 generic-all\n+runtime\/Dictionary\/ProtectionDomainCacheTest.java 8341916 generic-all\n+runtime\/logging\/ProtectionDomainVerificationTest.java 8341916 generic-all\n+\n+# Fails with +UseCompactObjectHeaders on aarch64\n+runtime\/cds\/appcds\/SharedBaseAddress.java 8340212 linux-aarch64,macosx-aarch64\n+runtime\/cds\/SharedBaseAddress.java 8340212 linux-aarch64,macosx-aarch64\n@@ -130,0 +137,11 @@\n+\n+# Valhalla + COH\n+gtest\/CompressedKlassGtest.java#use-zero-based-encoding-coh                     8348568 generic-all\n+gtest\/CompressedKlassGtest.java#use-zero-based-encoding-coh-large-class-space   8348568 generic-all\n+gtest\/MetaspaceGtests.java#UseCompactObjectHeaders                              8348568 generic-all\n+runtime\/CompressedOops\/CompressedClassPointersEncodingScheme.java               8348568 generic-all\n+runtime\/FieldLayout\/BaseOffsets.java#no-coops-with-coh                          8348568 generic-all\n+runtime\/FieldLayout\/BaseOffsets.java#with-coop--with-coh                        8348568 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#coops_coh                            8348568 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#nocoops_coh                          8348568 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -467,0 +467,1 @@\n+ -runtime\/cds\/appcds\/jvmti\/redefineClasses\/OldClassAndRedefineClass.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -289,0 +289,6 @@\n+    public static final String ADD_P_OF = COMPOSITE_PREFIX + \"ADD_P_OF\" + POSTFIX;\n+    static {\n+        String regex = START + \"addP_\" + IS_REPLACED + MID + \".*\" + END;\n+        machOnly(ADD_P_OF, regex);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -145,1 +145,2 @@\n-                    \"LogCompilation\"\n+                    \"LogCompilation\",\n+                    \"UseCompactObjectHeaders\"\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -470,0 +470,1 @@\n+java\/awt\/Robot\/InfiniteLoopException.java 8342638 windows-all\n@@ -563,2 +564,0 @@\n-javax\/management\/monitor\/DerivedGaugeMonitorTest.java           8042211 generic-all\n-\n@@ -781,0 +780,1 @@\n+jdk\/jfr\/event\/oldobject\/TestShenandoah.java                     8342951 generic-all\n@@ -820,0 +820,1 @@\n+java\/awt\/print\/PrinterJob\/PrintTextTest.java 8148334 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -434,2 +434,1 @@\n-    javax\/accessibility \\\n-    com\/sun\/java\/accessibility\n+    javax\/accessibility\n@@ -641,2 +640,0 @@\n-    sun\/security\/provider\/PolicyFile\/GrantAllPermToExtWhenNoPolicy.java \\\n-    sun\/security\/provider\/PolicyParser\/PrincipalExpansionError.java \\\n@@ -665,1 +662,0 @@\n-    java\/security\/Policy\/Root\/Root.java \\\n@@ -681,1 +677,1 @@\n-   tools\/sincechecker\/modules\/java_base\/CheckSince_javaBase.java\n+   tools\/sincechecker\/\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @run testng\/othervm\/java.security.policy=empty_security.policy BasicRecordSer\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/BasicRecordSer.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @run testng\/othervm\/java.security.policy=empty_security.policy RecordClassTest\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/RecordClassTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- * @run testng\/othervm\/java.security.policy=allPermissions.policy IsRecordTest\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/IsRecordTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- * @run testng\/othervm\/java.security.policy=allPermissions.policy RecordReflectionTest\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/RecordReflectionTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run testng\/othervm\/java.security.policy=empty.policy ObjectMethodsTest\n","filename":"test\/jdk\/java\/lang\/runtime\/ObjectMethodsTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331051\n+ * @summary Test for `@since` in java.base module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker java.base --ignoreSince Valhalla --exclude java.lang.classfile\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/java.base\/JavaBaseCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341399\n+ * @summary Test for `@since` in java.compiler module\n+ * @library \/test\/lib \/test\/jdk\/tools\/sincechecker\n+ * @run main SinceChecker java.compiler --ignoreSince Valhalla\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/java.compiler\/JavaCompilerCheckSince.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -141,0 +141,1 @@\n+        map.put(\"jlink.packagedModules\", this::packagedModules);\n@@ -719,0 +720,15 @@\n+    private String packagedModules() {\n+        \/\/ Some jlink tests require packaged modules being present (jmods).\n+        \/\/ For a runtime linkable image build packaged modules aren't present\n+        try {\n+            Path jmodsDir = Path.of(System.getProperty(\"java.home\"), \"jmods\");\n+            if (jmodsDir.toFile().exists()) {\n+                return Boolean.TRUE.toString();\n+            } else {\n+                return Boolean.FALSE.toString();\n+            }\n+        } catch (Throwable t) {\n+            return Boolean.FALSE.toString();\n+        }\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -19,0 +19,1 @@\n+compiler.err.annotation.array.too.large                 # Code\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -244,19 +244,0 @@\n-    @Test\n-    public void testSecurityManager(Path base) throws IOException {\n-        Path sourceFile = base.resolve(\"HelloWorld.java\");\n-        tb.writeJavaFiles(base,\n-                \"class HelloWorld {\\n\" +\n-                        \"    public static void main(String... args) {\\n\" +\n-                        \"        System.out.println(\\\"Hello World!\\\");\\n\" +\n-                        \"    }\\n\" +\n-                        \"}\");\n-\n-        String log = new JavaTask(tb)\n-                .vmOptions(\"-Djava.security.manager=default\")\n-                .className(sourceFile.toString())\n-                .run(Task.Expect.FAIL)\n-                .getOutput(Task.OutputKind.STDERR);\n-        checkContains(\"stderr\", log,\n-                \"error: cannot use source-code launcher with a security manager enabled\");\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -58,5 +58,0 @@\n-    @SuppressWarnings(\"removal\")\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm != null) {\n-      sm.checkPermission(new WhiteBoxPermission(\"getInstance\"));\n-    }\n@@ -557,2 +552,2 @@\n-  public native long getTotalCommittedWordsInMetaspaceTestContext(long context);\n-  public native long getTotalUsedWordsInMetaspaceTestContext(long context);\n+  public native long getTotalCommittedBytesInMetaspaceTestContext(long context);\n+  public native long getTotalUsedBytesInMetaspaceTestContext(long context);\n@@ -561,2 +556,2 @@\n-  public native long allocateFromMetaspaceTestArena(long arena, long word_size);\n-  public native void deallocateToMetaspaceTestArena(long arena, long p, long word_size);\n+  public native long allocateFromMetaspaceTestArena(long arena, long size);\n+  public native void deallocateToMetaspaceTestArena(long arena, long p, long size);\n@@ -566,0 +561,4 @@\n+  \/\/ Word size measured in bytes\n+  public native long wordSize();\n+  public native long rootChunkWordSize();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"}]}