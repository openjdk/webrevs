{"files":[{"patch":"@@ -283,6 +283,2 @@\n-    if (src_elem == T_ARRAY || src_elem == T_NARROWOOP || (src_elem == T_PRIMITIVE_OBJECT && !ary_src->is_flat())) {\n-      src_elem  = T_OBJECT;\n-    }\n-    if (dest_elem == T_ARRAY || dest_elem == T_NARROWOOP || (dest_elem == T_PRIMITIVE_OBJECT && !ary_dest->is_flat())) {\n-      dest_elem = T_OBJECT;\n-    }\n+    if (is_reference_type(src_elem, true)) src_elem = T_OBJECT;\n+    if (is_reference_type(dest_elem, true)) dest_elem = T_OBJECT;\n@@ -290,1 +286,1 @@\n-    if (src_elem != dest_elem || dest_elem == T_VOID) {\n+    if (src_elem != dest_elem || ary_src->is_flat() != ary_dest->is_flat() || dest_elem == T_VOID) {\n@@ -296,2 +292,2 @@\n-    if (bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, false, BarrierSetC2::Optimization) ||\n-        (src_elem == T_PRIMITIVE_OBJECT && ary_src->elem()->inline_klass()->contains_oops() &&\n+    if ((!ary_dest->is_flat() && bs->array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, false, BarrierSetC2::Optimization)) ||\n+        (ary_dest->is_flat() && ary_src->elem()->inline_klass()->contains_oops() &&\n@@ -306,1 +302,1 @@\n-    if (dest_elem == T_PRIMITIVE_OBJECT) {\n+    if (ary_dest->is_flat()) {\n@@ -354,1 +350,1 @@\n-    if (elem == T_ARRAY || elem == T_NARROWOOP || (elem == T_PRIMITIVE_OBJECT && !ary_src->is_flat())) {\n+    if (is_reference_type(elem, true)) {\n@@ -359,2 +355,2 @@\n-    if (bs->array_copy_requires_gc_barriers(true, elem, true, is_clone_inst(), BarrierSetC2::Optimization) ||\n-        (elem == T_PRIMITIVE_OBJECT && ary_src->elem()->inline_klass()->contains_oops() &&\n+    if ((!ary_src->is_flat() && bs->array_copy_requires_gc_barriers(true, elem, true, is_clone_inst(), BarrierSetC2::Optimization)) ||\n+        (ary_src->is_flat() && ary_src->elem()->inline_klass()->contains_oops() &&\n@@ -424,1 +420,1 @@\n-  if (copy_type == T_PRIMITIVE_OBJECT) {\n+  if (atp_dest->is_flat()) {\n@@ -555,9 +551,0 @@\n-#ifdef ASSERT\n-      Node* src = in(ArrayCopyNode::Src);\n-      const Type* src_type = phase->type(src);\n-      const TypeAryPtr* ary_src = src_type->isa_aryptr();\n-      BasicType elem = ary_src != NULL ? ary_src->elem()->array_element_basic_type() : T_CONFLICT;\n-      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-      assert(!is_clonebasic() || bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, is_clone_inst(), BarrierSetC2::Optimization) ||\n-             (ary_src != NULL && elem == T_PRIMITIVE_OBJECT && ary_src->is_not_flat()), \"added control for clone?\");\n-#endif\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -417,0 +417,1 @@\n+    \/\/ TODO 8302672\n@@ -430,1 +431,1 @@\n-      result =  my_type->cast_to_ptr_type(my_type->join_ptr(in_ptr));\n+      result = my_type->cast_to_ptr_type(my_type->join_ptr(in_ptr));\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2484,1 +2484,1 @@\n-  if (EnableValhalla && (_type->isa_ptr() || _type->isa_inlinetype()) && req() > 2) {\n+  if (EnableValhalla && _type->isa_ptr() && req() > 2) {\n@@ -2532,1 +2532,1 @@\n-        } else if (n->is_Phi() && can_reshape && (n->bottom_type()->isa_ptr() || n->bottom_type()->isa_inlinetype())) {\n+        } else if (n->is_Phi() && can_reshape && n->bottom_type()->isa_ptr()) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1415,2 +1415,2 @@\n-    if (ta->is_flat() && ta->elem() != TypeInlineType::BOTTOM && _flattened_accesses_share_alias) {\n-      const TypeAry *tary = TypeAry::make(TypeInlineType::BOTTOM, ta->size());\n+    if (ta->is_flat() && ta->elem() != TypeInstPtr::BOTTOM && _flattened_accesses_share_alias) {\n+      const TypeAry* tary = TypeAry::make(TypeInstPtr::BOTTOM, ta->size(), \/* stable= *\/ false, \/* flat= *\/ true);\n@@ -1719,1 +1719,1 @@\n-      if (elemtype->isa_inlinetype() &&\n+      if (flat->is_flat() &&\n@@ -1772,1 +1772,1 @@\n-        assert(flat->is_aryptr()->is_flat(), \"must be a flat array\");\n+        assert(flat->is_flat(), \"must be a flat array\");\n@@ -2096,2 +2096,1 @@\n-          ace->_adr_type->isa_aryptr() &&\n-          ace->_adr_type->is_aryptr()->is_flat()) {\n+          ace->_adr_type->is_flat()) {\n@@ -2222,2 +2221,2 @@\n-                  const Type* adr_type = get_adr_type(j);\n-                  if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat() || j == (uint)index) {\n+                  const TypePtr* adr_type = get_adr_type(j);\n+                  if (!adr_type->isa_aryptr() || !adr_type->is_flat() || j == (uint)index) {\n@@ -2252,2 +2251,2 @@\n-                const Type* adr_type = get_adr_type(j);\n-                if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat() || j == (uint)index) {\n+                const TypePtr* adr_type = get_adr_type(j);\n+                if (!adr_type->isa_aryptr() || !adr_type->is_flat() || j == (uint)index) {\n@@ -2295,2 +2294,2 @@\n-        const Type* adr_type = get_adr_type(j);\n-        if (!adr_type->isa_aryptr() || !adr_type->is_aryptr()->is_flat()) {\n+        const TypePtr* adr_type = get_adr_type(j);\n+        if (!adr_type->isa_aryptr() || !adr_type->is_flat()) {\n@@ -3713,2 +3712,2 @@\n-          const Type* adr_type = get_adr_type(i);\n-          if (adr_type->isa_aryptr() && adr_type->is_aryptr()->is_flat()) {\n+          const TypePtr* adr_type = get_adr_type(i);\n+          if (adr_type->is_flat()) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2376,2 +2376,2 @@\n-        const Type* elemtype = adr_type->isa_aryptr()->elem();\n-        if (elemtype->isa_inlinetype() && field_offset != Type::OffsetBot) {\n+        const Type* elemtype = adr_type->is_aryptr()->elem();\n+        if (adr_type->is_aryptr()->is_flat() && field_offset != Type::OffsetBot) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4245,1 +4245,1 @@\n-      ciInlineKlass* vk = ary_ptr->elem()->make_oopptr()->inline_klass();\n+      ciInlineKlass* vk = ary_ptr->elem()->inline_klass();\n@@ -4462,1 +4462,1 @@\n-                                                  TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, true, true),\n+                                                  TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, false, true, true),\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2430,0 +2430,3 @@\n+    if (adr_type->is_flat()) {\n+      bt = T_PRIMITIVE_OBJECT;\n+    }\n@@ -2457,3 +2460,1 @@\n-      if (!elem->isa_inlinetype()) {\n-        mismatched = true;\n-      } else if (elem->inline_klass() != inline_klass) {\n+      if (!adr_type->is_flat() || elem->inline_klass() != inline_klass) {\n@@ -2467,1 +2468,1 @@\n-      if (!(val_t->isa_inlinetype() || val_t->is_inlinetypeptr()) || val_t->inline_klass() != inline_klass) {\n+      if (!val_t->is_inlinetypeptr() || val_t->inline_klass() != inline_klass) {\n@@ -5527,1 +5528,1 @@\n-    if (src_elem == dest_elem && src_elem == T_OBJECT) {\n+    if (src_elem == dest_elem && top_src->is_flat() == top_dest->is_flat() && src_elem == T_OBJECT) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-      if (adr_type->is_aryptr()->is_flat()) {\n+      if (adr_type->is_flat()) {\n@@ -790,3 +790,0 @@\n-      if (basic_elem_type == T_PRIMITIVE_OBJECT && !res_type->is_aryptr()->is_flat()) {\n-        basic_elem_type = T_OBJECT;\n-      }\n@@ -796,1 +793,1 @@\n-      if (res_type->is_aryptr()->is_flat()) {\n+      if (res_type->is_flat()) {\n@@ -861,1 +858,1 @@\n-      if (res_type->isa_aryptr() && res_type->is_aryptr()->is_flat()) {\n+      if (res_type->is_flat()) {\n@@ -953,1 +950,1 @@\n-  bool allow_oop = res_type != NULL && (!res_type->isa_aryptr() || !res_type->is_aryptr()->is_flat());\n+  bool allow_oop = (res_type != NULL) && !res_type->is_flat();\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1343,3 +1343,2 @@\n-    if (dest_elem == T_ARRAY || dest_elem == T_NARROWOOP || (dest_elem == T_PRIMITIVE_OBJECT && !top_dest->is_flat())) {\n-      dest_elem = T_OBJECT;\n-    }\n+    if (is_reference_type(dest_elem, true)) dest_elem = T_OBJECT;\n+\n@@ -1348,1 +1347,0 @@\n-      dest_elem = T_PRIMITIVE_OBJECT;\n@@ -1362,1 +1360,1 @@\n-    if (dest_elem == T_PRIMITIVE_OBJECT) {\n+    if (top_dest->is_flat()) {\n@@ -1415,6 +1413,2 @@\n-  if (src_elem == T_ARRAY || src_elem == T_NARROWOOP || (src_elem == T_PRIMITIVE_OBJECT && !top_src->is_flat())) {\n-    src_elem = T_OBJECT;\n-  }\n-  if (dest_elem == T_ARRAY || dest_elem == T_NARROWOOP || (dest_elem == T_PRIMITIVE_OBJECT && !top_dest->is_flat())) {\n-    dest_elem = T_OBJECT;\n-  }\n+  if (is_reference_type(src_elem, true)) src_elem = T_OBJECT;\n+  if (is_reference_type(dest_elem, true)) dest_elem = T_OBJECT;\n@@ -1448,2 +1442,1 @@\n-  assert(!ac->is_arraycopy_validated() || (src_elem == dest_elem && dest_elem != T_VOID) ||\n-         (src_elem == T_PRIMITIVE_OBJECT && StressReflectiveCode), \"validated but different basic types\");\n+  assert(!ac->is_arraycopy_validated() || (src_elem == dest_elem && dest_elem != T_VOID), \"validated but different basic types\");\n@@ -1458,2 +1451,2 @@\n-  if (src_elem != dest_elem || dest_elem == T_VOID ||\n-      (dest_elem == T_PRIMITIVE_OBJECT && top_dest->elem()->inline_klass()->contains_oops() &&\n+  if (src_elem != dest_elem || top_src->is_flat() != top_dest->is_flat() || dest_elem == T_VOID ||\n+      (top_src->is_flat() && top_dest->elem()->inline_klass()->contains_oops() &&\n@@ -1490,1 +1483,1 @@\n-  if (dest_elem == T_PRIMITIVE_OBJECT) {\n+  if (top_dest->is_flat()) {\n@@ -1558,1 +1551,1 @@\n-  if (dest_elem == T_PRIMITIVE_OBJECT) {\n+  if (top_dest->is_flat()) {\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1978,1 +1978,1 @@\n-        && t->isa_inlinetype() == NULL\n+        && !ary->is_flat()\n@@ -2834,1 +2834,0 @@\n-      assert(!phase->type(val)->is_zero_type() || mem->in(0)->in(AllocateNode::DefaultValue) == NULL, \"storing null to inline type array is forbidden\");\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -612,2 +612,2 @@\n-    } else if (UseTypeSpeculation && (i == (arg_size - 1)) && !is_osr_parse() &&\n-               method()->has_vararg() && t->isa_aryptr() != NULL && !t->is_aryptr()->is_not_null_free()) {\n+    } else if (UseTypeSpeculation && (i == (arg_size - 1)) && !is_osr_parse() && method()->has_vararg() &&\n+               t->isa_aryptr() != NULL && !t->is_aryptr()->is_null_free() && !t->is_aryptr()->is_not_null_free()) {\n@@ -825,5 +825,0 @@\n-    \/\/ Scalarize inline type when returning as fields or inlining non-incrementally\n-    if ((tf()->returns_inline_type_as_fields() || (_caller->has_method() && !Compile::current()->inlining_incrementally())) &&\n-        ret_type->is_inlinetypeptr()) {\n-      ret_type = TypeInlineType::make(ret_type->inline_klass());\n-    }\n@@ -2350,2 +2345,2 @@\n-    \/\/ The return_type is set in Parse::build_exits().\n-    if (return_type->isa_inlinetype()) {\n+    if ((tf()->returns_inline_type_as_fields() || (_caller->has_method() && !Compile::current()->inlining_incrementally())) &&\n+        return_type->is_inlinetypeptr()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -210,4 +210,0 @@\n-    \/\/ We may have lost type information for 'val' here due to the casts\n-    \/\/ emitted by the array_store_check code (see JDK-6312651)\n-    \/\/ TODO Remove this code once JDK-6312651 is in.\n-    const Type* tval_init = _gvn.type(val);\n@@ -217,5 +213,3 @@\n-    bool not_inline = !tval->isa_inlinetype() &&\n-                      ((!tval_init->maybe_null() && !tval_init->is_oopptr()->can_be_inline_type()) ||\n-                       (!tval->maybe_null() && !tval->is_oopptr()->can_be_inline_type()));\n-    bool not_flattened = not_inline || ((tval_init->is_inlinetypeptr() || tval_init->isa_inlinetype()) && !tval_init->inline_klass()->flatten_array());\n-    if (!ary_t->is_not_null_free() && not_inline) {\n+    bool not_null_free = !tval->maybe_null() && !tval->is_oopptr()->can_be_inline_type();\n+    bool not_flattened = not_null_free || (tval->is_inlinetypeptr() && !tval->inline_klass()->flatten_array());\n+    if (!ary_t->is_not_null_free() && not_null_free) {\n@@ -279,1 +273,1 @@\n-        if (tval->isa_inlinetype() || tval->is_inlinetypeptr()) {\n+        if (tval->is_inlinetypeptr()) {\n@@ -281,2 +275,0 @@\n-        } else if (tval_init->isa_inlinetype() || tval_init->is_inlinetypeptr()) {\n-          vk = tval_init->inline_klass();\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -266,3 +266,1 @@\n-  if (!elemtype->isa_inlinetype()) {\n-    elemtype = elemtype->make_oopptr();\n-  }\n+  const TypeAryPtr* arytype = _gvn.type(ary)->is_aryptr();\n@@ -270,1 +268,1 @@\n-  if (elemtype->isa_inlinetype() != NULL || elemtype->is_inlinetypeptr()) {\n+  if (elemtype->make_ptr()->is_inlinetypeptr()) {\n@@ -272,1 +270,1 @@\n-    null_free = elemtype->isa_inlinetype() || !elemtype->maybe_null();\n+    null_free = arytype->is_flat() || !elemtype->make_ptr()->maybe_null();\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-  { Bad,             T_PRIMITIVE_OBJECT, \"inline:\",      false, Node::NotAMachineReg, relocInfo::none          },  \/\/ InlineType\n@@ -614,2 +613,0 @@\n-  TypeInlineType::BOTTOM = TypeInlineType::make(NULL);\n-\n@@ -658,1 +655,1 @@\n-  TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInlineType::BOTTOM,TypeInt::POS), NULL, false,  Offset::bottom);\n+  TypeAryPtr::INLINES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true), NULL, false, Offset::bottom);\n@@ -978,3 +975,0 @@\n-  case InlineType:\n-    return t->xmeet(this);\n-\n@@ -1150,1 +1144,0 @@\n-    case Type::InlineType:\n@@ -1565,1 +1558,0 @@\n-  case InlineType:\n@@ -2321,1 +2313,1 @@\n-                             bool not_flat, bool not_null_free) {\n+                             bool flat, bool not_flat, bool not_null_free) {\n@@ -2326,1 +2318,1 @@\n-  return (TypeAry*)(new TypeAry(elem, size, stable, not_flat, not_null_free))->hashcons();\n+  return (TypeAry*)(new TypeAry(elem, size, stable, flat, not_flat, not_null_free))->hashcons();\n@@ -2349,0 +2341,1 @@\n+                         _flat && a->_flat,\n@@ -2363,1 +2356,1 @@\n-  return new TypeAry(_elem->dual(), size_dual, !_stable, !_not_flat, !_not_null_free);\n+  return new TypeAry(_elem->dual(), size_dual, !_stable, !_flat, !_not_flat, !_not_null_free);\n@@ -2373,0 +2366,1 @@\n+    _flat == a->_flat &&\n@@ -2381,1 +2375,2 @@\n-  return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);\n+  return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0) +\n+      (_flat ? 44 : 0) + (_not_flat ? 45 : 0) + (_not_null_free ? 46 : 0);\n@@ -2388,1 +2383,1 @@\n-  return make(_elem->remove_speculative(), _size, _stable, _not_flat, _not_null_free);\n+  return make(_elem->remove_speculative(), _size, _stable, _flat, _not_flat, _not_null_free);\n@@ -2395,1 +2390,1 @@\n-  return make(_elem->cleanup_speculative(), _size, _stable, _not_flat, _not_null_free);\n+  return make(_elem->cleanup_speculative(), _size, _stable, _flat, _not_flat, _not_null_free);\n@@ -2414,0 +2409,1 @@\n+  if (_flat) st->print(\"flat:\");\n@@ -2477,131 +2473,0 @@\n-\/\/==============================TypeInlineType=======================================\n-\n-const TypeInlineType* TypeInlineType::BOTTOM;\n-\n-\/\/------------------------------make-------------------------------------------\n-const TypeInlineType* TypeInlineType::make(ciInlineKlass* vk, bool larval) {\n-  TypePtr::InterfaceSet interfaces;\n-  if (vk != NULL) {\n-    interfaces = TypePtr::InterfaceSet(vk->transitive_interfaces());\n-  }\n-  return (TypeInlineType*)(new TypeInlineType(vk, interfaces, larval))->hashcons();\n-}\n-\n-\/\/------------------------------meet-------------------------------------------\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type* TypeInlineType::xmeet(const Type* t) const {\n-  \/\/ Perform a fast test for common case; meeting the same types together.\n-  if(this == t) return this;  \/\/ Meeting same type-rep?\n-\n-  \/\/ Current \"this->_base\" is InlineType\n-  switch (t->base()) {          \/\/ switch on original type\n-\n-  case Int:\n-  case Long:\n-  case FloatTop:\n-  case FloatCon:\n-  case FloatBot:\n-  case DoubleTop:\n-  case DoubleCon:\n-  case DoubleBot:\n-  case NarrowKlass:\n-  case Bottom:\n-    return Type::BOTTOM;\n-\n-  case OopPtr:\n-  case MetadataPtr:\n-  case KlassPtr:\n-  case RawPtr:\n-  case AnyPtr:\n-    return TypePtr::BOTTOM;\n-\n-  case Top:\n-    return this;\n-\n-  case NarrowOop: {\n-    const Type* res = t->make_ptr()->xmeet(this);\n-    if (res->isa_ptr()) {\n-      return res->make_narrowoop();\n-    }\n-    return res;\n-  }\n-\n-  case InstKlassPtr:\n-  case AryKlassPtr:\n-  case AryPtr:\n-  case InstPtr: {\n-    return t->xmeet(this);\n-  }\n-\n-  case InlineType: {\n-    \/\/ All inline types inherit from Object\n-    const TypeInlineType* other = t->is_inlinetype();\n-    if (_vk == NULL) {\n-      return this;\n-    } else if (other->_vk == NULL) {\n-      return other;\n-    } else if (_vk == other->_vk) {\n-      if (_larval == other->_larval ||\n-          !_larval) {\n-        return this;\n-      } else {\n-        return t;\n-      }\n-    }\n-    return TypeInstPtr::NOTNULL;\n-  }\n-\n-  default:                      \/\/ All else is a mistake\n-    typerr(t);\n-\n-  }\n-  return this;\n-}\n-\n-\/\/------------------------------xdual------------------------------------------\n-const Type* TypeInlineType::xdual() const {\n-  return this;\n-}\n-\n-\/\/------------------------------eq---------------------------------------------\n-\/\/ Structural equality check for Type representations\n-bool TypeInlineType::eq(const Type* t) const {\n-  const TypeInlineType* vt = t->is_inlinetype();\n-  return (_vk == vt->inline_klass() && _larval == vt->larval());\n-}\n-\n-\/\/------------------------------hash-------------------------------------------\n-\/\/ Type-specific hashing function.\n-int TypeInlineType::hash(void) const {\n-  return (intptr_t)_vk;\n-}\n-\n-\/\/------------------------------singleton--------------------------------------\n-\/\/ TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple constants.\n-bool TypeInlineType::singleton(void) const {\n-  return false;\n-}\n-\n-\/\/------------------------------empty------------------------------------------\n-\/\/ TRUE if Type is a type with no values, FALSE otherwise.\n-bool TypeInlineType::empty(void) const {\n-  return false;\n-}\n-\n-\/\/------------------------------dump2------------------------------------------\n-#ifndef PRODUCT\n-void TypeInlineType::dump2(Dict &d, uint depth, outputStream* st) const {\n-  if (_vk == NULL) {\n-    st->print(\"BOTTOM inlinetype\");\n-    return;\n-  }\n-  int count = _vk->nof_declared_nonstatic_fields();\n-  st->print(\"inlinetype[%d]:{\", count);\n-  st->print(\"%s\", count != 0 ? _vk->declared_nonstatic_field_at(0)->type()->name() : \"empty\");\n-  for (int i = 1; i < count; ++i) {\n-    st->print(\", %s\", _vk->declared_nonstatic_field_at(i)->type()->name());\n-  }\n-  st->print(\"}%s\", _larval?\" : larval\":\"\");\n-}\n-#endif\n-\n@@ -2869,1 +2734,0 @@\n-  case InlineType:\n@@ -3862,1 +3726,1 @@\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, false, not_flat, not_null_free);\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ false, not_flat, not_null_free);\n@@ -3872,1 +3736,1 @@\n-                                        \/* stable= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n+                                        \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n@@ -3878,2 +3742,3 @@\n-    ciInlineKlass* vk = klass->as_array_klass()->element_klass()->as_inline_klass();\n-    const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::POS);\n+    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass->as_array_klass()->element_klass(), trust_interfaces);\n+    etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS, \/* stable= *\/ false, \/* flat= *\/ true);\n@@ -3912,1 +3777,1 @@\n-                                        \/* stable= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ !null_free);\n+                                        \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ !null_free);\n@@ -3925,1 +3790,1 @@\n-                                        \/* stable= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n+                                        \/* stable= *\/ false, \/* flat= *\/ false, \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n@@ -3934,2 +3799,3 @@\n-    ciInlineKlass* vk = klass->as_array_klass()->element_klass()->as_inline_klass();\n-    const TypeAry* arr0 = TypeAry::make(TypeInlineType::make(vk), TypeInt::make(o->as_array()->length()));\n+    const TypeOopPtr* etype = TypeOopPtr::make_from_klass_raw(klass->as_array_klass()->element_klass(), trust_interfaces);\n+    etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()), \/* stable= *\/ false, \/* flat= *\/ true);\n@@ -4505,22 +4371,0 @@\n-  case InlineType: {\n-    const TypeInlineType* tv = t->is_inlinetype();\n-    InterfaceSet interfaces = tv->interfaces();\n-    if (above_centerline(ptr())) {\n-      if (tv->inline_klass()->is_subtype_of(_klass) && interfaces.contains(_interfaces)) {\n-        return t;\n-      } else {\n-        return TypeInstPtr::NOTNULL;\n-      }\n-    } else {\n-      PTR ptr = this->_ptr;\n-      if (ptr == Constant) {\n-        ptr = NotNull;\n-      }\n-      if (tv->inline_klass()->is_subtype_of(_klass) && interfaces.contains(_interfaces)) {\n-        return make(ptr, _klass, _interfaces, false, NULL, Offset(0), _flatten_array, InstanceBot, _speculative);\n-      } else {\n-        return make(ptr, ciEnv::current()->Object_klass());\n-      }\n-    }\n-  }\n-\n@@ -4850,2 +4694,1 @@\n-    return this_one->is_reference_type(this_elem)->is_meet_subtype_of_helper(this_one->is_reference_type(other_elem), this_xk, other_xk) &&\n-      (this_one->is_null_free() == other_ary->is_null_free() || (this_one->is_null_free() && !other_ary->is_null_free()));\n+    return this_one->is_reference_type(this_elem)->is_meet_subtype_of_helper(this_one->is_reference_type(other_elem), this_xk, other_xk);\n@@ -4853,16 +4696,0 @@\n-\n-  if (this_one->elem()->isa_inlinetype()) {\n-    ciInstanceKlass* inline_klass = this_one->elem()->is_inlinetype()->inline_klass();\n-    if (other_ary->elem()->isa_inlinetype()) {\n-      return inline_klass == other_ary->elem()->is_inlinetype()->inline_klass();\n-    } else {\n-      auto other_inst = this_one->is_instance_type(this_one->is_reference_type(other_elem));\n-      if (other_inst != nullptr) {\n-        const InterfaceSet interfaces = this_one->elem()->is_inlinetype()->interfaces();\n-        return inline_klass->is_subtype_of(other_inst->instance_klass()) && interfaces.contains(other_inst->interfaces());\n-      } else {\n-        return false;\n-      }\n-    }\n-  }\n-\n@@ -4913,0 +4740,3 @@\n+  if (k != NULL && k->is_flat_array_klass() && !ary->_flat) {\n+    k = NULL;\n+  }\n@@ -4929,0 +4759,3 @@\n+  if (k != NULL && k->is_flat_array_klass() && !ary->_flat) {\n+    k = NULL;\n+  }\n@@ -4943,7 +4776,1 @@\n-\n-  const TypeAry* new_ary = _ary;\n-  if (klass() != NULL && klass()->is_obj_array_klass() && klass_is_exact) {\n-    \/\/ An object array can't be flat or null-free if the klass is exact\n-    new_ary = TypeAry::make(elem(), size(), is_stable(), \/* not_flat= *\/ true, \/* not_null_free= *\/ true);\n-  }\n-  return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact, _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n+  return make(ptr(), const_oop(), _ary, klass(), klass_is_exact, _offset, _field_offset, _instance_id, _speculative, _inline_depth, _is_autobox_cache);\n@@ -5011,1 +4838,1 @@\n-  const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_not_flat(), is_not_null_free());\n+  const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable(), is_flat(), is_not_flat(), is_not_null_free());\n@@ -5020,1 +4847,2 @@\n-  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_flat, is_not_null_free());\n+  assert(!not_flat || !is_flat(), \"inconsistency\");\n+  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), is_flat(), not_flat, is_not_null_free());\n@@ -5029,2 +4857,2 @@\n-  \/\/ Not null free implies not flat\n-  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), not_null_free ? true : is_not_flat(), not_null_free);\n+  assert(!not_null_free || !is_flat(), \"inconsistency\");\n+  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), is_flat(), \/* not_flat= *\/ not_null_free ? true : is_not_flat(), not_null_free);\n@@ -5079,1 +4907,1 @@\n-  const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_not_flat(), is_not_null_free());\n+  const TypeAry* new_ary = TypeAry::make(elem, size(), stable, is_flat(), is_not_flat(), is_not_null_free());\n@@ -5101,1 +4929,1 @@\n-  const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_not_flat(), is_not_null_free());\n+  const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable(), is_flat(), is_not_flat(), is_not_null_free());\n@@ -5225,0 +5053,1 @@\n+    bool res_flat = false;\n@@ -5228,1 +5057,1 @@\n-    if (meet_aryptr(ptr, elem, this, tap, res_klass, res_xk, res_not_flat, res_not_null_free) == NOT_SUBTYPE) {\n+    if (meet_aryptr(ptr, elem, this, tap, res_klass, res_xk, res_flat, res_not_flat, res_not_null_free) == NOT_SUBTYPE) {\n@@ -5230,1 +5059,1 @@\n-    } else if ((this->elem()->isa_inlinetype() != NULL) != (tap->elem()->isa_inlinetype() != NULL)) {\n+    } else if (this->is_flat() != tap->is_flat()) {\n@@ -5232,1 +5061,1 @@\n-      if (tary->_elem->isa_inlinetype()) {\n+      if (tary->_flat) {\n@@ -5236,1 +5065,1 @@\n-      } else if (tary->_elem->make_oopptr() != NULL && tary->_elem->make_oopptr()->isa_instptr() && below_centerline(ptr)) {\n+      } else if (below_centerline(ptr)) {\n@@ -5240,0 +5069,3 @@\n+      } else if (flattened_offset() == tap->flattened_offset()) {\n+        off = Offset(!is_flat() ? offset() : tap->offset());\n+        field_off = !is_flat() ? field_offset() : tap->field_offset();\n@@ -5258,1 +5090,1 @@\n-    return make(ptr, o, TypeAry::make(elem, tary->_size, tary->_stable, res_not_flat, res_not_null_free), res_klass, res_xk, off, field_off, instance_id, speculative, depth);\n+    return make(ptr, o, TypeAry::make(elem, tary->_size, tary->_stable, res_flat, res_not_flat, res_not_null_free), res_klass, res_xk, off, field_off, instance_id, speculative, depth);\n@@ -5317,13 +5149,0 @@\n-\n-  case InlineType: {\n-    const TypeInlineType* tv = t->is_inlinetype();\n-    if (above_centerline(ptr())) {\n-      return TypeInstPtr::NOTNULL;\n-    } else {\n-      PTR ptr = this->_ptr;\n-      if (ptr == Constant) {\n-        ptr = NotNull;\n-      }\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass());\n-    }\n-  }\n@@ -5336,1 +5155,1 @@\n-                                                           ciKlass*& res_klass, bool& res_xk, bool& res_not_flat, bool& res_not_null_free) {\n+                                                           ciKlass*& res_klass, bool& res_xk, bool &res_flat, bool& res_not_flat, bool& res_not_null_free) {\n@@ -5346,0 +5165,1 @@\n+  bool this_flat = this_ary->is_flat();\n@@ -5347,0 +5167,1 @@\n+  bool other_flat = other_ary->is_flat();\n@@ -5352,0 +5173,1 @@\n+  res_flat = this_flat && other_flat;\n@@ -5381,2 +5203,1 @@\n-      if (above_centerline(ptr) || (elem->make_ptr() && above_centerline(elem->make_ptr()->_ptr)) ||\n-          elem->isa_inlinetype()) {\n+      if (above_centerline(ptr) || (elem->make_ptr() && above_centerline(elem->make_ptr()->_ptr))) {\n@@ -5398,1 +5219,1 @@\n-        if (this_ary->elem()->isa_inlinetype()) {\n+        if (this_ary->is_flat()) {\n@@ -5408,1 +5229,1 @@\n-      } else if(above_centerline(this_ptr)) {\n+      } else if (above_centerline(this_ptr)) {\n@@ -5413,0 +5234,4 @@\n+        \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+        if (res_xk && !res_not_null_free) {\n+          res_xk = false;\n+        }\n@@ -5421,1 +5246,1 @@\n-        if (other_ary->elem()->isa_inlinetype()) {\n+        if (other_ary->is_flat()) {\n@@ -5427,0 +5252,4 @@\n+        \/\/ Even if MyValue is exact, [LMyValue is not exact due to [QMyValue <: [LMyValue.\n+        if (res_xk && !res_not_null_free) {\n+          res_xk = false;\n+        }\n@@ -5434,1 +5263,0 @@\n-\n@@ -5480,0 +5308,1 @@\n+    st->print(\":flat\");\n@@ -5484,0 +5313,3 @@\n+  if (is_null_free()) {\n+    st->print(\":null_free\");\n+  }\n@@ -5567,13 +5399,10 @@\n-  if (offset != Type::OffsetBot && offset != Type::OffsetTop) {\n-    const Type* elemtype = elem();\n-    if (elemtype->isa_inlinetype()) {\n-      if (_offset.get() != OffsetBot && _offset.get() != OffsetTop) {\n-        adj = _offset.get();\n-        offset += _offset.get();\n-      }\n-      uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);\n-      if (_field_offset.get() != OffsetBot && _field_offset.get() != OffsetTop) {\n-        offset += _field_offset.get();\n-        if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {\n-          offset += header;\n-        }\n+  if (is_flat() && offset != Type::OffsetBot && offset != Type::OffsetTop) {\n+    if (_offset.get() != OffsetBot && _offset.get() != OffsetTop) {\n+      adj = _offset.get();\n+      offset += _offset.get();\n+    }\n+    uint header = arrayOopDesc::base_offset_in_bytes(T_OBJECT);\n+    if (_field_offset.get() != OffsetBot && _field_offset.get() != OffsetTop) {\n+      offset += _field_offset.get();\n+      if (_offset.get() == OffsetBot || _offset.get() == OffsetTop) {\n+        offset += header;\n@@ -5581,12 +5410,10 @@\n-      if (offset >= (intptr_t)header || offset < 0) {\n-        \/\/ Try to get the field of the inline type array element we are pointing to\n-        ciKlass* arytype_klass = klass();\n-        ciFlatArrayKlass* vak = arytype_klass->as_flat_array_klass();\n-        ciInlineKlass* vk = vak->element_klass()->as_inline_klass();\n-        int shift = vak->log2_element_size();\n-        int mask = (1 << shift) - 1;\n-        intptr_t field_offset = ((offset - header) & mask);\n-        ciField* field = vk->get_field_by_offset(field_offset + vk->first_field_offset(), false);\n-        if (field != NULL) {\n-          return with_field_offset(field_offset)->add_offset(offset - field_offset - adj);\n-        }\n+    }\n+    if (offset >= (intptr_t)header || offset < 0) {\n+      \/\/ Try to get the field of the inline type array element we are pointing to\n+      ciInlineKlass* vk = elem()->inline_klass();\n+      int shift = flat_log_elem_size();\n+      int mask = (1 << shift) - 1;\n+      intptr_t field_offset = ((offset - header) & mask);\n+      ciField* field = vk->get_field_by_offset(field_offset + vk->first_field_offset(), false);\n+      if (field != NULL) {\n+        return with_field_offset(field_offset)->add_offset(offset - field_offset - adj);\n@@ -5712,3 +5539,0 @@\n-  case InlineType:\n-    return t->xmeet(this);\n-\n@@ -5967,1 +5791,1 @@\n-        (is_null_free() || !_ary->_elem->make_oopptr()->is_inlinetypeptr())) {\n+        (is_null_free() || is_flat() || !_ary->_elem->make_oopptr()->is_inlinetypeptr())) {\n@@ -5970,2 +5794,0 @@\n-  } else if (elem->isa_inlinetype() != NULL) {\n-    elem = TypeKlassPtr::make(elem->inline_klass());\n@@ -6355,21 +6177,0 @@\n-  case InlineType: {\n-    const TypeInlineType* tv = t->is_inlinetype();\n-    InterfaceSet interfaces = tv->interfaces();\n-    if (above_centerline(ptr())) {\n-      if (tv->inline_klass()->is_subtype_of(_klass) && interfaces.contains(_interfaces)) {\n-        return t;\n-      } else {\n-        return TypeInstPtr::NOTNULL;\n-      }\n-    } else {\n-      PTR ptr = this->_ptr;\n-      if (ptr == Constant) {\n-        ptr = NotNull;\n-      }\n-      if (tv->inline_klass()->is_subtype_of(_klass) && interfaces.contains(_interfaces)) {\n-        return make(ptr, _klass, _interfaces, Offset(0), _flatten_array);\n-      } else {\n-        return make(ptr, ciEnv::current()->Object_klass(), Offset(0));\n-      }\n-    }\n-  }\n@@ -6493,1 +6294,1 @@\n-  return _elem->isa_inlinetype() || (_elem->isa_instklassptr() && _elem->is_instklassptr()->_klass->can_be_inline_klass());\n+  return _elem->isa_instklassptr() && _elem->is_instklassptr()->_klass->can_be_inline_klass();\n@@ -6501,1 +6302,1 @@\n-  return elem()->isa_inlinetype() || (elem()->make_ptr() && elem()->make_ptr()->isa_instptr() && elem()->make_ptr()->is_instptr()->_klass->can_be_inline_klass());\n+  return elem()->make_ptr() && elem()->make_ptr()->isa_instptr() && elem()->make_ptr()->is_instptr()->_klass->can_be_inline_klass();\n@@ -6562,1 +6363,2 @@\n-  return (intptr_t)_elem + TypeKlassPtr::hash();\n+  return (intptr_t)_elem + TypeKlassPtr::hash() + (_not_flat ? 43 : 0) +\n+      (_not_null_free ? 44 : 0) + (_null_free ? 45 : 0);\n@@ -6578,6 +6380,2 @@\n-  if ((tinst = el->isa_instptr()) != NULL) {\n-    \/\/ Leave k_ary at NULL.\n-  } else if ((tary = el->isa_aryptr()) != NULL) {\n-    \/\/ Leave k_ary at NULL.\n-  } else if (el->isa_inlinetype()) {\n-    \/\/ If element type is TypeInlineType::BOTTOM, inline_klass() will be null.\n+  if (is_flat() && el->is_inlinetypeptr()) {\n+    \/\/ Klass is required by TypeAryPtr::flat_layout_helper() and others\n@@ -6587,0 +6385,4 @@\n+  } else if ((tinst = el->isa_instptr()) != NULL) {\n+    \/\/ Leave k_ary at NULL.\n+  } else if ((tary = el->isa_aryptr()) != NULL) {\n+    \/\/ Leave k_ary at NULL.\n@@ -6717,2 +6519,2 @@\n-      \/\/ An object array can't be flat or null-free if the klass is exact\n-      not_flat = true;\n+      assert(!is_null_free() && !is_flat(), \"null-free (or flat) inline type arrays should always be exact\");\n+      \/\/ An array can't be null-free (or flat) if the klass is exact\n@@ -6720,0 +6522,1 @@\n+      not_flat = true;\n@@ -6721,1 +6524,0 @@\n-      assert(_elem->isa_instklassptr(), \"\");\n@@ -6749,6 +6551,1 @@\n-  bool not_flat = is_not_flat();\n-  bool not_null_free = is_not_null_free();\n-  if (is_flat()) {\n-    el = TypeInlineType::make(el->inline_klass());\n-  }\n-  return TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(el, TypeInt::POS, false, not_flat, not_null_free), k, xk, Offset(0));\n+  return TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(el, TypeInt::POS, false, is_flat(), is_not_flat(), is_not_null_free()), k, xk, Offset(0));\n@@ -6834,0 +6631,1 @@\n+    bool res_flat = false;\n@@ -6837,1 +6635,1 @@\n-                                 res_klass, res_xk, res_not_flat, res_not_null_free);\n+                                 res_klass, res_xk, res_flat, res_not_flat, res_not_null_free);\n@@ -6847,0 +6645,2 @@\n+      } else if (above_centerline(this->ptr()) && above_centerline(tap->ptr())) {\n+        null_free = _null_free || tap->_null_free;\n@@ -6897,12 +6697,0 @@\n-  case InlineType: {\n-    const TypeInlineType* tv = t->is_inlinetype();\n-    if (above_centerline(ptr())) {\n-      return TypeInstKlassPtr::BOTTOM;\n-    } else {\n-      PTR ptr = this->_ptr;\n-      if (ptr == Constant) {\n-        ptr = NotNull;\n-      }\n-      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), Offset(0));\n-    }\n-  }\n@@ -6947,14 +6735,0 @@\n-  if (this_one->elem()->isa_inlinetype()) {\n-    ciInstanceKlass* inline_klass = this_one->elem()->is_inlinetype()->inline_klass();\n-    if (other_ary->elem()->isa_inlinetype()) {\n-      return inline_klass == other_ary->elem()->is_inlinetype()->inline_klass();\n-    } else {\n-      auto other_inst = this_one->is_instance_type(this_one->is_reference_type(other_elem));\n-      if (other_inst != nullptr) {\n-        const InterfaceSet interfaces = this_one->elem()->is_inlinetype()->interfaces();\n-        return inline_klass->is_subtype_of(other_inst->instance_klass()) && interfaces.contains(other_inst->interfaces());\n-      } else {\n-        return false;\n-      }\n-    }\n-  }\n@@ -6991,10 +6765,1 @@\n-    return this_one->is_reference_type(this_elem)->is_same_java_type_as(this_one->is_reference_type(other_elem)) &&\n-            this_one->is_null_free() == other_ary->is_null_free();\n-  }\n-  if (this_one->elem()->isa_inlinetype()) {\n-    ciInstanceKlass* inline_klass = this_one->elem()->is_inlinetype()->inline_klass();\n-    if (other_ary->elem()->isa_inlinetype()) {\n-      return inline_klass == other_ary->elem()->is_inlinetype()->inline_klass();\n-    } else {\n-      return false;\n-    }\n+    return this_one->is_reference_type(this_elem)->is_same_java_type_as(this_one->is_reference_type(other_elem));\n@@ -7042,14 +6807,0 @@\n-  if (this_one->elem()->isa_inlinetype()) {\n-    ciInstanceKlass* inline_klass = this_one->elem()->is_inlinetype()->inline_klass();\n-    if (other_ary->elem()->isa_inlinetype()) {\n-      return inline_klass == other_ary->elem()->is_inlinetype()->inline_klass();\n-    } else {\n-      auto other_inst = this_one->is_instance_type(this_one->is_reference_type(other_elem));\n-      if (other_inst != nullptr) {\n-        const InterfaceSet interfaces = this_one->elem()->is_inlinetype()->interfaces();\n-        return inline_klass->is_subtype_of(other_inst->instance_klass()) && interfaces.contains(other_inst->interfaces());\n-      } else {\n-        return false;\n-      }\n-    }\n-  }\n@@ -7091,8 +6842,0 @@\n-\n-\/\/  if (el->isa_inlinetype()) {\n-\/\/    \/\/ If element type is TypeInlineType::BOTTOM, inline_klass() will be null.\n-\/\/    if (el->inline_klass() != NULL) {\n-\/\/      k = ciArrayKlass::make(el->inline_klass(), \/* null_free *\/ true);\n-\/\/      ((TypeAryKlassPtr*)this)->_klass = k;\n-\/\/    }\n-\/\/  }\n@@ -7120,4 +6863,0 @@\n-      if (_elem->isa_inlinetype()) {\n-        const char *name = _elem->is_inlinetype()->inline_klass()->name()->as_utf8();\n-        st->print(\"precise %s: \" INTPTR_FORMAT \" \", name, p2i(klass()));\n-      }\n@@ -7138,0 +6877,2 @@\n+  if (is_flat()) st->print(\":flat\");\n+  if (_null_free) st->print(\":null free\");\n@@ -7139,1 +6880,0 @@\n-    if (is_flat()) st->print(\":flat\");\n@@ -7142,1 +6882,0 @@\n-    if (_null_free) st->print(\":null free\");\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":107,"deletions":368,"binary":false,"changes":475,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-class   TypeInlineType;\n@@ -106,1 +105,0 @@\n-    InlineType,                 \/\/ Inline type\n@@ -338,2 +336,0 @@\n-  const TypeInlineType* isa_inlinetype() const;  \/\/ Returns NULL if not Inline Type\n-  const TypeInlineType* is_inlinetype() const;   \/\/ Inline Type\n@@ -784,2 +780,2 @@\n-  TypeAry(const Type* elem, const TypeInt* size, bool stable, bool not_flat, bool not_null_free) : Type(Array),\n-      _elem(elem), _size(size), _stable(stable), _not_flat(not_flat), _not_null_free(not_null_free) {}\n+  TypeAry(const Type* elem, const TypeInt* size, bool stable, bool flat, bool not_flat, bool not_null_free) : Type(Array),\n+      _elem(elem), _size(size), _stable(stable), _flat(flat), _not_flat(not_flat), _not_null_free(not_null_free) {}\n@@ -798,0 +794,1 @@\n+  const bool _flat;             \/\/ Array is flattened\n@@ -805,1 +802,1 @@\n-                             bool not_flat = false, bool not_null_free = false);\n+                             bool flat = false, bool not_flat = false, bool not_null_free = false);\n@@ -918,1 +915,0 @@\n-  friend class TypeInlineType;\n@@ -1026,1 +1022,1 @@\n-                                                  ciKlass*& res_klass, bool& res_xk, bool &res_not_flat, bool &res_not_null_free);\n+                                                  ciKlass*& res_klass, bool& res_xk, bool &res_flat, bool &res_not_flat, bool &res_not_null_free);\n@@ -1507,1 +1503,1 @@\n-  bool is_flat()          const { return _ary->_elem->isa_inlinetype() != NULL; }\n+  bool is_flat()          const { return _ary->_flat; }\n@@ -2071,42 +2067,0 @@\n-\/\/ TODO 8293800 Remove\n-\/\/------------------------------TypeValue---------------------------------------\n-\/\/ Class of Inline Type Types\n-class TypeInlineType : public Type {\n-private:\n-  ciInlineKlass* _vk;\n-  TypePtr::InterfaceSet _interfaces;\n-  bool _larval;\n-\n-protected:\n-  TypeInlineType(ciInlineKlass* vk, TypePtr::InterfaceSet interfaces, bool larval)\n-          : Type(InlineType),\n-            _vk(vk), _interfaces(interfaces), _larval(larval) {\n-  }\n-\n-public:\n-  static const TypeInlineType* make(ciInlineKlass* vk, bool larval = false);\n-  virtual ciInlineKlass* inline_klass() const { return _vk; }\n-  TypePtr::InterfaceSet interfaces() const { return _interfaces; }\n-  bool larval() const { return _larval; }\n-\n-  virtual bool eq(const Type* t) const;\n-  virtual int  hash() const;             \/\/ Type specific hashing\n-  virtual bool singleton(void) const;    \/\/ TRUE if type is a singleton\n-  virtual bool empty(void) const;        \/\/ TRUE if type is vacuous\n-\n-  virtual const Type* xmeet(const Type* t) const;\n-  virtual const Type* xdual() const;     \/\/ Compute dual right now.\n-\n-  virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }\n-  virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }\n-\n-  virtual bool maybe_null() const { return false; }\n-\n-  static const TypeInlineType* BOTTOM;\n-\n-#ifndef PRODUCT\n-  virtual void dump2(Dict &d, uint, outputStream* st) const; \/\/ Specialized per-Type dumping\n-#endif\n-};\n-\n-\n@@ -2278,9 +2232,0 @@\n-inline const TypeInlineType* Type::isa_inlinetype() const {\n-  return (_base == InlineType) ? (TypeInlineType*)this : NULL;\n-}\n-\n-inline const TypeInlineType* Type::is_inlinetype() const {\n-  assert(_base == InlineType, \"Not an inline type\");\n-  return (TypeInlineType*)this;\n-}\n-\n@@ -2376,2 +2321,1 @@\n-  assert(is_inlinetypeptr(), \"must be an inline type ptr\");\n-  return is_instptr()->instance_klass()->as_inline_klass();\n+  return make_ptr()->is_instptr()->instance_klass()->as_inline_klass();\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":7,"deletions":63,"binary":false,"changes":70,"status":"modified"}]}