{"files":[{"patch":"@@ -7,1 +7,2 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists,copyright\n+#error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists,copyright\n+error=author,committer,executable,symlink,message,hg-tag,whitespace,problemlists,copyright\n@@ -30,1 +31,1 @@\n-pattern=^([124-8][0-9]{6}): \\[lworld\\] (\\S.*)$\n+pattern=^([124-8][0-9]{6}): \\[lw5\\] (\\S.*)$\n","filename":".jcheck\/conf","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+     * @throws IllegalArgumentException if any signature has null markers\n@@ -95,0 +96,1 @@\n+     * @throws IllegalArgumentException if any signature has null markers\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassSignature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,1 +135,2 @@\n-     * @throws IllegalArgumentException if any of {@code arguments} is void\n+     * @throws IllegalArgumentException if any of {@code arguments} is void or\n+     *         any of the exceptions signatures has null markers\n@@ -141,0 +142,4 @@\n+        var sanitizedExceptions = List.copyOf(requireNonNull(exceptions));\n+        for (var each : sanitizedExceptions) {\n+            SignaturesImpl.validateUnmarked((Signature.RefTypeSig) each);\n+        }\n@@ -143,1 +148,1 @@\n-                List.copyOf(requireNonNull(exceptions)),\n+                sanitizedExceptions,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodSignature.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.reflect.NullRestrictedType;\n@@ -41,0 +42,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -145,0 +147,60 @@\n+\n+        \/**\n+         * The null marker on a reference type signature. A null marker is\n+         * a prefix to reference type signatures.\n+         *\n+         * @since Valhalla\n+         *\/\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        enum NullMarker {\n+            \/\/ See JCNullableTypeExpression.NullMaker\n+            \/**\n+             * No null marker on a reference type.  This indicates no null\n+             * restriction, or when null restriction is insignificant.\n+             *\/\n+            UNSPECIFIED,\n+            \/**\n+             * A not-null marker on a reference type, {@code !}.  This\n+             * indicates null restriction for the values accepted by this type.\n+             *\n+             * @see NullRestrictedType\n+             *\/\n+            NOT_NULL,\n+            ;\n+        }\n+\n+        \/**\n+         * {@return the null marker on this reference type signature}\n+         *\n+         * @since Valhalla\n+         *\/\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        NullMarker nullMarker();\n+\n+        \/**\n+         * {@return a reference type signature with updated null marker,\n+         * otherwise equivalent to this signature}\n+         *\n+         * @param marker the updated marker\n+         * @since Valhalla\n+         *\/\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        RefTypeSig nullMarker(NullMarker marker);\n+\n+        \/**\n+         * {@return a reference type signature with no null marker, otherwise\n+         * equivalent to this signature}\n+         *\n+         * @since Valhalla\n+         *\/\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        RefTypeSig nullUnspecified();\n+\n+        \/**\n+         * {@return a reference type signature with null check, otherwise\n+         * equivalent to this signature}\n+         *\n+         * @since Valhalla\n+         *\/\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        RefTypeSig nullChecked();\n@@ -219,0 +281,16 @@\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        @Override\n+        ClassTypeSig nullMarker(NullMarker marker);\n+\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        @Override\n+        default ClassTypeSig nullUnspecified() {\n+            return nullMarker(NullMarker.UNSPECIFIED);\n+        }\n+\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        @Override\n+        default ClassTypeSig nullChecked() {\n+            return nullMarker(NullMarker.NOT_NULL);\n+        }\n+\n@@ -221,0 +299,1 @@\n+         * The returned signature has no null marker.\n@@ -234,0 +313,1 @@\n+         * The returned signature has no null marker.\n@@ -240,1 +320,2 @@\n-         *         {@linkplain Signature##identifier denoted}\n+         *         {@linkplain Signature##identifier denoted}, or if\n+         *         {@code outerType} has null markers\n@@ -255,0 +336,1 @@\n+         * The returned signature has no null marker.\n@@ -268,0 +350,1 @@\n+         * The returned signature has no null marker.\n@@ -274,1 +357,2 @@\n-         *         {@linkplain Signature##identifier denoted}\n+         *         {@linkplain Signature##identifier denoted}, or if\n+         *         {@code outerType} has null markers\n@@ -278,0 +362,1 @@\n+                SignaturesImpl.validateUnmarked(outerType);\n@@ -282,1 +367,1 @@\n-            return new SignaturesImpl.ClassTypeSigImpl(Optional.ofNullable(outerType), className, List.of(typeArgs));\n+            return new SignaturesImpl.ClassTypeSigImpl(NullMarker.UNSPECIFIED, Optional.ofNullable(outerType), className, List.of(typeArgs));\n@@ -368,0 +453,1 @@\n+         * @throws IllegalArgumentException if {@code boundType} has null markers\n@@ -386,0 +472,1 @@\n+         * @throws IllegalArgumentException if {@code boundType} has null markers\n@@ -397,0 +484,1 @@\n+         * @throws IllegalArgumentException if {@code boundType} has null markers\n@@ -409,0 +497,1 @@\n+         * @throws IllegalArgumentException if {@code boundType} has null markers\n@@ -434,0 +523,16 @@\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        @Override\n+        TypeVarSig nullMarker(NullMarker marker);\n+\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        @Override\n+        default TypeVarSig nullUnspecified() {\n+            return nullMarker(NullMarker.UNSPECIFIED);\n+        }\n+\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        @Override\n+        default TypeVarSig nullChecked() {\n+            return nullMarker(NullMarker.NOT_NULL);\n+        }\n+\n@@ -436,0 +541,1 @@\n+         * The returned signature has no null marker.\n@@ -442,1 +548,1 @@\n-            return new SignaturesImpl.TypeVarSigImpl(SignaturesImpl.validateIdentifier(identifier));\n+            return new SignaturesImpl.TypeVarSigImpl(NullMarker.UNSPECIFIED, SignaturesImpl.validateIdentifier(identifier));\n@@ -462,0 +568,16 @@\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        @Override\n+        ArrayTypeSig nullMarker(NullMarker marker);\n+\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        @Override\n+        default ArrayTypeSig nullUnspecified() {\n+            return nullMarker(NullMarker.UNSPECIFIED);\n+        }\n+\n+        @PreviewFeature(feature = PreviewFeature.Feature.NULL_RESTRICTION, reflective = true)\n+        @Override\n+        default ArrayTypeSig nullChecked() {\n+            return nullMarker(NullMarker.NOT_NULL);\n+        }\n+\n@@ -464,0 +586,2 @@\n+         * The returned signature has no null marker.\n+         *\n@@ -465,1 +589,2 @@\n-         * @throws IllegalArgumentException if the component type is void\n+         * @throws IllegalArgumentException if the component type is void or\n+         *         has null markers\n@@ -473,0 +598,2 @@\n+         * The returned signature has no null marker.\n+         *\n@@ -477,1 +604,1 @@\n-         *         type is void\n+         *         type is void or the component type has null markers\n@@ -481,0 +608,3 @@\n+            if (componentSignature instanceof RefTypeSig ref) {\n+                SignaturesImpl.validateUnmarked(ref);\n+            }\n@@ -484,1 +614,1 @@\n-                return new SignaturesImpl.ArrayTypeSigImpl(dims + arr.arrayDepth(), arr.elemType());\n+                return new SignaturesImpl.ArrayTypeSigImpl(NullMarker.UNSPECIFIED, dims + arr.arrayDepth(), arr.elemType());\n@@ -488,1 +618,1 @@\n-            return new SignaturesImpl.ArrayTypeSigImpl(dims, componentSignature);\n+            return new SignaturesImpl.ArrayTypeSigImpl(NullMarker.UNSPECIFIED, dims, componentSignature);\n@@ -529,1 +659,2 @@\n-         *         Signature##identifier denoted}\n+         *         Signature##identifier denoted}, or any of the bounds has\n+         *         null markers\n@@ -545,1 +676,2 @@\n-         *         Signature##identifier denoted}\n+         *         Signature##identifier denoted}, or any of the bounds has\n+         *         null markers\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":142,"deletions":10,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.javac.PreviewFeature.Feature;\n@@ -29,0 +31,3 @@\n+import jdk.internal.value.ValueClass;\n+\n+import java.util.Objects;\n@@ -115,0 +120,56 @@\n+    private static final int NULL_CHECKED = 0x0200;\n+\n+    \/**\n+     * Creates a new array with the specified component type, modifiers, and\n+     * length, whose elements are copied from the provided source array.\n+     *\n+     * <p>The number of dimensions of the new array must not\n+     * exceed 255.\n+     *\n+     * @param  componentType the {@code Class} object representing the\n+     *         component type of the new array\n+     * @param  modifiers the modifiers of the new array\n+     * @param  length the length of the new array\n+     * @param  sourceArray the source array from which the elements are copied\n+     * @param  sourceOffset the offset from which elements in the source array are copied\n+     * @return the new array\n+     * @throws NullPointerException if the specified\n+     *         {@code componentType} or {@code sourceArray} parameter is null,\n+     *         or if the new array is null-checked and a component of\n+     *         {@code sourceArray} cannot be stored into the new array because\n+     *         it is null\n+     * @throws IllegalArgumentException if {@code componentType} is {@link Void#TYPE}\n+     *         or if the number of dimensions of the requested array instance\n+     *         exceed 255.\n+     * @throws IndexOutOfBoundsException if {@code sourceOffset} or\n+     *         {@code sourceOffset + length} is not a valid index in\n+     *         {@code sourceArray}.\n+     * @throws ArrayStoreException if a component of {@code sourceArray} cannot\n+     *         be stored into the new array because of a type mismatch.\n+     * @throws NegativeArraySizeException if {@code length < 0}\n+     * @since Valhalla\n+     *\/\n+    @PreviewFeature(feature = Feature.NULL_RESTRICTION)\n+    public static Object newInstance(Class<?> componentType, int modifiers, int length,\n+                              Object sourceArray, int sourceOffset) {\n+        \/\/ modifiers may be ignored for now\n+        if (length < 0) {\n+            throw new NegativeArraySizeException(\"length must be >= 0\");\n+        }\n+        Objects.requireNonNull(componentType);\n+        Objects.requireNonNull(sourceArray);\n+        int sourceLength = getLength(sourceArray);\n+        Objects.checkFromIndexSize(sourceOffset, length, sourceLength);\n+        Object newArray;\n+        if ((modifiers & NULL_CHECKED) != 0 &&\n+            length > 0 &&\n+            ValueClass.isConcreteValueClass(componentType)) {\n+            newArray = ValueClass.newNullRestrictedAtomicArray(\n+                        componentType, length, get(sourceArray, 0));\n+        } else {\n+            newArray = newInstance(componentType, length);\n+        }\n+        System.arraycopy(sourceArray, sourceOffset, newArray, 0, length);\n+        return newArray;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Array.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.javac.PreviewFeature.Feature;\n+\n+\/**\n+ * NullRestrictedType represents a null-restricted type such as\n+ * {@code String!}.\n+ *\n+ * <p>Instances of classes that implement this interface must implement\n+ * an equals() method that equates any two null restricted type instances that\n+ * share the same base type.\n+ *\n+ * @since Valhalla\n+ *\/\n+@PreviewFeature(feature = Feature.NULL_RESTRICTION, reflective = true)\n+public interface NullRestrictedType extends Type {\n+    \/**\n+     * {@return the {@code Type} object representing the type to which the null-restriction has\n+     * been applied}\n+     *\/\n+    Type getBaseType();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/NullRestrictedType.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,752 @@\n+\/*\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.javac.PreviewFeature.Feature;\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Collections;\n+import java.util.function.IntFunction;\n+import java.lang.invoke.*;\n+import sun.invoke.util.Wrapper;\n+\n+import static java.lang.invoke.MethodHandles.*;\n+\n+\/**\n+ * Factory and bootstrap methods for strictly-initialized array creation.\n+ *\n+ * @since Valhalla\n+ *\/\n+@PreviewFeature(reflective = true, feature = Feature.NULL_RESTRICTION)\n+public final class ArrayCreation {\n+\n+    private ArrayCreation() {}\n+\n+    \/* FACTORIES *\/\n+\n+    \/**\n+     * Create an empty array with the given component type and modifiers.\n+     *\n+     * @param componentType array component type\n+     * @param modifiers array modifiers\n+     * @return a new array\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n+     *\/\n+    public static Object empty(Class<?> componentType, int modifiers) {\n+        Object arr = alloc(componentType, modifiers, 0);\n+        return finish(arr, componentType, modifiers, 0);\n+    }\n+\n+    \/**\n+     * Create an array with the given component type and modifiers, with every\n+     * component initialized to {@code initial}.\n+     *\n+     * @param componentType array component type\n+     * @param modifiers array modifiers\n+     * @param length array length\n+     * @param initial initial value for each component\n+     * @return a new array\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n+     * @throws NegativeArraySizeException if {@code length < 0}\n+     *\/\n+    public static Object filled(Class<?> componentType, int modifiers,\n+                                int length, Object initial) {\n+        Object arr = alloc(componentType, modifiers, length);\n+        if (!isDefault(componentType, initial)) {\n+            if (arr instanceof Object[]) {\n+                initFilled(arr, componentType, modifiers, length, initial);\n+            } else if (arr instanceof int[]) {\n+                initFilled_int(arr, componentType, modifiers, length, initial);\n+            } else if (arr instanceof long[]) {\n+                initFilled_long(arr, componentType, modifiers, length, initial);\n+            } else if (arr instanceof float[]) {\n+                initFilled_float(arr, componentType, modifiers, length, initial);\n+            } else if (arr instanceof double[]) {\n+                initFilled_double(arr, componentType, modifiers, length, initial);\n+            } else if (arr instanceof byte[]) {\n+                initFilled_byte(arr, componentType, modifiers, length, initial);\n+            } else if (arr instanceof short[]) {\n+                initFilled_short(arr, componentType, modifiers, length, initial);\n+            } else if (arr instanceof char[]) {\n+                initFilled_char(arr, componentType, modifiers, length, initial);\n+            } else if (arr instanceof boolean[]) {\n+                initFilled_boolean(arr, componentType, modifiers, length, initial);\n+            } else {\n+                throw new AssertionError();\n+            }\n+        }\n+        return finish(arr, componentType, modifiers, length);\n+    }\n+\n+    \/**\n+     * Create an array with the given component type and modifiers, with initial\n+     * components provided by an {@code IntFunction}.\n+     *\n+     * @param componentType array component type\n+     * @param modifiers array modifiers\n+     * @param length array length\n+     * @param generator function to produce the initial value for each component\n+     * @return a new array\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n+     * @throws NegativeArraySizeException if {@code length < 0}\n+     *\/\n+    public static Object computed(Class<?> componentType, int modifiers,\n+                                  int length, IntFunction<?> generator) {\n+        Object arr = alloc(componentType, modifiers, length);\n+        if (arr instanceof Object[]) {\n+            initComputed(arr, componentType, modifiers, length, generator);\n+        } else if (arr instanceof int[]) {\n+            initComputed_int(arr, componentType, modifiers, length, generator);\n+        } else if (arr instanceof long[]) {\n+            initComputed_long(arr, componentType, modifiers, length, generator);\n+        } else if (arr instanceof float[]) {\n+            initComputed_float(arr, componentType, modifiers, length, generator);\n+        } else if (arr instanceof double[]) {\n+            initComputed_double(arr, componentType, modifiers, length, generator);\n+        } else if (arr instanceof byte[]) {\n+            initComputed_byte(arr, componentType, modifiers, length, generator);\n+        } else if (arr instanceof short[]) {\n+            initComputed_short(arr, componentType, modifiers, length, generator);\n+        } else if (arr instanceof char[]) {\n+            initComputed_char(arr, componentType, modifiers, length, generator);\n+        } else if (arr instanceof boolean[]) {\n+            initComputed_boolean(arr, componentType, modifiers, length, generator);\n+        } else {\n+            throw new AssertionError();\n+        }\n+        return finish(arr, componentType, modifiers, length);\n+    }\n+\n+    \/**\n+     * Create an array with the given component type and modifiers, with initial\n+     * components provided by the first {@code length} components of\n+     * {@code sourceArray}.\n+     *\n+     * @param componentType array component type\n+     * @param modifiers array modifiers\n+     * @param length array length\n+     * @param sourceArray array to copy from\n+     * @return a new array\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n+     * @throws NegativeArraySizeException if {@code length < 0}\n+     *\/\n+    public static Object copied(Class<?> componentType, int modifiers,\n+                                int length, Object sourceArray) {\n+        return Array.newInstance(componentType, modifiers, length, sourceArray, 0);\n+    }\n+\n+    \/**\n+     * Create an array with the given component type and modifiers, with initial\n+     * components provided by {@code sourceArray}, from index {@code offset}\n+     * (inclusive) to index {@code offset + length} (exclusive).\n+     *\n+     * @param componentType array component type\n+     * @param modifiers array modifiers\n+     * @param length array length\n+     * @param sourceArray array to copy from\n+     * @param offset first index in {@code sourceArray} to copy from\n+     * @return a new array\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n+     * @throws NegativeArraySizeException if {@code length < 0}\n+     *\/\n+    public static Object offsetCopied(Class<?> componentType, int modifiers,\n+                                      int length, Object sourceArray, int offset) {\n+        return Array.newInstance(componentType, modifiers, length,\n+                                 sourceArray, offset);\n+    }\n+\n+    \/**\n+     * Create array of length 1 with the given component type and modifiers,\n+     * initialized with the given component value.\n+     *\n+     * @param componentType array component type\n+     * @param modifiers array modifiers\n+     * @param v0 initial value for the component at index 0\n+     * @return a new array\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n+     *\/\n+    public static Object enumerated(Class<?> componentType, int modifiers,\n+                                    Object v0) {\n+        Object arr = alloc(componentType, modifiers, 1);\n+        Array.set(arr, 0, v0);\n+        return finish(arr, componentType, modifiers, 1);\n+    }\n+\n+    \/**\n+     * Create array of length 2 with the given component type and modifiers,\n+     * initialized with the given component values.\n+     *\n+     * @param componentType array component type\n+     * @param modifiers array modifiers\n+     * @param v0 initial value for the component at index 0\n+     * @param v1 initial value for the component at index 1\n+     * @return a new array\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n+     *\/\n+    public static Object enumerated(Class<?> componentType, int modifiers,\n+                                    Object v0, Object v1) {\n+        Object arr = alloc(componentType, modifiers, 2);\n+        Array.set(arr, 0, v0);\n+        Array.set(arr, 1, v1);\n+        return finish(arr, componentType, modifiers, 2);\n+    }\n+\n+    \/**\n+     * Create array of length 3 with the given component type and modifiers,\n+     * initialized with the given component values.\n+     *\n+     * @param componentType array component type\n+     * @param modifiers array modifiers\n+     * @param v0 initial value for the component at index 0\n+     * @param v1 initial value for the component at index 1\n+     * @param v2 initial value for the component at index 2\n+     * @return a new array\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n+     *\/\n+    public static Object enumerated(Class<?> componentType, int modifiers,\n+                                    Object v0, Object v1, Object v2) {\n+        Object arr = alloc(componentType, modifiers, 3);\n+        Array.set(arr, 0, v0);\n+        Array.set(arr, 1, v1);\n+        Array.set(arr, 2, v2);\n+        return finish(arr, componentType, modifiers, 3);\n+    }\n+\n+    \/**\n+     * Create array of length 4 with the given component type and modifiers,\n+     * initialized with the given component values.\n+     *\n+     * @param componentType array component type\n+     * @param modifiers array modifiers\n+     * @param v0 initial value for the component at index 0\n+     * @param v1 initial value for the component at index 1\n+     * @param v2 initial value for the component at index 2\n+     * @param v3 initial value for the component at index 3\n+     * @return a new array\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n+     *\/\n+    public static Object enumerated(Class<?> componentType, int modifiers,\n+                                    Object v0, Object v1, Object v2, Object v3) {\n+        Object arr = alloc(componentType, modifiers, 4);\n+        Array.set(arr, 0, v0);\n+        Array.set(arr, 1, v1);\n+        Array.set(arr, 2, v2);\n+        Array.set(arr, 3, v3);\n+        return finish(arr, componentType, modifiers, 4);\n+    }\n+\n+    \/**\n+     * Create array of length 5 with the given component type and modifiers,\n+     * initialized with the given component values.\n+     *\n+     * @param componentType array component type\n+     * @param modifiers array modifiers\n+     * @param v0 initial value for the component at index 0\n+     * @param v1 initial value for the component at index 1\n+     * @param v2 initial value for the component at index 2\n+     * @param v3 initial value for the component at index 3\n+     * @param v4 initial value for the component at index 4\n+     * @return a new array\n+     * @throws IllegalArgumentException if componentType is {@link Void#TYPE}\n+     *\/\n+    public static Object enumerated(Class<?> componentType, int modifiers,\n+                                    Object v0, Object v1, Object v2, Object v3,\n+                                    Object v4) {\n+        Object arr = alloc(componentType, modifiers, 5);\n+        Array.set(arr, 0, v0);\n+        Array.set(arr, 1, v1);\n+        Array.set(arr, 2, v2);\n+        Array.set(arr, 3, v3);\n+        Array.set(arr, 4, v4);\n+        return finish(arr, componentType, modifiers, 5);\n+    }\n+\n+    \/* BOOTSTRAPS *\/\n+\n+    \/**\n+     * Bootstrap method to create an empty array. Intended for use with\n+     * {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: no parameters, with\n+     *                      an array return type\n+     * @param componentType Class representing the array component type\n+     * @param modifiers     Array modifiers\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite empty(Lookup lookup, String methodName,\n+                                 MethodType type, Class<?> componentType,\n+                                 int modifiers) throws Throwable {\n+        var factory = foldArguments(FINISH_MH, ALLOC_MH);\n+        factory = insertArguments(factory, 0, componentType, modifiers, 0);\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with a given constant initial\n+     * value. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, with an array return type\n+     * @param componentType Class representing the array component type\n+     * @param modifiers     Array modifiers\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @param initial       Initial value\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite constantFilled(Lookup lookup, String methodName,\n+                                          MethodType type, Class<?> componentType,\n+                                          int modifiers, int length, Object initial) throws Throwable {\n+        MethodHandle factory;\n+        if (isDefault(componentType, initial)) {\n+            factory = foldArguments(FINISH_MH, ALLOC_MH);\n+            factory = insertArguments(factory, 0, componentType, modifiers);\n+            if (length >= 0) {\n+                factory = insertArguments(factory, 0, length);\n+            }\n+        } else {\n+            String initName = \"initFilled\";\n+            if (componentType.isPrimitive()) {\n+                initName += \"_\" + componentType;\n+            }\n+            var init = LOOKUP.findStatic(ArrayCreation.class, initName, INIT_FILLED_TYPE);\n+            var alloc = dropArguments(ALLOC_MH, ALLOC_TYPE.parameterCount(),\n+                                      Object.class);\n+            var finish = dropArguments(FINISH_MH, FINISH_TYPE.parameterCount(),\n+                                       Object.class);\n+            factory = foldArguments(foldArguments(finish, init), alloc);\n+            factory = insertArguments(factory, 0, componentType, modifiers);\n+            factory = insertArguments(factory, 1, initial);\n+            if (length >= 0) {\n+                factory = insertArguments(factory, 0, length);\n+            }\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with a dynamically-evaluated\n+     * initial value. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, and an appropriately-typed initial value,\n+     *                      with an array return type\n+     * @param componentType Class representing the array component type\n+     * @param modifiers     Array modifiers\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite dynamicFilled(Lookup lookup, String methodName,\n+                                         MethodType type, Class<?> componentType,\n+                                         int modifiers, int length) throws Throwable {\n+        String initName = \"initFilled\";\n+        if (componentType.isPrimitive()) {\n+            initName += \"_\" + componentType;\n+        }\n+        var init = LOOKUP.findStatic(ArrayCreation.class, initName, INIT_FILLED_TYPE);\n+        var alloc = dropArguments(ALLOC_MH, ALLOC_TYPE.parameterCount(),\n+                                  Object.class);\n+        var finish = dropArguments(FINISH_MH, FINISH_TYPE.parameterCount(),\n+                                   Object.class);\n+        var factory = foldArguments(foldArguments(finish, init), alloc);\n+        factory = insertArguments(factory, 0, componentType, modifiers);\n+        if (length >= 0) {\n+            factory = insertArguments(factory, 0, length);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with lazily-computed initial\n+     * values. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, and an IntFunction producing initial values,\n+     *                      with an array return type\n+     * @param componentType Class representing the array component type\n+     * @param modifiers     Array modifiers\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite computed(Lookup lookup, String methodName,\n+                                    MethodType type, Class<?> componentType,\n+                                    int modifiers, int length) throws Throwable {\n+        String initName = \"initComputed\";\n+        if (componentType.isPrimitive()) {\n+            initName += \"_\" + componentType;\n+        }\n+        var init = LOOKUP.findStatic(ArrayCreation.class, initName, INIT_COMPUTED_TYPE);\n+        var alloc = dropArguments(ALLOC_MH, ALLOC_TYPE.parameterCount(),\n+                                  IntFunction.class);\n+        var finish = dropArguments(FINISH_MH, FINISH_TYPE.parameterCount(),\n+                                   IntFunction.class);\n+        var factory = foldArguments(foldArguments(finish, init), alloc);\n+        factory = insertArguments(factory, 0, componentType, modifiers);\n+        if (length >= 0) {\n+            factory = insertArguments(factory, 0, length);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with values copied from\n+     * another array. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, and a source array of initial values,\n+     *                      with an array return type\n+     * @param componentType Class representing the array component type\n+     * @param modifiers     Array modifiers\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite copied(Lookup lookup, String methodName,\n+                                  MethodType type, Class<?> componentType,\n+                                  int modifiers, int length) throws Throwable {\n+        var factory = insertArguments(COPY_MH, 0, componentType, modifiers);\n+        factory = insertArguments(factory, 2, 0);\n+        if (length >= 0) {\n+            factory = insertArguments(factory, 0, length);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with values copied from\n+     * another array, starting at an offset. Intended for use with\n+     * {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, a source array of initial values, and\n+     *                      a start offset into the array, with an array return type\n+     * @param componentType Class representing the array component type\n+     * @param modifiers     Array modifiers\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite offsetCopied(Lookup lookup, String methodName,\n+                                        MethodType type, Class<?> componentType,\n+                                        int modifiers, int length) throws Throwable {\n+        var factory = insertArguments(COPY_MH, 0, componentType, modifiers);\n+        if (length >= 0) {\n+            factory = insertArguments(factory, 0, length);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array initialized to an enumerated list of\n+     * constant values. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: no parameters, with\n+     *                      an array return type\n+     * @param componentType Class representing the array component type\n+     * @param modifiers     Array modifiers\n+     * @param values        Initial values\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite constantEnumerated(Lookup lookup, String methodName,\n+                                              MethodType type, Class<?> componentType,\n+                                              int modifiers, Object... values) throws Throwable {\n+        Object src = values;\n+        if (componentType.isPrimitive()) {\n+            \/\/ unbox values\n+            src = Array.newInstance(componentType, values.length);\n+            for (int i = 0; i < values.length; i++) {\n+                Array.set(src, i, values[i]);\n+            }\n+        }\n+        var factory = insertArguments(COPY_MH, 0, componentType, modifiers,\n+                                      values.length, src, 0);\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array initialized to an enumerated list of\n+     * dynamically-evaluated values. Intended for use with {@code invokedynamic}\n+     * call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: a parameter for each\n+     *                      array component, with an array return type\n+     * @param componentType Class representing the array component type\n+     * @param modifiers     Array modifiers\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite dynamicEnumerated(Lookup lookup, String methodName,\n+                                             MethodType type, Class<?> componentType,\n+                                             int modifiers) throws Throwable {\n+        Class<?> acls = componentType.arrayType();\n+        int arity = type.parameterCount();\n+        List<Class<?>> initArgs = Collections.nCopies(arity, Object.class);\n+        MethodHandle binaryId = dropArguments(identity(acls), 1, componentType);\n+        \/\/ binaryId type: (acls, comp)->acls\n+\n+       var init = MethodHandles.empty(MethodType.methodType(void.class, acls));\n+        for (int i = arity - 1; i >= 0; i--) {\n+            var setter = arrayElementSetter(acls);\n+            setter = insertArguments(setter, 1, i);\n+            setter = foldArguments(binaryId, setter);\n+            \/\/ setter type: (acls, comp)->acls\n+            init = collectArguments(init, 0, setter);\n+            \/\/ init type: (acls, comp, ...)->void\n+        }\n+        init = init.asType(init.type().generic().changeReturnType(void.class));\n+        init = dropArguments(init, 1, Class.class, int.class, int.class);\n+        \/\/ init type: (Object, Class, int, int, Object, ...)->void\n+\n+        var alloc = dropArguments(ALLOC_MH, ALLOC_TYPE.parameterCount(), initArgs);\n+        var finish = dropArguments(FINISH_MH, FINISH_TYPE.parameterCount(), initArgs);\n+        var factory = foldArguments(foldArguments(finish, init), alloc);\n+        factory = insertArguments(factory, 0, componentType, modifiers, arity);\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/* SUPPORT CODE *\/\n+\n+    private static boolean isDefault(Class<?> componentType, Object value) {\n+        if (componentType.isPrimitive()) {\n+            return Wrapper.forPrimitiveType(componentType).zero().equals(value);\n+        } else {\n+            return value == null;\n+        }\n+    }\n+\n+    private static final Lookup LOOKUP = lookup();\n+\n+    \/\/ copy\n+\n+    private static final MethodType COPY_TYPE =\n+            MethodType.methodType(Object.class, Class.class, int.class, int.class,\n+                                  Object.class, int.class);\n+\n+    private static final MethodHandle COPY_MH;\n+    static {\n+        try {\n+            COPY_MH = LOOKUP.findStatic(Array.class, \"newInstance\", COPY_TYPE);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ alloc\n+\n+    private static final MethodType ALLOC_TYPE =\n+            MethodType.methodType(Object.class, Class.class, int.class, int.class);\n+\n+    private static final MethodHandle ALLOC_MH;\n+    static {\n+        try {\n+            ALLOC_MH = LOOKUP.findStatic(ArrayCreation.class, \"alloc\", ALLOC_TYPE);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object alloc(Class<?> comp, int mods, int len) {\n+        return Array.newInstance(comp, len);\n+    }\n+\n+    \/\/ finish\n+\n+    private static final MethodType FINISH_TYPE =\n+            MethodType.methodType(Object.class, Object.class, Class.class, int.class, int.class);\n+\n+    private static final MethodHandle FINISH_MH;\n+    static {\n+        try {\n+            FINISH_MH = LOOKUP.findStatic(ArrayCreation.class, \"finish\", FINISH_TYPE);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Object finish(Object arr, Class<?> comp, int mods, int len) {\n+        if (mods == 0) {\n+            return arr;\n+        } else {\n+            return Array.newInstance(comp, mods, len, arr, 0);\n+        }\n+    }\n+\n+    \/\/ initFilled\n+\n+    private static final MethodType INIT_FILLED_TYPE =\n+            MethodType.methodType(void.class, Object.class, Class.class, int.class, int.class,\n+                                  Object.class);\n+\n+    private static void initFilled(Object arr, Class<?> comp, int mods, int len,\n+                                     Object init) {\n+        Arrays.fill((Object[]) arr, init);\n+    }\n+\n+    private static void initFilled_int(Object arr, Class<?> comp, int mods, int len,\n+                                         Object init) {\n+        Arrays.fill((int[]) arr, (int) init);\n+    }\n+\n+    private static void initFilled_long(Object arr, Class<?> comp, int mods, int len,\n+                                          Object init) {\n+        Arrays.fill((long[]) arr, (long) init);\n+    }\n+\n+    private static void initFilled_float(Object arr, Class<?> comp, int mods, int len,\n+                                          Object init) {\n+        Arrays.fill((float[]) arr, (float) init);\n+    }\n+\n+    private static void initFilled_double(Object arr, Class<?> comp, int mods, int len,\n+                                            Object init) {\n+        Arrays.fill((double[]) arr, (double) init);\n+    }\n+\n+    private static void initFilled_byte(Object arr, Class<?> comp, int mods, int len,\n+                                          Object init) {\n+        Arrays.fill((byte[]) arr, (byte) init);\n+    }\n+\n+    private static void initFilled_short(Object arr, Class<?> comp, int mods, int len,\n+                                           Object init) {\n+        Arrays.fill((short[]) arr, (short) init);\n+    }\n+\n+    private static void initFilled_char(Object arr, Class<?> comp, int mods, int len,\n+                                          Object init) {\n+        Arrays.fill((char[]) arr, (char) init);\n+    }\n+\n+    private static void initFilled_boolean(Object arr, Class<?> comp, int mods, int len,\n+                                             Object init) {\n+        Arrays.fill((boolean[]) arr, (boolean) init);\n+    }\n+\n+    \/\/ initComputed\n+\n+    private static final MethodType INIT_COMPUTED_TYPE =\n+            MethodType.methodType(void.class, Object.class, Class.class, int.class, int.class,\n+                                  IntFunction.class);\n+\n+    private static void initComputed(Object arr, Class<?> comp, int mods, int len,\n+                                     IntFunction<?> f) {\n+        Arrays.setAll((Object[]) arr, f);\n+    }\n+\n+    private static void initComputed_int(Object arr, Class<?> comp, int mods, int len,\n+                                         IntFunction<?> f) {\n+        int[] a = (int[]) arr;\n+        for (int i = 0; i < len; i++) a[i] = (int) f.apply(i);\n+    }\n+\n+    private static void initComputed_long(Object arr, Class<?> comp, int mods, int len,\n+                                          IntFunction<?> f) {\n+        long[] a = (long[]) arr;\n+        for (int i = 0; i < len; i++) a[i] = (long) f.apply(i);\n+    }\n+\n+    private static void initComputed_float(Object arr, Class<?> comp, int mods, int len,\n+                                           IntFunction<?> f) {\n+        float[] a = (float[]) arr;\n+        for (int i = 0; i < len; i++) a[i] = (float) f.apply(i);\n+    }\n+\n+    private static void initComputed_double(Object arr, Class<?> comp, int mods, int len,\n+                                            IntFunction<?> f) {\n+        double[] a = (double[]) arr;\n+        for (int i = 0; i < len; i++) a[i] = (double) f.apply(i);\n+    }\n+\n+    private static void initComputed_byte(Object arr, Class<?> comp, int mods, int len,\n+                                          IntFunction<?> f) {\n+        byte[] a = (byte[]) arr;\n+        for (int i = 0; i < len; i++) a[i] = (byte) f.apply(i);\n+    }\n+\n+    private static void initComputed_short(Object arr, Class<?> comp, int mods, int len,\n+                                          IntFunction<?> f) {\n+        short[] a = (short[]) arr;\n+        for (int i = 0; i < len; i++) a[i] = (short) f.apply(i);\n+    }\n+\n+    private static void initComputed_char(Object arr, Class<?> comp, int mods, int len,\n+                                          IntFunction<?> f) {\n+        char[] a = (char[]) arr;\n+        for (int i = 0; i < len; i++) a[i] = (char) f.apply(i);\n+    }\n+\n+    private static void initComputed_boolean(Object arr, Class<?> comp, int mods, int len,\n+                                          IntFunction<?> f) {\n+        boolean[] a = (boolean[]) arr;\n+        for (int i = 0; i < len; i++) a[i] = (boolean) f.apply(i);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ArrayCreation.java","additions":752,"deletions":0,"binary":false,"changes":752,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * This class consists of {@code static} utility methods for checking\n+ * if any of their arguments is {@code null}.\n+ *\n+ * @since valhalla\n+ *\/\n+public final class Checks {\n+    private Checks() {\n+        throw new AssertionError(\"can't instantiate java.lang.runtime.Checks\");\n+    }\n+\n+    \/**\n+     * Checks that the specified object reference is not {@code null}. This\n+     * method is designed primarily for doing parameter validation in methods\n+     * and constructors, as demonstrated below:\n+     * <blockquote><pre>\n+     * public Foo(Obj obj) {\n+     *     Checks.nullCheck(obj);\n+     *     this.obj = obj;\n+     * }\n+     * <\/pre><\/blockquote>\n+     *\n+     * @param obj the object reference to check for nullity\n+     * @throws NullPointerException if {@code obj} is {@code null}\n+     *\/\n+    @ForceInline\n+    public static void nullCheck(Object obj) {\n+        if (obj == null)\n+            throw new NullPointerException();\n+    }\n+\n+    \/**\n+     * Checks that the specified object references are not {@code null}. This\n+     * method is designed primarily for doing parameter validation in methods\n+     * and constructors, as demonstrated below:\n+     * <blockquote><pre>\n+     * public Foo(Obj1 obj1, Obj2 obj2) {\n+     *     Checks.nullCheck(obj1, obj2);\n+     *     this.obj1 = obj1;\n+     *     this.obj2 = obj2;\n+     * }\n+     * <\/pre><\/blockquote>\n+     *\n+     * @param obj1 an object reference to check for nullity\n+     * @param obj2 an object reference to check for nullity\n+     * @throws NullPointerException if any of {@code obj1} or {@code obj2} is {@code null}\n+     *\/\n+    @ForceInline\n+    public static void nullCheck(Object obj1, Object obj2) {\n+        if (obj1 == null || obj2 == null)\n+            throw new NullPointerException();\n+    }\n+\n+    \/**\n+     * Checks that the specified object references are not {@code null}. This\n+     * method is designed primarily for doing parameter validation in methods\n+     * and constructors, as demonstrated below:\n+     * <blockquote><pre>\n+     * public Foo(Obj1 obj1, Obj2 obj2, Obj3 obj3) {\n+     *     Checks.nullCheck(obj1, obj2, obj3);\n+     *     this.obj1 = obj1;\n+     *     this.obj2 = obj2;\n+     *     this.obj3 = obj3;\n+     * }\n+     * <\/pre><\/blockquote>\n+     *\n+     * @param obj1 an object reference to check for nullity\n+     * @param obj2 an object reference to check for nullity\n+     * @param obj3 an object reference to check for nullity\n+     * @throws NullPointerException if any of {@code obj1}, {@code obj2} or\n+     * {@code obj3} is {@code null}\n+     *\/\n+    @ForceInline\n+    public static void nullCheck(Object obj1, Object obj2, Object obj3) {\n+        if (obj1 == null || obj2 == null || obj3 == null)\n+            throw new NullPointerException();\n+    }\n+\n+    \/**\n+     * Checks that the specified object references are not {@code null}. This\n+     * method is designed primarily for doing parameter validation in methods\n+     * and constructors, as demonstrated below:\n+     * <blockquote><pre>\n+     * public Foo(Obj1 obj1, Obj2 obj2, Obj3 obj3, Obj4 obj4) {\n+     *     Checks.nullCheck(obj1, obj2, obj3, obj4);\n+     *     this.obj1 = obj1;\n+     *     this.obj2 = obj2;\n+     *     this.obj3 = obj3;\n+     *     this.obj4 = obj4;\n+     * }\n+     * <\/pre><\/blockquote>\n+     *\n+     * @param obj1 an object reference to check for nullity\n+     * @param obj2 an object reference to check for nullity\n+     * @param obj3 an object reference to check for nullity\n+     * @param obj4 an object reference to check for nullity\n+     * @throws NullPointerException if any of {@code obj1}, {@code obj2},\n+     * {@code obj3} or {@code obj4} is {@code null}\n+     *\/\n+    @ForceInline\n+    public static void nullCheck(Object obj1, Object obj2, Object obj3, Object obj4) {\n+        if (obj1 == null || obj2 == null || obj3 == null || obj4 == null)\n+            throw new NullPointerException();\n+    }\n+\n+    \/**\n+     * Checks that the specified object references are not {@code null}. This\n+     * method is designed primarily for doing parameter validation in methods\n+     * and constructors, as demonstrated below:\n+     * <blockquote><pre>\n+     * public Foo(Obj1 obj1, Obj2 obj2, Obj3 obj3, Obj4 obj4, Obj5 obj5) {\n+     *     Checks.nullCheck(obj1, obj2, obj3, obj4, obj5);\n+     *     this.obj1 = obj1;\n+     *     this.obj2 = obj2;\n+     *     this.obj3 = obj3;\n+     *     this.obj4 = obj4;\n+     *     this.obj5 = obj5;\n+     * }\n+     * <\/pre><\/blockquote>\n+     *\n+     * @param obj1 an object reference to check for nullity\n+     * @param obj2 an object reference to check for nullity\n+     * @param obj3 an object reference to check for nullity\n+     * @param obj4 an object reference to check for nullity\n+     * @param obj5 an object reference to check for nullity\n+     * @throws NullPointerException if any of {@code obj1}, {@code obj2},\n+     * {@code obj3}, {@code obj4} or {@code obj5} is {@code null}\n+     *\/\n+    @ForceInline\n+    public static void nullCheck(Object obj1, Object obj2, Object obj3, Object obj4, Object obj5) {\n+        if (obj1 == null || obj2 == null || obj3 == null || obj4 == null || obj5 == null)\n+            throw new NullPointerException();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Checks.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -55,1 +55,1 @@\n-            ClassTypeSig superclass = classTypeSig();\n+            ClassTypeSig superclass = unmarkedClassTypeSig();\n@@ -60,1 +60,1 @@\n-                superinterfaces.add(classTypeSig());\n+                superinterfaces.add(unmarkedClassTypeSig());\n@@ -84,1 +84,1 @@\n-                var t = referenceTypeSig();\n+                var t = unmarkedReferenceTypeSig();\n@@ -126,1 +126,1 @@\n-                            classBound = referenceTypeSig();\n+                            classBound = unmarkedReferenceTypeSig();\n@@ -135,1 +135,1 @@\n-                    interfaceBounds.add(referenceTypeSig());\n+                    interfaceBounds.add(unmarkedReferenceTypeSig());\n@@ -145,3 +145,4 @@\n-        switch (c) {\n-            case 'B','C','D','F','I','J','V','S','Z': return Signature.BaseTypeSig.of(c);\n-            default:\n+        return switch (c) {\n+            case 'B', 'C', 'D', 'F', 'I', 'J', 'V', 'S', 'Z' -> Signature.BaseTypeSig.of(c);\n+            case '!' -> unmarkedReferenceTypeSig().nullChecked();\n+            case 'L', 'T', '[' -> {\n@@ -149,2 +150,4 @@\n-                return referenceTypeSig();\n-        }\n+                yield unmarkedReferenceTypeSig();\n+            }\n+            default -> throw unexpectedError(\"a type signature\");\n+        };\n@@ -153,1 +156,1 @@\n-    private RefTypeSig referenceTypeSig() {\n+    private RefTypeSig unmarkedReferenceTypeSig() {\n@@ -155,1 +158,1 @@\n-            case 'L' -> classTypeSig();\n+            case 'L' -> unmarkedClassTypeSig();\n@@ -166,1 +169,1 @@\n-            default -> throw unexpectedError(\"a type signature\");\n+            default -> throw unexpectedError(\"an unmarked reference type signature\");\n@@ -174,2 +177,2 @@\n-            case '+': return TypeArg.extendsOf(referenceTypeSig());\n-            case '-': return TypeArg.superOf(referenceTypeSig());\n+            case '+': return TypeArg.extendsOf(unmarkedReferenceTypeSig());\n+            case '-': return TypeArg.superOf(unmarkedReferenceTypeSig());\n@@ -178,1 +181,1 @@\n-                return TypeArg.of(referenceTypeSig());\n+                return TypeArg.of(unmarkedReferenceTypeSig());\n@@ -182,1 +185,1 @@\n-    private ClassTypeSig classTypeSig() {\n+    private ClassTypeSig unmarkedClassTypeSig() {\n@@ -209,1 +212,1 @@\n-                t = new ClassTypeSigImpl(Optional.ofNullable(t), className, null2Empty(argTypes));\n+                t = new ClassTypeSigImpl(RefTypeSig.NullMarker.UNSPECIFIED, Optional.ofNullable(t), className, null2Empty(argTypes));\n@@ -310,0 +313,9 @@\n+    \/\/\/ Validates the signature to have no null marker.\n+    public static <T extends RefTypeSig> T validateUnmarked(T incoming) {\n+        \/\/ implicit null check\n+        if (incoming.nullMarker() != RefTypeSig.NullMarker.UNSPECIFIED) {\n+            throw new IllegalArgumentException(\"Must not have null marker: \" + incoming);\n+        }\n+        return incoming;\n+    }\n+\n@@ -333,1 +345,13 @@\n-    public static record TypeVarSigImpl(String identifier) implements Signature.TypeVarSig {\n+    public static String marker(RefTypeSig.NullMarker marker) {\n+        return switch (marker) {\n+            case UNSPECIFIED -> \"\";\n+            case NOT_NULL -> \"!\";\n+        };\n+    }\n+\n+    public static record TypeVarSigImpl(NullMarker nullMarker, String identifier) implements Signature.TypeVarSig {\n+\n+        @Override\n+        public TypeVarSig nullMarker(NullMarker marker) {\n+            return marker == nullMarker ? this : new TypeVarSigImpl(marker, identifier);\n+        }\n@@ -337,1 +361,1 @@\n-            return \"T\" + identifier + ';';\n+            return marker(nullMarker) + \"T\" + identifier + ';';\n@@ -341,1 +365,12 @@\n-    public static record ArrayTypeSigImpl(int arrayDepth, Signature elemType) implements Signature.ArrayTypeSig {\n+    public static record ArrayTypeSigImpl(NullMarker nullMarker, int arrayDepth, Signature elemType) implements Signature.ArrayTypeSig {\n+\n+        public ArrayTypeSigImpl {\n+            if (elemType instanceof RefTypeSig ref) {\n+                validateUnmarked(ref);\n+            }\n+        }\n+\n+        @Override\n+        public ArrayTypeSig nullMarker(NullMarker marker) {\n+            return marker == nullMarker ? this : new ArrayTypeSigImpl(marker, arrayDepth, elemType);\n+        }\n@@ -345,1 +380,1 @@\n-            return arrayDepth > 1 ? new ArrayTypeSigImpl(arrayDepth - 1, elemType) : elemType;\n+            return arrayDepth > 1 ? new ArrayTypeSigImpl(NullMarker.UNSPECIFIED, arrayDepth - 1, elemType) : elemType;\n@@ -350,1 +385,1 @@\n-            return \"[\".repeat(arrayDepth) + elemType.signatureString();\n+            return marker(nullMarker) + \"[\".repeat(arrayDepth) + elemType.signatureString();\n@@ -354,1 +389,1 @@\n-    public static record ClassTypeSigImpl(Optional<ClassTypeSig> outerType, String className, List<Signature.TypeArg> typeArgs)\n+    public static record ClassTypeSigImpl(NullMarker nullMarker, Optional<ClassTypeSig> outerType, String className, List<Signature.TypeArg> typeArgs)\n@@ -357,0 +392,5 @@\n+        @Override\n+        public ClassTypeSig nullMarker(NullMarker marker) {\n+            return marker == nullMarker ? this : new ClassTypeSigImpl(marker, outerType, className, typeArgs);\n+        }\n+\n@@ -383,1 +423,1 @@\n-            return prefix + className + suffix;\n+            return marker(nullMarker) + prefix + className + suffix;\n@@ -392,0 +432,3 @@\n+        public TypeArgImpl {\n+            validateUnmarked(boundType);\n+        }\n@@ -396,0 +439,8 @@\n+        public TypeParamImpl {\n+            if (classBound.isPresent()) {\n+                validateUnmarked(classBound.get());\n+            }\n+            for (var each : interfaceBounds) {\n+                validateUnmarked(each);\n+            }\n+        }\n@@ -417,0 +468,7 @@\n+        public ClassSignatureImpl {\n+            validateUnmarked(superclassSignature);\n+            for (var each : superinterfaceSignatures) {\n+                validateUnmarked(each);\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":83,"deletions":25,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+        @JEP(number=8303099, title=\"Null-Restricted and Nullable Types\", status = \"Preview\")\n+        NULL_RESTRICTION,\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.NullRestrictedType;\n@@ -108,0 +109,4 @@\n+    public NullRestrictedType makeNullRestrictedType(Type baseType) {\n+        return NullRestrictedTypeImpl.make(baseType);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/factory\/CoreReflectionFactory.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.NullRestrictedType;\n@@ -62,0 +63,8 @@\n+\n+    \/**\n+     * {@return an instance of the {@code NullRestrictedType} interface\n+     * that corresponds to a null restricted projection of a given base type}\n+     * @param baseType the base type\n+     *\/\n+    NullRestrictedType makeNullRestrictedType(Type baseType);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/factory\/GenericsFactory.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -453,0 +453,1 @@\n+     *     NullRestrictedType\n@@ -467,0 +468,3 @@\n+        case '!':\n+            return parseNullRestrictedTypeSignature();\n+\n@@ -505,0 +509,7 @@\n+    private NullRestrictedTypeSignature parseNullRestrictedTypeSignature() {\n+        advance();\n+        FieldTypeSignature restrictedType = parseFieldTypeSignature();\n+        return NullRestrictedTypeSignature.make(restrictedType);\n+    }\n+\n+\n@@ -589,0 +600,1 @@\n+            case '!':\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/parser\/SignatureParser.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.reflect.generics.reflectiveObjects;\n+\n+import java.lang.reflect.NullRestrictedType;\n+import java.lang.reflect.Type;\n+import java.util.Objects;\n+\n+\/** Implementing class for NullRestrictedType interface. *\/\n+\n+public class NullRestrictedTypeImpl implements NullRestrictedType {\n+    private final Type baseType;\n+\n+    private NullRestrictedTypeImpl(Type baseType) {\n+        this.baseType = baseType;\n+        checkNonRestricted(baseType);\n+    }\n+\n+    private static void checkNonRestricted(Type type) {\n+        if (type instanceof NullRestrictedType) {\n+            throw new IllegalArgumentException(\"Already a null-restricted type\");\n+        }\n+    }\n+\n+    \/**\n+     * Static factory. Given a type, creates a null-restricted type\n+     * @param baseType the type to which the null restriction is applied\n+     * @throws IllegalArgumentException if {@code baseType} is a null-restricted type\n+     *\/\n+    public static NullRestrictedTypeImpl make(Type baseType) {\n+        return new NullRestrictedTypeImpl(baseType);\n+    }\n+\n+    @Override\n+    public Type getBaseType() {\n+        return baseType;\n+    }\n+\n+    \/*\n+     * From the JavaDoc for java.lang.reflect.NullRestrictedType\n+     * \"Instances of classes that implement this interface must implement\n+     * an equals() method that equates any two null rrestricted type instances that\n+     * share the same base type.\"\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o)\n+            return true;\n+        return o instanceof NullRestrictedType that &&\n+                Objects.equals(baseType, that.getBaseType());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return\n+            Objects.hashCode(baseType) ^ 17;\n+    }\n+\n+    public String toString() {\n+        return baseType.getTypeName() + \"!\";\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/reflectiveObjects\/NullRestrictedTypeImpl.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.reflect.generics.tree;\n+\n+import sun.reflect.generics.visitor.TypeTreeVisitor;\n+\n+public class NullRestrictedTypeSignature implements TypeSignature {\n+    private final FieldTypeSignature baseType;\n+\n+    private NullRestrictedTypeSignature(FieldTypeSignature baseType) {\n+        this.baseType = baseType;\n+    }\n+\n+    public static NullRestrictedTypeSignature make(FieldTypeSignature ft) {\n+        return new NullRestrictedTypeSignature(ft);\n+    }\n+\n+    public FieldTypeSignature getBaseType(){return baseType;}\n+\n+    public void accept(TypeTreeVisitor<?> v){\n+        v.visitNullRestrictedTypeSignature(this);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/NullRestrictedTypeSignature.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -82,0 +82,7 @@\n+    @Override\n+    public void visitNullRestrictedTypeSignature(NullRestrictedTypeSignature nt) {\n+        nt.getBaseType().accept(this);\n+        Type baseType = resultType;\n+        resultType = getFactory().makeNullRestrictedType(baseType);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/visitor\/Reifier.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+    void visitNullRestrictedTypeSignature(NullRestrictedTypeSignature nt);\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/visitor\/TypeTreeVisitor.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -283,0 +283,5 @@\n+        \/**\n+         * Warn about operations on null-restricted and nullable types.\n+         *\/\n+        NULL(\"null\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+            case NULL_RESTRICTED_TYPES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -190,0 +191,1 @@\n+        res.append(nullMarker(t));\n@@ -193,0 +195,4 @@\n+    private String nullMarker(Type t) {\n+        return t.getNullMarker().typeSuffix();\n+    }\n+\n@@ -244,0 +250,1 @@\n+        buf.append(nullMarker(t));\n@@ -288,1 +295,1 @@\n-        return s;\n+        return s + nullMarker(t);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -301,0 +301,1 @@\n+        NULL_RESTRICTED_TYPES(JDK23, Fragments.FeatureNullRestrictedTypes, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -359,0 +359,8 @@\n+        \/*if (isValueClassConst()) {\n+            \/\/ previously we had vnew methods which had a return type, not `void`, and we were attaching metadata to it\n+            \/\/ like nullness for example. Type `void` doesn't accept metadata so if we need to state that the result of\n+            \/\/ invoking a value class constructor is never null, we will need another way.\n+            if (((MethodType)t).restype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                ((MethodType)t).restype = ((MethodType)t).restype.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n+            }\n+        }*\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+    public final Type nullRestrictedType;\n@@ -254,0 +255,3 @@\n+    public final Type checksType;\n+    public final Type arrayCreationType;\n+    public final MethodSymbol arrayCreationCopied;\n@@ -635,0 +639,1 @@\n+        nullRestrictedType = enterClass(\"jdk.internal.vm.annotation.NullRestricted\");\n@@ -660,0 +665,1 @@\n+        \/\/ for value objects\n@@ -661,0 +667,7 @@\n+        checksType = enterClass(\"java.lang.runtime.Checks\");\n+        arrayCreationType = enterClass(\"java.lang.runtime.ArrayCreation\");\n+        arrayCreationCopied = new MethodSymbol(PUBLIC | STATIC,\n+                names.copied,\n+                new MethodType(List.of(classType, intType, intType, objectType), objectType,\n+                        List.nil(), methodClass),\n+                arrayCreationType.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -540,0 +541,1 @@\n+        sb.append(getNullMarker().typeSuffix());\n@@ -748,0 +750,18 @@\n+    \/\/ support for null-marked types\n+\n+    public Type asNullMarked(NullMarker nullMarker) {\n+        if (nullMarker == getNullMarker()) return this;\n+        Type base = dropMetadata(TypeMetadata.NullMarker.class);\n+        return (nullMarker == NullMarker.UNSPECIFIED) ?\n+                base :\n+                base.addMetadata(new TypeMetadata.NullMarker(nullMarker));\n+    }\n+\n+    public NullMarker getNullMarker() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null ?\n+                nm.nullMarker() : NullMarker.UNSPECIFIED;\n+    }\n+\n+    \/\/ end of support for null-marked types\n+\n@@ -1109,0 +1129,2 @@\n+            buf.append(getNullMarker().typeSuffix());\n+\n@@ -1118,1 +1140,2 @@\n-                if (sym.name.isEmpty() && (sym.flags() & COMPOUND) != 0) {\n+                \/\/ invoking sym.flags() below can provoke symbol completion\n+                if (sym.name.isEmpty() && (sym.flags_field & COMPOUND) != 0) {\n@@ -1362,0 +1385,10 @@\n+\n+        public NullMarker getNullMarker() {\n+            for (Type component: getComponents()) {\n+                TypeMetadata.NullMarker nm = component.getMetadata(TypeMetadata.NullMarker.class);\n+                if (nm != null && !nm.equals(NullMarker.UNSPECIFIED)) {\n+                    return nm.nullMarker();\n+                }\n+            }\n+            return NullMarker.UNSPECIFIED;\n+        }\n@@ -1421,0 +1454,1 @@\n+                sb.append(t.getNullMarker().typeSuffix());\n@@ -2180,1 +2214,2 @@\n-                    if (types.isSameType(b, bound2)) return;\n+                    if (b.getNullMarker() == bound2.getNullMarker() &&\n+                            types.isSameType(b, bound2)) return;\n@@ -2347,1 +2382,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression;\n+import com.sun.tools.javac.util.Assert;\n@@ -79,0 +81,5 @@\n+\n+    record NullMarker(JCNullableTypeExpression.NullMarker nullMarker) implements TypeMetadata {\n+        @Override\n+        public String toString() { return \"NULL_MARKER [ \" + nullMarker.typeSuffix() + \" ]\"; }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeMetadata.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -106,0 +107,3 @@\n+    \/* are nullable and null-restricted types allowed? *\/\n+    private boolean allowNullRestrictedTypes;\n+\n@@ -131,0 +135,3 @@\n+        Preview preview = Preview.instance(context);\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -609,0 +616,8 @@\n+        boolean res = isConvertibleInternal(t, s, warn);\n+        if (res && t.hasTag(BOT) && isNonNullable(s)) {\n+            warn.warn(LintCategory.NULL);\n+        }\n+        return res;\n+    }\n+\n+    private boolean isConvertibleInternal(Type t, Type s, Warner warn) {\n@@ -1127,1 +1142,1 @@\n-                 case BOT:\n+                 case BOT: {\n@@ -1129,2 +1144,3 @@\n-                         s.hasTag(BOT) || s.hasTag(CLASS) ||\n-                         s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                             s.hasTag(BOT) || s.hasTag(CLASS) ||\n+                             s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                 }\n@@ -1755,2 +1771,7 @@\n-                case BOT:\n-                    return isSubtype(t, s);\n+                case BOT: {\n+                    boolean res = isSubtype(t, s);\n+                    if (res && isNonNullable(s)) {\n+                        warnStack.head.warn(LintCategory.NULL);\n+                    }\n+                    return res;\n+                }\n@@ -2440,1 +2461,2 @@\n-        return (t.isPrimitive()) || (syms.stringType.tsym == t.tsym);\n+        return (t.isPrimitive()) ||\n+                (syms.stringType.tsym == t.tsym && !isNonNullable(t));\n@@ -2466,1 +2488,1 @@\n-                            return s.dropMetadata(Annotations.class);\n+                            return s.dropMetadata(Annotations.class).dropMetadata(TypeMetadata.NullMarker.class);\n@@ -2499,1 +2521,2 @@\n-                            t.dropMetadata(Annotations.class).getMetadata());\n+                            t.dropMetadata(Annotations.class)\n+                             .dropMetadata(TypeMetadata.NullMarker.class).getMetadata());\n@@ -2511,1 +2534,7 @@\n-        };\n+\n+            @Override\n+            public Type visitArrayType(ArrayType t, Boolean aBoolean) {\n+                Type erased = super.visitArrayType(t, aBoolean);\n+                return combineMetadata(erased, t);\n+            }\n+    };\n@@ -3403,1 +3432,2 @@\n-                    return to.head.withTypeVar(t);\n+                    return to.head.withTypeVar(t)\n+                            .asNullMarked(t.getNullMarker());\n@@ -3409,0 +3439,6 @@\n+        @Override\n+        public Type visitArrayType(ArrayType t, Void unused) {\n+            return super.visitArrayType(t, unused)\n+                    .asNullMarked(t.getNullMarker());\n+        }\n+\n@@ -3412,1 +3448,2 @@\n-                return super.visitClassType(t, ignored);\n+                return super.visitClassType(t, ignored)\n+                        .asNullMarked(t.getNullMarker());\n@@ -5294,0 +5331,4 @@\n+            assembleSig(type, false);\n+        }\n+\n+        public void assembleSig(Type type, boolean includeNullMarkers) {\n@@ -5326,0 +5367,1 @@\n+                    appendNullMarkerIfNeeded(type, includeNullMarkers);\n@@ -5327,1 +5369,1 @@\n-                    assembleClassSig(type);\n+                    assembleClassSig(type, includeNullMarkers);\n@@ -5332,0 +5374,1 @@\n+                    appendNullMarkerIfNeeded(type, includeNullMarkers);\n@@ -5333,1 +5376,1 @@\n-                    assembleSig(at.elemtype);\n+                    assembleSig(at.elemtype, includeNullMarkers);\n@@ -5338,1 +5381,1 @@\n-                    assembleSig(mt.argtypes);\n+                    assembleSig(mt.argtypes, includeNullMarkers);\n@@ -5340,1 +5383,1 @@\n-                    assembleSig(mt.restype);\n+                    assembleSig(mt.restype, includeNullMarkers);\n@@ -5344,1 +5387,1 @@\n-                            assembleSig(l.head);\n+                            assembleSig(l.head, includeNullMarkers);\n@@ -5353,1 +5396,1 @@\n-                            assembleSig(ta.type);\n+                            assembleSig(ta.type, includeNullMarkers);\n@@ -5357,1 +5400,1 @@\n-                            assembleSig(ta.type);\n+                            assembleSig(ta.type, includeNullMarkers);\n@@ -5371,0 +5414,1 @@\n+                    appendNullMarkerIfNeeded(type, includeNullMarkers);\n@@ -5378,1 +5422,1 @@\n-                    assembleSig(ft.qtype);\n+                    assembleSig(ft.qtype, includeNullMarkers);\n@@ -5385,0 +5429,9 @@\n+        void appendNullMarkerIfNeeded(Type type, boolean includeNullMarkers) {\n+            if (includeNullMarkers) {\n+                NullMarker nullMarker = type.getNullMarker();\n+                if (nullMarker != NullMarker.UNSPECIFIED) {\n+                    append(nullMarker.typeSuffix().charAt(0));\n+                }\n+            }\n+        }\n+\n@@ -5396,0 +5449,4 @@\n+            assembleClassSig(type, false);\n+        }\n+\n+        public void assembleClassSig(Type type, boolean includeNullMarkers) {\n@@ -5406,1 +5463,1 @@\n-                        : outer);\n+                        : outer, includeNullMarkers);\n@@ -5417,1 +5474,1 @@\n-                assembleSig(ct.getTypeArguments());\n+                assembleSig(ct.getTypeArguments(), includeNullMarkers);\n@@ -5423,0 +5480,4 @@\n+            assembleParamsSig(typarams, false);\n+        }\n+\n+        public void assembleParamsSig(List<Type> typarams, boolean includeNullMarkers) {\n@@ -5433,1 +5494,1 @@\n-                    assembleSig(l.head);\n+                    assembleSig(l.head, includeNullMarkers);\n@@ -5440,0 +5501,4 @@\n+            assembleSig(types, false);\n+        }\n+\n+        public void assembleSig(List<Type> types, boolean includeNullMarkers) {\n@@ -5441,1 +5506,1 @@\n-                assembleSig(ts.head);\n+                assembleSig(ts.head, includeNullMarkers);\n@@ -5472,0 +5537,31 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"nullability methods\">\n+\n+    public boolean isNonNullable(Type type) {\n+        return type.getNullMarker() == NullMarker.NOT_NULL;\n+    }\n+\n+    public boolean isNullUnspecified(Type type) {\n+        return type.getNullMarker() == NullMarker.UNSPECIFIED;\n+    }\n+\n+    \/**\n+     * Do t and s have the same nullability?\n+     *\/\n+    public boolean hasSameNullability(Type t, Type s) {\n+        if (s == null || t == null || isNullUnspecified(t) || isNullUnspecified(s)) {\n+            return true;\n+        }\n+        return t.getNullMarker() == s.getNullMarker();\n+    }\n+\n+    \/**\n+     * Does t have narrower nullability than s?\n+     *\/\n+    public boolean hasNarrowerNullability(Type t, Type s) {\n+        if (s == null || t == null || isNullUnspecified(t) || isNullUnspecified(s)) {\n+            return false;\n+        }\n+        return t.getNullMarker().ordinal() < s.getNullMarker().ordinal();\n+    }\n+    \/\/ <\/editor-fold>\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":119,"deletions":23,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+import static com.sun.tools.javac.tree.JCTree.Tag.NULLRESTRICTEDCHK;\n@@ -763,1 +764,1 @@\n-            if (!oldNewClazz.args.isEmpty() && oldNewClazz.args.head.hasTag(NULLCHK)) {\n+            if (!oldNewClazz.args.isEmpty() && (oldNewClazz.args.head.hasTag(NULLCHK) || oldNewClazz.args.head.hasTag(NULLRESTRICTEDCHK))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Analyzer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -193,0 +194,2 @@\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -226,0 +229,4 @@\n+    \/** Are null-restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n+\n@@ -735,0 +742,4 @@\n+        if (allowNullRestrictedTypes && tree instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+            result = tree.type = result.addMetadata(new TypeMetadata.NullMarker(nullableTypeExpression.getNullMarker()));\n+        }\n@@ -3306,1 +3317,1 @@\n-            if (tree.constructor != null && tree.constructor.kind == MTH)\n+            if (tree.constructor != null && tree.constructor.kind == MTH) {\n@@ -3308,0 +3319,4 @@\n+                if (allowNullRestrictedTypes && owntype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                    owntype = owntype.addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL)); \/\/ constructor invocations are always null restricted\n+                }\n+            }\n@@ -3486,0 +3501,6 @@\n+        return makeNullCheck(arg, false);\n+    }\n+\n+    \/** Make an attributed null check tree.\n+     *\/\n+    public JCExpression makeNullCheck(JCExpression arg, boolean nullRestricted) {\n@@ -3493,1 +3514,1 @@\n-        JCTree.Tag optag = NULLCHK;\n+        JCTree.Tag optag = !nullRestricted ? NULLCHK : NULLRESTRICTEDCHK;\n@@ -3530,0 +3551,22 @@\n+\n+        if (types.isNonNullable(elemtype) && tree.elems == null) {\n+            \/\/ Null-restricted array requires an initializer unless either\n+            \/\/ (a) innermost dimension is missing, or (b) one of the provided dimensions\n+            \/\/ is the constant value 0.\n+            int dimsGiven = tree.dims.size();\n+            int arrayRank = types.dimensions(owntype);\n+            if (tree.dims.nonEmpty() && dimsGiven == arrayRank) {\n+                boolean hasZeroDims = tree.dims.stream()\n+                        .anyMatch(d -> d.type.constValue() instanceof Integer v && v == 0);\n+                if (!hasZeroDims) {\n+                    log.error(tree.pos(), Errors.RestrictedArrayMissingInit(elemtype));\n+                }\n+            }\n+        }\n+\n+        if (types.isNonNullable(elemtype) && tree.elems != null) {\n+            \/\/ if there's an initializer, and the element type is non-nullable,\n+            \/\/ mark the array creation as strict\n+            tree.strict = true;\n+        }\n+\n@@ -4486,0 +4529,3 @@\n+        if (types.isNonNullable(clazztype)) {\n+            tree.strict = true;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -172,0 +172,2 @@\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -209,0 +211,4 @@\n+    \/** Are null restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n+\n@@ -264,0 +270,10 @@\n+    \/** Warn about operation with bang types.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param warnKey    A warning key.\n+     *\/\n+    public void warnNullableTypes(DiagnosticPosition pos, LintWarning warnKey) {\n+        if (allowNullRestrictedTypes) {\n+            log.warning(pos, warnKey);\n+        }\n+    }\n+\n@@ -596,1 +612,2 @@\n-                && !is292targetTypeCast(tree)) {\n+                && !is292targetTypeCast(tree)\n+                && !types.hasNarrowerNullability(tree.clazz.type, tree.expr.type)) {\n@@ -1183,0 +1200,1 @@\n+                boolean isNonNullableFieldOfNonValueClass = !sym.owner.type.isValueClass() && types.isNonNullable(sym.type);\n@@ -1186,0 +1204,3 @@\n+                } else if (isNonNullableFieldOfNonValueClass) {\n+                    implicit |= STRICT;\n+                    mask = ValueFieldFlags;\n@@ -1313,0 +1334,4 @@\n+                 checkDisjoint(pos, flags,\n+                        INTERFACE,\n+                        VALUE_CLASS)\n+                 &&\n@@ -4429,0 +4454,3 @@\n+                case NULL:\n+                    Check.this.warnNullableTypes(pos(), LintWarnings.SuspiciousNullnessConversion(expected, found));\n+                    break;\n@@ -4918,3 +4946,8 @@\n-            if (currentPattern instanceof JCBindingPattern ||\n-                currentPattern instanceof JCAnyPattern) {\n-                return existingPattern instanceof JCBindingPattern ||\n+            if (currentPattern instanceof JCBindingPattern currentBinding) {\n+                return (existingPattern instanceof JCBindingPattern existingBinding &&\n+                        (types.isNullUnspecified(existingBinding.type) ||\n+                         types.isNonNullable(currentBinding.type))) ||\n+                       existingPattern instanceof JCAnyPattern;\n+            } else if (currentPattern instanceof JCAnyPattern) {\n+                return (existingPattern instanceof JCBindingPattern existingBinding &&\n+                        types.isNullUnspecified(existingBinding.type)) ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -65,3 +65,4 @@\n-        UNLAMBDA(10),\n-        STRICT_FIELDS_PROXIES(11),\n-        GENERATE(12);\n+        NULL_CHECKS_WRITER(10),\n+        UNLAMBDA(11),\n+        STRICT_FIELDS_PROXIES(12),\n+        GENERATE(13);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1726,0 +1726,1 @@\n+        private JCMethodDecl currentMethod;\n@@ -1742,1 +1743,2 @@\n-                isFinalOrStrictUninitializedField(sym)));\n+                isFinalOrStrictUninitializedField(sym)) ||\n+                isUninitializedNonNullableField(sym));\n@@ -1752,0 +1754,7 @@\n+        boolean isUninitializedNonNullableField(VarSymbol sym) {\n+            return sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                            classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                            types.isNonNullable(sym.type));\n+        }\n+\n@@ -1842,1 +1851,3 @@\n-            checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));\n+            checkInit(pos, sym, types.isNonNullable(sym.type) ?\n+                    Errors.NonNullableShouldBeInitialized :\n+                    Errors.VarMightNotHaveBeenInitialized(sym));\n@@ -2040,0 +2051,1 @@\n+            JCMethodDecl currentMethodPrev = currentMethod;\n@@ -2044,1 +2056,1 @@\n-\n+                currentMethod = tree;\n@@ -2115,0 +2127,1 @@\n+                currentMethod = currentMethodPrev;\n@@ -2597,1 +2610,2 @@\n-\n+                boolean isSynthesized = (currentMethod.sym.flags() &\n+                        GENERATEDCONSTR) != 0;\n@@ -2605,2 +2619,10 @@\n-                        if (allowValueClasses && (var.owner == classDef.sym && !var.isStatic() && (var.isStrict() || ((var.flags_field & RECORD) != 0)) && !isCompactOrGeneratedRecordConstructor)) {\n-                            checkInit(TreeInfo.diagEndPos(tree), var, Errors.StrictFieldNotHaveBeenInitializedBeforeSuper(var));\n+                        boolean isInstanceRecordField = var.enclClass().isRecord() &&\n+                                (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n+                                var.owner.kind == TYP;\n+                        if (allowValueClasses && (var.owner == classDef.sym && !var.isStatic() && var.isStrict() && !isInstanceRecordField)) {\n+                            if (isSynthesized) {\n+                                checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),\n+                                        var, Errors.NonNullableShouldBeInitialized);\n+                            } else {\n+                                checkInit(TreeInfo.diagEndPos(tree), var, Errors.StrictFieldNotHaveBeenInitializedBeforeSuper(var));\n+                            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1465,1 +1465,4 @@\n-                return filterBounds(uv, inferenceContext).head;\n+                Infer infer = inferenceContext.infer;\n+                List<Type> eqbounds = filterBounds(uv, inferenceContext);\n+                return eqbounds.tail.tail == null  ?\n+                        eqbounds.head : infer.types.lub(eqbounds);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4294,0 +4294,1 @@\n+        \/\/ nullness info could be lost in the translation process, let's keep the original element type\n@@ -4295,1 +4296,1 @@\n-        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail)\n+        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail) {\n@@ -4297,0 +4298,1 @@\n+        }\n@@ -4298,1 +4300,21 @@\n-        result = tree;\n+        if (tree.strict) {\n+            Assert.check(types.dimensions(tree.type) == 1, \"Unexpected multi-dimensional null-restricted array\");\n+            \/\/ create a null restricted array, this will generate code as follows:\n+            \/\/ let $tmp = <old array creation> in ArrayCreation.copied(<array type>, 0, <array size>, $tmp);\n+            VarSymbol tmpArrayVar = new VarSymbol(0, names.fromString(\"$arr\"), syms.objectType, currentMethodSym);\n+            JCVariableDecl tmpArrayVarDecl = make.VarDef(tmpArrayVar, tree);\n+            JCIdent tmpArrayVarRef = make.Ident(tmpArrayVar);\n+            JCFieldAccess qualifier = make.Select(make.Type(syms.arrayCreationType), names.copied);\n+            qualifier.sym = syms.arrayCreationCopied;\n+            qualifier.type = syms.arrayCreationCopied.type;\n+            JCMethodInvocation copiedCall = make.Apply(List.nil(), qualifier,\n+                    List.of(\n+                            classOfType(types.elemtype(tree.type), tree),\n+                            makeLit(syms.intType, 0x200), \/\/ flag -- NULL_CHECKED for now\n+                            makeLit(syms.intType, tree.elems.length()),\n+                            tmpArrayVarRef)).setType(syms.objectType);\n+            JCExpression cast = make.TypeCast(tree.type, copiedCall);\n+            result = make.LetExpr(tmpArrayVarDecl, cast).setType(cast.type);\n+        } else {\n+            result = tree;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.tools.javac.code.Attribute;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Preview;\n+import com.sun.tools.javac.code.Source;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.tree.*;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Options;\n+\n+import java.util.Locale;\n+\n+import static com.sun.tools.javac.code.Kinds.Kind.TYP;\n+import static com.sun.tools.javac.code.Kinds.Kind.VAR;\n+import static com.sun.tools.javac.code.TypeTag.VOID;\n+\n+\/** This pass generates null checks for the compiler to check for assertions on\n+ *  null restricted types.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class NullChecksWriter extends TreeTranslator {\n+\n+    protected static final Context.Key<NullChecksWriter> nullChecksWriterKey = new Context.Key<>();\n+\n+    public static NullChecksWriter instance(Context context) {\n+        NullChecksWriter instance = context.get(nullChecksWriterKey);\n+        if (instance == null)\n+            instance = new NullChecksWriter(context);\n+        return instance;\n+    }\n+\n+    private final Types types;\n+    private TreeMaker make;\n+    private final Attr attr;\n+    private final Symtab syms;\n+    \/** are null restricted types allowed?\n+      *\/\n+    private final boolean allowNullRestrictedTypes;\n+    private final UseSiteNullChecks useSiteNullChecks;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected NullChecksWriter(Context context) {\n+        context.put(nullChecksWriterKey, this);\n+        make = TreeMaker.instance(context);\n+        types = Types.instance(context);\n+        attr = Attr.instance(context);\n+        syms = Symtab.instance(context);\n+        Preview preview = Preview.instance(context);\n+        Source source = Source.instance(context);\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n+        useSiteNullChecks = UseSiteNullChecks.of(Options.instance(context).get(\"useSiteNullChecks\"));\n+    }\n+\n+    private enum UseSiteNullChecks {\n+        NONE(false, false),\n+        METHODS(true, false),\n+        METHODS_AND_FIELDS(true, true, \"methods+fields\");\n+\n+        final boolean generateChecksForMethods;\n+        final boolean generateChecksForFields;\n+        final String compilerOpt;\n+\n+        UseSiteNullChecks(boolean generateChecksForMethods, boolean generateChecksForFields) {\n+            this.generateChecksForMethods = generateChecksForMethods;\n+            this.generateChecksForFields = generateChecksForFields;\n+            this.compilerOpt = name().toLowerCase(Locale.ROOT);\n+        }\n+\n+        UseSiteNullChecks(boolean generateChecksForMethods, boolean generateChecksForFields, String compilerOpt) {\n+            this.generateChecksForMethods = generateChecksForMethods;\n+            this.generateChecksForFields = generateChecksForFields;\n+            this.compilerOpt = compilerOpt;\n+        }\n+\n+        static UseSiteNullChecks of(String compilerOpt) {\n+            if (compilerOpt == null) {\n+                return METHODS_AND_FIELDS;\n+            }\n+            for (UseSiteNullChecks useSiteNullChecks: UseSiteNullChecks.values()) {\n+                if (useSiteNullChecks.compilerOpt.equals(compilerOpt)) {\n+                    return useSiteNullChecks;\n+                }\n+            }\n+            Assert.error(\"Unknown useSiteNullChecks: \" + compilerOpt);\n+            throw new IllegalStateException(\"Unknown useSiteNullChecks: \" + compilerOpt);\n+        }\n+    }\n+\n+    Env<AttrContext> env;\n+    ClassSymbol currentClass;\n+\n+    public JCTree translateTopLevelClass(Env<AttrContext> env, JCTree cdef, TreeMaker make) {\n+        if (allowNullRestrictedTypes) {\n+            try {\n+                this.make = make;\n+                this.env = env;\n+                this.currentClass = (ClassSymbol) TreeInfo.symbolFor(cdef);\n+                return translate(cdef);\n+            } finally {\n+                \/\/ note that recursive invocations of this method fail hard\n+                this.make = null;\n+                this.env = null;\n+                this.currentClass = null;\n+            }\n+        }\n+        return cdef;\n+    }\n+\n+    \/* ************************************************************************\n+     * Visitor methods\n+     *************************************************************************\/\n+\n+    @Override\n+    public void visitVarDef(JCVariableDecl tree) {\n+        super.visitVarDef(tree);\n+        if (tree.init != null) {\n+            if (types.isNonNullable(tree.sym.type)) {\n+                tree.init = attr.makeNullCheck(tree.init, true);\n+            }\n+        }\n+        \/\/ temporary hack, this is only to test null restriction in the VM for fields of a value class type\n+        if (tree.sym.owner.kind == TYP &&\n+                tree.sym.type.isValueClass() &&\n+                types.isNonNullable(tree.sym.type)) {\n+            List<Attribute.Compound> rawAttrs = tree.sym.getRawAttributes();\n+            if (rawAttrs.isEmpty() || !rawAttrs.stream().anyMatch(ac -> ac.type.tsym == syms.nullRestrictedType.tsym)) {\n+                Attribute.Compound ac = new Attribute.Compound(syms.nullRestrictedType, List.nil());\n+                tree.sym.appendAttributes(List.of(ac));\n+            }\n+        }\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitAssign(JCAssign tree) {\n+        \/\/ could be null for indexed array accesses, we should deal with those later\n+        super.visitAssign(tree);\n+        Symbol lhsSym = TreeInfo.symbolFor(tree.lhs);\n+        if (lhsSym != null &&\n+                types.isNonNullable(lhsSym.type)) {\n+            tree.rhs = attr.makeNullCheck(tree.rhs, true);\n+        }\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitIdent(JCIdent tree) {\n+        super.visitIdent(tree);\n+        identSelectVisitHelper(tree);\n+    }\n+\n+    @Override\n+    public void visitSelect(JCFieldAccess tree) {\n+        super.visitSelect(tree);\n+        identSelectVisitHelper(tree);\n+    }\n+\n+    \/\/ where\n+        private void identSelectVisitHelper(JCTree tree) {\n+            Symbol sym = TreeInfo.symbolFor(tree);\n+            if (useSiteNullChecks.generateChecksForFields &&\n+                    sym.owner.kind == TYP &&\n+                    sym.kind == VAR &&\n+                    types.isNonNullable(sym.type) &&\n+                    sym.owner != currentClass) {\n+                \/* we are accessing a non-nullable field declared in another\n+                 * class\n+                 *\/\n+                result = attr.makeNullCheck((JCExpression) tree, true);\n+            }\n+        }\n+\n+    public void visitTypeCast(JCTypeCast tree) {\n+        super.visitTypeCast(tree);\n+        if (tree.strict) {\n+            tree.expr = attr.makeNullCheck(tree.expr, true);\n+        }\n+        result = tree;\n+    }\n+\n+    Type returnType = null;\n+\n+    @Override\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        Type prevRetType = returnType;\n+        try {\n+            returnType = tree.sym.type.getReturnType();\n+            ListBuffer<JCStatement> paramNullChecks = new ListBuffer<>();\n+            for (JCVariableDecl param : tree.params) {\n+                if (types.isNonNullable(param.sym.type)) {\n+                    paramNullChecks.add(make.at(tree.body.pos())\n+                            .Exec(attr.makeNullCheck(make.at(tree.body.pos()).Ident(param), true)));\n+                }\n+            }\n+            if (!paramNullChecks.isEmpty()) {\n+                tree.body.stats = tree.body.stats.prependList(paramNullChecks.toList());\n+            }\n+            super.visitMethodDef(tree);\n+            result = tree;\n+        } finally {\n+            returnType = prevRetType;\n+        }\n+    }\n+\n+    @Override\n+    public void visitReturn(JCReturn tree) {\n+        super.visitReturn(tree);\n+        if (tree.expr != null && returnType != null && !returnType.hasTag(VOID)) {\n+            if (types.isNonNullable(returnType)) {\n+                tree.expr = attr.makeNullCheck(tree.expr, true);\n+            }\n+        }\n+        result = tree;\n+    }\n+\n+    @Override\n+    public void visitApply(JCMethodInvocation tree) {\n+        Symbol.MethodSymbol msym = (Symbol.MethodSymbol) TreeInfo.symbolFor(tree.meth);\n+        if (useSiteNullChecks.generateChecksForMethods) {\n+            tree.args = newArgs(msym, tree.args);\n+        }\n+        super.visitApply(tree);\n+        result = tree;\n+        if (useSiteNullChecks.generateChecksForMethods) {\n+            if (types.isNonNullable(msym.type.asMethodType().restype)) {\n+                result = attr.makeNullCheck(tree, true);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void visitNewClass(JCNewClass tree) {\n+        if (useSiteNullChecks.generateChecksForMethods) {\n+            tree.args = newArgs((Symbol.MethodSymbol) tree.constructor, tree.args);\n+        }\n+        super.visitNewClass(tree);\n+        result = tree;\n+    }\n+\n+    private List<JCExpression> newArgs(Symbol.MethodSymbol msym, List<JCExpression> actualArgs) {\n+        \/\/ skip signature polymorphic methods they won't have null restricted arguments\n+        if ((msym.flags_field & Flags.SIGNATURE_POLYMORPHIC) != 0) {\n+            return actualArgs;\n+        }\n+        ListBuffer<JCExpression> newArgs = new ListBuffer<>();\n+        List<Type> declaredArgTypes = msym.type.asMethodType().argtypes;\n+        \/* there can be prefix arguments added by Lower, for example captured variables, etc\n+         * nothing to check for them\n+         *\/\n+        int declaredArgSize = declaredArgTypes.size();\n+        int prefixArgsLength = msym.externalType(types).getParameterTypes().size() - declaredArgSize;\n+        List<JCExpression> actualArgsTmp = actualArgs;\n+        while (prefixArgsLength-- > 0) {\n+            newArgs.add(actualArgsTmp.head);\n+            actualArgsTmp = actualArgsTmp.tail;\n+        }\n+        int noOfArgsToCheck = msym.isVarArgs() ? declaredArgSize - 1 : declaredArgSize;\n+        while (noOfArgsToCheck-- > 0) {\n+            Type formalArgType = declaredArgTypes.head;\n+            if (types.isNonNullable(formalArgType)) {\n+                newArgs.add(attr.makeNullCheck(actualArgsTmp.head, true));\n+            } else {\n+                newArgs.add(actualArgsTmp.head);\n+            }\n+            actualArgsTmp = actualArgsTmp.tail;\n+        }\n+        \/* now add the last vararg argument if applicable, no checks are needed here as varargs can't be\n+         * null restricted. Also note that at this point the vararg arguments have already been translated\n+         * by Lower into an array. This is not true for signature polymorphic methods, but we have already\n+         * filtered them out\n+         *\/\n+        if (msym.isVarArgs()) {\n+            newArgs.add(actualArgsTmp.head);\n+        }\n+        return newArgs.toList();\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/NullChecksWriter.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -687,1 +687,4 @@\n-                        .addUnaryOperator(OBJECT, OBJECT, nullchk));\n+                        .addUnaryOperator(OBJECT, OBJECT, nullchk),\n+                new UnaryReferenceOperator(Tag.NULLRESTRICTEDCHK)\n+                        .addUnaryOperator(OBJECT, OBJECT, nullchk)\n+        );\n@@ -840,0 +843,1 @@\n+        setOperatorName(Tag.NULLRESTRICTEDCHK, \"<*nullrestrictedchk*>\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Operators.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -418,0 +418,1 @@\n+            case NULLRESTRICTEDCHK:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -361,1 +361,2 @@\n-                allowNull = types.isSubtype(componentType,\n+                allowNull = !types.isNonNullable(nestedBinding.type) &&\n+                        types.isSubtype(componentType,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -39,0 +38,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -52,2 +52,0 @@\n-import javax.lang.model.type.TypeKind;\n-\n@@ -935,1 +933,3 @@\n-        if (meth.name == names.init && meth.owner == syms.enumSym)\n+        if (meth.name == names.init && meth.owner == syms.enumSym) {\n+            \/\/ this is special case code only for j.l.Enum constructor and will effectively\n+            \/\/ set the argtypes to an empty list making the invocation to translateArgs a no-op\n@@ -937,0 +937,1 @@\n+        }\n@@ -1015,1 +1016,1 @@\n-        tree.arg = translate(tree.arg, (tree.getTag() == Tag.NULLCHK)\n+        tree.arg = translate(tree.arg, (tree.getTag() == Tag.NULLCHK || tree.getTag() == Tag.NULLRESTRICTEDCHK)\n@@ -1037,0 +1038,1 @@\n+        \/\/ the information in tree.clazz.type is lost, so probably we need to do this one here\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -43,0 +44,1 @@\n+import com.sun.tools.javac.jvm.Target;\n@@ -59,0 +61,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.BiFunction;\n@@ -70,0 +71,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -517,0 +519,7 @@\n+        case '!':\n+            sigp++;\n+            if (signature[sigp] != 'L' && signature[sigp] != '[' && signature[sigp] != 'T') {\n+                \/\/ after a bang, we expect either a ref type, an array or a type var\n+                throw badClassFile(\"bad.class.signature\", quoteBadSignature());\n+            }\n+            return sigToType().asNullMarked(NullMarker.NOT_NULL);\n@@ -592,0 +601,1 @@\n+                Type result;\n@@ -595,1 +605,3 @@\n-                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata());\n+                        result = new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata());\n+                    } else {\n+                        result = new ClassType(outer, List.nil(), t, List.nil());\n@@ -597,1 +609,1 @@\n-                    return new ClassType(outer, List.nil(), t, List.nil());\n+                    return result;\n@@ -602,1 +614,0 @@\n-\n@@ -672,0 +683,5 @@\n+                char currentCh = (char)signature[sigp];\n+                if (currentCh == '!' ) {\n+                    outer = outer.asNullMarked(NullMarker.NOT_NULL);\n+                    sigp++;\n+                }\n@@ -693,1 +709,1 @@\n-                    throw new AssertionError(signature[sigp-1]);\n+                    throw new AssertionError((char)signature[sigp-1]);\n@@ -1351,0 +1367,15 @@\n+            new AttributeReader(names.NullRestricted, V66, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind != VAR) {\n+                        throw badClassFile(\"attribute.only.applicable.to.fields\", names.NullRestricted);\n+                    }\n+                    if (sym.type.isPrimitive() || sym.type.hasTag(TypeTag.ARRAY)) {\n+                        throw badClassFile(\"attribute.not.applicable.to.field.type\", names.NullRestricted, sym.type);\n+                    }\n+                    \/\/ there is no point on setting the nullness or not has it will be set while parsing the signature\n+                }\n+            },\n@@ -2672,0 +2703,7 @@\n+        if (names.isInit(name) && ((flags & STATIC) != 0)) {\n+            flags &= ~STATIC;\n+            type = new MethodType(type.getParameterTypes(),\n+                    syms.voidType,\n+                    type.getThrownTypes(),\n+                    syms.methodClass);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -84,0 +85,4 @@\n+    \/** Switch: are null-restricted types allowed\n+     *\/\n+    private boolean allowNullRestrictedTypes;\n+\n@@ -144,0 +149,2 @@\n+    private final Symtab syms;\n+\n@@ -179,0 +186,1 @@\n+        syms = Symtab.instance(context);\n@@ -194,0 +202,2 @@\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -368,0 +378,1 @@\n+             nullMarkersScanner.visit(sym.type, null) ||\n@@ -378,0 +389,3 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeNullRestrictedIfNeeded(sym);\n+        }\n@@ -381,0 +395,47 @@\n+    NullMarkersScanner nullMarkersScanner = new NullMarkersScanner();\n+    \/* we don't need to scan generic \/ parameterized types as we will be generating a signature for them anyways\n+     *\/\n+    class NullMarkersScanner extends Types.SimpleVisitor<Boolean, Void> {\n+\n+        @Override\n+        public Boolean visitType(Type t, Void ignore) {\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitClassType(ClassType t, Void ignore) {\n+            if (!t.isParameterized()) {\n+                if (t.getNullMarker() != NullMarker.UNSPECIFIED) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitArrayType(ArrayType t, Void ignore) {\n+            if (t.getNullMarker() != NullMarker.UNSPECIFIED) {\n+                return true;\n+            }\n+            return visit(t.elemtype, ignore);\n+        }\n+\n+        @Override\n+        public Boolean visitMethodType(MethodType t, Void ignore) {\n+            for (Type arg : t.argtypes) {\n+                if (visit(arg, ignore)) {\n+                    return true;\n+                }\n+            }\n+            for (Type param : t.allparams()) {\n+                if (visit(param, ignore)) {\n+                    return true;\n+                }\n+            }\n+            if (visit(t.restype, ignore)) {\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n@@ -962,0 +1023,14 @@\n+    \/** Write \"NullRestricted\" attribute.\n+     *\/\n+    int writeNullRestrictedIfNeeded(Symbol sym) {\n+        if (allowNullRestrictedTypes && sym.kind == VAR && types.isNonNullable(sym.type) && !sym.type.hasTag(ARRAY)) {\n+            int alenIdx = writeAttr(names.NullRestricted);\n+            endAttr(alenIdx);\n+            if (preview.isPreview(Source.Feature.VALUE_CLASSES)) {\n+                preview.markUsesPreview(null);\n+            }\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n@@ -1316,0 +1391,4 @@\n+                if (debugstackmap) System.out.print(\"object(\" + types.erasure(t).tsym + \")\");\n+                databuf.appendByte(7);\n+                databuf.appendChar(poolWriter.putClass(types.erasure(t)));\n+                break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    private static final Object[] NO_STATIC_ARGS = new Object[0];\n@@ -437,0 +438,2 @@\n+        \/\/ initializers for non-nullable fields of non-value classes\n+        ListBuffer<JCStatement> initCodeNonNullableFields = new ListBuffer<>();\n@@ -474,1 +477,5 @@\n-                        initCode.append(init);\n+                        if (!vdef.sym.owner.isValueClass() && types.isNonNullable(vdef.sym.type)) {\n+                            initCodeNonNullableFields.append(init);\n+                        } else {\n+                            initCode.append(init);\n+                        }\n@@ -499,1 +506,1 @@\n-        if (initCode.length() != 0 || initBlocks.length() != 0) {\n+        if (initCode.length() != 0 || initCodeNonNullableFields.length() != 0 || initBlocks.length() != 0) {\n@@ -503,1 +510,1 @@\n-                normalizeMethod((JCMethodDecl)t, initCode.toList(), initBlocks.toList(), initTAlist);\n+                normalizeMethod((JCMethodDecl)t, initCode.toList(), initCodeNonNullableFields.toList(), initBlocks.toList(), initTAlist);\n@@ -566,1 +573,1 @@\n-    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<JCStatement> initBlocks,  List<TypeCompound> initTAs) {\n+    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<JCStatement> initCodeNonNullableFields, List<JCStatement> initBlocks, List<TypeCompound> initTAs) {\n@@ -589,0 +596,3 @@\n+            } else if (!initCodeNonNullableFields.isEmpty()) {\n+                rewriteInitializersIfNeeded(md, initCodeNonNullableFields);\n+                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCodeNonNullableFields.append(supercall).appendList(initCode)));\n@@ -2321,0 +2331,1 @@\n+            case NULLRESTRICTEDCHK:\n@@ -2323,1 +2334,1 @@\n-                genNullCheck(tree);\n+                genNullCheck(tree, tree.getTag() == NULLRESTRICTEDCHK);\n@@ -2333,0 +2344,4 @@\n+        genNullCheck(tree, false);\n+    }\n+\n+    private void genNullCheck(JCTree tree, boolean nullRestricted) {\n@@ -2334,3 +2349,8 @@\n-        callMethod(tree.pos(), syms.objectsType, names.requireNonNull,\n-                   List.of(syms.objectType), true);\n-        code.emitop0(pop);\n+        if (!nullRestricted || !target.hasRuntimeChecks()) {\n+            callMethod(tree.pos(), syms.objectsType, names.requireNonNull,\n+                    List.of(syms.objectType), true);\n+            code.emitop0(pop);\n+        } else {\n+            callMethod(tree.pos(), syms.checksType, names.nullCheck,\n+                    List.of(syms.objectType), true);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-            return putName(typeSig(s.type));\n+            return putName(typeSig(s.type, true));\n@@ -305,0 +305,9 @@\n+            assembleSig(type, false);\n+        }\n+\n+        \/**\n+         * Assemble signature of given type in string buffer.\n+         * Check for uninitialized types before calling the general case.\n+         *\/\n+        @Override\n+        public void assembleSig(Type type, boolean includeNullMarkers) {\n@@ -310,1 +319,1 @@\n-                    assembleSig(types.erasure(((UninitializedType)type).qtype));\n+                    assembleSig(types.erasure(((UninitializedType)type).qtype), includeNullMarkers);\n@@ -313,1 +322,1 @@\n-                    super.assembleSig(type);\n+                    super.assembleSig(type, includeNullMarkers);\n@@ -510,0 +519,4 @@\n+        return typeSig(type, false);\n+    }\n+\n+    private Name typeSig(Type type, boolean includeNullMarkers) {\n@@ -511,1 +524,1 @@\n-        signatureGen.assembleSig(type);\n+        signatureGen.assembleSig(type, includeNullMarkers);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -267,0 +267,6 @@\n+\n+    \/** Does the target JDK defines class j.l.runtime.Checks?\n+     *\/\n+    public boolean hasRuntimeChecks() {\n+        return compareTo(JDK1_26) >= 0;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1708,0 +1708,7 @@\n+            if (shouldStop(CompileState.NULL_CHECKS_WRITER))\n+                return;\n+            for (JCTree def : cdefs) {\n+                NullChecksWriter.instance(context).translateTopLevelClass(env, def, localMake);\n+            }\n+            compileStates.put(env, CompileState.NULL_CHECKS_WRITER);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import com.sun.tools.javac.code.FlagsEnum;\n@@ -44,1 +43,0 @@\n-import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;\n@@ -51,0 +49,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -57,1 +56,0 @@\n-import static com.sun.tools.javac.code.Flags.asFlagSet;\n@@ -66,1 +64,1 @@\n-import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;\n+\n@@ -207,0 +205,2 @@\n+        this.allowNullRestrictedTypes = (!preview.isPreview(Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -233,0 +233,2 @@\n+        this.allowNullRestrictedTypes = (!preview.isPreview(Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -279,0 +281,4 @@\n+    \/** Switch: are null-restricted types allowed?\n+     *\/\n+    boolean allowNullRestrictedTypes;\n+\n@@ -289,0 +295,1 @@\n+     *     mode |= ALLOW_BANGS: bang types are allowed\n@@ -296,0 +303,1 @@\n+    protected static final int ALLOW_BANGS   = 1 << 6;\n@@ -318,1 +326,5 @@\n-        setMode((mode & NOLAMBDA) | TYPE);\n+        setMode((mode & ALLOW_BANGS) | (mode & NOLAMBDA) | TYPE);\n+    }\n+\n+    protected void selectTypeModeWithBangs() {\n+        setMode(ALLOW_BANGS | (mode & NOLAMBDA) | TYPE);\n@@ -826,0 +838,10 @@\n+    public JCExpression qualident(boolean allowAnnos, int newmode) {\n+        int prevmode = mode;\n+        setMode(newmode);\n+        try {\n+            return qualident(allowAnnos);\n+        } finally {\n+            setMode(prevmode);\n+        }\n+    }\n+\n@@ -831,0 +853,6 @@\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            if (checkNullRestrictionLocation(BAD_BANG_LOCATION_QUALIDENT)) {\n+                setNullMarker(t);\n+            }\n+            nextToken();\n+        }\n@@ -842,0 +870,6 @@\n+            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                if (checkNullRestrictionLocation(BAD_BANG_LOCATION_QUALIDENT)) {\n+                    setNullMarker(t);\n+                }\n+                nextToken();\n+            }\n@@ -1008,1 +1042,1 @@\n-                e = unannotatedType(allowVar, TYPE | NOLAMBDA);\n+                e = unannotatedType(allowVar, TYPE | NOLAMBDA | ALLOW_BANGS);\n@@ -1075,1 +1109,5 @@\n-        return parseType(false);\n+        return parseType(TYPE);\n+    }\n+\n+    public JCExpression parseType(int mode) {\n+        return parseType(false, mode);\n@@ -1079,0 +1117,4 @@\n+        return parseType(allowVar, TYPE);\n+    }\n+\n+    public JCExpression parseType(boolean allowVar, int mode) {\n@@ -1080,1 +1122,1 @@\n-        return parseType(allowVar, annotations);\n+        return parseType(allowVar, mode, annotations);\n@@ -1084,1 +1126,5 @@\n-        JCExpression result = unannotatedType(allowVar);\n+        return parseType(allowVar, TYPE, annotations);\n+    }\n+\n+    public JCExpression parseType(boolean allowVar, int mode, List<JCAnnotation> annotations) {\n+        JCExpression result = unannotatedType(allowVar, mode);\n@@ -1099,1 +1145,1 @@\n-            targets = targets.prepend(parseType());\n+            targets = targets.prepend(parseType(TYPE | ALLOW_BANGS));\n@@ -1107,4 +1153,0 @@\n-    public JCExpression unannotatedType(boolean allowVar) {\n-        return unannotatedType(allowVar, TYPE);\n-    }\n-\n@@ -1271,1 +1313,1 @@\n-                    JCExpression type = unannotatedType(false);\n+                    JCExpression type = unannotatedType(false, TYPE | ALLOW_BANGS);\n@@ -1483,1 +1525,1 @@\n-                       t = parseIntersectionType(pos, parseType());\n+                       t = parseIntersectionType(pos, parseType(TYPE | ALLOW_BANGS));\n@@ -1596,0 +1638,7 @@\n+                if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                    if (checkNullRestrictionLocation()) {\n+                        selectTypeMode();\n+                        setNullMarker(t);\n+                    }\n+                    nextToken();\n+                }\n@@ -1608,0 +1657,1 @@\n+                        boolean pendingNullRestriction = false;\n@@ -1610,2 +1660,16 @@\n-                            t = bracketsOpt(t);\n-                            t = toP(F.at(pos).TypeArray(t));\n+                            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                                checkNullRestrictionLocation();\n+                                pendingNullRestriction = true;\n+                                nextToken();\n+                            }\n+                            JCExpression elem = bracketsOpt(t);\n+                            t = toP(F.at(pos).TypeArray(elem));\n+                            if (elem instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                                    nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+                                \/\/ fixup, as null-restriction was attached to the \"wrong\" array\n+                                nullableTypeExpression.setNullMarker(NullMarker.UNSPECIFIED);\n+                                pendingNullRestriction = true;\n+                            }\n+                            if (pendingNullRestriction) {\n+                                ((JCNullableTypeExpression)t).setNullMarker(NullMarker.NOT_NULL);\n+                            }\n@@ -1714,0 +1778,1 @@\n+                            skipUnsupportedNullRestriction();\n@@ -1720,0 +1785,1 @@\n+                                skipUnsupportedNullRestriction();\n@@ -1855,1 +1921,8 @@\n-            if (token.kind == LBRACKET) {\n+            if (allowNullRestrictedTypes && isMode(TYPE) && typeArgs == null && EMOTIONAL_QUALIFIER.test(token.kind) &&\n+                    (t instanceof JCIdent || t instanceof JCFieldAccess || t instanceof JCArrayTypeTree || t instanceof JCTypeApply)) {\n+                if (checkNullRestrictionLocation()) {\n+                    setNullMarker(t);\n+                    selectTypeMode();\n+                }\n+                nextToken();\n+            } else if (token.kind == LBRACKET) {\n@@ -1864,0 +1937,5 @@\n+                        if (allowNullRestrictedTypes && isMode(TYPE) && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                            checkNullRestrictionLocation();\n+                            setNullMarker(t);\n+                            nextToken();\n+                        }\n@@ -1942,0 +2020,9 @@\n+    void setNullMarker(JCExpression exp) {\n+        setNullMarker(exp, token);\n+    }\n+\n+    void setNullMarker(JCExpression exp, Token tk) {\n+        checkSourceLevel(Feature.NULL_RESTRICTED_TYPES);\n+        ((JCNullableTypeExpression)exp).setNullMarker(NullMarker.NOT_NULL);\n+    }\n+\n@@ -1956,1 +2043,1 @@\n-                case MONKEYS_AT:\n+                case MONKEYS_AT: case BANG:\n@@ -1992,1 +2079,2 @@\n-                            nextKind == TokenKind.COLCOL;\n+                            nextKind == TokenKind.COLCOL ||\n+                            (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(nextKind));\n@@ -2006,1 +2094,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n+    @SuppressWarnings({\"fallthrough\", \"unchecked\"})\n@@ -2074,0 +2162,16 @@\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, RPAREN, ARROW))) {\n+                        \/\/ Identifier, '!'\/'?', Identifier\/'_'\/'assert'\/'enum', ','\/')' -> explicit lambda\n+                        return ParensResult.EXPLICIT_LAMBDA;\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN) ||\n+                            allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, AMP)) {\n+                        \/\/ this must be a cast with emotional type\n+                        return ParensResult.CAST;\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LBRACKET)) ) {\n+                        \/\/ Identifier, '!'\/'?', '<'\/','\/'>' or\n+                        \/\/ Identifier, '!'\/'?', '[' -> it's a type, skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -2096,1 +2200,3 @@\n-                            peekToken(lookahead, RBRACKET, AMP)) {\n+                            (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER, RPAREN)) ||\n+                            peekToken(lookahead, RBRACKET, AMP) ||\n+                            (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER, AMP))) {\n@@ -2098,0 +2204,1 @@\n+                        \/\/ '[', ']', '!', ')' -> cast\n@@ -2100,0 +2207,6 @@\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER)) {\n+                        \/\/consume the ']' and the '!' and skip\n+                        type = true;\n+                        lookahead++;\n+                        lookahead++;\n+                        break;\n@@ -2118,1 +2231,3 @@\n-                                peekToken(lookahead, AMP)) {\n+                                (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) ||\n+                                peekToken(lookahead, AMP) ||\n+                                (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, AMP))) {\n@@ -2177,0 +2292,4 @@\n+    protected Predicate<TokenKind> EMOTIONAL_QUALIFIER = t -> t == BANG;\n+    protected Predicate<TokenKind> GENERIC_TYPE_END = t -> t == GT || t == GTGT || t == GTGTGT;\n+    protected Predicate<TokenKind> BAD_BANG_LOCATION = t -> t == LT || t == LBRACKET || t == MONKEYS_AT || t == DOT || t == LPAREN;\n+    protected Predicate<TokenKind> BAD_BANG_LOCATION_QUALIDENT = t -> t == LT || t == MONKEYS_AT || t == DOT || t == LPAREN;\n@@ -2389,1 +2508,1 @@\n-        if (token.kind == LT &&\n+        if (isParameterizedTypeStart() &&\n@@ -2398,0 +2517,6 @@\n+\n+    private boolean isParameterizedTypeStart() {\n+        return token.kind == LT ||\n+                (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && peekToken(LT));\n+    }\n+\n@@ -2496,0 +2621,1 @@\n+        skipUnsupportedNullRestriction(); \/\/ null-restriction not supported immediately before '<'\n@@ -2531,0 +2657,46 @@\n+    \/*\n+     * Null restriction support. If we see a null restriction token (e.g. '!'),\n+     * we check that the token is not followed by unsupported tokens, like '[', '(' and '.'.\n+     * Then, we also make sure that null restriction is enabled in this context\n+     * e.g. by making sure the ALLOW_BANG mode is set.\n+     *\/\n+    boolean checkNullRestrictionLocation() {\n+        Assert.check(EMOTIONAL_QUALIFIER.test(token.kind));\n+        if (peekToken(BAD_BANG_LOCATION)) {\n+            unsupportedNullRestriction();\n+            return false;\n+        } else {\n+            return checkNullRestrictonAllowed();\n+        }\n+    }\n+\n+    boolean checkNullRestrictionLocation(Predicate<TokenKind> badLocationFilter) {\n+        Assert.check(EMOTIONAL_QUALIFIER.test(token.kind));\n+        if (peekToken(badLocationFilter)) {\n+            unsupportedNullRestriction();\n+            return false;\n+        } else {\n+            return checkNullRestrictonAllowed();\n+        }\n+    }\n+\n+    boolean checkNullRestrictonAllowed() {\n+        Assert.check(EMOTIONAL_QUALIFIER.test(token.kind));\n+        if ((mode & ALLOW_BANGS) == 0) {\n+            unsupportedNullRestriction();\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    void unsupportedNullRestriction() {\n+        reportSyntaxError(token.pos, Errors.UnsupportedNullRestriction);\n+    }\n+\n+    void skipUnsupportedNullRestriction() {\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            unsupportedNullRestriction();\n+            nextToken();\n+        }\n+    }\n+\n@@ -2540,0 +2712,6 @@\n+        Token nullMarker = null;\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            checkNullRestrictionLocation();\n+            nullMarker = token;\n+            nextToken();\n+        }\n@@ -2542,0 +2720,3 @@\n+        if (nullMarker != null) {\n+            setNullMarker(t, nullMarker);\n+        }\n@@ -2633,1 +2814,1 @@\n-        JCExpression t = qualident(true);\n+        JCExpression t = qualident(true, TYPE | ALLOW_BANGS);\n@@ -2636,1 +2817,1 @@\n-        selectTypeMode();\n+        selectTypeModeWithBangs();\n@@ -2642,0 +2823,6 @@\n+            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                if (checkNullRestrictionLocation(BAD_BANG_LOCATION_QUALIDENT)) {\n+                    setNullMarker(t);\n+                }\n+                nextToken();\n+            }\n@@ -2658,0 +2845,7 @@\n+            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                if (checkNullRestrictionLocation(BAD_BANG_LOCATION_QUALIDENT)) {\n+                    setNullMarker(t);\n+                }\n+                nextToken();\n+            }\n+\n@@ -2661,0 +2855,6 @@\n+                if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                    if (checkNullRestrictionLocation(BAD_BANG_LOCATION_QUALIDENT)) {\n+                        setNullMarker(t);\n+                    }\n+                    nextToken();\n+                }\n@@ -2715,1 +2915,1 @@\n-        if (token.kind == LT) {\n+        if (isParameterizedTypeStart()) {\n@@ -2720,0 +2920,3 @@\n+\n+        skipUnsupportedNullRestriction();\n+\n@@ -2732,0 +2935,1 @@\n+            skipUnsupportedNullRestriction();\n@@ -2761,0 +2965,1 @@\n+            skipUnsupportedNullRestriction();\n@@ -2766,1 +2971,1 @@\n-                if (token.kind == RBRACKET) { \/\/ no dimension\n+                if (token.kind == RBRACKET) {\n@@ -2772,0 +2977,1 @@\n+                    skipUnsupportedNullRestriction();\n@@ -2957,1 +3163,1 @@\n-                JCExpression t = parseType(true);\n+                JCExpression t = parseType(true, TYPE | ALLOW_BANGS);\n@@ -3054,1 +3260,1 @@\n-            JCExpression t = term(EXPR | TYPE);\n+            JCExpression t = term(EXPR | TYPE | ALLOW_BANGS);\n@@ -3292,1 +3498,1 @@\n-        catchTypes.add(parseType());\n+        catchTypes.add(parseType(TYPE | ALLOW_BANGS));\n@@ -3297,1 +3503,1 @@\n-            catchTypes.add(parseType());\n+            catchTypes.add(parseType(TYPE | ALLOW_BANGS));\n@@ -3459,0 +3665,15 @@\n+                    } else if (typeDepth == 0 && allowNullRestrictedTypes &&\n+                            ((peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, ARROW) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COLON) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, RPAREN))) ) {\n+                        \/\/ this is a type test pattern\n+                        return PatternResult.PATTERN;\n+                    } else if ( allowNullRestrictedTypes &&\n+                            (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LBRACKET) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA)) ) {\n+                        \/\/ this is a type - skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -3473,1 +3694,1 @@\n-                case DOT, QUES, EXTENDS, SUPER, COMMA: break;\n+                case BANG, DOT, QUES, EXTENDS, SUPER, COMMA: break;\n@@ -3481,1 +3702,4 @@\n-                                peekToken(lookahead, tk -> tk == LPAREN) ? PatternResult.PATTERN\n+                                peekToken(lookahead, tk -> tk == LPAREN) ||\n+                                (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER)) ||\n+                                (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, tk -> tk == LPAREN))\n+                                 ? PatternResult.PATTERN\n@@ -3489,1 +3713,2 @@\n-                    if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {\n+                    if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER) ||\n+                            allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER)) {\n@@ -3491,1 +3716,2 @@\n-                    } else if (peekToken(lookahead, RBRACKET)) {\n+                    } else if (peekToken(lookahead, RBRACKET) ||\n+                            allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RBRACKET)) {\n@@ -3555,1 +3781,1 @@\n-            JCExpression t = term(EXPR | TYPE);\n+            JCExpression t = term(EXPR | TYPE | ALLOW_BANGS);\n@@ -4041,1 +4267,1 @@\n-        JCExpression t = term(EXPR | TYPE);\n+        JCExpression t = term(EXPR | TYPE | ALLOW_BANGS);\n@@ -4853,1 +5079,1 @@\n-            type = unannotatedType(false);\n+            type = unannotatedType(false, TYPE | ALLOW_BANGS);\n@@ -4961,1 +5187,1 @@\n-            type = unannotatedType(false);\n+            type = unannotatedType(false, TYPE | ALLOW_BANGS);\n@@ -5496,1 +5722,1 @@\n-        JCExpression type = parseType(lambdaParameter);\n+        JCExpression type = parseType(lambdaParameter, TYPE | ALLOW_BANGS);\n@@ -5500,0 +5726,5 @@\n+            if (type instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                    nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+                \/\/ can't mix bangs and varargs\n+                unsupportedNullRestriction(); \/\/ @@@: we could probably improve the position here\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":273,"deletions":42,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -3427,0 +3427,3 @@\n+compiler.misc.feature.null.restricted.types=\\\n+    nullable and null restricted types\n+\n@@ -4362,0 +4365,31 @@\n+\n+### null-restricted types\n+\n+compiler.err.non.nullable.should.be.initialized=\\\n+    field of non-nullable type should be initialized\n+\n+# 0: name\n+compiler.misc.attribute.must.be.unique=\\\n+    attribute {0} must be unique\n+\n+# 0: name\n+compiler.misc.attribute.only.applicable.to.fields=\\\n+    attribute {0} is only applicable to fields\n+\n+# 0: name, 1: type\n+compiler.misc.attribute.not.applicable.to.field.type=\\\n+    attribute {0} is not applicable to {1}\n+\n+compiler.err.unsupported.null.restriction=\\\n+    null restriction not supported in this type context\n+\n+# lint: null\n+# 0: type, 1: type\n+compiler.warn.suspicious.nullness.conversion=\\\n+    Suspicious nullness conversion\\n\\\n+    required: {0}!\\n\\\n+    found:    {1}\n+\n+# 0: type\n+compiler.err.restricted.array.missing.init =\\\n+   Non-empty null-restricted array of type {0} must specify an initializer\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -248,0 +248,3 @@\n+javac.opt.Xlint.desc.null=\\\n+    Warn about operations on null-restricted types.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -342,0 +343,4 @@\n+        \/** unary operator for null reference checks, only used internally\n+         *  for null restricted types\n+         *\/\n+        NULLRESTRICTEDCHK,\n@@ -1976,0 +1981,1 @@\n+        public boolean strict = false;\n@@ -1977,2 +1983,2 @@\n-                           List<JCExpression> dims,\n-                           List<JCExpression> elems)\n+                             List<JCExpression> dims,\n+                             List<JCExpression> elems)\n@@ -2260,0 +2266,1 @@\n+        public boolean strict = false;\n@@ -2579,1 +2586,1 @@\n-    public static class JCFieldAccess extends JCExpression implements MemberSelectTree {\n+    public static class JCFieldAccess extends JCNullableTypeExpression implements MemberSelectTree {\n@@ -2716,1 +2723,1 @@\n-    public static class JCIdent extends JCExpression implements IdentifierTree {\n+    public static class JCIdent extends JCNullableTypeExpression implements IdentifierTree {\n@@ -2825,1 +2832,1 @@\n-    public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {\n+    public static class JCArrayTypeTree extends JCNullableTypeExpression implements ArrayTypeTree {\n@@ -2850,1 +2857,1 @@\n-    public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {\n+    public static class JCTypeApply extends JCNullableTypeExpression implements ParameterizedTypeTree {\n@@ -2908,0 +2915,41 @@\n+    \/**\n+     * A nullable type expression. Supported nullable expression types are: simple type names,\n+     * qualified type names, parameterized types and array types.\n+     *\/\n+\n+    public static abstract class JCNullableTypeExpression extends JCExpression {\n+        private NullMarker nullMarker = NullMarker.UNSPECIFIED;\n+\n+        public NullMarker getNullMarker() {\n+            return nullMarker;\n+        }\n+\n+        public JCNullableTypeExpression setNullMarker(NullMarker nullMarker) {\n+            this.nullMarker = nullMarker;\n+            return this;\n+        }\n+\n+        public enum NullMarker {\n+            NOT_NULL(\"!\"),\n+            UNSPECIFIED(\"\");\n+\n+            private final String typeSuffix;\n+\n+            NullMarker(String typeSuffix) {\n+                this.typeSuffix = typeSuffix;\n+            }\n+\n+            public String typeSuffix() {\n+                return typeSuffix;\n+            }\n+\n+            public static NullMarker of(String typeSuffix) {\n+                return switch (typeSuffix) {\n+                    case \"!\" -> NOT_NULL;\n+                    case \"\" -> UNSPECIFIED;\n+                    default -> throw new AssertionError(\"invalid type suffix \" + typeSuffix);\n+                };\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":54,"deletions":6,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+                if (!(tree instanceof JCArrayTypeTree) &&\n+                        tree instanceof JCNullableTypeExpression nullableType) {\n+                    print(nullableType.getNullMarker().typeSuffix());\n+                }\n@@ -1310,0 +1314,2 @@\n+            case NULLRESTRICTEDCHK:\n+                          return \"<*nullrestrictedchk*>\";\n@@ -1561,0 +1567,1 @@\n+                print(((JCArrayTypeTree)elem).getNullMarker().typeSuffix());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1180,1 +1180,2 @@\n-        case NULLCHK: return postfixPrec;\n+        case NULLCHK:\n+        case NULLRESTRICTEDCHK: return postfixPrec;\n@@ -1319,0 +1320,1 @@\n+        case NULLRESTRICTEDCHK:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -438,2 +439,2 @@\n-                             List<JCExpression> dims,\n-                             List<JCExpression> elems)\n+                               List<JCExpression> dims,\n+                               List<JCExpression> elems)\n@@ -891,1 +892,5 @@\n-        return tp.setType(t);\n+        tp.setType(t);\n+        TypeMetadata.NullMarker nm = t.getMetadata(TypeMetadata.NullMarker.class);\n+        return (nm != null && nm.nullMarker() != NullMarker.UNSPECIFIED && tp instanceof JCNullableTypeExpression) ?\n+            ((JCNullableTypeExpression)tp).setNullMarker(t.getMetadata(TypeMetadata.NullMarker.class).nullMarker()) :\n+            tp;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+    public final Name NullRestricted;\n@@ -240,0 +241,5 @@\n+    \/\/ value classes\n+    public final Name newInstance;\n+    public final Name nullCheck;\n+    public final Name copied;\n+\n@@ -371,0 +377,1 @@\n+        NullRestricted = fromString(\"NullRestricted\");\n@@ -431,0 +438,5 @@\n+\n+        \/\/value classes\n+        newInstance = fromString(\"newInstance\");\n+        nullCheck = fromString(\"nullCheck\");\n+        copied = fromString(\"copied\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -83,0 +83,5 @@\n+    public void remove(LintCategory lint) {\n+        nonSilentLintSet.remove(lint);\n+        silentLintSet.remove(lint);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Warner.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -288,0 +288,6 @@\n+                void addValue(TypeElement e) {\n+                    if (e.getModifiers().contains(Modifier.VALUE)) {\n+                        list.add(\"value\");\n+                    }\n+                }\n+\n@@ -299,0 +305,1 @@\n+                    addValue(e);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression;\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -332,0 +334,1 @@\n+            boolean nonNull = false;\n@@ -343,0 +346,4 @@\n+                if (baseType instanceof JCNullableTypeExpression nullable &&\n+                    nullable.getNullMarker() == NullMarker.NOT_NULL) {\n+                    nonNull = true;\n+                }\n@@ -428,1 +435,1 @@\n-                                     winit, enhancedDesugaring, anonDeclareWrap);\n+                                     winit, nonNull, enhancedDesugaring, anonDeclareWrap);\n@@ -431,1 +438,2 @@\n-                    name, fieldName, subkind, displayType, hasEnhancedType ? fullTypeName : null, anonymousClasses,\n+                    name, fieldName, subkind, displayType, hasEnhancedType ? fullTypeName : null,\n+                    nonNull, anonymousClasses,\n@@ -691,1 +699,1 @@\n-                        name, name, SubKind.TEMP_VAR_EXPRESSION_SUBKIND, displayTypeName, fullTypeName, anonymousClasses, declareReferences, null);\n+                        name, name, SubKind.TEMP_VAR_EXPRESSION_SUBKIND, displayTypeName, fullTypeName, false, anonymousClasses, declareReferences, null);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Eval.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-                                : EXPR | TYPE);\n+                                : EXPR | TYPE | ALLOW_BANGS);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/ReplParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    final boolean nonNull;\n@@ -65,0 +66,1 @@\n+            boolean nonNull,\n@@ -71,0 +73,1 @@\n+        this.nonNull = nonNull;\n@@ -89,1 +92,1 @@\n-        return \"import static \" + classFullName() + \".\" + name() + \";   \" +\n+        return \"import static \" + classFullName() + \".\" + (nonNull ? \"Holder.\" : \"\") + name() + \";   \" +\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/VarSnippet.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                               Wrap wname, Wrap winit, boolean enhanced,\n+                               Wrap wname, Wrap winit, boolean nonNull, boolean enhanced,\n@@ -94,1 +94,1 @@\n-        components.add(new VarDeclareWrap(wtype, brackets, wname));\n+\n@@ -97,2 +97,8 @@\n-        if (winit == null) {\n-            wmeth = new CompoundWrap(new NoWrap(\" \"), \"   return null;\\n\");\n+        if (nonNull) {\n+            components.add(\n+                    new CompoundWrap(\"    public static class Holder {\\n    \",\n+                                     new VarDeclareWrap(wtype, brackets, wname, winit),\n+                                     \"    }\\n\"));\n+            wmeth = new CompoundWrap(\n+                    \"        return \", \"Holder.\", wname, \";\\n\"\n+            );\n@@ -100,26 +106,4 @@\n-            \/\/ int x = y\n-            if (enhanced) {\n-                \/\/ private static <Z> Z do_itAux() {\n-                \/\/     wtype x_ = y;\n-                \/\/     @SuppressWarnings(\"unchecked\")\n-                \/\/     Z x__ = (Z) x_;\n-                \/\/     return x__;\n-                \/\/ }\n-                \/\/ in do_it method:\n-                \/\/return do_itAux();\n-                \/\/find an unused name:\n-                String scratchName = \"$\";\n-                while (winit.wrapped().contains(scratchName)) {\n-                    scratchName += \"$\";\n-                }\n-                Wrap waux = new CompoundWrap(\n-                        \"    private static <\" + scratchName + \"> \" + scratchName +\" \", DOIT_METHOD_NAME + \"Aux\", \"() throws java.lang.Throwable {\\n\",\n-                        wtype, brackets + \" \", scratchName, \"_ =\\n        \", winit, semi(winit),\n-                        \"        @java.lang.SuppressWarnings(\\\"unchecked\\\") \", scratchName, \" \", scratchName, \"__ = (\", scratchName, \")\", scratchName, \"_;\\n\",\n-                        \"        return \", scratchName, \"__;\\n\",\n-                        \"}\"\n-                );\n-                components.add(waux);\n-                wmeth = new CompoundWrap(\n-                        \"        return \", wname, \" = \", DOIT_METHOD_NAME + \"Aux\", \"();\\n\"\n-                );\n+            components.add(new VarDeclareWrap(wtype, brackets, wname));\n+\n+            if (winit == null) {\n+                wmeth = new CompoundWrap(new NoWrap(\" \"), \"   return null;\\n\");\n@@ -127,6 +111,34 @@\n-                \/\/ int x_ = y; return x = x_;\n-                \/\/ decl + \"_ = \" + init ; + \"return \" + name + \"= \" + name + \"_ ;\"\n-                wmeth = new CompoundWrap(\n-                        wtype, brackets + \" \", wname, \"_ =\\n        \", winit, semi(winit),\n-                        \"        return \", wname, \" = \", wname, \"_;\\n\"\n-                );\n+                \/\/ int x = y\n+                if (enhanced) {\n+                    \/\/ private static <Z> Z do_itAux() {\n+                    \/\/     wtype x_ = y;\n+                    \/\/     @SuppressWarnings(\"unchecked\")\n+                    \/\/     Z x__ = (Z) x_;\n+                    \/\/     return x__;\n+                    \/\/ }\n+                    \/\/ in do_it method:\n+                    \/\/return do_itAux();\n+                    \/\/find an unused name:\n+                    String scratchName = \"$\";\n+                    while (winit.wrapped().contains(scratchName)) {\n+                        scratchName += \"$\";\n+                    }\n+                    Wrap waux = new CompoundWrap(\n+                            \"    private static <\" + scratchName + \"> \" + scratchName +\" \", DOIT_METHOD_NAME + \"Aux\", \"() throws java.lang.Throwable {\\n\",\n+                            wtype, brackets + \" \", scratchName, \"_ =\\n        \", winit, semi(winit),\n+                            \"        @java.lang.SuppressWarnings(\\\"unchecked\\\") \", scratchName, \" \", scratchName, \"__ = (\", scratchName, \")\", scratchName, \"_;\\n\",\n+                            \"        return \", scratchName, \"__;\\n\",\n+                            \"}\"\n+                    );\n+                    components.add(waux);\n+                    wmeth = new CompoundWrap(\n+                            \"        return \", wname, \" = \", DOIT_METHOD_NAME + \"Aux\", \"();\\n\"\n+                    );\n+                } else {\n+                    \/\/ int x_ = y; return x = x_;\n+                    \/\/ decl + \"_ = \" + init ; + \"return \" + name + \"= \" + name + \"_ ;\"\n+                    wmeth = new CompoundWrap(\n+                            wtype, brackets + \" \", wname, \"_ =\\n        \", winit, semi(winit),\n+                            \"        return \", wname, \" = \", wname, \"_;\\n\"\n+                    );\n+                }\n@@ -564,0 +576,3 @@\n+        VarDeclareWrap(Wrap wtype, String brackets, Wrap wname, Wrap init) {\n+            super(\"    public static \", wtype, brackets + \" \", wname, \" = \", init, \";\\n\");\n+        }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Wrap.java","additions":51,"deletions":36,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -3242,2 +3241,1 @@\n-    @NullRestricted\n-    static final MyValueEmpty empty = new MyValueEmpty();\n+    static final MyValueEmpty! empty = new MyValueEmpty();\n@@ -3265,2 +3263,1 @@\n-        @NullRestricted\n-        MyValueEmpty empty = new MyValueEmpty();\n+        MyValueEmpty! empty = new MyValueEmpty();\n@@ -3792,2 +3789,1 @@\n-        @NullRestricted\n-        MyValue152Inline val = new MyValue152Inline(); \/\/ Not flat\n+        MyValue152Inline! val = new MyValue152Inline(); \/\/ Not flat\n@@ -3814,2 +3810,1 @@\n-        @NullRestricted\n-        MyValue152Inline val = new MyValue152Inline(); \/\/ Not flat\n+        MyValue152Inline! val = new MyValue152Inline(); \/\/ Not flat\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -76,2 +75,1 @@\n-    @NullRestricted\n-    static Point fsp = new Point();\n+    static Point! fsp = new Point();\n@@ -81,2 +79,1 @@\n-    @NullRestricted\n-    Point fip;\n+    Point! fip;\n@@ -86,2 +83,1 @@\n-    @NullRestricted\n-    static JumboInline fsj = new JumboInline();\n+    static JumboInline! fsj = new JumboInline();\n@@ -91,2 +87,1 @@\n-    @NullRestricted\n-    JumboInline fij;\n+    JumboInline! fij;\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlattenableSemanticTest.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,643 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class ArrayCreationInvoker version 67:0 {\n+\n+    const #1 = Dynamic REF_invokeStatic:java\/lang\/invoke\/ConstantBootstraps.primitiveClass\n+                   :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Class;\"\n+                   :I:\"Ljava\/lang\/Class;\";\n+\n+    public static Method emptyS:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.empty\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0;\n+        areturn;\n+    }\n+\n+    public static Method emptyS_N:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.empty\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200;\n+        areturn;\n+    }\n+\n+    public static Method emptyI:\"()[I\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.empty\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[I\"\n+                #1, int 0;\n+        areturn;\n+    }\n+\n+    public static Method constantFilled3S:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method constantFilled3S_N:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int 3, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method constantFilled3I:\"()[I\" stack 1 {\n+         invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[I\"\n+                #1, int 0, int 3, int 3;\n+         areturn;\n+     }\n+\n+    public static Method constantFilled0S:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method constantFilled0S_N:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int 0, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method constantFilled0I:\"()[I\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[I\"\n+                #1, int 0, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method constantFilledNS:\"(I)[Ljava\/lang\/String;\" stack 1 {\n+        iload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method constantFilledNS_N:\"(I)[Ljava\/lang\/String;\" stack 1 {\n+        iload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int -1, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method constantFilledNI:\"(I)[I\" stack 1 {\n+        iload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I)[I\"\n+                #1, int 0, int -1, int 3;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled3S:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled3S_N:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int 3;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled3I:\"(I)[I\" stack 1 {\n+        iload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I)[I\"\n+                #1, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled0S:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled0S_N:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled0I:\"(I)[I\" stack 1 {\n+        iload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I)[I\"\n+                #1, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilledNS:\"(ILjava\/lang\/String;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(ILjava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilledNS_N:\"(ILjava\/lang\/String;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(ILjava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int -1;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilledNI:\"(II)[I\" stack 2 {\n+        iload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(II)[I\"\n+                #1, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method computed3S:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method computed3S_N:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int 3;\n+        areturn;\n+    }\n+\n+    public static Method computed3I:\"(Ljava\/util\/function\/IntFunction;)[I\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[I\"\n+                #1, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method computed0S:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method computed0S_N:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int 0;\n+        areturn;\n+    }\n+\n+    public static Method computed0I:\"(Ljava\/util\/function\/IntFunction;)[I\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[I\"\n+                #1, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method computedNS:\"(ILjava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(ILjava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method computedNS_N:\"(ILjava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(ILjava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int -1;\n+        areturn;\n+    }\n+\n+    public static Method computedNI:\"(ILjava\/util\/function\/IntFunction;)[I\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(ILjava\/util\/function\/IntFunction;)[I\"\n+                #1, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method copied3S:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method copied3S_N:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int 3;\n+        areturn;\n+    }\n+\n+    public static Method copied3I:\"([I)[I\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([I)[I\"\n+                #1, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method copied0S:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method copied0S_N:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int 0;\n+        areturn;\n+    }\n+\n+    public static Method copied0I:\"([I)[I\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([I)[I\"\n+                #1, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method copiedNS:\"(I[Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method copiedNS_N:\"(I[Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int -1;\n+        areturn;\n+    }\n+\n+    public static Method copiedNI:\"(I[I)[I\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[I)[I\"\n+                #1, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied3S:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied3S_N:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int 3;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied3I:\"([II)[I\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([II)[I\"\n+                #1, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied0S:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied0S_N:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int 0;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied0I:\"([II)[I\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([II)[I\"\n+                #1, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopiedNS:\"(I[Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 3 {\n+        iload_0;\n+        aload_1;\n+        iload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopiedNS_N:\"(I[Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 3 {\n+        iload_0;\n+        aload_1;\n+        iload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, int -1;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopiedNI:\"(I[II)[I\" stack 3 {\n+        iload_0;\n+        aload_1;\n+        iload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[II)[I\"\n+                #1, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated3S:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, String \"c1\", String \"c2\", String \"c3\";\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated3S_N:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200, String \"c1\", String \"c2\", String \"c3\";\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated3I:\"()[I\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[I\"\n+                #1, int 0, int 30, int 40, int 50;\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated0S:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0;\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated0S_N:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200;\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated0I:\"()[I\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[I\"\n+                #1, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated3S\n+            :\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+            stack 3 {\n+        aload_0;\n+        aload_1;\n+        aload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated3S_N\n+            :\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+            stack 3 {\n+        aload_0;\n+        aload_1;\n+        aload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated3I:\"(III)[I\" stack 3 {\n+        iload_0;\n+        iload_1;\n+        iload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(III)[I\"\n+                #1, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated0S:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated0S_N:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0x0200;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated0I:\"()[I\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/Class;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[I\"\n+                #1, int 0;\n+        areturn;\n+    }\n+\n+ }\n","filename":"test\/jdk\/java\/lang\/runtime\/ArrayCreationInvoker.jasm","additions":643,"deletions":0,"binary":false,"changes":643,"status":"added"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+import java.lang.runtime.ArrayCreation;\n+\n+\/**\n+ * @test\n+ * @summary java.lang.runtime.ArrayCreation factories and bootstraps\n+ * @compile ArrayCreationInvoker.jasm\n+ * @run main ArrayCreationTest\n+ *\/\n+public class ArrayCreationTest {\n+\n+    private static final int PLAIN = 0;\n+    private static final int CHECKED = 0x0200;\n+\n+    public static void main(String... args) {\n+\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.empty(String.class, PLAIN),\n+                   ArrayCreationInvoker.emptyS());\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.empty(int.class, PLAIN),\n+                   ArrayCreationInvoker.emptyI());\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.empty(String.class, CHECKED),\n+                   ArrayCreationInvoker.emptyS_N());\n+\n+        checkArray(String.class, PLAIN, List.of(\"c\", \"c\", \"c\"),\n+                   ArrayCreation.filled(String.class, PLAIN, 3, \"c\"),\n+                   ArrayCreationInvoker.constantFilled3S());\n+        checkArray(int.class, PLAIN, List.of(3, 3, 3),\n+                   ArrayCreation.filled(int.class, PLAIN, 3, 3),\n+                   ArrayCreationInvoker.constantFilled3I());\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.filled(String.class, PLAIN, 0, \"c\"),\n+                   ArrayCreationInvoker.constantFilled0S());\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.filled(int.class, PLAIN, 0, 3),\n+                   ArrayCreationInvoker.constantFilled0I());\n+        checkArray(String.class, PLAIN, List.of(\"c\", \"c\", \"c\", \"c\", \"c\"),\n+                   ArrayCreation.filled(String.class, PLAIN, 5, \"c\"),\n+                   ArrayCreationInvoker.constantFilledNS(5));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.filled(String.class, PLAIN, 0, \"c\"),\n+                   ArrayCreationInvoker.constantFilledNS(0));\n+        checkArray(int.class, PLAIN, List.of(3, 3, 3, 3, 3),\n+                   ArrayCreation.filled(int.class, PLAIN, 5, 3),\n+                   ArrayCreationInvoker.constantFilledNI(5));\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.filled(int.class, PLAIN, 0, 3),\n+                   ArrayCreationInvoker.constantFilledNI(0));\n+        checkArray(String.class, CHECKED, List.of(\"c\", \"c\", \"c\"),\n+                   ArrayCreation.filled(String.class, CHECKED, 3, \"c\"),\n+                   ArrayCreationInvoker.constantFilled3S_N());\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.filled(String.class, CHECKED, 0, \"c\"),\n+                   ArrayCreationInvoker.constantFilled0S_N());\n+        checkArray(String.class, CHECKED, List.of(\"c\", \"c\", \"c\", \"c\", \"c\"),\n+                   ArrayCreation.filled(String.class, CHECKED, 5, \"c\"),\n+                   ArrayCreationInvoker.constantFilledNS_N(5));\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.filled(String.class, CHECKED, 0, \"c\"),\n+                   ArrayCreationInvoker.constantFilledNS_N(0));\n+\n+        checkArray(String.class, PLAIN, List.of(\"hi\", \"hi\", \"hi\"),\n+                   ArrayCreation.filled(String.class, PLAIN, 3, \"hi\"),\n+                   ArrayCreationInvoker.dynamicFilled3S(\"hi\"));\n+        checkArray(int.class, PLAIN, List.of(23, 23, 23),\n+                   ArrayCreation.filled(int.class, PLAIN, 3, 23),\n+                   ArrayCreationInvoker.dynamicFilled3I(23));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.filled(String.class, PLAIN, 0, \"hi\"),\n+                   ArrayCreationInvoker.dynamicFilled0S(\"hi\"));\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.filled(int.class, PLAIN, 0, 23),\n+                   ArrayCreationInvoker.dynamicFilled0I(23));\n+        checkArray(String.class, PLAIN, List.of(\"hi\", \"hi\"),\n+                   ArrayCreation.filled(String.class, PLAIN, 2, \"hi\"),\n+                   ArrayCreationInvoker.dynamicFilledNS(2, \"hi\"));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.filled(String.class, PLAIN, 0, \"hi\"),\n+                   ArrayCreationInvoker.dynamicFilledNS(0, \"hi\"));\n+        checkArray(int.class, PLAIN, List.of(23, 23),\n+                   ArrayCreation.filled(int.class, PLAIN, 2, 23),\n+                   ArrayCreationInvoker.dynamicFilledNI(2, 23));\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.filled(int.class, PLAIN, 0, 23),\n+                   ArrayCreationInvoker.dynamicFilledNI(0, 23));\n+        checkArray(String.class, CHECKED, List.of(\"hi\", \"hi\", \"hi\"),\n+                   ArrayCreation.filled(String.class, CHECKED, 3, \"hi\"),\n+                   ArrayCreationInvoker.dynamicFilled3S_N(\"hi\"));\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.filled(String.class, CHECKED, 0, \"hi\"),\n+                   ArrayCreationInvoker.dynamicFilled0S_N(\"hi\"));\n+        checkArray(String.class, CHECKED, List.of(\"hi\", \"hi\"),\n+                   ArrayCreation.filled(String.class, CHECKED, 2, \"hi\"),\n+                   ArrayCreationInvoker.dynamicFilledNS_N(2, \"hi\"));\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.filled(String.class, CHECKED, 0, \"hi\"),\n+                   ArrayCreationInvoker.dynamicFilledNS_N(0, \"hi\"));\n+\n+        checkArray(String.class, PLAIN, List.of(\"x0\", \"x1\", \"x2\"),\n+                   ArrayCreation.computed(String.class, PLAIN, 3, i -> \"x\"+i),\n+                   ArrayCreationInvoker.computed3S(i -> \"x\"+i));\n+        checkArray(int.class, PLAIN, List.of(5, 6, 7),\n+                   ArrayCreation.computed(int.class, PLAIN, 3, i -> i+5),\n+                   ArrayCreationInvoker.computed3I(i -> i+5));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.computed(String.class, PLAIN, 0, i -> \"y\"+i),\n+                   ArrayCreationInvoker.computed0S(i -> \"y\"+i));\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.computed(int.class, PLAIN, 0, i -> i+6),\n+                   ArrayCreationInvoker.computed0I(i -> i+6));\n+        checkArray(String.class, PLAIN, List.of(\"z0\", \"z1\", \"z2\", \"z3\", \"z4\"),\n+                   ArrayCreation.computed(String.class, PLAIN, 5, i -> \"z\"+i),\n+                   ArrayCreationInvoker.computedNS(5, i -> \"z\"+i));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.computed(String.class, PLAIN, 0, i -> \"w\"+i),\n+                   ArrayCreationInvoker.computedNS(0, i -> \"w\"+i));\n+        checkArray(int.class, PLAIN, List.of(7, 8, 9, 10, 11),\n+                   ArrayCreation.computed(int.class, PLAIN, 5, i -> i+7),\n+                   ArrayCreationInvoker.computedNI(5, i -> i+7));\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.computed(int.class, PLAIN, 0, i -> i+8),\n+                   ArrayCreationInvoker.computedNI(0, i -> i+8));\n+        checkArray(String.class, CHECKED, List.of(\"x0\", \"x1\", \"x2\"),\n+                   ArrayCreation.computed(String.class, CHECKED, 3, i -> \"x\"+i),\n+                   ArrayCreationInvoker.computed3S_N(i -> \"x\"+i));\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.computed(String.class, CHECKED, 0, i -> \"y\"+i),\n+                   ArrayCreationInvoker.computed0S_N(i -> \"y\"+i));\n+        checkArray(String.class, CHECKED, List.of(\"z0\", \"z1\", \"z2\", \"z3\", \"z4\"),\n+                   ArrayCreation.computed(String.class, CHECKED, 5, i -> \"z\"+i),\n+                   ArrayCreationInvoker.computedNS_N(5, i -> \"z\"+i));\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.computed(String.class, CHECKED, 0, i -> \"w\"+i),\n+                   ArrayCreationInvoker.computedNS_N(0, i -> \"w\"+i));\n+\n+        Object[] srcS = new Object[]{ \"a\", \"b\", \"c\", \"d\", \"e\" };\n+        int[] srcI = new int[]{ 1, 2, 3, 4, 5 };\n+\n+        checkArray(String.class, PLAIN, List.of(\"a\", \"b\", \"c\"),\n+                   ArrayCreation.copied(String.class, PLAIN, 3, srcS),\n+                   ArrayCreationInvoker.copied3S(srcS));\n+        checkArray(int.class, PLAIN, List.of(1, 2, 3),\n+                   ArrayCreation.copied(int.class, PLAIN, 3, srcI),\n+                   ArrayCreationInvoker.copied3I(srcI));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.copied(String.class, PLAIN, 0, srcS),\n+                   ArrayCreationInvoker.copied0S(srcS));\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.copied(int.class, PLAIN, 0, srcI),\n+                   ArrayCreationInvoker.copied0I(srcI));\n+        checkArray(String.class, PLAIN, List.of(\"a\", \"b\", \"c\", \"d\"),\n+                   ArrayCreation.copied(String.class, PLAIN, 4, srcS),\n+                   ArrayCreationInvoker.copiedNS(4, srcS));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.copied(String.class, PLAIN, 0, srcS),\n+                   ArrayCreationInvoker.copiedNS(0, srcS));\n+        checkArray(int.class, PLAIN, List.of(1, 2, 3, 4),\n+                   ArrayCreation.copied(int.class, PLAIN, 4, srcI),\n+                   ArrayCreationInvoker.copiedNI(4, srcI));\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.copied(int.class, PLAIN, 0, srcI),\n+                   ArrayCreationInvoker.copiedNI(0, srcI));\n+        checkArray(String.class, CHECKED, List.of(\"a\", \"b\", \"c\"),\n+                   ArrayCreation.copied(String.class, CHECKED, 3, srcS),\n+                   ArrayCreationInvoker.copied3S_N(srcS));\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.copied(String.class, CHECKED, 0, srcS),\n+                   ArrayCreationInvoker.copied0S_N(srcS));\n+        checkArray(String.class, CHECKED, List.of(\"a\", \"b\", \"c\", \"d\"),\n+                   ArrayCreation.copied(String.class, CHECKED, 4, srcS),\n+                   ArrayCreationInvoker.copiedNS_N(4, srcS));\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.copied(String.class, CHECKED, 0, srcS),\n+                   ArrayCreationInvoker.copiedNS_N(0, srcS));\n+\n+        checkArray(String.class, PLAIN, List.of(\"a\", \"b\", \"c\"),\n+                   ArrayCreation.offsetCopied(String.class, PLAIN, 3, srcS, 0),\n+                   ArrayCreationInvoker.offsetCopied3S(srcS, 0));\n+        checkArray(String.class, PLAIN, List.of(\"c\", \"d\", \"e\"),\n+                   ArrayCreation.offsetCopied(String.class, PLAIN, 3, srcS, 2),\n+                   ArrayCreationInvoker.offsetCopied3S(srcS, 2));\n+        checkArray(int.class, PLAIN, List.of(1, 2, 3),\n+                   ArrayCreation.offsetCopied(int.class, PLAIN, 3, srcI, 0),\n+                   ArrayCreationInvoker.offsetCopied3I(srcI, 0));\n+        checkArray(int.class, PLAIN, List.of(3, 4, 5),\n+                   ArrayCreation.offsetCopied(int.class, PLAIN, 3, srcI, 2),\n+                   ArrayCreationInvoker.offsetCopied3I(srcI, 2));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.offsetCopied(String.class, PLAIN, 0, srcS, 0),\n+                   ArrayCreationInvoker.offsetCopied0S(srcS, 0));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.offsetCopied(String.class, PLAIN, 0, srcS, 2),\n+                   ArrayCreationInvoker.offsetCopied0S(srcS, 2));\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.offsetCopied(int.class, PLAIN, 0, srcI, 0),\n+                   ArrayCreationInvoker.offsetCopied0I(srcI, 0));\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.offsetCopied(int.class, PLAIN, 0, srcI, 2),\n+                   ArrayCreationInvoker.offsetCopied0I(srcI, 2));\n+        checkArray(String.class, PLAIN, List.of(\"b\", \"c\", \"d\", \"e\"),\n+                   ArrayCreation.offsetCopied(String.class, PLAIN, 4, srcS, 1),\n+                   ArrayCreationInvoker.offsetCopiedNS(4, srcS, 1));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.offsetCopied(String.class, PLAIN, 0, srcS, 4),\n+                   ArrayCreationInvoker.offsetCopiedNS(0, srcS, 4));\n+        checkArray(int.class, PLAIN, List.of(2, 3, 4, 5),\n+                   ArrayCreation.offsetCopied(int.class, PLAIN, 4, srcI, 1),\n+                   ArrayCreationInvoker.offsetCopiedNI(4, srcI, 1));\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.offsetCopied(int.class, PLAIN, 0, srcI, 4),\n+                   ArrayCreationInvoker.offsetCopiedNI(0, srcI, 4));\n+        checkArray(String.class, CHECKED, List.of(\"a\", \"b\", \"c\"),\n+                   ArrayCreation.offsetCopied(String.class, CHECKED, 3, srcS, 0),\n+                   ArrayCreationInvoker.offsetCopied3S_N(srcS, 0));\n+        checkArray(String.class, CHECKED, List.of(\"c\", \"d\", \"e\"),\n+                   ArrayCreation.offsetCopied(String.class, CHECKED, 3, srcS, 2),\n+                   ArrayCreationInvoker.offsetCopied3S_N(srcS, 2));\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.offsetCopied(String.class, CHECKED, 0, srcS, 0),\n+                   ArrayCreationInvoker.offsetCopied0S_N(srcS, 0));\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.offsetCopied(String.class, CHECKED, 0, srcS, 2),\n+                   ArrayCreationInvoker.offsetCopied0S_N(srcS, 2));\n+        checkArray(String.class, CHECKED, List.of(\"b\", \"c\", \"d\", \"e\"),\n+                   ArrayCreation.offsetCopied(String.class, CHECKED, 4, srcS, 1),\n+                   ArrayCreationInvoker.offsetCopiedNS_N(4, srcS, 1));\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.offsetCopied(String.class, CHECKED, 0, srcS, 4),\n+                   ArrayCreationInvoker.offsetCopiedNS_N(0, srcS, 4));\n+\n+        checkArray(String.class, PLAIN, List.of(\"c1\", \"c2\", \"c3\"),\n+                   ArrayCreation.enumerated(String.class, PLAIN, \"c1\", \"c2\", \"c3\"),\n+                   ArrayCreationInvoker.constantEnumerated3S());\n+        checkArray(int.class, PLAIN, List.of(30, 40, 50),\n+                   ArrayCreation.enumerated(int.class, PLAIN, 30, 40, 50),\n+                   ArrayCreationInvoker.constantEnumerated3I());\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.empty(String.class, PLAIN),\n+                   ArrayCreationInvoker.constantEnumerated0S());\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.empty(int.class, PLAIN),\n+                   ArrayCreationInvoker.constantEnumerated0I());\n+        checkArray(String.class, CHECKED, List.of(\"c1\", \"c2\", \"c3\"),\n+                   ArrayCreation.enumerated(String.class, CHECKED, \"c1\", \"c2\", \"c3\"),\n+                   ArrayCreationInvoker.constantEnumerated3S_N());\n+        checkArray(String.class, CHECKED, List.of(),\n+                   ArrayCreation.empty(String.class, CHECKED),\n+                   ArrayCreationInvoker.constantEnumerated0S_N());\n+\n+        checkArray(String.class, PLAIN, List.of(\"x\", \"y\", \"z\"),\n+                   ArrayCreation.enumerated(String.class, PLAIN, \"x\", \"y\", \"z\"),\n+                   ArrayCreationInvoker.dynamicEnumerated3S(\"x\", \"y\", \"z\"));\n+        checkArray(int.class, PLAIN, List.of(-12, 0, 583),\n+                   ArrayCreation.enumerated(int.class, PLAIN, -12, 0, 583),\n+                   ArrayCreationInvoker.dynamicEnumerated3I(-12, 0, 583));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.empty(String.class, PLAIN),\n+                   ArrayCreationInvoker.dynamicEnumerated0S());\n+        checkArray(int.class, PLAIN, List.of(),\n+                   ArrayCreation.empty(int.class, PLAIN),\n+                   ArrayCreationInvoker.dynamicEnumerated0I());\n+        checkArray(String.class, CHECKED, List.of(\"x\", \"y\", \"z\"),\n+                   ArrayCreation.enumerated(String.class, CHECKED, \"x\", \"y\", \"z\"),\n+                   ArrayCreationInvoker.dynamicEnumerated3S_N(\"x\", \"y\", \"z\"));\n+        checkArray(String.class, PLAIN, List.of(),\n+                   ArrayCreation.empty(String.class, CHECKED),\n+                   ArrayCreationInvoker.dynamicEnumerated0S_N());\n+    }\n+\n+    private static void checkArray(Class<?> comp, int mods, List<?> expected, Object... actual) {\n+        for (Object o : actual) {\n+            if (!(o.getClass().isArray()) ||\n+                !o.getClass().getComponentType().equals(comp) ||\n+                \/\/ TODO: check modifiers once implemented\n+                !arrayToList(o).equals(expected)) {\n+                throw new AssertionError(\"Unexpected result: %s, expected %s\".formatted(\n+                                        arrayString(o), arrayString(comp, mods, expected)));\n+            }\n+        }\n+    }\n+\n+    private static List<?> arrayToList(Object arr) {\n+        return switch (arr) {\n+            case Object[] a -> Arrays.asList(a);\n+            case int[] a -> IntStream.range(0, a.length).mapToObj(i -> a[i]).toList();\n+            case long[] a -> IntStream.range(0, a.length).mapToObj(i -> a[i]).toList();\n+            case float[] a -> IntStream.range(0, a.length).mapToObj(i -> a[i]).toList();\n+            case double[] a -> IntStream.range(0, a.length).mapToObj(i -> a[i]).toList();\n+            case byte[] a -> IntStream.range(0, a.length).mapToObj(i -> a[i]).toList();\n+            case short[] a -> IntStream.range(0, a.length).mapToObj(i -> a[i]).toList();\n+            case char[] a -> IntStream.range(0, a.length).mapToObj(i -> a[i]).toList();\n+            case boolean[] a -> IntStream.range(0, a.length).mapToObj(i -> a[i]).toList();\n+            default -> throw new AssertionError();\n+        };\n+    }\n+\n+    private static String arrayString(Object o) {\n+        if (o.getClass().isArray()) {\n+            var comp = o.getClass().getComponentType();\n+            var mods = 0; \/\/ TODO\n+            return arrayString(comp, mods, arrayToList(o));\n+        } else {\n+            return \"object \" + o.toString();\n+        }\n+    }\n+\n+    private static String arrayString(Class<?> comp, int mods, List<?> contents) {\n+        return \"%s:%04x%s\".formatted(comp.getName(), mods, contents);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/ArrayCreationTest.java","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -138,0 +138,11 @@\n+\n+        assertEqualsDeep(\n+                MethodSignature.of(\n+                        List.of(),\n+                        List.of(),\n+                        BaseTypeSig.of('V'),\n+                        TypeVarSig.of(\"E\").nullChecked(),\n+                        ArrayTypeSig.of(BaseTypeSig.of('I')).nullChecked(),\n+                        ClassTypeSig.of(\"Generic\", TypeArg.unbounded()).nullChecked()),\n+                MethodSignature.parseFrom(\"(!TE;![I!LGeneric<*>;)V\")\n+        );\n@@ -156,0 +167,24 @@\n+    @Test\n+    void testBangRestrictions() {\n+        var plainClass = ClassTypeSig.of(CD_Class);\n+        var bangClass = plainClass.nullChecked();\n+        \/\/ class superclass\n+        assertThrows(IllegalArgumentException.class, () -> ClassSignature.of(bangClass));\n+        \/\/ class interfaces\n+        assertThrows(IllegalArgumentException.class, () -> ClassSignature.of(plainClass, bangClass));\n+        \/\/ method throws\n+        assertThrows(IllegalArgumentException.class, () -> MethodSignature.of(List.of(), List.of(bangClass), BaseTypeSig.of('V')));\n+        \/\/ type arg bounds\n+        assertThrows(IllegalArgumentException.class, () -> TypeArg.of(bangClass));\n+        assertThrows(IllegalArgumentException.class, () -> TypeArg.superOf(bangClass));\n+        assertThrows(IllegalArgumentException.class, () -> TypeArg.extendsOf(bangClass));\n+        \/\/ type param superclass\n+        assertThrows(IllegalArgumentException.class, () -> TypeParam.of(\"T\", bangClass));\n+        \/\/ type param interfaces\n+        assertThrows(IllegalArgumentException.class, () -> TypeParam.of(\"T\", Optional.empty(), bangClass));\n+        \/\/ array component\n+        assertThrows(IllegalArgumentException.class, () -> ArrayTypeSig.of(bangClass));\n+        \/\/ outer class\/enclosing instance\n+        assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(bangClass, \"Nested\"));\n+    }\n+\n@@ -313,0 +348,6 @@\n+                !I\n+                [!Ljava\/lang\/Class;\n+                ![!Ljava\/lang\/Class;\n+                !Ljava\/util\/Optional<!Ljava\/lang\/Integer;>;\n+                Ljava\/util\/Optional<+!Ljava\/lang\/Integer;>;\n+                Ljava\/util\/Optional<-!Ljava\/lang\/Integer;>;\n@@ -329,0 +370,5 @@\n+                ![B\n+                ![[I\n+                !Ljava\/lang\/Class<*>;\n+                !Ljava\/lang\/String;\n+                !TT;\n@@ -363,0 +409,3 @@\n+                !Ljava\/lang\/Object;\n+                Ljava\/lang\/Object;!Ljava\/lang\/Runnable;\n+                <T:!Ljava\/lang\/Number;>Ljava\/lang\/Object;\n@@ -395,0 +444,4 @@\n+                ()!I\n+                ()[!Ljava\/lang\/Object;\n+                ()V^!Ljava\/lang\/Throwable;\n+                <T::!Ljava\/lang\/Runnable;>()V\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -62,2 +61,1 @@\n-        @NullRestricted\n-        One one = new One(5, (short) 3);\n+        One! one = new One(5, (short) 3);\n","filename":"test\/jdk\/valhalla\/valuetypes\/LayoutIterationTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -62,4 +61,4 @@\n-        @NullRestricted  @Strict\n-        Point p1;\n-        @NullRestricted  @Strict\n-        Point p2;\n+        @Strict\n+        Point! p1;\n+        @Strict\n+        Point! p2;\n@@ -74,2 +73,2 @@\n-        @NullRestricted  @Strict\n-        Point p;\n+        @Strict\n+        Point! p;\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodHandleTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -57,2 +56,2 @@\n-        @NullRestricted  @Strict\n-        EmptyValue empty;\n+        @Strict\n+        EmptyValue! empty;\n@@ -71,4 +70,10 @@\n-        @NullRestricted  @Strict\n-        EmptyValue empty = new EmptyValue();\n-        @NullRestricted  @Strict\n-        volatile EmptyValue vempty = new EmptyValue();\n+        @Strict\n+        EmptyValue! empty;\n+        @Strict\n+        volatile EmptyValue! vempty;\n+\n+        Mutable() {\n+            empty = new EmptyValue();\n+            vempty = new EmptyValue();\n+            super();\n+        }\n","filename":"test\/jdk\/valhalla\/valuetypes\/NullRestrictedTest.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n@@ -63,4 +62,4 @@\n-        @NullRestricted  @Strict\n-        Point p1;\n-        @NullRestricted  @Strict\n-        Point p2;\n+        @Strict\n+        Point! p1;\n+        @Strict\n+        Point! p2;\n@@ -75,2 +74,2 @@\n-        @NullRestricted  @Strict\n-        Point p;\n+        @Strict\n+        Point! p;\n@@ -85,4 +84,4 @@\n-        @NullRestricted  @Strict\n-        Point p;\n-        @NullRestricted  @Strict\n-        Line l;\n+        @Strict\n+        Point! p;\n+        @Strict\n+        Line! l;\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueObjectMethodsTest.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -241,4 +241,2 @@\n-        checkOutput(\"pkg\/PrivateParent.html\", false,\n-                \"\"\"\n-                    <div class=\"type-signature\"><span class=\"modifiers\"> class <\/span><span class=\"el\\\n-                    ement-name type-name-label\">PrivateParent<\/span>\"\"\");\n+        checkOutput(\"pkg\/PrivateParent.html\", true,\n+                \"<div class=\\\"type-signature\\\"><span class=\\\"modifiers\\\">class <\/span><span class=\\\"element-name type-name-label\\\">PrivateParent<\/span>\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPrivateClasses\/TestPrivateClasses.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.jshell.JShell;\n@@ -56,0 +57,1 @@\n+import org.junit.jupiter.api.TestInfo;\n@@ -593,2 +595,1 @@\n-    @Override\n-    public void setUp() {\n+    public void setUp(TestInfo info) {\n@@ -644,1 +645,1 @@\n-        setUp(b -> b\n+        setUp(b -> addExtraOptions(b, info)\n@@ -649,0 +650,10 @@\n+    protected JShell.Builder addExtraOptions(JShell.Builder b, TestInfo testInfo) {\n+        return switch (testInfo.getTestMethod().orElseThrow().getName()) {\n+            case \"nonNullVariables\" ->\n+                b.compilerOptions(\"--source\", System.getProperty(\"java.specification.version\"),\n+                                  \"--enable-preview\")\n+                 .remoteVMOptions(\"--enable-preview\");\n+            default -> b;\n+        };\n+    }\n+\n@@ -680,0 +691,13 @@\n+    @Test\n+    public void nonNullVariables() {\n+        assertEval(\"String! str1 = \\\"\\\";\", \"\\\"\\\"\");\n+        assertEval(\"str1 = \\\"\\\";\", \"\\\"\\\"\");\n+        assertEvalException(\"str1 = null;\");\n+        assertEvalException(\"String! str2 = null;\");\n+        assertEval(\"int[] count = new int[1];\");\n+        assertEval(\"String! str3 = String.valueOf(count[0]++);\");\n+        assertEval(\"count[0]\", \"1\");\n+        assertEval(\"String! fail() { throw new RuntimeException(); }\");\n+        assertEvalException(\"String! str4 = fail();\");\n+        assertEval(\"String[]! arr1 = new String[0];\", \"String[0] {  }\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/VariablesTest.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+\n@@ -227,0 +228,8 @@\n+\n+#nullable types\n+compiler.misc.feature.null.restricted.types\n+compiler.misc.attribute.must.be.unique                                   # bad class file\n+compiler.misc.attribute.not.applicable.to.field.type                     # bad class file\n+compiler.misc.attribute.only.applicable.to.fields                        # bad class file\n+compiler.warn.suspicious.nullness.conversion\n+compiler.err.restricted.array.missing.init\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.non.nullable.should.be.initialized\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class NonNullableShouldBeInitialized {\n+    NonNullableShouldBeInitialized! field;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NonNullableShouldBeInitialized.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ReturnBeforeSuperclassInit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.unsupported.null.restriction\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class UnsupportedNullRestriction {\n+    String![] s;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnsupportedNullRestriction.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+import java.io.UncheckedIOException;\n@@ -44,0 +45,4 @@\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+import java.util.Optional;\n@@ -197,0 +202,25 @@\n+    \/**\n+     * Parse, analyze, perform code generation for the sources associated with this task and finally\n+     * executes them\n+     *\/\n+    public void execute(Consumer<ExecutionTask> c) {\n+        generate(generationResult -> {\n+            try {\n+                if (generationResult.hasErrors()) {\n+                    \/\/ we have nothing else to do\n+                    throw new IllegalStateException(\"Cannot compile: \" + generationResult.compilationInfo());\n+                }\n+                Iterable<? extends JavaFileObject> jfoIterable = generationResult.get();\n+                java.util.List<URL> urlList = new ArrayList<>();\n+                for (JavaFileObject jfo : jfoIterable) {\n+                    String urlStr = jfo.toUri().toURL().toString();\n+                    urlStr = urlStr.substring(0, urlStr.length() - jfo.getName().length());\n+                    urlList.add(new URL(urlStr));\n+                }\n+                c.accept(new ExecutionTask(new URLClassLoader(urlList.toArray(new URL[urlList.size()]))));\n+            } catch (IOException ex) {\n+                throw new AssertionError(ex);\n+            }\n+        });\n+    }\n+\n@@ -234,1 +264,1 @@\n-        private Consumer<Throwable> handler;\n+        private Consumer<Throwable> handler = t -> { throw new AssertionError(t); };\n@@ -245,6 +275,1 @@\n-            Assert.check(className != null, \"class name value is null, impossible to proceed\");\n-            try {\n-                c = classLoader.loadClass(className);\n-            } catch (Throwable t) {\n-                throw new IllegalStateException(t);\n-            }\n+            this.c = load(className);\n@@ -279,0 +304,9 @@\n+\n+        public Class<?> load(String className) {\n+            Assert.check(className != null, \"class name value is null, impossible to proceed\");\n+            try {\n+                return classLoader.loadClass(className);\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(t);\n+            }\n+        }\n","filename":"test\/langtools\/tools\/javac\/lib\/combo\/ComboTask.java","additions":41,"deletions":7,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for array creation API\n+ * @library \/tools\/javac\/lib\n+ * @enablePreview\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build combo.ComboTestHelper\n+ * @run main ArrayCreationRuntimeTest\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask.ExecutionTask;\n+import combo.ComboTestHelper;\n+\n+import javax.lang.model.SourceVersion;\n+import java.util.List;\n+\n+public class ArrayCreationRuntimeTest extends ComboInstance<ArrayCreationRuntimeTest> {\n+\n+    enum ArrayInitKind implements ComboParameter {\n+        INIT_1_0(\"[] { }\"),\n+        INIT_1_1(\"[] { \\\"a\\\" }\"),\n+        INIT_1_2(\"[] { \\\"a\\\", \\\"b\\\" }\"),\n+        INIT_2_0(\"[] { }\"),\n+        INIT_2_0_0(\"[][] { { }, { } }\"),\n+        INIT_2_0_1_0(\"[][] { { }, { \\\"a\\\" }, { } }\"),\n+        INIT_2_1_2(\"[][] { { \\\"a\\\" }, { \\\"b\\\", \\\"c\\\" } }\");\n+\n+        final String initString;\n+\n+        ArrayInitKind(String typeString) {\n+            this.initString = typeString;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return initString;\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<ArrayCreationRuntimeTest>()\n+                .withDimension(\"INIT\", (x, tk) -> x.aik = tk, ArrayInitKind.values())\n+                .run(ArrayCreationRuntimeTest::new);\n+    }\n+\n+    ArrayInitKind aik;\n+\n+    static final String TEMPLATE = \"\"\"\n+            import java.util.Arrays;\n+\n+            public class Test {\n+\n+                static {\n+                    test(new String!#{INIT}, new String#{INIT});\n+                }\n+\n+                {\n+                    test(new String!#{INIT}, new String#{INIT});\n+                }\n+\n+                static void m() {\n+                    test(new String!#{INIT}, new String#{INIT});\n+                }\n+\n+                void g() {\n+                    test(new String!#{INIT}, new String#{INIT});\n+                }\n+\n+                static void test(Object[] found, Object[] expected) {\n+                System.out.println(found);\n+                    if (!Arrays.deepToString(found).equals(Arrays.deepToString(expected))) {\n+                        throw new AssertionError(\"bad array comparison \" +\n+                            \"found: \" + Arrays.deepToString(found) + \" - expected: \" + Arrays.deepToString(expected));\n+                    }\n+                }\n+\n+                public static void main(String[] args) {\n+                    Test.m();\n+                    new Test().g();\n+                }\n+            }\n+            \"\"\";\n+\n+    @Override\n+    public void doWork() {\n+        String latestVersion = String.valueOf(SourceVersion.latestSupported().runtimeVersion().feature());\n+        newCompilationTask()\n+                .withOptions(List.of(\"--enable-preview\", \"--release\", latestVersion))\n+                .withSourceFromTemplate(TEMPLATE)\n+                .execute(this::check);\n+    }\n+\n+    void check(ExecutionTask executionTask) {\n+        executionTask.withClass(\"Test\").run();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/ArrayCreationRuntimeTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Smoke test for diagnostics for uninitialized non-nullable fields\n+ * @enablePreview\n+ * @compile\/fail\/ref=NonNullFieldInitTest.out -XDrawDiagnostics NonNullFieldInitTest.java\n+ *\/\n+\n+class NonNullFieldInitTest {\n+    static String! s;\n+\n+    static class WithInit {\n+        String! s;\n+\n+        WithInit() { }\n+    }\n+\n+    static class WithoutInit {\n+        String! s;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NonNullFieldInitTest.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+NonNullFieldInitTest.java:9:20: compiler.err.non.nullable.should.be.initialized\n+NonNullFieldInitTest.java:14:20: compiler.err.strict.field.not.have.been.initialized.before.super: s\n+NonNullFieldInitTest.java:18:17: compiler.err.non.nullable.should.be.initialized\n+- compiler.note.preview.filename: NonNullFieldInitTest.java, DEFAULT\n+- compiler.note.preview.recompile\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/nullability\/NonNullFieldInitTest.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Smoke test for null-restricted array creation type-checking\n+ * @enablePreview\n+ * @compile\/fail\/ref=NullRestrictedArrayCreationTest.out -XDrawDiagnostics NullRestrictedArrayCreationTest.java\n+ *\/\n+\n+public class NullRestrictedArrayCreationTest {\n+    void testSimple(int n) {\n+        var t1 = new String![10];             \/\/ Fail (no init, n > 0)\n+        var t2 = new String![0];              \/\/ Pass (no init, n == 0)\n+        var t3 = new String![] { \"x\", \"y\" };  \/\/ Pass (init)\n+        var t4 = new String![n];              \/\/ Fail (no init, n not constant)\n+    }\n+\n+    void testMulti(int n) {\n+        var t1 = new String![3][2];           \/\/ Fail (no init, innermost length > 0)\n+        var t2 = new String![3][0];           \/\/ Pass (no init, innermost length == 0)\n+        var t3 = new String![0][10];          \/\/ Pass (no init, outer length == 0, no array created)\n+        var t4 = new String![][] { {\"x\"} };   \/\/ Pass (init)\n+        var t5 = new String![10][];           \/\/ Pass (no init, no innermost length)\n+        var t6 = new String![2][][];          \/\/ Pass (no init, no innermost length)\n+        var t7 = new String![3][n];           \/\/ Fail (no init, innermost length not constant)\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictedArrayCreationTest.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+NullRestrictedArrayCreationTest.java:10:18: compiler.err.restricted.array.missing.init: java.lang.String\n+NullRestrictedArrayCreationTest.java:13:18: compiler.err.restricted.array.missing.init: java.lang.String\n+NullRestrictedArrayCreationTest.java:17:18: compiler.err.restricted.array.missing.init: java.lang.String\n+NullRestrictedArrayCreationTest.java:23:18: compiler.err.restricted.array.missing.init: java.lang.String\n+- compiler.note.preview.filename: NullRestrictedArrayCreationTest.java, DEFAULT\n+- compiler.note.preview.recompile\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictedArrayCreationTest.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338766\n+ * @summary [lw5] remove option enableNullRestrictedTypes and make null-restricted types a preview feature\n+ * @library \/tools\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main NullRestrictedAttrTest\n+ * @ignore support for the NullRestricted attribute is missing in javap, class library etc\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.classfile.ClassFile;\n+\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+\n+public class NullRestrictedAttrTest extends TestRunner {\n+    ToolBox tb = new ToolBox();\n+\n+    public NullRestrictedAttrTest() {\n+        super(System.err);\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws Exception {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new NullRestrictedAttrTest().runTests();\n+    }\n+\n+    @Test\n+    public void testLoadableDescField(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                value class V {\n+                    public implicit V();\n+                }\n+                class Test {\n+                    V! v1;\n+                    void m(V! v) {\n+                        v1 = v;\n+                    }\n+                }\n+                \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        new toolbox.JavacTask(tb)\n+                .options(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature()))\n+                .outdir(classes)\n+                .files(findJavaFiles(src))\n+                .run()\n+                .writeAll();\n+        Path classFilePath = classes.resolve(\"Test.class\");\n+        ClassFile classFile = ClassFile.read(classFilePath.toFile());\n+        Assert.check(classFile.minor_version == 65535);\n+        Assert.check(classFile.attributes.get(\"NullRestricted\") != null);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictedAttrTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @enablePreview\n+ * @summary smoke test for negative parser test for null restrictions\n+ * @compile\/fail\/ref=NullRestrictionNegParserTest.out -XDrawDiagnostics NullRestrictionNegParserTest.java\n+ *\/\n+\n+class NullRestrictionNegParserTest {\n+    static class Foo extends Bar! { } \/\/ not valid, superclass\n+    static class Foo implements Bar! { } \/\/ not valid, superinterface\n+\n+    class Foo<X extends String!> { } \/\/ not valid, type-param bound\n+    <X extends String!> void foo() { } \/\/ not valid, type-param bound\n+\n+    void foo() throws Error! { } \/\/ not valid, throws type\n+\n+    void testNew() {\n+        new Foo!(); \/\/ bad, class creation expression\n+    }\n+\n+    void testNewArray() {\n+        var z = new Foo![2]; \/\/ ok\n+        var y = new Foo![2]!; \/\/ bad, bang can't appear at the end\n+        var x = new Foo![2][][][]!; \/\/ bad, bang can't appear at the end\n+        var x = new Foo![2][]![][]!; \/\/ bad, bang can't appear in the middle or at the end\n+        var x = new Foo![2][1][1][1]!; \/\/ bad, bang can't appear at the end\n+        var x = new Foo![2][1]![1][1]!; \/\/ bad, bang can't appear at the end\n+        var x = new Bar!.Foo![2][1]![1][1]!; \/\/ bad, bang can't appear at the end, and bad qualifier\n+    }\n+\n+    void testNewArrayWithInit() {\n+        var z = new Foo![] { null }; \/\/ ok\n+        var y = new Foo![]! { null }; \/\/ bad, bang can't appear at the end\n+        var x = new Foo![]![] { null }; \/\/ bad, bang can't appear in the middle\n+        var x = new Foo![]![]! { null }; \/\/ bad, bang can't appear in the middle or at the end\n+    }\n+\n+    void testNoBangInQualifiedTypeNames() {\n+        a!.x x = \"\"; \/\/ bad, bang before '.'\n+        a!.b!.x x = \"\"; \/\/ bad, bang before '.'\n+        a!.m(); \/\/ bad, bang before '.'\n+        a.b!.m(); \/\/ bad, bang before '.'\n+    }\n+\n+    void testNoBangInMrefQualifier() {\n+        Runnable r = Foo!<String>::m;\n+        Runnable r = Foo<String!>::m;\n+        Runnable r = Foo<String>!::m;\n+        Runnable r = Foo<String>![]::m;\n+        Runnable r = Foo<String>![]!::m;\n+        Runnable r = Foo<String>.Foo!<Integer>::m;\n+        Runnable r = Foo<String>.Foo<Integer!>::m;\n+        Runnable r = Foo<String>.Foo<Integer>!::m;\n+        Runnable r = Foo<String>.Foo!<Integer>::m;\n+        Runnable r = Foo<String>.Foo<Integer!>::m;\n+        Runnable r = Foo<String>.Foo<Integer>![]::m;\n+        Runnable r = Foo<String>.Foo<Integer>![]!::m;\n+    }\n+\n+    void testInnerClassCreator() {\n+        encl.new Foo!();\n+        encl.new Foo<String!>();\n+        encl.new Foo<String>!();\n+    }\n+\n+    void testQualifiedType() {\n+        A<String>!.B<Integer> a;\n+        A!<String>.B<Integer> a;\n+        A<String>.B!<Integer> a;\n+        A<String>.B<Integer!> a;\n+        A<String!>.B<Integer> a;\n+    }\n+\n+    static class TestConstructor {\n+        TestConstructor!() { } \/\/ bad, no bang in constructor type\n+    }\n+\n+    void testVarargs(Foo!... args) { \/\/ bad, bangs and varargs\n+        Foo foo = (A a, B!... bs) -> { }; \/\/ bad, bangs and varargs\n+        record R(A a, B!... bs) { } \/\/ bad, bangs and varargs\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictionNegParserTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+NullRestrictionNegParserTest.java:9:33: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:10:36: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:12:31: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:13:22: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:15:28: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:18:16: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:23:28: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:24:34: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:25:30: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:25:35: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:26:37: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:27:31: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:27:38: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:28:24: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:28:36: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:28:43: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:33:27: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:34:27: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:35:27: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:35:30: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:39:10: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:40:10: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:40:13: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:41:10: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:42:12: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:46:25: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:47:32: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:48:33: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:49:33: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:50:33: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:50:36: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:51:37: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:52:45: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:53:46: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:54:37: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:55:45: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:56:46: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:57:46: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:57:49: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:61:21: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:62:28: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:63:29: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:67:18: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:68:10: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:69:20: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:70:28: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:71:17: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:75:24: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:78:26: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:79:27: compiler.err.unsupported.null.restriction\n+NullRestrictionNegParserTest.java:80:25: compiler.err.unsupported.null.restriction\n+51 errors\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictionNegParserTest.out","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for null restriction parsing\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build combo.ComboTestHelper\n+\n+ * @run main NullRestrictionParserTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask.Result;\n+import combo.ComboTestHelper;\n+\n+import javax.lang.model.SourceVersion;\n+import javax.tools.Diagnostic.Kind;\n+\n+public class NullRestrictionParserTest extends ComboInstance<NullRestrictionParserTest> {\n+\n+    enum AnnoKind implements ComboParameter {\n+        ANNO(\"@A \"),\n+        NO_ANNO(\"\");\n+\n+        final String annoTemplate;\n+\n+        AnnoKind(String annoTemplate) {\n+            this.annoTemplate = annoTemplate;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return annoTemplate;\n+        }\n+    }\n+\n+    enum TypeKind implements ComboParameter {\n+        STRING(\"#{ANNO}String\", 0),\n+        NN_STRING(\"#{ANNO}String!\", 0),\n+        STRING_ARR(\"#{ANNO}String[]\", 0),\n+        STRING_NN_ARR(\"#{ANNO}String[]!\", 0),\n+        NN_STRING_ARR(\"#{ANNO}String![]\", 1),\n+        NN_STRING_NN_ARR(\"#{ANNO}String![]!\", 1),\n+        STRING_ARR_ARR(\"#{ANNO}String[][]\", 0),\n+        STRING_NN_ARR_ARR(\"#{ANNO}String[]![]\", 1),\n+        STRING_NN_ARR_NN_ARR(\"#{ANNO}String[]![]!\", 1),\n+        NN_STRING_ARR_ARR(\"#{ANNO}String![]!\", 1),\n+        NN_STRING_NN_ARR_ARR(\"#{ANNO}String![]![]\", 2),\n+        NN_STRING_NN_ARR_NN_ARR(\"#{ANNO}String![]![]!\", 2),\n+        NN_LIST_STRING(\"#{ANNO}List<String>!\", 0),\n+        NN_LIST_STRING_BAD_POS(\"#{ANNO}List!<#{ANNO}String>\", 1),\n+        LIST_NN_STRING(\"#{ANNO}List<#{ANNO}String!>\", 1);\n+        \/\/NN_LIST_STRING_ARR(\"#{ANNO}List<#{ANNO}String>[]!\", 0); \/\/ this doesn't work because of an issue (see JDK-8374629)\n+\n+\n+        final String typeTemplate;\n+        final int errors;\n+\n+        TypeKind(String typeTemplate, int errors) {\n+            this.typeTemplate = typeTemplate;\n+            this.errors = errors;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return typeTemplate;\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<NullRestrictionParserTest>()\n+                .withDimension(\"ANNO\", (x, ak) -> x.ak = ak, AnnoKind.values())\n+                .withDimension(\"TYPE\", (x, tk) -> x.tk = tk, TypeKind.values())\n+                .run(NullRestrictionParserTest::new);\n+    }\n+\n+    AnnoKind ak;\n+    TypeKind tk;\n+\n+    static final String TEMPLATE = \"\"\"\n+            import java.lang.annotation.ElementType;\n+            import java.lang.annotation.Target;\n+            import java.util.List;\n+\n+            class Test {\n+\n+                @Target(ElementType.TYPE_USE)\n+                @interface A {}\n+\n+                #{TYPE} restype() { throw new AssertionError(); }\n+                void argtype(#{TYPE} arg) { throw new AssertionError(); }\n+                void final_argtype(final #{TYPE} arg) { throw new AssertionError(); }\n+\n+                #{TYPE} field;\n+\n+                void testRecord() {\n+                    record R(#{TYPE} c) { }\n+                }\n+\n+                void testLocal() {\n+                    #{TYPE} local;\n+                    final #{TYPE} local;\n+                }\n+\n+                void testCast(Object o) {\n+                    var x = (#{TYPE})o;\n+                }\n+\n+                void testIntersectionCast(Object o) {\n+                    var x = (#{TYPE} & #{TYPE})o;\n+                }\n+\n+                void testInstanceof(Object o) {\n+                    var x = o instanceof #{TYPE};\n+                    var x = o instanceof #{TYPE} p;\n+                }\n+\n+                void testSwitch(Object o) {\n+                    switch (o) {\n+                        case #{TYPE} p -> { }\n+                        default -> { }\n+                    };\n+                }\n+\n+                void testCatch() {\n+                    try {\n+                        foo();\n+                    } catch (#{TYPE} t) { }\n+                }\n+\n+                void testMultiCatch() {\n+                    try {\n+                        foo();\n+                    } catch (#{TYPE} | #{TYPE} t) { }\n+                }\n+            }\n+            \"\"\";\n+\n+    static final int num_types;\n+\n+    static {\n+        int occurrences = 0;\n+        int start = -1;\n+        while (start + 1 < TEMPLATE.length() && (start = TEMPLATE.indexOf(\"#{TYPE}\", start + 1)) != -1) {\n+            occurrences++;\n+        }\n+        num_types = occurrences;\n+    }\n+\n+    @Override\n+    public void doWork() throws IOException {\n+        String latestVersion = String.valueOf(SourceVersion.latestSupported().runtimeVersion().feature());\n+        newCompilationTask()\n+                .withOptions(List.of(\"--enable-preview\", \"--release\", latestVersion))\n+                .withSourceFromTemplate(TEMPLATE)\n+                .parse(this::check);\n+    }\n+\n+    void check(Result<?> res) {\n+        int expectedErrors = tk.errors * num_types;\n+\n+        var errors = res.diagnosticsForKey(\"compiler.err.unsupported.null.restriction\");\n+\n+        var otherErrors = res.diagnosticsForKind(Kind.ERROR).size() - errors.length();\n+\n+        if (expectedErrors != errors.length() || otherErrors > 0) {\n+            fail(\"invalid diagnostics for source:\\n\" +\n+                    res.compilationInfo() +\n+                    \"\\nFound error: \" + errors +\n+                    \"\\nExpected error: \" + expectedErrors);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictionParserTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for null restriction parsing\n+ * @library \/tools\/javac\/lib\n+ * @enablePreview\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build combo.ComboTestHelper\n+\n+ * @run main NullRestrictionReflectiveTest\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask.ExecutionTask;\n+import combo.ComboTestHelper;\n+\n+import javax.lang.model.SourceVersion;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+public class NullRestrictionReflectiveTest extends ComboInstance<NullRestrictionReflectiveTest> {\n+\n+    enum TypeKind implements ComboParameter {\n+        NN_STRING(\"java.lang.String!\"),\n+        NN_STRING_ARR(\"java.lang.String[]!\"),\n+        NN_STRING_ARR_ARR(\"java.lang.String[][]!\"),\n+        NN_LIST_STRING(\"java.util.List<java.lang.String>!\"),\n+        NN_TVAR(\"X!\"),\n+        NN_TVAR_ARR(\"X[]!\"),\n+        NN_TVAR_ARR_ARR(\"X[][]!\"),\n+        NN_LIST_TVAR(\"java.util.List<X>!\");\n+\n+        final String typeString;\n+\n+        TypeKind(String typeString) {\n+            this.typeString = typeString;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return typeString;\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<NullRestrictionReflectiveTest>()\n+                .withDimension(\"TYPE\", (x, tk) -> x.tk = tk, TypeKind.values())\n+                .run(NullRestrictionReflectiveTest::new);\n+    }\n+\n+    TypeKind tk;\n+\n+    static final String TEMPLATE = \"\"\"\n+            import java.util.List;\n+\n+            class Test<X> {\n+\n+                static <Z> Z init() { return null; }\n+\n+                #{TYPE} fld = init();\n+\n+                #{TYPE} meth(#{TYPE} arg) {\n+                    return init();\n+                }\n+            }\n+            \"\"\";\n+\n+    @Override\n+    public void doWork() throws IOException {\n+        String latestVersion = String.valueOf(SourceVersion.latestSupported().runtimeVersion().feature());\n+        newCompilationTask()\n+                .withOptions(List.of(\"--enable-preview\", \"--release\", latestVersion))\n+                .withSourceFromTemplate(TEMPLATE)\n+                .execute(this::check);\n+    }\n+\n+    void check(ExecutionTask executionTask) {\n+        try {\n+            Class<?> testClass = executionTask.load(\"Test\");\n+\n+            \/\/ check field type\n+            Field testField = testClass.getDeclaredField(\"fld\");\n+            checkType(testField.getGenericType());\n+\n+            \/\/ check method arguments and return type\n+            Method testMethod = testClass.getDeclaredMethod(\"meth\", testField.getType());\n+            checkType(testMethod.getGenericReturnType());\n+            checkType(testMethod.getGenericParameterTypes()[0]);\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    void checkType(Type type) {\n+        if (!type.getTypeName().equals(tk.typeString)) {\n+            fail(\"Type mismatch detected:\\n\" +\n+                    \"\\nFound type: \" + type.getTypeName() +\n+                    \"\\nExpected error: \" + tk.typeString);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictionReflectiveTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,692 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * NullabilityCompilationTests\n+ *\n+ * @test\n+ * @bug 8339357 8340027\n+ * @enablePreview\n+ * @summary compilation tests for bang types\n+ * @library \/lib\/combo \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @run junit NullabilityCompilationTests\n+ *\/\n+\n+import java.io.File;\n+import java.util.function.Consumer;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.tools.Diagnostic;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.reflect.AccessFlag;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.util.Assert;\n+\n+import org.junit.jupiter.api.Test;\n+import tools.javac.combo.CompilationTestCase;\n+\n+public class NullabilityCompilationTests extends CompilationTestCase {\n+    private static String[] PREVIEW_OPTIONS = {\n+            \"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())};\n+    private static String[] PREVIEW_PLUS_LINT_OPTIONS = {\n+            \"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature()),\n+            \"-Xlint:null\" };\n+\n+    public NullabilityCompilationTests() {\n+        setDefaultFilename(\"Test.java\");\n+    }\n+\n+    enum TestResult {\n+        COMPILE_OK,\n+        COMPILE_WITH_WARNING,\n+        ERROR\n+    }\n+\n+    void testHelper(String[] compilerOptions, String code) {\n+        testHelper(compilerOptions, \"\", 1, TestResult.COMPILE_OK, code, null);\n+    }\n+\n+    void testHelper(String[] compilerOptions, String code, Consumer<Diagnostic<?>> diagConsumer) {\n+        testHelper(compilerOptions, \"\", 1, TestResult.COMPILE_OK, code, diagConsumer);\n+    }\n+\n+    void testHelper(String[] compilerOptions, String diagsMessage, int diagsCount, TestResult testResult, String code,\n+                    Consumer<Diagnostic<?>> diagConsumer) {\n+        setCompileOptions(compilerOptions);\n+        try {\n+            if (testResult != TestResult.COMPILE_OK) {\n+                if (testResult == TestResult.COMPILE_WITH_WARNING) {\n+                    assertOKWithWarning(diagsMessage, diagsCount, code);\n+                } else {\n+                    assertFail(diagsMessage, code);\n+                }\n+            } else {\n+                if (diagConsumer == null) {\n+                    assertOK(code);\n+                } else {\n+                    assertOK(diagConsumer, code);\n+                }\n+            }\n+        } catch (Throwable t) {\n+            System.err.println(\"error while compiling code:\\n\" + code);\n+            throw t;\n+        }\n+    }\n+\n+    void testList(List<DiagAndCode> testList) {\n+        for (DiagAndCode diagAndCode : testList) {\n+            if (diagAndCode.result == Result.Clean) {\n+                testHelper(PREVIEW_PLUS_LINT_OPTIONS, diagAndCode.code);\n+            } else if (diagAndCode.result == Result.Warning) {\n+                testHelper(PREVIEW_PLUS_LINT_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.COMPILE_WITH_WARNING, diagAndCode.code, null);\n+                testHelper(PREVIEW_OPTIONS, diagAndCode.code,\n+                        d -> {\n+                            if (d.getKind() == Diagnostic.Kind.WARNING) {\n+                                \/\/ shouldn't issue any warnings if the -Xlint:null option is not passed\n+                                throw new AssertionError(\"unexpected warning for \" + diagAndCode.code);\n+                            }\n+                        });\n+            } else {\n+                testHelper(PREVIEW_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.ERROR, diagAndCode.code, null);\n+            }\n+            if (diagAndCode.result != Result.Error) {\n+                testHelper(PREVIEW_OPTIONS, diagAndCode.code);\n+            } else {\n+                testHelper(PREVIEW_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.ERROR, diagAndCode.code, null);\n+            }\n+        }\n+    }\n+\n+    enum Result { Warning, Error, Clean}\n+\n+    record DiagAndCode(String code, Result result, String diag, int diagsCount) {\n+        DiagAndCode(String code, Result result, String diag) {\n+            this(code, result, diag, 1);\n+        }\n+    }\n+\n+\n+    @Test\n+    void testErrorUninitialized() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { }\n+                                class Foo {\n+                                    Point! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    Foo! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { }\n+                                class Foo {\n+                                    Point[]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    Foo[]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { }\n+                                class Foo {\n+                                    Point[]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { }\n+                                class Foo {\n+                                    Point[][]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    Foo[][]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\")\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void testSuspiciousNullnessConversions () {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m() {\n+                                        String! s = null;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.suspicious.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m() {\n+                                        String[]! s = null;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.suspicious.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m() {\n+                                        String! s = (String!)null;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.suspicious.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m() {\n+                                        String[]! s = (String[]!)null;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.suspicious.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m() {\n+                                        g(null);\n+                                    }\n+                                    void g(String! s) { }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.suspicious.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m() {\n+                                        g(null);\n+                                    }\n+                                    void g(String[]! s) { }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.suspicious.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    String! m() {\n+                                        return null;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.suspicious.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    String[]! m() {\n+                                        return null;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.suspicious.nullness.conversion\",\n+                                1)\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void testNoWarnings() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class C<T> {\n+                                    T x = null;\n+                                    void set(T arg) { x = arg; }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test<T> {\n+                                    T field;\n+                                    void foo(T t) {\n+                                        field = t;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        \/\/ we are testing that the compiler won't infer the arguments of\n+                                        \/\/ VarHandle::setVolatile as (Cell, String!)\n+                                        VALUE.setVolatile(this, \"\");\n+                                    }\n+                                    final void reset(String identity) {\n+                                        \/\/ if that were the case, see comment above, then this invocation would generate\n+                                        \/\/ a warning, VarHandle::setVolatile is a polymorphic signature method\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+\n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        VALUE.setVolatile(this, 0L);\n+                                    }\n+                                    final void reset(long identity) {\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+\n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    void test1() {\n+                                        String[][] arr_local = null;\n+                                        arr_local = new String[3][4];\n+                                        arr_local = new String![][] { { \"\" } };\n+                                    }\n+\n+                                    void test2() {\n+                                        String[][]! arr_local = new String[0][0];\n+                                        arr_local = new String[3][4];\n+                                        arr_local = new String![][] { { \"\" } };\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Test {\n+                                    void m(Test t1, Test[] t2, Test[][] t3, Test[][][] t4) {\n+                                        Test! l1 = (Test!) t1;\n+                                        Test[]! l2 = (Test[]!) t2;\n+                                        Test[][]! l3 = (Test[][]!) t3;\n+                                        Test[][][]! l4 = (Test[][][]!) t4;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    void test() {\n+                                        String! s_nonnull = \"\";\n+                                        String s = null;\n+                                        s = s_nonnull;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    void test(Box b) {\n+                                        switch (b) {\n+                                            case Box(String! nonNull) -> {}\n+                                            case Box(String isNull) -> {}\n+                                        }\n+                                    }\n+                                    record Box(String str) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    void test(Box b) {\n+                                        switch (b) {\n+                                            case Box(String! nonNull) -> {}\n+                                            case Box(var v) -> {}\n+                                        }\n+                                    }\n+                                    record Box(String str) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    void test(Box b) {\n+                                        switch (b) {\n+                                            case Box(String! nonNull) -> {}\n+                                            case Box(_) -> {}\n+                                        }\n+                                    }\n+                                    record Box(String str) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                String! str = \"\";\n+                                void main() {\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                String! test() {\n+                                    return \"\";\n+                                }\n+                                void main() {\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void testNonNullableFieldsAreStrict() throws Exception {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o;\n+                                    Test() {\n+                                        super();\n+                                        o = new Object();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.strict.field.not.have.been.initialized.before.super\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o;\n+                                    Test() {\n+                                        o = new Object();\n+                                        super();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o = new Object();\n+                                    Test() {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o = new Object();\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        \/\/ static fields\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static Object! o;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static Object! o = new Object();\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static Object! o;\n+                                    static {\n+                                        o = new Object();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n+                )\n+        );\n+\n+        for (String source : List.of(\n+                \"\"\"\n+                class Test {\n+                    Object! o = new Object();\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static Object! o = new Object();\n+                }\n+                \"\"\"\n+        )) {\n+            File dir = assertOK(true, source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                for (var field : classFile.fields()) {\n+                    if (!field.flags().has(AccessFlag.STATIC)) {\n+                        Set<AccessFlag> fieldFlags = field.flags().flags();\n+                        Assert.check(fieldFlags.size() == 1 && fieldFlags.contains(AccessFlag.STRICT_INIT));\n+                    } else {\n+                        Set<AccessFlag> fieldFlags = field.flags().flags();\n+                        Assert.check(fieldFlags.size() == 2 && fieldFlags.contains(AccessFlag.STRICT_INIT) && fieldFlags.contains(AccessFlag.STATIC));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testPatternDominance() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    void test(Box b) {\n+                                        switch (b) {\n+                                            case Box(String nullAllowed) -> {}\n+                                            case Box(String! notNull) -> {}\n+                                        }\n+                                    }\n+                                    record Box(String str) {}\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.pattern.dominated\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    void test(Box b) {\n+                                        switch (b) {\n+                                            case Box(var v) -> {}\n+                                            case Box(String! notNull) -> {}\n+                                        }\n+                                    }\n+                                    record Box(String str) {}\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.pattern.dominated\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    void test(Box b) {\n+                                        switch (b) {\n+                                            case Box(_) -> {}\n+                                            case Box(String! notNull) -> {}\n+                                        }\n+                                    }\n+                                    record Box(String str) {}\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.pattern.dominated\")\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void testPatternExhaustiveness() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    void test(Box b) {\n+                                        switch (b) {\n+                                            case Box(String! notNull) -> {}\n+                                        }\n+                                    }\n+                                    record Box(String str) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\") \/\/is exhaustive\n+                )\n+        );\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityCompilationTests.java","additions":692,"deletions":0,"binary":false,"changes":692,"status":"added"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338910 8347754\n+ * @summary [lw5] enhance the Signature attribute to represent nullability\n+ * @enablePreview\n+ * @library \/lib\/combo \/tools\/lib\n+ * @modules\n+ *     jdk.compiler\/com.sun.tools.javac.util\n+ *     jdk.compiler\/com.sun.tools.javac.api\n+ *     jdk.compiler\/com.sun.tools.javac.main\n+ *     jdk.compiler\/com.sun.tools.javac.code\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run junit NullabilitySignatureAttrTests\n+ *\/\n+\n+import java.io.File;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import com.sun.tools.javac.util.Assert;\n+\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Opcode;\n+\n+import org.junit.jupiter.api.Test;\n+import tools.javac.combo.CompilationTestCase;\n+\n+import toolbox.*;\n+import toolbox.Task.*;\n+\n+public class NullabilitySignatureAttrTests extends CompilationTestCase {\n+    ToolBox tb = new ToolBox();\n+\n+    private static String[] PREVIEW_OPTIONS = {\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())};\n+\n+    public NullabilitySignatureAttrTests() {\n+        setDefaultFilename(\"Nullable.java\");\n+        setCompileOptions(PREVIEW_OPTIONS);\n+    }\n+\n+    record SignatureData(String source, String expectedSignature) {}\n+\n+    final List<SignatureData> signatureDataList = List.of(\n+            new SignatureData( \/\/ case 0\n+                    \"\"\"\n+                    class Test {\n+                        String! t = \"\";\n+                    }\n+                    \"\"\",\n+                    \"!Ljava\/lang\/String;\"\n+            ),\n+            new SignatureData( \/\/ case 1\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Test {\n+                        List<Test>! t = new ArrayList<>();\n+                    }\n+                    \"\"\",\n+                    \"!Ljava\/util\/List<LTest;>;\"\n+            ),\n+            new SignatureData( \/\/ case 2\n+                    \"\"\"\n+                    class Test<T> {\n+                        T! t = (T)new Object();\n+                    }\n+                    \"\"\",\n+                    \"!TT;\"\n+            ),\n+            new SignatureData( \/\/ case 3\n+                    \"\"\"\n+                    class Test {\n+                        String[]! t = {\"\"};\n+                    }\n+                    \"\"\",\n+                    \"![Ljava\/lang\/String;\"\n+            ),\n+            new SignatureData( \/\/ case 4\n+                    \"\"\"\n+                    class Test {\n+                        String[][]! t = {{\"\"}};\n+                    }\n+                    \"\"\",\n+                    \"![[Ljava\/lang\/String;\"\n+            )\n+    );\n+\n+    @Test\n+    void testCheckFieldSignature() throws Exception {\n+        int testNo = 0;\n+        for (SignatureData sd : signatureDataList) {\n+            System.err.println(\"executing test at index \" + testNo++);\n+            File dir = assertOK(true, sd.source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                var field = classFile.fields().get(0);\n+                var sa = field.findAttribute(Attributes.signature()).orElseThrow();\n+                Assert.check(sa.signature().toString().equals(sd.expectedSignature));\n+            }\n+        }\n+    }\n+\n+    record SepCompilationData(String clientSrc, String serverSrc, List<String> sourceExpectedWarnings, List<String> sepCompExpectedWarnings) {}\n+    final List<SepCompilationData> sepCompilationDataList = List.of(\n+            new SepCompilationData(  \/\/ case 0\n+                    \"\"\"\n+                    class Client {\n+                        static Integer! a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        public static Integer! b = 4;\n+                    }\n+                    \"\"\",\n+                    List.of(\"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData( \/\/ case 1\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Client {\n+                        static List<String>! a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Server {\n+                        public static List<String>! b = new ArrayList<>();\n+                    }\n+                    \"\"\",\n+                    List.of(\"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData( \/\/ case 2\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Client {\n+                        static List<String>! a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Server {\n+                        public static List<String> b = new ArrayList<>();\n+                    }\n+                    \"\"\",\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData( \/\/ case 3\n+                    \"\"\"\n+                    class Client {\n+                        static Server.Inner! a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        static class Inner {}\n+                        public static Server.Inner b = new Server.Inner();\n+                    }\n+                    \"\"\",\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData( \/\/ case 4\n+                    \"\"\"\n+                    class Client {\n+                        static String[][]! a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        public static String[][] b;\n+                    }\n+                    \"\"\",\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData( \/\/ case 5\n+                    \"\"\"\n+                    import java.util.List;\n+                    class Client {\n+                        static List<? extends String>! a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    import java.util.List;\n+                    class Server {\n+                        public static List<? extends String> b;\n+                    }\n+                    \"\"\",\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            )\n+    );\n+\n+    @Test\n+    void testCheckSeparateComp() throws Exception {\n+        Path base = Paths.get(\".\");\n+        Path src = base.resolve(\"src\");\n+        tb.createDirectories(src);\n+        Path out = base.resolve(\"out\");\n+        tb.createDirectories(out);\n+        int testNo = 0;\n+        for (SepCompilationData scd : sepCompilationDataList) {\n+            System.err.println(\"executing test at index \" + testNo++);\n+            tb.writeJavaFiles(src, scd.serverSrc, scd.clientSrc);\n+            List<String> log = new JavacTask(tb)\n+                    .outdir(out)\n+                    .options(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature()),\n+                            \"-Xlint:null\", \"-XDrawDiagnostics\")\n+                    .files(tb.findJavaFiles(src))\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+            if (!scd.sourceExpectedWarnings.equals(log))\n+                throw new Exception(\"expected output not found: \" + log);\n+\n+            \/\/ now lets remove serverSrc's source and compile client's source using the class file version of serverSrc\n+            tb.deleteFiles(src.resolve(\"Server.java\"));\n+            log = new JavacTask(tb)\n+                    .outdir(out)\n+                    .options(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature()),\n+                            \"-Xlint:null\", \"-XDrawDiagnostics\", \"-cp\", \"out\")\n+                    .files(tb.findJavaFiles(src))\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+            if (!scd.sepCompExpectedWarnings.equals(log))\n+                throw new Exception(\"expected output not found: \" + log);\n+\n+            \/\/ let's remove all the files in preparation for the next test\n+            tb.deleteFiles(src.resolve(\"Client.java\"));\n+            tb.deleteFiles(out.resolve(\"Client.class\"));\n+            tb.deleteFiles(out.resolve(\"Server.class\"));\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilitySignatureAttrTests.java","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"},{"patch":"@@ -0,0 +1,769 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @summary test runtime null checks\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RuntimeNullChecks\n+ *\/\n+\n+import java.util.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavaTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+\n+public class RuntimeNullChecks extends TestRunner {\n+    ToolBox tb;\n+\n+    RuntimeNullChecks() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        RuntimeNullChecks t = new RuntimeNullChecks();\n+        t.runTests();\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testRuntimeChecks(Path base) throws Exception {\n+        int i = 0;\n+        for (String code: new String[] {\n+                \/\/ local variables\n+                \"\"\"\n+                import java.util.*;\n+                class Test {\n+                    public static void main(String... args) {\n+                        List<String> list = new ArrayList<>();\n+                        list.add(null);\n+                        for (String! s : list) {\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String! o = s; \/\/ NPE at runtime, variable initialization\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    void m(String someObject) {\n+                        String! x = \"foo\";\n+                        x = (String)someObject;\n+                    }\n+                    public static void main(String... args) {\n+                        new Test().m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String! o;\n+                        o = s; \/\/ NPE at runtime, assignment, it doesn't stress the same code path as the case above\n+                    }\n+                }\n+                \"\"\",\n+                \/*\"\"\"\n+                class Test { \/\/ should fail, needs to be fixed once we redo null-restricted array creation\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String[]! sr = new String![10];\n+                        sr[0] = s; \/\/ NPE at runtime, assignment\n+                    }\n+                }\n+                \"\"\",*\/\n+                \"\"\"\n+                class Test {\n+                    static String id(String! arg) { return arg; }\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = id(s); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \/*\"\"\"\n+                class Test {\n+                    static String id(int i, String!... arg) { return \"\"; }\n+                    public static void main(String... args) {\n+                        String s1 = null;\n+                        String s2 = \"\";\n+                        Object o = id(1, s1, s2); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static String id(int i, String!... arg) { return \"\"; }\n+                    public static void main(String... args) {\n+                        String s1 = \"\";\n+                        String s2 = null;\n+                        Object o = id(1, s1, s2); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",*\/\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = (String!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        Object s = null;\n+                        Object o = (String & Runnable!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            \/\/ as the outer is inserted after the fact, we are checking the outer class argument not `o`,\n+                            \/\/ need to fix this\n+                            MyPrivilegedAction(Object! o) {}\n+                            T run() {\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) {\n+                        return action.run();\n+                    }\n+                    boolean isSystemProperty(String key, String value, String def, Object o) {\n+                        return doPrivileged(\n+                            new Inner().new MyPrivilegedAction<Boolean>(o) {\n+                                @Override\n+                                public Boolean run() {\n+                                    return value.equals(System.getProperty(key, def));\n+                                }\n+                            });\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.isSystemProperty(\"1\", \"2\", \"3\", null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    String! m(String someObject) {\n+                        return (String)someObject;\n+                    }\n+                    public static void main(String... args) {\n+                        new Test().m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    String! m(String someObject) {\n+                        return someObject;\n+                    }\n+                    public static void main(String... args) {\n+                        new Test().m(null);\n+                    }\n+                }\n+                \"\"\"\n+        }) {\n+            System.err.println(\"executing test \" + i++);\n+            testHelper(base, code, true, NullPointerException.class);\n+        }\n+\n+        \/\/ enums are a bit special as the NPE happens inside a static initializer and ExceptionInInitializerError is thrown\n+        testHelper(base,\n+                \"\"\"\n+                class Test {\n+                    static Object s = null;\n+                    enum E {\n+                        A(s);\n+                        \/\/ same issue as with inner classes\n+                        E(Object! o) {}\n+                    }\n+                    public static void main(String... args) {\n+                        Test.E a = E.A;\n+                    }\n+                }\n+                \"\"\", true, ExceptionInInitializerError.class);\n+\n+        \/\/ similar test cases as above but without null markers, should trivially pass\n+        i = 0;\n+        for (String code: new String[] {\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String o = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String o;\n+                        o = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String[] sr = new String[10];\n+                        sr[0] = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static String id(String arg) { return arg; }\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = id(s);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = (String) s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(Object o) {}\n+                            T run() {\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) {\n+                        return action.run();\n+                    }\n+                    boolean isSystemProperty(String key, String value, String def, Object o) {\n+                        return doPrivileged(\n+                            new Inner().new MyPrivilegedAction<Boolean>(o) {\n+                                @Override\n+                                public Boolean run() {\n+                                    return value.equals(System.getProperty(key, def));\n+                                }\n+                            });\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.isSystemProperty(\"1\", \"2\", \"3\", null);\n+                    }\n+                }\n+                \"\"\"\n+        }) {\n+            System.err.println(\"executing test \" + i++);\n+            testHelper(base, code, false, null);\n+        }\n+    }\n+\n+    private static String[] PREVIEW = {\n+            \"--enable-preview\",\n+            \"-source\", Integer.toString(Runtime.version().feature())\n+    };\n+\n+    private static String[] NO_USE_SITE_CHECKS = {\n+            \"--enable-preview\",\n+            \"-source\", Integer.toString(Runtime.version().feature()),\n+            \"-XDuseSiteNullChecks=none\"\n+    };\n+\n+    private static String[] USE_SITE_CHECKS_FOR_METHODS_ONLY = {\n+            \"--enable-preview\",\n+            \"-source\", Integer.toString(Runtime.version().feature()),\n+            \"-XDuseSiteNullChecks=methods\"\n+    };\n+\n+    private static String[] USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS = {\n+            \"--enable-preview\",\n+            \"-source\", Integer.toString(Runtime.version().feature()),\n+            \"-XDuseSiteNullChecks=methods+fields\"\n+    };\n+\n+    private void testHelper(Path base,\n+                            String testCode,\n+                            boolean shouldFail,\n+                            Class<?> expectedError) throws Exception {\n+        testHelper(base, testCode, shouldFail, expectedError, PREVIEW);\n+    }\n+\n+    private void testHelper(Path base,\n+                            String testCode,\n+                            boolean shouldFail,\n+                            Class<?> expectedError,\n+                            String[] compilerOptions) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path testSrc = src.resolve(\"Test\");\n+\n+        tb.writeJavaFiles(testSrc, testCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .options(compilerOptions)\n+                .files(findJavaFiles(src))\n+                .run();\n+\n+        if (shouldFail) {\n+            \/\/ let's check that we get the expected error\n+            try {\n+                String output = new JavaTask(tb)\n+                        .classpath(out.toString())\n+                        .classArgs(\"Test\")\n+                        .vmOptions(\"--enable-preview\")\n+                        .run(Task.Expect.FAIL)\n+                        .writeAll()\n+                        .getOutput(Task.OutputKind.STDERR);\n+                if (!output.startsWith(\"Exception in thread \\\"main\\\" \" + expectedError.getName())) {\n+                    throw new AssertionError(expectedError.getName() + \" expected\");\n+                }\n+            } catch (Throwable t) {\n+                throw new AssertionError(\"failing for test case \" + testCode);\n+            }\n+        } else {\n+            new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .vmOptions(\"--enable-preview\")\n+                    .classArgs(\"Test\")\n+                    .run(Task.Expect.SUCCESS);\n+        }\n+    }\n+\n+    @Test\n+    public void testPatternMatching(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          public class Test {\n+                              public static void main(String... args) {\n+                                  Box box = new Box(null);\n+\n+                                  if (!(box instanceof Box(String s1))) {\n+                                      throw new AssertionError();\n+                                  }\n+\n+                                  if (box instanceof Box(String! s2)) {\n+                                      throw new AssertionError();\n+                                  }\n+\n+                                  switch (box) {\n+                                      case Box(String s3) -> {} \/\/OK\n+                                      default -> throw new AssertionError();\n+                                  }\n+\n+                                  switch (box) {\n+                                      case Box(String! s4) ->\n+                                          throw new AssertionError();\n+                                      default -> {}\n+                                  }\n+\n+                                  System.out.println(\"pass\");\n+                              }\n+                              record Box(String str) {}\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(PREVIEW)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        var out = new JavaTask(tb)\n+                .vmOptions(\"--enable-preview\")\n+                .classpath(classes.toString())\n+                .className(\"Test\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+        var expectedOut = List.of(\"pass\");\n+\n+        if (!Objects.equals(expectedOut, out)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedOut +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n+    @Test\n+    public void testUseSideChecksForMethods(Path base) throws Exception {\n+        String[] testCases = new String[] {\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Object m(Object! arg) { return null; }\n+                    }\n+                    class Inner2 extends Inner {\n+                        @Override\n+                        String m(Object arg) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner2();\n+                        inner.m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Object! m(Object arg) { return \"\"; }\n+                    }\n+                    class Inner2 extends Inner {\n+                        @Override\n+                        String m(Object arg) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner2();\n+                        inner.m(null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Object m(Object! arg, Object... args) { return null; }\n+                    }\n+                    class Inner2 extends Inner {\n+                        @Override\n+                        String m(Object arg, Object... args) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner2();\n+                        inner.m(null, null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Object! m(Object arg, Object... args) { return \"\"; }\n+                    }\n+                    class Inner2 extends Inner {\n+                        @Override\n+                        String m(Object arg, Object... args) { return null; }\n+                    }\n+                    public static void main(String... args) {\n+                        Inner inner = new Test().new Inner2();\n+                        inner.m(null, null);\n+                    }\n+                }\n+                \"\"\"\n+        };\n+        for (String code : testCases) {\n+            testHelper(base, code, true, NullPointerException.class);\n+            testHelper(base, code, true, NullPointerException.class, USE_SITE_CHECKS_FOR_METHODS_ONLY);\n+            testHelper(base, code, true, NullPointerException.class, USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS);\n+            testHelper(base, code, false, null, NO_USE_SITE_CHECKS);\n+        }\n+    }\n+\n+    @Test\n+    public void testUseSideChecksForMethodsSepCompilation(Path base) throws Exception {\n+        testUseSiteForMethodsSeparateCompilationHelper(base,\n+                \"\"\"\n+                package pkg;\n+                class Super {\n+                    Super(Object! arg) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Super {\n+                    Super(Object arg) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Client {\n+                    public static void main(String... args) {\n+                        Super sup = new Super(null);\n+                    }\n+                }\n+                \"\"\");\n+        testUseSiteForMethodsSeparateCompilationHelper(base,\n+                \"\"\"\n+                package pkg;\n+                class Super {\n+                    Super(Object! arg, Object... args) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Super {\n+                    Super(Object arg, Object... args) {}\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Client {\n+                    public static void main(String... args) {\n+                        Super sup = new Super(null, null);\n+                    }\n+                }\n+                \"\"\");\n+        testUseSiteForMethodsSeparateCompilationHelper(base,\n+                \"\"\"\n+                package pkg;\n+                public class Super {\n+                    public class Inner extends Super {\n+                        public Inner(Object! arg) {}\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Super {\n+                    public class Inner extends Super {\n+                        public Inner(Object arg) {}\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Client {\n+                    public static void main(String... args) {\n+                        Super.Inner inner = new Super().new Inner(null);\n+                    }\n+                }\n+                \"\"\");\n+        testUseSiteForMethodsSeparateCompilationHelper(base,\n+                \"\"\"\n+                package pkg;\n+                public class Super {\n+                    public class Inner extends Super {\n+                        public Inner(Object! arg, Object... args) {}\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class Super {\n+                    public class Inner extends Super {\n+                        public Inner(Object arg, Object... args) {}\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Client {\n+                    public static void main(String... args) {\n+                        Super.Inner inner = new Super().new Inner(null, null);\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    private void testUseSiteForMethodsSeparateCompilationHelper(\n+            Path base,\n+            String code1,\n+            String code2,\n+            String clientCode) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path pkg = src.resolve(\"pkg\");\n+        Path ASrc = pkg.resolve(\"A\");\n+        Path client = pkg.resolve(\"Client\");\n+\n+        tb.writeJavaFiles(ASrc, code1);\n+        tb.writeJavaFiles(client, clientCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .options(PREVIEW)\n+                .files(findJavaFiles(pkg))\n+                .run();\n+\n+        \/\/ let's execute to check that it's producing the NPE\n+        System.err.println(\"running, this test should fail\");\n+        String output = new JavaTask(tb)\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Client\")\n+                .vmOptions(\"--enable-preview\")\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDERR);\n+        if (!output.startsWith(\"Exception in thread \\\"main\\\" java.lang.NullPointerException\")) {\n+            throw new AssertionError(\"java.lang.NullPointerException expected\");\n+        }\n+\n+        \/\/ now lets change the code\n+        tb.writeJavaFiles(ASrc, code2);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .options(NO_USE_SITE_CHECKS)\n+                .files(findJavaFiles(pkg))\n+                .run();\n+\n+        System.err.println(\"running, this test should pass\");\n+        new JavaTask(tb)\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Client\")\n+                .vmOptions(\"--enable-preview\")\n+                .run(Task.Expect.SUCCESS);\n+    }\n+\n+    @Test\n+    public void testUseSideChecksForFieldsSepCompilation(Path base) throws Exception {\n+        testUseSiteForFieldsSeparateCompilationHelper(base,\n+                \"\"\"\n+                package pkg;\n+                public class A {\n+                    String! a;\n+                    public A() {\n+                        this.a = \"test\";\n+                        super();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class A {\n+                    String a;\n+                    public A() {\n+                        this.a = null;\n+                        super();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Test {\n+                    public static void main(String... args) {\n+                        A a = new A();\n+                        System.out.println(a.a.toString());\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    private void testUseSiteForFieldsSeparateCompilationHelper(\n+            Path base,\n+            String code1,\n+            String code2,\n+            String testCode) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path pkg = src.resolve(\"pkg\");\n+        Path ASrc = pkg.resolve(\"A\");\n+        Path test = pkg.resolve(\"Test\");\n+\n+        tb.writeJavaFiles(ASrc, code1);\n+        tb.writeJavaFiles(test, testCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        \/\/ this compilation will generate null checks in Test before accessing field A.a\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .options(USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS) \/\/ equivalent to just using PREVIEW options\n+                .files(findJavaFiles(pkg))\n+                .run();\n+\n+        \/\/ let's execute to check that it's producing the NPE\n+        System.err.println(\"running, this test should pass\");\n+        String output = new JavaTask(tb)\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Test\")\n+                .vmOptions(\"--enable-preview\")\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDOUT);\n+        if (!output.startsWith(\"test\")) {\n+            throw new AssertionError(\"unexpected output: \" + output);\n+        }\n+\n+        \/\/ now lets change the code\n+        tb.writeJavaFiles(ASrc, code2);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .options(USE_SITE_CHECKS_FOR_METHODS_AND_FIELDS) \/\/ equivalent to just using PREVIEW options\n+                .files(findJavaFiles(ASrc))\n+                .run();\n+\n+        System.err.println(\"running, this test should fail\");\n+        output = new JavaTask(tb)\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Test\")\n+                .vmOptions(\"--enable-preview\")\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDERR);\n+\n+        \/\/ we need to check that the NPE is due to an invocation to j.l.r.Checks::nullCheck\n+        if (!output.contains(\"java.lang.NullPointerException\") &&\n+                !output.contains(\"java.base\/java.lang.runtime.Checks.nullCheck\")) {\n+            throw new AssertionError(\"unexpected output: \" + output);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":769,"deletions":0,"binary":false,"changes":769,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @enablePreview\n+ * @summary Smoke test for signature attribute parsing\n+ * @compile pkg\/Foo.java\n+ * @compile\/fail\/ref=SeparateCompilationTest.out -Werror -Xlint:null -XDrawDiagnostics SeparateCompilationTest.java\n+ *\/\n+\n+import pkg.Foo;\n+\n+public class SeparateCompilationTest {\n+    void test(Foo<String> foo) {\n+        foo.s = null;\n+        foo.s_arr = null;\n+        foo.x = null;\n+        foo.x_arr = null;\n+        foo.list_x = null;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/separate\/SeparateCompilationTest.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+SeparateCompilationTest.java:13:17: compiler.warn.suspicious.nullness.conversion: java.lang.String, compiler.misc.type.null\n+SeparateCompilationTest.java:14:21: compiler.warn.suspicious.nullness.conversion: java.lang.String[], compiler.misc.type.null\n+SeparateCompilationTest.java:15:17: compiler.warn.suspicious.nullness.conversion: java.lang.String, compiler.misc.type.null\n+SeparateCompilationTest.java:16:21: compiler.warn.suspicious.nullness.conversion: java.lang.String[], compiler.misc.type.null\n+SeparateCompilationTest.java:17:22: compiler.warn.suspicious.nullness.conversion: java.util.List<java.lang.String>, compiler.misc.type.null\n+- compiler.err.warnings.and.werror\n+1 error\n+5 warnings\n","filename":"test\/langtools\/tools\/javac\/nullability\/separate\/SeparateCompilationTest.out","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg;\n+\n+import java.util.List;\n+\n+public class Foo<X> {\n+    public String! s = \"\";\n+    public String[]! s_arr = new String[] { \"\" };\n+    @SuppressWarnings(\"unchecked\")\n+    public X! x = (X)(String)\"\";\n+    @SuppressWarnings(\"unchecked\")\n+    public X[]! x_arr = (X[])(String[])new String[] { \"\" };\n+    public List<X>! list_x = List.of(null);\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/separate\/pkg\/Foo.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -55,0 +55,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -168,1 +169,3 @@\n-            } else\n+            } else if (o instanceof NullMarker) {\n+                return;\n+            } else {\n@@ -170,0 +173,1 @@\n+            }\n","filename":"test\/langtools\/tools\/javac\/tree\/JavacTreeScannerTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -176,0 +177,2 @@\n+            } else if (o instanceof NullMarker) {\n+                return;\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceTreeScannerTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8209400 8215246\n+ * @summary Allow anonymous classes to be value types\n+ * @ignore 8316628\n+ *\/\n+\n+public class AnonymousValueType {\n+    public static void main(String[] args) {\n+        Object o = new value Comparable<String>() {\n+            int x = 10;\n+            @Override\n+            public int compareTo(String o) {\n+                return 0;\n+            }\n+        };\n+        if (!o.toString().equals(\"AnonymousValueType$1@\" + Integer.toHexString(o.hashCode())))\n+            throw new AssertionError(\"Broken\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnonymousValueType.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @enablePreview\n+ * @compile --enable-preview -source ${jdk.version} CanonicalCtorTest.java\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CanonicalCtorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -908,1 +908,1 @@\n-        assertFail(\"compiler.err.strict.field.not.have.been.initialized.before.super\",\n+        assertFail(\"compiler.err.non.nullable.should.be.initialized\",\n@@ -1064,1 +1064,1 @@\n-            assertFail(\"compiler.err.strict.field.not.have.been.initialized.before.super\",\n+            assertFail(\"compiler.err.non.nullable.should.be.initialized\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,16 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile --enable-preview -source ${jdk.version} ValueClass.jcod DuplicateNullRestrictedAttr.jcod\n+ * @compile\/fail\/ref=CheckNullRestrictedAttrIsUnique.out --enable-preview -source ${jdk.version} -XDrawDiagnostics CheckNullRestrictedAttrIsUnique.java\n+ * @ignore\n+ *\/\n+\n+public class CheckNullRestrictedAttrIsUnique {\n+    void m() {\n+        DuplicateNullRestrictedAttr v = new DuplicateNullRestrictedAttr();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/CheckNullRestrictedAttrIsUnique.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckNullRestrictedAttrIsUnique.java:13:9: compiler.err.cant.access: DuplicateNullRestrictedAttr, (compiler.misc.bad.class.file.header: DuplicateNullRestrictedAttr.class, (compiler.misc.attribute.must.be.unique: NullRestricted))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/CheckNullRestrictedAttrIsUnique.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+class DuplicateNullRestrictedAttr {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"DuplicateNullRestrictedAttr\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"field\"; \/\/ #5\n+    Utf8 \"LValueClass;\"; \/\/ #6\n+    Utf8 \"NullRestricted\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #8\n+    Utf8 \"()LDuplicateNullRestrictedAttr;\"; \/\/ #9\n+    Utf8 \"Code\"; \/\/ #10\n+    Utf8 \"LineNumberTable\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"DuplicateNullRestrictedAttr.java\"; \/\/ #13\n+    Utf8 \"ImplicitCreation\"; \/\/ #14\n+    Utf8 \"Preload\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"ValueClass\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+        ;\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #8; \/\/ name_index\n+      #9; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#10) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#11) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+                4  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#14) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+    ;\n+    Attr(#15) { \/\/ Preload\n+      0x00010010;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class DuplicateNullRestrictedAttr\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/DuplicateNullRestrictedAttr.jcod","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+class ValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClass;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"DuplicateNullRestrictedAttr.java\"; \/\/ #10\n+    Utf8 \"ImplicitCreation\"; \/\/ #11\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/ValueClass.jcod","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile --enable-preview -source ${jdk.version} NullRestrictedOnPrimitive.jcod\n+ * @compile\/fail\/ref=CheckFieldTypeTest.out --enable-preview -source ${jdk.version} -XDrawDiagnostics CheckFieldTypeTest.java\n+ *\/\n+\n+public class CheckFieldTypeTest {\n+    void m() {\n+        NullRestrictedOnPrimitive v = new NullRestrictedOnPrimitive();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckFieldTypeTest.java:13:9: compiler.err.cant.access: NullRestrictedOnPrimitive, (compiler.misc.bad.class.file.header: NullRestrictedOnPrimitive.class, (compiler.misc.attribute.not.applicable.to.field.type: NullRestricted, int))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile --enable-preview -source ${jdk.version} NullRestrictedOnArray.jcod\n+ * @compile\/fail\/ref=CheckFieldTypeTest2.out --enable-preview -source ${jdk.version} -XDrawDiagnostics CheckFieldTypeTest2.java\n+ *\/\n+\n+public class CheckFieldTypeTest2 {\n+    void m() {\n+        NullRestrictedOnArray v = new NullRestrictedOnArray();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest2.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckFieldTypeTest2.java:13:9: compiler.err.cant.access: NullRestrictedOnArray, (compiler.misc.bad.class.file.header: NullRestrictedOnArray.class, (compiler.misc.attribute.not.applicable.to.field.type: NullRestricted, java.lang.String[]))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+class NullRestrictedOnArray {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"NullRestrictedOnArray\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"arr\"; \/\/ #5\n+    Utf8 \"[Ljava\/lang\/String;\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()LNullRestrictedOnArray;\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"NullRestrictedOnArray.java\"; \/\/ #12\n+    Utf8 \"ImplicitCreation\"; \/\/ #13\n+    Utf8 \"NullRestricted\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnArray\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/NullRestrictedOnArray.jcod","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+class NullRestrictedOnPrimitive {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"NullRestrictedOnPrimitive\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()LNullRestrictedOnPrimitive;\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"NullRestrictedOnPrimitive.java\"; \/\/ #12\n+    Utf8 \"ImplicitCreation\"; \/\/ #13\n+    Utf8 \"NullRestricted\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  8;\n+                4  5;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnPrimitive\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/NullRestrictedOnPrimitive.jcod","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile --enable-preview -source ${jdk.version} NullRestrictedOnMethod.jcod\n+ * @compile\/fail\/ref=NullRestrictedAttrOnlyOnFields.out --enable-preview -source ${jdk.version} -XDrawDiagnostics NullRestrictedAttrOnlyOnFields.java\n+ *\/\n+\n+public class NullRestrictedAttrOnlyOnFields {\n+    void m() {\n+        NullRestrictedOnMethod v = new NullRestrictedOnMethod();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/NullRestrictedAttrOnlyOnFields.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+NullRestrictedAttrOnlyOnFields.java:13:9: compiler.err.cant.access: NullRestrictedOnMethod, (compiler.misc.bad.class.file.header: NullRestrictedOnMethod.class, (compiler.misc.attribute.only.applicable.to.fields: NullRestricted))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/NullRestrictedAttrOnlyOnFields.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+class NullRestrictedOnMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"NullRestrictedOnMethod\"; \/\/ #2     at 0x0D\n+    class #4; \/\/ #3     at 0x26\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x29\n+    Utf8 \"field\"; \/\/ #5     at 0x3C\n+    Utf8 \"LValueClass2;\"; \/\/ #6     at 0x44\n+    Utf8 \"NullRestricted\"; \/\/ #7     at 0x54\n+    Utf8 \"foo\"; \/\/ #8     at 0x65\n+    Utf8 \"()V\"; \/\/ #9     at 0x6B\n+    Utf8 \"Code\"; \/\/ #10     at 0x71\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x78\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x8A\n+    Utf8 \"()LNullRestrictedOnMethod;\"; \/\/ #13     at 0x93\n+    Utf8 \"SourceFile\"; \/\/ #14     at 0xB0\n+    Utf8 \"NullRestrictedOnMethod.java\"; \/\/ #15     at 0xBD\n+    Utf8 \"ImplicitCreation\"; \/\/ #16     at 0xDB\n+    Utf8 \"Preload\"; \/\/ #17     at 0xEE\n+    class #19; \/\/ #18     at 0xF8\n+    Utf8 \"ValueClass2\"; \/\/ #19     at 0xFB\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access [ ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x0113\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : field\n+      #6; \/\/ descriptor_index : LValueClass2;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0123\n+      0x0000; \/\/ access\n+      #8; \/\/ name_index       : foo\n+      #9; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 25) { \/\/ Code at 0x012B\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[1]{\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0x013E\n+              [1] { \/\/ line_number_table\n+                0  9; \/\/  at 0x014A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x014A\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : <vnew>\n+      #13; \/\/ descriptor_index : ()LNullRestrictedOnMethod;\n+      [2] { \/\/ Attributes\n+        Attr(#10, 34) { \/\/ Code at 0x0152\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[6]{\n+            0xCB00014B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x016A\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x0176\n+                4  2; \/\/  at 0x017A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#7, 0) { \/\/ NullRestricted at 0x011B\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#14, 2) { \/\/ SourceFile at 0x017C\n+      #15;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#16, 2) { \/\/ ImplicitCreation at 0x0184\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+    ;\n+    Attr(#17, 4) { \/\/ Preload at 0x018C\n+      0x00010012;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnMethod\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/NullRestrictedOnMethod.jcod","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+class ValueClass2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [12] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueClass2\"; \/\/ #2     at 0x0D\n+    class #4; \/\/ #3     at 0x1B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x1E\n+    Utf8 \"<vnew>\"; \/\/ #5     at 0x31\n+    Utf8 \"()LValueClass2;\"; \/\/ #6     at 0x3A\n+    Utf8 \"Code\"; \/\/ #7     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #8     at 0x53\n+    Utf8 \"SourceFile\"; \/\/ #9     at 0x65\n+    Utf8 \"NullRestrictedOnMethod.java\"; \/\/ #10     at 0x72\n+    Utf8 \"ImplicitCreation\"; \/\/ #11     at 0x90\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access [ ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0xAF\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index       : <vnew>\n+      #6; \/\/ descriptor_index : ()LValueClass2;\n+      [1] { \/\/ Attributes\n+        Attr(#7, 34) { \/\/ Code at 0xB7\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[6]{\n+            0xCB00014B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#8, 10) { \/\/ LineNumberTable at 0xCF\n+              [2] { \/\/ line_number_table\n+                0  2; \/\/  at 0xDB\n+                4  1; \/\/  at 0xDF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#9, 2) { \/\/ SourceFile at 0xE1\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11, 2) { \/\/ ImplicitCreation at 0xE9\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass2\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/ValueClass2.jcod","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @ignore\n+ * @compile ValueClass.jcod NullRestrictedOnValueClass.jcod\n+ * @compile\/fail\/ref=NullRestrictedAttrOnValueClassNoImplicitConst.out -XDrawDiagnostics NullRestrictedAttrOnValueClassNoImplicitConst.java\n+ *\/\n+\n+ \/* testing if a value class has an implicit constructor or not would imply loading the class if it is not loaded, this could provoke\n+  * altering the class loading order, not sure if this is worthy. Basically the assertion in the JVMS is:\n+  * `The descriptor_index of the field should name a value class that has an ImplicitCreation attribute with its ACC_DEFAULT flag is set`\n+  *\/\n+public class NullRestrictedAttrOnValueClassNoImplicitConst {\n+    void m() {\n+        NullRestrictedOnValueClass v = new NullRestrictedOnValueClass();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/NullRestrictedAttrOnValueClassNoImplicitConst.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/NullRestrictedAttrOnValueClassNoImplicitConst.out","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/langtools\/test\/TEST.ROOT","status":"copied"},{"patch":"@@ -0,0 +1,85 @@\n+class NullRestrictedOnValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"NullRestrictedOnValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"field\"; \/\/ #5\n+    Utf8 \"LValueClass;\"; \/\/ #6\n+    Utf8 \"NullRestricted\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #8\n+    Utf8 \"()LNullRestrictedOnValueClass;\"; \/\/ #9\n+    Utf8 \"Code\"; \/\/ #10\n+    Utf8 \"LineNumberTable\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"NullRestrictedOnValueClass.java\"; \/\/ #13\n+    Utf8 \"ImplicitCreation\"; \/\/ #14\n+    Utf8 \"Preload\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"ValueClass\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #8; \/\/ name_index\n+      #9; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#10) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#11) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+                4  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#14) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+    ;\n+    Attr(#15) { \/\/ Preload\n+      0x00010010;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/NullRestrictedOnValueClass.jcod","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+class ValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClass;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"NullRestrictedOnValueClass.java\"; \/\/ #10\n+    Utf8 \"ImplicitCreation\"; \/\/ #11\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/ValueClass.jcod","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8314165\n+ * @summary check for illegal circularity at class loading time\n+ * @compile --enable-preview -source ${jdk.version} CyclicValueClass.jcod\n+ * @compile\/fail\/ref=CheckForCyclesAtClassLoadingTimeTest.out --enable-preview -source ${jdk.version} -XDrawDiagnostics CheckForCyclesAtClassLoadingTimeTest.java\n+ * @ignore\n+ *\/\n+class CheckForCyclesAtClassLoadingTimeTest {\n+    CyclicValueClass cyclicValueClass;\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CheckForCyclesAtClassLoadingTimeTest.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CyclicValueClass.class:-:-: compiler.err.cyclic.primitive.class.membership: CyclicValueClass\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CheckForCyclesAtClassLoadingTimeTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+class CyclicValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"CyclicValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"cyclicField\"; \/\/ #5\n+    Utf8 \"LCyclicValueClass;\"; \/\/ #6\n+    Utf8 \"NullRestricted\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #8\n+    Utf8 \"()LCyclicValueClass;\"; \/\/ #9\n+    Utf8 \"Code\"; \/\/ #10\n+    Utf8 \"LineNumberTable\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"CyclicValueClass.java\"; \/\/ #13\n+    Utf8 \"ImplicitCreation\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #8; \/\/ name_index\n+      #9; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#10) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#11) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#14) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class CyclicValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CyclicValueClass.jcod","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}