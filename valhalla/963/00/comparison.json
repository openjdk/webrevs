{"files":[{"patch":"@@ -615,0 +615,5 @@\n+    @ForceInline\n+    \/*non-public*\/ static Object zeroInstanceIfNull(Class<?> fieldType, Object obj) {\n+        return obj != null ? obj : UNSAFE.uninitializedDefaultValue(fieldType);\n+    }\n+\n@@ -714,2 +719,1 @@\n-                    case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE\n-                                                     : isNullRestricted ? GET_NULL_RESTRICTED_REFERENCE_VOLATILE : GET_REFERENCE_VOLATILE;\n+                    case OBJECT:  return isFlatValue ? GET_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;\n@@ -727,2 +731,1 @@\n-                    case OBJECT:  return isFlatValue ? GET_VALUE\n-                                                     : isNullRestricted ? GET_NULL_RESTRICTED_REFERENCE : GET_REFERENCE;\n+                    case OBJECT:  return isFlatValue ? GET_VALUE : GET_REFERENCE;\n@@ -773,0 +776,1 @@\n+        boolean needsZeroInstance = isNullRestricted && isValue && !isFlat;\n@@ -820,0 +824,1 @@\n+        final int NULL_CHECK  = (isNullRestricted && !isGetter ? nameCursor++ : -1);\n@@ -822,0 +827,2 @@\n+        final int FIELD_TYPE = (needsZeroInstance && isGetter ? nameCursor++ : -1);\n+        final int ZERO_INSTANCE = (needsZeroInstance && isGetter ? nameCursor++ : -1);\n@@ -827,2 +834,6 @@\n-        if (needsCast && !isGetter)\n-            names[PRE_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[SET_VALUE]);\n+        if (!isGetter) {\n+            if (isNullRestricted)\n+                names[NULL_CHECK] = new Name(getFunction(NF_nullCheck), names[SET_VALUE]);\n+            if (needsCast)\n+                names[PRE_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[SET_VALUE]);\n+        }\n@@ -849,2 +860,11 @@\n-        if (needsCast && isGetter)\n-            names[POST_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[LINKER_CALL]);\n+        if (isGetter) {\n+            int argIndex = LINKER_CALL;\n+            if (needsZeroInstance) {\n+                names[FIELD_TYPE] = isStatic ? new Name(getFunction(NF_staticFieldType), names[DMH_THIS])\n+                                             : new Name(getFunction(NF_fieldType), names[DMH_THIS]);\n+                names[ZERO_INSTANCE] = new Name(getFunction(NF_zeroInstance), names[FIELD_TYPE], names[LINKER_CALL]);\n+                argIndex = ZERO_INSTANCE;\n+            }\n+            if (needsCast)\n+                names[POST_CAST] = new Name(getFunction(NF_checkCast), names[DMH_THIS], names[argIndex]);\n+        }\n@@ -898,1 +918,3 @@\n-            NF_LIMIT = 14;\n+            NF_zeroInstance = 14,\n+            NF_nullCheck = 15,\n+            NF_LIMIT = 16;\n@@ -958,0 +980,4 @@\n+                case NF_zeroInstance:\n+                    return getNamedFunction(\"zeroInstanceIfNull\", MethodType.methodType(Object.class, Class.class, Object.class));\n+                case NF_nullCheck:\n+                    return getNamedFunction(\"nullCheck\", OBJ_OBJ_TYPE);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -264,2 +264,0 @@\n-        GET_NULL_RESTRICTED_REFERENCE(\"getNullRestrictedReference\"),\n-        GET_NULL_RESTRICTED_REFERENCE_VOLATILE(\"getNullRestrictedReferenceVolatile\"),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,0 +184,4 @@\n+#if[Reference]\n+            if (value == null && handle.nullRestricted)\n+                throw new NullPointerException(\"null-restricted field\");\n+#end[Reference]\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -294,20 +294,0 @@\n-    \/**\n-     * Fetches a reference value of the given type from a given null-restricted\n-     * Java variable.  The VM may lazily set a null-restricted non-flat field.\n-     * If the reference value is null, return a zero instance instead.\n-     *\n-     * @apiNote This API is temporary.  It will be replaced when CheckedType\n-     *          is implemented.\n-     *\n-     * @param type type\n-     *\/\n-    public Object getNullRestrictedReference(Object o, long offset, Class<?> type) {\n-        Object ref = getReference(o, offset);\n-        return ref != null ? ref : ValueClass.zeroInstance(type);\n-    }\n-\n-    public Object getNullRestrictedReferenceVolatile(Object o, long offset, Class<?> type) {\n-        Object ref = getReferenceVolatile(o, offset);\n-        return ref != null ? ref : ValueClass.zeroInstance(type);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+        UNSAFE.ensureClassInitialized(cls);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/ValueClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test VarHandle on primitive class array\n+ * @summary test VarHandle on value class array\n@@ -29,2 +29,2 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:FlatArrayElementMaxSize=-1 ArrayElementVarHandleTest\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:FlatArrayElementMaxSize=0  ArrayElementVarHandleTest\n+ * @run junit\/othervm -XX:+EnableValhalla -XX:FlatArrayElementMaxSize=-1 ArrayElementVarHandleTest\n+ * @run testng\/othervm -XX:+EnableValhalla -XX:FlatArrayElementMaxSize=0  ArrayElementVarHandleTest\n@@ -34,0 +34,1 @@\n+import java.util.stream.Stream;\n@@ -35,3 +36,6 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -40,3 +44,9 @@\n-    private static final Point P = Point.makePoint(10, 20);\n-    private static final Line L = Line.makeLine(10, 20, 30, 40);\n-    private static final MutablePath PATH = MutablePath.makePath(10, 20, 30, 40);\n+    @ImplicitlyConstructible\n+    static value class Point {\n+        public int x;\n+        public int y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n@@ -44,5 +54,6 @@\n-    private static final Point[] POINTS = new Point[]{\n-            Point.makePoint(1, 2),\n-            Point.makePoint(10, 20),\n-            Point.makePoint(100, 200)\n-    };\n+    @ImplicitlyConstructible\n+    static value class Line {\n+        @NullRestricted\n+        Point p1;\n+        @NullRestricted\n+        Point p2;\n@@ -50,3 +61,13 @@\n-    private static final Point.ref[] NULL_POINTS = new Point.ref[]{\n-            Point.makePoint(11, 22),\n-            Point.makePoint(110, 220),\n+        Line(Point p1, Point p2) {\n+            this.p1 = p1;\n+            this.p2 = p2;\n+        }\n+        Line(int x1, int y1, int x2, int y2) {\n+            this(new Point(x1, y1), new Point(x2, y2));\n+        }\n+    }\n+\n+    private static final Point[] POINTS = new Point[]{\n+            new Point(1, 2),\n+            new Point(10, 20),\n+            new Point(100, 200),\n@@ -57,17 +78,2 @@\n-            Line.makeLine(1, 2, 3, 4),\n-            Line.makeLine(10, 20, 30, 40),\n-            Line.makeLine(15, 25, 35, 45),\n-            Line.makeLine(20, 30, 40, 50)\n-    };\n-\n-    private static final Line.ref[] NULL_LINES = new Line.ref[] { null, null };\n-\n-    private static final NonFlattenValue[] NFV_ARRAY = new NonFlattenValue[]{\n-            NonFlattenValue.make(1, 2),\n-            NonFlattenValue.make(10, 20),\n-            NonFlattenValue.make(100, 200)\n-    };\n-\n-    private static final ValueOptional[] VALUES = new ValueOptional[]{\n-            new ValueOptional(null),\n-            new ValueOptional(P),\n+            new Line(1, 2, 3, 4),\n+            new Line(10, 20, 30, 40),\n@@ -77,2 +83,1 @@\n-    @DataProvider(name=\"data\")\n-    static Object[][] data() throws Throwable {\n+    static Stream<Arguments> testCases() throws Throwable {\n@@ -81,40 +86,10 @@\n-        int vlen = VALUES.length;\n-        return new Object[][]{\n-                \/\/ Point[] <: Point.ref[] <: Object[]\n-                new Object[] { newArray(Object[].class, plen),    POINTS },\n-                new Object[] { newArray(Object[].class, plen),    NULL_POINTS },\n-                new Object[] { newArray(Object[].class, plen),    new Object[] { \"abc\", Point.makePoint(1, 2) } },\n-                new Object[] { newArray(Point.ref[].class, plen), NULL_POINTS },\n-                new Object[] { newArray(Point[].class, plen),     POINTS },\n-                new Object[] { new Point.ref[plen],               POINTS },\n-                new Object[] { new Point.ref[plen],               NULL_POINTS },\n-                new Object[] { new Point[plen],                   POINTS },\n-\n-                \/\/ Line[] <: Line.ref[]\n-                new Object[] { newArray(Object[].class, llen),    LINES },\n-                new Object[] { newArray(Object[].class, llen),    NULL_LINES },\n-                new Object[] { newArray(Object[].class, llen),    LINES },\n-                new Object[] { newArray(Line.ref[].class, llen),  NULL_LINES },\n-                new Object[] { newArray(Line[].class, llen),      LINES },\n-                new Object[] { new Line.ref[llen],                LINES },\n-                new Object[] { new Line.ref[llen],                NULL_LINES },\n-                new Object[] { new Line[llen],                    LINES },\n-\n-                \/\/ value class\n-                new Object[] { newArray(Object[].class, vlen),        VALUES },\n-                new Object[] { newArray(ValueOptional[].class, vlen), VALUES },\n-                new Object[] { new ValueOptional[vlen],               VALUES },\n-\n-                \/\/ non flattened values\n-                new Object[] { newArray(NonFlattenValue[].class, NFV_ARRAY.length), NFV_ARRAY },\n-                new Object[] { new NonFlattenValue[NFV_ARRAY.length], NFV_ARRAY }\n-        };\n-    }\n-\n-    \/*\n-     * Test VarHandle to set elements of the given array with\n-     * various access mode.\n-     *\/\n-    @Test(dataProvider = \"data\")\n-    public void testSetArrayElements(Object[] array, Object[] data) throws Throwable {\n-        setElements(array, data);\n+        return Stream.of(\n+                Arguments.of(newArray(Object[].class, plen),    POINTS),\n+                Arguments.of(newArray(Object[].class, plen),    new Object[] { \"abc\", new Point(1, 2) }),\n+                Arguments.of(newArray(Point[].class, plen),     POINTS),\n+                Arguments.of(new Point[plen],                   POINTS),\n+\n+                Arguments.of(newArray(Object[].class, llen),    LINES),\n+                Arguments.of(newArray(Line[].class, llen),      LINES),\n+                Arguments.of(new Line[llen],                    LINES)\n+        );\n@@ -127,1 +102,1 @@\n-    static Object[] newArray(Class<?> arrayType, int size) throws Throwable {\n+    private static Object[] newArray(Class<?> arrayType, int size) throws Throwable {\n@@ -133,2 +108,2 @@\n-     * Sets the given array with the given elements.\n-     * This tests several VarHandle access mode.\n+     * Test VarHandle to set elements of the given array with\n+     * various access mode.\n@@ -136,1 +111,3 @@\n-    void setElements(Object[] array, Object[] elements) {\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    public void testSetArrayElements(Object[] array, Object[] elements) {\n@@ -157,1 +134,1 @@\n-            assertEquals(v, elements[i]);\n+            assertEquals(elements[i], v);\n@@ -168,1 +145,1 @@\n-            assertEquals(v, elements[i]);\n+            assertEquals(elements[i], v);\n@@ -179,1 +156,1 @@\n-            assertEquals(v, elements[i]);\n+            assertEquals(elements[i], v);\n@@ -190,1 +167,1 @@\n-            assertEquals(v, elements[i]);\n+            assertEquals(elements[i], v);\n@@ -200,1 +177,1 @@\n-            assertEquals(v, elements[i]);\n+            assertEquals(elements[i], v);\n@@ -229,1 +206,1 @@\n-            assertEquals(vh.compareAndExchange(array, i, elements[i], v), elements[i]);\n+            assertEquals(elements[i], vh.compareAndExchange(array, i, elements[i], v));\n","filename":"test\/jdk\/valhalla\/valuetypes\/ArrayElementVarHandleTest.java","additions":64,"deletions":87,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -1,308 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @summary test reflection on primitive classes\n- * @compile --enable-preview --source ${jdk.version} -XDenablePrimitiveClasses BasicTest.java\n- * @run testng\/othervm --enable-preview -XX:+EnableValhalla -XX:+EnablePrimitiveClasses BasicTest\n- *\/\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.io.Serializable;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import jdk.internal.value.PrimitiveClass;\n-\n-import static org.testng.Assert.*;\n-\n-public class BasicTest {\n-    static primitive class Point {\n-        int x;\n-        int y;\n-        Point(int x, int y) {\n-            this.x = x;\n-            this.y = y;\n-        }\n-\n-        int x() {\n-            return x;\n-        }\n-\n-        int y() {\n-            return y;\n-        }\n-        static Point.val newVal(int x, int y) {\n-            return new Point(x, y);\n-        }\n-        static Point.ref toRef(Object o) {\n-            return (Point.ref) o;\n-        }\n-        static Point.val toVal(Point.ref o) {\n-            return (Point.val) o;\n-        }\n-    }\n-\n-    static value class Value {\n-        int v;\n-        Value(int v) {\n-            this.v = v;\n-        }\n-    }\n-\n-    @DataProvider(name=\"constants\")\n-    static Object[][] constants() {\n-        return new Object[][]{\n-            new Object[] { Point.class, PrimitiveClass.asPrimaryType(Point.class)},\n-            new Object[] { Point.val.class, PrimitiveClass.asValueType(Point.class)},\n-            new Object[] { Point.ref.class, PrimitiveClass.asPrimaryType(Point.class)},\n-            new Object[] { Value.class, PrimitiveClass.asPrimaryType(Value.class)},\n-        };\n-    }\n-\n-    @Test(dataProvider=\"constants\")\n-    public void ldc(Class<?> type, Class<?> expected) {\n-        assertTrue(type == expected);\n-    }\n-\n-    @DataProvider(name=\"refTypes\")\n-    static Object[][] refTypes() {\n-        return new Object[][]{\n-                new Object[] { int.class, true},\n-                new Object[] { Integer.class, true},\n-                new Object[] { Object.class, true},\n-                new Object[] { Point.ref.class, true},\n-                new Object[] { Point.val.class, false},\n-                new Object[] { PrimitiveClass.asPrimaryType(Point.class), true},\n-                new Object[] { PrimitiveClass.asValueType(Point.class), false},\n-                new Object[] { Value.class, true},\n-        };\n-    }\n-    @Test(dataProvider=\"refTypes\")\n-    public void isPrimaryType(Class<?> type, boolean isRefType) {\n-        assertTrue(PrimitiveClass.isPrimaryType(type) == isRefType);\n-    }\n-\n-    \/*\n-     * Tests the primary and secondary mirror.\n-     *\/\n-    @Test\n-    public void testMirrors() {\n-        Class<?> refType = PrimitiveClass.asPrimaryType(Point.class);\n-        Class<?> valType = PrimitiveClass.asValueType(Point.class);\n-\n-        assertTrue(refType == Point.ref.class);\n-        assertTrue(valType == Point.val.class);\n-        assertTrue(refType != valType);\n-\n-        assertTrue(PrimitiveClass.isPrimitiveClass(refType));\n-        assertTrue(PrimitiveClass.isPrimitiveClass(valType));\n-\n-        assertTrue(PrimitiveClass.isPrimaryType(refType));\n-        assertFalse(PrimitiveClass.isPrimitiveValueType(refType));\n-\n-        assertTrue(PrimitiveClass.isPrimitiveValueType(valType));\n-        assertFalse(PrimitiveClass.isPrimaryType(valType));\n-\n-        assertEquals(refType.getName(), valType.getName());\n-        assertEquals(refType.getName(), \"BasicTest$Point\");\n-        assertEquals(refType.getSimpleName(),\"Point\");\n-        assertEquals(valType.getSimpleName(),\"Point\");\n-\n-        assertEquals(valType.getTypeName(), \"BasicTest$Point\");\n-        assertEquals(refType.getTypeName(), \"BasicTest$Point.ref\");\n-\n-        assertEquals(valType.descriptorString(), \"QBasicTest$Point;\");\n-        assertEquals(refType.descriptorString(), \"LBasicTest$Point;\");\n-    }\n-\n-    \/*\n-     * Tests subtyping relationship: Point <: Point.ref and Point <: Object\n-     *\n-     * Class:isAssignableFrom\n-     * Class::isInstance\n-     * Class::asSubclass\n-     *\/\n-    @Test\n-    public void testSubtypes() {\n-        \/\/ Point <: Point.ref and Point <: Object\n-        assertTrue(Point.ref.class.isAssignableFrom(PrimitiveClass.asValueType(Point.class)));\n-        assertTrue(Object.class.isAssignableFrom(PrimitiveClass.asValueType(Point.class)));\n-        assertFalse(PrimitiveClass.asValueType(Point.class).isAssignableFrom(Point.ref.class));\n-        assertTrue(Object.class.isAssignableFrom(Point.ref.class));\n-\n-        assertTrue(PrimitiveClass.asValueType(Point.class).asSubclass(Point.ref.class) == PrimitiveClass.asValueType(Point.class));\n-        try {\n-            Class<?> c = Point.ref.class.asSubclass(PrimitiveClass.asValueType(Point.class));\n-            fail(\"Point.ref cannot be cast to Point.class\");\n-        } catch (ClassCastException e) { }\n-\n-        Point o = new Point(10, 20);\n-        assertTrue(PrimitiveClass.asValueType(Point.class).isInstance(o));\n-        assertTrue(Point.ref.class.isInstance(o));\n-        assertFalse(PrimitiveClass.asValueType(Point.class).isInstance(null));\n-        assertFalse(Point.ref.class.isInstance(null));\n-    }\n-\n-    @DataProvider(name=\"names\")\n-    static Object[][] names() {\n-        return new Object[][]{\n-                new Object[] { \"BasicTest$Point\", PrimitiveClass.asPrimaryType(Point.class)},\n-                new Object[] { \"[QBasicTest$Point;\", Point[].class},\n-                new Object[] { \"[[LBasicTest$Point;\", Point.ref[][].class},\n-                new Object[] { \"BasicTest$Value\", Value.class},\n-                new Object[] { \"[LBasicTest$Value;\", Value[].class},\n-        };\n-    }\n-    @Test(dataProvider=\"names\")\n-    public void classForName(String name, Class<?> expected) throws ClassNotFoundException {\n-        Class<?> type = Class.forName(name);\n-        assertTrue(type == expected);\n-        assertEquals(type.getName(), name);\n-    }\n-\n-    @Test\n-    public void testNull() {\n-        Point.ref ref = Point.toRef(null);\n-        assertTrue(ref == null);\n-        try {\n-            Point.toVal(null);\n-            throw new RuntimeException(\"expected NPE thrown\");\n-        } catch (NullPointerException e) {}\n-    }\n-\n-    @Test\n-    public void testConversion() {\n-        Point p = new Point(10,20);\n-        Point.ref ref = Point.toRef(p);\n-        Point.val val = Point.toVal(ref);\n-        assertEquals(ref, p);\n-        assertEquals(val, p);\n-    }\n-\n-    @Test\n-    public void testMembers() {\n-        Method[] refMethods = Point.ref.class.getDeclaredMethods();\n-        Method[] valMethods = Point.val.class.getDeclaredMethods();\n-        assertEquals(refMethods, valMethods);\n-        assertTrue(valMethods.length == 5);\n-\n-        Field[] refFields = Point.ref.class.getDeclaredFields();\n-        Field[] valFields = Point.val.class.getDeclaredFields();\n-        assertEquals(refFields, valFields);\n-        assertTrue(valFields.length == 2);\n-\n-        Constructor[] refCtors = Point.ref.class.getDeclaredConstructors();\n-        Constructor[] valCtors = Point.val.class.getDeclaredConstructors();\n-        assertEquals(refCtors, valCtors);\n-        assertTrue(valCtors.length == 1);\n-        assertTrue(Modifier.isStatic(valCtors[0].getModifiers()));\n-    }\n-\n-    @DataProvider(name=\"methods\")\n-    static Object[][] methods() {\n-        return new Object[][]{\n-                new Object[] { \"toVal\", Point.val.class, new Class<?>[] { Point.ref.class }},\n-                new Object[] { \"toRef\", Point.ref.class, new Class<?>[] { Object.class }},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"methods\")\n-    public void testMethod(String name, Class<?> returnType, Class<?>[] paramTypes) throws ReflectiveOperationException {\n-        Method m = Point.class.getDeclaredMethod(name, paramTypes);\n-        System.out.print(m.toString() + \"  \");\n-        System.out.println(m.getReturnType().descriptorString());\n-        assertTrue(m.getDeclaringClass() == PrimitiveClass.asPrimaryType(Point.class));\n-        assertTrue(m.getReturnType() == returnType);\n-        assertEquals(m.getParameterTypes(), paramTypes);\n-    }\n-\n-    @DataProvider(name=\"ctors\")\n-    static Object[][] ctors() {\n-        return new Object[][]{\n-                new Object[] { Point.class, new Class<?>[] { int.class, int.class}, new Object[] { 10, 10 }},\n-                new Object[] { Value.class, new Class<?>[] { int.class }, new Object[] { 20 }},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"ctors\")\n-    public void testConstructor(Class<?> c, Class<?>[] paramTypes, Object[] params) throws ReflectiveOperationException {\n-        Constructor<?> ctor = c.getDeclaredConstructor(paramTypes);\n-        assertTrue(ctor.getDeclaringClass() == PrimitiveClass.asPrimaryType(c));\n-        Object o = ctor.newInstance(params);\n-    }\n-\n-    class C { }\n-    primitive class T { }\n-\n-    @DataProvider(name=\"intfs\")\n-    Object[][] intfs() {\n-        Point point = new Point(10, 20);\n-        Point[] array = new Point[] { point };\n-        Value value = new Value(10);\n-        Class<?> [] empty_intfs = new Class<?>[0];\n-        return new Object[][]{\n-                new Object[]{ new BasicTest(), empty_intfs },\n-                new Object[]{ point, empty_intfs },\n-                new Object[]{ new T(), empty_intfs },\n-                new Object[]{ new C(), empty_intfs },\n-                new Object[]{ new Object(), empty_intfs },\n-                new Object[]{ array, new Class<?>[] { Cloneable.class, Serializable.class }},\n-                new Object[]{ value, empty_intfs },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"intfs\")\n-    public void testGetInterfaces(Object o, Class<?>[] expectedInterfaces) {\n-        Class<?> type = o.getClass();\n-        assertEquals(type.getInterfaces(), expectedInterfaces);\n-    }\n-\n-    @Test\n-    public void testNestMembership() {\n-        assertTrue(Point.class.getNestHost() == BasicTest.class);\n-        assertTrue(T.class.getNestHost() == BasicTest.class);\n-        assertTrue(C.class.getNestHost() == BasicTest.class);\n-\n-        Class<?>[] members = BasicTest.class.getNestMembers();\n-        assertEquals(Point.class.getNestMembers(), members);\n-        assertEquals(T.class.getNestMembers(), members);\n-        assertEquals(C.class.getNestMembers(), members);\n-        assertEquals(Arrays.stream(members).collect(Collectors.toSet()),\n-                     Set.of(BasicTest.class,\n-                            Value.class,\n-                            PrimitiveClass.asPrimaryType(Point.class),\n-                            PrimitiveClass.asPrimaryType(C.class),\n-                            PrimitiveClass.asPrimaryType(T.class)));\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/BasicTest.java","additions":0,"deletions":308,"binary":false,"changes":308,"status":"deleted"},{"patch":"@@ -1,186 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public primitive class InlinableValue {\n-    char char_v;\n-    byte byte_v;\n-    boolean boolean_v;\n-    int int_v;\n-    short short_v;\n-    long long_v;\n-    double double_v;\n-    float float_v;\n-    Number number_v;\n-    Point point_v;\n-    Point.ref point_ref;\n-    Object ref_v;\n-\n-    InlinableValue(char c, boolean z, byte b, int x, short y, long l, float f, double d, Number number, Point p, Object o) {\n-        char_v = c;\n-        byte_v = b;\n-        boolean_v = z;\n-        int_v = x;\n-        short_v = y;\n-        long_v = l;\n-        float_v = f;\n-        double_v = d;\n-        number_v = number;\n-        point_v = p;\n-        point_ref = null;\n-        ref_v = o;\n-    }\n-    InlinableValue(char c, boolean z, byte b, int x, short y, long l, float f, double d, Number number, Point p, Point.ref pref, Object o) {\n-        char_v = c;\n-        byte_v = b;\n-        boolean_v = z;\n-        int_v = x;\n-        short_v = y;\n-        long_v = l;\n-        float_v = f;\n-        double_v = d;\n-        number_v = number;\n-        point_v = p;\n-        point_ref = pref;\n-        ref_v = o;\n-    }\n-    static class Builder {\n-        private char c;\n-        private byte b;\n-        private boolean z;\n-        private int i;\n-        private short s;\n-        private long l;\n-        private double d;\n-        private float f;\n-        private Number n;\n-        private Point p = Point.makePoint(0,0);\n-        private Point.ref pref;\n-        private Object ref;\n-\n-        public Builder() {}\n-        Builder setChar(char c) {\n-            this.c = c;\n-            return this;\n-        }\n-        Builder setByte(byte b) {\n-            this.b = b;\n-            return this;\n-        }\n-        Builder setBoolean(boolean z) {\n-            this.z = z;\n-            return this;\n-        }\n-        Builder setInt(int i) {\n-            this.i = i;\n-            return this;\n-        }\n-        Builder setShort(short s) {\n-            this.s = s;\n-            return this;\n-        }\n-        Builder setLong(long l) {\n-            this.l = l;\n-            return this;\n-        }\n-        Builder setDouble(double d) {\n-            this.d = d;\n-            return this;\n-        }\n-        Builder setFloat(float f) {\n-            this.f = f;\n-            return this;\n-        }\n-        Builder setNumber(Number n) {\n-            this.n = n;\n-            return this;\n-        }\n-        Builder setPoint(Point p) {\n-            this.p = p;\n-            return this;\n-        }\n-        Builder setPointRef(Point p) {\n-            this.pref = p;\n-            return this;\n-        }\n-        Builder setReference(Object o) {\n-            this.ref = o;\n-            return this;\n-        }\n-        InlinableValue build() {\n-            return new InlinableValue(c, z, b, i, s, l, f, d, n, p, pref, ref);\n-        }\n-    }\n-\n-    interface Number {\n-        default int intValue() {\n-            throw new UnsupportedOperationException();\n-        }\n-        default short shortValue() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        static IntValue intValue(int i) {\n-            return new IntValue(i);\n-        }\n-\n-        static ShortValue shortValue(short s) {\n-            return new ShortValue(s);\n-        }\n-    }\n-\n-    static primitive class IntValue implements Number {\n-        int i;\n-        IntValue(int i) {\n-            this.i = i;\n-        }\n-        public int intValue() {\n-            return i;\n-        }\n-    }\n-\n-    static primitive class ShortValue implements Number {\n-        short s;\n-        ShortValue(short s) {\n-            this.s = s;\n-        }\n-        public short shortValue() {\n-            return s;\n-        }\n-    }\n-\n-    static class IntNumber implements Number {\n-        final int i;\n-        public IntNumber(int i) {\n-            this.i = i;\n-        }\n-\n-        public int intValue() {\n-            return i;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return Integer.toString(i);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/InlinableValue.java","additions":0,"deletions":186,"binary":false,"changes":186,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses LambdaConversion\n- * @summary test lambda type conversion of primitive class\n+ * @run junit\/othervm -XX:+EnableValhalla LambdaConversion\n+ * @summary test lambda type conversion of value class\n@@ -32,1 +32,0 @@\n-import java.util.stream.Stream;\n@@ -34,2 +33,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -40,2 +39,2 @@\n-    static primitive class Pointer<X> {\n-        final long addr;\n+    static value class Pointer<X> {\n+        long addr;\n@@ -57,1 +56,1 @@\n-    static <Z> int doAction(Pointer<Z> pointer, ToIntFunction<Pointer.ref<Z>> action) {\n+    static <Z> int doAction(Pointer<Z> pointer, ToIntFunction<Pointer<Z>> action) {\n","filename":"test\/jdk\/valhalla\/valuetypes\/LambdaMetaFactory\/LambdaConversion.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses LambdaTest\n+ * @run junit\/othervm -XX:+EnableValhalla LambdaTest\n@@ -34,3 +34,4 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -39,0 +40,1 @@\n+    @ImplicitlyConstructible\n@@ -40,3 +42,3 @@\n-        int v;\n-        V(int v) {\n-            this.v = v;\n+        int x;\n+        V(int x) {\n+            this.x = x;\n@@ -45,2 +47,2 @@\n-        static V get(int v) {\n-            return new V(v);\n+        static V get(int x) {\n+            return new V(x);\n@@ -50,4 +52,6 @@\n-    static primitive class P {\n-        int p;\n-        P(int p) {\n-            this.p = p;\n+    @ImplicitlyConstructible\n+    static value class Value {\n+        @NullRestricted\n+        V v;\n+        Value(V v) {\n+            this.v = v;\n@@ -55,3 +59,2 @@\n-\n-        static P get(int p) {\n-            return new P(p);\n+        static Value get(int x) {\n+            return new Value(new V(x));\n@@ -62,1 +65,1 @@\n-        return v.v;\n+        return v.x;\n@@ -65,2 +68,2 @@\n-    static int getP(P p) {\n-        return p.p;\n+    static int getValue(Value v) {\n+        return v.v.x;\n@@ -71,2 +74,2 @@\n-        Function<P.ref, Integer> func1 = LambdaTest::getP;\n-        assertTrue(func1.apply(new P(100)) == 100);\n+        Function<Value, Integer> func1 = LambdaTest::getValue;\n+        assertTrue(func1.apply(new Value(new V(100))) == 100);\n@@ -80,2 +83,2 @@\n-        IntFunction<P.ref> func1 = P::get;\n-        assertEquals(func1.apply(10), new P(10));\n+        IntFunction<Value> func1 = Value::get;\n+        assertEquals(func1.apply(10), new Value(new V(10)));\n","filename":"test\/jdk\/valhalla\/valuetypes\/LambdaMetaFactory\/LambdaTest.java","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public final primitive class Line {\n-    public Point p1;\n-    public Point p2;\n-\n-    Line() {\n-        this.p1 = Point.makePoint(0, 0);\n-        this.p2 = Point.makePoint(0, 0);\n-    }\n-\n-    Line(int x1, int y1, int x2, int y2) {\n-        this(Point.makePoint(x1, y1), Point.makePoint(x2, y2));\n-    }\n-\n-    Line(Point p1, Point p2) {\n-        this.p1 = p1;\n-        this.p2 = p2;\n-    }\n-\n-    public Point p1() {\n-        return p1;\n-    }\n-\n-    public Point p2() {\n-        return p2;\n-    }\n-\n-    public static Line makeLine(int x1, int y1, int x2, int y2) {\n-        return new Line(x1, y1, x2, y2);\n-    }\n-\n-    public static Line makeLine(Point p1, Point p2) {\n-        return new Line(p1, p2);\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/Line.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-\n@@ -27,3 +26,3 @@\n- * @compile --enable-preview --source ${jdk.version} -XDenablePrimitiveClasses MHZeroValue.java\n- * @run testng\/othervm --enable-preview -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:InlineFieldMaxFlatSize=128 MHZeroValue\n- * @run testng\/othervm --enable-preview -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:InlineFieldMaxFlatSize=0 MHZeroValue\n+ * @compile -XDenablePrimitiveClasses MHZeroValue.java\n+ * @run junit\/othervm -XX:+EnableValhalla -XX:InlineFieldMaxFlatSize=128 MHZeroValue\n+ * @run junit\/othervm -XX:+EnableValhalla -XX:InlineFieldMaxFlatSize=0 MHZeroValue\n@@ -34,1 +33,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -37,3 +35,1 @@\n-import static java.lang.invoke.MethodType.*;\n-\n-import jdk.internal.value.PrimitiveClass;\n+import java.util.stream.Stream;\n@@ -41,3 +37,7 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import static java.lang.invoke.MethodType.*;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -46,5 +46,2 @@\n-    static value class V {\n-        public boolean isEmpty() {\n-            return true;\n-        }\n-    }\n+    @ImplicitlyConstructible\n+    static value class V {}\n@@ -52,1 +49,3 @@\n-    static primitive class P {\n+    @ImplicitlyConstructible\n+    static value class P {\n+        @NullRestricted\n@@ -59,3 +58,2 @@\n-    @DataProvider\n-    public static Object[][] defaultValue() {\n-        return new Object[][] {\n+    static Stream<Arguments> defaultValue() {\n+        return Stream.of(\n@@ -63,11 +61,5 @@\n-                new Object[] { int.class,               (new int[1])[0] },\n-                new Object[] { Integer.class,           (new Integer[1])[0] },\n-                new Object[] { PrimitiveClass.asValueType(P.class),   (new P[1])[0] },\n-                new Object[] { PrimitiveClass.asPrimaryType(P.class), (new P.ref[1])[0] },\n-                new Object[] { V.class,                 (new V[1])[0] },\n-        };\n-    }\n-    @Test(dataProvider = \"defaultValue\")\n-    public void zero(Class<?> type, Object value) throws Throwable {\n-        MethodHandle mh = MethodHandles.zero(type);\n-        assertEquals(mh.invoke(), value);\n+                Arguments.of(int.class,         (new int[1])[0],      0 \/* default value *\/),\n+                Arguments.of(Integer.class,     (new Integer[1])[0],  null),\n+                Arguments.of(P.class,           (new P[1])[0],        null),\n+                Arguments.of(V.class,           (new V[1])[0],        null)\n+        );\n@@ -76,24 +68,6 @@\n-    @DataProvider\n-    public static Object[][] primitives() {\n-        return new Object[][] {\n-                \/\/ int : Integer\n-                new Object[] { int.class,             Integer.class },\n-                \/\/ Point : Point.ref\n-                new Object[] { PrimitiveClass.asValueType(P.class), PrimitiveClass.asPrimaryType(P.class) },\n-                new Object[] { null,                  V.class },\n-        };\n-    }\n-    @Test(dataProvider = \"primitives\")\n-    public void constant(Class<?> primitiveType, Class<?> refType) throws Throwable {\n-        if (primitiveType != null) {\n-            try {\n-                MethodHandles.constant(primitiveType, null);\n-                fail(\"Expected NPE thrown for \" + primitiveType.getName());\n-            } catch (NullPointerException e) {\n-            }\n-        }\n-\n-        try {\n-            MethodHandles.constant(refType, \"invalid value\");\n-            fail(\"Expected CCE thrown for \" + refType.getName());\n-        } catch (ClassCastException e) {}\n+    @ParameterizedTest\n+    @MethodSource(\"defaultValue\")\n+    public void zero(Class<?> type, Object value, Object expected) throws Throwable {\n+        var mh = MethodHandles.zero(type);\n+        assertEquals(mh.invoke(), expected);\n+        assertEquals(value, expected);\n@@ -102,12 +76,8 @@\n-    @DataProvider\n-    public static Object[][] emptyTypes() {\n-        Class<?> pref = PrimitiveClass.asPrimaryType(P.class);\n-        Class<?> pval = PrimitiveClass.asValueType(P.class);\n-        return new Object[][] {\n-                new Object[] { methodType(int.class, int.class, Object.class),     new V(), 0 },\n-                new Object[] { methodType(Integer.class, int.class, Object.class), new P(), null },\n-                new Object[] { methodType(pval, int.class, pref),                  null,    P.default },\n-                new Object[] { methodType(pref, int.class, pval),                  new P(), null },\n-                new Object[] { methodType(V.class, int.class, pval),               new P(), null },\n-                new Object[] { methodType(V.class, int.class, V.class),            new V(), null },\n-        };\n+    static Stream<Arguments> testCases() {\n+        return Stream.of(\n+                Arguments.of(methodType(int.class, int.class, Object.class),     new V(), 0),\n+                Arguments.of(methodType(Integer.class, int.class, Object.class), new P(), null),\n+                Arguments.of(methodType(P.class, int.class, P.class),            new P(), null),\n+                Arguments.of(methodType(V.class, int.class, P.class),            new P(), null),\n+                Arguments.of(methodType(V.class, int.class, V.class),            new V(), null)\n+        );\n@@ -116,1 +86,2 @@\n-    @Test(dataProvider = \"emptyTypes\")\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n@@ -118,1 +89,1 @@\n-        MethodHandle mh = MethodHandles.empty(mtype);\n+        var mh = MethodHandles.empty(mtype);\n","filename":"test\/jdk\/valhalla\/valuetypes\/MHZeroValue.java","additions":41,"deletions":70,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test MethodHandle\/VarHandle of value classes and primitive classes\n+ * @summary test MethodHandle and VarHandle of value classes\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses MethodHandleTest\n+ * @run junit\/othervm -XX:+EnableValhalla MethodHandleTest\n@@ -36,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -37,1 +38,5 @@\n-import jdk.internal.value.PrimitiveClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -39,3 +44,1 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -44,0 +47,44 @@\n+    @ImplicitlyConstructible\n+    static value class Point {\n+        public int x;\n+        public int y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class Line {\n+        @NullRestricted\n+        Point p1;\n+        @NullRestricted\n+        Point p2;\n+\n+        Line(int x1, int y1, int x2, int y2) {\n+            this.p1 = new Point(x1, y1);\n+            this.p2 = new Point(x2, y2);\n+        }\n+    }\n+\n+    static class Ref {\n+        @NullRestricted\n+        Point p;\n+        Line l;\n+        List<String> list;\n+        ValueOptional vo;\n+\n+        Ref(Point p, Line l) {\n+            this.p = p;\n+            this.l = l;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class ValueOptional {\n+        private Object o;\n+        public ValueOptional(Object o) {\n+            this.o = o;\n+        }\n+    }\n+\n@@ -45,4 +92,0 @@\n-    private static final Point P = Point.makePoint(10, 20);\n-    private static final Line L = Line.makeLine(10, 20, 30, 40);\n-    private static final MutablePath PATH = MutablePath.makePath(10, 20, 30, 40);\n-    private static final Value V = new Value(P, new ValueOptional(L));\n@@ -50,18 +93,13 @@\n-    @DataProvider(name=\"fields\")\n-    static Object[][] fields() {\n-        MutablePath path = MutablePath.makePath(1, 2, 3, 4);\n-        MixedValues mv = new MixedValues(P, L, PATH, \"mixed\", \"types\");\n-        return new Object[][]{\n-                \/\/ primitive class with int fields\n-                new Object[] { \"Point\", P, new String[] { \"x\", \"y\"} },\n-                \/\/ primitive class whose fields are of primitive value type\n-                new Object[] { \"Line\", L, new String[] { \"p1\", \"p2\"} },\n-                \/\/ non-primitive class whose non-final fields are of primitive value type\n-                new Object[] { \"MutablePath\", PATH, new String[] {\"p1\", \"p2\"} },\n-                new Object[] { \"Point\", path.p1, new String[] {\"x\", \"y\"} },\n-                new Object[] { \"Point\", path.p2, new String[] {\"x\", \"y\"} },\n-                \/\/ identity class whose non-final fields are of primitive value type,\n-                \/\/ primitive reference type, reference type and value class\n-                new Object[] { \"MixedValues\", mv, new String[] {\"p\", \"l\", \"mutablePath\", \"list\", \"nfp\", \"voptional\"} },\n-                new Object[] { \"MethodHandleTest$Value\", V, new String[] {\"p\", \"vo\"} },\n-        };\n+    static final Point P = new Point(1, 2);\n+    static final Line L = new Line(1, 2, 3, 4);\n+    static final Ref R = new Ref(P, null);\n+\n+    static Stream<Arguments> fields() {\n+        return Stream.of(\n+                \/\/ value class with int fields\n+                Arguments.of(\"MethodHandleTest$Point\", P, new String[] {\"x\", \"y\"}),\n+                \/\/ value class whose fields are null-restricted and of value class\n+                Arguments.of( \"MethodHandleTest$Line\", L, new String[] {\"p1\", \"p2\"}),\n+                \/\/ identity class whose non-final fields are of value type,\n+                Arguments.of( \"MethodHandleTest$Ref\", R, new String[] {\"p\", \"l\", \"list\", \"vo\"})\n+        );\n@@ -75,1 +113,2 @@\n-    @Test(dataProvider = \"fields\")\n+    @ParameterizedTest\n+    @MethodSource(\"fields\")\n@@ -80,0 +119,2 @@\n+            var mh = LOOKUP.findGetter(c, f.getName(), f.getType());\n+            var v1 = mh.invoke(o);\n@@ -81,2 +122,2 @@\n-            MethodHandle mh = LOOKUP.findGetter(c, f.getName(), f.getType());\n-            Object v1 = mh.invoke(o);\n+            var vh = LOOKUP.findVarHandle(c, f.getName(), f.getType());\n+            var v2 = vh.get(o);\n@@ -84,5 +125,2 @@\n-            VarHandle vh = LOOKUP.findVarHandle(c, f.getName(), f.getType());\n-            Object v2 = vh.get(o);\n-\n-            MethodHandle mh3 = LOOKUP.unreflectGetter(f);\n-            Object v3 = mh.invoke(o);\n+            var mh3 = LOOKUP.unreflectGetter(f);\n+            var v3 = mh.invoke(o);\n@@ -92,2 +130,0 @@\n-            else\n-                ensureNullable(f, o);\n@@ -97,7 +133,6 @@\n-    @Test\n-    public void testValueFields() throws Throwable {\n-        \/\/ set the mutable value fields\n-        MutablePath path = MutablePath.makePath(1, 2, 3, 44);\n-        Point p = Point.makePoint(100, 200);\n-        setValueField(MutablePath.class, \"p1\", path, p);\n-        setValueField(MutablePath.class, \"p2\", path, p);\n+    static Stream<Arguments> arrays() {\n+        return Stream.of(\n+                Arguments.of(Point[].class, P),\n+                Arguments.of(Line[].class, L),\n+                Arguments.of(Ref[].class, R)\n+        );\n@@ -106,10 +141,1 @@\n-    \/\/ Test writing to a field of primitive value type and of primitive\n-    \/\/ reference type\n-    @Test\n-    public void testMixedValues() throws Throwable {\n-        \/\/ set the mutable fields\n-        MutablePath path = MutablePath.makePath(1, 2, 3, 44);\n-        MixedValues mv = new MixedValues(P, L, PATH, \"mixed\", \"types\");\n-        Point p = Point.makePoint(100, 200);\n-        Line l = Line.makeLine(100, 200, 300, 400);\n-        ValueOptional vo = new ValueOptional(P);\n+    private static final int ARRAY_SIZE = 5;\n@@ -117,26 +143,2 @@\n-        setValueField(MutablePath.class, \"p1\", path, p);\n-        setValueField(MutablePath.class, \"p2\", path, p);\n-        setValueField(MixedValues.class, \"p\", mv, p);\n-        setValueField(MixedValues.class, \"l\", mv, l);\n-        setValueField(MixedValues.class, \"staticPoint\", null, p);\n-        \/\/ the following are nullable fields\n-        setField(MixedValues.class, \"nfp\", mv, p, false);\n-        setField(MixedValues.class, \"voptional\", mv, vo, false);\n-        \/\/ static fields of reference type\n-        setField(MixedValues.class, \"staticLine\", null, l, false);\n-        setField(MixedValues.class, \"staticLine\", null, null, false);\n-        setField(MixedValues.class, \"staticValue\", null, vo, false);\n-    }\n-\n-    @DataProvider(name=\"arrays\")\n-    static Object[][] arrays() {\n-        return new Object[][]{\n-                new Object[] { Point[].class, P },\n-                new Object[] { Point.ref[].class, P },\n-                new Object[] { Line[].class, L },\n-                new Object[] { MutablePath[].class, PATH },\n-                new Object[] { Value[].class, V },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"arrays\")\n+    @ParameterizedTest\n+    @MethodSource(\"arrays\")\n@@ -144,3 +146,0 @@\n-        Class<?> elementType = arrayClass.getComponentType();\n-        MethodHandle setter = MethodHandles.arrayElementSetter(arrayClass);\n-        MethodHandle getter = MethodHandles.arrayElementGetter(arrayClass);\n@@ -148,3 +147,8 @@\n-        int size = 5;\n-        Object[] array = (Object[])ctor.invoke(size);\n-        for (int i=0; i < size; i++) {\n+        Object[] array = (Object[])ctor.invoke(ARRAY_SIZE);\n+        testArrayElement(array, o, false);\n+    }\n+\n+    private void testArrayElement(Object array, Object o, boolean nullRestricted) throws Throwable {\n+        MethodHandle setter = MethodHandles.arrayElementSetter(array.getClass());\n+        MethodHandle getter = MethodHandles.arrayElementGetter(array.getClass());\n+        for (int i=0; i < ARRAY_SIZE; i++) {\n@@ -153,1 +157,1 @@\n-        for (int i=0; i < size; i++) {\n+        for (int i=0; i < ARRAY_SIZE; i++) {\n@@ -158,40 +162,5 @@\n-        try {\n-            Object v = (Object)setter.invoke(array, 1, null);\n-            assertFalse(PrimitiveClass.isPrimitiveValueType(elementType), \"should fail to set a primitive class array element to null\");\n-            assertNull((Object) getter.invoke(array, 1));\n-        } catch (NullPointerException e) {\n-            assertTrue(PrimitiveClass.isPrimitiveValueType(elementType), \"should only fail to set a primitive class array element to null\");\n-        }\n-    }\n-\n-    \/*\n-     * Test setting the given field to null via reflection, method handle\n-     * and var handle.\n-     *\/\n-    static void ensureNullable(Field f, Object o) throws Throwable {\n-        Class<?> c = f.getDeclaringClass();\n-        assertFalse(Modifier.isFinal(f.getModifiers()));\n-        assertFalse(Modifier.isStatic(f.getModifiers()));\n-        boolean canBeNull = PrimitiveClass.isPrimaryType(f.getType());\n-        \/\/ test reflection\n-        try {\n-            f.set(o, null);\n-            assertTrue(canBeNull, f + \" cannot be set to null\");\n-        } catch (NullPointerException e) {\n-            assertFalse(canBeNull, f + \" should allow be set to null\");\n-        }\n-        \/\/ test method handle, i.e. putfield bytecode behavior\n-        try {\n-            MethodHandle mh = LOOKUP.findSetter(c, f.getName(), f.getType());\n-            mh.invoke(o, null);\n-            assertTrue(canBeNull, f + \" cannot be set to null\");\n-        } catch (NullPointerException e) {\n-            assertFalse(canBeNull, f + \" should allow be set to null\");\n-        }\n-        \/\/ test var handle\n-        try {\n-            VarHandle vh = LOOKUP.findVarHandle(c, f.getName(), f.getType());\n-            vh.set(o, null);\n-            assertTrue(canBeNull, f + \" cannot be set to null\");\n-        } catch (NullPointerException e) {\n-            assertFalse(canBeNull, f + \" should allow be set to null\");\n+        if (nullRestricted) {\n+            assertThrows(NullPointerException.class, () -> setter.invoke(array, 1, null));\n+        } else {\n+            setter.invoke(array, 1, null);\n+            assertNull(getter.invoke(array, 1));\n@@ -205,7 +174,1 @@\n-        Object v = f.get(o);\n-        \/\/ test Field::set\n-        try {\n-            f.set(o, v);\n-            throw new RuntimeException(f + \" should be immutable\");\n-        } catch (IllegalAccessException e) {\n-        }\n+        assertTrue(f.trySetAccessible());\n@@ -213,111 +176,1 @@\n-        \/\/ test method handle, i.e. putfield bytecode behavior\n-        try {\n-            MethodHandle mh = LOOKUP.findSetter(c, f.getName(), f.getType());\n-            mh.invoke(o, v);\n-            throw new RuntimeException(f + \" should be immutable\");\n-        } catch (IllegalAccessException e) {\n-        }\n-        \/\/ test var handle\n-        try {\n-            VarHandle vh = LOOKUP.findVarHandle(c, f.getName(), f.getType());\n-            vh.set(o, v);\n-            throw new RuntimeException(f + \" should be immutable\");\n-        } catch (UnsupportedOperationException e) {\n-        }\n-    }\n-\n-    \/*\n-     * Test setting a field of a primitive class to a new value.\n-     * The field must be flattenable but may or may not be flattened.\n-     *\/\n-    static void setValueField(Class<?> c, String name, Object obj, Object value) throws Throwable {\n-        setField(c, name, obj, value, true);\n-    }\n-\n-    \/*\n-     * Test Field::set, MethodHandle::set on a method handle of a field\n-     * and VarHandle::compareAndSet and compareAndExchange.\n-     *\/\n-    static void setField(Class<?> c, String name, Object obj, Object value, boolean isPrimitiveValue) throws Throwable {\n-        Field f = c.getDeclaredField(name);\n-        boolean isStatic = Modifier.isStatic(f.getModifiers());\n-        assertTrue(f.getType().isValue());\n-        assertTrue(PrimitiveClass.isPrimitiveValueType(f.getType()) == isPrimitiveValue);\n-        assertTrue((isStatic && obj == null) || (!isStatic && obj != null));\n-        Object v = f.get(obj);\n-\n-        \/\/ Field::set\n-        try {\n-            f.set(obj, value);\n-            assertEquals(f.get(obj), value);\n-        } finally {\n-            f.set(obj, v);\n-        }\n-\n-        if (isStatic) {\n-            setStaticField(f, value);\n-        } else {\n-            setInstanceField(f, obj, value);\n-        }\n-    }\n-\n-    static void setInstanceField(Field f, Object obj, Object value) throws Throwable {\n-        Object v = f.get(obj);\n-        \/\/ MethodHandle::invoke\n-        try {\n-            MethodHandle mh = LOOKUP.findSetter(f.getDeclaringClass(), f.getName(), f.getType());\n-            mh.invoke(obj, value);\n-            assertEquals(f.get(obj), value);\n-        } finally {\n-            f.set(obj, v);\n-        }\n-\n-        \/\/ VarHandle tests\n-        VarHandle vh = LOOKUP.findVarHandle(f.getDeclaringClass(), f.getName(), f.getType());\n-        try {\n-            vh.set(obj, value);\n-            assertEquals(f.get(obj), value);\n-        } finally {\n-            f.set(obj, v);\n-        }\n-\n-        try {\n-            assertTrue(vh.compareAndSet(obj, v, value));\n-            assertEquals(f.get(obj), value);\n-        } finally {\n-            f.set(obj, v);\n-        }\n-\n-        try {\n-            assertEquals(vh.compareAndExchange(obj, v, value), v);\n-            assertEquals(f.get(obj), value);\n-        } finally {\n-            f.set(obj, v);\n-        }\n-    }\n-\n-    static void setStaticField(Field f, Object value) throws Throwable {\n-        Object v = f.get(null);\n-        \/\/ MethodHandle::invoke\n-        try {\n-            MethodHandle mh = LOOKUP.findStaticSetter(f.getDeclaringClass(), f.getName(), f.getType());\n-            mh.invoke(f.getType().cast(value));\n-            assertEquals(f.get(null), value);\n-        } finally {\n-            f.set(null, v);\n-        }\n-        \/\/ VarHandle tests\n-        VarHandle vh = LOOKUP.findStaticVarHandle(f.getDeclaringClass(), f.getName(), f.getType());\n-        try {\n-            vh.set(f.getType().cast(value));\n-            assertEquals(f.get(null), value);\n-        } finally {\n-            f.set(null, v);\n-        }\n-\n-        try {\n-            assertTrue(vh.compareAndSet(v, f.getType().cast(value)));\n-            assertEquals(f.get(null), value);\n-        } finally {\n-            f.set(null, v);\n-        }\n+        Object v = f.get(o);\n@@ -325,7 +178,3 @@\n-        try {\n-            assertEquals(vh.compareAndExchange(v, f.getType().cast(value)), v);\n-            assertEquals(f.get(null), value);\n-        } finally {\n-            f.set(null, v);\n-        }\n-    }\n+        assertThrows(IllegalAccessException.class, () -> LOOKUP.findSetter(c, f.getName(), f.getType()));\n+        assertThrows(IllegalAccessException.class, () -> LOOKUP.unreflectSetter(f));\n+        VarHandle vh = LOOKUP.findVarHandle(c, f.getName(), f.getType());\n@@ -333,7 +182,2 @@\n-    static value class Value {\n-        Point p;\n-        ValueOptional vo;\n-        Value(Point p, ValueOptional vo) {\n-            this.p = p;\n-            this.vo = vo;\n-        }\n+        \/\/ test var handle\n+        assertThrows(UnsupportedOperationException.class, () -> vh.set(o, v));\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodHandleTest.java","additions":105,"deletions":261,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses MethodReference\n- * @summary test method reference and primitive reference type as the parameter type\n+ * @run main\/othervm -XX:+EnableValhalla MethodReference\n+ * @summary test method reference of value class as the parameter type\n@@ -33,1 +33,1 @@\n-public primitive class MethodReference {\n+public value class MethodReference {\n@@ -42,2 +42,2 @@\n-        Supplier<MethodReference.ref> supplier = MethodReference::new;\n-        MethodReference o = (MethodReference) supplier.get();\n+        Supplier<MethodReference> supplier = MethodReference::new;\n+        MethodReference o = supplier.get();\n","filename":"test\/jdk\/valhalla\/valuetypes\/MethodReference.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.List;\n-\n-public class MixedValues {\n-    static Point staticPoint = Point.makePoint(10, 10);\n-    static Line.ref staticLine;   \/\/ null static field of non-flattened type\n-    static ValueOptional staticValue;\n-    Point p;\n-    Line l;\n-    MutablePath mutablePath;\n-    List<String> list;\n-    Point.ref nfp;\n-    ValueOptional voptional;\n-\n-    public MixedValues(Point p, Line l, MutablePath path, String... names) {\n-        this.p = p;\n-        this.l = l;\n-        this.mutablePath = path;\n-        this.list = List.of(names);\n-        this.nfp = p;\n-        this.voptional = new ValueOptional(p);\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/MixedValues.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public final class MutablePath {\n-    public Point p1;\n-    public Point p2;\n-\n-    public Point p1() {\n-        return p1;\n-    }\n-\n-    public Point p2() {\n-        return p2;\n-    }\n-\n-    public void set(int x1, int y1, int x2, int y2) {\n-        this.p1 = Point.makePoint(x1, y1);\n-        this.p2 = Point.makePoint(x2, y2);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"MutablePath\" + p1 + \", \" + p2;\n-    }\n-\n-    public static MutablePath makePath(int x1, int y1, int x2, int y2) {\n-        MutablePath path = new MutablePath();\n-        path.set(x1, y1, x2, y2);\n-        return path;\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/MutablePath.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses Nest\n+ * @run junit\/othervm -XX:+EnableValhalla Nest\n@@ -32,2 +32,19 @@\n-public interface Nest {\n-    public static void main(String... args) {\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+public class Nest {\n+    static interface I {\n+        String toString();\n+    }\n+\n+    static I of(int value, Object next) {\n+        \/\/ anonymous class capturing outer locals\n+        return new value I() {\n+            public String toString() {\n+                return value + \" -> \" + next;\n+            }\n+        };\n+    }\n+\n+    @Test\n+    public void test1() {\n@@ -36,0 +53,1 @@\n+    }\n@@ -37,0 +55,2 @@\n+    @Test\n+    public void test2() {\n@@ -41,0 +61,1 @@\n+        \/\/ o1.new Inner(1) == o2.new Inner(1) iff o1 == o2\n@@ -45,2 +66,2 @@\n-    \/\/ o1.new Inner(1) == o2.new Inner(1) iff o1 == o2\n-    static primitive class Outer {\n+    @ImplicitlyConstructible\n+    value class Outer {\n@@ -52,1 +73,2 @@\n-        primitive class Inner {\n+        @ImplicitlyConstructible\n+        value class Inner {\n@@ -59,22 +81,0 @@\n-\n-    String toString();\n-\n-    static Nest of(int value, Object next) {\n-        \/\/ anonymous class capturing outer locals\n-        return new primitive Nest() {\n-            public String toString() {\n-                return value + \" -> \" + next;\n-            }\n-        };\n-    }\n-\n-    static void assertEquals(Object o1, Object o2) {\n-        if (o1 != o2) {\n-            throw new RuntimeException(o1 + \" != \" + o2);\n-        }\n-    }\n-    static void assertNotEquals(Object o1, Object o2) {\n-        if (o1 == o2) {\n-            throw new RuntimeException(o1 + \" == \" + o2);\n-        }\n-    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/Nest.java","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public primitive class NonFlattenValue {\n-    Point.ref nfp;\n-\n-    NonFlattenValue() {\n-        this.nfp = Point.makePoint(0,0);\n-    }\n-    NonFlattenValue(Point p) {\n-        this.nfp = p;\n-    }\n-    public Point.ref point() {\n-        return nfp;\n-    }\n-    public Point pointValue() {\n-        return (Point) nfp;\n-    }\n-    public boolean has(Point p1, Point.ref p2) {\n-        return nfp.equals(p1) || nfp.equals(p2);\n-    }\n-\n-    public static NonFlattenValue make(int x, int y) {\n-        return new NonFlattenValue(Point.makePoint(x, y));\n-    }\n-\n-    @Override\n-    public String toString() {\n-        \/\/ nfp may be null when NonFlattenValue[] is created and filled with default value\n-        return nfp != null ? nfp.toString() : \"default NonFlattenValue\";\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/NonFlattenValue.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,9 +24,0 @@\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n-import jdk.internal.vm.annotation.NullRestricted;\n-\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n@@ -36,2 +27,0 @@\n- * @modules java.base\/jdk.internal.vm.annotation\n- *          java.base\/jdk.internal.value\n@@ -41,0 +30,2 @@\n+ * @summary Test reflection and method handle on accessing a field of a null-restricted value class\n+ *          that may be flattened or non-flattened\n@@ -42,0 +33,15 @@\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -44,1 +50,4 @@\n-    static value class MyValueEmpty {\n+    static value class EmptyValue {\n+        public boolean isEmpty() {\n+            return true;\n+        }\n@@ -48,1 +57,2 @@\n-    static value class EmptyContainer {\n+    static value class Value {\n+        Object o;\n@@ -50,1 +60,20 @@\n-        MyValueEmpty empty = new MyValueEmpty();\n+        EmptyValue empty;\n+        Value() {\n+            this.o = null;\n+            this.empty = new EmptyValue();\n+        }\n+    }\n+\n+    static class Mutable {\n+        EmptyValue o;\n+        @NullRestricted\n+        EmptyValue empty;\n+        @NullRestricted\n+        volatile EmptyValue vempty;\n+    }\n+\n+    @Test\n+    public void emptyValueClass() {\n+        EmptyValue e = new EmptyValue();\n+        Field[] fields = e.getClass().getDeclaredFields();\n+        assertTrue(fields.length == 0);\n@@ -56,1 +85,2 @@\n-        assertTrue(new EmptyContainer() == ValueClass.zeroInstance(EmptyContainer.class));\n+        assertTrue(new Value() == ValueClass.zeroInstance(Value.class));\n+        assertTrue(new Value().empty == ValueClass.zeroInstance(EmptyValue.class));\n@@ -59,4 +89,29 @@\n-    @Test\n-    public void testMethodHandle() throws Throwable {\n-        var mh = MethodHandles.lookup().findGetter(EmptyContainer.class, \"empty\", MyValueEmpty.class);\n-        assertTrue(mh.invoke(new EmptyContainer()) == ValueClass.zeroInstance(MyValueEmpty.class));\n+    static Stream<Arguments> getterCases() {\n+        Value v = new Value();\n+        EmptyValue emptyValue = ValueClass.zeroInstance(EmptyValue.class);\n+        Mutable m = new Mutable();\n+\n+        return Stream.of(\n+                Arguments.of(Value.class, \"o\", Object.class, v, null),\n+                Arguments.of(Value.class, \"empty\", EmptyValue.class, v, emptyValue),\n+                Arguments.of(Mutable.class, \"o\", EmptyValue.class, m, null),\n+                Arguments.of(Mutable.class, \"empty\", EmptyValue.class, m, emptyValue),\n+                Arguments.of(Mutable.class, \"vempty\", EmptyValue.class, m, emptyValue)\n+        );\n+    };\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getterCases\")\n+    public void testGetter(Class<?> type, String name, Class<?> ftype, Object obj, Object expected) throws Throwable {\n+        var f = type.getDeclaredField(name);\n+        assertTrue(f.getType() == ftype);\n+        var o1 = f.get(obj);\n+        assertTrue(expected == o1);\n+\n+        var getter = MethodHandles.lookup().findGetter(type, name, ftype);\n+        var o2 = getter.invoke(obj);\n+        assertTrue(expected == o2);\n+\n+        var vh = MethodHandles.lookup().findVarHandle(type, name, ftype);\n+        var o3 = vh.get(obj);\n+        assertTrue(expected == o3);\n@@ -65,4 +120,22 @@\n-    @Test\n-    public void testVarHandle() throws Throwable {\n-        var vh = MethodHandles.lookup().findVarHandle(EmptyContainer.class, \"empty\", MyValueEmpty.class);\n-        assertTrue(vh.get(new EmptyContainer()) == ValueClass.zeroInstance(MyValueEmpty.class));\n+    static Stream<Arguments> setterCases() {\n+        EmptyValue emptyValue = ValueClass.zeroInstance(EmptyValue.class);\n+        Mutable m = new Mutable();\n+        return Stream.of(\n+                Arguments.of(Mutable.class, \"o\", EmptyValue.class, m, null),\n+                Arguments.of(Mutable.class, \"o\", EmptyValue.class, m, emptyValue),\n+                Arguments.of(Mutable.class, \"empty\", EmptyValue.class, m, emptyValue),\n+                Arguments.of(Mutable.class, \"vempty\", EmptyValue.class, m, emptyValue)\n+        );\n+    };\n+\n+    @ParameterizedTest\n+    @MethodSource(\"setterCases\")\n+    public void testSetter(Class<?> type, String name, Class<?> ftype, Object obj, Object expected) throws Throwable {\n+        var f = type.getDeclaredField(name);\n+        assertTrue(f.getType() == ftype);\n+        f.set(obj, expected);\n+        assertTrue(f.get(obj) == expected);\n+\n+        var setter = MethodHandles.lookup().findSetter(type, name, ftype);\n+        setter.invoke(obj, expected);\n+        assertTrue(f.get(obj) == expected);\n@@ -72,3 +145,42 @@\n-    public void testField() throws Throwable {\n-        var f = EmptyContainer.class.getDeclaredField(\"empty\");\n-        assertTrue(f.get(new EmptyContainer()) == ValueClass.zeroInstance(MyValueEmpty.class));\n+    public void noWriteAccess() throws ReflectiveOperationException {\n+        Value v = new Value();\n+        Field f = v.getClass().getDeclaredField(\"o\");\n+        assertThrows(IllegalAccessException.class, () -> f.set(v, null));\n+    }\n+\n+    static Stream<Arguments> nullRestrictedFields() {\n+        Mutable m = new Mutable();\n+        return Stream.of(\n+                Arguments.of(Mutable.class, \"o\", EmptyValue.class, m, false),\n+                Arguments.of(Mutable.class, \"empty\", EmptyValue.class, m, true),\n+                Arguments.of(Mutable.class, \"vempty\", EmptyValue.class, m, true)\n+        );\n+    };\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nullRestrictedFields\")\n+    public void testNullRestrictedField(Class<?> type, String name, Class<?> ftype, Object obj, boolean nullRestricted) throws Throwable {\n+        var f = type.getDeclaredField(name);\n+        assertTrue(f.getType() == ftype);\n+        if (nullRestricted) {\n+            assertThrows(NullPointerException.class, () -> f.set(obj, null));\n+        } else {\n+            f.set(obj, null);\n+            assertTrue(f.get(obj) == null);\n+        }\n+\n+        var mh = MethodHandles.lookup().findSetter(type, name, ftype);\n+        if (nullRestricted) {\n+            assertThrows(NullPointerException.class, () -> mh.invoke(obj, null));\n+        } else {\n+            mh.invoke(obj, null);\n+            assertTrue(f.get(obj) == null);\n+        }\n+\n+        var vh = MethodHandles.lookup().findVarHandle(type, name, ftype);\n+        if (nullRestricted) {\n+            assertThrows(NullPointerException.class, () -> vh.set(obj, null));\n+        } else {\n+            vh.set(obj, null);\n+            assertTrue(f.get(obj) == null);\n+        }\n","filename":"test\/jdk\/valhalla\/valuetypes\/NullRestrictedTest.java","additions":139,"deletions":27,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * @summary test Object methods on value classes and primitive classes\n- * @modules java.base\/jdk.internal.value\n+ * @summary test Object methods on value classes\n@@ -30,2 +29,2 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Dvalue.bsm.salt=1 ObjectMethods\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Dvalue.bsm.salt=1 -XX:InlineFieldMaxFlatSize=0 ObjectMethods\n+ * @run junit\/othervm -XX:+EnableValhalla -Dvalue.bsm.salt=1 ObjectMethods\n+ * @run junit\/othervm -XX:+EnableValhalla -Dvalue.bsm.salt=1 -XX:InlineFieldMaxFlatSize=0 ObjectMethods\n@@ -39,4 +38,7 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -44,1 +46,1 @@\n-import jdk.internal.value.PrimitiveClass;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -47,0 +49,59 @@\n+    @ImplicitlyConstructible\n+    static value class Point {\n+        public int x;\n+        public int y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class Line {\n+        @NullRestricted\n+        Point p1;\n+        @NullRestricted\n+        Point p2;\n+\n+        Line(int x1, int y1, int x2, int y2) {\n+            this.p1 = new Point(x1, y1);\n+            this.p2 = new Point(x2, y2);\n+        }\n+    }\n+\n+    static class Ref {\n+        @NullRestricted\n+        Point p;\n+        Line l;\n+        Ref(Point p, Line l) {\n+            this.p = p;\n+            this.l = l;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class Value {\n+        @NullRestricted\n+        Point p;\n+        @NullRestricted\n+        Line l;\n+        Ref r;\n+        String s;\n+        Value(Point p, Line l, Ref r, String s) {\n+            this.p = p;\n+            this.l = l;\n+            this.r = r;\n+            this.s = s;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class ValueOptional {\n+        private Object o;\n+        public ValueOptional(Object o) {\n+            this.o = o;\n+        }\n+    }\n+\n+    static value record ValueRecord(int i, String name) {}\n+\n@@ -48,41 +109,22 @@\n-    static final Point P1 = Point.makePoint(1, 2);\n-    static final Point P2 = Point.makePoint(30, 40);\n-    static final Line LINE1 = Line.makeLine(1, 2, 3, 4);\n-    static final Line LINE2 = Line.makeLine(10, 20, 3, 4);\n-    static final MutablePath MUTABLE_PATH = MutablePath.makePath(10, 20, 30, 40);\n-    static final MixedValues MIXED_VALUES = new MixedValues(P1, LINE1, MUTABLE_PATH, \"value\");\n-    static final InlinableValue VALUE = new InlinableValue.Builder()\n-                                                .setChar('z')\n-                                                .setBoolean(false)\n-                                                .setByte((byte)0x1)\n-                                                .setShort((short)3)\n-                                                .setLong(4L)\n-                                                .setPoint(Point.makePoint(200, 200))\n-                                                .setNumber(InlinableValue.Number.intValue(10)).build();\n-    static final InlinableValue VALUE1 = new InlinableValue.Builder()\n-                                                .setChar('z')\n-                                                .setBoolean(false)\n-                                                .setByte((byte)0x1)\n-                                                .setShort((short)3)\n-                                                .setLong(4L)\n-                                                .setPoint(Point.makePoint(100, 100))\n-                                                .setPointRef(Point.makePoint(200, 200))\n-                                                .setReference(Point.makePoint(300, 300))\n-                                                .setNumber(InlinableValue.Number.intValue(20)).build();\n-\n-    @DataProvider(name=\"Identities\")\n-    Object[][] identitiesData() {\n-        return new Object[][]{\n-                {new Object(), false, false},\n-                {\"String\", true, false},\n-                {String.class, true, false},\n-                {Object.class, true, false},\n-                {new ValueType1(1), false, true},\n-                {new ValueType2(2), false, true},\n-                {new PrimitiveRecord(1, \"A\"), false, true},\n-                {new ValueRecord(1,\"B\"), false, true},\n-                {new int[0], true, false},  \/\/ arrays of primitive classes are identity objects\n-                {new Object[0], true, false},  \/\/ arrays of identity classes are identity objects\n-                {new String[0], true, false},  \/\/ arrays of identity classes are identity objects\n-                {new ValueType1[0], true, false},  \/\/ arrays of value classes are identity objects\n-        };\n+    static final Point P1 = new Point(1, 2);\n+    static final Point P2 = new Point(30, 40);\n+    static final Line L1 = new Line(1, 2, 3, 4);\n+    static final Line L2 = new Line(10, 20, 3, 4);\n+    static final Ref R1 = new Ref(P1, L1);\n+    static final Ref R2 = new Ref(P2, null);\n+    static final Value V = new Value(P1, L1, R1, \"value\");\n+\n+    static Stream<Arguments> identitiesData() {\n+        return Stream.of(\n+                Arguments.of(new Object(), false, false),\n+                Arguments.of(\"String\", true, false),\n+                Arguments.of(String.class, true, false),\n+                Arguments.of(Object.class, true, false),\n+                Arguments.of(L1, false, true),\n+                Arguments.of(V, false, true),\n+                Arguments.of(new ValueRecord(1, \"B\"), false, true),\n+                Arguments.of(new int[0], true, false),     \/\/ arrays of primitive type are identity objects\n+                Arguments.of(new Object[0], true, false),  \/\/ arrays of identity classes are identity objects\n+                Arguments.of(new String[0], true, false),  \/\/ arrays of identity classes are identity objects\n+                Arguments.of(new Value[0], true, false)    \/\/ arrays of value classes are identity objects\n+        );\n@@ -91,2 +133,3 @@\n-    @Test(dataProvider=\"Identities\")\n-    void identityTests(Object obj, boolean identityClass, boolean valueClass) {\n+    @ParameterizedTest\n+    @MethodSource(\"identitiesData\")\n+    public void identityTests(Object obj, boolean identityClass, boolean valueClass) {\n@@ -98,1 +141,1 @@\n-            assertEquals(Objects.isIdentityObject(obj), identityClass, \"Objects.isIdentityObject()\");\n+            assertEquals(identityClass, Objects.isIdentityObject(obj), \"Objects.isIdentityObject()\");\n@@ -101,1 +144,1 @@\n-        assertEquals(Objects.isValueObject(obj), valueClass, \"Objects.isValueObject()\");\n+        assertEquals(valueClass, Objects.isValueObject(obj), \"Objects.isValueObject()\");\n@@ -103,1 +146,1 @@\n-        assertEquals(clazz.isIdentity(), identityClass, \"Class.isIdentity()\");\n+        assertEquals(identityClass, clazz.isIdentity(), \"Class.isIdentity()\");\n@@ -105,1 +148,1 @@\n-        assertEquals(clazz.isValue(), valueClass, \"Class.isValue()\");\n+        assertEquals(valueClass, clazz.isValue(), \"Class.isValue()\");\n@@ -115,40 +158,24 @@\n-    @DataProvider(name=\"equalsTests\")\n-    Object[][] equalsTests() {\n-        return new Object[][]{\n-            { P1, P1, true},\n-            { P1, Point.makePoint(1, 2), true},\n-            { P1, P2, false},\n-            { P1, LINE1, false},\n-            { LINE1, Line.makeLine(1, 2, 3, 4), true},\n-            { LINE1, LINE2, false},\n-            { LINE1, LINE1, true},\n-            { VALUE, new InlinableValue.Builder()\n-                              .setChar('z')\n-                              .setBoolean(false)\n-                              .setByte((byte)0x1)\n-                              .setShort((short)3)\n-                              .setLong(4L)\n-                              .setPoint(Point.makePoint(200, 200))\n-                              .setNumber(InlinableValue.Number.intValue(10)).build(), true},\n-            { new InlinableValue.Builder().setNumber(new InlinableValue.IntNumber(10)).build(),\n-              new InlinableValue.Builder().setNumber(new InlinableValue.IntNumber(10)).build(), false},\n-            \/\/ reference classes containing fields of primitive class\n-            { MUTABLE_PATH, MutablePath.makePath(10, 20, 30, 40), false},\n-            { MIXED_VALUES, MIXED_VALUES, true},\n-            { MIXED_VALUES, new MixedValues(P1, LINE1, MUTABLE_PATH, \"value\"), false},\n-            \/\/ uninitialized default value\n-            { MyValue1.default, MyValue1.default, true},\n-            { MyValue1.default, new MyValue1(0,0, null), true},\n-            { new MyValue1(10, 20, P1), new MyValue1(10, 20, Point.makePoint(1,2)), true},\n-            { new ReferenceType0(10), new ReferenceType0(10), true},\n-            { new ValueType1(10),   new ValueType1(10), true},\n-            { new ValueType2(10),   new ValueType2(10), true},\n-            { new ValueType1(20),   new ValueType2(20), false},\n-            { new ValueType2(20),   new ValueType1(20), true},\n-            { new ReferenceType0(30), new ValueType1(30), true},\n-            { new ReferenceType0(30), new ValueType2(30), true},\n-            { new PrimitiveRecord(40, \"forty\"), new PrimitiveRecord(40, \"forty\"), true},\n-            { new ValueRecord(50, \"fifty\"), new ValueRecord(50, \"fifty\"), true},\n-            { new ValueOptional(LINE1), new ValueOptional(LINE1), true},\n-            { new ValueOptional(List.of(P1)), new ValueOptional(List.of(P1)), false},\n-        };\n+    static Stream<Arguments> equalsTests() {\n+        return Stream.of(\n+                Arguments.of(P1, P1, true),\n+                Arguments.of(P1, new Point(1, 2), true),\n+                Arguments.of(P1, P2, false),\n+                Arguments.of(P1, L1, false),\n+                Arguments.of(L1, new Line(1, 2, 3, 4), true),\n+                Arguments.of(L1, L2, false),\n+                Arguments.of(L1, L1, true),\n+                Arguments.of(V, new Value(P1, L1, R1, \"value\"), true),\n+                Arguments.of(V, new Value(new Point(1, 2), new Line(1, 2, 3, 4), R1, \"value\"), true),\n+                Arguments.of(V, new Value(P1, L1, new Ref(P1, L1), \"value\"), false),\n+                Arguments.of(new Value(P1, L1, R2, \"value2\"), new Value(P1, L1, new Ref(P2, null), \"value2\"), false),\n+                Arguments.of(new ValueRecord(50, \"fifty\"), new ValueRecord(50, \"fifty\"), true),\n+\n+                \/\/ reference classes containing fields of value class\n+                Arguments.of(R1, new Ref(P1, L1), false),   \/\/ identity object\n+\n+                \/\/ uninitialized default value\n+                Arguments.of(ValueClass.zeroInstance(Line.class), new Line(0, 0, 0, 0), true),\n+                Arguments.of(ValueClass.zeroInstance(Value.class), ValueClass.zeroInstance(Value.class), true),\n+                Arguments.of(new ValueOptional(L1), new ValueOptional(L1), true),\n+                Arguments.of(new ValueOptional(List.of(P1)), new ValueOptional(List.of(P1)), false)\n+        );\n@@ -157,1 +184,2 @@\n-    @Test(dataProvider=\"equalsTests\")\n+    @ParameterizedTest\n+    @MethodSource(\"equalsTests\")\n@@ -162,36 +190,13 @@\n-    @DataProvider(name=\"interfaceEqualsTests\")\n-    Object[][] interfaceEqualsTests() {\n-        return new Object[][]{\n-                { new ReferenceType0(10), new ReferenceType0(10), false, true},\n-                { new ValueType1(10),   new ValueType1(10),   true,  true},\n-                { new ValueType2(10),   new ValueType2(10),   true,  true},\n-                { new ValueType1(20),   new ValueType2(20),   false, false},\n-                { new ValueType2(20),   new ValueType1(20),   false, true},\n-                { new ReferenceType0(30), new ValueType1(30),   false, true},\n-                { new ReferenceType0(30), new ValueType2(30),   false, true},\n-        };\n-    }\n-\n-    @Test(dataProvider=\"interfaceEqualsTests\")\n-    public void testNumber(Number n1, Number n2, boolean isSubstitutable, boolean isEquals) {\n-        assertTrue((n1 == n2) == isSubstitutable);\n-        assertTrue(n1.equals(n2) == isEquals);\n-    }\n-\n-    @DataProvider(name=\"toStringTests\")\n-    Object[][] toStringTests() {\n-        return new Object[][] {\n-            { Point.makePoint(100, 200)  },\n-            { Line.makeLine(1, 2, 3, 4) },\n-            { VALUE },\n-            { VALUE1 },\n-            { new InlinableValue.Builder()\n-                        .setReference(List.of(\"ref\"))\n-                        .setNumber(new InlinableValue.IntNumber(99)).build() },\n-            \/\/ enclosing instance field `this$0` should be filtered\n-            { MyValue1.default },\n-            { new MyValue1(0,0, null) },\n-            { new MyValue1(0,0, P1) },\n-            { ValueOptional.default },\n-            { new ValueOptional(P1) },\n-        };\n+    static Stream<Arguments> toStringTests() {\n+        return Stream.of(\n+                Arguments.of(new Point(100, 200)),\n+                Arguments.of(new Line(1, 2, 3, 4)),\n+                Arguments.of(V),\n+                Arguments.of(R1),\n+                \/\/ enclosing instance field `this$0` should be filtered\n+                Arguments.of(ValueClass.zeroInstance(Value.class)),\n+                Arguments.of(new Value(P1, L1, null, null)),\n+                Arguments.of(new Value(P2, L2, new Ref(P1, null), \"value\")),\n+                Arguments.of(ValueClass.zeroInstance(ValueOptional.class)),\n+                Arguments.of(new ValueOptional(P1))\n+        );\n@@ -200,1 +205,2 @@\n-    @Test(dataProvider=\"toStringTests\")\n+    @ParameterizedTest\n+    @MethodSource(\"toStringTests\")\n@@ -207,3 +213,3 @@\n-    public void testPrimitiveRecordToString() {\n-        PrimitiveRecord o = new PrimitiveRecord(30, \"thirty\");\n-        assertEquals(o.toString(), \"PrimitiveRecord[i=30, name=thirty]\");\n+    public void testValueRecordToString() {\n+        ValueRecord o = new ValueRecord(30, \"thirty\");\n+        assertEquals(o.toString(), \"ValueRecord[i=30, name=thirty]\");\n@@ -212,2 +218,6 @@\n-    @DataProvider(name=\"hashcodeTests\")\n-    Object[][] hashcodeTests() {\n+\n+    static Stream<Arguments> hashcodeTests() {\n+        Point p = ValueClass.zeroInstance(Point.class);\n+        Line l = ValueClass.zeroInstance(Line.class);\n+        Value v = ValueClass.zeroInstance(Value.class);\n+\n@@ -215,11 +225,9 @@\n-        return new Object[][]{\n-            { P1,                   hash(PrimitiveClass.asValueType(Point.class), 1, 2) },\n-            { LINE1,                hash(PrimitiveClass.asValueType(Line.class), Point.makePoint(1, 2), Point.makePoint(3, 4)) },\n-            { VALUE,                hash(hashCodeComponents(VALUE))},\n-            { VALUE1,               hash(hashCodeComponents(VALUE1))},\n-            { Point.makePoint(0,0), hash(PrimitiveClass.asValueType(Point.class), 0, 0) },\n-            { Point.default,        hash(PrimitiveClass.asValueType(Point.class), 0, 0) },\n-            { MyValue1.default,     hash(PrimitiveClass.asValueType(MyValue1.class), Point.default, null) },\n-            { new MyValue1(0, 0, null), hash(PrimitiveClass.asValueType(MyValue1.class), Point.makePoint(0,0), null) },\n-            { new ValueOptional(P1), hash(ValueOptional.class, P1) },\n-        };\n+        return Stream.of(\n+                Arguments.of(P1, hash(Point.class, 1, 2)),\n+                Arguments.of(L1, hash(Line.class, new Point(1, 2), new Point(3, 4))),\n+                Arguments.of(V, hash(hashCodeComponents(V))),\n+                Arguments.of(new Point(0, 0), hash(Point.class, 0, 0)),\n+                Arguments.of(p, hash(Point.class, 0, 0)),\n+                Arguments.of(v, hash(Value.class, p, l, null, null)),\n+                Arguments.of(new ValueOptional(P1), hash(ValueOptional.class, P1))\n+        );\n@@ -228,1 +236,2 @@\n-    @Test(dataProvider=\"hashcodeTests\")\n+    @ParameterizedTest\n+    @MethodSource(\"hashcodeTests\")\n@@ -246,3 +255,0 @@\n-        if (PrimitiveClass.isPrimitiveClass(type)) {\n-            type = PrimitiveClass.asValueType(type);\n-        }\n@@ -260,10 +266,0 @@\n-    static primitive class MyValue1 {\n-        private Point p;\n-        private Point.ref np;\n-\n-        MyValue1(int x, int y, Point.ref np) {\n-            this.p = Point.makePoint(x, y);\n-            this.np = np;\n-        }\n-    }\n-\n@@ -275,1 +271,1 @@\n-    static class ReferenceType0 implements Number {\n+    static class ReferenceType implements Number {\n@@ -277,1 +273,1 @@\n-        public ReferenceType0(int i) {\n+        public ReferenceType(int i) {\n@@ -292,1 +288,2 @@\n-    static primitive class ValueType1 implements Number {\n+    @ImplicitlyConstructible\n+    static value class ValueType1 implements Number {\n@@ -302,1 +299,2 @@\n-    static primitive class ValueType2 implements Number {\n+    @ImplicitlyConstructible\n+    static value class ValueType2 implements Number {\n@@ -319,2 +317,11 @@\n-    static primitive record PrimitiveRecord(int i, String name) {}\n-    static value record ValueRecord(int i, String name) {}\n+    static Stream<Arguments> interfaceEqualsTests() {\n+        return Stream.of(\n+                Arguments.of(new ReferenceType(10), new ReferenceType(10), false, true),\n+                Arguments.of(new ValueType1(10),    new ValueType1(10),    true,  true),\n+                Arguments.of(new ValueType2(10),    new ValueType2(10),    true,  true),\n+                Arguments.of(new ValueType1(20),    new ValueType2(20),    false, false),\n+                Arguments.of(new ValueType2(20),    new ValueType1(20),    false, true),\n+                Arguments.of(new ReferenceType(30), new ValueType1(30),    false, true),\n+                Arguments.of(new ReferenceType(30), new ValueType2(30),    false, true)\n+        );\n+    }\n@@ -322,0 +329,6 @@\n+    @ParameterizedTest\n+    @MethodSource(\"interfaceEqualsTests\")\n+    public void testNumber(Number n1, Number n2, boolean isSubstitutable, boolean isEquals) {\n+        assertTrue((n1 == n2) == isSubstitutable);\n+        assertTrue(n1.equals(n2) == isEquals);\n+    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethods.java","additions":184,"deletions":171,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.org.objectweb.asm\n@@ -30,1 +30,1 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ObjectMethodsViaCondy\n+ * @run testng\/othervm -XX:+EnableValhalla ObjectMethodsViaCondy\n@@ -72,1 +72,1 @@\n-    public static primitive record PrimitiveRecord(int i, String name) {\n+    public static value record ValueRecord(int i, String name) {\n@@ -74,5 +74,1 @@\n-\n-        static final MethodType EQUALS_DESC = methodType(boolean.class, PrimitiveClass.asValueType(PrimitiveRecord.class), Object.class);\n-        static final MethodType HASHCODE_DESC = methodType(int.class, PrimitiveClass.asValueType(PrimitiveRecord.class));\n-        static final MethodType TO_STRING_DESC = methodType(String.class, PrimitiveClass.asValueType(PrimitiveRecord.class));\n-\n+        static final MethodType TO_STRING_DESC = methodType(String.class, ValueRecord.class);\n@@ -84,2 +80,2 @@\n-                        new Handle(H_GETFIELD, Type.getInternalName(PrimitiveRecord.class), \"i\", \"I\", false),\n-                        new Handle(H_GETFIELD, Type.getInternalName(PrimitiveRecord.class), \"name\", String.class.descriptorString(), false)\n+                        new Handle(H_GETFIELD, Type.getInternalName(ValueRecord.class), \"i\", \"I\", false),\n+                        new Handle(H_GETFIELD, Type.getInternalName(ValueRecord.class), \"name\", String.class.descriptorString(), false)\n@@ -93,1 +89,1 @@\n-         * Returns the method handle for the given method for this PrimitiveRecord class.\n+         * Returns the method handle for the given method for this ValueRecord class.\n@@ -102,1 +98,1 @@\n-            builder.bootstrapMethod(methodName, TO_STRING_DESC, PrimitiveClass.asValueType(PrimitiveRecord.class), NAME_LIST, ACCESSORS);\n+            builder.bootstrapMethod(methodName, TO_STRING_DESC, ValueRecord.class, NAME_LIST, ACCESSORS);\n@@ -113,3 +109,3 @@\n-        MethodHandle handle = PrimitiveRecord.makeBootstrapMethod(\"toString\");\n-        assertEquals((String)handle.invokeExact(new PrimitiveRecord(10, \"ten\")), \"PrimitiveRecord[i=10, name=ten]\");\n-        assertEquals((String)handle.invokeExact(new PrimitiveRecord(40, \"forty\")), \"PrimitiveRecord[i=40, name=forty]\");\n+        MethodHandle handle = ValueRecord.makeBootstrapMethod(\"toString\");\n+        assertEquals((String)handle.invokeExact(new ValueRecord(10, \"ten\")), \"ValueRecord[i=10, name=ten]\");\n+        assertEquals((String)handle.invokeExact(new ValueRecord(40, \"forty\")), \"ValueRecord[i=40, name=forty]\");\n@@ -120,3 +116,3 @@\n-        MethodHandle handle = PrimitiveRecord.makeBootstrapMethod(\"equals\");\n-        assertTrue((boolean)handle.invoke(new PrimitiveRecord(10, \"ten\"), new PrimitiveRecord(10, \"ten\")));\n-        assertFalse((boolean)handle.invoke(new PrimitiveRecord(11, \"eleven\"), new PrimitiveRecord(10, \"ten\")));\n+        MethodHandle handle = ValueRecord.makeBootstrapMethod(\"equals\");\n+        assertTrue((boolean)handle.invoke(new ValueRecord(10, \"ten\"), new ValueRecord(10, \"ten\")));\n+        assertFalse((boolean)handle.invoke(new ValueRecord(11, \"eleven\"), new ValueRecord(10, \"ten\")));\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethodsViaCondy.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ObjectNewInstance\n- * @run testng\/othervm -XX:+EnableValhalla -XX:-EnablePrimitiveClasses ObjectNewInstance\n+ * @run testng\/othervm -XX:+EnableValhalla ObjectNewInstance\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectNewInstance.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.Objects;\n-\n-public primitive class Point {\n-    static final Object STATIC_FIELD = new Object();\n-    public int x;\n-    public int y;\n-    public static Point makePoint(int x, int y) {\n-        return new Point(x, y);\n-    }\n-\n-    Point() {\n-        this.x = 10;\n-        this.y = 20;\n-    }\n-\n-    public Point(int x, int y) {\n-        this.x = x;\n-        this.y = y;\n-    }\n-\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/Point.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @summary test method handles with primitive narrowing\/widening conversion\n- * @compile -XDenablePrimitiveClasses PrimitiveTypeConversionTest.java\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses PrimitiveTypeConversionTest\n- *\/\n-\n-import java.lang.invoke.*;\n-\n-import static java.lang.invoke.MethodType.*;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-import jdk.internal.value.PrimitiveClass;\n-\n-public class PrimitiveTypeConversionTest {\n-    static primitive class Value {\n-        Point val;\n-        Point.ref ref;\n-        Value(Point p1, Point.ref p2) {\n-            this.val = p1;\n-            this.ref = p2;\n-        }\n-    }\n-\n-    static Value narrow(Value.ref v) {\n-        return v;\n-    }\n-\n-    static Value.ref widen(Value v) {\n-        if (((Object)v) == null) {\n-            throw new Error(\"should never reach here: should be caught by runtime\");\n-        }\n-        return null;\n-    }\n-\n-    static final Value VALUE = new Value(new Point(10,10), new Point(20, 20));\n-\n-    @Test\n-    public static void primitiveWidening() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh1 = lookup.findStatic(PrimitiveTypeConversionTest.class, \"narrow\", methodType(PrimitiveClass.asValueType(Value.class), Value.ref.class));\n-        MethodHandle mh2 = mh1.asType(methodType(PrimitiveClass.asValueType(Value.class), PrimitiveClass.asValueType(Value.class)));\n-        Object v = mh1.invoke(VALUE);\n-        assertEquals(v, VALUE);\n-        try {\n-            Object v1 = mh1.invoke((Object)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {}\n-\n-        try {\n-            Object v2 = mh2.invoke((Object)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {}\n-    }\n-\n-    @Test\n-    public static void primitiveNarrowing() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh = lookup.findStatic(PrimitiveTypeConversionTest.class, \"widen\", methodType(Value.ref.class, PrimitiveClass.asValueType(Value.class)));\n-        Object v = mh.invoke(VALUE);\n-        assertTrue(v == null);\n-        try {\n-            Object v1 = mh.invoke((Object)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {\n-            e.printStackTrace();\n-        }\n-        MethodHandle mh2 = mh.asType(methodType(PrimitiveClass.asValueType(Value.class), Value.ref.class));\n-        try {\n-            Value v2 = (Value) mh2.invoke((Value.ref)null);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Test\n-    public static void valToRef() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh1 = lookup.findGetter(PrimitiveClass.asValueType(Value.class), \"val\", PrimitiveClass.asValueType(Point.class));\n-        MethodHandle mh2 = mh1.asType(methodType(Point.ref.class, PrimitiveClass.asValueType(Value.class)));\n-        Value v = new Value(new Point(10,10), null);\n-\n-        Point p1 = (Point) mh1.invokeExact(VALUE);\n-        Point.ref p2 = (Point.ref) mh2.invokeExact(VALUE);\n-        assertEquals(p1, p2);\n-    }\n-\n-    @Test\n-    public static void refToVal() throws Throwable {\n-        MethodHandle mh1 = MethodHandles.lookup().findGetter(PrimitiveClass.asValueType(Value.class), \"ref\", Point.ref.class);\n-        MethodHandle mh2 = mh1.asType(methodType(PrimitiveClass.asValueType(Point.class), PrimitiveClass.asValueType(Value.class)));\n-        Point.ref p1 = (Point.ref) mh1.invokeExact(VALUE);\n-        Point p2 = (Point) mh2.invokeExact(VALUE);\n-        assertEquals(p1, p2);\n-    }\n-\n-    @Test\n-    public static void valToRef1() throws Throwable {\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        MethodHandle mh1 = lookup.findGetter(PrimitiveClass.asValueType(Value.class), \"val\", PrimitiveClass.asValueType(Point.class));\n-        MethodHandle mh2 = mh1.asType(methodType(PrimitiveClass.asValueType(Point.class), Value.ref.class));\n-\n-        Point p1 = (Point) mh1.invokeExact(VALUE);\n-        Point p2 = (Point) mh2.invoke(VALUE);\n-        Point p3 = (Point) mh2.invokeExact((Value.ref)VALUE);\n-        assertEquals(p1, p2);\n-        assertEquals(p1, p3);\n-    }\n-\n-    @Test\n-    public static void refToVal1() throws Throwable {\n-        MethodHandle mh1 = MethodHandles.lookup().findGetter(PrimitiveClass.asValueType(Value.class), \"ref\", Point.ref.class);\n-        MethodHandle mh2 = mh1.asType(methodType(Point.ref.class, Value.ref.class));\n-        Value v = new Value(new Point(10,10), null);\n-\n-        Point.ref p1 = (Point.ref) mh1.invokeExact(v);\n-        Point.ref p2 = (Point.ref) mh2.invoke(v);\n-        Point.ref p3 = (Point.ref) mh2.invokeExact((Value.ref)v);\n-        assertEquals(p1, p2);\n-        assertEquals(p1, p3);\n-    }\n-\n-    @Test\n-    public static void refToVal2() throws Throwable {\n-        MethodHandle mh1 = MethodHandles.lookup().findGetter(PrimitiveClass.asValueType(Value.class), \"ref\", Point.ref.class);\n-        MethodHandle mh2 = mh1.asType(methodType(PrimitiveClass.asValueType(Point.class), PrimitiveClass.asValueType(Value.class)));\n-        Value v = new Value(new Point(10,10), null);\n-\n-        Point.ref p1 = (Point.ref) mh1.invokeExact(v);\n-        try {\n-            Point p2 = (Point) mh2.invokeExact(v);\n-            fail(\"Expected NullPointerException but not thrown\");\n-        } catch (NullPointerException e) {}\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/PrimitiveTypeConversionTest.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ProxyTest\n+ * @run testng\/othervm -XX:+EnableValhalla ProxyTest\n@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -45,1 +46,2 @@\n-    static primitive class P {\n+    @ImplicitlyConstructible\n+    static value class P {\n","filename":"test\/jdk\/valhalla\/valuetypes\/ProxyTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,198 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test core reflection, dynamic proxy and lambdas that generates\n- *          classes dynamically that reference Q-type and L-type\n- * @compile -XDenablePrimitiveClasses QTypeDescriptorTest.java\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses QTypeDescriptorTest\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Dsun.reflect.noInflation=true QTypeDescriptorTest\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.*;\n-import java.util.function.*;\n-\n-import jdk.internal.value.PrimitiveClass;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class QTypeDescriptorTest {\n-    static final Point P0 = Point.makePoint(10, 20);\n-    static final Point P1 = Point.makePoint(30, 40);\n-    static final NonFlattenValue NFV = NonFlattenValue.make(30, 40);\n-\n-    @Test\n-    public void testLambda() {\n-        newArray(Point[]::new, 2);\n-        newArray(Point[][]::new, 1);\n-\n-        newArray(NonFlattenValue[]::new, 3);\n-        newArray(MutablePath[]::new, 4);\n-\n-        Function<Point[], T> f =\n-            (points) -> { return new T(points); };\n-        f.apply(new Point[] { P0, P1});\n-    }\n-\n-    @Test\n-    public void testMethodInvoke() throws Exception {\n-        Class<?> pointQType = PrimitiveClass.asValueType(Point.class);\n-        Class<?> nonFlattenValueQType = PrimitiveClass.asValueType(NonFlattenValue.class);\n-        Method m = QTypeDescriptorTest.class\n-            .getDeclaredMethod(\"toLine\", pointQType, nonFlattenValueQType);\n-        makeLine(m, P0, NFV);\n-\n-        m = QTypeDescriptorTest.class\n-                .getDeclaredMethod(\"toLine\", Point[].class);\n-        makeLine(m, (Object) new Point[] { P0, P1});\n-    }\n-\n-    private static void makeLine(Method m, Object... args) throws Exception {\n-        Line l = (Line) m.invoke(null, args);\n-        assertEquals(l.p1, P0);\n-        assertEquals(l.p2, NFV.pointValue());\n-    }\n-\n-    @Test\n-    public void testStaticMethod() throws Throwable {\n-        \/\/ static method in a primitive class with no parameter and void return type\n-        Runnable r = () -> ValueTest.run();\n-        r.run();\n-\n-        \/\/ via Method::invoke\n-        Method m = ValueTest.class.getMethod(\"run\");\n-        m.invoke(null);\n-\n-        \/\/ via MethodHandle\n-        MethodHandle mh = MethodHandles.lookup()\n-            .findStatic(ValueTest.class, \"run\", MethodType.methodType(void.class));\n-        mh.invokeExact();\n-\n-        mh = MethodHandles.lookup().unreflect(m);\n-        mh.invokeExact();\n-    }\n-\n-    @Test\n-    public void testConstructor() throws Exception {\n-        Constructor<T> ctor = T.class.getDeclaredConstructor(Point[].class);\n-        Point[] points = new Point[] { P0, P1 };\n-        T test = (T) ctor.newInstance((Object)points);\n-        assertEquals(test.points[0], P0);\n-        assertEquals(test.points[1], P1);\n-    }\n-\n-    @DataProvider\n-    static Object[][] descriptors() {\n-        return new Object[][]{\n-            { QTypeDescriptorTest.class, \"toLine\", new Class<?>[] { PrimitiveClass.asValueType(Point.class), PrimitiveClass.asValueType(NonFlattenValue.class)},     true},\n-            { QTypeDescriptorTest.class, \"toLine\", new Class<?>[] { Point.ref.class, PrimitiveClass.asValueType(NonFlattenValue.class)}, false},\n-            { QTypeDescriptorTest.class, \"toLine\", new Class<?>[] { Point[].class },                         true},\n-            { PrimitiveClass.asValueType(NonFlattenValue.class), \"point\",      null,                                                     true},\n-            { PrimitiveClass.asValueType(NonFlattenValue.class), \"pointValue\", null,                                                     true},\n-            { PrimitiveClass.asValueType(NonFlattenValue.class), \"has\",        new Class<?>[] { PrimitiveClass.asValueType(Point.class), Point.ref.class},           true},\n-            { PrimitiveClass.asValueType(NonFlattenValue.class), \"has\",        new Class<?>[] { PrimitiveClass.asValueType(Point.class), PrimitiveClass.asValueType(Point.class)},               false},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"descriptors\")\n-    public void testDescriptors(Class<?> defc, String name, Class<?>[] params, boolean found) throws Exception {\n-        try {\n-            defc.getDeclaredMethod(name, params);\n-            if (!found) throw new AssertionError(\"Expected NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n-            if (found) throw e;\n-        }\n-    }\n-\n-    @DataProvider\n-    static Object[][] methodTypes() {\n-        ClassLoader loader = QTypeDescriptorTest.class.getClassLoader();\n-        return new Object[][]{\n-            { \"point\",      MethodType.methodType(Point.ref.class),                                      true },\n-            { \"pointValue\", MethodType.methodType(PrimitiveClass.asValueType(Point.class)),                                          true },\n-            { \"has\",        MethodType.methodType(boolean.class, PrimitiveClass.asValueType(Point.class), Point.ref.class),          true },\n-            { \"point\",      MethodType.methodType(PrimitiveClass.asValueType(Point.class)),                                          false },\n-            { \"pointValue\", MethodType.methodType(Point.ref.class),                                      false },\n-            { \"has\",        MethodType.methodType(boolean.class, Point.ref.class, PrimitiveClass.asValueType(Point.class)),          false },\n-            { \"point\",      MethodType.fromMethodDescriptorString(\"()LPoint;\", loader),        true },\n-            { \"point\",      MethodType.fromMethodDescriptorString(\"()QPoint;\", loader),        false },\n-            { \"pointValue\", MethodType.fromMethodDescriptorString(\"()QPoint;\", loader),        true },\n-            { \"pointValue\", MethodType.fromMethodDescriptorString(\"()LPoint;\", loader),        false },\n-            { \"has\",        MethodType.fromMethodDescriptorString(\"(QPoint;LPoint;)Z\", loader),true },\n-            { \"has\",        MethodType.fromMethodDescriptorString(\"(LPoint;LPoint;)Z\", loader),false },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"methodTypes\")\n-    public void methodHandleLookup(String name, MethodType mtype, boolean found) throws Throwable {\n-        try {\n-            MethodHandles.lookup().findVirtual(PrimitiveClass.asValueType(NonFlattenValue.class), name, mtype);\n-            if (!found) throw new AssertionError(\"Expected NoSuchMethodException\");\n-        } catch (NoSuchMethodException e) {\n-            if (found) throw e;\n-        }\n-    }\n-\n-    private static <T> T[] newArray(IntFunction<T[]> arrayCreator, int size) {\n-        return arrayCreator.apply(size);\n-    }\n-\n-    private static Line toLine(Point p, NonFlattenValue nfv) {\n-        return Line.makeLine(p, nfv.pointValue());\n-    }\n-\n-    private static Line toLine(Point[] points) {\n-        assertTrue(points.length == 2);\n-        return Line.makeLine(points[0], points[1]);\n-    }\n-\n-    static class T {\n-        final Point[] points;\n-        T(Point[] points) {\n-            this.points = points;\n-        }\n-    }\n-\n-    interface I {\n-        Line toLine(Point p, NonFlattenValue nfv);\n-    }\n-\n-    static primitive class ValueTest {\n-        private final int value;\n-        public ValueTest() { this.value = 0; }\n-\n-        public static void run() {\n-            Runnable r = () -> {\n-                System.out.println(\"called ValueTest::run\");\n-            };\n-            r.run();\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/QTypeDescriptorTest.java","additions":0,"deletions":198,"binary":false,"changes":198,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,3 @@\n- * @summary test reflection on primitive classes\n- * @compile --enable-preview --source ${jdk.version} -XDenablePrimitiveClasses Reflection.java\n- * @run testng\/othervm --enable-preview -XX:+EnableValhalla -XX:+EnablePrimitiveClasses Reflection\n+ * @summary test core reflection on value classes\n+ * @compile -XDenablePrimitiveClasses Reflection.java\n+ * @run junit\/othervm -XX:+EnableValhalla Reflection\n@@ -32,1 +32,1 @@\n-import java.lang.constant.ClassDesc;\n+import java.lang.reflect.Array;\n@@ -35,0 +35,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -36,1 +37,2 @@\n-import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n@@ -38,4 +40,7 @@\n-import jdk.internal.value.PrimitiveClass;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -44,12 +49,5 @@\n-    @Test\n-    public static void testPointClass() throws Exception  {\n-        Object o = PrimitiveClass.asValueType(Point.class).newInstance();\n-        assertEquals(o.getClass(), PrimitiveClass.asPrimaryType(Point.class));\n-\n-        Constructor<?> ctor = Point.class.getDeclaredConstructor(int.class, int.class);\n-        o = ctor.newInstance(20, 30);\n-        assertEquals(o.getClass(), PrimitiveClass.asPrimaryType(Point.class));\n-\n-        Field field = Point.class.getField(\"x\");\n-        if (field.getInt(o) != 20) {\n-            fail(\"Unexpected Point.x value: \" +  field.getInt(o));\n+    @ImplicitlyConstructible\n+    static value class V {\n+        int x;\n+        V(int x) {\n+            this.x = x;\n@@ -57,12 +55,0 @@\n-        try {\n-            field.setInt(o, 100);\n-            fail(\"IllegalAccessException not thrown\");\n-        } catch (IllegalAccessException e) {}\n-\n-        \/\/ final static field in a primitive class\n-        Field f = Point.class.getDeclaredField(\"STATIC_FIELD\");\n-        assertTrue(f.getType() == Object.class);\n-        \/\/ accessible but no write access\n-        f.trySetAccessible();\n-        assertTrue(f.isAccessible());\n-        checkToString(f);\n@@ -71,6 +57,13 @@\n-    @Test\n-    public static void testLineClass() throws Exception {\n-        checkInstanceField(PrimitiveClass.asValueType(Line.class), \"p1\", PrimitiveClass.asValueType(Point.class));\n-        checkInstanceField(PrimitiveClass.asValueType(Line.class), \"p2\", PrimitiveClass.asValueType(Point.class));\n-        checkInstanceMethod(PrimitiveClass.asValueType(Line.class), \"p1\", PrimitiveClass.asValueType(Point.class));\n-        checkInstanceMethod(PrimitiveClass.asValueType(Line.class), \"p2\", PrimitiveClass.asValueType(Point.class));\n+    @ImplicitlyConstructible\n+    static value class Value {\n+        @NullRestricted\n+        V v1;\n+        V v2;\n+        Value(V v1, V v2) {\n+            this.v1 = v1;\n+            this.v2 = v2;\n+        }\n+\n+        static Value newValue(V v1, V v2) {\n+            return new Value(v1, v2);\n+        }\n@@ -80,5 +73,5 @@\n-    public static void testNonFlattenValue() throws Exception {\n-        checkInstanceField(PrimitiveClass.asValueType(NonFlattenValue.class), \"nfp\", Point.ref.class);\n-        checkInstanceMethod(PrimitiveClass.asValueType(NonFlattenValue.class), \"pointValue\", PrimitiveClass.asValueType(Point.class));\n-        checkInstanceMethod(PrimitiveClass.asValueType(NonFlattenValue.class), \"point\", Point.ref.class);\n-        checkInstanceMethod(PrimitiveClass.asValueType(NonFlattenValue.class), \"has\", boolean.class, PrimitiveClass.asValueType(Point.class), Point.ref.class);\n+    void testNewInstance() throws Exception {\n+        V v = new V(10);\n+        Constructor<Value> ctor = Value.class.getDeclaredConstructor(V.class, V.class);\n+        Value o = ctor.newInstance(v, v);\n+        assertEquals(o.getClass(), Value.class);\n@@ -88,5 +81,5 @@\n-    public static void testValueOptionalClass() throws Exception  {\n-        Point point = Point.makePoint(10,20);\n-        Constructor<ValueOptional> ctor = ValueOptional.class.getDeclaredConstructor(Object.class);\n-        ValueOptional o = ctor.newInstance(point);\n-        assertEquals(o.getClass(), ValueOptional.class);\n+    void testAccess() throws Exception {\n+        Field field = Value.class.getDeclaredField(\"v1\");\n+        V v = new V(10);\n+        Value o = new Value(v, null);\n+        assertEquals(v, field.get(o));\n@@ -94,1 +87,0 @@\n-        Field field = ValueOptional.class.getDeclaredField(\"o\");\n@@ -96,1 +88,1 @@\n-        field.trySetAccessible();\n+        assertTrue(field.trySetAccessible());\n@@ -98,10 +90,1 @@\n-\n-        if (field.get(o) != point) {\n-            fail(\"Unexpected ValueOptional.o value: \" +  field.get(o));\n-        }\n-        try {\n-            field.set(o, point);\n-            fail(\"IllegalAccessException not thrown\");\n-        } catch (IllegalAccessException e) {}\n-\n-        checkToString(field);\n+        assertThrows(IllegalAccessException.class, () -> field.set(o, v));\n@@ -110,4 +93,5 @@\n-    static void checkInstanceField(Class<?> declaringClass, String name, Class<?> type) throws Exception {\n-        Field f = declaringClass.getDeclaredField(name);\n-        assertTrue(f.getType() == type);\n-        checkToString(f);\n+    @Test\n+    void testNullRestricted() throws Exception {\n+        Method m = Value.class.getDeclaredMethod(\"newValue\", V.class, V.class);\n+        Throwable t = assertThrows(InvocationTargetException.class, () -> m.invoke(null, new Object[] {null, null}));\n+        assertEquals(NullPointerException.class, t.getCause().getClass());\n@@ -116,5 +100,6 @@\n-    static void checkInstanceMethod(Class<?> declaringClass,String name, Class<?> returnType, Class<?>... params) throws Exception {\n-        Method m = declaringClass.getDeclaredMethod(name, params);\n-        assertTrue(m.getReturnType() == returnType);\n-        checkToString(m);\n-    }\n+    \/*\n+     * TODO: null-restricted value class array\n+     *\/\n+    static Stream<Arguments> arrays() {\n+        V v1 = new V(10);\n+        V v2 = new V(20);\n@@ -122,18 +107,7 @@\n-    static void checkToString(Field f) {\n-        StringBuilder sb = new StringBuilder();\n-        int mods = f.getModifiers();\n-        if (Modifier.isPublic(mods)) {\n-            sb.append(\"public\").append(\" \");\n-        }\n-        if (Modifier.isPrivate(mods)) {\n-            sb.append(\"private\").append(\" \");\n-        }\n-        if (Modifier.isStatic(mods)) {\n-            sb.append(\"static\").append(\" \");\n-        }\n-        if (Modifier.isFinal(mods)) {\n-            sb.append(\"final\").append(\" \");\n-        }\n-        sb.append(displayName(f.getType())).append(\" \");\n-        sb.append(f.getDeclaringClass().getName()).append(\".\").append(f.getName());\n-        assertEquals(f.toString(), sb.toString());\n+        V[] varray = new V[] { v1, v2 };\n+        Value[] valuearray = new Value[] { new Value(v1, v2), new Value(v1, null)};\n+\n+        return Stream.of(\n+                Arguments.of(V[].class, varray, false),\n+                Arguments.of(Value[].class, valuearray, false)\n+        );\n@@ -142,8 +116,15 @@\n-    static void checkToString(Method m) {\n-        StringBuilder sb = new StringBuilder();\n-        int mods = m.getModifiers();\n-        if (Modifier.isPublic(mods)) {\n-            sb.append(\"public\").append(\" \");\n-        }\n-        if (Modifier.isStatic(mods)) {\n-            sb.append(\"static\").append(\" \");\n+    \/**\n+     * Setting the elements of an array.\n+     * NPE will be thrown if null is set on an element in a null-restricted value class array\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arrays\")\n+    public void testArrays(Class<?> arrayClass, Object[] array, boolean nullRestricted) {\n+        Class<?> componentType = arrayClass.getComponentType();\n+        assertTrue(arrayClass.isArray());\n+        Object[] newArray = (Object[]) Array.newInstance(componentType, array.length);\n+        assertTrue(newArray.getClass().getComponentType() == componentType);\n+\n+        \/\/ set elements\n+        for (int i = 0; i < array.length; i++) {\n+            Array.set(newArray, i, array[i]);\n@@ -151,2 +132,3 @@\n-        if (Modifier.isFinal(mods)) {\n-            sb.append(\"final\").append(\" \");\n+        for (int i = 0; i < array.length; i++) {\n+            Object o = Array.get(newArray, i);\n+            assertEquals(o, array[i]);\n@@ -154,8 +136,9 @@\n-        sb.append(displayName(m.getReturnType())).append(\" \");\n-        sb.append(m.getDeclaringClass().getName()).append(\".\").append(m.getName());\n-        sb.append(\"(\");\n-        int count = m.getParameterCount();\n-        for (Class<?> ptype : m.getParameterTypes()) {\n-            sb.append(displayName(ptype));\n-            if (--count > 0) {\n-                sb.append(\",\");\n+        Arrays.setAll(newArray, i -> array[i]);\n+\n+        for (int i = 0; i < newArray.length; i++) {\n+            \/\/ test nullable\n+            if (nullRestricted) {\n+                final int index = i;\n+                assertThrows(NullPointerException.class, () -> Array.set(newArray, index, null));\n+            } else {\n+                Array.set(newArray, i, null);\n@@ -164,10 +147,0 @@\n-        sb.append(\")\");\n-        assertEquals(m.toString(), sb.toString());\n-    }\n-\n-    static String displayName(Class<?> type) {\n-        if (type.isPrimitive()) {\n-            ClassDesc classDesc = type.describeConstable().get();\n-            return classDesc.displayName();\n-        }\n-        return type.getTypeName();\n","filename":"test\/jdk\/valhalla\/valuetypes\/Reflection.java","additions":90,"deletions":117,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -1,206 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @summary test MethodHandle of static vnew factories\n- * @compile -XDenablePrimitiveClasses StaticFactoryMethodHandleTest.java\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses StaticFactoryMethodHandleTest\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleInfo;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodHandles.Lookup;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-\n-import jdk.internal.value.PrimitiveClass;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import static java.lang.invoke.MethodType.*;\n-import static org.testng.Assert.*;\n-\n-public class StaticFactoryMethodHandleTest {\n-    static interface Cons {};\n-\n-    static primitive class DefaultConstructor implements Cons {\n-        int x = 0;\n-    }\n-    static primitive class ConstructorWithArgs implements Cons {\n-        int x;\n-        int y;\n-        public ConstructorWithArgs(int x) {\n-            this.x = x;\n-            this.y = 100;\n-        }\n-\n-        \/* package-private *\/ ConstructorWithArgs(int x, int y) {\n-            this.x = x;\n-            this.y = y;\n-        }\n-\n-        private ConstructorWithArgs(int x, int y, int z) {\n-            this.x = x+z;\n-            this.y = y+z;\n-        }\n-    }\n-    static value class Value implements Cons {\n-        int x;\n-        public Value(int x) {\n-            this.x = x;\n-        }\n-    }\n-\n-    \/*\n-     * Test no-arg static factory\n-     *\/\n-    @Test\n-    public void testNoArgStaticFactory() throws Throwable {\n-        \/\/ test default static vnew factory\n-        Class<? extends Cons> cls = (Class<? extends Cons>)PrimitiveClass.asValueType(DefaultConstructor.class);\n-        MethodHandle mh = staticValueFactory(cls, methodType(cls));\n-        DefaultConstructor o = (DefaultConstructor)mh.invokeExact();\n-        assertEquals(o, new DefaultConstructor());\n-        assertEquals(o, newInstance(cls, 0, new Class<?>[0]));\n-    }\n-\n-    @DataProvider(name=\"ctorWithArgs\")\n-    static Object[][] ctorWithArgs() {\n-        Class<? extends Cons> cls = (Class<? extends Cons>)PrimitiveClass.asValueType(ConstructorWithArgs.class);\n-        return new Object[][]{\n-                new Object[] { cls, methodType(cls, int.class), Modifier.PUBLIC, new ConstructorWithArgs(1) },\n-                new Object[] { cls, methodType(cls, int.class, int.class), 0, new ConstructorWithArgs(1, 2) },\n-                new Object[] { cls, methodType(cls, int.class, int.class, int.class), Modifier.PRIVATE, new ConstructorWithArgs(1, 2, 3) },\n-        };\n-    }\n-\n-    \/*\n-     * Test static factory with args\n-     *\/\n-    @Test(dataProvider=\"ctorWithArgs\")\n-    public void testStaticFactoryWithArgs(Class<? extends Cons> c, MethodType mtype, int modifiers, ConstructorWithArgs o) throws Throwable {\n-        MethodHandle mh = staticValueFactory(c, mtype);\n-        ConstructorWithArgs o1;\n-        Object o2;\n-        switch (mtype.parameterCount()) {\n-            case 1: o1 = (ConstructorWithArgs)mh.invokeExact(1);\n-                    o2 = newInstance(c, modifiers, mtype.parameterArray(), 1);\n-                    break;\n-            case 2: o1 = (ConstructorWithArgs)mh.invokeExact(1, 2);\n-                    o2 = newInstance(c, modifiers, mtype.parameterArray(), 1, 2);\n-                    break;\n-            case 3: o1 = (ConstructorWithArgs)mh.invokeExact(1, 2, 3);\n-                    o2 = newInstance(c, modifiers, mtype.parameterArray(), 1, 2, 3);\n-                    break;\n-            default:\n-                    throw new IllegalArgumentException(c + \" \" + mtype);\n-        }\n-\n-        assertEquals(o1, o);\n-        assertEquals(o1, o2);\n-    }\n-\n-    @Test\n-    public void testValueClasstaticFactory() throws Throwable {\n-        \/\/ test default static value class factory\n-        MethodType mtype = methodType(Value.class, int.class);\n-        MethodHandle mh = staticValueFactory(Value.class, mtype);\n-        Value o = (Value)mh.invokeExact(10);\n-        assertEquals(o, new Value(10));\n-        assertEquals(o, newInstance(Value.class, Modifier.PUBLIC, mtype.parameterArray(), 10));\n-    }\n-\n-    \/*\n-     * Test the following API when looking up a static value class factory method\n-     *\n-     * 1. Lookup::findStatic accepts \"<vnew>\" to lookup a static value class factory method\n-     * 2. Lookup::findConstructor is for invokespecial <init> constructor bytecode pattern\n-     *    i.e. the instance <init> constructor.\n-     *    Hence it won't find the static <vnew> factory.\n-     * 3. Lookup::revealDirect cracks the method handle info\n-     *\/\n-    static MethodHandle staticValueFactory(Class<? extends Cons> c, MethodType mtype) throws Throwable {\n-        Lookup lookup = MethodHandles.lookup();\n-        \/\/\n-        MethodHandle mh = lookup.findStatic(c, \"<vnew>\", mtype);\n-        try {\n-            lookup.findConstructor(PrimitiveClass.asValueType(DefaultConstructor.class), mtype);\n-            throw new RuntimeException(\"findConstructor should not find the static init factory\");\n-        } catch (NoSuchMethodException e) {\n-        }\n-\n-        \/\/ crack method handle\n-        MethodHandleInfo minfo = lookup.revealDirect(mh);\n-        assertEquals(minfo.getDeclaringClass(), PrimitiveClass.asPrimaryType(c));\n-        assertEquals(minfo.getName(), \"<vnew>\");\n-        assertEquals(minfo.getReferenceKind(), MethodHandleInfo.REF_invokeStatic);\n-        assertEquals(minfo.getMethodType(), mtype);\n-        return mh;\n-    }\n-\n-    \/*\n-     * Test unreflectConstructor and also generic invoke\n-     *\/\n-    static Cons newInstance(Class<? extends Cons> c, int mods, Class<?>[] params, int... args) throws Throwable {\n-        \/\/ get Constructor from getConstructor\/getDeclaredConstructor\n-        Constructor<? extends Cons> ctor;\n-        if (Modifier.isPublic(mods)) {\n-            ctor = c.getConstructor(params);\n-        } else {\n-            ctor = c.getDeclaredConstructor(params);\n-        }\n-\n-        \/\/ unreflect constructor\n-        MethodHandle mh = MethodHandles.lookup().unreflectConstructor(ctor);\n-        assertEquals(params.length, args.length);\n-        Cons o1, o2;\n-        switch (args.length) {\n-            case 0:\n-                o1 = (Cons) mh.invoke();\n-                o2 = ctor.newInstance();\n-                break;\n-            case 1:\n-                o1 = (Cons) mh.invoke(args[0]);\n-                o2 = ctor.newInstance(args[0]);\n-                break;\n-            case 2:\n-                o1 = (Cons) mh.invoke(args[0], args[1]);\n-                o2 = ctor.newInstance(args[0], args[1]);\n-                break;\n-            case 3:\n-                o1 = (Cons) mh.invoke(args[0], args[1], args[2]);\n-                o2 = ctor.newInstance(args[0], args[1], args[2]);\n-                break;\n-            default:\n-                throw new IllegalArgumentException(Arrays.toString(args));\n-        }\n-        assertEquals(o1, o2);\n-        return o1;\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryMethodHandleTest.java","additions":0,"deletions":206,"binary":false,"changes":206,"status":"deleted"},{"patch":"@@ -1,208 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @bug 8273360\n- * @summary Test reflection of constructors for value classes\n- * @compile -XDenablePrimitiveClasses StaticFactoryTest.java\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses StaticFactoryTest\n- *\/\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import jdk.internal.value.PrimitiveClass;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public final identity class StaticFactoryTest {\n-    \/\/ Target test class\n-\n-    static identity class SimpleIdentity {\n-        public final int x;\n-\n-        SimpleIdentity() {\n-            x = -1;\n-        }\n-\n-        public SimpleIdentity(int x) {\n-            this.x = x;\n-        }\n-    }\n-\n-    static primitive class SimplePrimitive {\n-        public final int x;\n-\n-        SimplePrimitive() {\n-            x = -1;\n-        }\n-\n-        public SimplePrimitive(int x) {\n-            this.x = x;\n-        }\n-    }\n-\n-    static value class SimpleValue {\n-        private final SimplePrimitive v;\n-\n-        SimpleValue() {\n-            this.v = SimplePrimitive.default;\n-        }\n-\n-        public SimpleValue(SimplePrimitive v) {\n-            this.v = v;\n-        }\n-    }\n-\n-    @DataProvider\n-    static Object[][] classes() {\n-        return new Object[][]{\n-                new Object[] { SimpleIdentity.class, true, false, false },\n-                new Object[] { SimplePrimitive.class, false, true, true },\n-                new Object[] { SimpleValue.class, false, true, false },\n-                new Object[] { InterfaceWithNested.IdentityClass.class, true, false, false },\n-                new Object[] { InterfaceWithNested.ValueClass.class, false, true, false },\n-                new Object[] { InterfaceWithNested.PrimitiveClass.class, false, true, true },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"classes\")\n-    public void testConstructor(Class<?> c, boolean isIdentityClass,\n-                                boolean isValueClass, boolean isPrimitiveClass)\n-            throws ReflectiveOperationException\n-    {\n-        String cn = c.getName();\n-        Class<?> clz = Class.forName(cn);\n-        System.out.printf(\"cn: %s, mod: 0x%04X%n\", cn, c.getModifiers());\n-\n-        assertEquals(clz.isIdentity(), isIdentityClass, \"identity class: \" + clz);\n-        assertEquals(clz.isValue(), isValueClass, \"value class: \" + clz);\n-        assertEquals(PrimitiveClass.isPrimitiveClass(clz), isPrimitiveClass, \"primitive class: \" + clz);\n-\n-        Constructor<?> ctor = clz.getDeclaredConstructor();\n-        Object o = ctor.newInstance();\n-        assertTrue(o.getClass() == c);\n-\n-        \/\/ Verify that the constructor and field can be set accessible\n-        ctor.setAccessible(true);\n-        assertTrue(ctor.trySetAccessible());\n-\n-        \/\/ Check that getDeclaredMethods does not include the static factory method\n-        Method[] methods = clz.getDeclaredMethods();\n-        for (Method m : methods) {\n-            if (Modifier.isStatic(m.getModifiers()) && \"<init>\".equals(m.getName())) {\n-                assertTrue(isIdentityClass, \"<init> method is not in an identity class\");\n-            }\n-        }\n-    }\n-\n-\n-    interface SimpleInterface {}\n-\n-    identity interface SimpleIdentityInterface {} \/\/ Illegal class modifiers from VM\n-\n-    value interface SimpleValueInterface {}\n-\n-    interface InterfaceWithNested {\n-        identity class IdentityClass {}\n-        value class ValueClass {}\n-        primitive class PrimitiveClass {}\n-    }\n-\n-    @DataProvider\n-    static Object[][] interfaces() {\n-        return new Object[][]{\n-                new Object[] { SimpleInterface.class, false, false, true },\n-                new Object[] { SimpleIdentityInterface.class, true, false, true },  \/\/ VM throws\n-                new Object[] { SimpleValueInterface.class, false, true, true },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"interfaces\")\n-    public void testInterfaces(Class<?> c, boolean isIdentityClass,\n-                                boolean isValueClass, boolean isAbstract) throws ReflectiveOperationException {\n-        String cn = c.getName();\n-        Class<?> clz = Class.forName(cn);\n-        System.out.printf(\"cn: %s, mod: 0x%04X%n\", cn, c.getModifiers());\n-\n-        assertEquals(clz.isIdentity(), isIdentityClass, \"identity class: \" + clz);\n-        assertEquals(clz.isValue(), isValueClass, \"value class: \" + clz);\n-        assertEquals(Modifier.isAbstract(clz.getModifiers()), isAbstract, \"abstract: \" + clz);\n-    }\n-\n-        @DataProvider\n-    static Object[][] ctors() {\n-        return new Object[][]{\n-                new Object[] { SimplePrimitive.class, Set.of(\"public StaticFactoryTest$SimplePrimitive(int)\",\n-                                                             \"StaticFactoryTest$SimplePrimitive()\")},\n-                new Object[] { SimpleValue.class, Set.of(\"public StaticFactoryTest$SimpleValue(StaticFactoryTest$SimplePrimitive)\",\n-                                                         \"StaticFactoryTest$SimpleValue()\") },\n-        };\n-    }\n-\n-    \/\/ Check that the class has the expected Constructors\n-    @Test(dataProvider = \"ctors\")\n-    public static void constructors(Class<?> c, Set<String> signatures) throws ReflectiveOperationException {\n-        Constructor<?>[] cons = c.getDeclaredConstructors();\n-        Set<String> actualSig = Arrays.stream(cons).map(Constructor::toString)\n-                                      .collect(Collectors.toSet());\n-        boolean ok = signatures.equals(actualSig);\n-        if (!ok) {\n-            System.out.printf(\"expected: %s%n\", signatures);\n-            System.out.printf(\"declared: %s%n\", actualSig);\n-            assertTrue(ok);\n-        }\n-    }\n-\n-    @DataProvider\n-    static Object[][] fields() throws ReflectiveOperationException {\n-        return new Object[][]{\n-                new Object[] { SimplePrimitive.class.getDeclaredField(\"x\"), new SimplePrimitive(), 200},\n-                new Object[] { SimpleValue.class.getDeclaredField(\"v\"), new SimpleValue(), new SimplePrimitive(10) },\n-        };\n-    }\n-\n-    \/\/ Check that the final field cannot be modified\n-    @Test(dataProvider = \"fields\", expectedExceptions = IllegalAccessException.class)\n-    public static void readOnlyFields(Field field, Object obj, Object newValue) throws ReflectiveOperationException {\n-        \/\/ succeeds to set accessible flag\n-        field.setAccessible(true);\n-        assertTrue(field.trySetAccessible());\n-\n-        \/\/ value class' final fields cannot be modified\n-        if (field.getType() == int.class) {\n-            field.setInt(obj, ((Integer) newValue).intValue());\n-        } else {\n-            field.set(obj, newValue);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/StaticFactoryTest.java","additions":0,"deletions":208,"binary":false,"changes":208,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary Basic test for Array::get, Array::set, Arrays::setAll on primitive class array\n+ * @summary Basic stream tests to iterate on nullable and null-restricted values\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses StreamTest\n+ * @run junit\/othervm -XX:+EnableValhalla StreamTest\n@@ -31,1 +31,2 @@\n-import org.testng.annotations.Test;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -37,1 +38,2 @@\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -40,0 +42,48 @@\n+\n+    static value class X {\n+        int x;\n+        X(int x) {\n+            this.x = x;\n+        }\n+        int x() {\n+            return x;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class Point {\n+        public int x;\n+        public int y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class Value {\n+        int i;\n+        @NullRestricted\n+        Point p;\n+        Point nullable;\n+        List<X> list;\n+        Value(int i, Point\/* Point! *\/ p, Point np, List<X> list) {\n+            this.i = i;\n+            this.p = p;\n+            this.nullable = np;\n+            this.list = list;\n+        }\n+\n+        Point point() {\n+            return p;\n+        }\n+\n+        Point nullablePoint() {\n+            return nullable;\n+        }\n+\n+        int getI() { return i; }\n+\n+        List<X> list() { return list; }\n+    }\n+\n@@ -44,1 +94,3 @@\n-            values[i] = new Value(i, new Point(i,i*2), (i%2) == 0 ? null : new Point(i*10, i*20),\n+            values[i] = new Value(i,\n+                                  new Point(i,i*2),\n+                                  (i%2) == 0 ? null : new Point(i*10, i*20),\n@@ -51,1 +103,1 @@\n-    public void testPrimitive() {\n+    public void testValues() {\n@@ -58,1 +110,1 @@\n-    public void testValueType() {\n+    public void testNullRestrictedType() {\n@@ -60,1 +112,1 @@\n-                .map(Value.ref::point)\n+                .map(Value::point)\n@@ -64,0 +116,4 @@\n+    }\n+\n+    @Test\n+    public void testNullableValueType() {\n@@ -65,1 +121,1 @@\n-                .map(Value.ref::nullablePoint)\n+                .map(Value::nullablePoint)\n@@ -72,3 +128,3 @@\n-        Stream<Point.ref> stream = Arrays.stream(values)\n-                                         .filter(v -> (v.getI() % 2) == 0)\n-                                         .map(Value.ref::point);\n+        Stream<Point> stream = Arrays.stream(values)\n+                                     .filter(v -> (v.getI() % 2) == 0)\n+                                     .map(Value::point);\n@@ -79,1 +135,1 @@\n-    public void testValue() {\n+    public void testListOfValues() {\n@@ -81,1 +137,1 @@\n-                           .map(Value.ref::list)\n+                           .map(Value::list)\n@@ -88,35 +144,0 @@\n-\n-    static primitive class Value {\n-        int i;\n-        Point p;\n-        Point.ref nullable;\n-        List<X> list;\n-        Value(int i, Point p, Point.ref np, List<X> list) {\n-            this.i = i;\n-            this.p = p;\n-            this.nullable = np;\n-            this.list = list;\n-        }\n-\n-        Point point() {\n-            return p;\n-        }\n-\n-        Point.ref nullablePoint() {\n-            return nullable;\n-        }\n-\n-        int getI() { return i; }\n-\n-        List<X> list() { return list; }\n-    }\n-\n-    static value class X {\n-        private int x;\n-        X(int x) {\n-            this.x = x;\n-        }\n-        int x() {\n-            return x;\n-        }\n-    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/StreamTest.java","additions":71,"deletions":50,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- *          java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n@@ -29,1 +30,1 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses SubstitutabilityTest\n+ * @run junit\/othervm -XX:+EnableValhalla SubstitutabilityTest\n@@ -33,1 +34,1 @@\n-import java.util.List;\n+import java.util.stream.Stream;\n@@ -35,3 +36,3 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -39,1 +40,4 @@\n-public class SubstitutabilityTest {\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -41,39 +45,1 @@\n-    @DataProvider(name=\"substitutable\")\n-    Object[][] substitutableCases() {\n-        Point p1 = Point.makePoint(10, 10);\n-        Point p2 = Point.makePoint(20, 20);\n-        Point.ref box1 = p1;\n-        Point.ref box2 = p2;\n-        Line l1 = Line.makeLine(p1, p2);\n-        var mpath = MutablePath.makePath(10, 20, 30, 40);\n-        var mixedValues = new MixedValues(p1, l1, mpath, \"value\");\n-        var number = InlinableValue.Number.intValue(99);\n-        var list = List.of(\"list\");\n-        return new Object[][] {\n-            new Object[] { p1, Point.makePoint(10, 10) },\n-            new Object[] { l1, Line.makeLine(10,10, 20,20) },\n-            new Object[] { box1, Point.makePoint(10, 10) },\n-            new Object[] { mpath, mpath},\n-            new Object[] { mixedValues, mixedValues},\n-            new Object[] { valueBuilder().setPoint(p1).build(),\n-                           valueBuilder().setPoint(Point.makePoint(10, 10)).build() },\n-            new Object[] { valueBuilder().setPointRef(p2).build(),\n-                           valueBuilder().setPointRef(Point.makePoint(20, 20)).build() },\n-            new Object[] { valueBuilder().setReference(p2).build(),\n-                           valueBuilder().setReference(Point.makePoint(20, 20)).build() },\n-            new Object[] { valueBuilder().setFloat(Float.NaN).setDouble(Double.NaN).setPoint(p1).build(),\n-                           valueBuilder().setFloat(Float.NaN).setDouble(Double.NaN).setPoint(l1.p1).build() },\n-            new Object[] { valueBuilder().setFloat(Float.NaN).setDouble(Double.NaN).setNumber(number).build(),\n-                           valueBuilder().setFloat(Float.NaN).setDouble(Double.NaN).setNumber(InlinableValue.Number.intValue(99)).build() },\n-            new Object[] { valueBuilder().setFloat(+0.0f).setDouble(+0.0).setReference(list).build(),\n-                           valueBuilder().setFloat(+0.0f).setDouble(+0.0).setReference(list).build() },\n-            new Object[] { valueBuilder().setNumber(InlinableValue.Number.intValue(100)).build(),\n-                           valueBuilder().setNumber(InlinableValue.Number.intValue(100)).build() },\n-            new Object[] { valueBuilder().setReference(list).build(),\n-                           valueBuilder().setReference(list).build() },\n-            new Object[] { new ValueOptional(p1), new ValueOptional(p1)},\n-            new Object[] { new ValueOptional(p1), new ValueOptional(Point.makePoint(10, 10))},\n-            new Object[] { new ValueOptional(list), new ValueOptional(list)},\n-            new Object[] { new ValueOptional(null), new ValueOptional(null)},\n-        };\n-    }\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -81,3 +47,9 @@\n-    @Test(dataProvider=\"substitutable\")\n-    public void substitutableTest(Object a, Object b) {\n-        assertTrue(isSubstitutable(a, b));\n+public class SubstitutabilityTest {\n+    @ImplicitlyConstructible\n+    static value class Point {\n+        public int x;\n+        public int y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n@@ -86,40 +58,14 @@\n-    @DataProvider(name=\"notSubstitutable\")\n-    Object[][] notSubstitutableCases() {\n-        var point = Point.makePoint(10, 10);\n-        var mpath = MutablePath.makePath(10, 20, 30, 40);\n-        var number = InlinableValue.Number.intValue(99);\n-        return new Object[][] {\n-            new Object[] { Point.makePoint(10, 10), Point.makePoint(10, 20)},\n-            new Object[] { mpath, MutablePath.makePath(10, 20, 30, 40)},\n-            new Object[] { point, mpath},\n-            new Object[] { valueBuilder().setFloat(+0.0f).setDouble(+0.0).build(),\n-                           valueBuilder().setFloat(-0.0f).setDouble(+0.0).build() },\n-            new Object[] { valueBuilder().setFloat(+0.0f).setDouble(+0.0).build(),\n-                           valueBuilder().setFloat(+0.0f).setDouble(-0.0).build() },\n-            new Object[] { valueBuilder().setPoint(point).build(),\n-                           valueBuilder().setPoint(Point.makePoint(20, 20)).build() },\n-            new Object[] { valueBuilder().setPointRef(point).build(),\n-                           valueBuilder().setPointRef(Point.makePoint(20, 20)).build() },\n-            new Object[] { valueBuilder().setNumber(number).build(),\n-                           valueBuilder().setNumber(new InlinableValue.IntNumber(99)).build() },\n-            new Object[] { valueBuilder().setNumber(InlinableValue.Number.intValue(1)).build(),\n-                           valueBuilder().setNumber(InlinableValue.Number.shortValue((short)1)).build() },\n-            new Object[] { valueBuilder().setNumber(new InlinableValue.IntNumber(99)).build(),\n-                           valueBuilder().setNumber(new InlinableValue.IntNumber(99)).build() },\n-            new Object[] { valueBuilder().setReference(List.of(\"list\")).build(),\n-                           valueBuilder().setReference(List.of(\"list\")).build() },\n-            new Object[] { new ValueOptional(point), new ValueOptional(mpath)},\n-            new Object[] { new ValueOptional(InlinableValue.Number.intValue(1)), new ValueOptional(InlinableValue.Number.shortValue((short)1))},\n-        };\n-    }\n-    @Test(dataProvider=\"notSubstitutable\")\n-    public void notSubstitutableTest(Object a, Object b) {\n-        assertFalse(isSubstitutable(a, b));\n-    }\n-    private static InlinableValue.Builder valueBuilder() {\n-        InlinableValue.Builder builder = new InlinableValue.Builder();\n-        return builder.setChar('a')\n-                       .setBoolean(true)\n-                       .setByte((byte)0x1)\n-                       .setShort((short)3)\n-                       .setLong(4L);\n+    @ImplicitlyConstructible\n+    static value class Line {\n+        @NullRestricted\n+        Point p1;\n+        @NullRestricted\n+        Point p2;\n+\n+        Line(Point p1, Point p2) {\n+            this.p1 = p1;\n+            this.p2 = p2;\n+        }\n+        Line(int x1, int y1, int x2, int y2) {\n+            this(new Point(x1, y1), new Point(x2, y2));\n+        }\n@@ -128,10 +74,9 @@\n-    static primitive class MyValue {\n-        static int cnt = 0;\n-        final int x;\n-        final MyValue2 vtField1;\n-        final MyValue2.ref vtField2;\n-\n-        public MyValue() {\n-            this.x = ++cnt;\n-            this.vtField1 = new MyValue2();\n-            this.vtField2 = new MyValue2();\n+    \/\/ contains null-reference and null-restricted fields\n+    @ImplicitlyConstructible\n+    static value class MyValue {\n+        MyValue2 v1;\n+        @NullRestricted\n+        MyValue2 v2;\n+        public MyValue(MyValue2 v1, MyValue2 v2) {\n+            this.v1 = v1;\n+            this.v2 = v2;\n@@ -141,1 +86,2 @@\n-    static primitive class MyValue2 {\n+    @ImplicitlyConstructible\n+    static value class MyValue2 {\n@@ -143,3 +89,3 @@\n-        final int x;\n-        public MyValue2() {\n-            this.x = ++cnt;\n+        int x;\n+        MyValue2(int x) {\n+            this.x = x;\n@@ -149,2 +95,8 @@\n-    @Test\n-    public void uninitializedArrayElement() throws Exception {\n+    static Stream<Arguments> substitutableCases() {\n+        Point p1 = new Point(10, 10);\n+        Point p2 = new Point(20, 20);\n+        Line l1 = new Line(p1, p2);\n+        MyValue v1 = new MyValue(null, ValueClass.zeroInstance(MyValue2.class));\n+        MyValue v2 = new MyValue(new MyValue2(2), new MyValue2(3));\n+        MyValue2 value2 = new MyValue2(2);\n+        MyValue2 value3 = new MyValue2(3);\n@@ -152,15 +104,8 @@\n-        Object[] oa = new Object[] { va };\n-        for (int i = 0; i < 100; ++i) {\n-            Object o = zerothElement(((i % 2) == 0) ? va : oa);\n-            if ((i % 2) == 0) {\n-                assertTrue(o instanceof MyValue);\n-                assertTrue(o == va[0]);\n-                assertFalse(o != va[0]);\n-                assertTrue(isSubstitutable(o, va[0]));\n-            } else {\n-                assertTrue(o.getClass().isArray());\n-                assertFalse(o == va[0]);\n-                assertTrue(o != va[0]);\n-                assertFalse(isSubstitutable(o, va[0]));\n-            }\n-        }\n+        return Stream.of(\n+                Arguments.of(p1, new Point(10, 10)),\n+                Arguments.of(p2, new Point(20, 20)),\n+                Arguments.of(l1, new Line(10,10, 20,20)),\n+                Arguments.of(v1, ValueClass.zeroInstance(MyValue.class)),\n+                Arguments.of(v2, new MyValue(value2, value3)),\n+                Arguments.of(va[0], null)\n+        );\n@@ -169,3 +114,9 @@\n-    @DataProvider(name=\"negativeSubstitutableCases\")\n-    Object[][] negativeSubstitutableCases() {\n-        MyValue[] va = new MyValue[1];\n+    @ParameterizedTest\n+    @MethodSource(\"substitutableCases\")\n+    public void substitutableTest(Object a, Object b) {\n+        assertTrue(isSubstitutable(a, b));\n+    }\n+\n+    static Stream<Arguments> notSubstitutableCases() {\n+        \/\/ MyValue![] va = new MyValue![1];\n+        MyValue[] va = new MyValue[] { ValueClass.zeroInstance(MyValue.class) };\n@@ -173,11 +124,15 @@\n-        Point p = Point.makePoint(10, 10);\n-        Integer i = Integer.valueOf(10);\n-        return new Object[][] {\n-                new Object[] { va[0], null },\n-                new Object[] { null,  va[0] },\n-                new Object[] { va[0], oa },\n-                new Object[] { va[0], oa[0] },\n-                new Object[] { va,    oa },\n-                new Object[] { p,     i },\n-                new Object[] { i,     Integer.valueOf(20) },\n-        };\n+        return Stream.of(\n+                Arguments.of(new Point(10, 10), new Point(20, 20)),\n+                \/*\n+                 * Verify ValueObjectMethods::isSubstitutable that does not\n+                 * throw an exception if any one of parameter is null or if\n+                 * the parameters are of different types.\n+                 *\/\n+                Arguments.of(va[0], null),\n+                Arguments.of(null, va[0]),\n+                Arguments.of(va[0], oa),\n+                Arguments.of(va[0], oa[0]),\n+                Arguments.of(va, oa),\n+                Arguments.of(new Point(10, 10), Integer.valueOf(10)),\n+                Arguments.of(Integer.valueOf(10), Integer.valueOf(20))\n+        );\n@@ -186,10 +141,3 @@\n-    \/*\n-     * isSubstitutable method handle invoker requires both parameters are\n-     * non-null and of the same primitive class.\n-     *\n-     * This verifies ValueObjectMethods::isSubstitutable that does not\n-     * throw an exception if any one of parameter is null or if\n-     * the parameters are of different types.\n-     *\/\n-    @Test(dataProvider=\"negativeSubstitutableCases\")\n-    public void testIsSubstitutable(Object a, Object b) {\n+    @ParameterizedTest\n+    @MethodSource(\"notSubstitutableCases\")\n+    public void notSubstitutableTest(Object a, Object b) {\n@@ -200,1 +148,1 @@\n-    public void nullArguments() throws Exception {\n+    public void nullArguments() {\n@@ -204,4 +152,0 @@\n-    private static Object zerothElement(Object[] oa) {\n-        return oa[0];\n-    }\n-\n","filename":"test\/jdk\/valhalla\/valuetypes\/SubstitutabilityTest.java","additions":94,"deletions":150,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-# Reflection methods for primitive classes are in PrimitiveClass instead of java.lang.class\n-modules = java.base\/jdk.internal.value\n+modules = java.base\/jdk.internal.value \\\n+          java.base\/jdk.internal.vm.annotation\n","filename":"test\/jdk\/valhalla\/valuetypes\/TEST.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @compile --enable-preview --source ${jdk.version} -XDenablePrimitiveClasses UninitializedValueTest.java\n- * @run testng\/othervm --enable-preview -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:InlineFieldMaxFlatSize=128 UninitializedValueTest\n- * @compile --enable-preview --source ${jdk.version} -XDenablePrimitiveClasses UninitializedValueTest.java\n- * @run testng\/othervm --enable-preview -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:InlineFieldMaxFlatSize=0 UninitializedValueTest\n- * @summary Test reflection and method handle on accessing a field of a primitive class\n- *          that may be flattened or non-flattened\n- *\/\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Field;\n-\n-import jdk.internal.value.PrimitiveClass;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class UninitializedValueTest {\n-    static primitive class EmptyValue {\n-        public boolean isEmpty() {\n-            return true;\n-        }\n-    }\n-\n-    static primitive class Value {\n-        Object o;\n-        EmptyValue empty;\n-        Value() {\n-            this.o = null;\n-            this.empty = new EmptyValue();\n-        }\n-    }\n-\n-    static class MutableValue {\n-        Object o;\n-        EmptyValue empty;\n-        volatile EmptyValue vempty;\n-    }\n-\n-    @Test\n-    public void emptyValueClass() throws ReflectiveOperationException {\n-        EmptyValue e = new EmptyValue();\n-        Field[] fields = e.getClass().getDeclaredFields();\n-        assertTrue(fields.length == 0);\n-    }\n-\n-    @Test\n-    public void testValue() throws ReflectiveOperationException {\n-        Value v = new Value();\n-        Field f0 = v.getClass().getDeclaredField(\"o\");\n-        Object o = f0.get(v);\n-        assertTrue(o == null);\n-\n-        \/\/ field of primitive value type must be non-null\n-        Field f1 = v.getClass().getDeclaredField(\"empty\");\n-        assertTrue(f1.getType() == PrimitiveClass.asValueType(EmptyValue.class));\n-        EmptyValue empty = (EmptyValue)f1.get(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-    }\n-\n-    @Test\n-    public void testMutableValue() throws ReflectiveOperationException {\n-        MutableValue v = new MutableValue();\n-        Field f0 = v.getClass().getDeclaredField(\"o\");\n-        f0.set(v, null);\n-        assertTrue( f0.get(v) == null);\n-\n-        \/\/ field of primitive value type type must be non-null\n-        Field f1 = v.getClass().getDeclaredField(\"empty\");\n-        assertTrue(f1.getType() == PrimitiveClass.asValueType(EmptyValue.class));\n-        EmptyValue empty = (EmptyValue)f1.get(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-\n-        Field f2 = v.getClass().getDeclaredField(\"vempty\");\n-        assertTrue(f2.getType() == PrimitiveClass.asValueType(EmptyValue.class));\n-        EmptyValue vempty = (EmptyValue)f2.get(v);\n-        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n-\n-        f1.set(v, new EmptyValue());\n-        assertTrue((EmptyValue)f1.get(v) == new EmptyValue());\n-        f2.set(v, new EmptyValue());\n-        assertTrue((EmptyValue)f2.get(v) == new EmptyValue());\n-    }\n-\n-    @Test\n-    public void testMethodHandleValue() throws Throwable {\n-        Value v = new Value();\n-        MethodHandle mh = MethodHandles.lookup().findGetter(PrimitiveClass.asValueType(Value.class), \"empty\", PrimitiveClass.asValueType(EmptyValue.class));\n-        EmptyValue empty = (EmptyValue) mh.invokeExact(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-    }\n-\n-    @Test\n-    public void testMethodHandleMutableValue() throws Throwable {\n-        MutableValue v = new MutableValue();\n-        MethodHandle getter = MethodHandles.lookup().findGetter(MutableValue.class, \"empty\", PrimitiveClass.asValueType(EmptyValue.class));\n-        EmptyValue empty = (EmptyValue) getter.invokeExact(v);\n-        assertTrue(empty.isEmpty());        \/\/ test if empty is non-null with default value\n-\n-        MethodHandle getter1 = MethodHandles.lookup().findGetter(MutableValue.class, \"vempty\", PrimitiveClass.asValueType(EmptyValue.class));\n-        EmptyValue vempty = (EmptyValue) getter1.invokeExact(v);\n-        assertTrue(vempty.isEmpty());        \/\/ test if vempty is non-null with default value\n-\n-        MethodHandle setter = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", PrimitiveClass.asValueType(EmptyValue.class));\n-        setter.invokeExact(v, new EmptyValue());\n-        empty = (EmptyValue) getter.invokeExact(v);\n-        assertTrue(empty == new EmptyValue());\n-\n-        MethodHandle setter1 = MethodHandles.lookup().findSetter(MutableValue.class, \"vempty\", PrimitiveClass.asValueType(EmptyValue.class));\n-        setter1.invokeExact(v, new EmptyValue());\n-        vempty = (EmptyValue) getter1.invokeExact(v);\n-        assertTrue(vempty == new EmptyValue());\n-    }\n-\n-    @Test(expectedExceptions = { IllegalAccessException.class})\n-    public void noWriteAccess() throws ReflectiveOperationException {\n-        Value v = new Value();\n-        Field f = v.getClass().getDeclaredField(\"empty\");\n-        f.set(v, null);\n-    }\n-\n-    @Test(expectedExceptions = { NullPointerException.class})\n-    public void nonNullableField_reflection() throws ReflectiveOperationException {\n-        MutableValue v = new MutableValue();\n-        Field f = v.getClass().getDeclaredField(\"empty\");\n-        f.set(v, null);\n-    }\n-\n-    @Test(expectedExceptions = { NullPointerException.class})\n-    public void nonNullableField_MethodHandle() throws Throwable {\n-        MutableValue v = new MutableValue();\n-        MethodHandle mh = MethodHandles.lookup().findSetter(MutableValue.class, \"empty\", PrimitiveClass.asValueType(EmptyValue.class));\n-        EmptyValue.ref e = null;\n-        EmptyValue empty = (EmptyValue) mh.invokeExact(v, (EmptyValue)e);\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/UninitializedValueTest.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -1,251 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Basic test for Array::get, Array::set, Arrays::setAll on primitive class array\n- * @compile -XDenablePrimitiveClasses ValueArray.java\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:FlatArrayElementMaxSize=-1 ValueArray\n- * @compile -XDenablePrimitiveClasses ValueArray.java\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -XX:FlatArrayElementMaxSize=0  ValueArray\n- *\/\n-\n-import java.lang.reflect.Array;\n-import java.util.Arrays;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-import jdk.internal.value.PrimitiveClass;\n-\n-public class ValueArray {\n-    @DataProvider(name=\"elementTypes\")\n-    static Object[][] elementTypes() {\n-        return new Object[][]{\n-            new Object[] { PrimitiveClass.asValueType(Point.class), Point.default },\n-            new Object[] { Point.ref.class, null },\n-            new Object[] { ValueOptional.class, null },\n-        };\n-    }\n-\n-    \/*\n-     * Test an array created from the given element type via Array::newInstance\n-     *\/\n-    @Test(dataProvider=\"elementTypes\")\n-    public void testElementType(Class<?> elementType, Object defaultValue) {\n-        assertTrue(elementType.isValue());\n-        assertTrue(PrimitiveClass.isPrimaryType(elementType) || defaultValue != null);\n-\n-        Object[] array = (Object[])Array.newInstance(elementType, 1);\n-        Class<?> arrayType = array.getClass();\n-        assertTrue(arrayType.componentType() == elementType);\n-        \/\/ Array is a reference type\n-        assertTrue(arrayType.isArray());\n-        assertTrue(PrimitiveClass.isPrimaryType(arrayType));\n-        assertEquals(PrimitiveClass.asPrimaryType(arrayType), arrayType);\n-        assertTrue(array[0] == defaultValue);\n-\n-        \/\/ check the element type of multi-dimensional array\n-        Object[][] multiArray = (Object[][])Array.newInstance(elementType, 1, 2, 3);\n-        Class<?> c = multiArray.getClass();\n-        while (c.getComponentType() != null) {\n-            c = c.getComponentType();\n-        }\n-        assertTrue(c == elementType);\n-    }\n-\n-    @DataProvider(name=\"arrayTypes\")\n-    static Object[][] arrayTypes() {\n-        return new Object[][] {\n-            new Object[] { Object[].class,\n-                           new Object[] { new Object(), new Object()}},\n-            new Object[] { Point[].class,\n-                           new Point[] { Point.makePoint(1, 2),\n-                                         Point.makePoint(10, 20),\n-                                         Point.makePoint(100, 200)}},\n-            new Object[] { Point[][].class,\n-                           new Point[][] { new Point[] { Point.makePoint(1, 2),\n-                                                         Point.makePoint(10, 20)}}},\n-            new Object[] { Point.ref[].class,\n-                           new Point.ref[] { Point.makePoint(11, 22),\n-                                             Point.makePoint(110, 220),\n-                                             null }},\n-            new Object[] { NonFlattenValue[].class,\n-                           new NonFlattenValue[] { NonFlattenValue.make(1, 2),\n-                                                   NonFlattenValue.make(10, 20),\n-                                                   NonFlattenValue.make(100, 200)}},\n-            new Object[] { Point[].class,  new Point[0] },\n-            new Object[] { Point.ref[].class,  new Point.ref[0] },\n-            new Object[] { ValueOptional[].class,  new ValueOptional[0] },\n-        };\n-    }\n-\n-    \/*\n-     * Test the following properties of an array of value class:\n-     * - class name\n-     * - array element can be null or not\n-     * - array covariance if the element type is a primitive value type\n-     *\/\n-    @Test(dataProvider=\"arrayTypes\")\n-    public void testArrays(Class<?> arrayClass, Object[] array) {\n-        testClassName(arrayClass);\n-        testArrayElements(arrayClass, array);\n-        Class<?> componentType = arrayClass.componentType();\n-        if (PrimitiveClass.isPrimitiveClass(componentType)) {\n-            Object[] qArray = (Object[]) Array.newInstance(PrimitiveClass.asValueType(componentType), 0);\n-            Object[] lArray = (Object[]) Array.newInstance(PrimitiveClass.asPrimaryType(componentType), 0);\n-            testArrayCovariance(componentType, qArray, lArray);\n-        }\n-    }\n-\n-    \/**\n-     * Verify the array class's name of the form \"[QPoint;\" or \"[LPoint;\"\n-     *\/\n-    static void testClassName(Class<?> arrayClass) {\n-        \/\/ test class names\n-        String arrayClassName = arrayClass.getName();\n-        StringBuilder sb = new StringBuilder();\n-        Class<?> c = arrayClass;\n-        while (c.isArray()) {\n-            sb.append(\"[\");\n-            c = c.getComponentType();\n-        }\n-        sb.append(PrimitiveClass.isPrimitiveValueType(c) ? \"Q\" : \"L\").append(c.getName()).append(\";\");\n-        assertEquals(sb.toString(), arrayClassName);\n-    }\n-\n-    \/**\n-     * Setting the elements of an array.\n-     * NPE will be thrown if null is set on an element in an array of primitive value type\n-     *\/\n-    static void testArrayElements(Class<?> arrayClass, Object[] array) {\n-        Class<?> componentType = arrayClass.getComponentType();\n-        assertTrue(arrayClass.isArray());\n-        assertTrue(array.getClass() == arrayClass);\n-        Object[] newArray = (Object[]) Array.newInstance(componentType, array.length);\n-        assertTrue(newArray.getClass() == arrayClass);\n-        assertTrue(newArray.getClass().getComponentType() == componentType);\n-\n-        \/\/ set elements\n-        for (int i = 0; i < array.length; i++) {\n-            Array.set(newArray, i, array[i]);\n-        }\n-        for (int i = 0; i < array.length; i++) {\n-            Object o = Array.get(newArray, i);\n-            assertEquals(o, array[i]);\n-        }\n-        Arrays.setAll(newArray, i -> array[i]);\n-\n-        \/\/ test nullable\n-        if (!PrimitiveClass.isPrimitiveValueType(componentType)) {\n-            for (int i = 0; i < newArray.length; i++) {\n-                Array.set(newArray, i, null);\n-            }\n-        } else {\n-            for (int i = 0; i < newArray.length; i++) {\n-                try {\n-                    Array.set(newArray, i, null);\n-                    fail(\"expect NPE but not thrown\");\n-                } catch (NullPointerException e) {\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Point[] is a subtype of Point.ref[], which is a subtype of Object[].\n-     *\/\n-    static void testArrayCovariance(Class<?> componentType, Object[] qArray, Object[] lArray) {\n-        assertTrue(PrimitiveClass.isPrimitiveClass(componentType));\n-\n-        \/\/ Class.instanceOf (self)\n-        assertTrue(qArray.getClass().isInstance(qArray));\n-        assertTrue(lArray.getClass().isInstance(lArray));\n-\n-        \/\/ Class.isAssignableFrom (self)\n-        assertTrue(qArray.getClass().isAssignableFrom(qArray.getClass()));\n-        assertTrue(lArray.getClass().isAssignableFrom(lArray.getClass()));\n-\n-        \/\/ V.val[] is a subtype of V.ref[]\n-        assertFalse(qArray.getClass().isInstance(lArray));\n-        assertTrue(lArray.getClass().isInstance(qArray));\n-\n-        \/\/ V.val[] is a subtype of V.ref[]\n-        assertTrue(lArray.getClass().isAssignableFrom(qArray.getClass()));\n-        assertFalse(qArray.getClass().isAssignableFrom(lArray.getClass()));\n-\n-        \/\/ Class.cast (self)\n-        qArray.getClass().cast(qArray);\n-        lArray.getClass().cast(lArray);\n-\n-        \/\/ Class.cast\n-        lArray.getClass().cast(qArray);\n-        try {\n-            qArray.getClass().cast(lArray);\n-            fail(\"cast of Point.ref[] to Point[] should not succeed\");\n-        } catch (ClassCastException cce) {\n-        }\n-    }\n-\n-    @Test\n-    public static void testIntArray() {\n-        int[] array = new int[] { 1, 2, 3};\n-        for (int i=0; i < array.length; i++) {\n-            Array.set(array, i, Integer.valueOf(i*10));\n-        }\n-\n-        for (int i=0; i < array.length; i++) {\n-            Integer o = (Integer) Array.get(array, i);\n-            assertTrue(o.intValue() == i*10);\n-        }\n-        Arrays.setAll(array, i -> array[i]);\n-    }\n-\n-    @Test\n-    public static void testNonArrayObject() {\n-        Object o = new Object();\n-        try {\n-            Array.get(o, 0);\n-            fail(\"IAE not thrown\");\n-        } catch (IllegalArgumentException e) {}\n-\n-        try {\n-            Array.set(o, 0, o);\n-            fail(\"IAE not thrown\");\n-        } catch (IllegalArgumentException e) {}\n-\n-    }\n-\n-    @Test\n-    static void testInstanceOf() {\n-        Point[] qArray = new Point[0];\n-        Point.ref[] lArray = new Point.ref[0];\n-        ValueOptional[] vArray = new ValueOptional[0];\n-\n-        \/\/ language instanceof\n-        assertTrue(qArray instanceof Point[]);\n-        assertTrue(lArray instanceof Point.ref[]);\n-        assertTrue(vArray instanceof ValueOptional[]);\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueArray.java","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,3 @@\n- * @summary Test ConstantDesc for primitive classes\n- * @compile --enable-preview --source ${jdk.version} -XDenablePrimitiveClasses Point.java ValueConstantDesc.java\n- * @run testng\/othervm --enable-preview -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ValueConstantDesc\n+ * @summary Test ConstantDesc for value classes\n+ * @compile -XDenablePrimitiveClasses ValueConstantDesc.java\n+ * @run junit\/othervm -XX:+EnableValhalla ValueConstantDesc\n@@ -32,3 +32,0 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n@@ -43,0 +40,1 @@\n+import java.util.stream.Stream;\n@@ -46,1 +44,4 @@\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -49,1 +50,2 @@\n-    private static final String NAME = \"Point\";\n+    static value class V { }\n+\n@@ -52,11 +54,6 @@\n-    @DataProvider(name=\"descs\")\n-    static Object[][] descs() {\n-        return new Object[][]{\n-            new Object[] { PrimitiveClass.asValueType(Point.class),     ClassDesc.ofDescriptor(\"Q\" + NAME + \";\"), NAME},\n-            new Object[] { Point.ref.class, ClassDesc.ofDescriptor(\"L\" + NAME + \";\"), NAME},\n-            new Object[] { Point[].class,   ClassDesc.ofDescriptor(\"[Q\" + NAME + \";\"), NAME + \"[]\"},\n-            new Object[] { Point.ref[][].class, ClassDesc.ofDescriptor(\"[[L\" + NAME + \";\"), NAME + \"[][]\"},\n-            new Object[] { ValueOptional.class, ClassDesc.ofDescriptor(\"LValueOptional;\"), \"ValueOptional\"},\n-            new Object[] { ValueOptional[].class, ClassDesc.ofDescriptor(\"[LValueOptional;\"), \"ValueOptional[]\"},\n-            new Object[] { ValueOptional[][].class, ClassDesc.ofDescriptor(\"[[LValueOptional;\"), \"ValueOptional[][]\"},\n-        };\n+    static Stream<Arguments> testCases() {\n+        return Stream.of(\n+                Arguments.of(V.class, \"LValueConstantDesc$V;\", \"ValueConstantDesc$V\"),\n+                Arguments.of(V[].class, \"[LValueConstantDesc$V;\", \"ValueConstantDesc$V[]\"),\n+                Arguments.of(V[][].class, \"[[LValueConstantDesc$V;\", \"ValueConstantDesc$V[][]\")\n+        );\n@@ -65,2 +62,3 @@\n-    @Test(dataProvider=\"descs\")\n-    public void classDesc(Class<?> type, ClassDesc expected, String displayName) {\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    public void classDesc(Class<?> type, String descriptor, String displayName) throws ReflectiveOperationException {\n@@ -68,0 +66,2 @@\n+        ClassDesc desc = ClassDesc.ofDescriptor(descriptor);\n+\n@@ -75,1 +75,1 @@\n-        assertEquals(cd, expected);\n+        assertEquals(cd, desc);\n@@ -78,16 +78,0 @@\n-    }\n-\n-    @DataProvider(name=\"componentTypes\")\n-    static Object[][] componentTypes() {\n-        return new Object[][]{\n-            new Object[] { PrimitiveClass.asValueType(Point.class) },\n-            new Object[] { Point.ref.class },\n-            new Object[] { ValueOptional.class }\n-        };\n-    }\n-\n-    @Test(dataProvider=\"componentTypes\")\n-    public void arrayType(Class<?> componentType) {\n-        ClassDesc cd = componentType.describeConstable().orElseThrow();\n-        ClassDesc arrayDesc = cd.arrayType();\n-        ClassDesc arrayDesc2 = cd.arrayType(2);\n@@ -95,23 +79,1 @@\n-        assertTrue(arrayDesc.isArray());\n-        assertEquals(arrayDesc.componentType(), cd);\n-        assertTrue(arrayDesc2.isArray());\n-        assertEquals(arrayDesc2.componentType(), arrayDesc);\n-    }\n-\n-    @DataProvider(name=\"valueDesc\")\n-    static Object[][] valueDesc() {\n-        return new Object[][]{\n-                new Object[] { PrimitiveClass.asValueType(Point.class),         \"Q\" + NAME + \";\"},\n-                new Object[] { Point.ref.class,     \"L\" + NAME + \";\"},\n-                new Object[] { Point[].class,       \"[Q\" + NAME + \";\"},\n-                new Object[] { Point.ref[][].class, \"[[L\" + NAME + \";\"},\n-                new Object[] { ValueOptional.class, \"LValueOptional;\"},\n-                new Object[] { ValueOptional[].class, \"[LValueOptional;\"},\n-        };\n-    }\n-    @Test(dataProvider=\"valueDesc\")\n-    public void asValueType(Class<?> type, String descriptor) throws ReflectiveOperationException {\n-        ClassDesc cd = type.describeConstable().orElseThrow();\n-        ClassDesc valueDesc = ClassDesc.ofDescriptor(descriptor);\n-        assertEquals(cd, valueDesc);\n-        Class<?> c = (Class<?>) cd.resolveConstantDesc(LOOKUP);\n+        Class<?> c = cd.resolveConstantDesc(LOOKUP);\n@@ -119,38 +81,0 @@\n-        assertTrue(PrimitiveClass.isPrimitiveValueClassDesc(cd) == PrimitiveClass.isPrimitiveValueType(type));\n-    }\n-    @DataProvider(name=\"classes\")\n-    static Object[][] classes() {\n-        Class<?> valType = PrimitiveClass.asValueType(Point.class);\n-        Class<?> refType = Point.class;\n-\n-        return new Object[][]{\n-            new Object[] { ValueOptional.class, \"(Ljava\/lang\/Object;)LValueOptional;\" },\n-            new Object[] { valType, \"(II)QPoint;\" },\n-            new Object[] { refType, \"(II)QPoint;\" },\n-        };\n-    }\n-    @Test(dataProvider=\"classes\")\n-    public void directMethodHandleDesc(Class<?> type, String methodDescriptor) throws Throwable {\n-        ClassDesc cd = type.describeConstable().orElseThrow();\n-        MethodTypeDesc methodTypeDesc = MethodTypeDesc.ofDescriptor(methodDescriptor);\n-\n-        DirectMethodHandleDesc dmhDesc = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC, cd, \"<vnew>\", methodTypeDesc);\n-        MethodHandle mh = (MethodHandle) dmhDesc.resolveConstantDesc(LOOKUP);\n-        MethodType methodType = (MethodType) methodTypeDesc.resolveConstantDesc(LOOKUP);\n-        MethodHandle vnew = LOOKUP.findStatic(type, \"<vnew>\", methodType);\n-        assertMethodHandleEquals(mh, vnew);\n-    }\n-\n-    private static void assertMethodHandleEquals(MethodHandle mh1, MethodHandle mh2) {\n-        MethodHandleInfo minfo1 = LOOKUP.revealDirect(mh1);\n-        MethodHandleInfo minfo2 = LOOKUP.revealDirect(mh2);\n-        assertEquals(minfo1.getDeclaringClass(), minfo2.getDeclaringClass());\n-        assertEquals(minfo1.getName(), minfo2.getName());\n-        assertEquals(minfo1.getMethodType(), minfo2.getMethodType());\n-    }\n-\n-    @Test(expectedExceptions = {LinkageError.class})\n-    public void illegalDescriptor() throws ReflectiveOperationException {\n-        \/\/ ValueConstantDesc is not a primitive class\n-        ClassDesc cd = ClassDesc.ofDescriptor(\"QValueConstantDesc;\");\n-        Class<?> c = (Class<?>) cd.resolveConstantDesc(LOOKUP);\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueConstantDesc.java","additions":24,"deletions":100,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public value class ValueOptional {\n-    private Object o;\n-    public ValueOptional(Object o) {\n-        this.o = o;\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueOptional.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n@@ -34,1 +33,1 @@\n- * @summary Test primitive classes with Reference types\n+ * @summary Test value classes with Reference types\n@@ -36,1 +35,1 @@\n- * @run testng\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses WeakReferenceTest\n+ * @run testng\/othervm -XX:+EnableValhalla WeakReferenceTest\n@@ -40,0 +39,3 @@\n+    @ImplicitlyConstructible\n+    static value class Value {\n+    }\n@@ -43,2 +45,2 @@\n-        Point.ref p = new Point(10,20);\n-        WeakReference<Point.ref> r = new WeakReference<>(p);\n+        Value v = new Value();\n+        WeakReference<Value> r = new WeakReference<>(v);\n@@ -50,2 +52,2 @@\n-        Point.ref p = new Point(1,2);\n-        WeakReference<Point.ref> r = new WeakReference<>(p, q);\n+        Value v = new Value();\n+        WeakReference<Value> r = new WeakReference<>(v, q);\n","filename":"test\/jdk\/valhalla\/valuetypes\/WeakReferenceTest.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"}]}