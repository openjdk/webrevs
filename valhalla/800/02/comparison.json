{"files":[{"patch":"@@ -43,0 +43,6 @@\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n@@ -132,1 +138,1 @@\n-          sudo qemu-debootstrap\n+          sudo debootstrap\n@@ -148,1 +154,3 @@\n-          rm -rf sysroot\/{dev,proc,run,sys}\n+          rm -rf sysroot\/{dev,proc,run,sys,var}\n+          rm -rf sysroot\/usr\/{sbin,bin,share}\n+          rm -rf sysroot\/usr\/lib\/{apt,udev,systemd}\n@@ -166,1 +174,1 @@\n-          ${{ inputs.extra-conf-options }} || (\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n@@ -175,1 +183,1 @@\n-          make-target: 'hotspot'\n+          make-target: 'hotspot ${{ inputs.make-arguments }}'\n","filename":".github\/workflows\/build-cross-compile.yml","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -61,0 +61,6 @@\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n@@ -126,1 +132,1 @@\n-          ${{ inputs.extra-conf-options }} || (\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n@@ -135,1 +141,1 @@\n-          make-target: '${{ inputs.make-target }}'\n+          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n","filename":".github\/workflows\/build-linux.yml","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,0 +48,6 @@\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n@@ -101,1 +107,1 @@\n-          ${{ inputs.extra-conf-options }} || (\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n@@ -110,1 +116,1 @@\n-          make-target: '${{ inputs.make-target }}'\n+          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n","filename":".github\/workflows\/build-macos.yml","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,0 +51,6 @@\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n@@ -114,1 +120,1 @@\n-          ${{ inputs.extra-conf-options }} || (\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n@@ -127,1 +133,1 @@\n-          make-target: '${{ inputs.make-target }}'\n+          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n","filename":".github\/workflows\/build-windows.yml","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,6 @@\n+      configure-arguments:\n+        description: 'Additional configure arguments'\n+        required: false\n+      make-arguments:\n+        description: 'Additional make arguments'\n+        required: false\n@@ -128,0 +134,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -145,0 +153,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -158,0 +168,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -171,0 +183,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -184,0 +198,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -198,0 +214,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -210,0 +228,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -219,0 +239,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -229,0 +251,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -239,0 +263,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n@@ -251,0 +277,2 @@\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n","filename":".github\/workflows\/main.yml","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.md|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,2 +5,2 @@\n-openjdk.java.net (\"OpenJDK Code\") is distributed under the terms of the GNU\n-General Public License <http:\/\/www.gnu.org\/copyleft\/gpl.html> version 2\n+openjdk.org (\"OpenJDK Code\") is distributed under the terms of the GNU\n+General Public License <https:\/\/www.gnu.org\/copyleft\/gpl.html> version 2\n@@ -15,1 +15,1 @@\n-    http:\/\/openjdk.java.net\/legal\/exception-modules-2007-05-08.html\n+    https:\/\/openjdk.org\/legal\/exception-modules-2007-05-08.html\n","filename":"ASSEMBLY_EXCEPTION","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-Please see <https:\/\/openjdk.java.net\/contribute\/> for how to contribute.\n+Please see <https:\/\/openjdk.org\/contribute> for how to contribute.\n","filename":"CONTRIBUTING.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,0 +138,22 @@\n+# Returns a shell-escaped version of the argument given.\n+shell_quote() {\n+  if [[ -n \"$1\" ]]; then\n+    # Uses only shell-safe characters?  No quoting needed.\n+    # '=' is a zsh meta-character, but only in word-initial position.\n+    if echo \"$1\" | grep '^[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\.:,%\/+=_-]\\{1,\\}$' > \/dev\/null \\\n+        && ! echo \"$1\" | grep '^=' > \/dev\/null; then\n+      quoted=\"$1\"\n+    else\n+      if echo \"$1\" | grep \"[\\'!]\" > \/dev\/null; then\n+        # csh does history expansion within single quotes, but not\n+        # when backslash-escaped!\n+        local quoted_quote=\"'\\\\''\" quoted_exclam=\"'\\\\!'\"\n+        word=\"${1\/\/\\'\/${quoted_quote}}\"\n+        word=\"${1\/\/\\!\/${quoted_exclam}}\"\n+      fi\n+      quoted=\"'$1'\"\n+    fi\n+    echo \"$quoted\"\n+  fi\n+}\n+\n@@ -154,0 +176,12 @@\n+\n+# Save the original command line\n+conf_quoted_arguments=()\n+for conf_option; do\n+  conf_quoted_arguments=(\"${conf_quoted_arguments[@]}\" \"$(shell_quote \"$conf_option\")\")\n+done\n+export REAL_CONFIGURE_COMMAND_LINE=\"${conf_quoted_arguments[@]}\"\n+\n+myfulldir=\"$(cd \"${mydir}\" > \/dev\/null && pwd)\"\n+export REAL_CONFIGURE_COMMAND_EXEC_FULL=\"$BASH $myfulldir\/$myname\"\n+export REAL_CONFIGURE_COMMAND_EXEC_SHORT=\"$myname\"\n+\n","filename":"bin\/jib.sh","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-<p>Too verbose tests which print all information even if they pass are very bad practice. They just pollute output, so it becomes harder to find useful information. In order not print information till it is really needed, one should consider saving it to a temporary buffer and pass to an assert. <a href=\"https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp\" class=\"uri\">https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp<\/a> has a good example how to do that.<\/p>\n+<p>Too verbose tests which print all information even if they pass are very bad practice. They just pollute output, so it becomes harder to find useful information. In order not print information till it is really needed, one should consider saving it to a temporary buffer and pass to an assert. <a href=\"https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp\" class=\"uri\">https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp<\/a> has a good example how to do that.<\/p>\n@@ -174,1 +174,1 @@\n-<p>For now, if a test depends on flags values, it should have <code>if (!&lt;flag&gt;) { return }<\/code> guards in the very beginning and <code>@requires<\/code> comment similar to jtreg <code>@requires<\/code> directive right before test macros. <a href=\"https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp\" class=\"uri\">https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp<\/a> ha an example of this temporary workaround. It is important to follow that pattern as it allows us to easily find all such tests and update them as soon as there is an implementation of flag passing facility.<\/p>\n+<p>For now, if a test depends on flags values, it should have <code>if (!&lt;flag&gt;) { return }<\/code> guards in the very beginning and <code>@requires<\/code> comment similar to jtreg <code>@requires<\/code> directive right before test macros. <a href=\"https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp\" class=\"uri\">https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp<\/a> ha an example of this temporary workaround. It is important to follow that pattern as it allows us to easily find all such tests and update them as soon as there is an implementation of flag passing facility.<\/p>\n","filename":"doc\/hotspot-unit-tests.html","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-### Nearness \n+### Nearness\n@@ -159,1 +159,1 @@\n-### C string comparison \n+### C string comparison\n@@ -197,1 +197,1 @@\n-<https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp>\n+<https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/shared\/test_memset_with_concurrent_readers.cpp>\n@@ -232,1 +232,1 @@\n-### Filename \n+### Filename\n@@ -286,1 +286,1 @@\n-### Friend classes \n+### Friend classes\n@@ -306,1 +306,1 @@\n-### Hotspot style \n+### Hotspot style\n@@ -386,1 +386,1 @@\n-<https:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp>\n+<https:\/\/git.openjdk.org\/jdk\/blob\/master\/test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp>\n@@ -395,1 +395,1 @@\n-### Flag restoring \n+### Flag restoring\n@@ -407,1 +407,1 @@\n-Caveats: \n+Caveats:\n","filename":"doc\/hotspot-unit-tests.md","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+<p><strong>Note:<\/strong> To be able to run the Gtest suite, you need to configure your build to be able to find a proper version of the gtest source. For details, see the section <a href=\"building.html#running-tests\">&quot;Running Tests&quot; in the build documentation<\/a>.<\/p>\n","filename":"doc\/testing.html","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-of files or directories containing JTReg tests. Documentation can be found at \n+of files or directories containing JTReg tests. Documentation can be found at\n@@ -172,0 +172,5 @@\n+**Note:** To be able to run the Gtest suite, you need to configure your build to\n+be able to find a proper version of the gtest source. For details, see the\n+section [\"Running Tests\" in the build\n+documentation](building.html#running-tests).\n+\n@@ -610,2 +615,2 @@\n-If you want to contribute changes to this document, edit `doc\/testing.md` and \n-then run `make update-build-docs` to generate the same changes in \n+If you want to contribute changes to this document, edit `doc\/testing.md` and\n+then run `make update-build-docs` to generate the same changes in\n","filename":"doc\/testing.md","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -280,1 +280,4 @@\n-        ifneq ($(CONFIGURE_COMMAND_LINE), )\n+        ifneq ($(REAL_CONFIGURE_COMMAND_EXEC_FULL), )\n+\t  $(ECHO) \"Re-running configure using original command line '$(REAL_CONFIGURE_COMMAND_EXEC_SHORT) $(REAL_CONFIGURE_COMMAND_LINE)'\"\n+\t  $(eval RECONFIGURE_COMMAND := $(REAL_CONFIGURE_COMMAND_EXEC_FULL) $(REAL_CONFIGURE_COMMAND_LINE))\n+        else ifneq ($(CONFIGURE_COMMAND_LINE), )\n@@ -282,0 +285,1 @@\n+\t  $(eval RECONFIGURE_COMMAND := $(BASH) $(TOPDIR)\/configure $(CONFIGURE_COMMAND_LINE))\n@@ -284,0 +288,1 @@\n+\t  $(eval RECONFIGURE_COMMAND := $(BASH) $(TOPDIR)\/configure)\n@@ -288,1 +293,1 @@\n-\t    $(BASH) $(TOPDIR)\/configure $(CONFIGURE_COMMAND_LINE) )\n+\t    $(RECONFIGURE_COMMAND) )\n","filename":"make\/Init.gmk","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+  # We might have the original command line if the wrapper was called by some\n+  # other script.\n+  AC_SUBST(REAL_CONFIGURE_COMMAND_EXEC_SHORT)\n+  AC_SUBST(REAL_CONFIGURE_COMMAND_EXEC_FULL)\n+  AC_SUBST(REAL_CONFIGURE_COMMAND_LINE)\n","filename":"make\/autoconf\/basic.m4","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -281,0 +281,5 @@\n+  if test \"x$REAL_CONFIGURE_COMMAND_EXEC_FULL\" != x; then\n+    printf \"\\n\"\n+    printf \"The original configure invocation was '$REAL_CONFIGURE_COMMAND_EXEC_SHORT $REAL_CONFIGURE_COMMAND_LINE'.\\n\"\n+  fi\n+\n","filename":"make\/autoconf\/help.m4","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -278,0 +278,2 @@\n+    elif test \"x$OPENJDK_TARGET_CPU\" = \"xriscv64\"; then\n+      AC_MSG_RESULT([yes])\n","filename":"make\/autoconf\/jvm-features.m4","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,0 +137,2 @@\n+  BINUTILS_DIR=\"$CONFIGURESUPPORT_OUTPUTDIR\/binutils\"\n+\n@@ -144,4 +146,8 @@\n-  if test -e $BINUTILS_SRC\/bfd\/libbfd.a && \\\n-      test -e $BINUTILS_SRC\/opcodes\/libopcodes.a && \\\n-      test -e $BINUTILS_SRC\/libiberty\/libiberty.a && \\\n-      test -e $BINUTILS_SRC\/zlib\/libz.a; then\n+  if ! test -d $BINUTILS_DIR; then\n+    $MKDIR -p $BINUTILS_DIR\n+  fi\n+\n+  if test -e $BINUTILS_DIR\/bfd\/libbfd.a && \\\n+      test -e $BINUTILS_DIR\/opcodes\/libopcodes.a && \\\n+      test -e $BINUTILS_DIR\/libiberty\/libiberty.a && \\\n+      test -e $BINUTILS_DIR\/zlib\/libz.a; then\n@@ -178,1 +184,5 @@\n-      binutils_target=\"\"\n+      if test \"x$COMPILE_TYPE\" = xcross; then\n+        binutils_target=\"--host=$OPENJDK_TARGET_AUTOCONF_NAME\"\n+      else\n+        binutils_target=\"\"\n+      fi\n@@ -183,1 +193,1 @@\n-    AC_MSG_NOTICE([configure command line: .\/configure --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" $binutils_target])\n+    AC_MSG_NOTICE([configure command line: cd $BINUTILS_DIR && $BINUTILS_SRC\/configure --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" AR=\"$AR\" $binutils_target])\n@@ -185,3 +195,3 @@\n-    cd \"$BINUTILS_SRC\"\n-    .\/configure --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" $binutils_target\n-    if test $? -ne 0 || ! test -e $BINUTILS_SRC\/Makefile; then\n+    cd \"$BINUTILS_DIR\"\n+    $BINUTILS_SRC\/configure --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" AR=\"$AR\" $binutils_target\n+    if test $? -ne 0 || ! test -e $BINUTILS_DIR\/Makefile; then\n@@ -200,2 +210,0 @@\n-\n-  BINUTILS_DIR=\"$BINUTILS_SRC\"\n@@ -237,2 +245,8 @@\n-        test -e $BINUTILS_DIR\/libiberty\/libiberty.a; then\n-      HSDIS_CFLAGS=\"-I$BINUTILS_DIR\/include -I$BINUTILS_DIR\/bfd -DLIBARCH_$OPENJDK_TARGET_CPU_LEGACY_LIB\"\n+        test -e $BINUTILS_DIR\/libiberty\/libiberty.a && \\\n+        test -e $BINUTILS_DIR\/zlib\/libz.a; then\n+      HSDIS_CFLAGS=\"-DLIBARCH_$OPENJDK_TARGET_CPU_LEGACY_LIB\"\n+      if test -n \"$BINUTILS_SRC\"; then\n+        HSDIS_CFLAGS=\"$HSDIS_CFLAGS -I$BINUTILS_SRC\/include -I$BINUTILS_DIR\/bfd\"\n+      else\n+        HSDIS_CFLAGS=\"$HSDIS_CFLAGS -I$BINUTILS_DIR\/include -I$BINUTILS_DIR\/bfd\"\n+      fi\n","filename":"make\/autoconf\/lib-hsdis.m4","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        GTEST_FRAMEWORK_SRC=${with_gtest}\n+        GTEST_FRAMEWORK_SRC=$with_gtest\n@@ -60,0 +60,16 @@\n+\n+        # Try to verify version. We require 1.8.1, but this can not be directly\n+        # determined. :-( Instead, there are different, incorrect version\n+        # numbers we can look for.\n+        GTEST_VERSION_1=\"`$GREP GOOGLETEST_VERSION $GTEST_FRAMEWORK_SRC\/CMakeLists.txt | $SED -E -e 's\/set\\(GOOGLETEST_VERSION (.*)\\)\/\\1\/'`\"\n+        if test \"x$GTEST_VERSION_1\" != \"x1.9.0\"; then\n+          AC_MSG_ERROR([gtest at $GTEST_FRAMEWORK_SRC does not seem to be version 1.8.1])\n+        fi\n+\n+        # We cannot grep for \"AC_IN*T\" as a literal since then m4 will treat it as a macro\n+        # and expand it.\n+        # Additional [] needed to keep m4 from mangling shell constructs.\n+        [ GTEST_VERSION_2=\"`$GREP -A1 ^.C_INIT $GTEST_FRAMEWORK_SRC\/configure.ac | $TAIL -n 1 | $SED -E -e 's\/ +\\[(.*)],\/\\1\/'`\" ]\n+        if test \"x$GTEST_VERSION_2\" != \"x1.8.0\"; then\n+          AC_MSG_ERROR([gtest at $GTEST_FRAMEWORK_SRC does not seem to be version 1.8.1 B])\n+        fi\n","filename":"make\/autoconf\/lib-tests.m4","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,2 +99,0 @@\n-    HEADERS_TO_CHECK=\"X11\/extensions\/shape.h X11\/extensions\/Xrender.h X11\/extensions\/XTest.h X11\/Intrinsic.h\"\n-    # There is no Xrandr extension on AIX\n@@ -102,0 +100,2 @@\n+      # There is no Xrandr extension on AIX. Code is duplicated to avoid autoconf\n+      # 2.71+ warning \"AC_CHECK_HEADERS: you should use literals\"\n@@ -103,0 +103,8 @@\n+      AC_CHECK_HEADERS([X11\/extensions\/shape.h X11\/extensions\/Xrender.h X11\/extensions\/XTest.h X11\/Intrinsic.h],\n+          [X11_HEADERS_OK=yes],\n+          [X11_HEADERS_OK=no; break],\n+          [\n+            # include <X11\/Xlib.h>\n+            # include <X11\/Xutil.h>\n+          ]\n+      )\n@@ -104,1 +112,8 @@\n-      HEADERS_TO_CHECK=\"$HEADERS_TO_CHECK X11\/extensions\/Xrandr.h\"\n+      AC_CHECK_HEADERS([X11\/extensions\/shape.h X11\/extensions\/Xrender.h X11\/extensions\/XTest.h X11\/Intrinsic.h X11\/extensions\/Xrandr.h],\n+          [X11_HEADERS_OK=yes],\n+          [X11_HEADERS_OK=no; break],\n+          [\n+            # include <X11\/Xlib.h>\n+            # include <X11\/Xutil.h>\n+          ]\n+      )\n@@ -107,10 +122,0 @@\n-    # Need to include Xlib.h and Xutil.h to avoid \"present but cannot be compiled\" warnings on Solaris 10\n-    AC_CHECK_HEADERS([$HEADERS_TO_CHECK],\n-        [X11_HEADERS_OK=yes],\n-        [X11_HEADERS_OK=no; break],\n-        [\n-          # include <X11\/Xlib.h>\n-          # include <X11\/Xutil.h>\n-        ]\n-    )\n-\n","filename":"make\/autoconf\/lib-x11.m4","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+# How configure was originally called, if not called directly\n+REAL_CONFIGURE_COMMAND_EXEC_SHORT := @REAL_CONFIGURE_COMMAND_EXEC_SHORT@\n+REAL_CONFIGURE_COMMAND_EXEC_FULL := @REAL_CONFIGURE_COMMAND_EXEC_FULL@\n+REAL_CONFIGURE_COMMAND_LINE := @REAL_CONFIGURE_COMMAND_LINE@\n+\n","filename":"make\/autoconf\/spec.gmk.in","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,1 +197,1 @@\n-MAX_PARAMS := 36\n+MAX_PARAMS := 96\n","filename":"make\/common\/MakeBase.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-        $$($$($1_BASE)_SYSROOT_CFLAGS) $$($1_WARNINGS_FLAGS)\n+        $$($$($1_BASE)_SYSROOT_CFLAGS)\n@@ -354,1 +354,1 @@\n-        $$($$($1_BASE)_SYSROOT_CFLAGS) $$($1_EXTRA_CXXFLAGS) $$($1_WARNINGS_FLAGS)\n+        $$($$($1_BASE)_SYSROOT_CFLAGS) $$($1_EXTRA_CXXFLAGS)\n@@ -359,0 +359,1 @@\n+      $1_CFLAGS += $$($1_WARNINGS_FLAGS)\n@@ -364,0 +365,1 @@\n+      $1_CFLAGS += $$($1_WARNINGS_FLAGS)\n@@ -387,0 +389,1 @@\n+      $1_CXXFLAGS += $$($1_WARNINGS_FLAGS)\n","filename":"make\/common\/NativeCompilation.gmk","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    ifneq ($$(findstring http:\/, $$($1_CSS)), )\n+    ifneq ($$(findstring https:\/, $$($1_CSS)), )\n","filename":"make\/common\/ProcessMarkdown.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    -I$(TOPDIR)\/src\/java.desktop\/share\/native\/include \\\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk18\/43f95e8614114aeaa8e8a5fcf20a682d\/36\/GPL\/openjdk-18_linux-x64_bin.tar.gz\n-LINUX_X64_BOOT_JDK_SHA256=0f60aef7b8504983d6e374fe94d09a7bedcf05ec559e812d801a33bd4ebd23d0\n+LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk19\/877d6127e982470ba2a7faa31cc93d04\/36\/GPL\/openjdk-19_linux-x64_bin.tar.gz\n+LINUX_X64_BOOT_JDK_SHA256=f47aba585cfc9ecff1ed8e023524e8309f4315ed8b80100b40c7dcc232c12f96\n@@ -36,2 +36,2 @@\n-MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk18\/43f95e8614114aeaa8e8a5fcf20a682d\/36\/GPL\/openjdk-18_macos-x64_bin.tar.gz\n-MACOS_X64_BOOT_JDK_SHA256=527b61b4265caf45cdcbacfcf8fbcd0b4b280bede1eff32a5b252d855ff0534b\n+MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk19\/877d6127e982470ba2a7faa31cc93d04\/36\/GPL\/openjdk-19_macos-x64_bin.tar.gz\n+MACOS_X64_BOOT_JDK_SHA256=bfd33f5b2590fd552ae2d9231340c6b4704a872f927dce1c52860b78c49a5a11\n@@ -40,2 +40,2 @@\n-WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk18\/43f95e8614114aeaa8e8a5fcf20a682d\/36\/GPL\/openjdk-18_windows-x64_bin.zip\n-WINDOWS_X64_BOOT_JDK_SHA256=a5b91d4c12752d44aa75df70ae3e2311287b3e60c288b07dade106376c688277\n+WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk19\/877d6127e982470ba2a7faa31cc93d04\/36\/GPL\/openjdk-19_windows-x64_bin.zip\n+WINDOWS_X64_BOOT_JDK_SHA256=8fabcee7c4e8d3b53486777ecd27bb906d67d7c1efd1bf22a8290cf659afa487\n","filename":"make\/conf\/github-actions.conf","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -391,1 +391,1 @@\n-    common.boot_jdk_version = \"18\";\n+    common.boot_jdk_version = \"19\";\n@@ -1150,1 +1150,1 @@\n-            revision: \"3.0-12-jdk-asm+1.0\",\n+            revision: \"3.0-13-jdk-asm+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"18 19 20\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"19 20\"\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    DISABLED_WARNINGS_gcc_test_threadCpuLoad.cpp := address, \\\n@@ -108,0 +109,2 @@\n+    DISABLED_WARNINGS_clang_test_g1ServiceThread.cpp := delete-abstract-non-virtual-dtor, \\\n+    DISABLED_WARNINGS_clang_test_logDecorations.cpp := missing-field-initializers, \\\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -86,8 +86,13 @@\n-DISABLED_WARNINGS_gcc := parentheses comment unknown-pragmas address \\\n-    delete-non-virtual-dtor char-subscripts array-bounds int-in-bool-context \\\n-    ignored-qualifiers  missing-field-initializers implicit-fallthrough \\\n-    empty-body strict-overflow sequence-point maybe-uninitialized \\\n-    misleading-indentation cast-function-type shift-negative-value\n-\n-ifeq ($(call check-jvm-feature, zero), true)\n-  DISABLED_WARNINGS_gcc += return-type switch clobbered\n+DISABLED_WARNINGS_gcc := array-bounds comment delete-non-virtual-dtor \\\n+    empty-body ignored-qualifiers implicit-fallthrough int-in-bool-context \\\n+    maybe-uninitialized missing-field-initializers parentheses \\\n+    shift-negative-value unknown-pragmas\n+\n+DISABLED_WARNINGS_clang := ignored-qualifiers sometimes-uninitialized \\\n+    missing-braces delete-non-abstract-non-virtual-dtor unknown-pragmas\n+\n+ifneq ($(DEBUG_LEVEL), release)\n+  # Assert macro gives warning\n+  DISABLED_WARNINGS_clang += tautological-constant-out-of-range-compare\n+  # Some reasonable asserts produce warnings on GCC <= 7\n+  DISABLED_WARNINGS_gcc += strict-overflow\n@@ -96,6 +101,0 @@\n-DISABLED_WARNINGS_clang := tautological-compare \\\n-    undefined-var-template sometimes-uninitialized unknown-pragmas \\\n-    delete-non-virtual-dtor missing-braces char-subscripts \\\n-    ignored-qualifiers missing-field-initializers mismatched-tags \\\n-    shift-negative-value misleading-indentation\n-\n@@ -104,2 +103,1 @@\n-DISABLED_WARNINGS_microsoft := 4100 4127 4146 4201 4244 4291 4351 \\\n-    4511 4512 4514 4624\n+DISABLED_WARNINGS_microsoft := 4624 4244 4291 4146 4127\n@@ -159,0 +157,20 @@\n+    DISABLED_WARNINGS_gcc_ad_$(HOTSPOT_TARGET_CPU_ARCH).cpp := nonnull, \\\n+    DISABLED_WARNINGS_gcc_assembler_aarch64.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_c1_LIR.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_cgroupV1Subsystem_linux.cpp := address, \\\n+    DISABLED_WARNINGS_gcc_cgroupV2Subsystem_linux.cpp := address, \\\n+    DISABLED_WARNINGS_gcc_interp_masm_x86.cpp := uninitialized, \\\n+    DISABLED_WARNINGS_gcc_javaClasses.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_postaloc.cpp := address, \\\n+    DISABLED_WARNINGS_gcc_sharedRuntimeTrig.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_shenandoahBarrierSet.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_shenandoahBarrierSetAssembler_aarch64.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_shenandoahBarrierSetAssembler_ppc.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_shenandoahBarrierSetAssembler_riscv.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_shenandoahBarrierSetAssembler_x86.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_shenandoahBarrierSetC1_aarch64.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_shenandoahBarrierSetC1_ppc.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_shenandoahBarrierSetC1_riscv.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_shenandoahBarrierSetC1_x86.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_shenandoahBarrierSetC1.cpp := misleading-indentation, \\\n+    DISABLED_WARNINGS_gcc_templateTable.cpp := cast-function-type, \\\n@@ -160,0 +178,10 @@\n+    DISABLED_WARNINGS_clang_arguments.cpp := missing-field-initializers, \\\n+    DISABLED_WARNINGS_clang_codeBuffer.cpp := tautological-undefined-compare, \\\n+    DISABLED_WARNINGS_clang_directivesParser.cpp := missing-field-initializers, \\\n+    DISABLED_WARNINGS_clang_g1ParScanThreadState.cpp := delete-abstract-non-virtual-dtor, \\\n+    DISABLED_WARNINGS_clang_g1YoungGCPostEvacuateTasks.cpp := delete-abstract-non-virtual-dtor, \\\n+    DISABLED_WARNINGS_clang_management.cpp := missing-field-initializers, \\\n+    DISABLED_WARNINGS_clang_os_posix.cpp := mismatched-tags missing-field-initializers, \\\n+    DISABLED_WARNINGS_clang_postaloc.cpp := tautological-undefined-compare, \\\n+    DISABLED_WARNINGS_clang_vm_version_x86.cpp := missing-field-initializers, \\\n+    DISABLED_WARNINGS_clang_zTracer.cpp := undefined-var-template, \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":44,"deletions":16,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -36,4 +36,0 @@\n-  BUILD_LIBJVM_assembler_x86.cpp_CXXFLAGS := -Wno-maybe-uninitialized\n-  BUILD_LIBJVM_cardTableBarrierSetAssembler_x86.cpp_CXXFLAGS := -Wno-maybe-uninitialized\n-  BUILD_LIBJVM_interp_masm_x86.cpp_CXXFLAGS := -Wno-uninitialized\n-  BUILD_LIBJVM_ad_$(HOTSPOT_TARGET_CPU_ARCH).cpp_CXXFLAGS := -Wno-nonnull\n","filename":"make\/hotspot\/lib\/JvmOverrideFiles.gmk","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -249,2 +249,1 @@\n-            return BigInteger.valueOf(2).pow(power)\n-                    .multiply(BigInteger.valueOf(coefficient));\n+            return BigInteger.valueOf(coefficient).shiftLeft(power);\n@@ -666,1 +665,1 @@\n-            String powExpr = \"BigInteger.valueOf(2).pow(\" + t.getPower() + \")\";\n+            String powExpr = \".shiftLeft(\" + t.getPower() + \")\";\n@@ -670,2 +669,0 @@\n-            } else if (coefValue == 1) {\n-                termExpr = powExpr;\n@@ -673,1 +670,1 @@\n-                termExpr = powExpr + \".multiply(\" + coefExpr + \")\";\n+                termExpr = coefExpr + powExpr;\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    LIBS_windows := jvm.lib ws2_32.lib $(WIN_JAVA_LIB) \\\n+    LIBS_windows := jvm.lib Mswsock.lib ws2_32.lib $(WIN_JAVA_LIB) \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,1 @@\n-    DISABLED_WARNINGS_gcc_e_asin.c := misleading-indentation, \\\n-    DISABLED_WARNINGS_gcc_k_rem_pio2.c := misleading-indentation maybe-uninitialized, \\\n+    DISABLED_WARNINGS_gcc_k_rem_pio2.c := maybe-uninitialized, \\\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -370,0 +370,1 @@\n+      include \\\n@@ -479,0 +480,1 @@\n+    include \\\n@@ -657,0 +659,2 @@\n+  LIBSPLASHSCREEN_HEADER_DIRS += include\n+\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-          $(call SET_SHARED_LIBRARY_ORIGIN) \\\n+          $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+      LIBS := Secur32.lib, \\\n","filename":"make\/modules\/java.security.jgss\/Lib.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,1 +77,2 @@\n-    LIBS_windows := $(LIBCXX), \\\n+    LIBS_windows := $(LIBCXX) user32.lib ole32.lib msi.lib shlwapi.lib \\\n+        Shell32.lib, \\\n@@ -127,1 +128,2 @@\n-      LIBS := $(LIBCXX), \\\n+      LIBS := $(LIBCXX) advapi32.lib ole32.lib msi.lib user32.lib \\\n+          shlwapi.lib Shell32.lib, \\\n@@ -147,2 +149,2 @@\n-      LIBS := $(LIBCXX), \\\n-      LIBS_windows := User32.lib, \\\n+      LIBS := $(LIBCXX) ole32.lib msi.lib User32.lib shlwapi.lib \\\n+          Shell32.lib, \\\n@@ -166,1 +168,1 @@\n-      LIBS := $(LIBCXX), \\\n+      LIBS := $(LIBCXX) ole32.lib msi.lib user32.lib shlwapi.lib Shell32.lib, \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-DISABLED_WARNINGS_java += lossy-conversions\n","filename":"make\/modules\/jdk.naming.dns\/Java.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -463,0 +463,1 @@\n+    \/\/ Governing predicates for load\/store and arithmetic\n@@ -470,1 +471,0 @@\n-    P7,\n@@ -472,0 +472,1 @@\n+    \/\/ Extra predicates\n@@ -480,0 +481,3 @@\n+\n+    \/\/ Preserved for all-true predicate\n+    P7,\n@@ -5581,0 +5585,1 @@\n+  match(pReg);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -460,2 +460,1 @@\n-instruct vloadconB(vReg dst, immI0 src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+instruct vloadcon(vReg dst, immI0 src) %{\n@@ -463,1 +462,1 @@\n-  format %{ \"vloadconB $dst, $src\\t# load\/generate iota indices\" %}\n+  format %{ \"vloadcon $dst, $src\\t# load\/generate iota indices\" %}\n@@ -465,0 +464,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -468,1 +468,6 @@\n-      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n+      \/\/ The iota indices are ordered by type B\/S\/I\/L\/F\/D, and the offset between two types is 16.\n+      int offset = exact_log2(type2aelembytes(bt)) << 4;\n+      if (is_floating_point_type(bt)) {\n+        offset += 32;\n+      }\n+      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices() + offset));\n@@ -475,1 +480,5 @@\n-      __ sve_index($dst$$FloatRegister, __ B, 0, 1);\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_index($dst$$FloatRegister, size, 0, 1);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n@@ -4662,1 +4671,1 @@\n-instruct vloadmaskB_sve(pRegGov dst, vReg src, rFlagsReg cr) %{\n+instruct vloadmaskB_sve(pReg dst, vReg src, rFlagsReg cr) %{\n@@ -4674,1 +4683,1 @@\n-instruct vloadmask_extend_sve(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_sve(pReg dst, vReg src, vReg tmp, rFlagsReg cr) %{\n@@ -4688,1 +4697,1 @@\n-instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n+instruct vloadmaskB_masked(pReg dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n@@ -4700,1 +4709,1 @@\n-instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_masked(pReg dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -4754,1 +4763,1 @@\n-instruct vstoremaskB_sve(vReg dst, pRegGov src, immI_1 size) %{\n+instruct vstoremaskB_sve(vReg dst, pReg src, immI_1 size) %{\n@@ -4764,1 +4773,1 @@\n-instruct vstoremask_narrow_sve(vReg dst, pRegGov src, immI_gt_1 size, vReg tmp) %{\n+instruct vstoremask_narrow_sve(vReg dst, pReg src, immI_gt_1 size, vReg tmp) %{\n@@ -4781,1 +4790,1 @@\n-instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadV(pReg dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n@@ -4803,1 +4812,1 @@\n-instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg,\n+instruct vloadmask_loadV_masked(pReg dst, indirect mem, pRegGov pg,\n@@ -4824,1 +4833,1 @@\n-instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadVMasked(pReg dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -4851,1 +4860,1 @@\n-instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n+instruct vloadmask_loadVMasked_masked(pReg dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n@@ -4881,1 +4890,1 @@\n-instruct storeV_vstoremask(indirect mem, pRegGov src, immI_gt_1 esize, vReg tmp) %{\n+instruct storeV_vstoremask(indirect mem, pReg src, immI_gt_1 esize, vReg tmp) %{\n@@ -4902,1 +4911,1 @@\n-instruct storeV_vstoremask_masked(indirect mem, pRegGov src, immI_gt_1 esize,\n+instruct storeV_vstoremask_masked(indirect mem, pReg src, immI_gt_1 esize,\n@@ -4924,1 +4933,1 @@\n-instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n+instruct storeVMasked_vstoremask(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n@@ -4950,1 +4959,1 @@\n-instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize,\n+instruct storeVMasked_vstoremask_masked(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize,\n@@ -4980,1 +4989,1 @@\n-instruct vmask_and(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_and(pReg pd, pReg pn, pReg pm) %{\n@@ -4990,1 +4999,1 @@\n-instruct vmask_or(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_or(pReg pd, pReg pn, pReg pm) %{\n@@ -5000,1 +5009,1 @@\n-instruct vmask_xor(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_xor(pReg pd, pReg pn, pReg pm) %{\n@@ -5010,1 +5019,1 @@\n-instruct vmask_and_notI(pRegGov pd, pRegGov pn, pRegGov pm, immI_M1 m1) %{\n+instruct vmask_and_notI(pReg pd, pReg pn, pReg pm, immI_M1 m1) %{\n@@ -5020,1 +5029,1 @@\n-instruct vmask_and_notL(pRegGov pd, pRegGov pn, pRegGov pm, immL_M1 m1) %{\n+instruct vmask_and_notL(pReg pd, pReg pn, pReg pm, immL_M1 m1) %{\n@@ -5048,1 +5057,1 @@\n-instruct vmaskcmp_sve(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+instruct vmaskcmp_sve(pReg dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n@@ -5063,1 +5072,1 @@\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond,\n+instruct vmaskcmp_masked(pReg dst, vReg src1, vReg src2, immI cond,\n@@ -5090,1 +5099,43 @@\n-instruct vmaskcast_same_esize_sve(pRegGov dst_src) %{\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_same_esize_sve(pReg dst_src) %{\n@@ -5100,1 +5151,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pReg dst, pReg src) %{\n@@ -5104,1 +5155,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -5117,1 +5168,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pReg dst, pReg src) %{\n@@ -5121,1 +5172,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n@@ -5136,1 +5187,1 @@\n-instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n+instruct vmask_reinterpret_same_esize(pReg dst_src) %{\n@@ -5147,1 +5198,1 @@\n-instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n+instruct vmask_reinterpret_diff_esize(pReg dst, pReg src, vReg tmp, rFlagsReg cr) %{\n@@ -5293,1 +5344,1 @@\n-instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n+instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pReg pg, pReg ptmp) %{\n@@ -5405,1 +5456,1 @@\n-instruct vmask_fromlong(pRegGov dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+instruct vmask_fromlong(pReg dst, iRegL src, vReg tmp1, vReg tmp2) %{\n@@ -5422,1 +5473,1 @@\n-instruct vmaskAll_immI(pRegGov dst, immI src, rFlagsReg cr) %{\n+instruct vmaskAll_immI(pReg dst, immI src, rFlagsReg cr) %{\n@@ -5440,1 +5491,1 @@\n-instruct vmaskAllI(pRegGov dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllI(pReg dst, iRegIorL2I src, vReg tmp, rFlagsReg cr) %{\n@@ -5456,1 +5507,1 @@\n-instruct vmaskAllI_masked(pRegGov dst, iRegIorL2I src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllI_masked(pReg dst, iRegIorL2I src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -5471,1 +5522,1 @@\n-instruct vmaskAll_immL(pRegGov dst, immL src, rFlagsReg cr) %{\n+instruct vmaskAll_immL(pReg dst, immL src, rFlagsReg cr) %{\n@@ -5489,1 +5540,1 @@\n-instruct vmaskAllL(pRegGov dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllL(pReg dst, iRegL src, vReg tmp, rFlagsReg cr) %{\n@@ -5505,1 +5556,1 @@\n-instruct vmaskAllL_masked(pRegGov dst, iRegL src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAllL_masked(pReg dst, iRegL src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -5522,1 +5573,1 @@\n-instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n+instruct vmask_gen_I(pReg pd, iRegIorL2I src, rFlagsReg cr) %{\n@@ -5534,1 +5585,1 @@\n-instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n+instruct vmask_gen_L(pReg pd, iRegL src, rFlagsReg cr) %{\n@@ -5546,1 +5597,1 @@\n-instruct vmask_gen_imm(pRegGov pd, immL con, rFlagsReg cr) %{\n+instruct vmask_gen_imm(pReg pd, immL con, rFlagsReg cr) %{\n@@ -5840,1 +5891,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(iRegINoSp dst, pReg src1, pReg src2, rFlagsReg cr) %{\n@@ -5874,1 +5925,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(iRegINoSp dst, pReg src1, pReg src2, pReg ptmp, rFlagsReg cr) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":97,"deletions":46,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -399,2 +399,1 @@\n-instruct vloadconB(vReg dst, immI0 src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+instruct vloadcon(vReg dst, immI0 src) %{\n@@ -402,1 +401,1 @@\n-  format %{ \"vloadconB $dst, $src\\t# load\/generate iota indices\" %}\n+  format %{ \"vloadcon $dst, $src\\t# load\/generate iota indices\" %}\n@@ -404,0 +403,1 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -407,1 +407,6 @@\n-      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices()));\n+      \/\/ The iota indices are ordered by type B\/S\/I\/L\/F\/D, and the offset between two types is 16.\n+      int offset = exact_log2(type2aelembytes(bt)) << 4;\n+      if (is_floating_point_type(bt)) {\n+        offset += 32;\n+      }\n+      __ lea(rscratch1, ExternalAddress(StubRoutines::aarch64::vector_iota_indices() + offset));\n@@ -414,1 +419,5 @@\n-      __ sve_index($dst$$FloatRegister, __ B, 0, 1);\n+      Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+      __ sve_index($dst$$FloatRegister, size, 0, 1);\n+      if (is_floating_point_type(bt)) {\n+        __ sve_scvtf($dst$$FloatRegister, size, ptrue, $dst$$FloatRegister, size);\n+      }\n@@ -3096,1 +3105,1 @@\n-instruct vloadmaskB_sve(pRegGov dst, vReg src, rFlagsReg cr) %{\n+instruct vloadmaskB_sve(pReg dst, vReg src, rFlagsReg cr) %{\n@@ -3108,1 +3117,1 @@\n-instruct vloadmask_extend_sve(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_sve(pReg dst, vReg src, vReg tmp, rFlagsReg cr) %{\n@@ -3122,1 +3131,1 @@\n-instruct vloadmaskB_masked(pRegGov dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n+instruct vloadmaskB_masked(pReg dst, vReg src, pRegGov pg, rFlagsReg cr) %{\n@@ -3134,1 +3143,1 @@\n-instruct vloadmask_extend_masked(pRegGov dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_extend_masked(pReg dst, vReg src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -3188,1 +3197,1 @@\n-instruct vstoremaskB_sve(vReg dst, pRegGov src, immI_1 size) %{\n+instruct vstoremaskB_sve(vReg dst, pReg src, immI_1 size) %{\n@@ -3198,1 +3207,1 @@\n-instruct vstoremask_narrow_sve(vReg dst, pRegGov src, immI_gt_1 size, vReg tmp) %{\n+instruct vstoremask_narrow_sve(vReg dst, pReg src, immI_gt_1 size, vReg tmp) %{\n@@ -3215,1 +3224,1 @@\n-instruct vloadmask_loadV(pRegGov dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadV(pReg dst, indirect mem, vReg tmp, rFlagsReg cr) %{\n@@ -3237,1 +3246,1 @@\n-instruct vloadmask_loadV_masked(pRegGov dst, indirect mem, pRegGov pg,\n+instruct vloadmask_loadV_masked(pReg dst, indirect mem, pRegGov pg,\n@@ -3258,1 +3267,1 @@\n-instruct vloadmask_loadVMasked(pRegGov dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vloadmask_loadVMasked(pReg dst, vmemA mem, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -3285,1 +3294,1 @@\n-instruct vloadmask_loadVMasked_masked(pRegGov dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n+instruct vloadmask_loadVMasked_masked(pReg dst, vmemA mem, pRegGov pg1, pRegGov pg2,\n@@ -3315,1 +3324,1 @@\n-instruct storeV_vstoremask(indirect mem, pRegGov src, immI_gt_1 esize, vReg tmp) %{\n+instruct storeV_vstoremask(indirect mem, pReg src, immI_gt_1 esize, vReg tmp) %{\n@@ -3336,1 +3345,1 @@\n-instruct storeV_vstoremask_masked(indirect mem, pRegGov src, immI_gt_1 esize,\n+instruct storeV_vstoremask_masked(indirect mem, pReg src, immI_gt_1 esize,\n@@ -3358,1 +3367,1 @@\n-instruct storeVMasked_vstoremask(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n+instruct storeVMasked_vstoremask(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize, vReg tmp) %{\n@@ -3384,1 +3393,1 @@\n-instruct storeVMasked_vstoremask_masked(vmemA mem, pRegGov src, pRegGov pg, immI_gt_1 esize,\n+instruct storeVMasked_vstoremask_masked(vmemA mem, pReg src, pRegGov pg, immI_gt_1 esize,\n@@ -3416,1 +3425,1 @@\n-instruct vmask_$1(pRegGov pd, pRegGov pn, pRegGov pm) %{\n+instruct vmask_$1(pReg pd, pReg pn, pReg pm) %{\n@@ -3429,1 +3438,1 @@\n-instruct vmask_and_not$1(pRegGov pd, pRegGov pn, pRegGov pm, imm$1_M1 m1) %{\n+instruct vmask_and_not$1(pReg pd, pReg pn, pReg pm, imm$1_M1 m1) %{\n@@ -3464,1 +3473,1 @@\n-instruct vmaskcmp_sve(pRegGov dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n+instruct vmaskcmp_sve(pReg dst, vReg src1, vReg src2, immI cond, rFlagsReg cr) %{\n@@ -3479,1 +3488,1 @@\n-instruct vmaskcmp_masked(pRegGov dst, vReg src1, vReg src2, immI cond,\n+instruct vmaskcmp_masked(pReg dst, vReg src1, vReg src2, immI cond,\n@@ -3506,1 +3515,43 @@\n-instruct vmaskcast_same_esize_sve(pRegGov dst_src) %{\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_same_esize_sve(pReg dst_src) %{\n@@ -3516,1 +3567,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pReg dst, pReg src) %{\n@@ -3520,1 +3571,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -3533,1 +3584,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pReg dst, pReg src) %{\n@@ -3537,1 +3588,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n@@ -3552,1 +3603,1 @@\n-instruct vmask_reinterpret_same_esize(pRegGov dst_src) %{\n+instruct vmask_reinterpret_same_esize(pReg dst_src) %{\n@@ -3563,1 +3614,1 @@\n-instruct vmask_reinterpret_diff_esize(pRegGov dst, pRegGov src, vReg tmp, rFlagsReg cr) %{\n+instruct vmask_reinterpret_diff_esize(pReg dst, pReg src, vReg tmp, rFlagsReg cr) %{\n@@ -3709,1 +3760,1 @@\n-instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pRegGov pg, pReg ptmp) %{\n+instruct vmask_firsttrue_masked(iRegINoSp dst, pReg src, pReg pg, pReg ptmp) %{\n@@ -3821,1 +3872,1 @@\n-instruct vmask_fromlong(pRegGov dst, iRegL src, vReg tmp1, vReg tmp2) %{\n+instruct vmask_fromlong(pReg dst, iRegL src, vReg tmp1, vReg tmp2) %{\n@@ -3841,1 +3892,1 @@\n-instruct vmaskAll_imm$1(pRegGov dst, imm$1 src, rFlagsReg cr) %{\n+instruct vmaskAll_imm$1(pReg dst, imm$1 src, rFlagsReg cr) %{\n@@ -3862,1 +3913,1 @@\n-instruct vmaskAll$1(pRegGov dst, $2 src, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAll$1(pReg dst, $2 src, vReg tmp, rFlagsReg cr) %{\n@@ -3881,1 +3932,1 @@\n-instruct vmaskAll$1_masked(pRegGov dst, $2 src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n+instruct vmaskAll$1_masked(pReg dst, $2 src, pRegGov pg, vReg tmp, rFlagsReg cr) %{\n@@ -3905,1 +3956,1 @@\n-instruct vmask_gen_I(pRegGov pd, iRegIorL2I src, rFlagsReg cr) %{\n+instruct vmask_gen_I(pReg pd, iRegIorL2I src, rFlagsReg cr) %{\n@@ -3917,1 +3968,1 @@\n-instruct vmask_gen_L(pRegGov pd, iRegL src, rFlagsReg cr) %{\n+instruct vmask_gen_L(pReg pd, iRegL src, rFlagsReg cr) %{\n@@ -3929,1 +3980,1 @@\n-instruct vmask_gen_imm(pRegGov pd, immL con, rFlagsReg cr) %{\n+instruct vmask_gen_imm(pReg pd, immL con, rFlagsReg cr) %{\n@@ -4212,1 +4263,1 @@\n-instruct vtest_anytrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, rFlagsReg cr) %{\n+instruct vtest_anytrue_sve(iRegINoSp dst, pReg src1, pReg src2, rFlagsReg cr) %{\n@@ -4246,1 +4297,1 @@\n-instruct vtest_alltrue_sve(iRegINoSp dst, pRegGov src1, pRegGov src2, pReg ptmp, rFlagsReg cr) %{\n+instruct vtest_alltrue_sve(iRegINoSp dst, pReg src1, pReg src2, pReg ptmp, rFlagsReg cr) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":91,"deletions":40,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -1002,1 +1002,1 @@\n-\/\/ Clobbers: rscratch1 if hardware doesn't support FEAT_BITPERM.\n+\/\/ Clobbers: rscratch1, if UseSVE=1 or the hardware doesn't support FEAT_BITPERM.\n@@ -1020,15 +1020,2 @@\n-  if (UseSVE > 0 && !VM_Version::supports_svebitperm()) {\n-    \/\/ Compress the lowest 8 bytes.\n-    fmovd(dst, vtmp1);\n-    bytemask_compress(dst);\n-    if (lane_cnt <= 8) return;\n-\n-    \/\/ Repeat on higher bytes and join the results.\n-    \/\/ Compress 8 bytes in each iteration.\n-    for (int idx = 1; idx < (lane_cnt \/ 8); idx++) {\n-      sve_extract_integral(rscratch1, T_LONG, vtmp1, idx, vtmp2);\n-      bytemask_compress(rscratch1);\n-      orr(dst, dst, rscratch1, Assembler::LSL, idx << 3);\n-    }\n-  } else if (UseSVE == 2 && VM_Version::supports_svebitperm()) {\n-    \/\/ Given by the vector with value 0x00 or 0x01 in each byte, the basic idea\n+  if (UseSVE > 1 && VM_Version::supports_svebitperm()) {\n+    \/\/ Given a vector with the value 0x00 or 0x01 in each byte, the basic idea\n@@ -1036,3 +1023,3 @@\n-    \/\/ to the lack of cross-lane bit-compress instruction, here we use BEXT\n-    \/\/ (bit-compress in each lane) with the biggest lane size (T = D) and\n-    \/\/ concatenates the results then.\n+    \/\/ to the lack of a cross-lane bit-compress instruction, we use BEXT\n+    \/\/ (bit-compress in each lane) with the biggest lane size (T = D) then\n+    \/\/ concatenate the results.\n@@ -1067,0 +1054,13 @@\n+  } else if (UseSVE > 0) {\n+    \/\/ Compress the lowest 8 bytes.\n+    fmovd(dst, vtmp1);\n+    bytemask_compress(dst);\n+    if (lane_cnt <= 8) return;\n+\n+    \/\/ Repeat on higher bytes and join the results.\n+    \/\/ Compress 8 bytes in each iteration.\n+    for (int idx = 1; idx < (lane_cnt \/ 8); idx++) {\n+      sve_extract_integral(rscratch1, T_LONG, vtmp1, idx, vtmp2);\n+      bytemask_compress(rscratch1);\n+      orr(dst, dst, rscratch1, Assembler::LSL, idx << 3);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-                                  Register start, Register end, Register tmp, RegSet saved_regs) {}\n+                                  Register start, Register count, Register tmp, RegSet saved_regs) {}\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-  load_heap_oop(result, Address(result, index, Address::uxtw(LogBytesPerHeapOop)));\n+  load_heap_oop(result, Address(result, index, Address::uxtw(LogBytesPerHeapOop)), tmp, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1138,1 +1138,1 @@\n-  load_heap_oop(obj, field);\n+  load_heap_oop(obj, field, temp_reg, rscratch2);\n@@ -2056,18 +2056,0 @@\n-void MacroAssembler::atomic_incw(Register counter_addr, Register tmp, Register tmp2) {\n-  if (UseLSE) {\n-    mov(tmp, 1);\n-    ldadd(Assembler::word, tmp, zr, counter_addr);\n-    return;\n-  }\n-  Label retry_load;\n-  prfm(Address(counter_addr), PSTL1STRM);\n-  bind(retry_load);\n-  \/\/ flush and load exclusive from the memory location\n-  ldxrw(tmp, counter_addr);\n-  addw(tmp, tmp, 1);\n-  \/\/ if we store+flush with no intervening write tmp will be zero\n-  stxrw(tmp2, tmp, counter_addr);\n-  cbnzw(tmp2, retry_load);\n-}\n-\n-\n@@ -2242,1 +2224,1 @@\n-void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {\n+void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed) {\n@@ -2252,1 +2234,1 @@\n-void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {\n+void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes) {\n@@ -2560,1 +2542,1 @@\n-  unsigned char regs[PRegister::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_registers];\n@@ -2562,1 +2544,1 @@\n-  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_registers; reg++) {\n@@ -2597,1 +2579,1 @@\n-  unsigned char regs[PRegister::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_registers];\n@@ -2599,1 +2581,1 @@\n-  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_registers; reg++) {\n@@ -3103,1 +3085,1 @@\n-    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n+    for (int i = 0; i < PRegister::number_of_registers; i++) {\n@@ -3112,1 +3094,1 @@\n-    for (int i = PRegister::number_of_saved_registers - 1; i >= 0; i--) {\n+    for (int i = PRegister::number_of_registers - 1; i >= 0; i--) {\n@@ -4590,1 +4572,1 @@\n-                                     Address dst, Register src,\n+                                     Address dst, Register val,\n@@ -4596,1 +4578,1 @@\n-    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -4598,1 +4580,1 @@\n-    bs->store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -4652,1 +4634,1 @@\n-void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,\n+void MacroAssembler::store_heap_oop(Address dst, Register val, Register tmp1,\n@@ -4654,1 +4636,1 @@\n-  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);\n+  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, val, tmp1, tmp2, tmp3);\n@@ -6233,1 +6215,1 @@\n-        load_heap_oop(dst, fromAddr);\n+        load_heap_oop(dst, fromAddr, rscratch1, rscratch2);\n@@ -6321,1 +6303,1 @@\n-  load_heap_oop(val_obj, Address(val_array, index));\n+  load_heap_oop(val_obj, Address(val_array, index), tmp1, tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":16,"deletions":34,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -118,7 +118,0 @@\n-  \/\/ Helper functions for statistics gathering.\n-  \/\/ Unconditional atomic increment.\n-  void atomic_incw(Register counter_addr, Register tmp, Register tmp2);\n-  void atomic_incw(Address counter_addr, Register tmp1, Register tmp2, Register tmp3) {\n-    lea(tmp1, counter_addr);\n-    atomic_incw(tmp1, tmp2, tmp3);\n-  }\n@@ -696,2 +689,2 @@\n-  void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);\n-  void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);\n+  void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed);\n+  void store_sized_value(Address dst, Register src, size_t size_in_bytes);\n@@ -891,1 +884,1 @@\n-  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,\n+  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register val,\n@@ -903,2 +896,2 @@\n-  void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,\n-                     Register tmp2 = noreg, DecoratorSet decorators = 0);\n+  void load_heap_oop(Register dst, Address src, Register tmp1,\n+                     Register tmp2, DecoratorSet decorators = 0);\n@@ -906,4 +899,4 @@\n-  void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,\n-                              Register tmp2 = noreg, DecoratorSet decorators = 0);\n-  void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,\n-                      Register tmp2 = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);\n+  void load_heap_oop_not_null(Register dst, Address src, Register tmp1,\n+                              Register tmp2, DecoratorSet decorators = 0);\n+  void store_heap_oop(Address dst, Register val, Register tmp1,\n+                      Register tmp2, Register tmp3, DecoratorSet decorators = 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  __ load_heap_oop(method_temp, Address(recv, NONZERO(java_lang_invoke_MethodHandle::form_offset())), temp2);\n+  __ load_heap_oop(method_temp, Address(recv, NONZERO(java_lang_invoke_MethodHandle::form_offset())), temp2, rscratch2);\n@@ -145,1 +145,1 @@\n-  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset())), temp2);\n+  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset())), temp2, rscratch2);\n@@ -147,1 +147,1 @@\n-  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset())), temp2);\n+  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset())), temp2, rscratch2);\n@@ -344,1 +344,1 @@\n-        __ load_heap_oop(temp2_defc, member_clazz, temp3);\n+        __ load_heap_oop(temp2_defc, member_clazz, temp3, rscratch2);\n@@ -372,1 +372,1 @@\n-      __ load_heap_oop(rmethod, member_vmtarget);\n+      __ load_heap_oop(rmethod, member_vmtarget, temp3, rscratch2);\n@@ -380,1 +380,1 @@\n-      __ load_heap_oop(rmethod, member_vmtarget);\n+      __ load_heap_oop(rmethod, member_vmtarget, temp3, rscratch2);\n@@ -422,1 +422,1 @@\n-      __ load_heap_oop(temp3_intf, member_clazz);\n+      __ load_heap_oop(temp3_intf, member_clazz, temp2, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -299,5 +299,0 @@\n-    \/\/ p0-p7 are governing predicates for load\/store and arithmetic, but p7 is\n-    \/\/ preserved as an all-true predicate in OpenJDK. And since we don't support\n-    \/\/ non-governing predicate registers allocation for non-temp register, the\n-    \/\/ predicate registers to be saved are p0-p6.\n-    number_of_saved_registers = number_of_governing_registers - 1,\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -165,5 +165,2 @@\n-    \/\/ The number of total predicate bytes is unlikely to be a multiple\n-    \/\/ of 16 bytes so we manually align it up.\n-    return align_up(Matcher::scalable_predicate_reg_slots() *\n-                    VMRegImpl::stack_slot_size *\n-                    PRegister::number_of_saved_registers, 16);\n+    return (Matcher::scalable_vector_reg_size(T_BYTE) >> LogBitsPerByte) *\n+           PRegister::number_of_registers;\n@@ -255,8 +252,0 @@\n-  if (_save_vectors && use_sve) {\n-    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n-      PRegister r = as_PRegister(i);\n-      int sp_offset = sve_predicate_size_in_slots * i;\n-      oop_map->set_callee_saved(VMRegImpl::stack2reg(sp_offset), r->as_VMReg());\n-    }\n-  }\n-\n@@ -758,1 +747,1 @@\n-      __ load_heap_oop(buf_oop, Address(buf_array, index));\n+      __ load_heap_oop(buf_oop, Address(buf_array, index), tmp1, tmp2);\n@@ -3423,1 +3412,1 @@\n-      __ load_heap_oop(r_1->as_Register(), from);\n+      __ load_heap_oop(r_1->as_Register(), from, rscratch1, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -651,0 +651,1 @@\n+    \/\/ B\n@@ -653,0 +654,15 @@\n+    \/\/ H\n+    __ emit_data64(0x0003000200010000, relocInfo::none);\n+    __ emit_data64(0x0007000600050004, relocInfo::none);\n+    \/\/ S\n+    __ emit_data64(0x0000000100000000, relocInfo::none);\n+    __ emit_data64(0x0000000300000002, relocInfo::none);\n+    \/\/ D\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000001, relocInfo::none);\n+    \/\/ S - FP\n+    __ emit_data64(0x3F80000000000000, relocInfo::none); \/\/ 0.0f, 1.0f\n+    __ emit_data64(0x4040000040000000, relocInfo::none); \/\/ 2.0f, 3.0f\n+    \/\/ D - FP\n+    __ emit_data64(0x0000000000000000, relocInfo::none); \/\/ 0.0d\n+    __ emit_data64(0x3FF0000000000000, relocInfo::none); \/\/ 1.0d\n@@ -8010,1 +8026,3 @@\n-    StubRoutines::aarch64::_vector_iota_indices    = generate_iota_indices(\"iota_indices\");\n+    if (UseSVE == 0) {\n+      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1988,9 +1988,2 @@\n-  Register rscratch3 = r0;\n-  __ push(rscratch1);\n-  __ push(rscratch2);\n-  __ push(rscratch3);\n-  __ mov(rscratch3, (address) &BytecodeCounter::_counter_value);\n-  __ atomic_add(noreg, 1, rscratch3);\n-  __ pop(rscratch3);\n-  __ pop(rscratch2);\n-  __ pop(rscratch1);\n+  __ mov(r10, (address) &BytecodeCounter::_counter_value);\n+  __ atomic_addw(noreg, 1, r10);\n@@ -1999,3 +1992,4 @@\n-void TemplateInterpreterGenerator::histogram_bytecode(Template* t) { ; }\n-\n-void TemplateInterpreterGenerator::histogram_bytecode_pair(Template* t) { ; }\n+void TemplateInterpreterGenerator::histogram_bytecode(Template* t) {\n+  __ mov(r10, (address) &BytecodeHistogram::_counters[t->bytecode()]);\n+  __ atomic_addw(noreg, 1, r10);\n+}\n@@ -2003,0 +1997,21 @@\n+void TemplateInterpreterGenerator::histogram_bytecode_pair(Template* t) {\n+  \/\/ Calculate new index for counter:\n+  \/\/   _index = (_index >> log2_number_of_codes) |\n+  \/\/            (bytecode << log2_number_of_codes);\n+  Register index_addr = rscratch1;\n+  Register index = rscratch2;\n+  __ mov(index_addr, (address) &BytecodePairHistogram::_index);\n+  __ ldrw(index, index_addr);\n+  __ mov(r10,\n+         ((int)t->bytecode()) << BytecodePairHistogram::log2_number_of_codes);\n+  __ orrw(index, r10, index, Assembler::LSR,\n+          BytecodePairHistogram::log2_number_of_codes);\n+  __ strw(index, index_addr);\n+\n+  \/\/ Bump bucket contents:\n+  \/\/   _counters[_index] ++;\n+  Register counter_addr = rscratch1;\n+  __ mov(r10, (address) &BytecodePairHistogram::_counters);\n+  __ lea(counter_addr, Address(r10, index, Address::lsl(LogBytesPerInt)));\n+  __ atomic_addw(noreg, 1, counter_addr);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2621,1 +2621,1 @@\n-      __ load_heap_oop(r0, field);\n+      __ load_heap_oop(r0, field, rscratch1, rscratch2);\n@@ -2651,1 +2651,1 @@\n-        __ load_heap_oop(r0, field);\n+        __ load_heap_oop(r0, field, rscratch1, rscratch2);\n@@ -2660,1 +2660,1 @@\n-          __ load_heap_oop(r0, field);\n+          __ load_heap_oop(r0, field, rscratch1, rscratch2);\n@@ -3314,1 +3314,1 @@\n-        __ load_heap_oop(r0, field);\n+        __ load_heap_oop(r0, field, rscratch1, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+  static void assert_is_rfp(VMReg r) NOT_DEBUG_RETURN\n","filename":"src\/hotspot\/cpu\/arm\/smallRegisterMap_arm.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 SAP SE. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"nativeInst_ppc.hpp\"\n@@ -166,1 +165,2 @@\n-  __ lwz(R0, in_bytes(bs_nm->thread_disarmed_offset()), R16_thread);\n+  \/\/ Low order half of 64 bit value is currently used.\n+  __ ld(R0, in_bytes(bs_nm->thread_disarmed_offset()), R16_thread);\n@@ -171,2 +171,6 @@\n-  \/\/ Oops may have been changed; exploiting isync semantics (used as acquire) to make those updates observable.\n-  __ isync();\n+  \/\/ Oops may have been changed. Make those updates observable.\n+  \/\/ \"isync\" can serve both, data and instruction patching.\n+  \/\/ But, many GCs don't modify nmethods during a concurrent phase.\n+  if (nmethod_patching_type() != NMethodPatchingType::stw_instruction_and_data_patch) {\n+    __ isync();\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 SAP SE. All rights reserved.\n@@ -33,1 +33,5 @@\n-class InterpreterMacroAssembler;\n+enum class NMethodPatchingType {\n+  stw_instruction_and_data_patch,\n+  conc_instruction_and_data_patch,\n+  conc_data_patch\n+};\n@@ -61,0 +65,2 @@\n+  virtual NMethodPatchingType nmethod_patching_type() { return NMethodPatchingType::stw_instruction_and_data_patch; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -77,1 +79,1 @@\n-    verify_op_code(current_instruction, Assembler::LWZ_OPCODE);\n+    verify_op_code(current_instruction, Assembler::LD_OPCODE);\n@@ -85,1 +87,1 @@\n-    verify_op_code(current_instruction, Assembler::ISYNC_OPCODE);\n+    \/\/ isync is optional\n@@ -103,1 +105,5 @@\n-  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + (-9 * 4);\n+  BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + (-8 * 4);\n+  if (bs_asm->nmethod_patching_type() != NMethodPatchingType::stw_instruction_and_data_patch) {\n+    barrier_address -= 4; \/\/ isync (see nmethod_entry_barrier)\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetNMethod_ppc.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2022, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n@@ -64,0 +64,1 @@\n+  virtual NMethodPatchingType nmethod_patching_type() { return NMethodPatchingType::conc_data_patch; }\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n@@ -67,0 +67,2 @@\n+  virtual NMethodPatchingType nmethod_patching_type() { return NMethodPatchingType::conc_data_patch; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -401,1 +401,1 @@\n-inline void MacroAssembler::store_heap_oop(Register d, RegisterOrConstant offs, Register s1,\n+inline void MacroAssembler::store_heap_oop(Register val, RegisterOrConstant offs, Register base,\n@@ -405,1 +405,1 @@\n-  access_store_at(T_OBJECT, decorators | IN_HEAP, s1, offs, d, tmp1, tmp2, tmp3, preservation_level);\n+  access_store_at(T_OBJECT, decorators | IN_HEAP, base, offs, val, tmp1, tmp2, tmp3, preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+  static void assert_is_rfp(VMReg r) NOT_DEBUG_RETURN\n","filename":"src\/hotspot\/cpu\/ppc\/smallRegisterMap_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,261 +43,0 @@\n-void Assembler::add(Register Rd, Register Rn, int64_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addi(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    add(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\n-  if (is_imm_in_range(increment, 12, 0)) {\n-    addiw(Rd, Rn, increment);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, increment);\n-    addw(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::sub(Register Rd, Register Rn, int64_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addi(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    sub(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n-  if (is_imm_in_range(-decrement, 12, 0)) {\n-    addiw(Rd, Rn, -decrement);\n-  } else {\n-    assert_different_registers(Rn, temp);\n-    li(temp, decrement);\n-    subw(Rd, Rn, temp);\n-  }\n-}\n-\n-void Assembler::zext_w(Register Rd, Register Rs) {\n-  add_uw(Rd, Rs, zr);\n-}\n-\n-void Assembler::_li(Register Rd, int64_t imm) {\n-  \/\/ int64_t is in range 0x8000 0000 0000 0000 ~ 0x7fff ffff ffff ffff\n-  int shift = 12;\n-  int64_t upper = imm, lower = imm;\n-  \/\/ Split imm to a lower 12-bit sign-extended part and the remainder,\n-  \/\/ because addi will sign-extend the lower imm.\n-  lower = ((int32_t)imm << 20) >> 20;\n-  upper -= lower;\n-\n-  \/\/ Test whether imm is a 32-bit integer.\n-  if (!(((imm) & ~(int64_t)0x7fffffff) == 0 ||\n-        (((imm) & ~(int64_t)0x7fffffff) == ~(int64_t)0x7fffffff))) {\n-    while (((upper >> shift) & 1) == 0) { shift++; }\n-    upper >>= shift;\n-    li(Rd, upper);\n-    slli(Rd, Rd, shift);\n-    if (lower != 0) {\n-      addi(Rd, Rd, lower);\n-    }\n-  } else {\n-    \/\/ 32-bit integer\n-    Register hi_Rd = zr;\n-    if (upper != 0) {\n-      lui(Rd, (int32_t)upper);\n-      hi_Rd = Rd;\n-    }\n-    if (lower != 0 || hi_Rd == zr) {\n-      addiw(Rd, hi_Rd, lower);\n-    }\n-  }\n-}\n-\n-void Assembler::li64(Register Rd, int64_t imm) {\n-  \/\/ Load upper 32 bits. upper = imm[63:32], but if imm[31] == 1 or\n-  \/\/ (imm[31:20] == 0x7ff && imm[19] == 1), upper = imm[63:32] + 1.\n-  int64_t lower = imm & 0xffffffff;\n-  lower -= ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)(imm & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper = (tmp_imm - (int32_t)lower) >> 32;\n-\n-  \/\/ Load upper 32 bits\n-  int64_t up = upper, lo = upper;\n-  lo = (lo << 52) >> 52;\n-  up -= lo;\n-  up = (int32_t)up;\n-  lui(Rd, up);\n-  addi(Rd, Rd, lo);\n-\n-  \/\/ Load the rest 32 bits.\n-  slli(Rd, Rd, 12);\n-  addi(Rd, Rd, (int32_t)lower >> 20);\n-  slli(Rd, Rd, 12);\n-  lower = ((int32_t)imm << 12) >> 20;\n-  addi(Rd, Rd, lower);\n-  slli(Rd, Rd, 8);\n-  lower = imm & 0xff;\n-  addi(Rd, Rd, lower);\n-}\n-\n-void Assembler::li32(Register Rd, int32_t imm) {\n-  \/\/ int32_t is in range 0x8000 0000 ~ 0x7fff ffff, and imm[31] is the sign bit\n-  int64_t upper = imm, lower = imm;\n-  lower = (imm << 20) >> 20;\n-  upper -= lower;\n-  upper = (int32_t)upper;\n-  \/\/ lui Rd, imm[31:12] + imm[11]\n-  lui(Rd, upper);\n-  \/\/ use addiw to distinguish li32 to li64\n-  addiw(Rd, Rd, lower);\n-}\n-\n-#define INSN(NAME, REGISTER)                                       \\\n-  void Assembler::NAME(const address &dest, Register temp) {       \\\n-    assert_cond(dest != NULL);                                     \\\n-    int64_t distance = dest - pc();                                \\\n-    if (is_imm_in_range(distance, 20, 1)) {                        \\\n-      jal(REGISTER, distance);                                     \\\n-    } else {                                                       \\\n-      assert(temp != noreg, \"temp must not be empty register!\");   \\\n-      int32_t offset = 0;                                          \\\n-      movptr(temp, dest, offset);                                  \\\n-      jalr(REGISTER, temp, offset);                                \\\n-    }                                                              \\\n-  }                                                                \\\n-  void Assembler::NAME(Label &l, Register temp) {                  \\\n-    jal(REGISTER, l, temp);                                        \\\n-  }                                                                \\\n-\n-  INSN(j,   x0);\n-  INSN(jal, x1);\n-\n-#undef INSN\n-\n-#define INSN(NAME, REGISTER)                                       \\\n-  void Assembler::NAME(Register Rs) {                              \\\n-    jalr(REGISTER, Rs, 0);                                         \\\n-  }\n-\n-  INSN(jr,   x0);\n-  INSN(jalr, x1);\n-\n-#undef INSN\n-\n-#define INSN(NAME, REGISTER)                                   \\\n-  void Assembler::NAME(const Address &adr, Register temp) {    \\\n-    switch (adr.getMode()) {                                   \\\n-      case Address::literal: {                                 \\\n-        relocate(adr.rspec());                                 \\\n-        NAME(adr.target(), temp);                              \\\n-        break;                                                 \\\n-      }                                                        \\\n-      case Address::base_plus_offset: {                        \\\n-        int32_t offset = 0;                                    \\\n-        baseOffset(temp, adr, offset);                         \\\n-        jalr(REGISTER, temp, offset);                          \\\n-        break;                                                 \\\n-      }                                                        \\\n-      default:                                                 \\\n-        ShouldNotReachHere();                                  \\\n-    }                                                          \\\n-  }\n-\n-  INSN(j,    x0);\n-  INSN(jal,  x1);\n-\n-#undef INSN\n-\n-void Assembler::wrap_label(Register r1, Register r2, Label &L, compare_and_branch_insn insn,\n-                           compare_and_branch_label_insn neg_insn, bool is_far) {\n-  if (is_far) {\n-    Label done;\n-    (this->*neg_insn)(r1, r2, done, \/* is_far *\/ false);\n-    j(L);\n-    bind(done);\n-  } else {\n-    if (L.is_bound()) {\n-      (this->*insn)(r1, r2, target(L));\n-    } else {\n-      L.add_patch_at(code(), locator());\n-      (this->*insn)(r1, r2, pc());\n-    }\n-  }\n-}\n-\n-void Assembler::wrap_label(Register Rt, Label &L, Register tmp, load_insn_by_temp insn) {\n-  if (L.is_bound()) {\n-    (this->*insn)(Rt, target(L), tmp);\n-  } else {\n-    L.add_patch_at(code(), locator());\n-    (this->*insn)(Rt, pc(), tmp);\n-  }\n-}\n-\n-void Assembler::wrap_label(Register Rt, Label &L, jal_jalr_insn insn) {\n-  if (L.is_bound()) {\n-    (this->*insn)(Rt, target(L));\n-  } else {\n-    L.add_patch_at(code(), locator());\n-    (this->*insn)(Rt, pc());\n-  }\n-}\n-\n-void Assembler::movptr(Register Rd, address addr, int32_t &offset) {\n-  int64_t imm64 = (int64_t)addr;\n-#ifndef PRODUCT\n-  {\n-    char buffer[64];\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, imm64);\n-    block_comment(buffer);\n-  }\n-#endif\n-  assert(is_unsigned_imm_in_range(imm64, 47, 0) || (imm64 == (int64_t)-1),\n-         \"bit 47 overflows in address constant\");\n-  \/\/ Load upper 31 bits\n-  int64_t imm = imm64 >> 17;\n-  int64_t upper = imm, lower = imm;\n-  lower = (lower << 52) >> 52;\n-  upper -= lower;\n-  upper = (int32_t)upper;\n-  lui(Rd, upper);\n-  addi(Rd, Rd, lower);\n-\n-  \/\/ Load the rest 17 bits.\n-  slli(Rd, Rd, 11);\n-  addi(Rd, Rd, (imm64 >> 6) & 0x7ff);\n-  slli(Rd, Rd, 6);\n-\n-  \/\/ This offset will be used by following jalr\/ld.\n-  offset = imm64 & 0x3f;\n-}\n-\n-void Assembler::movptr(Register Rd, uintptr_t imm64) {\n-  movptr(Rd, (address)imm64);\n-}\n-\n-void Assembler::movptr(Register Rd, address addr) {\n-  int offset = 0;\n-  movptr(Rd, addr, offset);\n-  addi(Rd, Rd, offset);\n-}\n-\n-#define INSN(NAME, NEG_INSN)                                                         \\\n-  void Assembler::NAME(Register Rs, Register Rt, const address &dest) {              \\\n-    NEG_INSN(Rt, Rs, dest);                                                          \\\n-  }                                                                                  \\\n-  void Assembler::NAME(Register Rs, Register Rt, Label &l, bool is_far) {            \\\n-    NEG_INSN(Rt, Rs, l, is_far);                                                     \\\n-  }\n-\n-  INSN(bgt,  blt);\n-  INSN(ble,  bge);\n-  INSN(bgtu, bltu);\n-  INSN(bleu, bgeu);\n-#undef INSN\n-\n-#undef __\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.cpp","additions":0,"deletions":261,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+\n@@ -183,0 +184,1 @@\n+\n@@ -190,0 +192,1 @@\n+\n@@ -294,42 +297,0 @@\n-  void baseOffset32(Register Rd, const Address &adr, int32_t &offset) {\n-    assert(Rd != noreg, \"Rd must not be empty register!\");\n-    guarantee(Rd != adr.base(), \"should use different registers!\");\n-    if (is_offset_in_range(adr.offset(), 32)) {\n-      int32_t imm = adr.offset();\n-      int32_t upper = imm, lower = imm;\n-      lower = (imm << 20) >> 20;\n-      upper -= lower;\n-      lui(Rd, upper);\n-      offset = lower;\n-    } else {\n-      offset = ((int32_t)adr.offset() << 20) >> 20;\n-      li(Rd, adr.offset() - offset);\n-    }\n-    add(Rd, Rd, adr.base());\n-  }\n-\n-  void baseOffset(Register Rd, const Address &adr, int32_t &offset) {\n-    if (is_offset_in_range(adr.offset(), 12)) {\n-      assert(Rd != noreg, \"Rd must not be empty register!\");\n-      addi(Rd, adr.base(), adr.offset());\n-      offset = 0;\n-    } else {\n-      baseOffset32(Rd, adr, offset);\n-    }\n-  }\n-\n-  void _li(Register Rd, int64_t imm);  \/\/ optimized load immediate\n-  void li32(Register Rd, int32_t imm);\n-  void li64(Register Rd, int64_t imm);\n-  void movptr(Register Rd, address addr);\n-  void movptr(Register Rd, address addr, int32_t &offset);\n-  void movptr(Register Rd, uintptr_t imm64);\n-  void j(const address &dest, Register temp = t0);\n-  void j(const Address &adr, Register temp = t0);\n-  void j(Label &l, Register temp = t0);\n-  void jal(Label &l, Register temp = t0);\n-  void jal(const address &dest, Register temp = t0);\n-  void jal(const Address &adr, Register temp = t0);\n-  void jr(Register Rs);\n-  void jalr(Register Rs);\n-\n@@ -477,7 +438,1 @@\n-#define INSN_ENTRY_RELOC(result_type, header)                               \\\n-  result_type header {                                                      \\\n-    guarantee(rtype == relocInfo::internal_word_type,                       \\\n-              \"only internal_word_type relocs make sense here\");            \\\n-    relocate(InternalAddress(dest).rspec());\n-\n-  \/\/ Load\/store register (all modes)\n+\/\/ Load\/store register (all modes)\n@@ -507,56 +462,0 @@\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(Register Rd, address dest) {                                                           \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(Rd, (int32_t)distance + 0x800);                                                        \\\n-      NAME(Rd, Rd, ((int32_t)distance << 20) >> 20);                                               \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(Rd, dest, offset);                                                                    \\\n-      NAME(Rd, Rd, offset);                                                                        \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  INSN_ENTRY_RELOC(void, NAME(Register Rd, address dest, relocInfo::relocType rtype))              \\\n-    NAME(Rd, dest);                                                                                \\\n-  }                                                                                                \\\n-  void NAME(Register Rd, const Address &adr, Register temp = t0) {                                 \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        relocate(adr.rspec());                                                                     \\\n-        NAME(Rd, adr.target());                                                                    \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rd, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset = 0;                                                                      \\\n-          if (Rd == adr.base()) {                                                                  \\\n-            baseOffset32(temp, adr, offset);                                                       \\\n-            NAME(Rd, temp, offset);                                                                \\\n-          } else {                                                                                 \\\n-            baseOffset32(Rd, adr, offset);                                                         \\\n-            NAME(Rd, Rd, offset);                                                                  \\\n-          }                                                                                        \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  void NAME(Register Rd, Label &L) {                                                               \\\n-    wrap_label(Rd, L, &Assembler::NAME);                                                           \\\n-  }\n-\n-  INSN(lb);\n-  INSN(lbu);\n-  INSN(lh);\n-  INSN(lhu);\n-  INSN(lw);\n-  INSN(lwu);\n-  INSN(ld);\n-\n-#undef INSN\n-\n@@ -581,42 +480,0 @@\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(FloatRegister Rd, address dest, Register temp = t0) {                                  \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n-      NAME(Rd, temp, ((int32_t)distance << 20) >> 20);                                             \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(temp, dest, offset);                                                                  \\\n-      NAME(Rd, temp, offset);                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  INSN_ENTRY_RELOC(void, NAME(FloatRegister Rd, address dest, relocInfo::relocType rtype, Register temp = t0)) \\\n-    NAME(Rd, dest, temp);                                                                          \\\n-  }                                                                                                \\\n-  void NAME(FloatRegister Rd, const Address &adr, Register temp = t0) {                            \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        relocate(adr.rspec());                                                                     \\\n-        NAME(Rd, adr.target(), temp);                                                              \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rd, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset = 0;                                                                      \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n-          NAME(Rd, temp, offset);                                                                  \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }\n-\n-  INSN(flw);\n-  INSN(fld);\n-#undef INSN\n-\n@@ -643,2 +500,2 @@\n-  INSN(_beq, 0b1100011, 0b000);\n-  INSN(_bne, 0b1100011, 0b001);\n+  INSN(beq,  0b1100011, 0b000);\n+  INSN(bne,  0b1100011, 0b001);\n@@ -652,34 +509,0 @@\n-#define INSN(NAME)                                                                                       \\\n-  void NAME(Register Rs1, Register Rs2, const address dest) {                                            \\\n-    assert_cond(dest != NULL);                                                                           \\\n-    int64_t offset = (dest - pc());                                                                      \\\n-    guarantee(is_imm_in_range(offset, 12, 1), \"offset is invalid.\");                                     \\\n-    NAME(Rs1, Rs2, offset);                                                                              \\\n-  }                                                                                                      \\\n-  INSN_ENTRY_RELOC(void, NAME(Register Rs1, Register Rs2, address dest, relocInfo::relocType rtype))     \\\n-    NAME(Rs1, Rs2, dest);                                                                                \\\n-  }\n-\n-  INSN(beq);\n-  INSN(bne);\n-  INSN(bge);\n-  INSN(bgeu);\n-  INSN(blt);\n-  INSN(bltu);\n-\n-#undef INSN\n-\n-#define INSN(NAME, NEG_INSN)                                                                \\\n-  void NAME(Register Rs1, Register Rs2, Label &L, bool is_far = false) {                    \\\n-    wrap_label(Rs1, Rs2, L, &Assembler::NAME, &Assembler::NEG_INSN, is_far);                \\\n-  }\n-\n-  INSN(beq,  bne);\n-  INSN(bne,  beq);\n-  INSN(blt,  bge);\n-  INSN(bge,  blt);\n-  INSN(bltu, bgeu);\n-  INSN(bgeu, bltu);\n-\n-#undef INSN\n-\n@@ -711,99 +534,0 @@\n-#define INSN(NAME, REGISTER)                                                                                \\\n-  INSN_ENTRY_RELOC(void, NAME(REGISTER Rs, address dest, relocInfo::relocType rtype, Register temp = t0))   \\\n-    NAME(Rs, dest, temp);                                                                                   \\\n-  }\n-\n-  INSN(sb,  Register);\n-  INSN(sh,  Register);\n-  INSN(sw,  Register);\n-  INSN(sd,  Register);\n-  INSN(fsw, FloatRegister);\n-  INSN(fsd, FloatRegister);\n-\n-#undef INSN\n-\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(Register Rs, address dest, Register temp = t0) {                                       \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    assert_different_registers(Rs, temp);                                                          \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n-      NAME(Rs, temp, ((int32_t)distance << 20) >> 20);                                             \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(temp, dest, offset);                                                                  \\\n-      NAME(Rs, temp, offset);                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  void NAME(Register Rs, const Address &adr, Register temp = t0) {                                 \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        assert_different_registers(Rs, temp);                                                      \\\n-        relocate(adr.rspec());                                                                     \\\n-        NAME(Rs, adr.target(), temp);                                                              \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rs, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset= 0;                                                                       \\\n-          assert_different_registers(Rs, temp);                                                    \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n-          NAME(Rs, temp, offset);                                                                  \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }\n-\n-  INSN(sb);\n-  INSN(sh);\n-  INSN(sw);\n-  INSN(sd);\n-\n-#undef INSN\n-\n-#define INSN(NAME)                                                                                 \\\n-  void NAME(FloatRegister Rs, address dest, Register temp = t0) {                                  \\\n-    assert_cond(dest != NULL);                                                                     \\\n-    int64_t distance = (dest - pc());                                                              \\\n-    if (is_offset_in_range(distance, 32)) {                                                        \\\n-      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n-      NAME(Rs, temp, ((int32_t)distance << 20) >> 20);                                             \\\n-    } else {                                                                                       \\\n-      int32_t offset = 0;                                                                          \\\n-      movptr(temp, dest, offset);                                                                  \\\n-      NAME(Rs, temp, offset);                                                                      \\\n-    }                                                                                              \\\n-  }                                                                                                \\\n-  void NAME(FloatRegister Rs, const Address &adr, Register temp = t0) {                            \\\n-    switch (adr.getMode()) {                                                                       \\\n-      case Address::literal: {                                                                     \\\n-        relocate(adr.rspec());                                                                     \\\n-        NAME(Rs, adr.target(), temp);                                                              \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      case Address::base_plus_offset: {                                                            \\\n-        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n-          NAME(Rs, adr.base(), adr.offset());                                                      \\\n-        } else {                                                                                   \\\n-          int32_t offset = 0;                                                                      \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n-          NAME(Rs, temp, offset);                                                                  \\\n-        }                                                                                          \\\n-        break;                                                                                     \\\n-      }                                                                                            \\\n-      default:                                                                                     \\\n-        ShouldNotReachHere();                                                                      \\\n-    }                                                                                              \\\n-  }\n-\n-  INSN(fsw);\n-  INSN(fsd);\n-\n-#undef INSN\n-\n@@ -848,33 +572,11 @@\n-#define INSN(NAME, op)                                                                        \\\n-  void NAME(Register Rd, const int32_t offset) {                                              \\\n-    guarantee(is_imm_in_range(offset, 20, 1), \"offset is invalid.\");                          \\\n-    unsigned insn = 0;                                                                        \\\n-    patch((address)&insn, 6, 0, op);                                                          \\\n-    patch_reg((address)&insn, 7, Rd);                                                         \\\n-    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));                         \\\n-    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));                              \\\n-    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));                         \\\n-    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));                              \\\n-    emit(insn);                                                                               \\\n-  }\n-\n-  INSN(_jal, 0b1101111);\n-\n-#undef INSN\n-\n-#define INSN(NAME)                                                                            \\\n-  void NAME(Register Rd, const address dest, Register temp = t0) {                            \\\n-    assert_cond(dest != NULL);                                                                \\\n-    int64_t offset = dest - pc();                                                             \\\n-    if (is_imm_in_range(offset, 20, 1)) {                                                     \\\n-      NAME(Rd, offset);                                                                       \\\n-    } else {                                                                                  \\\n-      assert_different_registers(Rd, temp);                                                   \\\n-      int32_t off = 0;                                                                        \\\n-      movptr(temp, dest, off);                                                                \\\n-      jalr(Rd, temp, off);                                                                    \\\n-    }                                                                                         \\\n-  }                                                                                           \\\n-  void NAME(Register Rd, Label &L, Register temp = t0) {                                      \\\n-    assert_different_registers(Rd, temp);                                                     \\\n-    wrap_label(Rd, L, temp, &Assembler::NAME);                                                \\\n+#define INSN(NAME, op)                                                                \\\n+  void NAME(Register Rd, const int32_t offset) {                                      \\\n+    guarantee(is_imm_in_range(offset, 20, 1), \"offset is invalid.\");                  \\\n+    unsigned insn = 0;                                                                \\\n+    patch((address)&insn, 6, 0, op);                                                  \\\n+    patch_reg((address)&insn, 7, Rd);                                                 \\\n+    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));                 \\\n+    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));                      \\\n+    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));                 \\\n+    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));                      \\\n+    emit(insn);                                                                       \\\n@@ -883,1 +585,1 @@\n-  INSN(jal);\n+  INSN(jal, 0b1101111);\n@@ -887,13 +589,11 @@\n-#undef INSN_ENTRY_RELOC\n-\n-#define INSN(NAME, op, funct)                                                              \\\n-  void NAME(Register Rd, Register Rs, const int32_t offset) {                              \\\n-    guarantee(is_offset_in_range(offset, 12), \"offset is invalid.\");                       \\\n-    unsigned insn = 0;                                                                     \\\n-    patch((address)&insn, 6, 0, op);                                                       \\\n-    patch_reg((address)&insn, 7, Rd);                                                      \\\n-    patch((address)&insn, 14, 12, funct);                                                  \\\n-    patch_reg((address)&insn, 15, Rs);                                                     \\\n-    int32_t val = offset & 0xfff;                                                          \\\n-    patch((address)&insn, 31, 20, val);                                                    \\\n-    emit(insn);                                                                            \\\n+#define INSN(NAME, op, funct)                                                         \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                         \\\n+    guarantee(is_offset_in_range(offset, 12), \"offset is invalid.\");                  \\\n+    unsigned insn = 0;                                                                \\\n+    patch((address)&insn, 6, 0, op);                                                  \\\n+    patch_reg((address)&insn, 7, Rd);                                                 \\\n+    patch((address)&insn, 14, 12, funct);                                             \\\n+    patch_reg((address)&insn, 15, Rs);                                                \\\n+    int32_t val = offset & 0xfff;                                                     \\\n+    patch((address)&insn, 31, 20, val);                                               \\\n+    emit(insn);                                                                       \\\n@@ -1027,4 +727,4 @@\n-  INSN(fsqrt_s,   0b1010011, 0b00000, 0b0101100);\n-  INSN(fsqrt_d,   0b1010011, 0b00000, 0b0101101);\n-  INSN(fcvt_s_d,  0b1010011, 0b00001, 0b0100000);\n-  INSN(fcvt_d_s,  0b1010011, 0b00000, 0b0100001);\n+  INSN(fsqrt_s,  0b1010011, 0b00000, 0b0101100);\n+  INSN(fsqrt_d,  0b1010011, 0b00000, 0b0101101);\n+  INSN(fcvt_s_d, 0b1010011, 0b00001, 0b0100000);\n+  INSN(fcvt_d_s, 0b1010011, 0b00000, 0b0100001);\n@@ -2082,7 +1782,6 @@\n-\/\/ 1. When UseRVC is enabled, 32-bit instructions under 'CompressibleRegion's will be\n-\/\/    transformed to 16-bit instructions if compressible.\n-\/\/ 2. RVC instructions in Assembler always begin with 'c_' prefix, as 'c_li',\n-\/\/    but most of time we have no need to explicitly use these instructions.\n-\/\/ 3. 'CompressibleRegion' is introduced to hint instructions in this Region's RTTI range\n-\/\/    are qualified to be compressed with their 2-byte versions.\n-\/\/    An example:\n+\/\/ 1. Assembler functions encoding 16-bit compressed instructions always begin with a 'c_'\n+\/\/    prefix, such as 'c_add'. Correspondingly, assembler functions encoding normal 32-bit\n+\/\/    instructions with begin with a '_' prefix, such as \"_add\". Most of time users have no\n+\/\/    need to explicitly emit these compressed instructions. Instead, they still use unified\n+\/\/    wrappers such as 'add' which do the compressing work through 'c_add' depending on the\n+\/\/    the operands of the instruction and availability of the RVC hardware extension.\n@@ -2090,2 +1789,3 @@\n-\/\/      CompressibleRegion cr(_masm);\n-\/\/      __ andr(...);      \/\/ this instruction could change to c.and if able to\n+\/\/ 2. 'CompressibleRegion' and 'IncompressibleRegion' are introduced to mark assembler scopes\n+\/\/     within which instructions are qualified or unqualified to be compressed into their 16-bit\n+\/\/     versions. An example:\n@@ -2093,2 +1793,10 @@\n-\/\/ 4. Using -XX:PrintAssemblyOptions=no-aliases could distinguish RVC instructions from\n-\/\/    normal ones.\n+\/\/      CompressibleRegion cr(_masm);\n+\/\/      __ add(...);       \/\/ this instruction will be compressed into 'c.and' when possible\n+\/\/      {\n+\/\/         IncompressibleRegion ir(_masm);\n+\/\/         __ add(...);    \/\/ this instruction will not be compressed\n+\/\/         {\n+\/\/            CompressibleRegion cr(_masm);\n+\/\/            __ add(...); \/\/ this instruction will be compressed into 'c.and' when possible\n+\/\/         }\n+\/\/      }\n@@ -2096,0 +1804,2 @@\n+\/\/ 3. When printing JIT assembly code, using -XX:PrintAssemblyOptions=no-aliases could help\n+\/\/    distinguish compressed 16-bit instructions from normal 32-bit ones.\n@@ -2104,2 +1814,2 @@\n-  \/\/ a compressible region\n-  class CompressibleRegion : public StackObj {\n+  \/\/ an abstract compressible region\n+  class AbstractCompressibleRegion : public StackObj {\n@@ -2109,2 +1819,2 @@\n-  public:\n-    CompressibleRegion(Assembler *_masm)\n+  protected:\n+    AbstractCompressibleRegion(Assembler *_masm)\n@@ -2112,1 +1822,6 @@\n-    , _saved_in_compressible_region(_masm->in_compressible_region()) {\n+    , _saved_in_compressible_region(_masm->in_compressible_region()) {}\n+  };\n+  \/\/ a compressible region\n+  class CompressibleRegion : public AbstractCompressibleRegion {\n+  public:\n+    CompressibleRegion(Assembler *_masm) : AbstractCompressibleRegion(_masm) {\n@@ -2119,0 +1834,31 @@\n+  \/\/ an incompressible region\n+  class IncompressibleRegion : public AbstractCompressibleRegion {\n+  public:\n+    IncompressibleRegion(Assembler *_masm) : AbstractCompressibleRegion(_masm) {\n+      _masm->set_in_compressible_region(false);\n+    }\n+    ~IncompressibleRegion() {\n+      _masm->set_in_compressible_region(_saved_in_compressible_region);\n+    }\n+  };\n+\n+public:\n+  \/\/ Emit a relocation.\n+  void relocate(RelocationHolder const& rspec, int format = 0) {\n+    AbstractAssembler::relocate(rspec, format);\n+  }\n+  void relocate(relocInfo::relocType rtype, int format = 0) {\n+    AbstractAssembler::relocate(rtype, format);\n+  }\n+  template <typename Callback>\n+  void relocate(RelocationHolder const& rspec, Callback emit_insts, int format = 0) {\n+    AbstractAssembler::relocate(rspec, format);\n+    IncompressibleRegion ir(this);  \/\/ relocations\n+    emit_insts();\n+  }\n+  template <typename Callback>\n+  void relocate(relocInfo::relocType rtype, Callback emit_insts, int format = 0) {\n+    AbstractAssembler::relocate(rtype, format);\n+    IncompressibleRegion ir(this);  \/\/ relocations\n+    emit_insts();\n+  }\n@@ -2654,4 +2400,0 @@\n-  bool do_compress() const {\n-    return UseRVC && in_compressible_region();\n-  }\n-\n@@ -2697,0 +2439,4 @@\n+  bool do_compress() const {\n+    return UseRVC && in_compressible_region();\n+  }\n+\n@@ -2819,20 +2565,0 @@\n-\/\/ --------------------------\n-\/\/ Conditional branch instructions\n-\/\/ --------------------------\n-#define INSN(NAME, C_NAME, NORMAL_NAME)                                                      \\\n-  void NAME(Register Rs1, Register Rs2, const int64_t offset) {                              \\\n-    \/* beq\/bne -> c.beqz\/c.bnez *\/                                                           \\\n-    if (do_compress() &&                                                                     \\\n-        (offset != 0 && Rs2 == x0 && Rs1->is_compressed_valid() &&                           \\\n-        is_imm_in_range(offset, 8, 1))) {                                                    \\\n-      C_NAME(Rs1, offset);                                                                   \\\n-      return;                                                                                \\\n-    }                                                                                        \\\n-    NORMAL_NAME(Rs1, Rs2, offset);                                                           \\\n-  }\n-\n-  INSN(beq, c_beqz, _beq);\n-  INSN(bne, c_bnez, _bne);\n-\n-#undef INSN\n-\n@@ -2841,15 +2567,0 @@\n-\/\/ --------------------------\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, const int32_t offset) {                                             \\\n-    \/* jal -> c.j *\/                                                                         \\\n-    if (do_compress() && offset != 0 && Rd == x0 && is_imm_in_range(offset, 11, 1)) {        \\\n-      c_j(offset);                                                                           \\\n-      return;                                                                                \\\n-    }                                                                                        \\\n-    _jal(Rd, offset);                                                                        \\\n-  }\n-\n-  INSN(jal);\n-\n-#undef INSN\n-\n@@ -2895,15 +2606,0 @@\n-\/\/ --------------------------\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, int64_t imm) {                                                      \\\n-    \/* li -> c.li *\/                                                                         \\\n-    if (do_compress() && (is_imm_in_range(imm, 6, 0) && Rd != x0)) {                         \\\n-      c_li(Rd, imm);                                                                         \\\n-      return;                                                                                \\\n-    }                                                                                        \\\n-    _li(Rd, imm);                                                                            \\\n-  }\n-\n-  INSN(li);\n-\n-#undef INSN\n-\n@@ -3021,18 +2717,4 @@\n-  void bgt(Register Rs, Register Rt, const address &dest);\n-  void ble(Register Rs, Register Rt, const address &dest);\n-  void bgtu(Register Rs, Register Rt, const address &dest);\n-  void bleu(Register Rs, Register Rt, const address &dest);\n-  void bgt(Register Rs, Register Rt, Label &l, bool is_far = false);\n-  void ble(Register Rs, Register Rt, Label &l, bool is_far = false);\n-  void bgtu(Register Rs, Register Rt, Label &l, bool is_far = false);\n-  void bleu(Register Rs, Register Rt, Label &l, bool is_far = false);\n-\n-  typedef void (Assembler::* jal_jalr_insn)(Register Rt, address dest);\n-  typedef void (Assembler::* load_insn_by_temp)(Register Rt, address dest, Register temp);\n-  typedef void (Assembler::* compare_and_branch_insn)(Register Rs1, Register Rs2, const address dest);\n-  typedef void (Assembler::* compare_and_branch_label_insn)(Register Rs1, Register Rs2, Label &L, bool is_far);\n-\n-  void wrap_label(Register r1, Register r2, Label &L, compare_and_branch_insn insn,\n-                  compare_and_branch_label_insn neg_insn, bool is_far);\n-  void wrap_label(Register r, Label &L, Register t, load_insn_by_temp insn);\n-  void wrap_label(Register r, Label &L, jal_jalr_insn insn);\n+#define INSN(NAME, REGISTER)                       \\\n+  void NAME(Register Rs) {                         \\\n+    jalr(REGISTER, Rs, 0);                         \\\n+  }\n@@ -3040,3 +2722,2 @@\n-  \/\/ Computational pseudo instructions\n-  void add(Register Rd, Register Rn, int64_t increment, Register temp = t0);\n-  void addw(Register Rd, Register Rn, int32_t increment, Register temp = t0);\n+  INSN(jr,   x0);\n+  INSN(jalr, x1);\n@@ -3044,2 +2725,1 @@\n-  void sub(Register Rd, Register Rn, int64_t decrement, Register temp = t0);\n-  void subw(Register Rd, Register Rn, int32_t decrement, Register temp = t0);\n+#undef INSN\n@@ -3049,3 +2729,2 @@\n-  void zext_w(Register Rd, Register Rs);\n-\n-  Assembler(CodeBuffer* code) : AbstractAssembler(code), _in_compressible_region(false) {\n+  void zext_w(Register Rd, Register Rs) {\n+    add_uw(Rd, Rs, zr);\n@@ -3068,0 +2747,2 @@\n+  Assembler(CodeBuffer* code) : AbstractAssembler(code), _in_compressible_region(true) {}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":110,"deletions":429,"binary":false,"changes":539,"status":"modified"},{"patch":"@@ -45,2 +45,3 @@\n-  __ relocate(safepoint_pc.rspec());\n-  __ la(t0, safepoint_pc.target());\n+  __ relocate(safepoint_pc.rspec(), [&] {\n+    __ la(t0, safepoint_pc.target());\n+  });\n@@ -104,3 +105,6 @@\n-  int32_t off = 0;\n-  __ la_patchable(ra, RuntimeAddress(Runtime1::entry_for(stub_id)), off);\n-  __ jalr(ra, ra, off);\n+  RuntimeAddress target(Runtime1::entry_for(stub_id));\n+  __ relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(ra, target, offset);\n+    __ jalr(ra, ra, offset);\n+  });\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -546,1 +546,1 @@\n-  void (Assembler::* insn)(Register Rt, const Address &adr, Register temp);\n+  void (MacroAssembler::* insn)(Register Rt, const Address &adr, Register temp);\n@@ -550,1 +550,1 @@\n-      insn = &Assembler::sd; break;\n+      insn = &MacroAssembler::sd; break;\n@@ -553,1 +553,1 @@\n-      insn = &Assembler::sd; break;\n+      insn = &MacroAssembler::sd; break;\n@@ -556,1 +556,1 @@\n-      insn = &Assembler::sd; break;\n+      insn = &MacroAssembler::sd; break;\n@@ -559,1 +559,1 @@\n-      insn = &Assembler::sw; break;\n+      insn = &MacroAssembler::sw; break;\n@@ -562,1 +562,1 @@\n-      insn = &Assembler::sw; break;\n+      insn = &MacroAssembler::sw; break;\n@@ -567,1 +567,1 @@\n-        insn = &Assembler::sw;\n+        insn = &MacroAssembler::sw;\n@@ -569,1 +569,1 @@\n-        insn = &Assembler::sd;\n+        insn = &MacroAssembler::sd;\n@@ -575,1 +575,1 @@\n-      insn = &Assembler::sh;\n+      insn = &MacroAssembler::sh;\n@@ -580,1 +580,1 @@\n-      insn = &Assembler::sb; break;\n+      insn = &MacroAssembler::sb; break;\n@@ -583,1 +583,1 @@\n-      insn = &Assembler::sd;  \/\/ unreachable\n+      insn = &MacroAssembler::sd;  \/\/ unreachable\n@@ -1412,3 +1412,5 @@\n-  int32_t off = 0;\n-  __ la_patchable(exceptionPC->as_register(), pc_for_athrow, off);\n-  __ addi(exceptionPC->as_register(), exceptionPC->as_register(), off);\n+  __ relocate(pc_for_athrow.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(exceptionPC->as_register(), pc_for_athrow, offset);\n+    __ addi(exceptionPC->as_register(), exceptionPC->as_register(), offset);\n+  });\n@@ -1842,3 +1844,6 @@\n-    int32_t offset = 0;\n-    __ la_patchable(t0, RuntimeAddress(dest), offset);\n-    __ jalr(x1, t0, offset);\n+    RuntimeAddress target(dest);\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ jalr(x1, t0, offset);\n+    });\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-                                  Register result)\n-{\n+                                  Register result) {\n@@ -326,0 +325,1 @@\n+  IncompressibleRegion ir(this);  \/\/ keep the nop as 4 bytes for patching.\n@@ -327,1 +327,1 @@\n-  nop();\n+  nop();  \/\/ 4 bytes\n@@ -377,8 +377,8 @@\n-  (c1_cond_branch_insn)&Assembler::beq,\n-  (c1_cond_branch_insn)&Assembler::bne,\n-  (c1_cond_branch_insn)&Assembler::blt,\n-  (c1_cond_branch_insn)&Assembler::ble,\n-  (c1_cond_branch_insn)&Assembler::bge,\n-  (c1_cond_branch_insn)&Assembler::bgt,\n-  (c1_cond_branch_insn)&Assembler::bleu, \/\/ lir_cond_belowEqual\n-  (c1_cond_branch_insn)&Assembler::bgeu  \/\/ lir_cond_aboveEqual\n+  (c1_cond_branch_insn)&MacroAssembler::beq,\n+  (c1_cond_branch_insn)&MacroAssembler::bne,\n+  (c1_cond_branch_insn)&MacroAssembler::blt,\n+  (c1_cond_branch_insn)&MacroAssembler::ble,\n+  (c1_cond_branch_insn)&MacroAssembler::bge,\n+  (c1_cond_branch_insn)&MacroAssembler::bgt,\n+  (c1_cond_branch_insn)&MacroAssembler::bleu, \/\/ lir_cond_belowEqual\n+  (c1_cond_branch_insn)&MacroAssembler::bgeu  \/\/ lir_cond_aboveEqual\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -70,3 +70,6 @@\n-  int32_t off = 0;\n-  la_patchable(t0, RuntimeAddress(entry), off);\n-  jalr(x1, t0, off);\n+  RuntimeAddress target(entry);\n+  relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    la_patchable(t0, target, offset);\n+    jalr(x1, t0, offset);\n+  });\n@@ -570,3 +573,6 @@\n-  int32_t off = 0;\n-  __ la_patchable(t0, RuntimeAddress(target), off);\n-  __ jalr(x1, t0, off);\n+  RuntimeAddress addr(target);\n+  __ relocate(addr.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(t0, addr, offset);\n+    __ jalr(x1, t0, offset);\n+  });\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -246,0 +246,2 @@\n+  IncompressibleRegion ir(this);  \/\/ Fixed length: see C2_MacroAssembler::entry_barrier_stub_size()\n+\n@@ -1208,2 +1210,2 @@\n-      lbu(tmp1, a1, 0);\n-      lbu(tmp2, a2, 0);\n+      lbu(tmp1, Address(a1, 0));\n+      lbu(tmp2, Address(a2, 0));\n@@ -1230,2 +1232,2 @@\n-  (conditional_branch_insn)&Assembler::beq,\n-  (conditional_branch_insn)&Assembler::bgt,\n+  (conditional_branch_insn)&MacroAssembler::beq,\n+  (conditional_branch_insn)&MacroAssembler::bgt,\n@@ -1233,3 +1235,3 @@\n-  (conditional_branch_insn)&Assembler::blt,\n-  (conditional_branch_insn)&Assembler::bne,\n-  (conditional_branch_insn)&Assembler::ble,\n+  (conditional_branch_insn)&MacroAssembler::blt,\n+  (conditional_branch_insn)&MacroAssembler::bne,\n+  (conditional_branch_insn)&MacroAssembler::ble,\n@@ -1237,1 +1239,1 @@\n-  (conditional_branch_insn)&Assembler::bge,\n+  (conditional_branch_insn)&MacroAssembler::bge,\n@@ -1240,2 +1242,2 @@\n-  (conditional_branch_insn)&Assembler::beq,\n-  (conditional_branch_insn)&Assembler::bgtu,\n+  (conditional_branch_insn)&MacroAssembler::beq,\n+  (conditional_branch_insn)&MacroAssembler::bgtu,\n@@ -1243,3 +1245,3 @@\n-  (conditional_branch_insn)&Assembler::bltu,\n-  (conditional_branch_insn)&Assembler::bne,\n-  (conditional_branch_insn)&Assembler::bleu,\n+  (conditional_branch_insn)&MacroAssembler::bltu,\n+  (conditional_branch_insn)&MacroAssembler::bne,\n+  (conditional_branch_insn)&MacroAssembler::bleu,\n@@ -1247,1 +1249,1 @@\n-  (conditional_branch_insn)&Assembler::bgeu\n+  (conditional_branch_insn)&MacroAssembler::bgeu\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -41,3 +41,4 @@\n-  InternalAddress safepoint_pc(masm.pc() - masm.offset() + entry->_safepoint_offset);\n-  masm.relocate(safepoint_pc.rspec());\n-  __ la(t0, safepoint_pc.target());\n+  InternalAddress safepoint_pc(__ pc() - __ offset() + entry->_safepoint_offset);\n+  __ relocate(safepoint_pc.rspec(), [&] {\n+    __ la(t0, safepoint_pc.target());\n+  });\n","filename":"src\/hotspot\/cpu\/riscv\/c2_safepointPollStubTable_riscv.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -196,0 +196,2 @@\n+  Assembler::IncompressibleRegion ir(masm);  \/\/ Fixed length: see entry_barrier_offset()\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-                                  Register start, Register end, Register tmp, RegSet saved_regs) {}\n+                                  Register start, Register count, Register tmp, RegSet saved_regs) {}\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -341,3 +341,7 @@\n-    int32_t offset = 0;\n-    __ la_patchable(t0, stub->slow_path(), offset);\n-    __ jalr(x1, t0, offset);\n+\n+    Address target(stub->slow_path());\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ jalr(x1, t0, offset);\n+    });\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -185,3 +185,6 @@\n-  int32_t offset = 0;\n-  la_patchable(xdispatch, ExternalAddress((address)Interpreter::dispatch_table()), offset);\n-  addi(xdispatch, xdispatch, offset);\n+  ExternalAddress target((address)Interpreter::dispatch_table());\n+  relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    la_patchable(xdispatch, target, offset);\n+    addi(xdispatch, xdispatch, offset);\n+  });\n@@ -371,1 +374,1 @@\n-  flw(r, esp, 0);\n+  flw(r, Address(esp, 0));\n@@ -376,1 +379,1 @@\n-  fld(r, esp, 0);\n+  fld(r, Address(esp, 0));\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -76,4 +76,6 @@\n-  Label slow;\n-  int32_t offset = 0;\n-  __ la_patchable(rcounter_addr, SafepointSynchronize::safepoint_counter_addr(), offset);\n-  __ addi(rcounter_addr, rcounter_addr, offset);\n+  Address target(SafepointSynchronize::safepoint_counter_addr());\n+  __ relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(rcounter_addr, target, offset);\n+    __ addi(rcounter_addr, rcounter_addr, offset);\n+  });\n@@ -81,0 +83,1 @@\n+  Label slow;\n@@ -93,5 +96,6 @@\n-    int32_t offset2;\n-    __ la_patchable(result,\n-                    ExternalAddress((address) JvmtiExport::get_field_access_count_addr()),\n-                    offset2);\n-    __ lwu(result, Address(result, offset2));\n+    ExternalAddress target((address) JvmtiExport::get_field_access_count_addr());\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(result, target, offset);\n+      __ lwu(result, Address(result, offset));\n+    });\n@@ -172,3 +176,6 @@\n-    int32_t tmp_offset = 0;\n-    __ la_patchable(t0, ExternalAddress(slow_case_addr), tmp_offset);\n-    __ jalr(x1, t0, tmp_offset);\n+    ExternalAddress target(slow_case_addr);\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ jalr(x1, t0, offset);\n+    });\n","filename":"src\/hotspot\/cpu\/riscv\/jniFastGetField_riscv.cpp","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"jvmci\/jvmci.hpp\"\n+#include \"jvmci\/jvmciCodeInstaller.hpp\"\n+#include \"jvmci\/jvmciRuntime.hpp\"\n+#include \"jvmci\/jvmciCompilerToVM.hpp\"\n+#include \"jvmci\/jvmciJavaClasses.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"vmreg_riscv.inline.hpp\"\n+\n+jint CodeInstaller::pd_next_offset(NativeInstruction* inst, jint pc_offset, JVMCI_TRAPS) {\n+  address pc = (address) inst;\n+  if (inst->is_call()) {\n+    return pc_offset + NativeCall::instruction_size;\n+  } else if (inst->is_jump()) {\n+    return pc_offset + NativeJump::instruction_size;\n+  } else if (inst->is_movptr()) {\n+    return pc_offset + NativeMovConstReg::movptr_instruction_size;\n+  } else {\n+    JVMCI_ERROR_0(\"unsupported type of instruction for call site\");\n+  }\n+}\n+\n+void CodeInstaller::pd_patch_OopConstant(int pc_offset, Handle& obj, bool compressed, JVMCI_TRAPS) {\n+  address pc = _instructions->start() + pc_offset;\n+  jobject value = JNIHandles::make_local(obj());\n+  MacroAssembler::patch_oop(pc, cast_from_oop<address>(obj()));\n+  int oop_index = _oop_recorder->find_index(value);\n+  RelocationHolder rspec = oop_Relocation::spec(oop_index);\n+  _instructions->relocate(pc, rspec);\n+}\n+\n+void CodeInstaller::pd_patch_MetaspaceConstant(int pc_offset, HotSpotCompiledCodeStream* stream, u1 tag, JVMCI_TRAPS) {\n+  address pc = _instructions->start() + pc_offset;\n+  if (tag == PATCH_NARROW_KLASS) {\n+    narrowKlass narrowOop = record_narrow_metadata_reference(_instructions, pc, stream, tag, JVMCI_CHECK);\n+    MacroAssembler::pd_patch_instruction_size(pc, (address) (long) narrowOop);\n+    JVMCI_event_3(\"relocating (narrow metaspace constant) at \" PTR_FORMAT \"\/0x%x\", p2i(pc), narrowOop);\n+  } else {\n+    NativeMovConstReg* move = nativeMovConstReg_at(pc);\n+    void* reference = record_metadata_reference(_instructions, pc, stream, tag, JVMCI_CHECK);\n+    move->set_data((intptr_t) reference);\n+    JVMCI_event_3(\"relocating (metaspace constant) at \" PTR_FORMAT \"\/\" PTR_FORMAT, p2i(pc), p2i(reference));\n+  }\n+}\n+\n+void CodeInstaller::pd_patch_DataSectionReference(int pc_offset, int data_offset, JVMCI_TRAPS) {\n+  address pc = _instructions->start() + pc_offset;\n+  address dest = _constants->start() + data_offset;\n+  _instructions->relocate(pc, section_word_Relocation::spec((address) dest, CodeBuffer::SECT_CONSTS));\n+  JVMCI_event_3(\"relocating at \" PTR_FORMAT \" (+%d) with destination at %d\", p2i(pc), pc_offset, data_offset);\n+}\n+\n+void CodeInstaller::pd_relocate_ForeignCall(NativeInstruction* inst, jlong foreign_call_destination, JVMCI_TRAPS) {\n+  address pc = (address) inst;\n+  if (inst->is_jal()) {\n+    NativeCall* call = nativeCall_at(pc);\n+    call->set_destination((address) foreign_call_destination);\n+    _instructions->relocate(call->instruction_address(), runtime_call_Relocation::spec());\n+  } else if (inst->is_jump()) {\n+    NativeJump* jump = nativeJump_at(pc);\n+    jump->set_jump_destination((address) foreign_call_destination);\n+    _instructions->relocate(jump->instruction_address(), runtime_call_Relocation::spec());\n+  } else if (inst->is_movptr()) {\n+    NativeMovConstReg* movptr = nativeMovConstReg_at(pc);\n+    movptr->set_data((intptr_t) foreign_call_destination);\n+    _instructions->relocate(movptr->instruction_address(), runtime_call_Relocation::spec());\n+  } else {\n+    JVMCI_ERROR(\"unknown call or jump instruction at \" PTR_FORMAT, p2i(pc));\n+  }\n+  JVMCI_event_3(\"relocating (foreign call) at \" PTR_FORMAT, p2i(inst));\n+}\n+\n+void CodeInstaller::pd_relocate_JavaMethod(CodeBuffer &cbuf, methodHandle& method, jint pc_offset, JVMCI_TRAPS) {\n+  Unimplemented();\n+}\n+\n+void CodeInstaller::pd_relocate_poll(address pc, jint mark, JVMCI_TRAPS) {\n+  Unimplemented();\n+}\n+\n+\/\/ convert JVMCI register indices (as used in oop maps) to HotSpot registers\n+VMReg CodeInstaller::get_hotspot_reg(jint jvmci_reg, JVMCI_TRAPS) {\n+  if (jvmci_reg < Register::number_of_registers) {\n+    return as_Register(jvmci_reg)->as_VMReg();\n+  } else {\n+    jint floatRegisterNumber = jvmci_reg - Register::number_of_registers;\n+    if (floatRegisterNumber >= 0 && floatRegisterNumber < FloatRegister::number_of_registers) {\n+      return as_FloatRegister(floatRegisterNumber)->as_VMReg();\n+    }\n+    JVMCI_ERROR_NULL(\"invalid register number: %d\", jvmci_reg);\n+  }\n+}\n+\n+bool CodeInstaller::is_general_purpose_reg(VMReg hotspotRegister) {\n+  return !(hotspotRegister->is_FloatRegister() || hotspotRegister->is_VectorRegister());\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/jvmciCodeInstaller_riscv.cpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -244,0 +245,1 @@\n+    IncompressibleRegion ir(this);  \/\/ the label address will be patched back.\n@@ -309,3 +311,6 @@\n-    int32_t offset = 0;\n-    la_patchable(t0, RuntimeAddress(StubRoutines::forward_exception_entry()), offset);\n-    jalr(x0, t0, offset);\n+    RuntimeAddress target(StubRoutines::forward_exception_entry());\n+    relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      la_patchable(t0, target, offset);\n+      jalr(x0, t0, offset);\n+    });\n@@ -384,3 +389,6 @@\n-  int32_t offset = 0;\n-  la_patchable(t1, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()), offset);\n-  ld(t1, Address(t1, offset));\n+  ExternalAddress target(StubRoutines::verify_oop_subroutine_entry_address());\n+  relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    la_patchable(t1, target, offset);\n+    ld(t1, Address(t1, offset));\n+  });\n@@ -423,3 +431,6 @@\n-  int32_t offset = 0;\n-  la_patchable(t1, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()), offset);\n-  ld(t1, Address(t1, offset));\n+  ExternalAddress target(StubRoutines::verify_oop_subroutine_entry_address());\n+  relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    la_patchable(t1, target, offset);\n+    ld(t1, Address(t1, offset));\n+  });\n@@ -552,0 +563,1 @@\n+  IncompressibleRegion ir(this);  \/\/ Fixed length: see CompiledStaticCall::to_interp_stub_size().\n@@ -720,1 +732,28 @@\n-void MacroAssembler::la(Register Rd, const address &dest) {\n+void MacroAssembler::baseOffset32(Register Rd, const Address &adr, int32_t &offset) {\n+  assert(Rd != noreg, \"Rd must not be empty register!\");\n+  guarantee(Rd != adr.base(), \"should use different registers!\");\n+  if (is_offset_in_range(adr.offset(), 32)) {\n+    int32_t imm = adr.offset();\n+    int32_t upper = imm, lower = imm;\n+    lower = (imm << 20) >> 20;\n+    upper -= lower;\n+    lui(Rd, upper);\n+    offset = lower;\n+  } else {\n+    offset = ((int32_t)adr.offset() << 20) >> 20;\n+    li(Rd, adr.offset() - offset);\n+  }\n+  add(Rd, Rd, adr.base());\n+}\n+\n+void MacroAssembler::baseOffset(Register Rd, const Address &adr, int32_t &offset) {\n+  if (is_offset_in_range(adr.offset(), 12)) {\n+    assert(Rd != noreg, \"Rd must not be empty register!\");\n+    addi(Rd, adr.base(), adr.offset());\n+    offset = 0;\n+  } else {\n+    baseOffset32(Rd, adr, offset);\n+  }\n+}\n+\n+void MacroAssembler::la(Register Rd, const address dest) {\n@@ -737,2 +776,3 @@\n-        relocate(adr.rspec());\n-        movptr(Rd, adr.target());\n+        relocate(adr.rspec(), [&] {\n+          movptr(Rd, adr.target());\n+        });\n@@ -754,0 +794,1 @@\n+  IncompressibleRegion ir(this);   \/\/ the label address may be patched back.\n@@ -757,0 +798,203 @@\n+void MacroAssembler::li32(Register Rd, int32_t imm) {\n+  \/\/ int32_t is in range 0x8000 0000 ~ 0x7fff ffff, and imm[31] is the sign bit\n+  int64_t upper = imm, lower = imm;\n+  lower = (imm << 20) >> 20;\n+  upper -= lower;\n+  upper = (int32_t)upper;\n+  \/\/ lui Rd, imm[31:12] + imm[11]\n+  lui(Rd, upper);\n+  \/\/ use addiw to distinguish li32 to li64\n+  addiw(Rd, Rd, lower);\n+}\n+\n+void MacroAssembler::li64(Register Rd, int64_t imm) {\n+  \/\/ Load upper 32 bits. upper = imm[63:32], but if imm[31] == 1 or\n+  \/\/ (imm[31:20] == 0x7ff && imm[19] == 1), upper = imm[63:32] + 1.\n+  int64_t lower = imm & 0xffffffff;\n+  lower -= ((lower << 44) >> 44);\n+  int64_t tmp_imm = ((uint64_t)(imm & 0xffffffff00000000)) + (uint64_t)lower;\n+  int32_t upper = (tmp_imm - (int32_t)lower) >> 32;\n+\n+  \/\/ Load upper 32 bits\n+  int64_t up = upper, lo = upper;\n+  lo = (lo << 52) >> 52;\n+  up -= lo;\n+  up = (int32_t)up;\n+  lui(Rd, up);\n+  addi(Rd, Rd, lo);\n+\n+  \/\/ Load the rest 32 bits.\n+  slli(Rd, Rd, 12);\n+  addi(Rd, Rd, (int32_t)lower >> 20);\n+  slli(Rd, Rd, 12);\n+  lower = ((int32_t)imm << 12) >> 20;\n+  addi(Rd, Rd, lower);\n+  slli(Rd, Rd, 8);\n+  lower = imm & 0xff;\n+  addi(Rd, Rd, lower);\n+}\n+\n+void MacroAssembler::li(Register Rd, int64_t imm) {\n+  \/\/ int64_t is in range 0x8000 0000 0000 0000 ~ 0x7fff ffff ffff ffff\n+  \/\/ li -> c.li\n+  if (do_compress() && (is_imm_in_range(imm, 6, 0) && Rd != x0)) {\n+    c_li(Rd, imm);\n+    return;\n+  }\n+\n+  int shift = 12;\n+  int64_t upper = imm, lower = imm;\n+  \/\/ Split imm to a lower 12-bit sign-extended part and the remainder,\n+  \/\/ because addi will sign-extend the lower imm.\n+  lower = ((int32_t)imm << 20) >> 20;\n+  upper -= lower;\n+\n+  \/\/ Test whether imm is a 32-bit integer.\n+  if (!(((imm) & ~(int64_t)0x7fffffff) == 0 ||\n+        (((imm) & ~(int64_t)0x7fffffff) == ~(int64_t)0x7fffffff))) {\n+    while (((upper >> shift) & 1) == 0) { shift++; }\n+    upper >>= shift;\n+    li(Rd, upper);\n+    slli(Rd, Rd, shift);\n+    if (lower != 0) {\n+      addi(Rd, Rd, lower);\n+    }\n+  } else {\n+    \/\/ 32-bit integer\n+    Register hi_Rd = zr;\n+    if (upper != 0) {\n+      lui(Rd, (int32_t)upper);\n+      hi_Rd = Rd;\n+    }\n+    if (lower != 0 || hi_Rd == zr) {\n+      addiw(Rd, hi_Rd, lower);\n+    }\n+  }\n+}\n+\n+#define INSN(NAME, REGISTER)                                       \\\n+  void MacroAssembler::NAME(const address dest, Register temp) {   \\\n+    assert_cond(dest != NULL);                                     \\\n+    int64_t distance = dest - pc();                                \\\n+    if (is_imm_in_range(distance, 20, 1)) {                        \\\n+      Assembler::jal(REGISTER, distance);                          \\\n+    } else {                                                       \\\n+      assert(temp != noreg, \"temp must not be empty register!\");   \\\n+      int32_t offset = 0;                                          \\\n+      movptr(temp, dest, offset);                                  \\\n+      Assembler::jalr(REGISTER, temp, offset);                     \\\n+    }                                                              \\\n+  }                                                                \\\n+\n+  INSN(j,   x0);\n+  INSN(jal, x1);\n+\n+#undef INSN\n+\n+#define INSN(NAME, REGISTER)                                       \\\n+  void MacroAssembler::NAME(const Address &adr, Register temp) {   \\\n+    switch (adr.getMode()) {                                       \\\n+      case Address::literal: {                                     \\\n+        relocate(adr.rspec(), [&] {                                \\\n+          NAME(adr.target(), temp);                                \\\n+        });                                                        \\\n+        break;                                                     \\\n+      }                                                            \\\n+      case Address::base_plus_offset: {                            \\\n+        int32_t offset = 0;                                        \\\n+        baseOffset(temp, adr, offset);                             \\\n+        Assembler::jalr(REGISTER, temp, offset);                   \\\n+        break;                                                     \\\n+      }                                                            \\\n+      default:                                                     \\\n+        ShouldNotReachHere();                                      \\\n+    }                                                              \\\n+  }\n+\n+  INSN(j,   x0);\n+  INSN(jal, x1);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                    \\\n+  void MacroAssembler::NAME(Register Rd, const address dest, Register temp) {         \\\n+    assert_cond(dest != NULL);                                                        \\\n+    int64_t distance = dest - pc();                                                   \\\n+    if (is_imm_in_range(distance, 20, 1)) {                                           \\\n+      Assembler::NAME(Rd, distance);                                                  \\\n+    } else {                                                                          \\\n+      assert_different_registers(Rd, temp);                                           \\\n+      int32_t offset = 0;                                                             \\\n+      movptr(temp, dest, offset);                                                     \\\n+      jalr(Rd, temp, offset);                                                         \\\n+    }                                                                                 \\\n+  }                                                                                   \\\n+  void MacroAssembler::NAME(Register Rd, Label &L, Register temp) {                   \\\n+    assert_different_registers(Rd, temp);                                             \\\n+    wrap_label(Rd, L, temp, &MacroAssembler::NAME);                                   \\\n+  }\n+\n+  INSN(jal);\n+\n+#undef INSN\n+\n+#define INSN(NAME, REGISTER)                                       \\\n+  void MacroAssembler::NAME(Label &l, Register temp) {             \\\n+    jal(REGISTER, l, temp);                                        \\\n+  }                                                                \\\n+\n+  INSN(j,   x0);\n+  INSN(jal, x1);\n+\n+#undef INSN\n+\n+void MacroAssembler::wrap_label(Register Rt, Label &L, Register tmp, load_insn_by_temp insn) {\n+  if (L.is_bound()) {\n+    (this->*insn)(Rt, target(L), tmp);\n+  } else {\n+    L.add_patch_at(code(), locator());\n+    (this->*insn)(Rt, pc(), tmp);\n+  }\n+}\n+\n+void MacroAssembler::wrap_label(Register Rt, Label &L, jal_jalr_insn insn) {\n+  if (L.is_bound()) {\n+    (this->*insn)(Rt, target(L));\n+  } else {\n+    L.add_patch_at(code(), locator());\n+    (this->*insn)(Rt, pc());\n+  }\n+}\n+\n+void MacroAssembler::wrap_label(Register r1, Register r2, Label &L,\n+                                compare_and_branch_insn insn,\n+                                compare_and_branch_label_insn neg_insn, bool is_far) {\n+  if (is_far) {\n+    Label done;\n+    (this->*neg_insn)(r1, r2, done, \/* is_far *\/ false);\n+    j(L);\n+    bind(done);\n+  } else {\n+    if (L.is_bound()) {\n+      (this->*insn)(r1, r2, target(L));\n+    } else {\n+      L.add_patch_at(code(), locator());\n+      (this->*insn)(r1, r2, pc());\n+    }\n+  }\n+}\n+\n+#define INSN(NAME, NEG_INSN)                                                              \\\n+  void MacroAssembler::NAME(Register Rs1, Register Rs2, Label &L, bool is_far) {          \\\n+    wrap_label(Rs1, Rs2, L, &MacroAssembler::NAME, &MacroAssembler::NEG_INSN, is_far);    \\\n+  }\n+\n+  INSN(beq,  bne);\n+  INSN(bne,  beq);\n+  INSN(blt,  bge);\n+  INSN(bge,  blt);\n+  INSN(bltu, bgeu);\n+  INSN(bgeu, bltu);\n+\n+#undef INSN\n+\n@@ -758,1 +1002,1 @@\n-  void MacroAssembler::NAME##z(Register Rs, const address &dest) {                \\\n+  void MacroAssembler::NAME##z(Register Rs, const address dest) {                 \\\n@@ -774,0 +1018,15 @@\n+#define INSN(NAME, NEG_INSN)                                                      \\\n+  void MacroAssembler::NAME(Register Rs, Register Rt, const address dest) {       \\\n+    NEG_INSN(Rt, Rs, dest);                                                       \\\n+  }                                                                               \\\n+  void MacroAssembler::NAME(Register Rs, Register Rt, Label &l, bool is_far) {    \\\n+    NEG_INSN(Rt, Rs, l, is_far);                                                  \\\n+  }\n+\n+  INSN(bgt,  blt);\n+  INSN(ble,  bge);\n+  INSN(bgtu, bltu);\n+  INSN(bleu, bgeu);\n+\n+#undef INSN\n+\n@@ -776,8 +1035,8 @@\n-#define INSN(NAME, FLOATCMP, BRANCH)                                                                                   \\\n-  void MacroAssembler::float_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) {  \\\n-    FLOATCMP##_s(t0, Rs1, Rs2);                                                                                        \\\n-    BRANCH(t0, l, is_far);                                                                                             \\\n-  }                                                                                                                    \\\n-  void MacroAssembler::double_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) { \\\n-    FLOATCMP##_d(t0, Rs1, Rs2);                                                                                        \\\n-    BRANCH(t0, l, is_far);                                                                                             \\\n+#define INSN(NAME, FLOATCMP, BRANCH)                                                                                    \\\n+  void MacroAssembler::float_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) {   \\\n+    FLOATCMP##_s(t0, Rs1, Rs2);                                                                                         \\\n+    BRANCH(t0, l, is_far);                                                                                              \\\n+  }                                                                                                                     \\\n+  void MacroAssembler::double_##NAME(FloatRegister Rs1, FloatRegister Rs2, Label &l, bool is_far, bool is_unordered) {  \\\n+    FLOATCMP##_d(t0, Rs1, Rs2);                                                                                         \\\n+    BRANCH(t0, l, is_far);                                                                                              \\\n@@ -928,1 +1187,1 @@\n-  ld(Rd, esp, 0);\n+  ld(Rd, Address(esp, 0));\n@@ -948,2 +1207,0 @@\n-  CompressibleRegion cr(this);\n-\n@@ -970,2 +1227,0 @@\n-  CompressibleRegion cr(this);\n-\n@@ -993,1 +1248,0 @@\n-  CompressibleRegion cr(this);\n@@ -1014,1 +1268,0 @@\n-  CompressibleRegion cr(this);\n@@ -1038,1 +1291,0 @@\n-  CompressibleRegion cr(this);\n@@ -1054,1 +1306,0 @@\n-  CompressibleRegion cr(this);\n@@ -1071,1 +1322,0 @@\n-  CompressibleRegion cr(this);\n@@ -1086,1 +1336,0 @@\n-  CompressibleRegion cr(this);\n@@ -1099,1 +1348,0 @@\n-  CompressibleRegion cr(this);\n@@ -1121,1 +1369,0 @@\n-  CompressibleRegion cr(this);\n@@ -1340,3 +1587,6 @@\n-      int32_t offset = 0;\n-      la_patchable(xheapbase, ExternalAddress(CompressedOops::ptrs_base_addr()), offset);\n-      ld(xheapbase, Address(xheapbase, offset));\n+      ExternalAddress target(CompressedOops::ptrs_base_addr());\n+      relocate(target.rspec(), [&] {\n+        int32_t offset;\n+        la_patchable(xheapbase, target, offset);\n+        ld(xheapbase, Address(xheapbase, offset));\n+      });\n@@ -1349,2 +1599,3 @@\n-  relocate(dest.rspec());\n-  movptr(Rd, dest.target());\n+  relocate(dest.rspec(), [&] {\n+    movptr(Rd, dest.target());\n+  });\n@@ -1361,0 +1612,79 @@\n+void MacroAssembler::movptr(Register Rd, address addr, int32_t &offset) {\n+  int64_t imm64 = (int64_t)addr;\n+#ifndef PRODUCT\n+  {\n+    char buffer[64];\n+    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, imm64);\n+    block_comment(buffer);\n+  }\n+#endif\n+  assert(is_unsigned_imm_in_range(imm64, 47, 0) || (imm64 == (int64_t)-1),\n+         \"bit 47 overflows in address constant\");\n+  \/\/ Load upper 31 bits\n+  int64_t imm = imm64 >> 17;\n+  int64_t upper = imm, lower = imm;\n+  lower = (lower << 52) >> 52;\n+  upper -= lower;\n+  upper = (int32_t)upper;\n+  lui(Rd, upper);\n+  addi(Rd, Rd, lower);\n+\n+  \/\/ Load the rest 17 bits.\n+  slli(Rd, Rd, 11);\n+  addi(Rd, Rd, (imm64 >> 6) & 0x7ff);\n+  slli(Rd, Rd, 6);\n+\n+  \/\/ This offset will be used by following jalr\/ld.\n+  offset = imm64 & 0x3f;\n+}\n+\n+void MacroAssembler::movptr(Register Rd, uintptr_t imm64) {\n+  movptr(Rd, (address)imm64);\n+}\n+\n+void MacroAssembler::movptr(Register Rd, address addr) {\n+  int offset = 0;\n+  movptr(Rd, addr, offset);\n+  addi(Rd, Rd, offset);\n+}\n+\n+void MacroAssembler::add(Register Rd, Register Rn, int64_t increment, Register temp) {\n+  if (is_imm_in_range(increment, 12, 0)) {\n+    addi(Rd, Rn, increment);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, increment);\n+    add(Rd, Rn, temp);\n+  }\n+}\n+\n+void MacroAssembler::addw(Register Rd, Register Rn, int32_t increment, Register temp) {\n+  if (is_imm_in_range(increment, 12, 0)) {\n+    addiw(Rd, Rn, increment);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, increment);\n+    addw(Rd, Rn, temp);\n+  }\n+}\n+\n+void MacroAssembler::sub(Register Rd, Register Rn, int64_t decrement, Register temp) {\n+  if (is_imm_in_range(-decrement, 12, 0)) {\n+    addi(Rd, Rn, -decrement);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, decrement);\n+    sub(Rd, Rn, temp);\n+  }\n+}\n+\n+void MacroAssembler::subw(Register Rd, Register Rn, int32_t decrement, Register temp) {\n+  if (is_imm_in_range(-decrement, 12, 0)) {\n+    addiw(Rd, Rn, -decrement);\n+  } else {\n+    assert_different_registers(Rn, temp);\n+    li(temp, decrement);\n+    subw(Rd, Rn, temp);\n+  }\n+}\n+\n@@ -1407,1 +1737,1 @@\n-void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {\n+void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed) {\n@@ -1417,1 +1747,1 @@\n-void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {\n+void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes) {\n@@ -1696,2 +2026,6 @@\n-  _masm->la_patchable(t0, ExternalAddress((address)flag_addr), offset);\n-  _masm->lbu(t0, Address(t0, offset));\n+  ExternalAddress target((address)flag_addr);\n+  _masm->relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    _masm->la_patchable(t0, target, offset);\n+    _masm->lbu(t0, Address(t0, offset));\n+  });\n@@ -1763,1 +2097,1 @@\n-                                     Address dst, Register src,\n+                                     Address dst, Register val,\n@@ -1769,1 +2103,1 @@\n-    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -1771,1 +2105,1 @@\n-    bs->store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -1938,1 +2272,1 @@\n-void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,\n+void MacroAssembler::store_heap_oop(Address dst, Register val, Register tmp1,\n@@ -1940,1 +2274,1 @@\n-  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);\n+  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, val, tmp1, tmp2, tmp3);\n@@ -2440,1 +2774,1 @@\n-  int32_t offset = 0;\n+  IncompressibleRegion ir(this);  \/\/ Fixed length: see MacroAssembler::far_branch_size()\n@@ -2444,2 +2778,5 @@\n-    la_patchable(tmp, entry, offset);\n-    jalr(x0, tmp, offset);\n+    relocate(entry.rspec(), [&] {\n+      int32_t offset;\n+      la_patchable(tmp, entry, offset);\n+      jalr(x0, tmp, offset);\n+    });\n@@ -2458,1 +2795,1 @@\n-  int32_t offset = 0;\n+  IncompressibleRegion ir(this);  \/\/ Fixed length: see MacroAssembler::far_branch_size()\n@@ -2462,2 +2799,5 @@\n-    la_patchable(tmp, entry, offset);\n-    jalr(x1, tmp, offset); \/\/ link\n+    relocate(entry.rspec(), [&] {\n+      int32_t offset;\n+      la_patchable(tmp, entry, offset);\n+      jalr(x1, tmp, offset); \/\/ link\n+    });\n@@ -2699,1 +3039,0 @@\n-  relocate(dest.rspec());\n@@ -2739,3 +3078,6 @@\n-    int32_t offset = 0;\n-    la_patchable(t0, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone)), offset);\n-    jalr(x1, t0, offset);\n+    RuntimeAddress target(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone));\n+    relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      la_patchable(t0, target, offset);\n+      jalr(x1, t0, offset);\n+    });\n@@ -2747,3 +3089,6 @@\n-    offset = 0;\n-    la_patchable(t0, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()), offset);\n-    jalr(x0, t0, offset);\n+    target = RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry());\n+    relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      la_patchable(t0, target, offset);\n+      jalr(x0, t0, offset);\n+    });\n@@ -2763,2 +3108,3 @@\n-  relocate(rtype);\n-  lwu(zr, Address(r, offset));\n+  relocate(rtype, [&] {\n+    lwu(zr, Address(r, offset));\n+  });\n@@ -2778,2 +3124,3 @@\n-  relocate(oop_Relocation::spec(oop_index));\n-  li32(dst, 0xDEADBEEF);\n+  relocate(oop_Relocation::spec(oop_index), [&] {\n+    li32(dst, 0xDEADBEEF);\n+  });\n@@ -2790,2 +3137,3 @@\n-  relocate(metadata_Relocation::spec(index));\n-  li32(dst, nk);\n+  relocate(metadata_Relocation::spec(index), [&] {\n+    li32(dst, nk);\n+  });\n@@ -2838,2 +3186,3 @@\n-  relocate(entry.rspec());\n-  jal(target);\n+  relocate(entry.rspec(), [&] {\n+    jal(target);\n+  });\n@@ -2847,0 +3196,1 @@\n+  IncompressibleRegion ir(this);  \/\/ relocations\n@@ -2878,2 +3228,2 @@\n-  relocate(trampoline_stub_Relocation::spec(code()->insts()->start() +\n-                                            insts_call_instruction_offset));\n+  RelocationHolder rh = trampoline_stub_Relocation::spec(code()->insts()->start() +\n+                                                         insts_call_instruction_offset);\n@@ -2881,12 +3231,13 @@\n-\n-  \/\/ Now, create the trampoline stub's code:\n-  \/\/ - load the call\n-  \/\/ - call\n-  Label target;\n-  ld(t0, target);  \/\/ auipc + ld\n-  jr(t0);          \/\/ jalr\n-  bind(target);\n-  assert(offset() - stub_start_offset == NativeCallTrampolineStub::data_offset,\n-         \"should be\");\n-  assert(offset() % wordSize == 0, \"bad alignment\");\n-  emit_int64((intptr_t)dest);\n+  relocate(rh, [&] {\n+    \/\/ Now, create the trampoline stub's code:\n+    \/\/ - load the call\n+    \/\/ - call\n+    Label target;\n+    ld(t0, target);  \/\/ auipc + ld\n+    jr(t0);          \/\/ jalr\n+    bind(target);\n+    assert(offset() - stub_start_offset == NativeCallTrampolineStub::data_offset,\n+           \"should be\");\n+    assert(offset() % wordSize == 0, \"bad alignment\");\n+    emit_int64((int64_t)dest);\n+  });\n@@ -2960,3 +3311,5 @@\n-  int32_t offset;\n-  la_patchable(t0, src2, offset);\n-  ld(t0, Address(t0, offset));\n+  relocate(src2.rspec(), [&] {\n+    int32_t offset;\n+    la_patchable(t0, src2, offset);\n+    ld(t0, Address(t0, offset));\n+  });\n@@ -3856,1 +4209,1 @@\n-    Assembler::sd(zr, Address(tmp, i * wordSize));\n+    sd(zr, Address(tmp, i * wordSize));\n@@ -4147,0 +4500,1 @@\n+  RuntimeAddress target(dest);\n@@ -4148,1 +4502,1 @@\n-    far_call(RuntimeAddress(dest));\n+    far_call(target);\n@@ -4150,3 +4504,5 @@\n-    int32_t offset = 0;\n-    la_patchable(tmp, RuntimeAddress(dest), offset);\n-    jalr(x1, tmp, offset);\n+    relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      la_patchable(tmp, target, offset);\n+      jalr(x1, tmp, offset);\n+    });\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":447,"deletions":91,"binary":false,"changes":538,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-  MacroAssembler(CodeBuffer* code) : Assembler(code) {\n-  }\n+  MacroAssembler(CodeBuffer* code) : Assembler(code) {}\n+\n@@ -53,0 +53,1 @@\n+\n@@ -193,1 +194,1 @@\n-                       Register src, Register tmp1, Register tmp2, Register tmp3);\n+                       Register val, Register tmp1, Register tmp2, Register tmp3);\n@@ -212,1 +213,1 @@\n-  void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,\n+  void store_heap_oop(Address dst, Register val, Register tmp1 = noreg,\n@@ -274,1 +275,1 @@\n-    bool is_far = false\n+    bool     is_far = false\n@@ -400,2 +401,2 @@\n-  void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);\n-  void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);\n+  void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed);\n+  void store_sized_value(Address dst, Register src, size_t size_in_bytes);\n@@ -404,1 +405,1 @@\n-  \/\/ Standard pseudoinstruction\n+  \/\/ Standard pseudo instructions\n@@ -417,1 +418,1 @@\n-  \/\/ Float pseudoinstruction\n+  \/\/ Floating-point data-processing pseudo instructions\n@@ -419,1 +420,1 @@\n-  void fabs_s(FloatRegister Rd, FloatRegister Rs);    \/\/ single-precision absolute value\n+  void fabs_s(FloatRegister Rd, FloatRegister Rs);\n@@ -421,2 +422,0 @@\n-\n-  \/\/ Double pseudoinstruction\n@@ -427,1 +426,1 @@\n-  \/\/ Pseudoinstruction for control and status register\n+  \/\/ Control and status pseudo instructions\n@@ -452,9 +451,17 @@\n-  void beqz(Register Rs, const address &dest);\n-  void bnez(Register Rs, const address &dest);\n-  void blez(Register Rs, const address &dest);\n-  void bgez(Register Rs, const address &dest);\n-  void bltz(Register Rs, const address &dest);\n-  void bgtz(Register Rs, const address &dest);\n-  void la(Register Rd, Label &label);\n-  void la(Register Rd, const address &dest);\n-  void la(Register Rd, const Address &adr);\n+  \/\/ Control transfer pseudo instructions\n+  void beqz(Register Rs, const address dest);\n+  void bnez(Register Rs, const address dest);\n+  void blez(Register Rs, const address dest);\n+  void bgez(Register Rs, const address dest);\n+  void bltz(Register Rs, const address dest);\n+  void bgtz(Register Rs, const address dest);\n+\n+  void j(Label &l, Register temp = t0);\n+  void j(const address dest, Register temp = t0);\n+  void j(const Address &adr, Register temp = t0);\n+  void jal(Label &l, Register temp = t0);\n+  void jal(const address dest, Register temp = t0);\n+  void jal(const Address &adr, Register temp = t0);\n+  void jal(Register Rd, Label &L, Register temp = t0);\n+  void jal(Register Rd, const address dest, Register temp = t0);\n+\n@@ -468,0 +475,47 @@\n+\n+  void beq (Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bne (Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void blt (Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bge (Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bltu(Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+  void bgeu(Register Rs1, Register Rs2, Label &L, bool is_far = false);\n+\n+  void bgt (Register Rs, Register Rt, const address dest);\n+  void ble (Register Rs, Register Rt, const address dest);\n+  void bgtu(Register Rs, Register Rt, const address dest);\n+  void bleu(Register Rs, Register Rt, const address dest);\n+\n+  void bgt (Register Rs, Register Rt, Label &l, bool is_far = false);\n+  void ble (Register Rs, Register Rt, Label &l, bool is_far = false);\n+  void bgtu(Register Rs, Register Rt, Label &l, bool is_far = false);\n+  void bleu(Register Rs, Register Rt, Label &l, bool is_far = false);\n+\n+#define INSN_ENTRY_RELOC(result_type, header)                               \\\n+  result_type header {                                                      \\\n+    guarantee(rtype == relocInfo::internal_word_type,                       \\\n+              \"only internal_word_type relocs make sense here\");            \\\n+    relocate(InternalAddress(dest).rspec());                                \\\n+    IncompressibleRegion ir(this);  \/* relocations *\/\n+\n+#define INSN(NAME)                                                                                       \\\n+  void NAME(Register Rs1, Register Rs2, const address dest) {                                            \\\n+    assert_cond(dest != NULL);                                                                           \\\n+    int64_t offset = dest - pc();                                                                        \\\n+    guarantee(is_imm_in_range(offset, 12, 1), \"offset is invalid.\");                                     \\\n+    Assembler::NAME(Rs1, Rs2, offset);                                                                   \\\n+  }                                                                                                      \\\n+  INSN_ENTRY_RELOC(void, NAME(Register Rs1, Register Rs2, address dest, relocInfo::relocType rtype))     \\\n+    NAME(Rs1, Rs2, dest);                                                                                \\\n+  }\n+\n+  INSN(beq);\n+  INSN(bne);\n+  INSN(bge);\n+  INSN(bgeu);\n+  INSN(blt);\n+  INSN(bltu);\n+\n+#undef INSN\n+\n+#undef INSN_ENTRY_RELOC\n+\n@@ -474,0 +528,1 @@\n+\n@@ -529,0 +584,22 @@\n+  typedef void (MacroAssembler::* compare_and_branch_insn)(Register Rs1, Register Rs2, const address dest);\n+  typedef void (MacroAssembler::* compare_and_branch_label_insn)(Register Rs1, Register Rs2, Label &L, bool is_far);\n+  typedef void (MacroAssembler::* jal_jalr_insn)(Register Rt, address dest);\n+  typedef void (MacroAssembler::* load_insn_by_temp)(Register Rt, address dest, Register temp);\n+\n+  void wrap_label(Register r, Label &L, Register t, load_insn_by_temp insn);\n+  void wrap_label(Register r, Label &L, jal_jalr_insn insn);\n+  void wrap_label(Register r1, Register r2, Label &L,\n+                  compare_and_branch_insn insn,\n+                  compare_and_branch_label_insn neg_insn, bool is_far = false);\n+\n+  void baseOffset(Register Rd, const Address &adr, int32_t &offset);\n+  void baseOffset32(Register Rd, const Address &adr, int32_t &offset);\n+\n+  void la(Register Rd, Label &label);\n+  void la(Register Rd, const address dest);\n+  void la(Register Rd, const Address &adr);\n+\n+  void li32(Register Rd, int32_t imm);\n+  void li64(Register Rd, int64_t imm);\n+  void li(Register Rd, int64_t imm);  \/\/ optimized load immediate\n+\n@@ -546,0 +623,22 @@\n+  void movptr(Register Rd, address addr);\n+  void movptr(Register Rd, address addr, int32_t &offset);\n+  void movptr(Register Rd, uintptr_t imm64);\n+\n+  \/\/ arith\n+  void add (Register Rd, Register Rn, int64_t increment, Register temp = t0);\n+  void addw(Register Rd, Register Rn, int32_t increment, Register temp = t0);\n+  void sub (Register Rd, Register Rn, int64_t decrement, Register temp = t0);\n+  void subw(Register Rd, Register Rn, int32_t decrement, Register temp = t0);\n+\n+#define INSN(NAME)                                               \\\n+  inline void NAME(Register Rd, Register Rs1, Register Rs2) {    \\\n+    Assembler::NAME(Rd, Rs1, Rs2);                               \\\n+  }\n+\n+  INSN(add);\n+  INSN(addw);\n+  INSN(sub);\n+  INSN(subw);\n+\n+#undef INSN\n+\n@@ -565,0 +664,214 @@\n+\/\/ Load and Store Instructions\n+#define INSN_ENTRY_RELOC(result_type, header)                               \\\n+  result_type header {                                                      \\\n+    guarantee(rtype == relocInfo::internal_word_type,                       \\\n+              \"only internal_word_type relocs make sense here\");            \\\n+    relocate(InternalAddress(dest).rspec());                                \\\n+    IncompressibleRegion ir(this);  \/* relocations *\/\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(Register Rd, address dest) {                                                           \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    int64_t distance = dest - pc();                                                                \\\n+    if (is_offset_in_range(distance, 32)) {                                                        \\\n+      auipc(Rd, (int32_t)distance + 0x800);                                                        \\\n+      Assembler::NAME(Rd, Rd, ((int32_t)distance << 20) >> 20);                                    \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(Rd, dest, offset);                                                                    \\\n+      Assembler::NAME(Rd, Rd, offset);                                                             \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  INSN_ENTRY_RELOC(void, NAME(Register Rd, address dest, relocInfo::relocType rtype))              \\\n+    NAME(Rd, dest);                                                                                \\\n+  }                                                                                                \\\n+  void NAME(Register Rd, const Address &adr, Register temp = t0) {                                 \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        relocate(adr.rspec(), [&] {                                                                \\\n+          NAME(Rd, adr.target());                                                                  \\\n+        });                                                                                        \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rd, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset = 0;                                                                      \\\n+          if (Rd == adr.base()) {                                                                  \\\n+            baseOffset32(temp, adr, offset);                                                       \\\n+            Assembler::NAME(Rd, temp, offset);                                                     \\\n+          } else {                                                                                 \\\n+            baseOffset32(Rd, adr, offset);                                                         \\\n+            Assembler::NAME(Rd, Rd, offset);                                                       \\\n+          }                                                                                        \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  void NAME(Register Rd, Label &L) {                                                               \\\n+    wrap_label(Rd, L, &MacroAssembler::NAME);                                                      \\\n+  }\n+\n+  INSN(lb);\n+  INSN(lbu);\n+  INSN(lh);\n+  INSN(lhu);\n+  INSN(lw);\n+  INSN(lwu);\n+  INSN(ld);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(FloatRegister Rd, address dest, Register temp = t0) {                                  \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    int64_t distance = dest - pc();                                                                \\\n+    if (is_offset_in_range(distance, 32)) {                                                        \\\n+      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n+      Assembler::NAME(Rd, temp, ((int32_t)distance << 20) >> 20);                                  \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(temp, dest, offset);                                                                  \\\n+      Assembler::NAME(Rd, temp, offset);                                                           \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  INSN_ENTRY_RELOC(void, NAME(FloatRegister Rd, address dest,                                      \\\n+                              relocInfo::relocType rtype, Register temp = t0))                     \\\n+    NAME(Rd, dest, temp);                                                                          \\\n+  }                                                                                                \\\n+  void NAME(FloatRegister Rd, const Address &adr, Register temp = t0) {                            \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        relocate(adr.rspec(), [&] {                                                                \\\n+          NAME(Rd, adr.target(), temp);                                                            \\\n+        });                                                                                        \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rd, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset = 0;                                                                      \\\n+          baseOffset32(temp, adr, offset);                                                         \\\n+          Assembler::NAME(Rd, temp, offset);                                                       \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }\n+\n+  INSN(flw);\n+  INSN(fld);\n+\n+#undef INSN\n+\n+#define INSN(NAME, REGISTER)                                                                       \\\n+  INSN_ENTRY_RELOC(void, NAME(REGISTER Rs, address dest,                                           \\\n+                              relocInfo::relocType rtype, Register temp = t0))                     \\\n+    NAME(Rs, dest, temp);                                                                          \\\n+  }\n+\n+  INSN(sb,  Register);\n+  INSN(sh,  Register);\n+  INSN(sw,  Register);\n+  INSN(sd,  Register);\n+  INSN(fsw, FloatRegister);\n+  INSN(fsd, FloatRegister);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(Register Rs, address dest, Register temp = t0) {                                       \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    assert_different_registers(Rs, temp);                                                          \\\n+    int64_t distance = dest - pc();                                                                \\\n+    if (is_offset_in_range(distance, 32)) {                                                        \\\n+      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n+      Assembler::NAME(Rs, temp, ((int32_t)distance << 20) >> 20);                                  \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(temp, dest, offset);                                                                  \\\n+      Assembler::NAME(Rs, temp, offset);                                                           \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  void NAME(Register Rs, const Address &adr, Register temp = t0) {                                 \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        assert_different_registers(Rs, temp);                                                      \\\n+        relocate(adr.rspec(), [&] {                                                                \\\n+          NAME(Rs, adr.target(), temp);                                                            \\\n+        });                                                                                        \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rs, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset= 0;                                                                       \\\n+          assert_different_registers(Rs, temp);                                                    \\\n+          baseOffset32(temp, adr, offset);                                                         \\\n+          Assembler::NAME(Rs, temp, offset);                                                       \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }\n+\n+  INSN(sb);\n+  INSN(sh);\n+  INSN(sw);\n+  INSN(sd);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n+  void NAME(FloatRegister Rs, address dest, Register temp = t0) {                                  \\\n+    assert_cond(dest != NULL);                                                                     \\\n+    int64_t distance = dest - pc();                                                                \\\n+    if (is_offset_in_range(distance, 32)) {                                                        \\\n+      auipc(temp, (int32_t)distance + 0x800);                                                      \\\n+      Assembler::NAME(Rs, temp, ((int32_t)distance << 20) >> 20);                                  \\\n+    } else {                                                                                       \\\n+      int32_t offset = 0;                                                                          \\\n+      movptr(temp, dest, offset);                                                                  \\\n+      Assembler::NAME(Rs, temp, offset);                                                           \\\n+    }                                                                                              \\\n+  }                                                                                                \\\n+  void NAME(FloatRegister Rs, const Address &adr, Register temp = t0) {                            \\\n+    switch (adr.getMode()) {                                                                       \\\n+      case Address::literal: {                                                                     \\\n+        relocate(adr.rspec(), [&] {                                                                \\\n+          NAME(Rs, adr.target(), temp);                                                            \\\n+        });                                                                                        \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      case Address::base_plus_offset: {                                                            \\\n+        if (is_offset_in_range(adr.offset(), 12)) {                                                \\\n+          Assembler::NAME(Rs, adr.base(), adr.offset());                                           \\\n+        } else {                                                                                   \\\n+          int32_t offset = 0;                                                                      \\\n+          baseOffset32(temp, adr, offset);                                                         \\\n+          Assembler::NAME(Rs, temp, offset);                                                       \\\n+        }                                                                                          \\\n+        break;                                                                                     \\\n+      }                                                                                            \\\n+      default:                                                                                     \\\n+        ShouldNotReachHere();                                                                      \\\n+    }                                                                                              \\\n+  }\n+\n+  INSN(fsw);\n+  INSN(fsd);\n+\n+#undef INSN\n+\n+#undef INSN_ENTRY_RELOC\n+\n@@ -938,3 +1251,6 @@\n-      int32_t offset = 0;\n-      la_patchable(dest, InternalAddress(const_addr.target()), offset);\n-      ld(dest, Address(dest, offset));\n+      InternalAddress target(const_addr.target());\n+      relocate(target.rspec(), [&] {\n+        int32_t offset;\n+        la_patchable(dest, target, offset);\n+        ld(dest, Address(dest, offset));\n+      });\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":341,"deletions":25,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -393,0 +394,1 @@\n+  Assembler::IncompressibleRegion ir(&a);  \/\/ Fixed length: see NativeGeneralJump::get_instruction_size()\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1227,1 +1227,0 @@\n-  Assembler::CompressibleRegion cr(&_masm);\n@@ -1321,2 +1320,5 @@\n-  MacroAssembler::assert_alignment(__ pc());\n-  __ nop();\n+  {\n+    Assembler::IncompressibleRegion ir(&_masm);  \/\/ keep the nop as 4 bytes for patching.\n+    MacroAssembler::assert_alignment(__ pc());\n+    __ nop();  \/\/ 4 bytes\n+  }\n@@ -1532,1 +1534,0 @@\n-      Assembler::CompressibleRegion cr(&_masm);\n@@ -1553,1 +1554,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -1683,0 +1683,1 @@\n+  Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see BoxLockNode::size()\n@@ -2107,1 +2108,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -2134,1 +2134,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -2271,0 +2270,1 @@\n+    Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see ret_addr_offset\n@@ -2309,0 +2309,1 @@\n+    Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see ret_addr_offset\n@@ -2327,0 +2328,1 @@\n+    Assembler::IncompressibleRegion ir(&_masm);  \/\/ Fixed length: see ret_addr_offset\n@@ -2553,1 +2555,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -2560,1 +2561,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -2576,1 +2576,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -4561,1 +4560,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -4577,1 +4575,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -4608,1 +4605,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -4640,1 +4636,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -4671,1 +4666,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -4717,1 +4711,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -5002,1 +4995,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -5032,1 +5024,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -5063,1 +5054,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -5094,1 +5084,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -5139,1 +5128,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -5155,1 +5143,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6337,1 +6324,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6353,1 +6339,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6370,1 +6355,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6387,1 +6371,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6403,1 +6386,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6419,1 +6401,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6436,1 +6417,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6452,1 +6432,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6470,1 +6449,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6487,1 +6465,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6504,1 +6481,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6520,1 +6496,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6650,1 +6625,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6806,1 +6780,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6842,1 +6815,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6861,1 +6833,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -6897,1 +6868,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -7451,1 +7421,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -7468,1 +7437,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -7485,1 +7453,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -7518,1 +7485,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -7551,1 +7517,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -7568,1 +7533,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -7585,1 +7549,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -7618,1 +7581,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -7820,1 +7782,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -7836,1 +7797,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -7991,1 +7951,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -8146,1 +8105,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -8164,1 +8122,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -8261,1 +8218,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -8298,1 +8254,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -8317,1 +8272,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -8354,1 +8308,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -8373,1 +8326,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n@@ -8392,1 +8344,0 @@\n-    Assembler::CompressibleRegion cr(&_masm);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":9,"deletions":58,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciJavaClasses.hpp\"\n+#endif\n@@ -211,0 +214,3 @@\n+#if !INCLUDE_JVMCI\n+  assert(!_save_vectors, \"vectors are generated only by C2 and JVMCI\");\n+#endif\n@@ -336,3 +342,6 @@\n-  int32_t offset = 0;\n-  __ la_patchable(t0, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)), offset);\n-  __ jalr(x1, t0, offset);\n+  RuntimeAddress target(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite));\n+  __ relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(t0, target, offset);\n+    __ jalr(x1, t0, offset);\n+  });\n@@ -496,0 +505,12 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    \/\/ check if this call should be routed towards a specific entry point\n+    __ ld(t0, Address(xthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));\n+    Label no_alternative_target;\n+    __ beqz(t0, no_alternative_target);\n+    __ mv(t1, t0);\n+    __ sd(zr, Address(xthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));\n+    __ bind(no_alternative_target);\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+\n@@ -941,2 +962,5 @@\n-    MacroAssembler::assert_alignment(__ pc());\n-    __ nop();\n+    {\n+      Assembler::IncompressibleRegion ir(masm);  \/\/ keep the nop as 4 bytes for patching.\n+      MacroAssembler::assert_alignment(__ pc());\n+      __ nop();  \/\/ 4 bytes\n+    }\n@@ -1093,2 +1117,5 @@\n-  MacroAssembler::assert_alignment(__ pc());\n-  __ nop();\n+  {\n+    Assembler::IncompressibleRegion ir(masm);  \/\/ keep the nop as 4 bytes for patching.\n+    MacroAssembler::assert_alignment(__ pc());\n+    __ nop();  \/\/ 4 bytes\n+  }\n@@ -1266,3 +1293,6 @@\n-    int32_t offset = 0;\n-    __ la_patchable(t0, ExternalAddress((address)&DTraceMethodProbes), offset);\n-    __ lbu(t0, Address(t0, offset));\n+    ExternalAddress target((address)&DTraceMethodProbes);\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ lbu(t0, Address(t0, offset));\n+    });\n@@ -1469,3 +1499,6 @@\n-    int32_t offset = 0;\n-    __ la_patchable(t0, ExternalAddress((address)&DTraceMethodProbes), offset);\n-    __ lbu(t0, Address(t0, offset));\n+    ExternalAddress target((address)&DTraceMethodProbes);\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ lbu(t0, Address(t0, offset));\n+    });\n@@ -1602,3 +1635,6 @@\n-    int32_t offset = 0;\n-    __ la_patchable(t0, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)), offset);\n-    __ jalr(x1, t0, offset);\n+    RuntimeAddress target(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ jalr(x1, t0, offset);\n+    });\n@@ -1678,0 +1714,5 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    pad += 512; \/\/ Increase the buffer size when compiling for JVMCI\n+  }\n+#endif\n@@ -1729,0 +1770,6 @@\n+#if INCLUDE_JVMCI && !defined(COMPILER1)\n+  if (EnableJVMCI && UseJVMCICompiler) {\n+    \/\/ JVMCI does not use this kind of deoptimization\n+    __ should_not_reach_here();\n+  }\n+#endif\n@@ -1739,0 +1786,41 @@\n+#if INCLUDE_JVMCI\n+  Label after_fetch_unroll_info_call;\n+  int implicit_exception_uncommon_trap_offset = 0;\n+  int uncommon_trap_offset = 0;\n+\n+  if (EnableJVMCI) {\n+    implicit_exception_uncommon_trap_offset = __ pc() - start;\n+\n+    __ ld(ra, Address(xthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));\n+    __ sd(zr, Address(xthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));\n+\n+    uncommon_trap_offset = __ pc() - start;\n+\n+    \/\/ Save everything in sight.\n+    reg_saver.save_live_registers(masm, 0, &frame_size_in_words);\n+    \/\/ fetch_unroll_info needs to call last_java_frame()\n+    Label retaddr;\n+    __ set_last_Java_frame(sp, noreg, retaddr, t0);\n+\n+    __ lw(c_rarg1, Address(xthread, in_bytes(JavaThread::pending_deoptimization_offset())));\n+    __ mvw(t0, -1);\n+    __ sw(t0, Address(xthread, in_bytes(JavaThread::pending_deoptimization_offset())));\n+\n+    __ mvw(xcpool, (int32_t)Deoptimization::Unpack_reexecute);\n+    __ mv(c_rarg0, xthread);\n+    __ orrw(c_rarg2, zr, xcpool); \/\/ exec mode\n+    RuntimeAddress target(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap));\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ jalr(x1, t0, offset);\n+    });\n+    __ bind(retaddr);\n+    oop_maps->add_gc_map( __ pc()-start, map->deep_copy());\n+\n+    __ reset_last_Java_frame(false);\n+\n+    __ j(after_fetch_unroll_info_call);\n+  } \/\/ EnableJVMCI\n+#endif \/\/ INCLUDE_JVMCI\n+\n@@ -1821,3 +1909,6 @@\n-  int32_t offset = 0;\n-  __ la_patchable(t0, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)), offset);\n-  __ jalr(x1, t0, offset);\n+  RuntimeAddress target(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info));\n+  __ relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(t0, target, offset);\n+    __ jalr(x1, t0, offset);\n+  });\n@@ -1832,0 +1923,6 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    __ bind(after_fetch_unroll_info_call);\n+  }\n+#endif\n+\n@@ -1959,3 +2056,6 @@\n-  offset = 0;\n-  __ la_patchable(t0, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)), offset);\n-  __ jalr(x1, t0, offset);\n+  target = RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames));\n+  __ relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(t0, target, offset);\n+    __ jalr(x1, t0, offset);\n+  });\n@@ -1987,0 +2087,6 @@\n+#if INCLUDE_JVMCI\n+  if (EnableJVMCI) {\n+    _deopt_blob->set_uncommon_trap_offset(uncommon_trap_offset);\n+    _deopt_blob->set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);\n+  }\n+#endif\n@@ -2045,5 +2151,6 @@\n-  int32_t offset = 0;\n-  __ la_patchable(t0,\n-        RuntimeAddress(CAST_FROM_FN_PTR(address,\n-                                        Deoptimization::uncommon_trap)), offset);\n-  __ jalr(x1, t0, offset);\n+  RuntimeAddress target(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap));\n+  __ relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(t0, target, offset);\n+    __ jalr(x1, t0, offset);\n+  });\n@@ -2091,2 +2198,2 @@\n-  __ ld(fp, sp, 0);\n-  __ ld(ra, sp, wordSize);\n+  __ ld(fp, Address(sp, 0));\n+  __ ld(ra, Address(sp, wordSize));\n@@ -2171,3 +2278,6 @@\n-  offset = 0;\n-  __ la_patchable(t0, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)), offset);\n-  __ jalr(x1, t0, offset);\n+  target = RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames));\n+  __ relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(t0, target, offset);\n+    __ jalr(x1, t0, offset);\n+  });\n@@ -2242,3 +2352,6 @@\n-  int32_t offset = 0;\n-  __ la_patchable(t0, RuntimeAddress(call_ptr), offset);\n-  __ jalr(x1, t0, offset);\n+  RuntimeAddress target(call_ptr);\n+  __ relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(t0, target, offset);\n+    __ jalr(x1, t0, offset);\n+  });\n@@ -2352,3 +2465,6 @@\n-    int32_t offset = 0;\n-    __ la_patchable(t0, RuntimeAddress(destination), offset);\n-    __ jalr(x1, t0, offset);\n+    RuntimeAddress target(destination);\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ jalr(x1, t0, offset);\n+    });\n@@ -2483,3 +2599,6 @@\n-  int32_t offset = 0;\n-  __ la_patchable(t0, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)), offset);\n-  __ jalr(x1, t0, offset);\n+  RuntimeAddress target(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C));\n+  __ relocate(target.rspec(), [&] {\n+    int32_t offset;\n+    __ la_patchable(t0, target, offset);\n+    __ jalr(x1, t0, offset);\n+  });\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":160,"deletions":41,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+  static void assert_is_rfp(VMReg r) NOT_DEBUG_RETURN\n","filename":"src\/hotspot\/cpu\/riscv\/smallRegisterMap_riscv.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-    __ ld(t0, c_rarg5, 0);\n+    __ ld(t0, Address(c_rarg5, 0));\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1078,1 +1078,1 @@\n-    __ ld(t1, t1);\n+    __ ld(t1, Address(t1, 0));\n@@ -1445,0 +1445,11 @@\n+\/\/ Method entry for java.lang.Thread.currentThread\n+address TemplateInterpreterGenerator::generate_currentThread() {\n+  address entry_point = __ pc();\n+\n+  __ ld(x10, Address(xthread, JavaThread::vthread_offset()));\n+  __ resolve_oop_handle(x10, t0, t1);\n+  __ ret();\n+\n+  return entry_point;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-      __ flw(f10, t0, 0);\n+      __ flw(f10, Address(t0, 0));\n@@ -250,1 +250,1 @@\n-      __ flw(f10, t0, sizeof(float));\n+      __ flw(f10, Address(t0, sizeof(float)));\n@@ -266,1 +266,1 @@\n-      __ fld(f10, t0, 0);\n+      __ fld(f10, Address(t0, 0));\n@@ -269,1 +269,1 @@\n-      __ fld(f10, t0, sizeof(double));\n+      __ fld(f10, Address(t0, sizeof(double)));\n@@ -2266,3 +2266,6 @@\n-    int32_t offset = 0;\n-    __ la_patchable(t0, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()), offset);\n-    __ lwu(x10, Address(t0, offset));\n+    ExternalAddress target((address) JvmtiExport::get_field_access_count_addr());\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ lwu(x10, Address(t0, offset));\n+    });\n@@ -2482,3 +2485,6 @@\n-    int32_t offset = 0;\n-    __ la_patchable(t0, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()), offset);\n-    __ lwu(x10, Address(t0, offset));\n+    ExternalAddress target((address)JvmtiExport::get_field_modification_count_addr());\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ lwu(x10, Address(t0, offset));\n+    });\n@@ -2781,3 +2787,6 @@\n-    int32_t offset = 0;\n-    __ la_patchable(t0, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()), offset);\n-    __ lwu(c_rarg3, Address(t0, offset));\n+    ExternalAddress target((address)JvmtiExport::get_field_modification_count_addr());\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ lwu(c_rarg3, Address(t0, offset));\n+    });\n@@ -2917,3 +2926,6 @@\n-    int32_t offset = 0;\n-    __ la_patchable(t0, ExternalAddress((address)JvmtiExport::get_field_access_count_addr()), offset);\n-    __ lwu(x12, Address(t0, offset));\n+    ExternalAddress target((address)JvmtiExport::get_field_access_count_addr());\n+    __ relocate(target.rspec(), [&] {\n+      int32_t offset;\n+      __ la_patchable(t0, target, offset);\n+      __ lwu(x12, Address(t0, offset));\n+    });\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":28,"deletions":16,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  void asm_assert_ijava_state_magic(Register tmp) PRODUCT_RETURN;\n+  void asm_assert_ijava_state_magic(Register tmp) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+  static void assert_is_rfp(VMReg r) NOT_DEBUG_RETURN\n","filename":"src\/hotspot\/cpu\/s390\/smallRegisterMap_s390.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1933,0 +1933,28 @@\n+void Assembler::vcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/*uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24(0x1D, (0xC0 | encode), imm8);\n+}\n+\n+void Assembler::evcvtps2ph(Address dst, KRegister mask, XMMRegister src, int imm8, int vector_len) {\n+  assert(VM_Version::supports_avx512vl(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/*uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_HVM, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.reset_is_clear_context();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x1D);\n+  emit_operand(src, dst, 1);\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::vcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512vl() || VM_Version::supports_f16c(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x13, (0xC0 | encode));\n+}\n+\n@@ -2132,0 +2160,7 @@\n+void Assembler::vcvttpd2dq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len <= AVX_256bit ? VM_Version::supports_avx() : VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xE6, (0xC0 | encode));\n+}\n+\n@@ -2140,1 +2175,1 @@\n-  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n@@ -2148,1 +2183,1 @@\n-  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n@@ -2156,1 +2191,1 @@\n-  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n@@ -2164,1 +2199,1 @@\n-  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n@@ -2172,1 +2207,1 @@\n-  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_avx512dq(), \"\");\n@@ -2180,1 +2215,1 @@\n-  assert(UseAVX > 2  && VM_Version::supports_avx512bw(), \"\");\n+  assert(VM_Version::supports_avx512bw(), \"\");\n@@ -7187,1 +7222,1 @@\n-void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+void Assembler::evpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n@@ -7222,1 +7257,1 @@\n-void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n+void Assembler::evpmullq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":43,"deletions":8,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1159,0 +1159,5 @@\n+  \/\/ Convert Halffloat to Single Precision Floating-Point value\n+  void vcvtps2ph(XMMRegister dst, XMMRegister src, int imm8, int vector_len);\n+  void vcvtph2ps(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evcvtps2ph(Address dst, KRegister mask, XMMRegister src, int imm8, int vector_len);\n+\n@@ -1199,0 +1204,3 @@\n+  \/\/ Convert vector double to int\n+  void vcvttpd2dq(XMMRegister dst, XMMRegister src, int vector_len);\n+\n@@ -2514,1 +2522,1 @@\n-  void vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -2518,1 +2526,1 @@\n-  void vpmullq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n+  void evpmullq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1723,13 +1723,5 @@\n-void C2_MacroAssembler::load_iota_indices(XMMRegister dst, int vlen_in_bytes) {\n-  ExternalAddress addr(StubRoutines::x86::vector_iota_indices());\n-  if (vlen_in_bytes <= 4) {\n-    movdl(dst, addr);\n-  } else if (vlen_in_bytes == 8) {\n-    movq(dst, addr);\n-  } else if (vlen_in_bytes == 16) {\n-    movdqu(dst, addr, noreg);\n-  } else if (vlen_in_bytes == 32) {\n-    vmovdqu(dst, addr, noreg);\n-  } else {\n-    assert(vlen_in_bytes == 64, \"%d\", vlen_in_bytes);\n-    evmovdqub(dst, k0, addr, false \/*merge*\/, Assembler::AVX_512bit, noreg);\n+void C2_MacroAssembler::load_iota_indices(XMMRegister dst, int vlen_in_bytes, BasicType bt) {\n+  \/\/ The iota indices are ordered by type B\/S\/I\/L\/F\/D, and the offset between two types is 64.\n+  int offset = exact_log2(type2aelembytes(bt)) << 6;\n+  if (is_floating_point_type(bt)) {\n+    offset += 128;\n@@ -1737,0 +1729,2 @@\n+  ExternalAddress addr(StubRoutines::x86::vector_iota_indices() + offset);\n+  load_vector(dst, addr, vlen_in_bytes);\n@@ -1789,1 +1783,1 @@\n-                            vpmullq(dst, dst, src, vector_len); break;\n+                            evpmullq(dst, dst, src, vector_len); break;\n@@ -1837,1 +1831,1 @@\n-    case Op_MulReductionVL: vpmullq(dst, src1, src2, vector_len); break;\n+    case Op_MulReductionVL: evpmullq(dst, src1, src2, vector_len); break;\n@@ -4391,3 +4385,5 @@\n-void C2_MacroAssembler::vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                                            XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                                            Register rscratch) {\n+void C2_MacroAssembler::vector_cast_float_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                   XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                                                   Register rscratch, AddressLiteral float_sign_flip,\n+                                                                   int vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n@@ -4419,4 +4415,5 @@\n-void C2_MacroAssembler::vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                                             XMMRegister xtmp1, XMMRegister xtmp2,\n-                                                             KRegister ktmp1, KRegister ktmp2,\n-                                                             Register rscratch) {\n+void C2_MacroAssembler::vector_cast_float_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                    XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                    Register rscratch, AddressLiteral float_sign_flip,\n+                                                                    int vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n@@ -4440,5 +4437,4 @@\n-void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src,\n-                                                                     AddressLiteral double_sign_flip, int vec_enc,\n-                                                                     XMMRegister xtmp1, XMMRegister xtmp2,\n-                                                                     KRegister ktmp1, KRegister ktmp2,\n-                                                                     Register rscratch) {\n+void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                     XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                     Register rscratch, AddressLiteral double_sign_flip,\n+                                                                     int vec_enc) {\n@@ -4464,0 +4460,22 @@\n+void C2_MacroAssembler::vector_cast_double_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                     XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                     Register rscratch, AddressLiteral float_sign_flip,\n+                                                                     int vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n+  Label done;\n+  evmovdquq(xtmp1, k0, float_sign_flip, false, vec_enc, rscratch);\n+  Assembler::evpcmpeqd(ktmp1, k0, xtmp1, dst, vec_enc);\n+  kortestwl(ktmp1, ktmp1);\n+  jccb(Assembler::equal, done);\n+\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  evcmppd(ktmp2, k0, src, src, Assembler::UNORD_Q, vec_enc);\n+  evmovdqul(dst, ktmp2, xtmp2, true, vec_enc);\n+\n+  kxorwl(ktmp1, ktmp1, ktmp2);\n+  evcmppd(ktmp1, ktmp1, src, xtmp2, Assembler::NLT_UQ, vec_enc);\n+  vpternlogq(xtmp2, 0x11, xtmp1, xtmp1, vec_enc);\n+  evmovdqul(dst, ktmp1, xtmp2, true, vec_enc);\n+  bind(done);\n+}\n+\n@@ -4472,4 +4490,4 @@\n-void C2_MacroAssembler::vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src,\n-                                                              AddressLiteral double_sign_flip, int vec_enc,\n-                                                              XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                              Register rscratch) {\n+void C2_MacroAssembler::vector_cast_double_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                      XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                      Register rscratch, AddressLiteral double_sign_flip,\n+                                                                      int vec_enc) {\n@@ -4495,0 +4513,76 @@\n+void C2_MacroAssembler::vector_crosslane_doubleword_pack_avx(XMMRegister dst, XMMRegister src, XMMRegister zero,\n+                                                             XMMRegister xtmp, int index, int vec_enc) {\n+   assert(vec_enc < Assembler::AVX_512bit, \"\");\n+   if (vec_enc == Assembler::AVX_256bit) {\n+     vextractf128_high(xtmp, src);\n+     vshufps(dst, src, xtmp, index, vec_enc);\n+   } else {\n+     vshufps(dst, src, zero, index, vec_enc);\n+   }\n+}\n+\n+void C2_MacroAssembler::vector_cast_double_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                                    XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5, Register rscratch,\n+                                                                    AddressLiteral float_sign_flip, int src_vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n+\n+  Label done;\n+  \/\/ Compare the destination lanes with float_sign_flip\n+  \/\/ value to get mask for all special values.\n+  movdqu(xtmp1, float_sign_flip, rscratch);\n+  vpcmpeqd(xtmp2, dst, xtmp1, Assembler::AVX_128bit);\n+  ptest(xtmp2, xtmp2);\n+  jccb(Assembler::equal, done);\n+\n+  \/\/ Flip float_sign_flip to get max integer value.\n+  vpcmpeqd(xtmp4, xtmp4, xtmp4, Assembler::AVX_128bit);\n+  pxor(xtmp1, xtmp4);\n+\n+  \/\/ Set detination lanes corresponding to unordered source lanes as zero.\n+  vpxor(xtmp4, xtmp4, xtmp4, src_vec_enc);\n+  vcmppd(xtmp3, src, src, Assembler::UNORD_Q, src_vec_enc);\n+\n+  \/\/ Shuffle mask vector and pack lower doubles word from each quadword lane.\n+  vector_crosslane_doubleword_pack_avx(xtmp3, xtmp3, xtmp4, xtmp5, 0x88, src_vec_enc);\n+  vblendvps(dst, dst, xtmp4, xtmp3, Assembler::AVX_128bit);\n+\n+  \/\/ Recompute the mask for remaining special value.\n+  pxor(xtmp2, xtmp3);\n+  \/\/ Extract mask corresponding to non-negative source lanes.\n+  vcmppd(xtmp3, src, xtmp4, Assembler::NLT_UQ, src_vec_enc);\n+\n+  \/\/ Shuffle mask vector and pack lower doubles word from each quadword lane.\n+  vector_crosslane_doubleword_pack_avx(xtmp3, xtmp3, xtmp4, xtmp5, 0x88, src_vec_enc);\n+  pand(xtmp3, xtmp2);\n+\n+  \/\/ Replace destination lanes holding special value(0x80000000) with max int\n+  \/\/ if corresponding source lane holds a +ve value.\n+  vblendvps(dst, dst, xtmp1, xtmp3, Assembler::AVX_128bit);\n+  bind(done);\n+}\n+\n+\n+void C2_MacroAssembler::vector_cast_int_to_subword(BasicType to_elem_bt, XMMRegister dst, XMMRegister zero,\n+                                                   XMMRegister xtmp, Register rscratch, int vec_enc) {\n+  switch(to_elem_bt) {\n+    case T_SHORT:\n+      assert(rscratch != noreg || always_reachable(ExternalAddress(StubRoutines::x86::vector_int_to_short_mask())), \"missing\");\n+      vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_int_to_short_mask()), vec_enc, rscratch);\n+      vpackusdw(dst, dst, zero, vec_enc);\n+      if (vec_enc == Assembler::AVX_256bit) {\n+        vector_crosslane_doubleword_pack_avx(dst, dst, zero, xtmp, 0x44, vec_enc);\n+      }\n+      break;\n+    case  T_BYTE:\n+      assert(rscratch != noreg || always_reachable(ExternalAddress(StubRoutines::x86::vector_int_to_byte_mask())), \"missing\");\n+      vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_int_to_byte_mask()), vec_enc, rscratch);\n+      vpackusdw(dst, dst, zero, vec_enc);\n+      if (vec_enc == Assembler::AVX_256bit) {\n+        vector_crosslane_doubleword_pack_avx(dst, dst, zero, xtmp, 0x44, vec_enc);\n+      }\n+      vpackuswb(dst, dst, zero, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n+}\n+\n@@ -4505,13 +4599,5 @@\n-void C2_MacroAssembler::vector_castD2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n-\n-  evcvttpd2qq(dst, src, vec_enc);\n-  vector_cast_double_special_cases_evex(dst, src, double_sign_flip, vec_enc,\n-                                        xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n-}\n-\n-void C2_MacroAssembler::vector_castF2I_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                           XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n-\n+void C2_MacroAssembler::vector_castF2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                           AddressLiteral float_sign_flip, Register rscratch, int vec_enc) {\n+  int to_elem_sz = type2aelembytes(to_elem_bt);\n+  assert(to_elem_sz <= 4, \"\");\n@@ -4519,2 +4605,5 @@\n-  vector_cast_float_special_cases_avx(dst, src, float_sign_flip, vec_enc,\n-                                      xtmp1, xtmp2, xtmp3, xtmp4, rscratch);\n+  vector_cast_float_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, rscratch, float_sign_flip, vec_enc);\n+  if (to_elem_sz < 4) {\n+    vpxor(xtmp4, xtmp4, xtmp4, vec_enc);\n+    vector_cast_int_to_subword(to_elem_bt, dst, xtmp4, xtmp3, rscratch, vec_enc);\n+  }\n@@ -4523,4 +4612,5 @@\n-void C2_MacroAssembler::vector_castF2I_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n-\n+void C2_MacroAssembler::vector_castF2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                            XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n+                                            Register rscratch, int vec_enc) {\n+  int to_elem_sz = type2aelembytes(to_elem_bt);\n+  assert(to_elem_sz <= 4, \"\");\n@@ -4528,2 +4618,12 @@\n-  vector_cast_float_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n-                                       xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n+  vector_cast_float_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, float_sign_flip, vec_enc);\n+  switch(to_elem_bt) {\n+    case T_INT:\n+      break;\n+    case T_SHORT:\n+      evpmovdw(dst, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evpmovdb(dst, dst, vec_enc);\n+      break;\n+    default: assert(false, \"%s\", type2name(to_elem_bt));\n+  }\n@@ -4532,4 +4632,3 @@\n-void C2_MacroAssembler::vector_castF2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n-\n+void C2_MacroAssembler::vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                                            Register rscratch, int vec_enc) {\n@@ -4537,11 +4636,25 @@\n-  vector_cast_float_to_long_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n-                                               xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n-}\n-\n-void C2_MacroAssembler::vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch) {\n-  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n-\n-  vector_castD2L_evex(dst, src, double_sign_flip, vec_enc,\n-                      xtmp1, xtmp2, ktmp1, ktmp2, rscratch);\n-  if (to_elem_bt != T_LONG) {\n+  vector_cast_float_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, double_sign_flip, vec_enc);\n+}\n+\n+\/\/ Handling for downcasting from double to integer or sub-word types on AVX2.\n+void C2_MacroAssembler::vector_castD2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5,\n+                                           AddressLiteral float_sign_flip, Register rscratch, int vec_enc) {\n+  int to_elem_sz = type2aelembytes(to_elem_bt);\n+  assert(to_elem_sz < 8, \"\");\n+  vcvttpd2dq(dst, src, vec_enc);\n+  vector_cast_double_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, xtmp5, rscratch,\n+                                              float_sign_flip, vec_enc);\n+  if (to_elem_sz < 4) {\n+    \/\/ xtmp4 holds all zero lanes.\n+    vector_cast_int_to_subword(to_elem_bt, dst, xtmp4, xtmp5, rscratch, Assembler::AVX_128bit);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src,\n+                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1,\n+                                            KRegister ktmp2, AddressLiteral sign_flip,\n+                                            Register rscratch, int vec_enc) {\n+  if (VM_Version::supports_avx512dq()) {\n+    evcvttpd2qq(dst, src, vec_enc);\n+    vector_cast_double_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, sign_flip, vec_enc);\n@@ -4549,0 +4662,2 @@\n+      case T_LONG:\n+        break;\n@@ -4562,0 +4677,15 @@\n+  } else {\n+    assert(type2aelembytes(to_elem_bt) <= 4, \"\");\n+    vcvttpd2dq(dst, src, vec_enc);\n+    vector_cast_double_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, sign_flip, vec_enc);\n+    switch(to_elem_bt) {\n+      case T_INT:\n+        break;\n+      case T_SHORT:\n+        evpmovdw(dst, dst, vec_enc);\n+        break;\n+      case T_BYTE:\n+        evpmovdb(dst, dst, vec_enc);\n+        break;\n+      default: assert(false, \"%s\", type2name(to_elem_bt));\n+    }\n@@ -4577,2 +4707,2 @@\n-  vector_cast_double_special_cases_evex(dst, src, double_sign_flip, vec_enc,\n-                                        xtmp1, xtmp2, ktmp1, ktmp2, tmp);\n+  vector_cast_double_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, tmp \/*rscratch*\/,\n+                                                double_sign_flip, vec_enc);;\n@@ -4595,2 +4725,2 @@\n-  vector_cast_float_special_cases_evex(dst, src, float_sign_flip, vec_enc,\n-                                       xtmp1, xtmp2, ktmp1, ktmp2, tmp);\n+  vector_cast_float_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, tmp \/*rscratch*\/,\n+                                              float_sign_flip, vec_enc);\n@@ -4613,2 +4743,1 @@\n-  vector_cast_float_special_cases_avx(dst, src, float_sign_flip, vec_enc,\n-                                      xtmp1, xtmp2, xtmp3, xtmp4, tmp);\n+  vector_cast_float_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, tmp \/*rscratch*\/, float_sign_flip, vec_enc);\n@@ -4647,0 +4776,55 @@\n+void C2_MacroAssembler::vector_mask_cast(XMMRegister dst, XMMRegister src,\n+                                         BasicType dst_bt, BasicType src_bt, int vlen) {\n+  int vlen_enc = vector_length_encoding(MAX2(type2aelembytes(src_bt), type2aelembytes(dst_bt)) * vlen);\n+  assert(vlen_enc != AVX_512bit, \"\");\n+\n+  int dst_bt_size = type2aelembytes(dst_bt);\n+  int src_bt_size = type2aelembytes(src_bt);\n+  if (dst_bt_size > src_bt_size) {\n+    switch (dst_bt_size \/ src_bt_size) {\n+      case 2: vpmovsxbw(dst, src, vlen_enc); break;\n+      case 4: vpmovsxbd(dst, src, vlen_enc); break;\n+      case 8: vpmovsxbq(dst, src, vlen_enc); break;\n+      default: ShouldNotReachHere();\n+    }\n+  } else {\n+    assert(dst_bt_size < src_bt_size, \"\");\n+    switch (src_bt_size \/ dst_bt_size) {\n+      case 2: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpacksswb(dst, src, src, vlen_enc);\n+        } else {\n+          vpacksswb(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+        }\n+        break;\n+      }\n+      case 4: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      case 8: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, AVX_128bit);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      default: ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":257,"deletions":73,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  void load_iota_indices(XMMRegister dst, int vlen_in_bytes);\n+  void load_iota_indices(XMMRegister dst, int vlen_in_bytes, BasicType bt);\n@@ -312,2 +312,2 @@\n-  void vector_castF2I_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                          XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, Register rscratch = noreg);\n+  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                            BasicType from_elem_bt, BasicType to_elem_bt);\n@@ -315,2 +315,2 @@\n-  void vector_castF2I_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n+  void vector_cast_int_to_subword(BasicType to_elem_bt, XMMRegister dst, XMMRegister zero,\n+                                  XMMRegister xtmp, Register rscratch, int vec_enc);\n@@ -318,2 +318,3 @@\n-  void vector_castF2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n+  void vector_castF2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                          XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                          AddressLiteral float_sign_flip, Register rscratch, int vec_enc);\n@@ -321,2 +322,3 @@\n-  void vector_castD2L_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg );\n+  void vector_castF2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                           XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n+                           Register rscratch, int vec_enc);\n@@ -324,2 +326,3 @@\n-  void vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                           XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n+  void vector_castF2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                           KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                           Register rscratch, int vec_enc);\n@@ -327,1 +330,3 @@\n-  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc, BasicType from_elem_bt, BasicType to_elem_bt);\n+  void vector_castD2X_evex(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                           XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, AddressLiteral sign_flip,\n+                           Register rscratch, int vec_enc);\n@@ -329,2 +334,3 @@\n-  void vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg );\n+  void vector_castD2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                          XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5,\n+                          AddressLiteral float_sign_flip, Register rscratch, int vec_enc);\n@@ -332,2 +338,0 @@\n-  void vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                            XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2, Register rscratch = noreg);\n@@ -335,3 +339,3 @@\n-  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, AddressLiteral double_sign_flip, int vec_enc,\n-                                                    XMMRegister xtmp1, XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                    Register rscratch = noreg);\n+  void vector_cast_double_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                   XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5, Register rscratch,\n+                                                   AddressLiteral float_sign_flip, int vec_enc);\n@@ -339,3 +343,24 @@\n-  void vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, AddressLiteral float_sign_flip, int vec_enc,\n-                                           XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                           Register rscratch = noreg);\n+  void vector_cast_double_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                    KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral float_sign_flip,\n+                                                    int vec_enc);\n+\n+  void vector_cast_double_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                     KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral double_sign_flip,\n+                                                     int vec_enc);\n+\n+  void vector_cast_float_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                   KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral float_sign_flip,\n+                                                   int vec_enc);\n+\n+  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                    KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral double_sign_flip,\n+                                                    int vec_enc);\n+\n+  void vector_cast_float_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3,\n+                                                  XMMRegister xtmp4, Register rscratch, AddressLiteral float_sign_flip,\n+                                                  int vec_enc);\n+\n+  void vector_crosslane_doubleword_pack_avx(XMMRegister dst, XMMRegister src, XMMRegister zero,\n+                                            XMMRegister xtmp, int index, int vec_enc);\n+\n+  void vector_mask_cast(XMMRegister dst, XMMRegister src, BasicType dst_bt, BasicType src_bt, int vlen);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":47,"deletions":22,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -5442,1 +5442,1 @@\n-void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,\n+void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register val,\n@@ -5448,1 +5448,1 @@\n-    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -5450,1 +5450,1 @@\n-    bs->store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -5505,1 +5505,1 @@\n-void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,\n+void MacroAssembler::store_heap_oop(Address dst, Register val, Register tmp1,\n@@ -5507,1 +5507,1 @@\n-  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);\n+  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, val, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -390,1 +390,1 @@\n-  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,\n+  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register val,\n@@ -407,1 +407,1 @@\n-  void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,\n+  void store_heap_oop(Address dst, Register val, Register tmp1 = noreg,\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -187,0 +187,3 @@\n+  \/\/ Currently, it's a rudimentary heuristic based on emitted code size for complex\n+  \/\/ IR nodes used by unroll policy. Idea is to constrain unrolling factor and prevent\n+  \/\/ generating bloated loop bodies.\n@@ -191,0 +194,7 @@\n+      case Op_MulVB:\n+        return 7;\n+      case Op_MulVL:\n+        return VM_Version::supports_avx512vldq() ? 0 : 6;\n+      case Op_VectorCastF2X: \/\/ fall through\n+      case Op_VectorCastD2X:\n+        return is_floating_point_type(ety) ? 0 : (is_subword_type(ety) ? 35 : 30);\n@@ -206,1 +216,1 @@\n-      case Op_RoundVD: {\n+      case Op_RoundVD:\n@@ -208,1 +218,0 @@\n-      }\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#ifdef COMPILER2\n+\n+#include \"peephole_x86_64.hpp\"\n+\n+\/\/ This function transforms the shapes\n+\/\/ mov d, s1; add d, s2 into\n+\/\/ lea d, [s1 + s2]     and\n+\/\/ mov d, s1; shl d, s2 into\n+\/\/ lea d, [s1 << s2]    with s2 = 1, 2, 3\n+bool lea_coalesce_helper(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                         MachNode* (*new_root)(), uint inst0_rule, bool imm) {\n+  MachNode* inst0 = block->get_node(block_index)->as_Mach();\n+  assert(inst0->rule() == inst0_rule, \"sanity\");\n+\n+  OptoReg::Name dst = ra_->get_reg_first(inst0);\n+  MachNode* inst1 = nullptr;\n+  OptoReg::Name src1 = OptoReg::Bad;\n+\n+  if (inst0->in(1)->is_MachSpillCopy()) {\n+    OptoReg::Name in = ra_->get_reg_first(inst0->in(1)->in(1));\n+    if (OptoReg::is_reg(in) && OptoReg::as_VMReg(in)->is_Register()) {\n+      inst1 = inst0->in(1)->as_Mach();\n+      src1 = in;\n+    }\n+  }\n+  if (inst1 == nullptr) {\n+    return false;\n+  }\n+  assert(dst != src1, \"\");\n+\n+  \/\/ Only coalesce if inst1 is immediately followed by inst0\n+  \/\/ Can be improved for more general cases\n+  if (block_index < 1 || block->get_node(block_index - 1) != inst1) {\n+    return false;\n+  }\n+  int inst1_index = block_index - 1;\n+  Node* inst2;\n+  if (imm) {\n+    inst2 = nullptr;\n+  } else {\n+    inst2 = inst0->in(2);\n+    if (inst2 == inst1) {\n+      inst2 = inst2->in(1);\n+    }\n+  }\n+\n+  \/\/ See VM_Version::supports_fast_3op_lea()\n+  if (!imm) {\n+    Register rsrc1 = OptoReg::as_VMReg(src1)->as_Register();\n+    Register rsrc2 = OptoReg::as_VMReg(ra_->get_reg_first(inst2))->as_Register();\n+    if ((rsrc1 == rbp || rsrc1 == r13) && (rsrc2 == rbp || rsrc2 == r13)) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ Go down the block to find the output proj node (the flag output) of inst0\n+  int proj_index = -1;\n+  Node* proj = nullptr;\n+  for (uint pos = block_index + 1; pos < block->number_of_nodes(); pos++) {\n+    Node* curr = block->get_node(pos);\n+    if (curr->is_MachProj() && curr->in(0) == inst0) {\n+      proj_index = pos;\n+      proj = curr;\n+      break;\n+    }\n+  }\n+  assert(proj != nullptr, \"\");\n+  \/\/ If some node uses the flag, cannot remove\n+  if (proj->outcnt() > 0) {\n+    return false;\n+  }\n+\n+  MachNode* root = new_root();\n+  \/\/ Assign register for the newly allocated node\n+  ra_->set_oop(root, ra_->is_oop(inst0));\n+  ra_->set_pair(root->_idx, ra_->get_reg_second(inst0), ra_->get_reg_first(inst0));\n+\n+  \/\/ Set input and output for the node\n+  root->add_req(inst0->in(0));\n+  root->add_req(inst1->in(1));\n+  \/\/ No input for constant after matching\n+  if (!imm) {\n+    root->add_req(inst2);\n+  }\n+  inst0->replace_by(root);\n+  proj->set_req(0, inst0);\n+\n+  \/\/ Initialize the operand array\n+  root->_opnds[0] = inst0->_opnds[0]->clone();\n+  root->_opnds[1] = inst0->_opnds[1]->clone();\n+  root->_opnds[2] = inst0->_opnds[2]->clone();\n+\n+  \/\/ Modify the block\n+  inst0->set_removed();\n+  inst1->set_removed();\n+  block->remove_node(proj_index);\n+  block->remove_node(block_index);\n+  block->remove_node(inst1_index);\n+  block->insert_node(root, block_index - 1);\n+\n+  \/\/ Modify the CFG\n+  cfg_->map_node_to_block(inst0, nullptr);\n+  cfg_->map_node_to_block(inst1, nullptr);\n+  cfg_->map_node_to_block(proj, nullptr);\n+  cfg_->map_node_to_block(root, block);\n+\n+  return true;\n+}\n+\n+bool Peephole::lea_coalesce_reg(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                                MachNode* (*new_root)(), uint inst0_rule) {\n+  return lea_coalesce_helper(block, block_index, cfg_, ra_, new_root, inst0_rule, false);\n+}\n+\n+bool Peephole::lea_coalesce_imm(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                                MachNode* (*new_root)(), uint inst0_rule) {\n+  return lea_coalesce_helper(block, block_index, cfg_, ra_, new_root, inst0_rule, true);\n+}\n+\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/peephole_x86_64.cpp","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_X86_PEEPHOLE_X86_64_HPP\n+#define CPU_X86_PEEPHOLE_X86_64_HPP\n+\n+#include \"opto\/machnode.hpp\"\n+#include \"opto\/regalloc.hpp\"\n+\n+class Peephole {\n+public:\n+  static bool lea_coalesce_reg(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                               MachNode* (*new_root)(), uint inst0_rule);\n+  static bool lea_coalesce_imm(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                               MachNode* (*new_root)(), uint inst0_rule);\n+};\n+\n+#endif \/\/ CPU_X86_PEEPHOLE_X86_64_HPP\n","filename":"src\/hotspot\/cpu\/x86\/peephole_x86_64.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -832,1 +832,1 @@\n-\n+  \/\/ B\n@@ -841,1 +841,45 @@\n-\n+  \/\/ W\n+  __ emit_data64(0x0003000200010000, relocInfo::none);\n+  __ emit_data64(0x0007000600050004, relocInfo::none);\n+  __ emit_data64(0x000B000A00090008, relocInfo::none);\n+  __ emit_data64(0x000F000E000D000C, relocInfo::none);\n+  __ emit_data64(0x0013001200110010, relocInfo::none);\n+  __ emit_data64(0x0017001600150014, relocInfo::none);\n+  __ emit_data64(0x001B001A00190018, relocInfo::none);\n+  __ emit_data64(0x001F001E001D001C, relocInfo::none);\n+  \/\/ D\n+  __ emit_data64(0x0000000100000000, relocInfo::none);\n+  __ emit_data64(0x0000000300000002, relocInfo::none);\n+  __ emit_data64(0x0000000500000004, relocInfo::none);\n+  __ emit_data64(0x0000000700000006, relocInfo::none);\n+  __ emit_data64(0x0000000900000008, relocInfo::none);\n+  __ emit_data64(0x0000000B0000000A, relocInfo::none);\n+  __ emit_data64(0x0000000D0000000C, relocInfo::none);\n+  __ emit_data64(0x0000000F0000000E, relocInfo::none);\n+  \/\/ Q\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0x0000000000000001, relocInfo::none);\n+  __ emit_data64(0x0000000000000002, relocInfo::none);\n+  __ emit_data64(0x0000000000000003, relocInfo::none);\n+  __ emit_data64(0x0000000000000004, relocInfo::none);\n+  __ emit_data64(0x0000000000000005, relocInfo::none);\n+  __ emit_data64(0x0000000000000006, relocInfo::none);\n+  __ emit_data64(0x0000000000000007, relocInfo::none);\n+  \/\/ D - FP\n+  __ emit_data64(0x3F80000000000000, relocInfo::none); \/\/ 0.0f, 1.0f\n+  __ emit_data64(0x4040000040000000, relocInfo::none); \/\/ 2.0f, 3.0f\n+  __ emit_data64(0x40A0000040800000, relocInfo::none); \/\/ 4.0f, 5.0f\n+  __ emit_data64(0x40E0000040C00000, relocInfo::none); \/\/ 6.0f, 7.0f\n+  __ emit_data64(0x4110000041000000, relocInfo::none); \/\/ 8.0f, 9.0f\n+  __ emit_data64(0x4130000041200000, relocInfo::none); \/\/ 10.0f, 11.0f\n+  __ emit_data64(0x4150000041400000, relocInfo::none); \/\/ 12.0f, 13.0f\n+  __ emit_data64(0x4170000041600000, relocInfo::none); \/\/ 14.0f, 15.0f\n+  \/\/ Q - FP\n+  __ emit_data64(0x0000000000000000, relocInfo::none); \/\/ 0.0d\n+  __ emit_data64(0x3FF0000000000000, relocInfo::none); \/\/ 1.0d\n+  __ emit_data64(0x4000000000000000, relocInfo::none); \/\/ 2.0d\n+  __ emit_data64(0x4008000000000000, relocInfo::none); \/\/ 3.0d\n+  __ emit_data64(0x4010000000000000, relocInfo::none); \/\/ 4.0d\n+  __ emit_data64(0x4014000000000000, relocInfo::none); \/\/ 5.0d\n+  __ emit_data64(0x4018000000000000, relocInfo::none); \/\/ 6.0d\n+  __ emit_data64(0x401c000000000000, relocInfo::none); \/\/ 7.0d\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2886,0 +2886,2 @@\n+    if (_cpuid_info.std_cpuid1_ecx.bits.f16c != 0)\n+      result |= CPU_F16C;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-                        : 2,\n+               f16c     : 1,\n+                        : 1,\n@@ -377,1 +378,2 @@\n-    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\n+    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\\\n+    decl(F16C,              \"f16c\",              53) \/* Half-precision and single precision FP conversion instructions*\/\n@@ -684,0 +686,1 @@\n+  static bool supports_f16c()         { return (_features & CPU_F16C) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1395,0 +1395,2 @@\n+  static address vector_float_signflip() { return StubRoutines::x86::vector_float_sign_flip();}\n+  static address vector_double_signflip() { return StubRoutines::x86::vector_double_sign_flip();}\n@@ -1481,0 +1483,1 @@\n+    case Op_VectorMaskCast:\n@@ -1681,0 +1684,6 @@\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n+      if (!VM_Version::supports_f16c() && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -1728,1 +1737,0 @@\n-    case Op_MulVL:\n@@ -1852,0 +1860,1 @@\n+    case Op_VectorMaskCast:\n@@ -1880,8 +1889,6 @@\n-    case Op_VectorCastD2X:\n-      \/\/ Conversion to integral type is only supported on AVX-512 platforms with avx512dq.\n-      \/\/ Need avx512vl for size_in_bits < 512\n-      if (is_integral_type(bt)) {\n-        if (!VM_Version::supports_avx512dq()) {\n-          return false;\n-        }\n-        if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+    case Op_VectorCastF2X: {\n+        \/\/ As per JLS section 5.1.3 narrowing conversion to sub-word types\n+        \/\/ happen after intermediate conversion to integer and special handling\n+        \/\/ code needs AVX2 vpcmpeqd instruction for 256 bit vectors.\n+        int src_size_in_bits = type2aelembytes(T_FLOAT) * vlen * BitsPerByte;\n+        if (is_integral_type(bt) && src_size_in_bits == 256 && UseAVX < 2) {\n@@ -1891,0 +1898,5 @@\n+      \/\/ fallthrough\n+    case Op_VectorCastD2X:\n+      if (bt == T_LONG && !VM_Version::supports_avx512dq()) {\n+        return false;\n+      }\n@@ -1897,17 +1909,0 @@\n-    case Op_VectorCastF2X:\n-      \/\/ F2I is supported on all AVX and above platforms\n-      \/\/ For conversion to other integral types need AVX512:\n-      \/\/     Conversion to long in addition needs avx512dq\n-      \/\/     Need avx512vl for size_in_bits < 512\n-      if (is_integral_type(bt) && (bt != T_INT)) {\n-        if (UseAVX <= 2) {\n-          return false;\n-        }\n-        if ((bt == T_LONG) && !VM_Version::supports_avx512dq()) {\n-          return false;\n-        }\n-        if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n-          return false;\n-        }\n-      }\n-      break;\n@@ -3691,0 +3686,35 @@\n+instruct convF2HF_reg_reg(rRegI dst, regF src, regF tmp) %{\n+  effect(TEMP tmp);\n+  match(Set dst (ConvF2HF src));\n+  ins_cost(125);\n+  format %{ \"vcvtps2ph $dst,$src \\t using $tmp as TEMP\"%}\n+  ins_encode %{\n+    __ vcvtps2ph($tmp$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+    __ movdl($dst$$Register, $tmp$$XMMRegister);\n+    __ movswl($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct convF2HF_mem_reg(memory mem, regF src, kReg ktmp, rRegI rtmp) %{\n+  predicate((UseAVX > 2) && VM_Version::supports_avx512vl());\n+  effect(TEMP ktmp, TEMP rtmp);\n+  match(Set mem (StoreC mem (ConvF2HF src)));\n+  format %{ \"evcvtps2ph $mem,$src \\t using $ktmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    __ movl($rtmp$$Register, 0x1);\n+    __ kmovwl($ktmp$$KRegister, $rtmp$$Register);\n+    __ evcvtps2ph($mem$$Address, $ktmp$$KRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct convHF2F_reg_reg(regF dst, rRegI src) %{\n+  match(Set dst (ConvHF2F src));\n+  format %{ \"vcvtph2ps $dst,$src\" %}\n+  ins_encode %{\n+    __ movdl($dst$$XMMRegister, $src$$Register);\n+    __ vcvtph2ps($dst$$XMMRegister, $dst$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -5648,3 +5678,2 @@\n-instruct mulB_reg(vec dst, vec src1, vec src2, vec tmp) %{\n-  predicate(Matcher::vector_length(n) == 4 ||\n-            Matcher::vector_length(n) == 8);\n+instruct vmul8B(vec dst, vec src1, vec src2, vec xtmp) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 8);\n@@ -5652,2 +5681,2 @@\n-  effect(TEMP dst, TEMP tmp);\n-  format %{\"vector_mulB $dst,$src1,$src2\" %}\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"mulVB   $dst, $src1, $src2\\t! using $xtmp as TEMP\" %}\n@@ -5656,5 +5685,5 @@\n-    __ pmovsxbw($tmp$$XMMRegister, $src1$$XMMRegister);\n-    __ pmovsxbw($dst$$XMMRegister, $src2$$XMMRegister);\n-    __ pmullw($tmp$$XMMRegister, $dst$$XMMRegister);\n-    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n-    __ pand($dst$$XMMRegister, $tmp$$XMMRegister);\n+    __ pmovsxbw($dst$$XMMRegister, $src1$$XMMRegister);\n+    __ pmovsxbw($xtmp$$XMMRegister, $src2$$XMMRegister);\n+    __ pmullw($dst$$XMMRegister, $xtmp$$XMMRegister);\n+    __ psllw($dst$$XMMRegister, 8);\n+    __ psrlw($dst$$XMMRegister, 8);\n@@ -5666,2 +5695,2 @@\n-instruct mul16B_reg(vec dst, vec src1, vec src2, vec tmp1, vec tmp2) %{\n-  predicate(Matcher::vector_length(n) == 16 && UseAVX <= 1);\n+instruct vmulB(vec dst, vec src1, vec src2, vec xtmp) %{\n+  predicate(UseAVX == 0 && Matcher::vector_length_in_bytes(n) > 8);\n@@ -5669,2 +5698,2 @@\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n-  format %{\"vector_mulB $dst,$src1,$src2\" %}\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"mulVB   $dst, $src1, $src2\\t! using $xtmp as TEMP\" %}\n@@ -5673,18 +5702,20 @@\n-    __ pmovsxbw($tmp1$$XMMRegister, $src1$$XMMRegister);\n-    __ pmovsxbw($tmp2$$XMMRegister, $src2$$XMMRegister);\n-    __ pmullw($tmp1$$XMMRegister, $tmp2$$XMMRegister);\n-    __ pshufd($tmp2$$XMMRegister, $src1$$XMMRegister, 0xEE);\n-    __ pshufd($dst$$XMMRegister, $src2$$XMMRegister, 0xEE);\n-    __ pmovsxbw($tmp2$$XMMRegister, $tmp2$$XMMRegister);\n-    __ pmovsxbw($dst$$XMMRegister, $dst$$XMMRegister);\n-    __ pmullw($tmp2$$XMMRegister, $dst$$XMMRegister);\n-    __ movdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n-    __ pand($tmp2$$XMMRegister, $dst$$XMMRegister);\n-    __ pand($dst$$XMMRegister, $tmp1$$XMMRegister);\n-    __ packuswb($dst$$XMMRegister, $tmp2$$XMMRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vmul16B_reg_avx(vec dst, vec src1, vec src2, vec tmp) %{\n-  predicate(Matcher::vector_length(n) == 16 && UseAVX > 1);\n+    \/\/ Odd-index elements\n+    __ movdqu($dst$$XMMRegister, $src1$$XMMRegister);\n+    __ psrlw($dst$$XMMRegister, 8);\n+    __ movdqu($xtmp$$XMMRegister, $src2$$XMMRegister);\n+    __ psrlw($xtmp$$XMMRegister, 8);\n+    __ pmullw($dst$$XMMRegister, $xtmp$$XMMRegister);\n+    __ psllw($dst$$XMMRegister, 8);\n+    \/\/ Even-index elements\n+    __ movdqu($xtmp$$XMMRegister, $src1$$XMMRegister);\n+    __ pmullw($xtmp$$XMMRegister, $src2$$XMMRegister);\n+    __ psllw($xtmp$$XMMRegister, 8);\n+    __ psrlw($xtmp$$XMMRegister, 8);\n+    \/\/ Combine\n+    __ por($dst$$XMMRegister, $xtmp$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmulB_reg(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2) %{\n+  predicate(UseAVX > 0 && Matcher::vector_length_in_bytes(n) > 8);\n@@ -5692,20 +5723,2 @@\n-  effect(TEMP dst, TEMP tmp);\n-  format %{\"vector_mulB $dst,$src1,$src2\" %}\n-  ins_encode %{\n-  int vlen_enc = Assembler::AVX_256bit;\n-    __ vpmovsxbw($tmp$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($dst$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n-    __ vpmullw($tmp$$XMMRegister, $tmp$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n-    __ vpand($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister, vlen_enc);\n-    __ vextracti128_high($tmp$$XMMRegister, $dst$$XMMRegister);\n-    __ vpackuswb($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister, 0);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vmul32B_reg_avx(vec dst, vec src1, vec src2, vec tmp1, vec tmp2) %{\n-  predicate(Matcher::vector_length(n) == 32);\n-  match(Set dst (MulVB src1 src2));\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n-  format %{\"vector_mulB $dst,$src1,$src2\" %}\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vmulVB  $dst, $src1, $src2\\t! using $xtmp1, $xtmp2 as TEMP\" %}\n@@ -5713,43 +5726,12 @@\n-    assert(UseAVX > 1, \"required\");\n-    int vlen_enc = Assembler::AVX_256bit;\n-    __ vextracti128_high($tmp1$$XMMRegister, $src1$$XMMRegister);\n-    __ vextracti128_high($dst$$XMMRegister, $src2$$XMMRegister);\n-    __ vpmovsxbw($tmp1$$XMMRegister, $tmp1$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpmullw($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($tmp2$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($dst$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n-    __ vpmullw($tmp2$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n-    __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpand($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpand($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister, vlen_enc);\n-    __ vpackuswb($dst$$XMMRegister, $dst$$XMMRegister, $tmp1$$XMMRegister, vlen_enc);\n-    __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 0xD8, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct vmul64B_reg_avx(vec dst, vec src1, vec src2, vec tmp1, vec tmp2) %{\n-  predicate(Matcher::vector_length(n) == 64);\n-  match(Set dst (MulVB src1 src2));\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n-  format %{\"vector_mulB $dst,$src1,$src2\\n\\t\" %}\n-  ins_encode %{\n-    assert(UseAVX > 2, \"required\");\n-    int vlen_enc = Assembler::AVX_512bit;\n-    __ vextracti64x4_high($tmp1$$XMMRegister, $src1$$XMMRegister);\n-    __ vextracti64x4_high($dst$$XMMRegister, $src2$$XMMRegister);\n-    __ vpmovsxbw($tmp1$$XMMRegister, $tmp1$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpmullw($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($tmp2$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n-    __ vpmovsxbw($dst$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n-    __ vpmullw($tmp2$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vmovdqu($dst$$XMMRegister, ExternalAddress(vector_short_to_byte_mask()), noreg);\n-    __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpand($tmp1$$XMMRegister, $tmp1$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpand($tmp2$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    __ vpackuswb($dst$$XMMRegister, $tmp1$$XMMRegister, $tmp2$$XMMRegister, vlen_enc);\n-    __ evmovdquq($tmp2$$XMMRegister, ExternalAddress(vector_byte_perm_mask()), vlen_enc, noreg);\n-    __ vpermq($dst$$XMMRegister, $tmp2$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    int vlen_enc = vector_length_encoding(this);\n+    \/\/ Odd-index elements\n+    __ vpsrlw($xtmp2$$XMMRegister, $src1$$XMMRegister, 8, vlen_enc);\n+    __ vpsrlw($xtmp1$$XMMRegister, $src2$$XMMRegister, 8, vlen_enc);\n+    __ vpmullw($xtmp2$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n+    __ vpsllw($xtmp2$$XMMRegister, $xtmp2$$XMMRegister, 8, vlen_enc);\n+    \/\/ Even-index elements\n+    __ vpmullw($xtmp1$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+    __ vpsllw($xtmp1$$XMMRegister, $xtmp1$$XMMRegister, 8, vlen_enc);\n+    __ vpsrlw($xtmp1$$XMMRegister, $xtmp1$$XMMRegister, 8, vlen_enc);\n+    \/\/ Combine\n+    __ vpor($dst$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n@@ -5764,1 +5746,1 @@\n-  format %{ \"pmullw $dst,$src\\t! mul packedS\" %}\n+  format %{ \"pmullw  $dst,$src\\t! mul packedS\" %}\n@@ -5830,2 +5812,4 @@\n-instruct vmulL_reg(vec dst, vec src1, vec src2) %{\n-  predicate(VM_Version::supports_avx512dq());\n+instruct evmulL_reg(vec dst, vec src1, vec src2) %{\n+  predicate((Matcher::vector_length_in_bytes(n) == 64 &&\n+             VM_Version::supports_avx512dq()) ||\n+            VM_Version::supports_avx512vldq());\n@@ -5833,1 +5817,1 @@\n-  format %{ \"vpmullq $dst,$src1,$src2\\t! mul packedL\" %}\n+  format %{ \"evpmullq $dst,$src1,$src2\\t! mul packedL\" %}\n@@ -5837,1 +5821,1 @@\n-    __ vpmullq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+    __ evpmullq($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n@@ -5842,3 +5826,5 @@\n-instruct vmulL_mem(vec dst, vec src, memory mem) %{\n-  predicate(VM_Version::supports_avx512dq() &&\n-              (Matcher::vector_length_in_bytes(n->in(1)) > 8));\n+instruct evmulL_mem(vec dst, vec src, memory mem) %{\n+  predicate((Matcher::vector_length_in_bytes(n) == 64 &&\n+             VM_Version::supports_avx512dq()) ||\n+            (Matcher::vector_length_in_bytes(n) > 8 &&\n+             VM_Version::supports_avx512vldq()));\n@@ -5846,1 +5832,1 @@\n-  format %{ \"vpmullq $dst,$src,$mem\\t! mul packedL\" %}\n+  format %{ \"evpmullq $dst,$src,$mem\\t! mul packedL\" %}\n@@ -5850,1 +5836,1 @@\n-    __ vpmullq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vlen_enc);\n+    __ evpmullq($dst$$XMMRegister, $src$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -5855,12 +5841,5 @@\n-instruct mul2L_reg(vec dst, vec src2, legVec tmp) %{\n-  predicate(Matcher::vector_length(n) == 2 && !VM_Version::supports_avx512dq());\n-  match(Set dst (MulVL dst src2));\n-  effect(TEMP dst, TEMP tmp);\n-  format %{ \"pshufd $tmp,$src2, 177\\n\\t\"\n-            \"pmulld $tmp,$dst\\n\\t\"\n-            \"phaddd $tmp,$tmp\\n\\t\"\n-            \"pmovzxdq $tmp,$tmp\\n\\t\"\n-            \"psllq $tmp, 32\\n\\t\"\n-            \"pmuludq $dst,$src2\\n\\t\"\n-            \"paddq $dst,$tmp\\n\\t! mul packed2L\" %}\n-\n+instruct vmulL(vec dst, vec src1, vec src2, vec xtmp) %{\n+  predicate(UseAVX == 0);\n+  match(Set dst (MulVL src1 src2));\n+  effect(TEMP dst, TEMP xtmp);\n+  format %{ \"mulVL   $dst, $src1, $src2\\t! using $xtmp as TEMP\" %}\n@@ -5869,8 +5848,10 @@\n-    int vlen_enc = Assembler::AVX_128bit;\n-    __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 177);\n-    __ pmulld($tmp$$XMMRegister, $dst$$XMMRegister);\n-    __ phaddd($tmp$$XMMRegister, $tmp$$XMMRegister);\n-    __ pmovzxdq($tmp$$XMMRegister, $tmp$$XMMRegister);\n-    __ psllq($tmp$$XMMRegister, 32);\n-    __ pmuludq($dst$$XMMRegister, $src2$$XMMRegister);\n-    __ paddq($dst$$XMMRegister, $tmp$$XMMRegister);\n+    \/\/ Get the lo-hi products, only the lower 32 bits is in concerns\n+    __ pshufd($xtmp$$XMMRegister, $src2$$XMMRegister, 0xB1);\n+    __ pmulld($xtmp$$XMMRegister, $src1$$XMMRegister);\n+    __ pshufd($dst$$XMMRegister, $xtmp$$XMMRegister, 0xB1);\n+    __ paddd($dst$$XMMRegister, $xtmp$$XMMRegister);\n+    __ psllq($dst$$XMMRegister, 32);\n+    \/\/ Get the lo-lo products\n+    __ movdqu($xtmp$$XMMRegister, $src1$$XMMRegister);\n+    __ pmuludq($xtmp$$XMMRegister, $src2$$XMMRegister);\n+    __ paddq($dst$$XMMRegister, $xtmp$$XMMRegister);\n@@ -5881,2 +5862,6 @@\n-instruct vmul4L_reg_avx(vec dst, vec src1, vec src2, legVec tmp, legVec tmp1) %{\n-  predicate(Matcher::vector_length(n) == 4 && !VM_Version::supports_avx512dq());\n+instruct vmulL_reg(vec dst, vec src1, vec src2, vec xtmp1, vec xtmp2) %{\n+  predicate(UseAVX > 0 &&\n+            ((Matcher::vector_length_in_bytes(n) == 64 &&\n+              !VM_Version::supports_avx512dq()) ||\n+             (Matcher::vector_length_in_bytes(n) < 64 &&\n+              !VM_Version::supports_avx512vldq())));\n@@ -5884,8 +5869,2 @@\n-  effect(TEMP tmp1, TEMP tmp);\n-  format %{ \"vpshufd $tmp,$src2\\n\\t\"\n-            \"vpmulld $tmp,$src1,$tmp\\n\\t\"\n-            \"vphaddd $tmp,$tmp,$tmp\\n\\t\"\n-            \"vpmovzxdq $tmp,$tmp\\n\\t\"\n-            \"vpsllq $tmp,$tmp\\n\\t\"\n-            \"vpmuludq $tmp1,$src1,$src2\\n\\t\"\n-            \"vpaddq $dst,$tmp,$tmp1\\t! mul packed4L\" %}\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vmulVL  $dst, $src1, $src2\\t! using $xtmp1, $xtmp2 as TEMP\" %}\n@@ -5893,9 +5872,10 @@\n-    int vlen_enc = Assembler::AVX_256bit;\n-    __ vpshufd($tmp$$XMMRegister, $src2$$XMMRegister, 177, vlen_enc);\n-    __ vpmulld($tmp$$XMMRegister, $src1$$XMMRegister, $tmp$$XMMRegister, vlen_enc);\n-    __ vextracti128_high($tmp1$$XMMRegister, $tmp$$XMMRegister);\n-    __ vphaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp1$$XMMRegister, vlen_enc);\n-    __ vpmovzxdq($tmp$$XMMRegister, $tmp$$XMMRegister, vlen_enc);\n-    __ vpsllq($tmp$$XMMRegister, $tmp$$XMMRegister, 32, vlen_enc);\n-    __ vpmuludq($tmp1$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n-    __ vpaddq($dst$$XMMRegister, $tmp$$XMMRegister, $tmp1$$XMMRegister, vlen_enc);\n+    int vlen_enc = vector_length_encoding(this);\n+    \/\/ Get the lo-hi products, only the lower 32 bits is in concerns\n+    __ vpshufd($xtmp1$$XMMRegister, $src2$$XMMRegister, 0xB1, vlen_enc);\n+    __ vpmulld($xtmp1$$XMMRegister, $src1$$XMMRegister, $xtmp1$$XMMRegister, vlen_enc);\n+    __ vpshufd($xtmp2$$XMMRegister, $xtmp1$$XMMRegister, 0xB1, vlen_enc);\n+    __ vpaddd($xtmp2$$XMMRegister, $xtmp2$$XMMRegister, $xtmp1$$XMMRegister, vlen_enc);\n+    __ vpsllq($xtmp2$$XMMRegister, $xtmp2$$XMMRegister, 32, vlen_enc);\n+    \/\/ Get the lo-lo products\n+    __ vpmuludq($xtmp1$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+    __ vpaddq($dst$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, vlen_enc);\n@@ -7374,6 +7354,3 @@\n-instruct castFtoI_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rFlagsReg cr) %{\n-  \/\/ F2I conversion for < 64 byte vector using AVX instructions\n-  \/\/ AVX512 platforms that dont support avx512vl also use AVX instructions to support F2I\n-  predicate(!VM_Version::supports_avx512vl() &&\n-            Matcher::vector_length_in_bytes(n) < 64 &&\n-            Matcher::vector_element_basic_type(n) == T_INT);\n+instruct castFtoX_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 4);\n@@ -7382,17 +7359,1 @@\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3, $xtmp4 as TEMP\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_castF2I_avx($dst$$XMMRegister, $src$$XMMRegister,\n-                          ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n-                          $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct castFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n-  predicate((VM_Version::supports_avx512vl() ||\n-             Matcher::vector_length_in_bytes(n) == 64) &&\n-             Matcher::vector_element_basic_type(n) == T_INT);\n-  match(Set dst (VectorCastF2X src));\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, KILL cr);\n-  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n+  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n@@ -7400,4 +7361,12 @@\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister,\n-                           ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n-                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    \/\/ JDK-8292878 removed the need for an explicit scratch register needed to load greater than\n+    \/\/ 32 bit addresses for register indirect addressing mode since stub constants\n+    \/\/ are part of code cache and there is a cap of 2G on ReservedCodeCacheSize currently.\n+    \/\/ However, targets are free to increase this limit, but having a large code cache size\n+    \/\/ greater than 2G looks unreasonable in practical scenario, on the hind side with given\n+    \/\/ cap we save a temporary register allocation which in limiting case can prevent\n+    \/\/ spilling in high register pressure blocks.\n+    __ vector_castF2X_avx(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                          $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister,\n+                          ExternalAddress(vector_float_signflip()), noreg, vlen_enc);\n@@ -7409,4 +7378,2 @@\n-  \/\/ F2X conversion for integral non T_INT target using AVX512 instructions\n-  \/\/ Platforms that dont support avx512vl can only support 64 byte vectors\n-  predicate(is_integral_type(Matcher::vector_element_basic_type(n)) &&\n-            Matcher::vector_element_basic_type(n) != T_INT);\n+  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7415,1 +7382,1 @@\n-  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n+  format %{ \"vector_cast_f2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n@@ -7420,3 +7387,3 @@\n-      __ vector_castF2L_evex($dst$$XMMRegister, $src$$XMMRegister,\n-                             ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vlen_enc,\n-                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+      __ vector_castF2L_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                             ExternalAddress(vector_double_signflip()), noreg, vlen_enc);\n@@ -7425,9 +7392,3 @@\n-      __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister,\n-                             ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vlen_enc,\n-                             $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n-      if (to_elem_bt == T_SHORT) {\n-        __ evpmovdw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-      } else {\n-        assert(to_elem_bt == T_BYTE, \"required\");\n-        __ evpmovdb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-      }\n+      __ vector_castF2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                             ExternalAddress(vector_float_signflip()), noreg, vlen_enc);\n@@ -7450,0 +7411,16 @@\n+instruct castDtoX_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, vec xtmp5, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64 &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, TEMP xtmp5, KILL cr);\n+  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3, $xtmp4 and $xtmp5 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_castD2X_avx(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                          $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister, $xtmp5$$XMMRegister,\n+                          ExternalAddress(vector_float_signflip()), noreg, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7451,1 +7428,2 @@\n-  predicate(is_integral_type(Matcher::vector_element_basic_type(n)));\n+  predicate((VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n->in(1)) == 64) &&\n+            is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -7454,1 +7432,1 @@\n-  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1, $ktmp2 as TEMP\" %}\n+  format %{ \"vector_cast_d2x $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n@@ -7458,3 +7436,4 @@\n-    __ vector_castD2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister,\n-                           ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vlen_enc,\n-                           $xtmp1$$XMMRegister, $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    AddressLiteral signflip = VM_Version::supports_avx512dq() ? ExternalAddress(vector_double_signflip()) :\n+                              ExternalAddress(vector_float_signflip());\n+    __ vector_castD2X_evex(to_elem_bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                           $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister, signflip, noreg, vlen_enc);\n@@ -8424,1 +8403,0 @@\n-  predicate(Matcher::vector_length(n) == Matcher::vector_length(n->in(1)));\n@@ -8435,2 +8413,1 @@\n-  predicate((Matcher::vector_length(n) == Matcher::vector_length(n->in(1))) &&\n-            (Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1))));\n+  predicate(Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n@@ -8446,0 +8423,13 @@\n+instruct vmaskcast_avx(vec dst, vec src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vector_mask_cast $dst, $src\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_mask_cast($dst$$XMMRegister, $src$$XMMRegister, dst_bt, src_bt, vlen);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -8449,1 +8439,0 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n@@ -8454,1 +8443,2 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes);\n+     BasicType bt = Matcher::vector_element_basic_type(this);\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, bt);\n@@ -8466,1 +8456,1 @@\n-     int vlen = Matcher::vector_length(this);\n+     int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -8470,4 +8460,1 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen);\n-     if (elem_bt != T_BYTE) {\n-       __ vconvert_b2x(elem_bt, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-     }\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, elem_bt);\n@@ -8485,1 +8472,1 @@\n-     int vlen = Matcher::vector_length(this);\n+     int vlen_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -8489,4 +8476,1 @@\n-     __ load_iota_indices($dst$$XMMRegister, vlen);\n-     if (elem_bt != T_BYTE) {\n-       __ vconvert_b2x(elem_bt, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-     }\n+     __ load_iota_indices($dst$$XMMRegister, vlen_in_bytes, elem_bt);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":218,"deletions":234,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -657,2 +657,2 @@\n-    st->print(\"CMPL     rsp, poll_offset[thread]  \\n\\t\"\n-              \"JA       #safepoint_stub\\t\"\n+    st->print(\"CMPL    rsp, poll_offset[thread]  \\n\\t\"\n+              \"JA      #safepoint_stub\\t\"\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -322,0 +322,8 @@\n+\n+source_hpp %{\n+\n+#include \"peephole_x86_64.hpp\"\n+\n+%}\n+\n+\/\/ Register masks\n@@ -953,2 +961,2 @@\n-    st->print_cr(\"cmpq     rsp, poll_offset[r15_thread] \\n\\t\"\n-                 \"ja       #safepoint_stub\\t\"\n+    st->print_cr(\"cmpq    rsp, poll_offset[r15_thread] \\n\\t\"\n+                 \"ja      #safepoint_stub\\t\"\n@@ -9038,0 +9046,13 @@\n+\/\/ Shift Left by one, two, three\n+instruct salI_rReg_immI2(rRegI dst, immI2 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (LShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sall    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sall($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9272,0 +9293,13 @@\n+\/\/ Shift Left by one, two, three\n+instruct salL_rReg_immI2(rRegL dst, immI2 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (LShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"salq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ salq($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -13806,0 +13840,3 @@\n+\/\/ peeppredicate ( rule_predicate );\n+\/\/ \/\/ the predicate unless which the peephole rule will be ignored\n+\/\/\n@@ -13808,0 +13845,10 @@\n+\/\/ peepprocedure ( procedure_name );\n+\/\/ \/\/ provide a procedure name to perform the optimization, the procedure should\n+\/\/ \/\/ reside in the architecture dependent peephole file, the method has the\n+\/\/ \/\/ signature of MachNode* (Block*, int, PhaseRegAlloc*, (MachNode*)(*)(), int...)\n+\/\/ \/\/ with the arguments being the basic block, the current node index inside the\n+\/\/ \/\/ block, the register allocator, the functions upon invoked return a new node\n+\/\/ \/\/ defined in peepreplace, and the rules of the nodes appearing in the\n+\/\/ \/\/ corresponding peepmatch, the function return true if successful, else\n+\/\/ \/\/ return false\n+\/\/\n@@ -13828,4 +13875,1 @@\n-\/\/ Only match adjacent instructions in same basic block\n-\/\/ Only equality constraints\n-\/\/ Only constraints between operands, not (0.dest_reg == RAX_enc)\n-\/\/ Only one replacement instruction\n+\/\/ Only transformations inside a basic block (do we need more for peephole)\n@@ -13847,0 +13891,11 @@\n+\/\/ instruct leaI_rReg_immI(rRegI dst, immI_1 src)\n+\/\/ %{\n+\/\/   match(Set dst (AddI dst src));\n+\/\/ %}\n+\/\/\n+\/\/ 1. Simple replacement\n+\/\/ - Only match adjacent instructions in same basic block\n+\/\/ - Only equality constraints\n+\/\/ - Only constraints between operands, not (0.dest_reg == RAX_enc)\n+\/\/ - Only one replacement instruction\n+\/\/\n@@ -13849,0 +13904,2 @@\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n@@ -13859,3 +13916,6 @@\n-\n-\/\/ Implementation no longer uses movX instructions since\n-\/\/ machine-independent system no longer uses CopyX nodes.\n+\/\/ 2. Procedural replacement\n+\/\/ - More flexible finding relevent nodes\n+\/\/ - More flexible constraints\n+\/\/ - More flexible transformations\n+\/\/ - May utilise architecture-dependent API more effectively\n+\/\/ - Currently only one replacement instruction due to adlc parsing capabilities\n@@ -13863,5 +13923,11 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (incI_rReg movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n+\/\/ \/\/ Change (inc mov) to lea\n+\/\/ peephole %{\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n+\/\/   \/\/ the rule numbers of these nodes inside are passed into the function below\n+\/\/   peepmatch ( incI_rReg movI );\n+\/\/   \/\/ the method that takes the responsibility of transformation\n+\/\/   peepprocedure ( inc_mov_to_lea );\n+\/\/   \/\/ the replacement is a leaI_rReg_immI, a lambda upon invoked creating this\n+\/\/   \/\/ node is passed into the function above\n+\/\/   peepreplace ( leaI_rReg_immI() );\n@@ -13870,6 +13936,19 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (decI_rReg movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n-\/\/ %}\n+\/\/ These instructions is not matched by the matcher but used by the peephole\n+instruct leaI_rReg_rReg_peep(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leal(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leal(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13877,6 +13956,10 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addI_rReg_imm movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaI_rReg_immI_peep(rRegI dst, rRegI src1, immI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leal($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13884,6 +13967,16 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (incL_rReg movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaI_rReg_immI2_peep(rRegI dst, rRegI src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftI src shift));\n+  format %{ \"leal    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leal($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leal($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13891,6 +13984,18 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (decL_rReg movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_rReg_peep(rRegL dst, rRegL src1, rRegL src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leaq(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leaq(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13898,6 +14003,10 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addL_rReg_imm movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_immL32_peep(rRegL dst, rRegL src1, immL32 src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13905,6 +14014,16 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addP_rReg_imm movP);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_immI2_peep(rRegL dst, rRegL src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftL src shift));\n+  format %{ \"leaq    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leaq($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leaq($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13912,11 +14031,63 @@\n-\/\/ \/\/ Change load of spilled value to only a spill\n-\/\/ instruct storeI(memory mem, rRegI src)\n-\/\/ %{\n-\/\/   match(Set mem (StoreI mem src));\n-\/\/ %}\n-\/\/\n-\/\/ instruct loadI(rRegI dst, memory mem)\n-\/\/ %{\n-\/\/   match(Set dst (LoadI mem));\n-\/\/ %}\n-\/\/\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaI_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (incI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (decI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salI_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI2_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaL_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (incL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n@@ -13926,3 +14097,4 @@\n-  peepmatch (loadI storeI);\n-  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);\n-  peepreplace (storeI(1.mem 1.mem 1.src));\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (decL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n@@ -13933,3 +14105,4 @@\n-  peepmatch (loadL storeL);\n-  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);\n-  peepreplace (storeL(1.mem 1.mem 1.src));\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salL_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immI2_peep());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":240,"deletions":67,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -89,1 +89,5 @@\n-          \"Use fast method entry code for accessor methods\")\n+          \"Use fast method entry code for accessor methods\")                \\\n+                                                                            \\\n+  product(bool, DecodeErrorContext, false, DIAGNOSTIC,                      \\\n+          \"Try to decode the architecture-specific context for better \"     \\\n+          \"diagnostics\")\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+  static void assert_is_rfp(VMReg r) NOT_DEBUG_RETURN\n","filename":"src\/hotspot\/cpu\/zero\/smallRegisterMap_zero.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,0 +119,11 @@\n+  \/\/ Enable error context decoding on known platforms\n+#if defined(IA32) || defined(AMD64) || defined(ARM) || \\\n+    defined(AARCH64) || defined(PPC) || defined(RISCV) || \\\n+    defined(S390)\n+  if (FLAG_IS_DEFAULT(DecodeErrorContext)) {\n+    FLAG_SET_DEFAULT(DecodeErrorContext, true);\n+  }\n+#else\n+  UNSUPPORTED_OPTION(DecodeErrorContext);\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -947,1 +947,0 @@\n-\/\/ ported from solaris version\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1375,44 +1375,0 @@\n-struct _address_to_library_name {\n-  address addr;          \/\/ input : memory address\n-  size_t  buflen;        \/\/         size of fname\n-  char*   fname;         \/\/ output: library name\n-  address base;          \/\/         library base addr\n-};\n-\n-static int address_to_library_name_callback(struct dl_phdr_info *info,\n-                                            size_t size, void *data) {\n-  int i;\n-  bool found = false;\n-  address libbase = NULL;\n-  struct _address_to_library_name * d = (struct _address_to_library_name *)data;\n-\n-  \/\/ iterate through all loadable segments\n-  for (i = 0; i < info->dlpi_phnum; i++) {\n-    address segbase = (address)(info->dlpi_addr + info->dlpi_phdr[i].p_vaddr);\n-    if (info->dlpi_phdr[i].p_type == PT_LOAD) {\n-      \/\/ base address of a library is the lowest address of its loaded\n-      \/\/ segments.\n-      if (libbase == NULL || libbase > segbase) {\n-        libbase = segbase;\n-      }\n-      \/\/ see if 'addr' is within current segment\n-      if (segbase <= d->addr &&\n-          d->addr < segbase + info->dlpi_phdr[i].p_memsz) {\n-        found = true;\n-      }\n-    }\n-  }\n-\n-  \/\/ dlpi_name is NULL or empty if the ELF file is executable, return 0\n-  \/\/ so dll_address_to_library_name() can fall through to use dladdr() which\n-  \/\/ can figure out executable name from argv[0].\n-  if (found && info->dlpi_name && info->dlpi_name[0]) {\n-    d->base = libbase;\n-    if (d->fname) {\n-      jio_snprintf(d->fname, d->buflen, \"%s\", info->dlpi_name);\n-    }\n-    return 1;\n-  }\n-  return 0;\n-}\n-\n@@ -1422,1 +1378,1 @@\n-  assert(buf != NULL, \"sanity check\");\n+  assert(buf != nullptr, \"sanity check\");\n@@ -1425,18 +1381,0 @@\n-  struct _address_to_library_name data;\n-\n-  \/\/ There is a bug in old glibc dladdr() implementation that it could resolve\n-  \/\/ to wrong library name if the .so file has a base address != NULL. Here\n-  \/\/ we iterate through the program headers of all loaded libraries to find\n-  \/\/ out which library 'addr' really belongs to. This workaround can be\n-  \/\/ removed once the minimum requirement for glibc is moved to 2.3.x.\n-  data.addr = addr;\n-  data.fname = buf;\n-  data.buflen = buflen;\n-  data.base = NULL;\n-  int rslt = dl_iterate_phdr(address_to_library_name_callback, (void *)&data);\n-\n-  if (rslt) {\n-    \/\/ buf already contains library name\n-    if (offset) *offset = addr - data.base;\n-    return true;\n-  }\n@@ -1444,1 +1382,1 @@\n-    if (dlinfo.dli_fname != NULL) {\n+    if (dlinfo.dli_fname != nullptr) {\n@@ -1447,1 +1385,1 @@\n-    if (dlinfo.dli_fbase != NULL && offset != NULL) {\n+    if (dlinfo.dli_fbase != nullptr && offset != nullptr) {\n@@ -1452,1 +1390,0 @@\n-\n@@ -1458,5 +1395,0 @@\n-\/\/ Loads .dll\/.so and\n-\/\/ in case of error it checks if .dll\/.so was built for the\n-\/\/ same architecture as Hotspot is running on\n-\n-\n@@ -2377,1 +2309,1 @@\n-static void print_sys_devices_cpu_info(outputStream* st, char* buf, size_t buflen) {\n+static void print_sys_devices_cpu_info(outputStream* st) {\n@@ -2430,1 +2362,1 @@\n-  print_sys_devices_cpu_info(st, buf, buflen);\n+  print_sys_devices_cpu_info(st);\n@@ -4311,1 +4243,1 @@\n-  void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+  void* p = ::mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n@@ -4317,1 +4249,1 @@\n-  int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);\n+  int res = ::mprotect(p, size, PROT_READ|PROT_WRITE|PROT_EXEC);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":7,"deletions":75,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+  #elif defined(ALPHA)\n+  #define SYS_membarrier 517\n","filename":"src\/hotspot\/os\/linux\/systemMemoryBarrier_linux.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -605,6 +605,0 @@\n-    } else if (ZERO_ONLY(true) NOT_ZERO(false)) {\n-      \/\/ Non-arch-specific Zero code does not really know the pc.\n-      \/\/ This can be alleviated by making arch-specific os::Posix::ucontext_get_pc\n-      \/\/ available for Zero for known architectures. But for generic Zero\n-      \/\/ code, it would still remain unknown.\n-      pc = NULL;\n@@ -667,6 +661,1 @@\n-    \/\/ For Zero, we ignore the crash context, because:\n-    \/\/  a) The crash would be in C++ interpreter code, so context is not really relevant;\n-    \/\/  b) Generic Zero code would not be able to parse it, so when generic error\n-    \/\/     reporting code asks e.g. about frames on stack, Zero would experience\n-    \/\/     a secondary ShouldNotCallThis() crash.\n-    VMError::report_and_die(t, sig, pc, info, NOT_ZERO(ucVoid) ZERO_ONLY(NULL));\n+    VMError::report_and_die(t, sig, pc, info, ucVoid);\n@@ -798,1 +787,1 @@\n-static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context);\n+static void SR_handler(int sig, siginfo_t* siginfo, void* ucVoid);\n@@ -1600,2 +1589,2 @@\n-static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {\n-  osthread->set_ucontext(context);\n+static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, void* ucVoid) {\n+  osthread->set_ucontext((ucontext_t*)ucVoid);\n@@ -1618,1 +1607,1 @@\n-static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n+static void SR_handler(int sig, siginfo_t* siginfo, void* ucVoid) {\n@@ -1661,1 +1650,1 @@\n-    suspend_save_context(osthread, siginfo, context);\n+    suspend_save_context(osthread, siginfo, ucVoid);\n@@ -1727,1 +1716,1 @@\n-  act.sa_handler = (void (*)(int)) SR_handler;\n+  act.sa_sigaction = SR_handler;\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1702,1 +1702,0 @@\n-#if _MSC_VER >= 1900\n@@ -1711,23 +1710,0 @@\n-#else\n-  \/\/ Before Visual Studio 2015, vsnprintf is not C99 compliant, so use\n-  \/\/ _vsnprintf, whose behavior seems to be *mostly* consistent across\n-  \/\/ versions.  However, when len == 0, avoid _vsnprintf too, and just\n-  \/\/ go straight to _vscprintf.  The output is going to be truncated in\n-  \/\/ that case, except in the unusual case of empty output.  More\n-  \/\/ importantly, the documentation for various versions of Visual Studio\n-  \/\/ are inconsistent about the behavior of _vsnprintf when len == 0,\n-  \/\/ including it possibly being an error.\n-  int result = -1;\n-  if (len > 0) {\n-    result = _vsnprintf(buf, len, fmt, args);\n-    \/\/ If output (including NUL terminator) is truncated, the buffer\n-    \/\/ won't be NUL terminated.  Add the trailing NUL specified by C99.\n-    if ((result < 0) || ((size_t)result >= len)) {\n-      buf[len - 1] = '\\0';\n-    }\n-  }\n-  if (result < 0) {\n-    result = _vscprintf(fmt, args);\n-  }\n-  return result;\n-#endif \/\/ _MSC_VER dispatch\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -148,0 +148,6 @@\n+  if (!is_readable_pointer(epc)) {\n+    \/\/ Try to recover from calling into bad memory\n+    \/\/ Assume new frame has not been set up, the same as\n+    \/\/ compiled frame stack bang\n+    return fetch_compiled_frame_from_context(ucVoid);\n+  }\n@@ -360,2 +366,2 @@\n-  address pc = os::Posix::ucontext_get_pc(uc);\n-  print_instructions(st, pc, UseRVC ? sizeof(char) : 4\/*non-compressed native instruction size*\/);\n+  address pc = os::fetch_frame_from_context(uc).pc();\n+  print_instructions(st, pc, UseRVC ? sizeof(char) : (int)NativeInstruction::instruction_size);\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -90,2 +90,24 @@\n-  ShouldNotCallThis();\n-  return NULL; \/\/ silence compile warnings\n+  if (DecodeErrorContext) {\n+#if defined(IA32)\n+    return (address)uc->uc_mcontext.gregs[REG_EIP];\n+#elif defined(AMD64)\n+    return (address)uc->uc_mcontext.gregs[REG_RIP];\n+#elif defined(ARM)\n+    return (address)uc->uc_mcontext.arm_pc;\n+#elif defined(AARCH64)\n+    return (address)uc->uc_mcontext.pc;\n+#elif defined(PPC)\n+    return (address)uc->uc_mcontext.regs->nip;\n+#elif defined(RISCV)\n+    return (address)uc->uc_mcontext.__gregs[REG_PC];\n+#elif defined(S390)\n+    return (address)uc->uc_mcontext.psw.addr;\n+#else\n+    \/\/ Non-arch-specific Zero code does not really know the PC.\n+    \/\/ If possible, add the arch-specific definition in this method.\n+    fatal(\"Cannot handle ucontext_get_pc\");\n+#endif\n+  }\n+\n+  \/\/ Answer the default and hope for the best\n+  return nullptr;\n@@ -94,1 +116,1 @@\n-void os::Posix::ucontext_set_pc(ucontext_t * uc, address pc) {\n+void os::Posix::ucontext_set_pc(ucontext_t* uc, address pc) {\n@@ -98,0 +120,54 @@\n+intptr_t* os::Linux::ucontext_get_sp(const ucontext_t* uc) {\n+  if (DecodeErrorContext) {\n+#if defined(IA32)\n+    return (intptr_t*)uc->uc_mcontext.gregs[REG_UESP];\n+#elif defined(AMD64)\n+    return (intptr_t*)uc->uc_mcontext.gregs[REG_RSP];\n+#elif defined(ARM)\n+    return (intptr_t*)uc->uc_mcontext.arm_sp;\n+#elif defined(AARCH64)\n+    return (intptr_t*)uc->uc_mcontext.sp;\n+#elif defined(PPC)\n+    return (intptr_t*)uc->uc_mcontext.regs->gpr[1\/*REG_SP*\/];\n+#elif defined(RISCV)\n+    return (intptr_t*)uc->uc_mcontext.__gregs[REG_SP];\n+#elif defined(S390)\n+    return (intptr_t*)uc->uc_mcontext.gregs[15\/*REG_SP*\/];\n+#else\n+    \/\/ Non-arch-specific Zero code does not really know the SP.\n+    \/\/ If possible, add the arch-specific definition in this method.\n+    fatal(\"Cannot handle ucontext_get_sp\");\n+#endif\n+  }\n+\n+  \/\/ Answer the default and hope for the best\n+  return nullptr;\n+}\n+\n+intptr_t* os::Linux::ucontext_get_fp(const ucontext_t* uc) {\n+  if (DecodeErrorContext) {\n+#if defined(IA32)\n+    return (intptr_t*)uc->uc_mcontext.gregs[REG_EBP];\n+#elif defined(AMD64)\n+    return (intptr_t*)uc->uc_mcontext.gregs[REG_RBP];\n+#elif defined(ARM)\n+    return (intptr_t*)uc->uc_mcontext.arm_fp;\n+#elif defined(AARCH64)\n+    return (intptr_t*)uc->uc_mcontext.regs[29 \/* REG_FP *\/];\n+#elif defined(PPC)\n+    return nullptr;\n+#elif defined(RISCV)\n+    return (intptr_t*)uc->uc_mcontext.__gregs[8 \/* REG_FP *\/];\n+#elif defined(S390)\n+    return nullptr;\n+#else\n+    \/\/ Non-arch-specific Zero code does not really know the FP.\n+    \/\/ If possible, add the arch-specific definition in this method.\n+    fatal(\"Cannot handle ucontext_get_fp\");\n+#endif\n+  }\n+\n+  \/\/ Answer the default and hope for the best\n+  return nullptr;\n+}\n+\n@@ -101,2 +177,22 @@\n-  ShouldNotCallThis();\n-  return NULL; \/\/ silence compile warnings\n+  address epc;\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+\n+  if (uc != NULL) {\n+    epc = os::Posix::ucontext_get_pc(uc);\n+    if (ret_sp) {\n+      *ret_sp = (intptr_t*) os::Linux::ucontext_get_sp(uc);\n+    }\n+    if (ret_fp) {\n+      *ret_fp = (intptr_t*) os::Linux::ucontext_get_fp(uc);\n+    }\n+  } else {\n+    epc = NULL;\n+    if (ret_sp) {\n+      *ret_sp = nullptr;\n+    }\n+    if (ret_fp) {\n+      *ret_fp = nullptr;\n+    }\n+  }\n+\n+  return epc;\n@@ -106,2 +202,12 @@\n-  ShouldNotCallThis();\n-  return frame(NULL, NULL); \/\/ silence compile warnings\n+  \/\/ This code is only called from error handler to get PC and SP.\n+  \/\/ We don't have the ready ZeroFrame* at this point, so fake the\n+  \/\/ frame with bare minimum.\n+  if (ucVoid != NULL) {\n+    const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+    frame dummy = frame();\n+    dummy.set_pc(os::Posix::ucontext_get_pc(uc));\n+    dummy.set_sp((intptr_t*)os::Linux::ucontext_get_sp(uc));\n+    return dummy;\n+  } else {\n+    return frame(nullptr, nullptr);\n+  }\n@@ -291,2 +397,2 @@\n-void os::print_context(outputStream* st, const void* context) {\n-  ShouldNotCallThis();\n+void os::print_context(outputStream* st, const void* ucVoid) {\n+  st->print_cr(\"No context information.\");\n@@ -295,2 +401,13 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  ShouldNotCallThis();\n+void os::print_tos_pc(outputStream *st, const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+\n+  address sp = (address)os::Linux::ucontext_get_sp(uc);\n+  print_tos(st, sp);\n+  st->cr();\n+\n+  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n+  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n+  \/\/ this at the end, and hope for the best.\n+  address pc = os::Posix::ucontext_get_pc(uc);\n+  print_instructions(st, pc, sizeof(char));\n+  st->cr();\n@@ -299,2 +416,2 @@\n-void os::print_register_info(outputStream *st, const void *context) {\n-  ShouldNotCallThis();\n+void os::print_register_info(outputStream *st, const void* ucVoid) {\n+  st->print_cr(\"No register info.\");\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":130,"deletions":13,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -49,4 +49,0 @@\n-#if _MSC_VER < 1900\n-#define snprintf _snprintf\n-#endif\n-\n","filename":"src\/hotspot\/share\/adlc\/adlc.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2049,1 +2049,3 @@\n-      if (strcmp(token,\"peepmatch\")==0) {\n+      if (strcmp(token,\"peeppredicate\")==0) {\n+        peep_predicate_parse(*peep); }\n+      else if (strcmp(token,\"peepmatch\")==0) {\n@@ -2051,0 +2053,2 @@\n+      else if (strcmp(token, \"peepprocedure\")==0) {\n+        peep_procedure_parse(*peep); }\n@@ -2056,1 +2060,3 @@\n-        parse_err(SYNERR, \"expected peepmatch, peepconstraint, or peepreplace for identifier %s.\\n\", token);\n+        parse_err(SYNERR,\n+            \"expected peeppreddicate, peepmatch, peepprocedure, peepconstraint, peepreplace, received %s.\\n\",\n+            token);\n@@ -2540,0 +2546,25 @@\n+\/\/---------------------------peep-predicate-parse------------------------------\n+\/\/ Syntax for a peeppredicate rule\n+\/\/\n+\/\/ peeppredicate ( predicate );\n+\/\/\n+void ADLParser::peep_predicate_parse(Peephole& peep) {\n+\n+  skipws();\n+  char* rule = nullptr;\n+  if ( (rule = get_paren_expr(\"pred expression\", true)) == nullptr ) {\n+    parse_err(SYNERR, \"incorrect or missing expression for 'peeppredicate'\\n\");\n+    return;\n+  }\n+  if (_curchar != ';') {\n+    parse_err(SYNERR, \"missing ';' in peeppredicate definition\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip ';'\n+  skipws();\n+\n+  \/\/ Construct PeepPredicate\n+  PeepPredicate* predicate = new PeepPredicate(rule);\n+  peep.add_predicate(predicate);\n+}\n+\n@@ -2586,0 +2617,40 @@\n+\/\/---------------------------peep-procedure-parse------------------------------\n+\/\/ Syntax for a peepprocedure rule\n+\/\/\n+\/\/ peeppredicate ( function_name );\n+\/\/\n+void ADLParser::peep_procedure_parse(Peephole& peep) {\n+\n+  skipws();\n+  \/\/ Check for open paren\n+  if (_curchar != '(') {\n+    parse_err(SYNERR, \"missing '(' at start of peepprocedure rule.\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip '('\n+  skipws();\n+\n+  char* name = nullptr;\n+  if ( (name = get_ident_dup()) == nullptr ) {\n+    parse_err(SYNERR, \"incorrect or missing expression for 'peepprocedure'\\n\");\n+    return;\n+  }\n+\n+  skipws();\n+  if (_curchar != ')') {\n+    parse_err(SYNERR, \"peepprocedure should contain a single identifier only\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip ')'\n+  if (_curchar != ';') {\n+    parse_err(SYNERR, \"missing ';' in peepprocedure definition\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip ';'\n+  skipws();\n+\n+  \/\/ Construct PeepProcedure\n+  PeepProcedure* procedure = new PeepProcedure(name);\n+  peep.add_procedure(procedure);\n+}\n+\n@@ -2632,1 +2703,1 @@\n-    int right_inst;        \/\/ Right-instructions's number\n+    int right_inst;        \/\/ Right-instruction's number\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":74,"deletions":3,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+class PeepPredicate;\n@@ -66,0 +67,1 @@\n+class PeepProcedure;\n@@ -139,0 +141,1 @@\n+  void peep_predicate_parse(Peephole &peep); \/\/ Parse the peephole predicate\n@@ -140,0 +143,1 @@\n+  void peep_procedure_parse(Peephole &peep); \/\/ Parse the peephole procedure\n","filename":"src\/hotspot\/share\/adlc\/adlparse.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -638,1 +638,2 @@\n-Peephole::Peephole() : _match(NULL), _constraint(NULL), _replace(NULL), _next(NULL) {\n+Peephole::Peephole() : _predicate(NULL), _match(NULL), _procedure(NULL),\n+                       _constraint(NULL), _replace(NULL), _next(NULL) {\n@@ -653,0 +654,6 @@\n+\/\/ Add a predicate to this peephole rule\n+void Peephole::add_predicate(PeepPredicate* predicate) {\n+  assert( _predicate == NULL, \"fatal()\" );\n+  _predicate = predicate;\n+}\n+\n@@ -659,0 +666,6 @@\n+\/\/ Add a procedure to this peephole rule\n+void Peephole::add_procedure(PeepProcedure* procedure) {\n+  assert( _procedure == NULL, \"fatal()\" );\n+  _procedure = procedure;\n+}\n+\n@@ -688,0 +701,18 @@\n+\/\/----------------------------PeepPredicate------------------------------------\n+PeepPredicate::PeepPredicate(const char* rule) : _rule(rule) {\n+}\n+PeepPredicate::~PeepPredicate() {\n+}\n+\n+const char* PeepPredicate::rule() const {\n+  return _rule;\n+}\n+\n+void PeepPredicate::dump() {\n+  output(stderr);\n+}\n+\n+void PeepPredicate::output(FILE* fp) {\n+  fprintf(fp, \"PeepPredicate\\n\");\n+}\n+\n@@ -694,1 +725,0 @@\n-\n@@ -744,0 +774,18 @@\n+\/\/----------------------------PeepProcedure------------------------------------\n+PeepProcedure::PeepProcedure(const char* name) : _name(name) {\n+}\n+PeepProcedure::~PeepProcedure() {\n+}\n+\n+const char* PeepProcedure::name() const {\n+  return _name;\n+}\n+\n+void PeepProcedure::dump() {\n+  output(stderr);\n+}\n+\n+void PeepProcedure::output(FILE* fp) {\n+  fprintf(fp, \"PeepProcedure\\n\");\n+}\n+\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,0 @@\n-class Peephole;\n-class PeepMatch;\n-class PeepConstraint;\n@@ -70,0 +67,2 @@\n+class Peephole;\n+class PeepPredicate;\n@@ -71,0 +70,1 @@\n+class PeepProcedure;\n@@ -529,0 +529,1 @@\n+  PeepPredicate  *_predicate;      \/\/ Predicate to apply peep rule\n@@ -530,0 +531,1 @@\n+  PeepProcedure  *_procedure;      \/\/ The detailed procedure to perform the rule\n@@ -544,0 +546,1 @@\n+  void add_predicate(PeepPredicate *only_one_predicate);\n@@ -545,0 +548,1 @@\n+  void add_procedure(PeepProcedure *only_one_procedure);\n@@ -550,0 +554,1 @@\n+  PeepPredicate  *predicate()   { return _predicate; }\n@@ -551,0 +556,1 @@\n+  PeepProcedure  *procedure()   { return _procedure; }\n@@ -559,0 +565,13 @@\n+class PeepPredicate : public Form {\n+private:\n+  const char* _rule;\n+public:\n+  \/\/ Public Methods\n+  PeepPredicate(const char* rule);\n+  ~PeepPredicate();\n+\n+  const char* rule() const;\n+\n+  void dump();\n+  void output(FILE* fp);\n+};\n@@ -591,0 +610,13 @@\n+class PeepProcedure : public Form {\n+private:\n+  const char* _name;\n+public:\n+  \/\/ Public Methods\n+  PeepProcedure(const char* name);\n+  ~PeepProcedure();\n+\n+  const char* name() const;\n+\n+  void dump();\n+  void output(FILE* fp);\n+};\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1268,1 +1268,2 @@\n-static void generate_peepreplace( FILE *fp, FormDict &globals, PeepMatch *pmatch, PeepConstraint *pconstraint, PeepReplace *preplace, int max_position ) {\n+static void generate_peepreplace( FILE *fp, FormDict &globals, int peephole_number, PeepMatch *pmatch,\n+                                  PeepConstraint *pconstraint, PeepReplace *preplace, int max_position ) {\n@@ -1317,1 +1318,0 @@\n-        fprintf(fp, \"        ra_->add_reference(root, inst%d);\\n\", inst_num);\n@@ -1343,0 +1343,3 @@\n+  \/\/ Set output of the new node\n+  fprintf(fp, \"        inst0->replace_by(root);\\n\");\n+  \/\/ Mark the node as removed because peephole does not remove nodes from the graph\n@@ -1345,0 +1348,1 @@\n+    fprintf(fp, \"        cfg_->map_node_to_block(inst%d, nullptr);\\n\", i);\n@@ -1346,3 +1350,7 @@\n-  \/\/ Return the new sub-tree\n-  fprintf(fp, \"        deleted = %d;\\n\", max_position+1 \/*zero to one based*\/);\n-  fprintf(fp, \"        return root;  \/\/ return new root;\\n\");\n+  for (int i = 0; i <= max_position; i++) {\n+    fprintf(fp, \"        block->remove_node(block_index - %d);\\n\", i);\n+  }\n+  fprintf(fp, \"        block->insert_node(root, block_index - %d);\\n\", max_position);\n+  fprintf(fp, \"        cfg_->map_node_to_block(root, block);\\n\");\n+  \/\/ Return the peephole index\n+  fprintf(fp, \"        return %d;  \/\/ return the peephole index;\\n\", peephole_number);\n@@ -1356,1 +1364,1 @@\n-  fprintf(fp, \"MachNode *%sNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted) {\\n\", node->_ident);\n+  fprintf(fp, \"int %sNode::peephole(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_) {\\n\", node->_ident);\n@@ -1369,0 +1377,3 @@\n+    if (peep->procedure() != NULL) {\n+      continue;\n+    }\n@@ -1387,0 +1398,1 @@\n+    PeepPredicate  *ppredicate  = peep->predicate();\n@@ -1388,0 +1400,1 @@\n+    PeepProcedure  *pprocedure  = peep->procedure();\n@@ -1396,4 +1409,10 @@\n-    fprintf(fp, \"  if( (OptoPeepholeAt == -1) || (OptoPeepholeAt==%d) ) {\\n\", peephole_number);\n-    fprintf(fp, \"    matches = true;\\n\");\n-    \/\/ Scan the peepmatch and output a test for each instruction\n-    check_peepmatch_instruction_sequence( fp, pmatch, pconstraint );\n+    fprintf(fp, \"  if( ((OptoPeepholeAt == -1) || (OptoPeepholeAt==%d)) && ( %s ) ) {\\n\",\n+            peephole_number, ppredicate != NULL ? ppredicate->rule() : \"true\");\n+    if (pprocedure == NULL) {\n+      fprintf(fp, \"    matches = true;\\n\");\n+      \/\/ Scan the peepmatch and output a test for each instruction\n+      check_peepmatch_instruction_sequence( fp, pmatch, pconstraint );\n+\n+      \/\/ Check constraints and build replacement inside scope\n+      fprintf(fp, \"    \/\/ If instruction subtree matches\\n\");\n+      fprintf(fp, \"    if( matches ) {\\n\");\n@@ -1401,3 +1420,2 @@\n-    \/\/ Check constraints and build replacement inside scope\n-    fprintf(fp, \"    \/\/ If instruction subtree matches\\n\");\n-    fprintf(fp, \"    if( matches ) {\\n\");\n+      \/\/ Generate tests for the constraints\n+      check_peepconstraints( fp, _globalNames, pmatch, pconstraint );\n@@ -1405,2 +1423,2 @@\n-    \/\/ Generate tests for the constraints\n-    check_peepconstraints( fp, _globalNames, pmatch, pconstraint );\n+      \/\/ Construct the new sub-tree\n+      generate_peepreplace( fp, _globalNames, peephole_number, pmatch, pconstraint, preplace, max_position );\n@@ -1408,2 +1426,28 @@\n-    \/\/ Construct the new sub-tree\n-    generate_peepreplace( fp, _globalNames, pmatch, pconstraint, preplace, max_position );\n+      \/\/ End of scope for this peephole's constraints\n+      fprintf(fp, \"    }\\n\");\n+    } else {\n+      const char* replace_inst = NULL;\n+      preplace->next_instruction(replace_inst);\n+      \/\/ Generate the target instruction\n+      fprintf(fp, \"    auto replacing = [](){ return static_cast<MachNode*>(new %sNode()); };\\n\", replace_inst);\n+\n+      \/\/ Call the precedure\n+      fprintf(fp, \"    bool replacement = Peephole::%s(block, block_index, cfg_, ra_, replacing\", pprocedure->name());\n+\n+      int         parent        = -1;\n+      int         inst_position = 0;\n+      const char* inst_name     = NULL;\n+      int         input         = 0;\n+      pmatch->reset();\n+      for (pmatch->next_instruction(parent, inst_position, inst_name, input);\n+           inst_name != NULL;\n+           pmatch->next_instruction(parent, inst_position, inst_name, input)) {\n+        fprintf(fp, \", %s_rule\", inst_name);\n+      }\n+      fprintf(fp, \");\\n\");\n+\n+      \/\/ If substitution succeeded, return the new node\n+      fprintf(fp, \"    if (replacement) {\\n\");\n+      fprintf(fp, \"      return %d;\\n\", peephole_number);\n+      fprintf(fp, \"    }\\n\");\n+    }\n@@ -1411,2 +1455,0 @@\n-    \/\/ End of scope for this peephole's constraints\n-    fprintf(fp, \"    }\\n\");\n@@ -1418,1 +1460,1 @@\n-  fprintf(fp, \"  return NULL;  \/\/ No peephole rules matched\\n\");\n+  fprintf(fp, \"  return -1;  \/\/ No peephole rules matched\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":62,"deletions":20,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1706,1 +1706,1 @@\n-      fprintf(fp,\"  virtual MachNode      *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted);\\n\");\n+      fprintf(fp,\"  virtual int            peephole(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_);\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  _output = new(ResourceObj::C_HEAP, mtCompiler) fileStream(file_name, \"at\");\n+  _output = new(mtCompiler) fileStream(file_name, \"at\");\n","filename":"src\/hotspot\/share\/c1\/c1_CFGPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1180,2 +1180,2 @@\n-                                   GrowableArray<ArchiveHeapOopmapInfo>* closed_heap_oopmaps,\n-                                   GrowableArray<ArchiveHeapOopmapInfo>* open_heap_oopmaps) {\n+                                   GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_bitmaps,\n+                                   GrowableArray<ArchiveHeapBitmapInfo>* open_heap_bitmaps) {\n@@ -1190,1 +1190,1 @@\n-  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_heap_oopmaps, open_heap_oopmaps,\n+  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_heap_bitmaps, open_heap_bitmaps,\n@@ -1196,1 +1196,1 @@\n-                                        closed_heap_oopmaps,\n+                                        closed_heap_bitmaps,\n@@ -1201,1 +1201,1 @@\n-                                        open_heap_oopmaps,\n+                                        open_heap_bitmaps,\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-struct ArchiveHeapOopmapInfo;\n+struct ArchiveHeapBitmapInfo;\n@@ -416,2 +416,2 @@\n-                     GrowableArray<ArchiveHeapOopmapInfo>* closed_heap_oopmaps,\n-                     GrowableArray<ArchiveHeapOopmapInfo>* open_heap_oopmaps);\n+                     GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_oopmaps,\n+                     GrowableArray<ArchiveHeapBitmapInfo>* open_heap_oopmaps);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    fill_failed_loaded_region();\n+    fill_failed_loaded_heap();\n@@ -83,1 +83,0 @@\n-  SystemDictionaryShared::update_archived_mirror_native_pointers();\n@@ -174,1 +173,1 @@\n-                                             int num_loaded_regions) {\n+                                                    int num_loaded_regions) {\n@@ -317,1 +316,1 @@\n-      \/\/ in fill_failed_loaded_region(), and it will eventually be GC'ed.\n+      \/\/ in fill_failed_loaded_heap(), and it will eventually be GC'ed.\n@@ -342,0 +341,1 @@\n+    r->set_mapped_base((char*)load_address);\n@@ -395,5 +395,5 @@\n-    HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n-    HeapWord* top    = (HeapWord*)_loaded_heap_top;\n-\n-    MemRegion archive_space = MemRegion(bottom, top);\n-    Universe::heap()->complete_loaded_archive_space(archive_space);\n+    \/\/ These operations are needed only when the heap is loaded (not mapped).\n+    finish_loaded_heap();\n+    if (VerifyArchivedFields > 0) {\n+      verify_loaded_heap();\n+    }\n@@ -401,0 +401,2 @@\n+  patch_native_pointers();\n+}\n@@ -402,3 +404,7 @@\n-  if (VerifyArchivedFields <= 0 || !is_loaded()) {\n-    return;\n-  }\n+void ArchiveHeapLoader::finish_loaded_heap() {\n+  HeapWord* bottom = (HeapWord*)_loaded_heap_bottom;\n+  HeapWord* top    = (HeapWord*)_loaded_heap_top;\n+\n+  MemRegion archive_space = MemRegion(bottom, top);\n+  Universe::heap()->complete_loaded_archive_space(archive_space);\n+}\n@@ -406,0 +412,1 @@\n+void ArchiveHeapLoader::verify_loaded_heap() {\n@@ -427,1 +434,1 @@\n-void ArchiveHeapLoader::fill_failed_loaded_region() {\n+void ArchiveHeapLoader::fill_failed_loaded_heap() {\n@@ -437,0 +444,33 @@\n+class PatchNativePointers: public BitMapClosure {\n+  Metadata** _start;\n+\n+ public:\n+  PatchNativePointers(Metadata** start) : _start(start) {}\n+\n+  bool do_bit(size_t offset) {\n+    Metadata** p = _start + offset;\n+    *p = (Metadata*)(address(*p) + MetaspaceShared::relocation_delta());\n+    \/\/ Currently we have only Klass pointers in heap objects.\n+    \/\/ This needs to be relaxed when we support other types of native\n+    \/\/ pointers such as Method.\n+    assert(((Klass*)(*p))->is_klass(), \"must be\");\n+    return true;\n+  }\n+};\n+\n+void ArchiveHeapLoader::patch_native_pointers() {\n+  if (MetaspaceShared::relocation_delta() == 0) {\n+    return;\n+  }\n+\n+  for (int i = MetaspaceShared::first_archive_heap_region;\n+       i <= MetaspaceShared::last_archive_heap_region; i++) {\n+    FileMapRegion* r = FileMapInfo::current_info()->space_at(i);\n+    if (r->mapped_base() != NULL && r->has_ptrmap()) {\n+      log_info(cds, heap)(\"Patching native pointers in heap region %d\", i);\n+      BitMapView bm = r->ptrmap_view();\n+      PatchNativePointers patcher((Metadata**)r->mapped_base());\n+      bm.iterate(&patcher);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":53,"deletions":13,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -149,1 +149,4 @@\n-  static void fill_failed_loaded_region();\n+  static void patch_native_pointers();\n+  static void finish_loaded_heap();\n+  static void verify_loaded_heap();\n+  static void fill_failed_loaded_heap();\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -131,1 +131,2 @@\n-  ADD_EXCL(\"jdk\/internal\/util\/StaticProperty\",           \"FILE_ENCODING\");         \/\/ C\n+  ADD_EXCL(\"jdk\/internal\/util\/StaticProperty\",           \"FILE_ENCODING\",          \/\/ C\n+                                                 \"JAVA_LOCALE_USE_OLD_ISO_CODES\"); \/\/ C\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,1 +57,3 @@\n-ClassListParser::ClassListParser(const char* file) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+  log_info(cds)(\"Parsing %s%s\", file,\n+                (parse_mode == _parse_lambda_forms_invokers_only) ? \" (lambda form invokers only)\" : \"\");\n@@ -76,0 +78,1 @@\n+  _parse_mode = parse_mode;\n@@ -107,0 +110,4 @@\n+    if (_parse_mode == _parse_lambda_forms_invokers_only) {\n+      continue;\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,7 @@\n+public:\n+  enum ParseMode {\n+    _parse_all,\n+    _parse_lambda_forms_invokers_only,\n+  };\n+\n+private:\n@@ -110,0 +117,1 @@\n+  ParseMode           _parse_mode;\n@@ -127,2 +135,1 @@\n-public:\n-  ClassListParser(const char* file);\n+  ClassListParser(const char* file, ParseMode _parse_mode);\n@@ -131,0 +138,6 @@\n+public:\n+  static int parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n+    ClassListParser parser(classlist_path, parse_mode);\n+    return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    _classlist_file = new(ResourceObj::C_HEAP, mtInternal)\n+    _classlist_file = new(mtInternal)\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1566,0 +1566,23 @@\n+void FileMapRegion::init_bitmaps(ArchiveHeapBitmapInfo oopmap, ArchiveHeapBitmapInfo ptrmap) {\n+  _oopmap_offset = oopmap._bm_region_offset;\n+  _oopmap_size_in_bits = oopmap._size_in_bits;\n+\n+  _ptrmap_offset = ptrmap._bm_region_offset;\n+  _ptrmap_size_in_bits = ptrmap._size_in_bits;\n+}\n+\n+BitMapView FileMapRegion::bitmap_view(bool is_oopmap) {\n+  char* bitmap_base = FileMapInfo::current_info()->map_bitmap_region();\n+  bitmap_base += is_oopmap ? _oopmap_offset : _ptrmap_offset;\n+  size_t size_in_bits = is_oopmap ? _oopmap_size_in_bits : _ptrmap_size_in_bits;\n+  return BitMapView((BitMap::bm_word_t*)(bitmap_base), size_in_bits);\n+}\n+\n+BitMapView FileMapRegion::oopmap_view() {\n+  return bitmap_view(true);\n+}\n+\n+BitMapView FileMapRegion::ptrmap_view() {\n+  assert(has_ptrmap(), \"must be\");\n+  return bitmap_view(false);\n+}\n@@ -1640,4 +1663,4 @@\n-size_t FileMapInfo::set_oopmaps_offset(GrowableArray<ArchiveHeapOopmapInfo>* oopmaps, size_t curr_size) {\n-  for (int i = 0; i < oopmaps->length(); i++) {\n-    oopmaps->at(i)._offset = curr_size;\n-    curr_size += oopmaps->at(i)._oopmap_size_in_bytes;\n+size_t FileMapInfo::set_bitmaps_offset(GrowableArray<ArchiveHeapBitmapInfo>* bitmaps, size_t curr_size) {\n+  for (int i = 0; i < bitmaps->length(); i++) {\n+    bitmaps->at(i)._bm_region_offset = curr_size;\n+    curr_size += bitmaps->at(i)._size_in_bytes;\n@@ -1648,4 +1671,4 @@\n-size_t FileMapInfo::write_oopmaps(GrowableArray<ArchiveHeapOopmapInfo>* oopmaps, size_t curr_offset, char* buffer) {\n-  for (int i = 0; i < oopmaps->length(); i++) {\n-    memcpy(buffer + curr_offset, oopmaps->at(i)._oopmap, oopmaps->at(i)._oopmap_size_in_bytes);\n-    curr_offset += oopmaps->at(i)._oopmap_size_in_bytes;\n+size_t FileMapInfo::write_bitmaps(GrowableArray<ArchiveHeapBitmapInfo>* bitmaps, size_t curr_offset, char* buffer) {\n+  for (int i = 0; i < bitmaps->length(); i++) {\n+    memcpy(buffer + curr_offset, bitmaps->at(i)._map, bitmaps->at(i)._size_in_bytes);\n+    curr_offset += bitmaps->at(i)._size_in_bytes;\n@@ -1657,2 +1680,2 @@\n-                                       GrowableArray<ArchiveHeapOopmapInfo>* closed_oopmaps,\n-                                       GrowableArray<ArchiveHeapOopmapInfo>* open_oopmaps,\n+                                       GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n+                                       GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps,\n@@ -1663,3 +1686,3 @@\n-  if (closed_oopmaps != NULL && open_oopmaps != NULL) {\n-    size_in_bytes = set_oopmaps_offset(closed_oopmaps, size_in_bytes);\n-    size_in_bytes = set_oopmaps_offset(open_oopmaps, size_in_bytes);\n+  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+    size_in_bytes = set_bitmaps_offset(closed_bitmaps, size_in_bytes);\n+    size_in_bytes = set_bitmaps_offset(open_bitmaps, size_in_bytes);\n@@ -1672,3 +1695,3 @@\n-  if (closed_oopmaps != NULL && open_oopmaps != NULL) {\n-    size_t curr_offset = write_oopmaps(closed_oopmaps, ptrmap->size_in_bytes(), buffer);\n-    write_oopmaps(open_oopmaps, curr_offset, buffer);\n+  if (closed_bitmaps != NULL && open_bitmaps != NULL) {\n+    size_t curr_offset = write_bitmaps(closed_bitmaps, ptrmap->size_in_bytes(), buffer);\n+    write_bitmaps(open_bitmaps, curr_offset, buffer);\n@@ -1713,1 +1736,1 @@\n-                                       GrowableArray<ArchiveHeapOopmapInfo>* oopmaps,\n+                                       GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n@@ -1739,2 +1762,4 @@\n-      space_at(region_idx)->init_oopmap(oopmaps->at(i)._offset,\n-                                        oopmaps->at(i)._oopmap_size_in_bits);\n+      int oopmap_idx = i * 2;\n+      int ptrmap_idx = i * 2 + 1;\n+      space_at(region_idx)->init_bitmaps(bitmaps->at(oopmap_idx),\n+                                         bitmaps->at(ptrmap_idx));\n@@ -2381,0 +2406,2 @@\n+\n+    si->set_mapped_base(base);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":46,"deletions":19,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+class BitMapView;\n@@ -106,5 +107,5 @@\n-struct ArchiveHeapOopmapInfo {\n-  address _oopmap;               \/\/ bitmap for relocating embedded oops\n-  size_t  _offset;               \/\/ this oopmap is stored at this offset from the bottom of the BM region\n-  size_t  _oopmap_size_in_bits;\n-  size_t  _oopmap_size_in_bytes;\n+struct ArchiveHeapBitmapInfo {\n+  address _map;               \/\/ bitmap for relocating embedded oops\n+  size_t  _bm_region_offset;  \/\/ this bitmap is stored at this offset from the bottom of the BM region\n+  size_t  _size_in_bits;\n+  size_t  _size_in_bytes;\n@@ -141,0 +142,1 @@\n+  BitMapView bitmap_view(bool is_oopmap);\n@@ -160,1 +162,1 @@\n-  char*  mapped_base()              const { assert_is_not_heap_region(); return _mapped_base; }\n+  char*  mapped_base()              const { return _mapped_base; }\n@@ -174,5 +176,4 @@\n-\n-  void init_oopmap(size_t oopmap_offset, size_t size_in_bits) {\n-    _oopmap_offset = oopmap_offset;\n-    _oopmap_size_in_bits = size_in_bits;\n-  }\n+  void init_bitmaps(ArchiveHeapBitmapInfo oopmap, ArchiveHeapBitmapInfo ptrmap);\n+  BitMapView oopmap_view();\n+  BitMapView ptrmap_view();\n+  bool has_ptrmap()                  { return _ptrmap_size_in_bits != 0; }\n@@ -481,2 +482,2 @@\n-                            GrowableArray<ArchiveHeapOopmapInfo>* closed_oopmaps,\n-                            GrowableArray<ArchiveHeapOopmapInfo>* open_oopmaps,\n+                            GrowableArray<ArchiveHeapBitmapInfo>* closed_bitmaps,\n+                            GrowableArray<ArchiveHeapBitmapInfo>* open_bitmaps,\n@@ -485,1 +486,1 @@\n-                            GrowableArray<ArchiveHeapOopmapInfo>* oopmaps,\n+                            GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n@@ -610,2 +611,2 @@\n-  static size_t set_oopmaps_offset(GrowableArray<ArchiveHeapOopmapInfo> *oopmaps, size_t curr_size);\n-  static size_t write_oopmaps(GrowableArray<ArchiveHeapOopmapInfo> *oopmaps, size_t curr_offset, char* buffer);\n+  static size_t set_bitmaps_offset(GrowableArray<ArchiveHeapBitmapInfo> *bitmaps, size_t curr_size);\n+  static size_t write_bitmaps(GrowableArray<ArchiveHeapBitmapInfo> *bitmaps, size_t curr_offset, char* buffer);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+GrowableArrayCHeap<Metadata**, mtClassShared>* HeapShared::_native_pointers = NULL;\n@@ -325,0 +326,1 @@\n+    mark_native_pointers(obj, archived_oop);\n@@ -358,0 +360,26 @@\n+void HeapShared::mark_native_pointers(oop orig_obj, oop archived_obj) {\n+  if (java_lang_Class::is_instance(orig_obj)) {\n+    mark_one_native_pointer(archived_obj, java_lang_Class::klass_offset());\n+    mark_one_native_pointer(archived_obj, java_lang_Class::array_klass_offset());\n+  }\n+}\n+\n+void HeapShared::mark_one_native_pointer(oop archived_obj, int offset) {\n+  Metadata* ptr = archived_obj->metadata_field_acquire(offset);\n+  if (ptr != NULL) {\n+    \/\/ Set the native pointer to the requested address (at runtime, if the metadata\n+    \/\/ is mapped at the default location, it will be at this address).\n+    address buffer_addr = ArchiveBuilder::current()->get_buffered_addr((address)ptr);\n+    address requested_addr = ArchiveBuilder::current()->to_requested(buffer_addr);\n+    archived_obj->metadata_field_put(offset, (Metadata*)requested_addr);\n+\n+    \/\/ Remember this pointer. At runtime, if the metadata is mapped at a non-default\n+    \/\/ location, the pointer needs to be patched (see ArchiveHeapLoader::patch_native_pointers()).\n+    _native_pointers->append(archived_obj->field_addr<Metadata*>(offset));\n+\n+    log_debug(cds, heap, mirror)(\n+        \"Marked metadata field at %d: \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n+         offset, p2i(ptr), p2i(requested_addr));\n+  }\n+}\n+\n@@ -1637,0 +1665,1 @@\n+    _native_pointers = new GrowableArrayCHeap<Metadata**, mtClassShared>(2048);\n@@ -1802,0 +1831,29 @@\n+\n+ResourceBitMap HeapShared::calculate_ptrmap(MemRegion region) {\n+  size_t num_bits = region.byte_size() \/ sizeof(Metadata*);\n+  ResourceBitMap oopmap(num_bits);\n+\n+  Metadata** start = (Metadata**)region.start();\n+  Metadata** end   = (Metadata**)region.end();\n+\n+  int num_non_null_ptrs = 0;\n+  int len = _native_pointers->length();\n+  for (int i = 0; i < len; i++) {\n+    Metadata** p = _native_pointers->at(i);\n+    if (start <= p && p < end) {\n+      assert(*p != NULL, \"must be non-null\");\n+      num_non_null_ptrs ++;\n+      size_t idx = p - start;\n+      oopmap.set_bit(idx);\n+    }\n+  }\n+\n+  log_info(cds, heap)(\"calculate_ptrmap: marked %d non-null native pointers out of \"\n+                      SIZE_FORMAT \" possible locations\", num_non_null_ptrs, num_bits);\n+  if (num_non_null_ptrs > 0) {\n+    return oopmap;\n+  } else {\n+    return ResourceBitMap(0);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+  static GrowableArrayCHeap<Metadata**, mtClassShared>* _native_pointers;\n@@ -314,0 +315,2 @@\n+  static void mark_native_pointers(oop orig_obj, oop archived_obj);\n+  static void mark_one_native_pointer(oop archived_obj, int offset);\n@@ -362,1 +365,2 @@\n-  static ResourceBitMap calculate_oopmap(MemRegion region);\n+  static ResourceBitMap calculate_oopmap(MemRegion region); \/\/ marks all the oop pointers\n+  static ResourceBitMap calculate_ptrmap(MemRegion region); \/\/ marks all the native pointers\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -443,2 +443,2 @@\n-  GrowableArray<ArchiveHeapOopmapInfo> *_closed_heap_oopmaps;\n-  GrowableArray<ArchiveHeapOopmapInfo> *_open_heap_oopmaps;\n+  GrowableArray<ArchiveHeapBitmapInfo> *_closed_heap_bitmaps;\n+  GrowableArray<ArchiveHeapBitmapInfo> *_open_heap_bitmaps;\n@@ -447,3 +447,5 @@\n-  void dump_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;\n-  void dump_heap_oopmaps(GrowableArray<MemRegion>* regions,\n-                                 GrowableArray<ArchiveHeapOopmapInfo>* oopmaps);\n+  void dump_heap_bitmaps() NOT_CDS_JAVA_HEAP_RETURN;\n+  void dump_heap_bitmaps(GrowableArray<MemRegion>* regions,\n+                         GrowableArray<ArchiveHeapBitmapInfo>* bitmaps);\n+  void dump_one_heap_bitmap(MemRegion region, GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n+                            ResourceBitMap bitmap, bool is_oopmap);\n@@ -462,2 +464,2 @@\n-    _closed_heap_oopmaps(NULL),\n-    _open_heap_oopmaps(NULL) {}\n+    _closed_heap_bitmaps(NULL),\n+    _open_heap_bitmaps(NULL) {}\n@@ -509,1 +511,1 @@\n-  dump_heap_oopmaps();\n+  dump_heap_bitmaps();\n@@ -571,2 +573,2 @@\n-                        _closed_heap_oopmaps,\n-                        _open_heap_oopmaps);\n+                        _closed_heap_bitmaps,\n+                        _open_heap_bitmaps);\n@@ -738,0 +740,27 @@\n+void MetaspaceShared::get_default_classlist(char* default_classlist, const size_t buf_size) {\n+  \/\/ Construct the path to the class list (in jre\/lib)\n+  \/\/ Walk up two directories from the location of the VM and\n+  \/\/ optionally tack on \"lib\" (depending on platform)\n+  os::jvm_path(default_classlist, (jint)(buf_size));\n+  for (int i = 0; i < 3; i++) {\n+    char *end = strrchr(default_classlist, *os::file_separator());\n+    if (end != NULL) *end = '\\0';\n+  }\n+  size_t classlist_path_len = strlen(default_classlist);\n+  if (classlist_path_len >= 3) {\n+    if (strcmp(default_classlist + classlist_path_len - 3, \"lib\") != 0) {\n+      if (classlist_path_len < buf_size - 4) {\n+        jio_snprintf(default_classlist + classlist_path_len,\n+                     buf_size - classlist_path_len,\n+                     \"%slib\", os::file_separator());\n+        classlist_path_len += 4;\n+      }\n+    }\n+  }\n+  if (classlist_path_len < buf_size - 10) {\n+    jio_snprintf(default_classlist + classlist_path_len,\n+                 buf_size - classlist_path_len,\n+                 \"%sclasslist\", os::file_separator());\n+  }\n+}\n+\n@@ -742,0 +771,1 @@\n+  get_default_classlist(default_classlist, sizeof(default_classlist));\n@@ -743,24 +773,0 @@\n-    \/\/ Construct the path to the class list (in jre\/lib)\n-    \/\/ Walk up two directories from the location of the VM and\n-    \/\/ optionally tack on \"lib\" (depending on platform)\n-    os::jvm_path(default_classlist, sizeof(default_classlist));\n-    for (int i = 0; i < 3; i++) {\n-      char *end = strrchr(default_classlist, *os::file_separator());\n-      if (end != NULL) *end = '\\0';\n-    }\n-    int classlist_path_len = (int)strlen(default_classlist);\n-    if (classlist_path_len >= 3) {\n-      if (strcmp(default_classlist + classlist_path_len - 3, \"lib\") != 0) {\n-        if (classlist_path_len < JVM_MAXPATHLEN - 4) {\n-          jio_snprintf(default_classlist + classlist_path_len,\n-                       sizeof(default_classlist) - classlist_path_len,\n-                       \"%slib\", os::file_separator());\n-          classlist_path_len += 4;\n-        }\n-      }\n-    }\n-    if (classlist_path_len < JVM_MAXPATHLEN - 10) {\n-      jio_snprintf(default_classlist + classlist_path_len,\n-                   sizeof(default_classlist) - classlist_path_len,\n-                   \"%sclasslist\", os::file_separator());\n-    }\n@@ -774,1 +780,2 @@\n-  int class_count = parse_classlist(classlist_path, CHECK);\n+  int class_count = ClassListParser::parse_classlist(classlist_path,\n+                                                     ClassListParser::_parse_all, CHECK);\n@@ -776,1 +783,10 @@\n-    class_count += parse_classlist(ExtraSharedClassListFile, CHECK);\n+    class_count += ClassListParser::parse_classlist(ExtraSharedClassListFile,\n+                                                    ClassListParser::_parse_all, CHECK);\n+  }\n+  if (classlist_path != default_classlist) {\n+    struct stat statbuf;\n+    if (os::stat(default_classlist, &statbuf) == 0) {\n+      \/\/ File exists, let's use it.\n+      class_count += ClassListParser::parse_classlist(default_classlist,\n+                                                      ClassListParser::_parse_lambda_forms_invokers_only, CHECK);\n+    }\n@@ -819,6 +835,0 @@\n-\n-int MetaspaceShared::parse_classlist(const char* classlist_path, TRAPS) {\n-  ClassListParser parser(classlist_path);\n-  return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n-}\n-\n@@ -896,1 +906,1 @@\n-void VM_PopulateDumpSharedSpace::dump_heap_oopmaps() {\n+void VM_PopulateDumpSharedSpace::dump_heap_bitmaps() {\n@@ -898,2 +908,7 @@\n-    _closed_heap_oopmaps = new GrowableArray<ArchiveHeapOopmapInfo>(2);\n-    dump_heap_oopmaps(_closed_heap_regions, _closed_heap_oopmaps);\n+    _closed_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n+    dump_heap_bitmaps(_closed_heap_regions, _closed_heap_bitmaps);\n+\n+    _open_heap_bitmaps = new GrowableArray<ArchiveHeapBitmapInfo>(2);\n+    dump_heap_bitmaps(_open_heap_regions, _open_heap_bitmaps);\n+  }\n+}\n@@ -901,2 +916,8 @@\n-    _open_heap_oopmaps = new GrowableArray<ArchiveHeapOopmapInfo>(2);\n-    dump_heap_oopmaps(_open_heap_regions, _open_heap_oopmaps);\n+void VM_PopulateDumpSharedSpace::dump_heap_bitmaps(GrowableArray<MemRegion>* regions,\n+                                                   GrowableArray<ArchiveHeapBitmapInfo>* bitmaps) {\n+  for (int i = 0; i < regions->length(); i++) {\n+    MemRegion region = regions->at(i);\n+    ResourceBitMap oopmap = HeapShared::calculate_oopmap(region);\n+    ResourceBitMap ptrmap = HeapShared::calculate_ptrmap(region);\n+    dump_one_heap_bitmap(region, bitmaps, oopmap, true);\n+    dump_one_heap_bitmap(region, bitmaps, ptrmap, false);\n@@ -906,18 +927,14 @@\n-void VM_PopulateDumpSharedSpace::dump_heap_oopmaps(GrowableArray<MemRegion>* regions,\n-                                                   GrowableArray<ArchiveHeapOopmapInfo>* oopmaps) {\n-  for (int i=0; i<regions->length(); i++) {\n-    ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions->at(i));\n-    size_t size_in_bits = oopmap.size();\n-    size_t size_in_bytes = oopmap.size_in_bytes();\n-    uintptr_t* buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);\n-    oopmap.write_to(buffer, size_in_bytes);\n-    log_info(cds, heap)(\"Oopmap = \" INTPTR_FORMAT \" (\" SIZE_FORMAT_W(6) \" bytes) for heap region \"\n-                        INTPTR_FORMAT \" (\" SIZE_FORMAT_W(8) \" bytes)\",\n-                        p2i(buffer), size_in_bytes,\n-                        p2i(regions->at(i).start()), regions->at(i).byte_size());\n-\n-    ArchiveHeapOopmapInfo info;\n-    info._oopmap = (address)buffer;\n-    info._oopmap_size_in_bits = size_in_bits;\n-    info._oopmap_size_in_bytes = size_in_bytes;\n-    oopmaps->append(info);\n+void VM_PopulateDumpSharedSpace::dump_one_heap_bitmap(MemRegion region,\n+                                                      GrowableArray<ArchiveHeapBitmapInfo>* bitmaps,\n+                                                      ResourceBitMap bitmap, bool is_oopmap) {\n+  size_t size_in_bits = bitmap.size();\n+  size_t size_in_bytes;\n+  uintptr_t* buffer;\n+\n+  if (size_in_bits > 0) {\n+    size_in_bytes = bitmap.size_in_bytes();\n+    buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);\n+    bitmap.write_to(buffer, size_in_bytes);\n+  } else {\n+    size_in_bytes = 0;\n+    buffer = NULL;\n@@ -925,0 +942,12 @@\n+\n+  log_info(cds, heap)(\"%s = \" INTPTR_FORMAT \" (\" SIZE_FORMAT_W(6) \" bytes) for heap region \"\n+                      INTPTR_FORMAT \" (\" SIZE_FORMAT_W(8) \" bytes)\",\n+                      is_oopmap ? \"Oopmap\" : \"Ptrmap\",\n+                      p2i(buffer), size_in_bytes,\n+                      p2i(region.start()), region.byte_size());\n+\n+  ArchiveHeapBitmapInfo info;\n+  info._map = (address)buffer;\n+  info._size_in_bits = size_in_bits;\n+  info._size_in_bytes = size_in_bytes;\n+  bitmaps->append(info);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":94,"deletions":65,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -91,3 +91,0 @@\n-  static int parse_classlist(const char * classlist_path,\n-                              TRAPS) NOT_CDS_RETURN_(0);\n-\n@@ -205,0 +202,1 @@\n+  static void get_default_classlist(char* default_classlist, const size_t buf_size);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -287,0 +287,6 @@\n+#ifdef ASSERT\n+void ClassLoaderData::verify_not_claimed(int claim) {\n+  assert((_claim & claim) == 0, \"Found claim: %d bits in _claim: %d\", claim, _claim);\n+}\n+#endif\n+\n@@ -614,1 +620,0 @@\n-  bool resizable = false;\n@@ -617,1 +622,0 @@\n-    resizable = true;\n@@ -622,1 +626,0 @@\n-    resizable = true;\n@@ -625,4 +628,0 @@\n-    resizable = true;\n-  }\n-  if (!DynamicallyResizeSystemDictionaries || DumpSharedSpaces) {\n-    resizable = false;\n@@ -630,1 +629,1 @@\n-  return new Dictionary(this, size, resizable);\n+  return new Dictionary(this, size);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+  void verify_not_claimed(int claim) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,9 @@\n+\n+void ClassLoaderDataGraph::verify_claimed_marks_cleared(int claim) {\n+#ifdef ASSERT\n+ for (ClassLoaderData* cld = Atomic::load_acquire(&_head); cld != NULL; cld = cld->next()) {\n+    cld->verify_not_claimed(claim);\n+  }\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+  static void verify_claimed_marks_cleared(int claim);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-Dictionary::Dictionary(ClassLoaderData* loader_data, size_t table_size, bool resizable)\n-  : _resizable(resizable), _number_of_entries(0), _loader_data(loader_data) {\n+Dictionary::Dictionary(ClassLoaderData* loader_data, size_t table_size)\n+  : _number_of_entries(0), _loader_data(loader_data) {\n@@ -107,2 +107,1 @@\n-  return (_resizable &&\n-         (_number_of_entries > (_resize_load_trigger * table_size())) &&\n+  return ((_number_of_entries > (_resize_load_trigger * table_size())) &&\n@@ -483,2 +482,2 @@\n-  st->print_cr(\"Java dictionary (table_size=%d, classes=%d, resizable=%s)\",\n-               table_size(), _number_of_entries, BOOL_TO_STR(_resizable));\n+  st->print_cr(\"Java dictionary (table_size=%d, classes=%d)\",\n+               table_size(), _number_of_entries);\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  bool _resizable;\n@@ -66,1 +65,1 @@\n-  Dictionary(ClassLoaderData* loader_data, size_t table_size, bool resizable = false);\n+  Dictionary(ClassLoaderData* loader_data, size_t table_size);\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1160,15 +1160,0 @@\n-static void set_klass_field_in_archived_mirror(oop mirror_obj, int offset, Klass* k) {\n-  assert(java_lang_Class::is_instance(mirror_obj), \"must be\");\n-  \/\/ this is the copy of k in the output buffer\n-  Klass* copy = ArchiveBuilder::get_buffered_klass(k);\n-\n-  \/\/ This is the address of k, if the archive is loaded at the requested location\n-  Klass* def = ArchiveBuilder::current()->to_requested(copy);\n-\n-  log_debug(cds, heap, mirror)(\n-      \"Relocate mirror metadata field at %d from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n-      offset, p2i(k), p2i(def));\n-\n-  mirror_obj->metadata_field_put(offset, def);\n-}\n-\n@@ -1185,5 +1170,0 @@\n-      Klass *ak = (Klass*)(archived_m->metadata_field(_array_klass_offset));\n-      assert(ak != NULL || t == T_VOID, \"should not be NULL\");\n-      if (ak != NULL) {\n-        set_klass_field_in_archived_mirror(archived_m, _array_klass_offset, ak);\n-      }\n@@ -1309,11 +1289,0 @@\n-  \/\/ The archived mirror's field at _klass_offset is still pointing to the original\n-  \/\/ klass. Updated the field in the archived mirror to point to the relocated\n-  \/\/ klass in the archive.\n-  set_klass_field_in_archived_mirror(archived_mirror, _klass_offset, as_Klass(mirror));\n-\n-  \/\/ The field at _array_klass_offset is pointing to the original one dimension\n-  \/\/ higher array klass if exists. Relocate the pointer.\n-  Klass *arr = array_klass_acquire(mirror);\n-  if (arr != NULL) {\n-    set_klass_field_in_archived_mirror(archived_mirror, _array_klass_offset, arr);\n-  }\n@@ -1323,27 +1292,0 @@\n-void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {\n-  if (MetaspaceShared::relocation_delta() != 0) {\n-    assert(archived_mirror->metadata_field(_klass_offset) == NULL, \"must be for primitive class\");\n-\n-    Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));\n-    if (ak != NULL) {\n-      archived_mirror->metadata_field_put(_array_klass_offset,\n-          (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));\n-    }\n-  }\n-}\n-\n-void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {\n-  assert(MetaspaceShared::relocation_delta() != 0, \"must be\");\n-\n-  Klass* k = ((Klass*)archived_mirror->metadata_field(_klass_offset));\n-  archived_mirror->metadata_field_put(_klass_offset,\n-      (Klass*)(address(k) + MetaspaceShared::relocation_delta()));\n-\n-  Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));\n-  if (ak != NULL) {\n-    archived_mirror->metadata_field_put(_array_klass_offset,\n-        (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":58,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -263,2 +263,0 @@\n-  static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;\n-  static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,4 @@\n-    \/\/ is being redefined or retransformed. We use jvmti_thread_state()\n+    \/\/ is being retransformed. If class file load hook provides\n+    \/\/ modified class data during class loading or redefinition,\n+    \/\/ new cached class file buffer should be allocated.\n+    \/\/ We use jvmti_thread_state()\n@@ -135,2 +138,1 @@\n-\n-      if (k != NULL) {\n+      if (k != NULL && state->get_class_load_kind() == jvmti_class_load_kind_retransform) {\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -664,1 +664,0 @@\n-  assert(event->should_commit(), \"invariant\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1553,70 +1553,0 @@\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-\n-class ArchivedMirrorPatcher {\n-protected:\n-  static void update(Klass* k) {\n-    if (k->has_archived_mirror_index()) {\n-      oop m = k->archived_java_mirror();\n-      if (m != NULL) {\n-        java_lang_Class::update_archived_mirror_native_pointers(m);\n-      }\n-    }\n-  }\n-\n-public:\n-  static void update_array_klasses(Klass* ak) {\n-    while (ak != NULL) {\n-      update(ak);\n-      ak = ArrayKlass::cast(ak)->higher_dimension();\n-    }\n-  }\n-\n-  void do_value(const RunTimeClassInfo* info) {\n-    InstanceKlass* ik = info->_klass;\n-    update(ik);\n-    update_array_klasses(ik->array_klasses());\n-  }\n-};\n-\n-class ArchivedLambdaMirrorPatcher : public ArchivedMirrorPatcher {\n-public:\n-  void do_value(const RunTimeLambdaProxyClassInfo* info) {\n-    InstanceKlass* ik = info->proxy_klass_head();\n-    while (ik != NULL) {\n-      update(ik);\n-      Klass* k = ik->next_link();\n-      ik = (k != NULL) ? InstanceKlass::cast(k) : NULL;\n-    }\n-  }\n-};\n-\n-void SystemDictionaryShared::update_archived_mirror_native_pointers_for(RunTimeSharedDictionary* dict) {\n-  ArchivedMirrorPatcher patcher;\n-  dict->iterate(&patcher);\n-}\n-\n-void SystemDictionaryShared::update_archived_mirror_native_pointers_for(LambdaProxyClassDictionary* dict) {\n-  ArchivedLambdaMirrorPatcher patcher;\n-  dict->iterate(&patcher);\n-}\n-\n-void SystemDictionaryShared::update_archived_mirror_native_pointers() {\n-  if (!ArchiveHeapLoader::are_archived_mirrors_available()) {\n-    return;\n-  }\n-  if (MetaspaceShared::relocation_delta() == 0) {\n-    return;\n-  }\n-  \/\/ mirrors are not archived for the classes in the dynamic archive\n-  update_archived_mirror_native_pointers_for(&_static_archive._builtin_dictionary);\n-  update_archived_mirror_native_pointers_for(&_static_archive._unregistered_dictionary);\n-  update_archived_mirror_native_pointers_for(&_static_archive._lambda_proxy_class_dictionary);\n-\n-  for (int t = T_BOOLEAN; t <= T_LONG; t++) {\n-    Klass* k = Universe::typeArrayKlassObj((BasicType)t);\n-    ArchivedMirrorPatcher::update_array_klasses(k);\n-  }\n-  ArchivedMirrorPatcher::update_array_klasses(Universe::fillerArrayKlassObj());\n-}\n-#endif\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":70,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -349,8 +349,0 @@\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-private:\n-  static void update_archived_mirror_native_pointers_for(RunTimeSharedDictionary* dict);\n-  static void update_archived_mirror_native_pointers_for(LambdaProxyClassDictionary* dict);\n-public:\n-  static void update_archived_mirror_native_pointers() NOT_CDS_RETURN;\n-#endif\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -227,0 +227,6 @@\n+  do_intrinsic(_float16ToFloat,           java_lang_Float,        float16ToFloat_name,      f16_float_signature, F_S)   \\\n+   do_name(     float16ToFloat_name,                             \"float16ToFloat\")                                      \\\n+   do_signature(f16_float_signature,                             \"(S)F\")                                                \\\n+  do_intrinsic(_floatToFloat16,           java_lang_Float,        floatToFloat16_name,      float_f16_signature, F_S)   \\\n+   do_name(     floatToFloat16_name,                             \"floatToFloat16\")                                      \\\n+   do_signature(float_f16_signature,                             \"(F)S\")                                                \\\n@@ -1191,0 +1197,12 @@\n+                                                                                                                                               \\\n+  do_intrinsic(_IndexVector, jdk_internal_vm_vector_VectorSupport, index_vector_op_name, index_vector_op_sig, F_S)                             \\\n+    do_signature(index_vector_op_sig, \"(Ljava\/lang\/Class;\"                                                                                     \\\n+                                       \"Ljava\/lang\/Class;\"                                                                                     \\\n+                                       \"I\"                                                                                                     \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                         \\\n+                                       \"I\"                                                                                                     \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;\"                                                  \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation;)\"                                                \\\n+                                       \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                        \\\n+    do_name(index_vector_op_name, \"indexVector\")                                                                                               \\\n+                                                                                                                                               \\\n@@ -1299,1 +1317,1 @@\n-  LAST_COMPILER_INLINE = _VectorCompressExpand,\n+  LAST_COMPILER_INLINE = _IndexVector,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -993,1 +993,1 @@\n-    EventJitRestart event;\n+    EventJITRestart event;\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1963,1 +1963,1 @@\n-        CompileLog* log = new(ResourceObj::C_HEAP, mtCompiler) CompileLog(file_name, fp, thread_id);\n+        CompileLog* log = new(mtCompiler) CompileLog(file_name, fp, thread_id);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  initialize(new(ResourceObj::C_HEAP, mtCompiler) fileStream(fp, true));\n+  initialize(new(mtCompiler) fileStream(fp, true));\n","filename":"src\/hotspot\/share\/compiler\/compileLog.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#ifndef ZERO\n@@ -75,0 +76,6 @@\n+#else\n+\/\/ Zero runs without compilers. Do not let this code to force\n+\/\/ the GC mode and default heap settings.\n+define_pd_global(bool, NeverActAsServerClassMachine, false);\n+define_pd_global(uint64_t,MaxRAM,                    128ULL*G);\n+#endif\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals_pd.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2022, Red Hat, Inc. All rights reserved.\n@@ -77,4 +77,0 @@\n-void EpsilonHeap::post_initialize() {\n-  CollectedHeap::post_initialize();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-  virtual void post_initialize();\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-    _rs_length_diff_seq(new TruncatedSeq(TruncatedSeqLength)),\n+    _young_rs_length_diff_seq(new TruncatedSeq(TruncatedSeqLength)),\n+    _mixed_rs_length_diff_seq(new TruncatedSeq(TruncatedSeqLength)),\n@@ -84,2 +85,2 @@\n-    _young_card_merge_to_scan_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _mixed_card_merge_to_scan_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),\n+    _young_card_scan_to_merge_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),\n+    _mixed_card_scan_to_merge_ratio_seq(new TruncatedSeq(TruncatedSeqLength)),\n@@ -94,2 +95,4 @@\n-    _pending_cards_seq(new TruncatedSeq(TruncatedSeqLength)),\n-    _rs_length_seq(new TruncatedSeq(TruncatedSeqLength)),\n+    _young_pending_cards_seq(new TruncatedSeq(TruncatedSeqLength)),\n+    _mixed_pending_cards_seq(new TruncatedSeq(TruncatedSeqLength)),\n+    _young_rs_length_seq(new TruncatedSeq(TruncatedSeqLength)),\n+    _mixed_rs_length_seq(new TruncatedSeq(TruncatedSeqLength)),\n@@ -107,1 +110,1 @@\n-  _rs_length_diff_seq->add(rs_length_diff_defaults[index]);\n+  _young_rs_length_diff_seq->add(rs_length_diff_defaults[index]);\n@@ -112,1 +115,1 @@\n-  _young_card_merge_to_scan_ratio_seq->add(young_card_merge_to_scan_ratio_defaults[index]);\n+  _young_card_scan_to_merge_ratio_seq->add(young_card_merge_to_scan_ratio_defaults[index]);\n@@ -172,2 +175,2 @@\n-void G1Analytics::report_cost_per_card_scan_ms(double cost_per_card_ms, bool for_young_gc) {\n-  if (for_young_gc) {\n+void G1Analytics::report_cost_per_card_scan_ms(double cost_per_card_ms, bool for_young_only_phase) {\n+  if  (for_young_only_phase) {\n@@ -180,2 +183,2 @@\n-void G1Analytics::report_cost_per_card_merge_ms(double cost_per_card_ms, bool for_young_gc) {\n-  if (for_young_gc) {\n+void G1Analytics::report_cost_per_card_merge_ms(double cost_per_card_ms, bool for_young_only_phase) {\n+  if  (for_young_only_phase) {\n@@ -188,3 +191,3 @@\n-void G1Analytics::report_card_merge_to_scan_ratio(double merge_to_scan_ratio, bool for_young_gc) {\n-  if (for_young_gc) {\n-    _young_card_merge_to_scan_ratio_seq->add(merge_to_scan_ratio);\n+void G1Analytics::report_card_scan_to_merge_ratio(double merge_to_scan_ratio, bool for_young_only_phase) {\n+  if (for_young_only_phase) {\n+    _young_card_scan_to_merge_ratio_seq->add(merge_to_scan_ratio);\n@@ -192,1 +195,1 @@\n-    _mixed_card_merge_to_scan_ratio_seq->add(merge_to_scan_ratio);\n+    _mixed_card_scan_to_merge_ratio_seq->add(merge_to_scan_ratio);\n@@ -196,2 +199,6 @@\n-void G1Analytics::report_rs_length_diff(double rs_length_diff) {\n-  _rs_length_diff_seq->add(rs_length_diff);\n+void G1Analytics::report_rs_length_diff(double rs_length_diff, bool for_young_only_phase) {\n+  if  (for_young_only_phase) {\n+    _young_rs_length_diff_seq->add(rs_length_diff);\n+  } else {\n+    _mixed_rs_length_diff_seq->add(rs_length_diff);\n+  }\n@@ -220,2 +227,6 @@\n-void G1Analytics::report_pending_cards(double pending_cards) {\n-  _pending_cards_seq->add(pending_cards);\n+void G1Analytics::report_pending_cards(double pending_cards, bool for_young_only_phase) {\n+  if  (for_young_only_phase) {\n+    _young_pending_cards_seq->add(pending_cards);\n+  } else {\n+    _mixed_pending_cards_seq->add(pending_cards);\n+  }\n@@ -224,2 +235,6 @@\n-void G1Analytics::report_rs_length(double rs_length) {\n-  _rs_length_seq->add(rs_length);\n+void G1Analytics::report_rs_length(double rs_length, bool for_young_only_phase) {\n+  if  (for_young_only_phase) {\n+    _young_rs_length_seq->add(rs_length);\n+  } else {\n+    _mixed_rs_length_seq->add(rs_length);\n+  }\n@@ -244,7 +259,3 @@\n-double G1Analytics::predict_young_card_merge_to_scan_ratio() const {\n-  return predict_in_unit_interval(_young_card_merge_to_scan_ratio_seq);\n-}\n-\n-size_t G1Analytics::predict_scan_card_num(size_t rs_length, bool for_young_gc) const {\n-  if (for_young_gc || !enough_samples_available(_mixed_card_merge_to_scan_ratio_seq)) {\n-    return (size_t)(rs_length * predict_young_card_merge_to_scan_ratio());\n+size_t G1Analytics::predict_scan_card_num(size_t rs_length, bool for_young_only_phase) const {\n+  if (for_young_only_phase || !enough_samples_available(_mixed_card_scan_to_merge_ratio_seq)) {\n+    return (size_t)(rs_length * predict_in_unit_interval(_young_card_scan_to_merge_ratio_seq));\n@@ -252,1 +263,1 @@\n-    return (size_t)(rs_length * predict_in_unit_interval(_mixed_card_merge_to_scan_ratio_seq));\n+    return (size_t)(rs_length * predict_in_unit_interval(_mixed_card_scan_to_merge_ratio_seq));\n@@ -256,2 +267,2 @@\n-double G1Analytics::predict_card_merge_time_ms(size_t card_num, bool for_young_gc) const {\n-  if (for_young_gc || !enough_samples_available(_mixed_cost_per_card_merge_ms_seq)) {\n+double G1Analytics::predict_card_merge_time_ms(size_t card_num, bool for_young_only_phase) const {\n+  if  (for_young_only_phase || !enough_samples_available(_mixed_cost_per_card_merge_ms_seq)) {\n@@ -264,2 +275,2 @@\n-double G1Analytics::predict_card_scan_time_ms(size_t card_num, bool for_young_gc) const {\n-  if (for_young_gc || !enough_samples_available(_mixed_cost_per_card_scan_ms_seq)) {\n+double G1Analytics::predict_card_scan_time_ms(size_t card_num, bool for_young_only_phase) const {\n+  if  (for_young_only_phase || !enough_samples_available(_mixed_cost_per_card_scan_ms_seq)) {\n@@ -308,2 +319,6 @@\n-size_t G1Analytics::predict_rs_length() const {\n-  return predict_size(_rs_length_seq) + predict_size(_rs_length_diff_seq);\n+size_t G1Analytics::predict_rs_length(bool for_young_only_phase) const {\n+  if  (for_young_only_phase || !enough_samples_available(_mixed_rs_length_seq)) {\n+    return predict_size(_young_rs_length_seq) + predict_size(_young_rs_length_diff_seq);\n+  } else {\n+    return predict_size(_mixed_rs_length_seq) + predict_size(_mixed_rs_length_diff_seq);\n+  }\n@@ -312,2 +327,6 @@\n-size_t G1Analytics::predict_pending_cards() const {\n-  return predict_size(_pending_cards_seq);\n+size_t G1Analytics::predict_pending_cards(bool for_young_only_phase) const {\n+  if (for_young_only_phase || !enough_samples_available(_mixed_pending_cards_seq)) {\n+    return predict_size(_young_pending_cards_seq);\n+  } else {\n+    return predict_size(_mixed_pending_cards_seq);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.cpp","additions":56,"deletions":37,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -48,1 +48,2 @@\n-  TruncatedSeq* _rs_length_diff_seq;\n+  TruncatedSeq* _young_rs_length_diff_seq;\n+  TruncatedSeq* _mixed_rs_length_diff_seq;\n@@ -51,1 +52,1 @@\n-  \/\/ The ratio between the number of merged cards and actually scanned cards, for\n+  \/\/ The ratio between the number of scanned cards and actually merged cards, for\n@@ -53,2 +54,2 @@\n-  TruncatedSeq* _young_card_merge_to_scan_ratio_seq;\n-  TruncatedSeq* _mixed_card_merge_to_scan_ratio_seq;\n+  TruncatedSeq* _young_card_scan_to_merge_ratio_seq;\n+  TruncatedSeq* _mixed_card_scan_to_merge_ratio_seq;\n@@ -70,2 +71,4 @@\n-  TruncatedSeq* _pending_cards_seq;\n-  TruncatedSeq* _rs_length_seq;\n+  TruncatedSeq* _young_pending_cards_seq;\n+  TruncatedSeq* _mixed_pending_cards_seq;\n+  TruncatedSeq* _young_rs_length_seq;\n+  TruncatedSeq* _mixed_rs_length_seq;\n@@ -126,4 +129,4 @@\n-  void report_cost_per_card_scan_ms(double cost_per_remset_card_ms, bool for_young_gc);\n-  void report_cost_per_card_merge_ms(double cost_per_card_ms, bool for_young_gc);\n-  void report_card_merge_to_scan_ratio(double cards_per_entry_ratio, bool for_young_gc);\n-  void report_rs_length_diff(double rs_length_diff);\n+  void report_cost_per_card_scan_ms(double cost_per_remset_card_ms, bool for_young_only_phase);\n+  void report_cost_per_card_merge_ms(double cost_per_card_ms, bool for_young_only_phase);\n+  void report_card_scan_to_merge_ratio(double cards_per_entry_ratio, bool for_young_only_phase);\n+  void report_rs_length_diff(double rs_length_diff, bool for_young_only_phase);\n@@ -134,2 +137,2 @@\n-  void report_pending_cards(double pending_cards);\n-  void report_rs_length(double rs_length);\n+  void report_pending_cards(double pending_cards, bool for_young_only_phase);\n+  void report_rs_length(double rs_length, bool for_young_only_phase);\n@@ -142,1 +145,0 @@\n-  double predict_young_card_merge_to_scan_ratio() const;\n@@ -144,1 +146,3 @@\n-  double predict_mixed_card_merge_to_scan_ratio() const;\n+  \/\/ Predict how many of the given remembered set of length rs_length will add to\n+  \/\/ the number of total cards scanned.\n+  size_t predict_scan_card_num(size_t rs_length, bool for_young_only_phase) const;\n@@ -146,4 +150,2 @@\n-  size_t predict_scan_card_num(size_t rs_length, bool for_young_gc) const;\n-\n-  double predict_card_merge_time_ms(size_t card_num, bool for_young_gc) const;\n-  double predict_card_scan_time_ms(size_t card_num, bool for_young_gc) const;\n+  double predict_card_merge_time_ms(size_t card_num, bool for_young_only_phase) const;\n+  double predict_card_scan_time_ms(size_t card_num, bool for_young_only_phase) const;\n@@ -165,2 +167,2 @@\n-  size_t predict_rs_length() const;\n-  size_t predict_pending_cards() const;\n+  size_t predict_rs_length(bool for_young_only_phase) const;\n+  size_t predict_pending_cards(bool for_young_only_phase) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -103,3 +103,1 @@\n-  \/\/ Returns the number of dirtied cards that were not yet dirty. This result may\n-  \/\/ be inaccurate as it does not perform the dirtying atomically.\n-  inline size_t mark_range_dirty(size_t start_card_index, size_t num_cards);\n+  inline void mark_range_dirty(size_t start_card_index, size_t num_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-inline size_t G1CardTable::mark_range_dirty(size_t start_card_index, size_t num_cards) {\n+inline void G1CardTable::mark_range_dirty(size_t start_card_index, size_t num_cards) {\n@@ -50,2 +50,0 @@\n-  size_t result = 0;\n-\n@@ -60,1 +58,0 @@\n-      result += sizeof(value);\n@@ -70,1 +67,0 @@\n-          result++;\n@@ -77,2 +73,0 @@\n-\n-  return result;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.inline.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -424,1 +424,1 @@\n-  double predicted_base_time_ms = _policy->predict_base_elapsed_time_ms(pending_cards);\n+  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    MergeRSDirtyCards,\n+    MergeRSCards,\n@@ -122,1 +122,1 @@\n-      \"Dirty Cards\" };\n+      \"Merged Cards\" };\n@@ -393,1 +393,4 @@\n-    return _cur_collection_initial_evac_time_ms + _cur_optional_evac_time_ms;\n+    return _cur_collection_initial_evac_time_ms +\n+           _cur_optional_evac_time_ms +\n+           _cur_merge_heap_roots_time_ms +\n+           _cur_optional_merge_heap_roots_time_ms;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-  _rs_length_prediction(0),\n@@ -183,11 +182,5 @@\n-  \/\/ One could argue that any useful eden length to keep any MMU wouldn't be zero, but\n-  \/\/ in theory this is possible. Other constraints enforce a minimum eden size of one\n-  \/\/ region anyway.\n-  uint desired_min_length = 0;\n-  if (use_adaptive_young_list_length()) {\n-    double now_sec = os::elapsedTime();\n-    double when_ms = _mmu_tracker->when_max_gc_sec(now_sec) * 1000.0;\n-    double alloc_rate_ms = _analytics->predict_alloc_rate_ms();\n-    desired_min_length = (uint) ceil(alloc_rate_ms * when_ms);\n-  }\n-  return desired_min_length;\n+  assert(use_adaptive_young_list_length(), \"precondition\");\n+  double now_sec = os::elapsedTime();\n+  double when_ms = _mmu_tracker->when_max_gc_sec(now_sec) * 1000.0;\n+  double alloc_rate_ms = _analytics->predict_alloc_rate_ms();\n+  return (uint) ceil(alloc_rate_ms * when_ms);\n@@ -197,1 +190,3 @@\n-  update_young_length_bounds(_analytics->predict_rs_length());\n+  bool for_young_only_phase = collector_state()->in_young_only_phase();\n+  update_young_length_bounds(_analytics->predict_pending_cards(for_young_only_phase),\n+                             _analytics->predict_rs_length(for_young_only_phase));\n@@ -200,2 +195,4 @@\n-void G1Policy::update_young_length_bounds(size_t rs_length) {\n-  _young_list_desired_length = calculate_young_desired_length(rs_length);\n+void G1Policy::update_young_length_bounds(size_t pending_cards, size_t rs_length) {\n+  uint old_young_list_target_length = _young_list_target_length;\n+\n+  _young_list_desired_length = calculate_young_desired_length(pending_cards, rs_length);\n@@ -205,1 +202,4 @@\n-  log_debug(gc, ergo, heap)(\"Young list lengths: desired: %u, target: %u, max: %u\",\n+  log_trace(gc, ergo, heap)(\"Young list length update: pending cards %zu rs_length %zu old target %u desired: %u target: %u max: %u\",\n+                            pending_cards,\n+                            rs_length,\n+                            old_young_list_target_length,\n@@ -224,1 +224,1 @@\n-uint G1Policy::calculate_young_desired_length(size_t rs_length) const {\n+uint G1Policy::calculate_young_desired_length(size_t pending_cards, size_t rs_length) const {\n@@ -259,2 +259,1 @@\n-    const size_t pending_cards = _analytics->predict_pending_cards();\n-    double survivor_base_time_ms = predict_base_elapsed_time_ms(pending_cards, rs_length);\n+    double base_time_ms = predict_base_time_ms(pending_cards, rs_length);\n@@ -263,1 +262,1 @@\n-      calculate_desired_eden_length_by_pause(survivor_base_time_ms,\n+      calculate_desired_eden_length_by_pause(base_time_ms,\n@@ -479,1 +478,1 @@\n-uint G1Policy::calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,\n+uint G1Policy::calculate_desired_eden_length_before_mixed(double base_time_ms,\n@@ -486,1 +485,1 @@\n-  double predicted_region_evac_time_ms = survivor_base_time_ms;\n+  double predicted_region_evac_time_ms = base_time_ms;\n@@ -489,1 +488,1 @@\n-    predicted_region_evac_time_ms += predict_region_total_time_ms(r, false);\n+    predicted_region_evac_time_ms += predict_region_total_time_ms(r, false \/* for_young_only_phase *\/);\n@@ -519,1 +518,1 @@\n-void G1Policy::revise_young_list_target_length_if_necessary(size_t rs_length) {\n+void G1Policy::revise_young_list_target_length(size_t rs_length) {\n@@ -522,16 +521,4 @@\n-  if (rs_length > _rs_length_prediction) {\n-    \/\/ add 10% to avoid having to recalculate often\n-    size_t rs_length_prediction = rs_length * 1100 \/ 1000;\n-    update_rs_length_prediction(rs_length_prediction);\n-    update_young_length_bounds(rs_length_prediction);\n-  }\n-}\n-\n-void G1Policy::update_rs_length_prediction() {\n-  update_rs_length_prediction(_analytics->predict_rs_length());\n-}\n-\n-void G1Policy::update_rs_length_prediction(size_t prediction) {\n-  if (collector_state()->in_young_only_phase() && use_adaptive_young_list_length()) {\n-    _rs_length_prediction = prediction;\n-  }\n+  G1DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();\n+  \/\/ We have no measure of the number of cards in the thread buffers, assume\n+  \/\/ these are very few compared to the ones in the DCQS.\n+  update_young_length_bounds(dcqs.num_cards(), rs_length);\n@@ -572,1 +559,0 @@\n-  update_rs_length_prediction();\n@@ -696,1 +682,1 @@\n-  return other_time_ms(pause_time_ms) - phase_times()->total_rebuild_freelist_time_ms();\n+  return other_time_ms(pause_time_ms) - (young_other_time_ms() + non_young_other_time_ms());\n@@ -752,0 +738,1 @@\n+  bool is_young_only_pause = G1GCPauseTypeHelper::is_young_only_pause(this_pause);\n@@ -805,1 +792,1 @@\n-    assert(G1GCPauseTypeHelper::is_young_only_pause(this_pause), \"must be\");\n+    assert(is_young_only_pause, \"must be\");\n@@ -812,12 +799,10 @@\n-    size_t const total_log_buffer_cards = p->sum_thread_work_items(G1GCPhaseTimes::MergeHCC, G1GCPhaseTimes::MergeHCCDirtyCards) +\n-                                          p->sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);\n-    \/\/ Update prediction for card merge; MergeRSDirtyCards includes the cards from the Eager Reclaim phase.\n-    size_t const total_cards_merged = p->sum_thread_work_items(G1GCPhaseTimes::MergeRS, G1GCPhaseTimes::MergeRSDirtyCards) +\n-                                      p->sum_thread_work_items(G1GCPhaseTimes::OptMergeRS, G1GCPhaseTimes::MergeRSDirtyCards) +\n-                                      total_log_buffer_cards;\n-\n-    \/\/ The threshold for the number of cards in a given sampling which we consider\n-    \/\/ large enough so that the impact from setup and other costs is negligible.\n-    size_t const CardsNumSamplingThreshold = 10;\n-\n-    if (total_cards_merged > CardsNumSamplingThreshold) {\n+    \/\/ Update prediction for card merge.\n+    size_t const merged_cards_from_log_buffers = p->sum_thread_work_items(G1GCPhaseTimes::MergeHCC, G1GCPhaseTimes::MergeHCCDirtyCards) +\n+                                                 p->sum_thread_work_items(G1GCPhaseTimes::MergeLB, G1GCPhaseTimes::MergeLBDirtyCards);\n+    \/\/ MergeRSCards includes the cards from the Eager Reclaim phase.\n+    size_t const merged_cards_from_rs = p->sum_thread_work_items(G1GCPhaseTimes::MergeRS, G1GCPhaseTimes::MergeRSCards) +\n+                                        p->sum_thread_work_items(G1GCPhaseTimes::OptMergeRS, G1GCPhaseTimes::MergeRSCards);\n+    size_t const total_cards_merged = merged_cards_from_rs +\n+                                      merged_cards_from_log_buffers;\n+\n+    if (total_cards_merged >= G1NumCardsCostSampleThreshold) {\n@@ -829,2 +814,1 @@\n-      _analytics->report_cost_per_card_merge_ms(avg_time_merge_cards \/ total_cards_merged,\n-                                                G1GCPauseTypeHelper::is_young_only_pause(this_pause));\n+      _analytics->report_cost_per_card_merge_ms(avg_time_merge_cards \/ total_cards_merged, is_young_only_pause);\n@@ -837,1 +821,1 @@\n-    if (total_cards_scanned > CardsNumSamplingThreshold) {\n+    if (total_cards_scanned >= G1NumCardsCostSampleThreshold) {\n@@ -841,2 +825,1 @@\n-      _analytics->report_cost_per_card_scan_ms(avg_time_dirty_card_scan \/ total_cards_scanned,\n-                                               G1GCPauseTypeHelper::is_young_only_pause(this_pause));\n+      _analytics->report_cost_per_card_scan_ms(avg_time_dirty_card_scan \/ total_cards_scanned, is_young_only_pause);\n@@ -847,3 +830,1 @@\n-    \/\/ Cards from the remembered sets are all cards not duplicated by cards from\n-    \/\/ the logs.\n-    \/\/ Due to duplicates in the log buffers, the number of actually scanned cards\n+    \/\/ Due to duplicates in the log buffers, the number of scanned cards\n@@ -851,4 +832,4 @@\n-    const size_t from_rs_length_cards = (total_cards_scanned > total_log_buffer_cards) ? total_cards_scanned - total_log_buffer_cards : 0;\n-    double merge_to_scan_ratio = 0.0;\n-    if (total_cards_scanned > 0) {\n-      merge_to_scan_ratio = (double) from_rs_length_cards \/ total_cards_scanned;\n+    const size_t scanned_cards_from_rs = (total_cards_scanned > merged_cards_from_log_buffers) ? total_cards_scanned - merged_cards_from_log_buffers : 0;\n+    double scan_to_merge_ratio = 0.0;\n+    if (merged_cards_from_rs > 0) {\n+      scan_to_merge_ratio = (double)scanned_cards_from_rs \/ merged_cards_from_rs;\n@@ -856,2 +837,1 @@\n-    _analytics->report_card_merge_to_scan_ratio(merge_to_scan_ratio,\n-                                                G1GCPauseTypeHelper::is_young_only_pause(this_pause));\n+    _analytics->report_card_scan_to_merge_ratio(scan_to_merge_ratio, is_young_only_pause);\n@@ -861,1 +841,1 @@\n-    _analytics->report_rs_length_diff(rs_length_diff);\n+    _analytics->report_rs_length_diff(rs_length_diff, is_young_only_pause);\n@@ -886,5 +866,2 @@\n-    \/\/ During mixed gc we do not use them for young gen sizing.\n-    if (G1GCPauseTypeHelper::is_young_only_pause(this_pause)) {\n-      _analytics->report_pending_cards((double) _pending_cards_at_gc_start);\n-      _analytics->report_rs_length((double) _rs_length);\n-    }\n+    _analytics->report_pending_cards((double) _pending_cards_at_gc_start, is_young_only_pause);\n+    _analytics->report_rs_length((double) _rs_length, is_young_only_pause);\n@@ -901,1 +878,0 @@\n-  update_rs_length_prediction();\n@@ -917,1 +893,1 @@\n-    \/\/ the marking threads may have received an uncharacterisic amount of cpu time\n+    \/\/ the marking threads may have received an uncharacteristic amount of cpu time\n@@ -1011,8 +987,21 @@\n-double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards,\n-                                              size_t rs_length) const {\n-  size_t effective_scanned_cards = _analytics->predict_scan_card_num(rs_length, collector_state()->in_young_only_phase());\n-  return\n-    _analytics->predict_card_merge_time_ms(pending_cards + rs_length, collector_state()->in_young_only_phase()) +\n-    _analytics->predict_card_scan_time_ms(effective_scanned_cards, collector_state()->in_young_only_phase()) +\n-    _analytics->predict_constant_other_time_ms() +\n-    predict_survivor_regions_evac_time();\n+double G1Policy::predict_base_time_ms(size_t pending_cards,\n+                                      size_t rs_length) const {\n+  bool in_young_only_phase = collector_state()->in_young_only_phase();\n+\n+  size_t unique_cards_from_rs = _analytics->predict_scan_card_num(rs_length, in_young_only_phase);\n+  \/\/ Assume that all cards from the log buffers will be scanned, i.e. there are no\n+  \/\/ duplicates in that set.\n+  size_t effective_scanned_cards = unique_cards_from_rs + pending_cards;\n+\n+  double card_merge_time = _analytics->predict_card_merge_time_ms(pending_cards + rs_length, in_young_only_phase);\n+  double card_scan_time = _analytics->predict_card_scan_time_ms(effective_scanned_cards, in_young_only_phase);\n+  double constant_other_time = _analytics->predict_constant_other_time_ms();\n+  double survivor_evac_time = predict_survivor_regions_evac_time();\n+\n+  double total_time = card_merge_time + card_scan_time + constant_other_time + survivor_evac_time;\n+\n+  log_trace(gc, ergo, heap)(\"Predicted base time: total %f lb_cards %zu rs_length %zu effective_scanned_cards %zu \"\n+                            \"card_merge_time %f card_scan_time %f constant_other_time %f survivor_evac_time %f\",\n+                            total_time, pending_cards, rs_length, effective_scanned_cards,\n+                            card_merge_time, card_scan_time, constant_other_time, survivor_evac_time);\n+  return total_time;\n@@ -1021,3 +1010,4 @@\n-double G1Policy::predict_base_elapsed_time_ms(size_t pending_cards) const {\n-  size_t rs_length = _analytics->predict_rs_length();\n-  return predict_base_elapsed_time_ms(pending_cards, rs_length);\n+double G1Policy::predict_base_time_ms(size_t pending_cards) const {\n+  bool for_young_only_phase = collector_state()->in_young_only_phase();\n+  size_t rs_length = _analytics->predict_rs_length(for_young_only_phase);\n+  return predict_base_time_ms(pending_cards, rs_length);\n@@ -1053,1 +1043,1 @@\n-                                                 bool for_young_gc) const {\n+                                                 bool for_young_only_phase) const {\n@@ -1055,1 +1045,1 @@\n-  size_t scan_card_num = _analytics->predict_scan_card_num(rs_length, for_young_gc);\n+  size_t scan_card_num = _analytics->predict_scan_card_num(rs_length, for_young_only_phase);\n@@ -1071,2 +1061,2 @@\n-double G1Policy::predict_region_total_time_ms(HeapRegion* hr, bool for_young_gc) const {\n-  return predict_region_non_copy_time_ms(hr, for_young_gc) + predict_region_copy_time_ms(hr);\n+double G1Policy::predict_region_total_time_ms(HeapRegion* hr, bool for_young_only_phase) const {\n+  return predict_region_non_copy_time_ms(hr, for_young_only_phase) + predict_region_copy_time_ms(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":82,"deletions":92,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -107,2 +107,0 @@\n-  size_t _rs_length_prediction;\n-\n@@ -140,1 +138,1 @@\n-  double predict_base_elapsed_time_ms(size_t num_pending_cards) const;\n+  double predict_base_time_ms(size_t pending_cards) const;\n@@ -143,1 +141,1 @@\n-  double predict_base_elapsed_time_ms(size_t num_pending_cards, size_t rs_length) const;\n+  double predict_base_time_ms(size_t pending_cards, size_t rs_length) const;\n@@ -150,2 +148,2 @@\n-  double predict_region_non_copy_time_ms(HeapRegion* hr, bool for_young_gc) const;\n-  double predict_region_total_time_ms(HeapRegion* hr, bool for_young_gc) const;\n+  double predict_region_non_copy_time_ms(HeapRegion* hr, bool for_young_only_phase) const;\n+  double predict_region_total_time_ms(HeapRegion* hr, bool for_young_only_phase) const;\n@@ -197,2 +195,2 @@\n-  \/\/ If no rs_length parameter is passed, predict the RS length using the\n-  \/\/ prediction model, otherwise use the given rs_length as the prediction.\n+  \/\/ If no parameters are passed, predict pending cards and the RS length using\n+  \/\/ the prediction model.\n@@ -200,1 +198,1 @@\n-  void update_young_length_bounds(size_t rs_length);\n+  void update_young_length_bounds(size_t pending_cards, size_t rs_length);\n@@ -222,1 +220,1 @@\n-  uint calculate_desired_eden_length_before_mixed(double survivor_base_time_ms,\n+  uint calculate_desired_eden_length_before_mixed(double base_time_ms,\n@@ -228,1 +226,1 @@\n-  uint calculate_young_desired_length(size_t rs_length) const;\n+  uint calculate_young_desired_length(size_t pending_cards, size_t rs_length) const;\n@@ -235,3 +233,0 @@\n-  void update_rs_length_prediction();\n-  void update_rs_length_prediction(size_t prediction);\n-\n@@ -298,1 +293,1 @@\n-  void revise_young_list_target_length_if_necessary(size_t rs_length);\n+  void revise_young_list_target_length(size_t rs_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -541,1 +541,1 @@\n-        policy->revise_young_list_target_length_if_necessary(cl.sampled_rs_length());\n+        policy->revise_young_list_target_length(cl.sampled_rs_length());\n@@ -1119,2 +1119,2 @@\n-    void inc_cards_dirty(size_t increment = 1) {\n-      _merged[G1GCPhaseTimes::MergeRSDirtyCards] += increment;\n+    void inc_remset_cards(size_t increment = 1) {\n+      _merged[G1GCPhaseTimes::MergeRSCards] += increment;\n@@ -1175,1 +1175,0 @@\n-        _stats.inc_cards_dirty();\n@@ -1178,0 +1177,1 @@\n+      _stats.inc_remset_cards();\n@@ -1198,1 +1198,1 @@\n-      assert(tag < G1GCPhaseTimes::MergeRSDirtyCards, \"invalid tag %u\", tag);\n+      assert(tag < G1GCPhaseTimes::MergeRSCards, \"invalid tag %u\", tag);\n@@ -1208,2 +1208,2 @@\n-      size_t num_dirtied = _ct->mark_range_dirty(_region_base_idx + start_card_idx, length);\n-      _stats.inc_cards_dirty(num_dirtied);\n+      _ct->mark_range_dirty(_region_base_idx + start_card_idx, length);\n+      _stats.inc_remset_cards(length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-bool G1YoungGCEvacFailureInjector::arm_if_needed_for_gc_type(bool for_young_gc,\n+bool G1YoungGCEvacFailureInjector::arm_if_needed_for_gc_type(bool for_young_only_phase,\n@@ -70,1 +70,1 @@\n-  if (for_young_gc) {\n+  if (for_young_only_phase) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  bool arm_if_needed_for_gc_type(bool for_young_gc,\n+  bool arm_if_needed_for_gc_type(bool for_young_only_phase,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -380,0 +380,5 @@\n+  product(uint, G1NumCardsCostSampleThreshold, 1000, DIAGNOSTIC,            \\\n+          \"Threshold for the number of cards when reporting card cost \"     \\\n+          \"related prediction sample. That sample must involve the same or \"\\\n+          \"more than that number of cards to be used.\")                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-  double region_elapsed_time_ms = policy->predict_region_total_time_ms(this, false \/* for_young_gc *\/);\n+  double region_elapsed_time_ms = policy->predict_region_total_time_ms(this, false \/* for_young_only_phase *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-  _lines = new (ResourceObj::C_HEAP, mtGC) stringStream();\n-  _temp = new (ResourceObj::C_HEAP, mtGC) stringStream();\n+  _lines = new (mtGC) stringStream();\n+  _temp = new (mtGC) stringStream();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,4 @@\n-  \/\/ This function clears the memory of the object\n+  \/\/ Initialization provided by subclasses.\n+  virtual oop initialize(HeapWord* mem) const = 0;\n+\n+  \/\/ This function clears the memory of the object.\n@@ -61,0 +64,1 @@\n+\n@@ -64,1 +68,1 @@\n-  virtual oop finish(HeapWord* mem) const;\n+  oop finish(HeapWord* mem) const;\n@@ -75,0 +79,1 @@\n+  \/\/ Allocate and fully construct the object, and perform various instrumentation. Could safepoint.\n@@ -77,1 +82,0 @@\n-  virtual oop initialize(HeapWord* mem) const = 0;\n@@ -96,0 +100,1 @@\n+protected:\n@@ -98,1 +103,1 @@\n-protected:\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -808,0 +808,4 @@\n+OopStorage* OopStorage::create(const char* name, MEMFLAGS memflags) {\n+  return new (memflags) OopStorage(name, memflags);\n+}\n+\n@@ -818,9 +822,0 @@\n-void* OopStorage::operator new(size_t size, MEMFLAGS memflags) {\n-  assert(size >= sizeof(OopStorage), \"precondition\");\n-  return NEW_C_HEAP_ARRAY(char, size, memflags);\n-}\n-\n-void OopStorage::operator delete(void* obj, MEMFLAGS \/* memflags *\/) {\n-  FREE_C_HEAP_ARRAY(char, obj);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-class OopStorage {\n+class OopStorage : public CHeapObjBase {\n@@ -77,1 +77,1 @@\n-  explicit OopStorage(const char* name, MEMFLAGS memflags);\n+  static OopStorage* create(const char* name, MEMFLAGS memflags);\n@@ -80,3 +80,0 @@\n-  void* operator new(size_t size, MEMFLAGS memflags);\n-  void operator delete(void* obj, MEMFLAGS memflags);\n-\n@@ -285,0 +282,4 @@\n+  \/\/ Clients construct via \"create\" factory function.\n+  OopStorage(const char* name, MEMFLAGS memflags);\n+  NONCOPYABLE(OopStorage);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  OopStorage* storage = new (memflags) OopStorage(name, memflags);\n+  OopStorage* storage = OopStorage::create(name, memflags);\n@@ -45,1 +45,1 @@\n-  OopStorage* storage = new (memflags) OopStorage(name, memflags);\n+  OopStorage* storage = OopStorage::create(name, memflags);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-  _alloc_failure_waiters_lock(Mutex::safepoint-1, \"ShenandoahAllocFailureGC_lock\", true),\n-  _gc_waiters_lock(Mutex::safepoint-1, \"ShenandoahRequestedGC_lock\", true),\n+  _alloc_failure_waiters_lock(Mutex::safepoint-2, \"ShenandoahAllocFailureGC_lock\", true),\n+  _gc_waiters_lock(Mutex::safepoint-2, \"ShenandoahRequestedGC_lock\", true),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,5 +164,1 @@\n-  if (!do_zero) {\n-    return CollectedHeap::array_allocate(klass, size, length, false \/* do_zero *\/, THREAD);\n-  }\n-\n-  ZObjArrayAllocator allocator(klass, size, length, THREAD);\n+  ZObjArrayAllocator allocator(klass, size, length, do_zero, THREAD);\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -224,0 +225,3 @@\n+  \/\/ Verification\n+  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_strong);\n+\n@@ -338,0 +342,4 @@\n+\n+  \/\/ Clear old markings claim bits.\n+  \/\/ Note: Clearing _claim_strong also clears _claim_finalizable.\n+  ClassLoaderDataGraph::clear_claimed_marks(ClassLoaderData::_claim_strong);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"classfile\/classLoaderData.hpp\"\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -239,0 +239,3 @@\n+\n+  \/\/ Clear claimed CLD bits\n+  ClassLoaderDataGraph::clear_claimed_marks(ClassLoaderData::_claim_other);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -31,2 +32,2 @@\n-ZObjArrayAllocator::ZObjArrayAllocator(Klass* klass, size_t word_size, int length, Thread* thread) :\n-    ObjArrayAllocator(klass, word_size, length, false \/* do_zero *\/, thread) {}\n+ZObjArrayAllocator::ZObjArrayAllocator(Klass* klass, size_t word_size, int length, bool do_zero, Thread* thread) :\n+    ObjArrayAllocator(klass, word_size, length, do_zero, thread) {}\n@@ -34,3 +35,3 @@\n-oop ZObjArrayAllocator::finish(HeapWord* mem) const {\n-  \/\/ Initialize object header and length field\n-  ObjArrayAllocator::finish(mem);\n+void ZObjArrayAllocator::yield_for_safepoint() const {\n+  ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n+}\n@@ -38,4 +39,8 @@\n-  \/\/ Keep the array alive across safepoints through an invisible\n-  \/\/ root. Invisible roots are not visited by the heap itarator\n-  \/\/ and the marking logic will not attempt to follow its elements.\n-  ZThreadLocalData::set_invisible_root(_thread, (oop*)&mem);\n+oop ZObjArrayAllocator::initialize(HeapWord* mem) const {\n+  \/\/ ZGC specializes the initialization by performing segmented clearing\n+  \/\/ to allow shorter time-to-safepoints.\n+\n+  if (!_do_zero) {\n+    \/\/ No need for ZGC specialization\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n@@ -47,2 +52,30 @@\n-  const size_t skip = arrayOopDesc::header_size(ArrayKlass::cast(_klass)->element_type());\n-  size_t remaining = _word_size - skip;\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t header = arrayOopDesc::header_size(element_type);\n+  const size_t payload_size = _word_size - header;\n+\n+  if (payload_size <= segment_max) {\n+    \/\/ To small to use segmented clearing\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n+\n+  \/\/ Segmented clearing\n+\n+  \/\/ The array is going to be exposed before it has been completely\n+  \/\/ cleared, therefore we can't expose the header at the end of this\n+  \/\/ function. Instead explicitly initialize it according to our needs.\n+  arrayOopDesc::set_mark(mem, Klass::default_prototype_header(_klass));\n+  arrayOopDesc::release_set_klass(mem, _klass);\n+  assert(_length >= 0, \"length should be non-negative\");\n+  arrayOopDesc::set_length(mem, _length);\n+\n+  \/\/ Keep the array alive across safepoints through an invisible\n+  \/\/ root. Invisible roots are not visited by the heap itarator\n+  \/\/ and the marking logic will not attempt to follow its elements.\n+  \/\/ Relocation knows how to dodge iterating over such objects.\n+  ZThreadLocalData::set_invisible_root(_thread, (oop*)&mem);\n+\n+  for (size_t processed = 0; processed < payload_size; processed += segment_max) {\n+    \/\/ Calculate segment\n+    HeapWord* const start = (HeapWord*)(mem + header + processed);\n+    const size_t remaining = payload_size - processed;\n+    const size_t segment_size = MIN2(remaining, segment_max);\n@@ -50,1 +83,0 @@\n-  while (remaining > 0) {\n@@ -52,3 +84,1 @@\n-    const size_t segment = MIN2(remaining, segment_max);\n-    Copy::zero_to_words(mem + (_word_size - remaining), segment);\n-    remaining -= segment;\n+    Copy::zero_to_words(start, segment_size);\n@@ -56,4 +86,2 @@\n-    if (remaining > 0) {\n-      \/\/ Safepoint\n-      ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n-    }\n+    \/\/ Safepoint\n+    yield_for_safepoint();\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":47,"deletions":19,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -30,2 +30,4 @@\n-public:\n-  ZObjArrayAllocator(Klass* klass, size_t word_size, int length, Thread* thread);\n+private:\n+  virtual oop initialize(HeapWord* mem) const override;\n+\n+  void yield_for_safepoint() const;\n@@ -33,1 +35,2 @@\n-  virtual oop finish(HeapWord* mem) const;\n+public:\n+  ZObjArrayAllocator(Klass* klass, size_t word_size, int length, bool do_zero, Thread* thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    ClassLoaderDataGraph::clear_claimed_marks(cld_claim);\n+    ClassLoaderDataGraph::verify_claimed_marks_cleared(cld_claim);\n","filename":"src\/hotspot\/share\/gc\/z\/zRootsIterator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 14\n+#define CURRENT_CDS_ARCHIVE_VERSION 15\n@@ -58,1 +58,2 @@\n-  size_t  _oopmap_offset;     \/\/ Bitmap for relocating embedded oops (offset from SharedBaseAddress).\n+  size_t  _oopmap_offset;     \/\/ Bitmap for relocating oop fields in archived heap objects.\n+                              \/\/ (The base address is the bottom of the BM region)\n@@ -60,0 +61,3 @@\n+  size_t  _ptrmap_offset;     \/\/ Bitmap for relocating native pointer fields in archived heap objects.\n+                              \/\/ (The base address is the bottom of the BM region).\n+  size_t  _ptrmap_size_in_bits;\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-#if defined(AMD64) || defined(AARCH64)\n+#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-#if defined(AMD64) || defined(AARCH64)\n+#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n@@ -360,1 +360,0 @@\n-  if (PrintBytecodeHistogram)                                    histogram_bytecode(t);\n@@ -364,0 +363,1 @@\n+  if (PrintBytecodeHistogram)                                    histogram_bytecode(t);\n@@ -437,1 +437,1 @@\n-#if defined(AMD64) || defined(AARCH64)\n+#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-#if defined(AMD64) || defined(AARCH64)\n+#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,3 +280,1 @@\n-  if (periodMillis > 0) {\n-    JfrEventSetting::set_enabled(typed_event_id, true); \/\/ ensure sampling event is enabled\n-  }\n+  JfrEventSetting::set_enabled(typed_event_id, periodMillis > 0);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-  <Event name=\"JitRestart\" category=\"Java Virtual Machine, Compiler\" label=\"JIT Restart\" stackTrace=\"false\" startTime=\"false\" thread=\"true\">\n+  <Event name=\"JITRestart\" category=\"Java Virtual Machine, Compiler\" label=\"JIT Restart\" stackTrace=\"false\" startTime=\"false\" thread=\"true\">\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -302,2 +302,4 @@\n-    for (uint i = 0; i < _added_java; ++i) {\n-      _events[i].commit();\n+    if (EventExecutionSample::is_enabled()) {\n+      for (uint i = 0; i < _added_java; ++i) {\n+        _events[i].commit();\n+      }\n@@ -308,2 +310,4 @@\n-    for (uint i = 0; i < _added_native; ++i) {\n-      _events_native[i].commit();\n+    if (EventNativeMethodSample::is_enabled()) {\n+      for (uint i = 0; i < _added_native; ++i) {\n+        _events_native[i].commit();\n+      }\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+typedef JfrCheckpointManager::ConstBufferPtr ConstBufferPtr;\n@@ -80,2 +81,3 @@\n-  _global_mspace(NULL),\n-  _thread_local_mspace(NULL),\n+  _global_mspace(nullptr),\n+  _thread_local_mspace(nullptr),\n+  _virtual_thread_local_mspace(nullptr),\n@@ -94,2 +96,5 @@\n-static const size_t thread_local_buffer_prealloc_count = 32;\n-static const size_t thread_local_buffer_size = 4 * K;\n+static const size_t thread_local_buffer_prealloc_count = 16;\n+static const size_t thread_local_buffer_size = 256;\n+\n+static const size_t virtual_thread_local_buffer_prealloc_count = 0;\n+static const size_t virtual_thread_local_buffer_size = 4 * K;\n@@ -113,1 +118,1 @@\n-                                                                        JFR_MSPACE_UNLIMITED_CACHE_SIZE,\n+                                                                        thread_local_buffer_prealloc_count,\n@@ -117,0 +122,8 @@\n+\n+  assert(_virtual_thread_local_mspace == NULL, \"invariant\");\n+  _virtual_thread_local_mspace = new JfrThreadLocalCheckpointMspace();\n+  if (_virtual_thread_local_mspace == NULL || !_virtual_thread_local_mspace->initialize(virtual_thread_local_buffer_size,\n+                                                                                        JFR_MSPACE_UNLIMITED_CACHE_SIZE,\n+                                                                                        virtual_thread_local_buffer_prealloc_count)) {\n+    return false;\n+  }\n@@ -121,1 +134,1 @@\n-static void assert_lease(const BufferPtr buffer) {\n+static void assert_lease(ConstBufferPtr buffer) {\n@@ -127,1 +140,1 @@\n-static void assert_release(const BufferPtr buffer) {\n+static void assert_release(ConstBufferPtr buffer) {\n@@ -133,1 +146,1 @@\n-static void assert_retired(const BufferPtr buffer, Thread* thread) {\n+static void assert_retired(ConstBufferPtr buffer, Thread* thread) {\n@@ -145,1 +158,16 @@\n-BufferPtr JfrCheckpointManager::lease(Thread* thread, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n+static inline bool is_global(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_GLOBAL;\n+}\n+\n+static inline bool is_thread_local(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_THREADLOCAL;\n+}\n+\n+static inline bool is_virtual_thread_local(ConstBufferPtr buffer) {\n+  assert(buffer != NULL, \"invariant\");\n+  return buffer->context() == JFR_VIRTUAL_THREADLOCAL;\n+}\n+\n+BufferPtr JfrCheckpointManager::lease_global(Thread* thread, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n@@ -163,23 +191,9 @@\n-const u1 thread_local_context = 1;\n-\n-static bool is_thread_local(const JfrBuffer* buffer) {\n-  assert(buffer != NULL, \"invariant\");\n-  return buffer->context() == thread_local_context;\n-}\n-\n-static void retire(JfrBuffer* buffer) {\n-  DEBUG_ONLY(assert_release(buffer);)\n-  buffer->clear_lease();\n-  buffer->set_retired();\n-}\n-\n-\/*\n- * The buffer is effectively invalidated for the thread post-return,\n- * and the caller should take means to ensure that it is not referenced.\n- *\/\n-static void release(JfrBuffer* buffer) {\n-  DEBUG_ONLY(assert_release(buffer);)\n-  if (!is_thread_local(buffer)) {\n-    buffer->clear_lease();\n-    buffer->release();\n-  }\n+BufferPtr JfrCheckpointManager::lease_thread_local(Thread* thread, size_t size) {\n+  BufferPtr buffer = instance()._thread_local_mspace->acquire(size, thread);\n+  assert(buffer != nullptr, \"invariant\");\n+  assert(buffer->free_size() >= size, \"invariant\");\n+  buffer->set_lease();\n+  DEBUG_ONLY(assert_lease(buffer);)\n+  buffer->set_context(JFR_THREADLOCAL);\n+  assert(is_thread_local(buffer), \"invariant\");\n+  return buffer;\n@@ -188,1 +202,1 @@\n-BufferPtr JfrCheckpointManager::get_thread_local(Thread* thread) {\n+BufferPtr JfrCheckpointManager::get_virtual_thread_local(Thread* thread) {\n@@ -194,1 +208,1 @@\n-void JfrCheckpointManager::set_thread_local(Thread* thread, BufferPtr buffer) {\n+void JfrCheckpointManager::set_virtual_thread_local(Thread* thread, BufferPtr buffer) {\n@@ -203,4 +217,3 @@\n-BufferPtr JfrCheckpointManager::acquire_thread_local(size_t size, Thread* thread) {\n-  assert(thread != NULL, \"invariant\");\n-  JfrBuffer* const buffer = instance()._thread_local_mspace->acquire(size, thread);\n-  assert(buffer != NULL, \"invariant\");\n+BufferPtr JfrCheckpointManager::new_virtual_thread_local(Thread* thread, size_t size) {\n+  BufferPtr buffer = instance()._virtual_thread_local_mspace->acquire(size, thread);\n+  assert(buffer != nullptr, \"invariant\");\n@@ -208,4 +221,3 @@\n-  buffer->set_context(thread_local_context);\n-  assert(is_thread_local(buffer), \"invariant\");\n-  buffer->set_lease();\n-  set_thread_local(thread, buffer);\n+  buffer->set_context(JFR_VIRTUAL_THREADLOCAL);\n+  assert(is_virtual_thread_local(buffer), \"invariant\");\n+  set_virtual_thread_local(thread, buffer);\n@@ -215,7 +227,4 @@\n-BufferPtr JfrCheckpointManager::lease_thread_local(Thread* thread, size_t size \/* 0 *\/) {\n-  JfrBuffer* buffer = get_thread_local(thread);\n-  if (buffer == NULL) {\n-    buffer = acquire_thread_local(size, thread);\n-  } else if (buffer->free_size() < size) {\n-    retire(buffer);\n-    buffer = acquire_thread_local(size, thread);\n+BufferPtr JfrCheckpointManager::acquire_virtual_thread_local(Thread* thread, size_t size \/* 0 *\/) {\n+  BufferPtr buffer = get_virtual_thread_local(thread);\n+  if (buffer == nullptr || buffer->free_size() < size) {\n+    buffer = new_virtual_thread_local(thread, size);\n@@ -223,1 +232,1 @@\n-  DEBUG_ONLY(assert_lease(buffer);)\n+  assert(buffer->acquired_by_self(), \"invariant\");\n@@ -225,1 +234,2 @@\n-  assert(get_thread_local(thread) == buffer, \"invariant\");\n+  assert(get_virtual_thread_local(thread) == buffer, \"invariant\");\n+  assert(is_virtual_thread_local(buffer), \"invariant\");\n@@ -229,1 +239,1 @@\n-BufferPtr JfrCheckpointManager::lease(BufferPtr old, Thread* thread, size_t size) {\n+BufferPtr JfrCheckpointManager::renew(ConstBufferPtr old, Thread* thread, size_t size, JfrCheckpointBufferKind kind \/* JFR_THREADLOCAL *\/) {\n@@ -231,2 +241,42 @@\n-  return is_thread_local(old) ? acquire_thread_local(size, thread) :\n-                                lease(thread, instance()._global_mspace->in_previous_epoch_list(old), size);\n+  assert(old->acquired_by_self(), \"invariant\");\n+  if (kind == JFR_GLOBAL) {\n+    return lease_global(thread, instance()._global_mspace->in_previous_epoch_list(old), size);\n+  }\n+  return kind == JFR_THREADLOCAL ? lease_thread_local(thread, size) : acquire_virtual_thread_local(thread, size);\n+}\n+\n+BufferPtr JfrCheckpointManager::acquire(Thread* thread, JfrCheckpointBufferKind kind \/* JFR_THREADLOCAL *\/, bool previous_epoch \/* false *\/, size_t size \/* 0 *\/) {\n+  if (kind == JFR_GLOBAL) {\n+    return lease_global(thread, previous_epoch, size);\n+  }\n+  if (kind == JFR_THREADLOCAL) {\n+    return lease_thread_local(thread, size);\n+  }\n+  assert(kind == JFR_VIRTUAL_THREADLOCAL, \"invariant\");\n+  return acquire_virtual_thread_local(thread, size);\n+}\n+\n+static inline void retire(BufferPtr buffer) {\n+  assert(buffer != nullptr, \"invariant\");\n+  assert(buffer->acquired_by_self(), \"invariant\");\n+  buffer->set_retired();\n+}\n+\n+\/*\n+ * The buffer is effectively invalidated for the thread post-return,\n+ * and the caller should take means to ensure that it is not referenced.\n+ *\/\n+static inline void release(BufferPtr buffer) {\n+  DEBUG_ONLY(assert_release(buffer);)\n+  assert(!is_virtual_thread_local(buffer), \"invariant\");\n+  if (is_global(buffer)) {\n+    buffer->release();\n+    return;\n+  }\n+  assert(is_thread_local(buffer), \"invariant\");\n+  retire(buffer);\n+}\n+\n+static inline JfrCheckpointBufferKind kind(ConstBufferPtr buffer) {\n+  assert(buffer != nullptr, \"invariant\");\n+  return static_cast<JfrCheckpointBufferKind>(buffer->context());\n@@ -237,1 +287,0 @@\n-  assert(old->lease(), \"invariant\");\n@@ -240,0 +289,1 @@\n+    assert(old->lease(), \"invariant\");\n@@ -245,1 +295,1 @@\n-  BufferPtr new_buffer = lease(old, thread, used + requested);\n+  BufferPtr new_buffer = renew(old, thread, used + requested, kind(old));\n@@ -375,1 +425,1 @@\n-class ThreadLocalCheckpointWriteOp {\n+class VirtualThreadLocalCheckpointWriteOp {\n@@ -384,1 +434,1 @@\n-  ThreadLocalCheckpointWriteOp(JfrChunkWriter& cw) : _cw(cw), _begin_offset(cw.current_offset()), _elements_offset(0), _processed(0), _elements(0) {\n+  VirtualThreadLocalCheckpointWriteOp(JfrChunkWriter& cw) : _cw(cw), _begin_offset(cw.current_offset()), _elements_offset(0), _processed(0), _elements(0) {\n@@ -399,1 +449,1 @@\n-  ~ThreadLocalCheckpointWriteOp() {\n+  ~VirtualThreadLocalCheckpointWriteOp() {\n@@ -420,2 +470,1 @@\n-typedef ThreadLocalCheckpointWriteOp<JfrCheckpointManager::Buffer> ThreadLocalCheckpointOperation;\n-typedef MutexedWriteOp<ThreadLocalCheckpointOperation> ThreadLocalWriteOperation;\n+typedef MutexedWriteOp<WriteOperation> MutexedWriteOperation;\n@@ -423,2 +472,3 @@\n-typedef ExclusiveOp<WriteOperation> GlobalWriteOperation;\n-typedef CompositeOperation<GlobalWriteOperation, ReleaseOperation> GlobalWriteReleaseOperation;\n+typedef CompositeOperation<MutexedWriteOperation, ReleaseOperation> WriteReleaseOperation;\n+typedef VirtualThreadLocalCheckpointWriteOp<JfrCheckpointManager::Buffer> VirtualThreadLocalCheckpointOperation;\n+typedef MutexedWriteOp<VirtualThreadLocalCheckpointOperation> VirtualThreadLocalWriteOperation;\n@@ -441,1 +491,2 @@\n-  GlobalWriteOperation gwo(wo);\n+  MutexedWriteOperation mwo(wo);\n+  _thread_local_mspace->iterate(mwo, true); \/\/ previous epoch list\n@@ -443,8 +494,8 @@\n-  ReleaseOperation ro(_global_mspace, _global_mspace->live_list(true));\n-  GlobalWriteReleaseOperation gwro(&gwo, &ro);\n-  process_live_list(gwro, _global_mspace, true); \/\/ previous epoch list\n-  \/\/ Do thread local list after global. Careful, the tlco destructor writes to chunk.\n-  ThreadLocalCheckpointOperation tlco(_chunkwriter);\n-  ThreadLocalWriteOperation tlwo(tlco);\n-  _thread_local_mspace->iterate(tlwo, true); \/\/ previous epoch list\n-  return wo.processed() + tlco.processed();\n+  ReleaseOperation ro(_global_mspace, _global_mspace->live_list(true)); \/\/ previous epoch list\n+  WriteReleaseOperation wro(&mwo, &ro);\n+  process_live_list(wro, _global_mspace, true); \/\/ previous epoch list\n+  \/\/ Do virtual thread local list last. Careful, the vtlco destructor writes to chunk.\n+  VirtualThreadLocalCheckpointOperation vtlco(_chunkwriter);\n+  VirtualThreadLocalWriteOperation vtlwo(vtlco);\n+  _virtual_thread_local_mspace->iterate(vtlwo, true); \/\/ previous epoch list\n+  return wo.processed() + vtlco.processed();\n@@ -453,3 +504,2 @@\n-typedef DiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > ThreadLocalDiscardOperation;\n-typedef ExclusiveDiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > GlobalDiscardOperation;\n-typedef CompositeOperation<GlobalDiscardOperation, ReleaseOperation> DiscardReleaseOperation;\n+typedef DiscardOp<DefaultDiscarder<JfrCheckpointManager::Buffer> > DiscardOperation;\n+typedef CompositeOperation<DiscardOperation, ReleaseOperation> DiscardReleaseOperation;\n@@ -460,3 +510,3 @@\n-  ThreadLocalDiscardOperation tldo(mutexed); \/\/ mutexed discard mode\n-  _thread_local_mspace->iterate(tldo, true); \/\/ previous epoch list\n-  GlobalDiscardOperation gdo(mutexed); \/\/ mutexed discard mode\n+  DiscardOperation dop(mutexed); \/\/ mutexed discard mode\n+  _thread_local_mspace->iterate(dop, true); \/\/ previous epoch list\n+  _virtual_thread_local_mspace->iterate(dop, true); \/\/ previous epoch list\n@@ -464,1 +514,1 @@\n-  DiscardReleaseOperation dro(&gdo, &ro);\n+  DiscardReleaseOperation dro(&dop, &ro);\n@@ -467,1 +517,1 @@\n-  return tldo.elements() + gdo.elements();\n+  return dop.elements();\n@@ -564,0 +614,3 @@\n+    WriteOperation wo(_chunkwriter);\n+    MutexedWriteOperation mwo(wo);\n+    _thread_local_mspace->iterate(mwo); \/\/ current epoch list\n@@ -566,9 +619,5 @@\n-    WriteOperation wo(_chunkwriter);\n-    GlobalWriteOperation gwo(wo);\n-    ReleaseOperation ro(_global_mspace, _global_mspace->live_list()); \/\/ current epoch list\n-    GlobalWriteReleaseOperation gwro(&gwo, &ro);\n-    process_live_list(gwro, _global_mspace); \/\/ current epoch list\n-    \/\/ Do thread local list after global. Careful, the tlco destructor writes to chunk.\n-    ThreadLocalCheckpointOperation tlco(_chunkwriter);\n-    ThreadLocalWriteOperation tlwo(tlco);\n-    _thread_local_mspace->iterate(tlwo); \/\/ current epoch list\n+    process_live_list(mwo, _global_mspace); \/\/ current epoch list\n+    \/\/ Do virtual thread local list last. Careful, the vtlco destructor writes to chunk.\n+    VirtualThreadLocalCheckpointOperation vtlco(_chunkwriter);\n+    VirtualThreadLocalWriteOperation vtlwo(vtlco);\n+    _virtual_thread_local_mspace->iterate(vtlwo); \/\/ current epoch list\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":138,"deletions":89,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  typedef const JfrCheckpointMspace::Node* ConstBufferPtr;\n@@ -63,0 +64,1 @@\n+  JfrThreadLocalCheckpointMspace* _virtual_thread_local_mspace;\n@@ -72,3 +74,4 @@\n-  static BufferPtr get_thread_local(Thread* thread);\n-  static void set_thread_local(Thread* thread, BufferPtr buffer);\n-  static BufferPtr acquire_thread_local(size_t size, Thread* thread);\n+  static BufferPtr get_virtual_thread_local(Thread* thread);\n+  static void set_virtual_thread_local(Thread* thread, BufferPtr buffer);\n+  static BufferPtr acquire_virtual_thread_local(Thread* thread, size_t size);\n+  static BufferPtr new_virtual_thread_local(Thread* thread, size_t size = 0);\n@@ -76,2 +79,0 @@\n-  static BufferPtr lease(Thread* thread, bool previous_epoch = false, size_t size = 0);\n-  static BufferPtr lease(BufferPtr old, Thread* thread, size_t size);\n@@ -79,0 +80,1 @@\n+  static BufferPtr lease_global(Thread* thread, bool previous_epoch = false, size_t size = 0);\n@@ -80,0 +82,2 @@\n+  static BufferPtr acquire(Thread* thread, JfrCheckpointBufferKind kind = JFR_THREADLOCAL, bool previous_epoch = false, size_t size = 0);\n+  static BufferPtr renew(ConstBufferPtr old, Thread* thread, size_t size, JfrCheckpointBufferKind kind = JFR_THREADLOCAL);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -34,2 +35,2 @@\n-JfrCheckpointWriter::JfrCheckpointWriter(JfrCheckpointType type \/* GENERIC *\/) :\n-  JfrCheckpointWriterBase(JfrCheckpointManager::lease(Thread::current()), Thread::current()),\n+JfrCheckpointWriter::JfrCheckpointWriter(bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, JfrCheckpointBufferKind kind \/* JFR_GLOBAL *\/) :\n+  JfrCheckpointWriterBase(JfrCheckpointManager::acquire(Thread::current(), kind), Thread::current()),\n@@ -40,1 +41,1 @@\n-  _header(true) {\n+  _header(header) {\n@@ -48,2 +49,2 @@\n-JfrCheckpointWriter::JfrCheckpointWriter(Thread* thread, bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, bool global_lease \/* true *\/) :\n-  JfrCheckpointWriterBase(global_lease ? JfrCheckpointManager::lease(thread) : JfrCheckpointManager::lease_thread_local(thread), thread),\n+JfrCheckpointWriter::JfrCheckpointWriter(Thread* thread, bool header \/* true *\/, JfrCheckpointType type \/* GENERIC *\/, JfrCheckpointBufferKind kind \/* JFR_GLOBAL *\/) :\n+  JfrCheckpointWriterBase(JfrCheckpointManager::acquire(thread, kind), thread),\n@@ -63,1 +64,1 @@\n-  JfrCheckpointWriterBase(JfrCheckpointManager::lease(thread, previous_epoch), thread),\n+  JfrCheckpointWriterBase(JfrCheckpointManager::lease_global(thread, previous_epoch), thread),\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -73,3 +73,3 @@\n- public:\n-  JfrCheckpointWriter(JfrCheckpointType type = GENERIC);\n-  JfrCheckpointWriter(Thread* thread, bool header = true, JfrCheckpointType mode = GENERIC, bool global_lease = true);\n+public:\n+  JfrCheckpointWriter(bool header = true, JfrCheckpointType mode = GENERIC, JfrCheckpointBufferKind kind = JFR_GLOBAL);\n+  JfrCheckpointWriter(Thread* thread, bool header = true, JfrCheckpointType mode = GENERIC, JfrCheckpointBufferKind kind = JFR_GLOBAL);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -107,1 +108,1 @@\n-  JfrCheckpointWriter writer(jt, true, THREADS, false); \/\/ Thread local lease for blob creation.\n+  JfrCheckpointWriter writer(jt, true, THREADS, JFR_THREADLOCAL); \/\/ Thread local lease for blob creation.\n@@ -122,1 +123,1 @@\n-  JfrCheckpointWriter writer(current, true, THREADS, !is_vthread); \/\/ Virtual Threads use thread local lease.\n+  JfrCheckpointWriter writer(current, true, THREADS, is_vthread ? JFR_VIRTUAL_THREADLOCAL : JFR_THREADLOCAL);\n@@ -205,1 +206,1 @@\n-    JfrCheckpointWriter writer(STATICS);\n+    JfrCheckpointWriter writer(Thread::current(), true, STATICS);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeManager.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  static const char field[] = \"FILE_DELTA_CHANGE\";\n+  static const char field[] = \"CHUNK_ROTATION_MONITOR\";\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunkRotation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  bool _started;\n@@ -73,1 +72,1 @@\n-                                          _started(false), _untimed(timing == UNTIMED),\n+                                          _untimed(timing == UNTIMED),\n@@ -79,5 +78,2 @@\n-    if (T::is_enabled() && JfrThreadLocal::is_included(Thread::current())) {\n-      _started = true;\n-      if (TIMED == timing && !T::isInstant) {\n-        set_starttime(JfrTicks::now());\n-      }\n+    if (!T::isInstant && !_untimed && is_enabled()) {\n+      set_starttime(JfrTicks::now());\n@@ -149,2 +145,2 @@\n-  bool is_started() const {\n-    return _started;\n+  bool is_started() {\n+    return is_instant() || _start_time != 0 || _untimed;\n@@ -154,1 +150,1 @@\n-    if (!_started) {\n+    if (!is_enabled()) {\n@@ -160,3 +156,0 @@\n-    if (_evaluated) {\n-      return _should_commit;\n-    }\n@@ -170,1 +163,7 @@\n-    return _started && (_evaluated ? _should_commit : evaluate());\n+    if (_evaluated) {\n+      return _should_commit;\n+    }\n+    if (!is_enabled()) {\n+      return false;\n+    }\n+    return evaluate() && JfrThreadLocal::is_included(Thread::current());\n@@ -174,1 +173,0 @@\n-    assert(_started, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEvent.hpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-bool JfrBuffer::initialize(size_t header_size, size_t size) {\n+void JfrBuffer::initialize(size_t header_size, size_t size) {\n@@ -51,1 +51,0 @@\n-  return true;\n@@ -54,1 +53,1 @@\n-void JfrBuffer::reinitialize(bool exclusion \/* false *\/) {\n+void JfrBuffer::reinitialize() {\n@@ -176,2 +175,1 @@\n-  LEASE = 4,\n-  EXCLUDED = 8\n+  LEASE = 4\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-  bool initialize(size_t header_size, size_t size);\n-  void reinitialize(bool exclusion = false);\n+  void initialize(size_t header_size, size_t size);\n+  void reinitialize();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,4 +221,1 @@\n-  if (!node->initialize(sizeof(Node), aligned_size_bytes)) {\n-    JfrCHeapObj::free(node, aligned_size_bytes + sizeof(Node));\n-    return NULL;\n-  }\n+  node->initialize(sizeof(Node), aligned_size_bytes);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrMemorySpace.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+  template(jfr_chunk_rotation_monitor,                                \"jdk\/jfr\/internal\/JVM$ChunkRotationMonitor\")   \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,0 +60,6 @@\n+enum JfrCheckpointBufferKind {\n+  JFR_GLOBAL,\n+  JFR_THREADLOCAL,\n+  JFR_VIRTUAL_THREADLOCAL\n+};\n+\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTypes.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1619,0 +1619,1 @@\n+      set_HotSpotInstalledCode_codeStart(obj, 0);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -823,0 +823,1 @@\n+      HotSpotJVMCI::HotSpotInstalledCode::set_codeStart(jvmciEnv, nmethod_mirror, 0);\n@@ -828,0 +829,1 @@\n+      HotSpotJVMCI::HotSpotInstalledCode::set_codeStart(jvmciEnv, nmethod_mirror, 0);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    _jni_config_file = new(ResourceObj::C_HEAP, mtJVMCI) fileStream(JVMCILibDumpJNIConfig);\n+    _jni_config_file = new(mtJVMCI) fileStream(JVMCILibDumpJNIConfig);\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -238,1 +238,2 @@\n-  char c, k = 0;\n+  char c;\n+  int k = 0;\n","filename":"src\/hotspot\/share\/libadt\/dict.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -177,1 +177,55 @@\n-template <MEMFLAGS F> class CHeapObj {\n+class CHeapObjBase {\n+ public:\n+  ALWAYSINLINE void* operator new(size_t size, MEMFLAGS f) throw() {\n+    return AllocateHeap(size, f);\n+  }\n+\n+  ALWAYSINLINE void* operator new(size_t size,\n+                                  MEMFLAGS f,\n+                                  const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack);\n+  }\n+\n+  ALWAYSINLINE void* operator new(size_t size,\n+                                  MEMFLAGS f,\n+                                  const std::nothrow_t&,\n+                                  const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  ALWAYSINLINE void* operator new(size_t size,\n+                                  MEMFLAGS f,\n+                                  const std::nothrow_t&) throw() {\n+    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size, MEMFLAGS f) throw() {\n+    return AllocateHeap(size, f);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size,\n+                                    MEMFLAGS f,\n+                                    const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size,\n+                                    MEMFLAGS f,\n+                                    const std::nothrow_t&,\n+                                    const NativeCallStack& stack) throw() {\n+    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size,\n+                                    MEMFLAGS f,\n+                                    const std::nothrow_t&) throw() {\n+    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+  }\n+\n+  void operator delete(void* p)     { FreeHeap(p); }\n+  void operator delete [] (void* p) { FreeHeap(p); }\n+};\n+\n+\/\/ Uses the implicitly static new and delete operators of CHeapObjBase\n+template<MEMFLAGS F>\n+class CHeapObj {\n@@ -180,1 +234,1 @@\n-    return (void*)AllocateHeap(size, F);\n+    return CHeapObjBase::operator new(size, F);\n@@ -185,1 +239,1 @@\n-    return (void*)AllocateHeap(size, F, stack);\n+    return CHeapObjBase::operator new(size, F, stack);\n@@ -188,1 +242,1 @@\n-  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&,\n+  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t& nt,\n@@ -190,1 +244,1 @@\n-    return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);\n+    return CHeapObjBase::operator new(size, F, nt, stack);\n@@ -193,2 +247,2 @@\n-  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t&) throw() {\n-    return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);\n+  ALWAYSINLINE void* operator new(size_t size, const std::nothrow_t& nt) throw() {\n+    return CHeapObjBase::operator new(size, F, nt);\n@@ -198,1 +252,1 @@\n-    return (void*)AllocateHeap(size, F);\n+    return CHeapObjBase::operator new[](size, F);\n@@ -202,2 +256,2 @@\n-                                  const NativeCallStack& stack) throw() {\n-    return (void*)AllocateHeap(size, F, stack);\n+                                    const NativeCallStack& stack) throw() {\n+    return CHeapObjBase::operator new[](size, F, stack);\n@@ -206,1 +260,1 @@\n-  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&,\n+  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t& nt,\n@@ -208,1 +262,5 @@\n-    return (void*)AllocateHeap(size, F, stack, AllocFailStrategy::RETURN_NULL);\n+    return CHeapObjBase::operator new[](size, F, nt, stack);\n+  }\n+\n+  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t& nt) throw() {\n+    return CHeapObjBase::operator new[](size, F, nt);\n@@ -211,2 +269,2 @@\n-  ALWAYSINLINE void* operator new[](size_t size, const std::nothrow_t&) throw() {\n-    return (void*)AllocateHeap(size, F, AllocFailStrategy::RETURN_NULL);\n+  void operator delete(void* p)     {\n+    CHeapObjBase::operator delete(p);\n@@ -215,2 +273,3 @@\n-  void  operator delete(void* p)     { FreeHeap(p); }\n-  void  operator delete [] (void* p) { FreeHeap(p); }\n+  void operator delete [] (void* p) {\n+    CHeapObjBase::operator delete[](p);\n+  }\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":75,"deletions":16,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -274,23 +274,0 @@\n-void* Arena::operator new(size_t size) throw() {\n-  assert(false, \"Use dynamic memory type binding\");\n-  return NULL;\n-}\n-\n-void* Arena::operator new (size_t size, const std::nothrow_t&  nothrow_constant) throw() {\n-  assert(false, \"Use dynamic memory type binding\");\n-  return NULL;\n-}\n-\n-  \/\/ dynamic memory type binding\n-void* Arena::operator new(size_t size, MEMFLAGS flags) throw() {\n-  return (void *) AllocateHeap(size, flags, CALLER_PC);\n-}\n-\n-void* Arena::operator new(size_t size, const std::nothrow_t& nothrow_constant, MEMFLAGS flags) throw() {\n-  return (void*)AllocateHeap(size, flags, CALLER_PC, AllocFailStrategy::RETURN_NULL);\n-}\n-\n-void Arena::operator delete(void* p) {\n-  FreeHeap(p);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-class Arena : public CHeapObj<mtNone> {\n+class Arena : public CHeapObjBase {\n@@ -124,9 +124,0 @@\n-  \/\/ new operators\n-  void* operator new (size_t size) throw();\n-  void* operator new (size_t size, const std::nothrow_t& nothrow_constant) throw();\n-\n-  \/\/ dynamic memory type tagging\n-  void* operator new(size_t size, MEMFLAGS flags) throw();\n-  void* operator new(size_t size, const std::nothrow_t& nothrow_constant, MEMFLAGS flags) throw();\n-  void  operator delete(void* p);\n-\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -265,3 +265,0 @@\n-      if (mirror_oop != NULL) { \/\/ may be null if archived heap is disabled\n-        java_lang_Class::update_archived_primitive_mirror_native_pointers(mirror_oop);\n-      }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -498,8 +498,3 @@\n-  if (this == NULL) {\n-    st->print(\"NULL\");\n-  } else {\n-    st->print(\"'Q\");\n-    for (int i = 0; i < utf8_length(); i++) {\n-      st->print(\"%c\", char_at(i));\n-    }\n-    st->print(\";'\");\n+  st->print(\"'Q\");\n+  for (int i = 0; i < utf8_length(); i++) {\n+    st->print(\"%c\", char_at(i));\n@@ -507,0 +502,1 @@\n+  st->print(\";'\");\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -367,9 +367,0 @@\n-  \/\/ Convert (~x+c) into (c-1)-x. Note there isn't a bitwise not\n-  \/\/ bytecode, \"~x\" would typically represented as \"x^(-1)\", so (~x+c)\n-  \/\/ will be (x^(-1))+c.\n-  if (op1 == Op_Xor(bt) &&\n-      (in2->Opcode() == Op_ConI || in2->Opcode() == Op_ConL) &&\n-      phase->type(in1->in(2)) == TypeInteger::minus_1(bt)) {\n-    Node* c_minus_one = phase->makecon(add_ring(phase->type(in(2)), TypeInteger::minus_1(bt)));\n-    return SubNode::make(c_minus_one, in1->in(1), bt);\n-  }\n@@ -877,0 +868,13 @@\n+\/\/---------------------------Helper -------------------------------------------\n+\/* Decide if the given node is used only in arithmetic expressions(add or sub).\n+ *\/\n+static bool is_used_in_only_arithmetic(Node* n, BasicType bt) {\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* u = n->fast_out(i);\n+    if (u->Opcode() != Op_Add(bt) && u->Opcode() != Op_Sub(bt)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -882,9 +886,14 @@\n-  int op1 = in1->Opcode();\n-  \/\/ Convert ~(x+c) into (-c-1)-x. Note there isn't a bitwise not\n-  \/\/ bytecode, \"~x\" would typically represented as \"x^(-1)\", so ~(x+c)\n-  \/\/ will eventually be (x+c)^-1.\n-  if (op1 == Op_AddI && phase->type(in2) == TypeInt::MINUS_1 &&\n-      in1->in(2)->Opcode() == Op_ConI) {\n-    jint c = phase->type(in1->in(2))->isa_int()->get_con();\n-    Node* neg_c_minus_one = phase->intcon(java_add(-c, -1));\n-    return new SubINode(neg_c_minus_one, in1->in(1));\n+\n+  \/\/ Convert ~x into -1-x when ~x is used in an arithmetic expression\n+  \/\/ or x itself is an expression.\n+  if (phase->type(in2) == TypeInt::MINUS_1) { \/\/ follows LHS^(-1), i.e., ~LHS\n+    if (phase->is_IterGVN()) {\n+      if (is_used_in_only_arithmetic(this, T_INT)\n+          \/\/ LHS is arithmetic\n+          || (in1->Opcode() == Op_AddI || in1->Opcode() == Op_SubI)) {\n+        return new SubINode(in2, in1);\n+      }\n+    } else {\n+      \/\/ graph could be incomplete in GVN so we postpone to IGVN\n+      phase->record_for_igvn(this);\n+    }\n@@ -962,9 +971,14 @@\n-  int op1 = in1->Opcode();\n-  \/\/ Convert ~(x+c) into (-c-1)-x. Note there isn't a bitwise not\n-  \/\/ bytecode, \"~x\" would typically represented as \"x^(-1)\", so ~(x+c)\n-  \/\/ will eventually be (x+c)^-1.\n-  if (op1 == Op_AddL && phase->type(in2) == TypeLong::MINUS_1 &&\n-      in1->in(2)->Opcode() == Op_ConL) {\n-    jlong c = phase->type(in1->in(2))->isa_long()->get_con();\n-    Node* neg_c_minus_one = phase->longcon(java_add(-c, (jlong)-1));\n-    return new SubLNode(neg_c_minus_one, in1->in(1));\n+\n+  \/\/ Convert ~x into -1-x when ~x is used in an arithmetic expression\n+  \/\/ or x itself is an arithmetic expression.\n+  if (phase->type(in2) == TypeLong::MINUS_1) { \/\/ follows LHS^(-1), i.e., ~LHS\n+    if (phase->is_IterGVN()) {\n+      if (is_used_in_only_arithmetic(this, T_LONG)\n+          \/\/ LHS is arithmetic\n+          || (in1->Opcode() == Op_AddL || in1->Opcode() == Op_SubL)) {\n+        return new SubLNode(in2, in1);\n+      }\n+    } else {\n+      \/\/ graph could be incomplete in GVN so we postpone to IGVN\n+      phase->record_for_igvn(this);\n+    }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":41,"deletions":27,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -303,0 +303,6 @@\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!Matcher::match_rule_supported(Op_ConvHF2F)) return false;\n+    break;\n+  case vmIntrinsics::_floatToFloat16:\n+    if (!Matcher::match_rule_supported(Op_ConvF2HF)) return false;\n+    break;\n@@ -781,0 +787,1 @@\n+  case vmIntrinsics::_IndexVector:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+macro(ConvF2HF)\n+macro(ConvHF2F)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -654,1 +655,1 @@\n-                  _print_inlining_stream(new stringStream()),\n+                  _print_inlining_stream(new (mtCompiler) stringStream()),\n@@ -935,1 +936,1 @@\n-    _print_inlining_stream(new stringStream()),\n+    _print_inlining_stream(new (mtCompiler) stringStream()),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1084,0 +1084,4 @@\n+  ~Compile() {\n+    delete _print_inlining_stream;\n+  };\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,0 +175,15 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* ConvF2HFNode::Value(PhaseGVN* phase) const {\n+  const Type *t = phase->type( in(1) );\n+  if( t == Type::TOP ) return Type::TOP;\n+  if( t == Type::FLOAT ) return TypeInt::SHORT;\n+  const TypeF *tf = t->is_float_constant();\n+  return TypeInt::make( SharedRuntime::f2hf( tf->getf() ) );\n+}\n+\n+\/\/------------------------------Identity---------------------------------------\n+Node* ConvF2HFNode::Identity(PhaseGVN* phase) {\n+  return (in(1)->Opcode() == Op_ConvHF2F) ? in(1)->in(1) : this;\n+}\n+\n@@ -233,0 +248,12 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* ConvHF2FNode::Value(PhaseGVN* phase) const {\n+  const Type *t = phase->type( in(1) );\n+  if( t == Type::TOP ) return Type::TOP;\n+  if( t == TypeInt::SHORT ) return Type::FLOAT;\n+  const TypeInt *ti = t->is_int();\n+  if ( ti->is_con() ) return TypeF::make( SharedRuntime::hf2f( ti->get_con() ) );\n+\n+  return bottom_type();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -104,0 +104,12 @@\n+\/\/------------------------------ConvF2HFNode------------------------------------\n+\/\/ Convert Float to Halffloat\n+class ConvF2HFNode : public Node {\n+  public:\n+  ConvF2HFNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeInt::SHORT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n@@ -131,0 +143,11 @@\n+\/\/------------------------------ConvHF2FNode------------------------------------\n+\/\/ Convert Halffloat to float\n+class ConvHF2FNode : public Node {\n+  public:\n+  ConvHF2FNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-  _xml = new (ResourceObj::C_HEAP, mtCompiler) xmlStream(_output);\n+  _xml = new (mtCompiler) xmlStream(_output);\n@@ -734,1 +734,1 @@\n-  GrowableArray<Node *> nodeStack(Thread::current()->resource_area(), 0, 0, NULL);\n+  GrowableArray<Node *> nodeStack(Thread::current()->resource_area(), 0, 0, nullptr);\n@@ -736,2 +736,1 @@\n-  visited.test_set(start->_idx);\n-  if (C->cfg() != NULL) {\n+  if (C->cfg() != nullptr) {\n@@ -748,1 +747,5 @@\n-  while(nodeStack.length() > 0) {\n+  while (nodeStack.length() > 0) {\n+    Node* n = nodeStack.pop();\n+    if (visited.test_set(n->_idx)) {\n+      continue;\n+    }\n@@ -750,1 +753,0 @@\n-    Node *n = nodeStack.pop();\n@@ -755,4 +757,1 @@\n-        Node* p = n->out(i);\n-        if (!visited.test_set(p->_idx)) {\n-          nodeStack.push(p);\n-        }\n+        nodeStack.push(n->out(i));\n@@ -762,5 +761,3 @@\n-    for ( uint i = 0; i < n->len(); i++ ) {\n-      if ( n->in(i) ) {\n-        if (!visited.test_set(n->in(i)->_idx)) {\n-          nodeStack.push(n->in(i));\n-        }\n+    for (uint i = 0; i < n->len(); i++) {\n+      if (n->in(i) != nullptr) {\n+        nodeStack.push(n->in(i));\n@@ -854,1 +851,1 @@\n-    _output = new (ResourceObj::C_HEAP, mtCompiler) fileStream(st.as_string(), \"w\");\n+    _output = new (mtCompiler) fileStream(st.as_string(), \"w\");\n@@ -856,1 +853,1 @@\n-    _output = new (ResourceObj::C_HEAP, mtCompiler) fileStream(file_name, append ? \"a\" : \"w\");\n+    _output = new (mtCompiler) fileStream(file_name, append ? \"a\" : \"w\");\n@@ -865,1 +862,1 @@\n-  _network_stream = new (ResourceObj::C_HEAP, mtCompiler) networkStream();\n+  _network_stream = new (mtCompiler) networkStream();\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -527,1 +527,3 @@\n-  case vmIntrinsics::_longBitsToDouble:         return inline_fp_conversions(intrinsic_id());\n+  case vmIntrinsics::_longBitsToDouble:\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:           return inline_fp_conversions(intrinsic_id());\n@@ -727,0 +729,2 @@\n+  case vmIntrinsics::_IndexVector:\n+    return inline_index_vector();\n@@ -4788,0 +4792,2 @@\n+  case vmIntrinsics::_floatToFloat16:       result = new ConvF2HFNode(arg); break;\n+  case vmIntrinsics::_float16ToFloat:       result = new ConvHF2FNode(arg); break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -374,0 +374,1 @@\n+  bool inline_index_vector();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -861,1 +862,1 @@\n-    predString = new stringStream();\n+    predString = new (mtCompiler) stringStream();\n@@ -986,1 +987,1 @@\n-    predString->~stringStream();\n+    delete predString;\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1007,0 +1007,2 @@\n+      case Op_VectorCastD2X:\n+      case Op_VectorCastF2X:\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1397,1 +1397,1 @@\n-    Node* scaled_iv_plus_offset = scaled_iv_plus_offset = new AddINode(scaled_iv, L_2);\n+    Node* scaled_iv_plus_offset = new AddINode(scaled_iv, L_2);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -448,2 +448,2 @@\n-MachNode *MachNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted) {\n-  return NULL;\n+int MachNode::peephole(Block *block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc *ra_) {\n+  return -1;\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-  virtual MachNode *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted);\n+  virtual int peephole(Block *block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc *ra_);\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1792,1 +1792,1 @@\n-  assert(t->meet(t0) == t, \"Not monotonic\");\n+  assert(t->meet(t0) == t->remove_speculative(), \"Not monotonic\");\n@@ -2218,11 +2218,11 @@\n-    \/\/ and each instruction within a block\n-    uint end_index = block->number_of_nodes();\n-    \/\/ block->end_idx() not valid after PhaseRegAlloc\n-    for( uint instruction_index = 1; instruction_index < end_index; ++instruction_index ) {\n-      Node     *n = block->get_node(instruction_index);\n-      if( n->is_Mach() ) {\n-        MachNode *m = n->as_Mach();\n-        int deleted_count = 0;\n-        \/\/ check for peephole opportunities\n-        MachNode *m2 = m->peephole(block, instruction_index, _regalloc, deleted_count);\n-        if( m2 != NULL ) {\n+    for (bool progress = true; progress;) {\n+      progress = false;\n+      \/\/ block->end_idx() not valid after PhaseRegAlloc\n+      uint end_index = block->number_of_nodes();\n+      for( uint instruction_index = end_index - 1; instruction_index > 0; --instruction_index ) {\n+        Node     *n = block->get_node(instruction_index);\n+        if( n->is_Mach() ) {\n+          MachNode *m = n->as_Mach();\n+          \/\/ check for peephole opportunities\n+          int result = m->peephole(block, instruction_index, &_cfg, _regalloc);\n+          if( result != -1 ) {\n@@ -2230,15 +2230,14 @@\n-          if( PrintOptoPeephole ) {\n-            \/\/ Print method, first time only\n-            if( C->method() && method_name_not_printed ) {\n-              C->method()->print_short_name(); tty->cr();\n-              method_name_not_printed = false;\n-            }\n-            \/\/ Print this block\n-            if( Verbose && block_not_printed) {\n-              tty->print_cr(\"in block\");\n-              block->dump();\n-              block_not_printed = false;\n-            }\n-            \/\/ Print instructions being deleted\n-            for( int i = (deleted_count - 1); i >= 0; --i ) {\n-              block->get_node(instruction_index-i)->as_Mach()->format(_regalloc); tty->cr();\n+            if( PrintOptoPeephole ) {\n+              \/\/ Print method, first time only\n+              if( C->method() && method_name_not_printed ) {\n+                C->method()->print_short_name(); tty->cr();\n+                method_name_not_printed = false;\n+              }\n+              \/\/ Print this block\n+              if( Verbose && block_not_printed) {\n+                tty->print_cr(\"in block\");\n+                block->dump();\n+                block_not_printed = false;\n+              }\n+              \/\/ Print the peephole number\n+              tty->print_cr(\"peephole number: %d\", result);\n@@ -2246,5 +2245,1 @@\n-            tty->print_cr(\"replaced with\");\n-            \/\/ Print new instruction\n-            m2->format(_regalloc);\n-            tty->print(\"\\n\\n\");\n-          }\n+            inc_peepholes();\n@@ -2252,7 +2247,3 @@\n-          \/\/ Remove old nodes from basic block and update instruction_index\n-          \/\/ (old nodes still exist and may have edges pointing to them\n-          \/\/  as register allocation info is stored in the allocator using\n-          \/\/  the node index to live range mappings.)\n-          uint safe_instruction_index = (instruction_index - deleted_count);\n-          for( ; (instruction_index > safe_instruction_index); --instruction_index ) {\n-            block->remove_node( instruction_index );\n+            \/\/ Set progress, start again\n+            progress = true;\n+            break;\n@@ -2260,4 +2251,0 @@\n-          \/\/ install new node after safe_instruction_index\n-          block->insert_node(m2, safe_instruction_index + 1);\n-          end_index = block->number_of_nodes() - 1; \/\/ Recompute new block size\n-          NOT_PRODUCT( inc_peepholes(); )\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":30,"deletions":43,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1847,0 +1847,14 @@\n+\/\/ Clear the unused cmove pack and its related packs from superword candidate packset.\n+void SuperWord::remove_cmove_and_related_packs(Node_List* cmove_pk) {\n+  Node* cmove = cmove_pk->at(0);\n+  Node* bol = cmove->as_CMove()->in(CMoveNode::Condition);\n+  if (my_pack(bol)) {\n+    remove_pack(my_pack(bol));\n+  }\n+  Node* cmp = bol->in(1);\n+  if (my_pack(cmp)) {\n+    remove_pack(my_pack(cmp));\n+  }\n+  remove_pack(cmove_pk);\n+}\n+\n@@ -1848,1 +1862,1 @@\n-\/\/ Merge CMoveD into new vector-nodes\n+\/\/ Merge qualified CMoveD into new vector-nodes\n@@ -1870,0 +1884,1 @@\n+\/\/ Also delete unqualified CMove pack from the packset and clear all info.\n@@ -1873,1 +1888,8 @@\n-    _cmovev_kit.make_cmovevd_pack(_packset.at(i));\n+    Node_List* pk = _packset.at(i);\n+    if (_cmovev_kit.is_cmove_pack_candidate(pk)) {\n+      if (_cmovev_kit.can_merge_cmove_pack(pk)) {\n+        _cmovev_kit.make_cmove_pack(pk);\n+      } else {\n+        remove_cmove_and_related_packs(pk);\n+      }\n+    }\n@@ -1875,0 +1897,1 @@\n+\n@@ -1912,10 +1935,5 @@\n-Node_List* CMoveKit::make_cmovevd_pack(Node_List* cmovd_pk) {\n-  Node *cmovd = cmovd_pk->at(0);\n-  if (!cmovd->is_CMove()) {\n-    return NULL;\n-  }\n-  if (cmovd->Opcode() != Op_CMoveF && cmovd->Opcode() != Op_CMoveD) {\n-    return NULL;\n-  }\n-  if (pack(cmovd) != NULL) { \/\/ already in the cmov pack\n-    return NULL;\n+bool CMoveKit::is_cmove_pack_candidate(Node_List* cmove_pk) {\n+  Node* cmove = cmove_pk->at(0);\n+  if ((cmove->Opcode() != Op_CMoveF && cmove->Opcode() != Op_CMoveD) ||\n+      pack(cmove) != NULL \/* already in the cmove pack *\/) {\n+    return false;\n@@ -1923,3 +1941,11 @@\n-  if (cmovd->in(0) != NULL) {\n-    NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::make_cmovevd_pack: CMoveD %d has control flow, escaping...\", cmovd->_idx); cmovd->dump();})\n-    return NULL;\n+  return true;\n+}\n+\n+\/\/ Determine if the current pack is an ideal cmove pack, and if its related packs,\n+\/\/ i.e. bool node pack and cmp node pack, can be successfully merged for vectorization.\n+bool CMoveKit::can_merge_cmove_pack(Node_List* cmove_pk) {\n+  Node* cmove = cmove_pk->at(0);\n+\n+  if (cmove->in(0) != NULL) {\n+    NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::make_cmove_pack: CMove %d has control flow, escaping...\", cmove->_idx); cmove->dump();})\n+    return false;\n@@ -1928,8 +1954,8 @@\n-  Node* bol = cmovd->as_CMove()->in(CMoveNode::Condition);\n-  if (!bol->is_Bool()\n-      || bol->outcnt() != 1\n-      || !_sw->same_generation(bol, cmovd)\n-      || bol->in(0) != NULL  \/\/ BoolNode has control flow!!\n-      || _sw->my_pack(bol) == NULL) {\n-      NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::make_cmovevd_pack: Bool %d does not fit CMoveD %d for building vector, escaping...\", bol->_idx, cmovd->_idx); bol->dump();})\n-      return NULL;\n+  Node* bol = cmove->as_CMove()->in(CMoveNode::Condition);\n+  if (!bol->is_Bool() ||\n+      bol->outcnt() != 1 ||\n+      !_sw->same_generation(bol, cmove) ||\n+      bol->in(0) != NULL || \/\/ BoolNode has control flow!!\n+      _sw->my_pack(bol) == NULL) {\n+      NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::make_cmove_pack: Bool %d does not fit CMove %d for building vector, escaping...\", bol->_idx, cmove->_idx); bol->dump();})\n+    return false;\n@@ -1938,2 +1964,2 @@\n-  if (bool_pk->size() != cmovd_pk->size() ) {\n-    return NULL;\n+  if (bool_pk->size() != cmove_pk->size() ) {\n+    return false;\n@@ -1942,8 +1968,8 @@\n-  Node* cmpd = bol->in(1);\n-  if (!cmpd->is_Cmp()\n-      || cmpd->outcnt() != 1\n-      || !_sw->same_generation(cmpd, cmovd)\n-      || cmpd->in(0) != NULL  \/\/ CmpDNode has control flow!!\n-      || _sw->my_pack(cmpd) == NULL) {\n-      NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::make_cmovevd_pack: CmpD %d does not fit CMoveD %d for building vector, escaping...\", cmpd->_idx, cmovd->_idx); cmpd->dump();})\n-      return NULL;\n+  Node* cmp = bol->in(1);\n+  if (!cmp->is_Cmp() ||\n+      cmp->outcnt() != 1 ||\n+      !_sw->same_generation(cmp, cmove) ||\n+      cmp->in(0) != NULL || \/\/ CmpNode has control flow!!\n+      _sw->my_pack(cmp) == NULL) {\n+      NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::make_cmove_pack: Cmp %d does not fit CMove %d for building vector, escaping...\", cmp->_idx, cmove->_idx); cmp->dump();})\n+    return false;\n@@ -1951,3 +1977,3 @@\n-  Node_List* cmpd_pk = _sw->my_pack(cmpd);\n-  if (cmpd_pk->size() != cmovd_pk->size() ) {\n-    return NULL;\n+  Node_List* cmp_pk = _sw->my_pack(cmp);\n+  if (cmp_pk->size() != cmove_pk->size() ) {\n+    return false;\n@@ -1956,3 +1982,3 @@\n-  if (!test_cmpd_pack(cmpd_pk, cmovd_pk)) {\n-    NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::make_cmovevd_pack: cmpd pack for CmpD %d failed vectorization test\", cmpd->_idx); cmpd->dump();})\n-    return NULL;\n+  if (!test_cmpd_pack(cmp_pk, cmove_pk)) {\n+    NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print(\"CMoveKit::make_cmove_pack: cmp pack for Cmp %d failed vectorization test\", cmp->_idx); cmp->dump();})\n+    return false;\n@@ -1961,2 +1987,14 @@\n-  Node_List* new_cmpd_pk = new Node_List();\n-  uint sz = cmovd_pk->size() - 1;\n+  return true;\n+}\n+\n+\/\/ Create a new cmove pack to substitute the old one, map all info to the\n+\/\/ new pack and delete the old cmove pack and related packs from the packset.\n+void CMoveKit::make_cmove_pack(Node_List* cmove_pk) {\n+  Node* cmove = cmove_pk->at(0);\n+  Node* bol = cmove->as_CMove()->in(CMoveNode::Condition);\n+  Node_List* bool_pk = _sw->my_pack(bol);\n+  Node* cmp = bol->in(1);\n+  Node_List* cmp_pk = _sw->my_pack(cmp);\n+\n+  Node_List* new_cmove_pk = new Node_List();\n+  uint sz = cmove_pk->size() - 1;\n@@ -1964,1 +2002,1 @@\n-    Node* cmov = cmovd_pk->at(i);\n+    Node* cmov = cmove_pk->at(i);\n@@ -1966,1 +2004,1 @@\n-    Node* cmp  = cmpd_pk->at(i);\n+    Node* cmp  = cmp_pk->at(i);\n@@ -1968,1 +2006,1 @@\n-    new_cmpd_pk->insert(i, cmov);\n+    new_cmove_pk->insert(i, cmov);\n@@ -1970,3 +2008,3 @@\n-    map(cmov, new_cmpd_pk);\n-    map(bol, new_cmpd_pk);\n-    map(cmp, new_cmpd_pk);\n+    map(cmov, new_cmove_pk);\n+    map(bol, new_cmove_pk);\n+    map(cmp, new_cmove_pk);\n@@ -1974,1 +2012,1 @@\n-    _sw->set_my_pack(cmov, new_cmpd_pk); \/\/ and keep old packs for cmp and bool\n+    _sw->set_my_pack(cmov, new_cmove_pk); \/\/ and keep old packs for cmp and bool\n@@ -1976,1 +2014,1 @@\n-  _sw->_packset.remove(cmovd_pk);\n+  _sw->_packset.remove(cmove_pk);\n@@ -1978,4 +2016,3 @@\n-  _sw->_packset.remove(cmpd_pk);\n-  _sw->_packset.append(new_cmpd_pk);\n-  NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print_cr(\"CMoveKit::make_cmovevd_pack: added syntactic CMoveD pack\"); _sw->print_pack(new_cmpd_pk);})\n-  return new_cmpd_pk;\n+  _sw->_packset.remove(cmp_pk);\n+  _sw->_packset.append(new_cmove_pk);\n+  NOT_PRODUCT(if(_sw->is_trace_cmov()) {tty->print_cr(\"CMoveKit::make_cmove_pack: added syntactic CMove pack\"); _sw->print_pack(new_cmove_pk);})\n@@ -3678,0 +3715,10 @@\n+\/\/------------------------------remove_pack------------------------------\n+\/\/ Remove the pack in the packset\n+void SuperWord::remove_pack(Node_List* p) {\n+  for (uint i = 0; i < p->size(); i++) {\n+    Node* s = p->at(i);\n+    set_my_pack(s, NULL);\n+  }\n+  _packset.remove(p);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":100,"deletions":53,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -218,1 +218,5 @@\n-  Node_List* make_cmovevd_pack(Node_List* cmovd_pk);\n+  \/\/ If the input pack is a cmove candidate, return true, otherwise return false.\n+  bool is_cmove_pack_candidate(Node_List* cmove_pk);\n+  \/\/ Determine if the current cmove pack can be vectorized.\n+  bool can_merge_cmove_pack(Node_List* cmove_pk);\n+  void make_cmove_pack(Node_List* cmovd_pk);\n@@ -539,0 +543,2 @@\n+  \/\/ Clear the unused cmove pack and its related packs from superword candidate packset.\n+  void remove_cmove_and_related_packs(Node_List* cmove_pk);\n@@ -587,0 +593,2 @@\n+  \/\/ Remove the pack in the packset\n+  void remove_pack(Node_List* p);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2491,9 +2491,2 @@\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    if (is_mask && is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from = elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    if (is_mask && is_floating_point_type(elem_bt_to)) {\n-      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    int cast_vopc = VectorCastNode::opcode(new_elem_bt_from, !is_ucast);\n+    assert(!is_mask || num_elem_from == num_elem_to, \"vector mask cast needs the same elem num\");\n+    int cast_vopc = VectorCastNode::opcode(elem_bt_from, !is_ucast);\n@@ -2501,5 +2494,3 @@\n-    \/\/ Make sure that vector cast is implemented to particular type\/size combination.\n-    bool no_vec_cast_check = is_mask &&\n-                             ((src_type->isa_vectmask() && dst_type->isa_vectmask()) ||\n-                              type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to));\n-    if (!no_vec_cast_check && !arch_supports_vector(cast_vopc, num_elem_to, new_elem_bt_to, VecMaskNotUsed)) {\n+    \/\/ Make sure that vector cast is implemented to particular type\/size combination if it is\n+    \/\/ not a mask casting.\n+    if (!is_mask && !arch_supports_vector(cast_vopc, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n@@ -2508,1 +2499,1 @@\n-                      cast_vopc, num_elem_to, type2name(new_elem_bt_to), is_mask);\n+                      cast_vopc, num_elem_to, type2name(elem_bt_to), is_mask);\n@@ -2555,5 +2546,7 @@\n-        if ((dst_type->isa_vectmask() && src_type->isa_vectmask()) ||\n-            (type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to))) {\n-          op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n-        } else {\n-          op = VectorMaskCastNode::makeCastNode(&gvn(), op, dst_type);\n+        \/\/ Make sure that cast for vector mask is implemented to particular type\/size combination.\n+        if (!arch_supports_vector(Op_VectorMaskCast, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n+          if (C->print_intrinsics()) {\n+            tty->print_cr(\"  ** not supported: arity=1 op=maskcast vlen2=%d etype2=%s ismask=%d\",\n+                          num_elem_to, type2name(elem_bt_to), is_mask);\n+          }\n+          return false;\n@@ -2561,0 +2554,1 @@\n+        op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n@@ -2853,0 +2847,152 @@\n+\n+\/\/ public static\n+\/\/ <V extends Vector<E>,\n+\/\/  E,\n+\/\/  S extends VectorSpecies<E>>\n+\/\/  V indexVector(Class<? extends V> vClass, Class<E> eClass,\n+\/\/                int length,\n+\/\/                V v, int step, S s,\n+\/\/                IndexOperation<V, S> defaultImpl)\n+bool LibraryCallKit::inline_index_vector() {\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+\n+  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n+      vector_klass->const_oop() == NULL || !vlen->is_con() ||\n+      elem_klass->const_oop() == NULL) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()]);\n+    }\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(vector_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = elem_type->basic_type();\n+\n+  \/\/ Check whether the iota index generation op is supported by the current hardware\n+  if (!arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n+    }\n+    return false; \/\/ not supported\n+  }\n+\n+  int mul_op = VectorSupport::vop2ideal(VectorSupport::VECTOR_OP_MUL, elem_bt);\n+  int vmul_op = VectorNode::opcode(mul_op, elem_bt);\n+  bool needs_mul = true;\n+  Node* scale = argument(4);\n+  const TypeInt* scale_type = gvn().type(scale)->isa_int();\n+  \/\/ Multiply is not needed if the scale is a constant \"1\".\n+  if (scale_type && scale_type->is_con() && scale_type->get_con() == 1) {\n+    needs_mul = false;\n+  } else {\n+    \/\/ Check whether the vector multiply op is supported by the current hardware\n+    if (!arch_supports_vector(vmul_op, num_elem, elem_bt, VecMaskNotUsed)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n+    }\n+\n+    \/\/ Check whether the scalar cast op is supported by the current hardware\n+    if (is_floating_point_type(elem_bt) || elem_bt == T_LONG) {\n+      int cast_op = elem_bt == T_LONG ? Op_ConvI2L :\n+                    elem_bt == T_FLOAT? Op_ConvI2F : Op_ConvI2D;\n+      if (!Matcher::match_rule_supported(cast_op)) {\n+        if (C->print_intrinsics()) {\n+          tty->print_cr(\"  ** Rejected op (%s) because architecture does not support it\",\n+                        NodeClassNames[cast_op]);\n+        }\n+        return false; \/\/ not supported\n+      }\n+    }\n+  }\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+  Node* opd = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  if (opd == NULL) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** unbox failed vector=%s\",\n+                    NodeClassNames[argument(3)->Opcode()]);\n+    }\n+    return false;\n+  }\n+\n+  int add_op = VectorSupport::vop2ideal(VectorSupport::VECTOR_OP_ADD, elem_bt);\n+  int vadd_op = VectorNode::opcode(add_op, elem_bt);\n+  bool needs_add = true;\n+  \/\/ The addition is not needed if all the element values of \"opd\" are zero\n+  if (VectorNode::is_all_zeros_vector(opd)) {\n+    needs_add = false;\n+  } else {\n+    \/\/ Check whether the vector addition op is supported by the current hardware\n+    if (!arch_supports_vector(vadd_op, num_elem, elem_bt, VecMaskNotUsed)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: vlen=%d etype=%s\", num_elem, type2name(elem_bt));\n+      }\n+      return false; \/\/ not supported\n+    }\n+  }\n+\n+  \/\/ Compute the iota indice vector\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  Node* index = gvn().transform(new VectorLoadConstNode(gvn().makecon(TypeInt::ZERO), vt));\n+\n+  \/\/ Broadcast the \"scale\" to a vector, and multiply the \"scale\" with iota indice vector.\n+  if (needs_mul) {\n+    switch (elem_bt) {\n+      case T_BOOLEAN: \/\/ fall-through\n+      case T_BYTE:    \/\/ fall-through\n+      case T_SHORT:   \/\/ fall-through\n+      case T_CHAR:    \/\/ fall-through\n+      case T_INT: {\n+        \/\/ no conversion needed\n+        break;\n+      }\n+      case T_LONG: {\n+        scale = gvn().transform(new ConvI2LNode(scale));\n+        break;\n+      }\n+      case T_FLOAT: {\n+        scale = gvn().transform(new ConvI2FNode(scale));\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        scale = gvn().transform(new ConvI2DNode(scale));\n+        break;\n+      }\n+      default: fatal(\"%s\", type2name(elem_bt));\n+    }\n+    scale = gvn().transform(VectorNode::scalar2vector(scale, num_elem, Type::get_const_basic_type(elem_bt)));\n+    index = gvn().transform(VectorNode::make(vmul_op, index, scale, vt));\n+  }\n+\n+  \/\/ Add \"opd\" if addition is needed.\n+  if (needs_add) {\n+    index = gvn().transform(VectorNode::make(vadd_op, opd, index, vt));\n+  }\n+  Node* vbox = box_vector(index, vbox_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":166,"deletions":20,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -1622,0 +1622,1 @@\n+          \/\/ VectorUnbox (VectorBox vmask) ==> VectorMaskCast vmask\n@@ -1623,10 +1624,1 @@\n-          if (in_vt->length_in_bytes() == out_vt->length_in_bytes() &&\n-              Matcher::match_rule_supported_vector(Op_VectorMaskCast, out_vt->length(), out_vt->element_basic_type())) {\n-            \/\/ Apply \"VectorUnbox (VectorBox vmask) ==> VectorMaskCast (vmask)\"\n-            \/\/ directly. This could avoid the transformation ordering issue from\n-            \/\/ \"VectorStoreMask (VectorLoadMask vmask) => vmask\".\n-            return new VectorMaskCastNode(value, vmask_type);\n-          }\n-          \/\/ VectorUnbox (VectorBox vmask) ==> VectorLoadMask (VectorStoreMask vmask)\n-          value = phase->transform(VectorStoreMaskNode::make(*phase, value, in_vt->element_basic_type(), in_vt->length()));\n-          return new VectorLoadMaskNode(value, vmask_type);\n+          return new VectorMaskCastNode(value, vmask_type);\n@@ -1723,42 +1715,0 @@\n-Node* VectorMaskCastNode::makeCastNode(PhaseGVN* phase, Node* src, const TypeVect* dst_type) {\n-  const TypeVect* src_type = src->bottom_type()->is_vect();\n-  assert(src_type->length() == dst_type->length(), \"\");\n-\n-  int num_elem = src_type->length();\n-  BasicType elem_bt_from = src_type->element_basic_type();\n-  BasicType elem_bt_to = dst_type->element_basic_type();\n-\n-  if (dst_type->isa_vectmask() == NULL && src_type->isa_vectmask() == NULL &&\n-      type2aelembytes(elem_bt_from) != type2aelembytes(elem_bt_to)) {\n-\n-    Node* op = src;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    if (is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from =  elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    if (is_floating_point_type(elem_bt_to)) {\n-      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-    }\n-\n-    \/\/ Special handling for casting operation involving floating point types.\n-    \/\/ Case A) F -> X :=  F -> VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2X\n-    \/\/ Case B) X -> F :=  X -> VectorCastX2[I\/L] -> VectorMaskCast ([I\/L]->F [NOP])\n-    \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectotMaskCast (L\/I->F [NOP])\n-\n-    if (new_elem_bt_from != elem_bt_from) {\n-      const TypeVect* new_src_type = TypeVect::makemask(new_elem_bt_from, num_elem);\n-      op = phase->transform(new VectorMaskCastNode(op, new_src_type));\n-    }\n-\n-    op = phase->transform(VectorCastNode::make(VectorCastNode::opcode(new_elem_bt_from), op, new_elem_bt_to, num_elem));\n-\n-    if (new_elem_bt_to != elem_bt_to) {\n-      op = phase->transform(new VectorMaskCastNode(op, dst_type));\n-    }\n-    return op;\n-  } else {\n-    return new VectorMaskCastNode(src, dst_type);\n-  }\n-}\n-\n@@ -1785,1 +1735,1 @@\n-       return VectorMaskCastNode::makeCastNode(phase, src, dst_type);\n+       return new VectorMaskCastNode(src, dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":53,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1508,1 +1508,0 @@\n-  static Node* makeCastNode(PhaseGVN* phase, Node* in1, const TypeVect * vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5834,0 +5834,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -5876,0 +5878,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -5887,0 +5892,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -5916,0 +5923,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -5925,0 +5935,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -5969,0 +5981,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -5977,0 +5992,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6018,0 +6035,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6026,0 +6046,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6067,0 +6089,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6075,0 +6100,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6116,0 +6143,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6124,0 +6154,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6175,0 +6207,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6185,0 +6220,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6234,0 +6271,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6242,0 +6282,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6288,0 +6330,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6296,0 +6341,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6342,0 +6389,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n@@ -6350,0 +6400,2 @@\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n@@ -6396,0 +6448,3 @@\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2249,0 +2249,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2250,2 +2259,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2254,1 +2261,1 @@\n-                                     current_thread, depth, slot);\n+                                     current_thread, depth, slot, self);\n@@ -2262,7 +2269,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, current_thread, depth, slot);\n+    VM_GetOrSetLocal op(java_thread, current_thread, depth, slot, self);\n@@ -2289,0 +2290,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2290,2 +2300,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2294,1 +2302,1 @@\n-                                   current_thread, depth);\n+                                   current_thread, depth, self);\n@@ -2302,7 +2310,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetReceiver op(java_thread, current_thread, depth);\n+    VM_GetReceiver op(java_thread, current_thread, depth, self);\n@@ -2330,0 +2332,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2331,2 +2342,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2335,1 +2344,1 @@\n-                                     depth, slot, T_INT);\n+                                     depth, slot, T_INT, self);\n@@ -2343,7 +2352,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT, self);\n@@ -2371,0 +2374,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2372,2 +2384,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2376,1 +2386,1 @@\n-                                     depth, slot, T_LONG);\n+                                     depth, slot, T_LONG, self);\n@@ -2384,7 +2394,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG, self);\n@@ -2412,0 +2416,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2413,2 +2426,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2417,1 +2428,1 @@\n-                                     depth, slot, T_FLOAT);\n+                                     depth, slot, T_FLOAT, self);\n@@ -2425,7 +2436,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT, self);\n@@ -2453,0 +2458,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2454,2 +2468,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2458,1 +2470,1 @@\n-                                     depth, slot, T_DOUBLE);\n+                                     depth, slot, T_DOUBLE, self);\n@@ -2466,7 +2478,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE, self);\n@@ -2493,0 +2499,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2496,2 +2511,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2500,1 +2513,1 @@\n-                                     depth, slot, T_OBJECT, val);\n+                                     depth, slot, T_OBJECT, val, self);\n@@ -2505,7 +2518,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_OBJECT, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_OBJECT, val, self);\n@@ -2529,0 +2536,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2532,2 +2548,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2536,1 +2550,1 @@\n-                                     depth, slot, T_INT, val);\n+                                     depth, slot, T_INT, val, self);\n@@ -2541,7 +2555,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_INT, val, self);\n@@ -2565,0 +2573,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2568,2 +2585,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2572,1 +2587,1 @@\n-                                     depth, slot, T_LONG, val);\n+                                     depth, slot, T_LONG, val, self);\n@@ -2577,7 +2592,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_LONG, val, self);\n@@ -2601,0 +2610,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2604,2 +2622,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2608,1 +2624,1 @@\n-                                     depth, slot, T_FLOAT, val);\n+                                     depth, slot, T_FLOAT, val, self);\n@@ -2613,7 +2629,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_FLOAT, val, self);\n@@ -2637,0 +2647,9 @@\n+  ThreadsListHandle tlh(current_thread);\n+\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+  bool self = is_JavaThread_current(java_thread, thread_obj);\n@@ -2640,2 +2659,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  oop thread_obj = current_thread_obj_or_resolve_external_guard(thread);\n@@ -2644,1 +2661,1 @@\n-                                     depth, slot, T_DOUBLE, val);\n+                                     depth, slot, T_DOUBLE, val, self);\n@@ -2649,7 +2666,1 @@\n-    ThreadsListHandle tlh(current_thread);\n-    JavaThread* java_thread = NULL;\n-    err = get_JavaThread(tlh.list(), thread, &java_thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      return err;\n-    }\n-    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE, val);\n+    VM_GetOrSetLocal op(java_thread, depth, slot, T_DOUBLE, val, self);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":121,"deletions":110,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -174,0 +174,15 @@\n+  \/\/ Return true if the thread identified with a pair <jt,thr_obj> is current.\n+  \/\/ A passive carrier thread is not treated as current.\n+  static bool is_JavaThread_current(JavaThread* jt, oop thr_obj) {\n+    JavaThread* current = JavaThread::current();\n+    \/\/ jt can be NULL in case of a virtual thread\n+    if (jt == NULL || jt != current) {\n+      return false;\n+    }\n+    oop cur_obj = current->jvmti_vthread();\n+\n+    \/\/ cur_obj == NULL is true for normal platform threads only\n+    \/\/ otherwise it can be virtual or carrier thread.\n+    return cur_obj == NULL || cur_obj == thr_obj;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -435,1 +435,1 @@\n-                                           jint index, BasicType type, jvalue value, bool set)\n+                                           jint index, BasicType type, jvalue value, bool set, bool self)\n@@ -443,0 +443,1 @@\n+  , _self(self)\n@@ -750,2 +751,2 @@\n-VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false),\n+VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false, self),\n@@ -758,2 +759,2 @@\n-VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true),\n+VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true, self),\n@@ -766,2 +767,2 @@\n-VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth, int index)\n-  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false),\n+VM_GetOrSetLocal::VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth, int index, bool self)\n+  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false, self),\n@@ -792,0 +793,4 @@\n+  if (!(_self || _thread->is_carrier_thread_suspended())) {\n+    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    return NULL;\n+  }\n@@ -806,2 +811,2 @@\n-    JavaThread* thread, JavaThread* caller_thread, jint depth)\n-    : VM_GetOrSetLocal(thread, caller_thread, depth, 0) {}\n+    JavaThread* thread, JavaThread* caller_thread, jint depth, bool self)\n+    : VM_GetOrSetLocal(thread, caller_thread, depth, 0, self) {}\n@@ -817,2 +822,2 @@\n-                                                             jint index, BasicType type)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false)\n+                                                             jint index, BasicType type, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, _DEFAULT_VALUE, false, self)\n@@ -826,2 +831,2 @@\n-                                                             jint index, BasicType type, jvalue value)\n-  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true)\n+                                                             jint index, BasicType type, jvalue value, bool self)\n+  : VM_BaseGetOrSetLocal((JavaThread*)NULL, depth, index, type, value, true, self)\n@@ -835,2 +840,2 @@\n-                                                             jint depth, int index)\n-  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false)\n+                                                             jint depth, int index, bool self)\n+  : VM_BaseGetOrSetLocal(calling_thread, depth, index, T_OBJECT, _DEFAULT_VALUE, false, self)\n@@ -851,0 +856,5 @@\n+  if (!(_self || JvmtiVTSuspender::is_vthread_suspended(_vthread_h()))) {\n+    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    return NULL;\n+  }\n+\n@@ -885,2 +895,2 @@\n-    JvmtiEnv* env, Handle vthread_h, JavaThread* caller_thread, jint depth)\n-    : VM_VirtualThreadGetOrSetLocal(env, vthread_h, caller_thread, depth, 0) {}\n+    JvmtiEnv* env, Handle vthread_h, JavaThread* caller_thread, jint depth, bool self)\n+    : VM_VirtualThreadGetOrSetLocal(env, vthread_h, caller_thread, depth, 0, self) {}\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -322,0 +322,1 @@\n+  bool        _self;\n@@ -337,1 +338,1 @@\n-                       BasicType type, jvalue value, bool set);\n+                       BasicType type, jvalue value, bool set, bool self);\n@@ -361,1 +362,1 @@\n-  VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type);\n+  VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, bool self);\n@@ -364,1 +365,1 @@\n-  VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value);\n+  VM_GetOrSetLocal(JavaThread* thread, jint depth, jint index, BasicType type, jvalue value, bool self);\n@@ -367,2 +368,1 @@\n-  VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth,\n-                   int index);\n+  VM_GetOrSetLocal(JavaThread* thread, JavaThread* calling_thread, jint depth, int index, bool self);\n@@ -382,1 +382,1 @@\n-  VM_GetReceiver(JavaThread* thread, JavaThread* calling_thread, jint depth);\n+  VM_GetReceiver(JavaThread* thread, JavaThread* calling_thread, jint depth, bool self);\n@@ -396,1 +396,1 @@\n-  VM_VirtualThreadGetOrSetLocal(JvmtiEnv* env, Handle vthread_h, jint depth, jint index, BasicType type);\n+  VM_VirtualThreadGetOrSetLocal(JvmtiEnv* env, Handle vthread_h, jint depth, jint index, BasicType type, bool self);\n@@ -400,1 +400,1 @@\n-                                jint index, BasicType type, jvalue value);\n+                                jint index, BasicType type, jvalue value, bool self);\n@@ -404,1 +404,1 @@\n-                                jint depth, int index);\n+                                jint depth, int index, bool self);\n@@ -416,1 +416,1 @@\n-  VM_VirtualThreadGetReceiver(JvmtiEnv* env, Handle vthread_h, JavaThread* calling_thread, jint depth);\n+  VM_VirtualThreadGetReceiver(JvmtiEnv* env, Handle vthread_h, JavaThread* calling_thread, jint depth, bool self);\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4370,11 +4370,3 @@\n-  \/\/ The class file bytes from before any retransformable agents mucked\n-  \/\/ with them was cached on the scratch class, move to the_class.\n-  \/\/ Note: we still want to do this if nothing needed caching since it\n-  \/\/ should get cleared in the_class too.\n-  if (the_class->get_cached_class_file() == 0) {\n-    \/\/ the_class doesn't have a cache yet so copy it\n-    the_class->set_cached_class_file(scratch_class->get_cached_class_file());\n-  }\n-  else if (scratch_class->get_cached_class_file() !=\n-           the_class->get_cached_class_file()) {\n-    \/\/ The same class can be present twice in the scratch classes list or there\n+  if (scratch_class->get_cached_class_file() != the_class->get_cached_class_file()) {\n+    \/\/ 1. the_class doesn't have a cache yet, scratch_class does have a cache.\n+    \/\/ 2. The same class can be present twice in the scratch classes list or there\n@@ -4382,2 +4374,8 @@\n-    \/\/ In such cases we have to deallocate scratch_class cached_class_file.\n-    os::free(scratch_class->get_cached_class_file());\n+    \/\/ the_class and scratch_class have the same cached bytes, but different buffers.\n+    \/\/ In such cases we need to deallocate one of the buffers.\n+    \/\/ 3. RedefineClasses and the_class has cached bytes from a previous transformation.\n+    \/\/ In the case we need to use class bytes from scratch_class.\n+    if (the_class->get_cached_class_file() != nullptr) {\n+      os::free(the_class->get_cached_class_file());\n+    }\n+    the_class->set_cached_class_file(scratch_class->get_cached_class_file());\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -358,18 +358,0 @@\n-void* NativeLookup::dll_load(const methodHandle& method) {\n-  if (method->has_native_function()) {\n-\n-    address current_entry = method->native_function();\n-\n-    char dll_name[JVM_MAXPATHLEN];\n-    dll_name[0] = '\\0';\n-    int offset;\n-    bool ret = os::dll_address_to_library_name(current_entry, dll_name, sizeof(dll_name), &offset);\n-    if (ret && dll_name[0] != '\\0') {\n-      char ebuf[32];\n-      return os::dll_load(dll_name, ebuf, sizeof(ebuf));\n-    }\n-  }\n-\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  static void* dll_load(const methodHandle& method);\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -900,1 +900,0 @@\n-  assert(event->should_commit(), \"invariant\");\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -206,5 +206,1 @@\n-      #if _MSC_VER == 1800\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 12.0 (VS2013)\"\n-      #elif _MSC_VER == 1900\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 14.0 (VS2015)\"\n-      #elif _MSC_VER == 1911\n+      #if _MSC_VER == 1911\n@@ -246,0 +242,4 @@\n+      #elif _MSC_VER == 1932\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.2 (VS2022)\"\n+      #elif _MSC_VER == 1933\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.3 (VS2022)\"\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-#include \"metaprogramming\/enableIf.hpp\"\n@@ -65,0 +64,1 @@\n+#include \"utilities\/parseInteger.hpp\"\n@@ -748,109 +748,0 @@\n-template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ signed 32-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  \/\/ Don't use strtol -- on 64-bit builds, \"long\" could be either 32- or 64-bits\n-  \/\/ so the range tests could be tautological and might cause compiler warnings.\n-  STATIC_ASSERT(sizeof(long long) >= 8); \/\/ C++ specification\n-  errno = 0; \/\/ errno is thread safe\n-  long long v = strtoll(s, endptr, base);\n-  if (errno != 0 || v < min_jint || v > max_jint) {\n-    return false;\n-  }\n-  *result = static_cast<T>(v);\n-  return true;\n-}\n-\n-template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ unsigned 32-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  if (s[0] == '-') {\n-    return false;\n-  }\n-  \/\/ Don't use strtoul -- same reason as above.\n-  STATIC_ASSERT(sizeof(unsigned long long) >= 8); \/\/ C++ specification\n-  errno = 0; \/\/ errno is thread safe\n-  unsigned long long v = strtoull(s, endptr, base);\n-  if (errno != 0 || v > max_juint) {\n-    return false;\n-  }\n-  *result = static_cast<T>(v);\n-  return true;\n-}\n-\n-template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ signed 64-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  errno = 0; \/\/ errno is thread safe\n-  *result = strtoll(s, endptr, base);\n-  return errno == 0;\n-}\n-\n-template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ unsigned 64-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  if (s[0] == '-') {\n-    return false;\n-  }\n-  errno = 0; \/\/ errno is thread safe\n-  *result = strtoull(s, endptr, base);\n-  return errno == 0;\n-}\n-\n-template<typename T>\n-static bool multiply_by_1k(T& n) {\n-  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n-      n <= std::numeric_limits<T>::max() \/ 1024) {\n-    n *= 1024;\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ All of the integral types that can be used for command line options:\n-\/\/   int, uint, intx, uintx, uint64_t, size_t\n-\/\/\n-\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n-\/\/    {signed, unsigned} x {32-bit, 64-bit}\n-\/\/\n-\/\/ We use SFINAE to pick the correct parse_integer_impl() function\n-template<typename T>\n-static bool parse_integer(const char *s, T* result) {\n-  if (!isdigit(s[0]) && s[0] != '-') {\n-    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n-    return false;\n-  }\n-\n-  T n = 0;\n-  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n-                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n-  char* remainder;\n-\n-  if (!parse_integer_impl(s, &remainder, (is_hex ? 16 : 10), &n)) {\n-    return false;\n-  }\n-\n-  \/\/ Fail if no number was read at all or if the remainder contains more than a single non-digit character.\n-  if (remainder == s || strlen(remainder) > 1) {\n-    return false;\n-  }\n-\n-  switch (*remainder) {\n-    case 'T': case 't':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'G': case 'g':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'M': case 'm':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'K': case 'k':\n-      if (!multiply_by_1k(n)) return false;\n-      break;\n-    case '\\0':\n-      break;\n-    default:\n-      return false;\n-  }\n-\n-  *result = n;\n-  return true;\n-}\n-\n@@ -3171,6 +3062,0 @@\n-\n-  \/\/ Zero runs without compilers. Do not let compiler selection code\n-  \/\/ to force it into Serial GC, let the GC ergonomics decide.\n-  if (FLAG_IS_DEFAULT(NeverActAsServerClassMachine)) {\n-    FLAG_SET_ERGO(NeverActAsServerClassMachine, false);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":116,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -596,2 +596,2 @@\n-    st->print(\" - obj    [\");\n-    current->obj()->print_value_on(st);\n+    st->print(\" - obj    [%s\", current->obj() == nullptr ? \"null\" : \"\");\n+    if (current->obj() != nullptr) current->obj()->print_value_on(st);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -679,3 +679,0 @@\n-  product(bool, DynamicallyResizeSystemDictionaries, true, DIAGNOSTIC,      \\\n-          \"Dynamically resize system dictionaries as needed\")               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -383,0 +386,10 @@\n+void MutexLocker::post_initialize() {\n+  \/\/ Print mutex ranks if requested.\n+  LogTarget(Info, vmmutex) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    print_lock_ranks(&ls);\n+  }\n+}\n+\n@@ -412,0 +425,36 @@\n+\n+void print_lock_ranks(outputStream* st) {\n+  st->print_cr(\"VM Mutex\/Monitor ranks: \");\n+\n+#ifdef ASSERT\n+  \/\/ Be extra defensive and figure out the bounds on\n+  \/\/ ranks right here. This also saves a bit of time\n+  \/\/ in the #ranks*#mutexes loop below.\n+  int min_rank = INT_MAX;\n+  int max_rank = INT_MIN;\n+  for (int i = 0; i < _num_mutex; i++) {\n+    Mutex* m = _mutex_array[i];\n+    int r = (int) m->rank();\n+    if (min_rank > r) min_rank = r;\n+    if (max_rank < r) max_rank = r;\n+  }\n+\n+  \/\/ Print the listings rank by rank\n+  for (int r = min_rank; r <= max_rank; r++) {\n+    bool first = true;\n+    for (int i = 0; i < _num_mutex; i++) {\n+      Mutex* m = _mutex_array[i];\n+      if (r != (int) m->rank()) continue;\n+\n+      if (first) {\n+        st->cr();\n+        st->print_cr(\"Rank \\\"%s\\\":\", m->rank_name());\n+        first = false;\n+      }\n+      st->print_cr(\"  %s\", m->name());\n+    }\n+  }\n+#else\n+  st->print_cr(\"  Only known in debug builds.\");\n+#endif \/\/ ASSERT\n+}\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+void print_lock_ranks(outputStream* st);\n@@ -228,0 +229,2 @@\n+\n+  static void post_initialize();\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1419,0 +1419,6 @@\n+static inline bool is_excluded(const Klass* monitor_klass) {\n+  assert(monitor_klass != nullptr, \"invariant\");\n+  NOT_JFR_RETURN_(false);\n+  JFR_ONLY(return vmSymbols::jfr_chunk_rotation_monitor() == monitor_klass->name());\n+}\n+\n@@ -1426,1 +1432,5 @@\n-  event->set_monitorClass(monitor->object()->klass());\n+  const Klass* monitor_klass = monitor->object()->klass();\n+  if (is_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -658,0 +658,5 @@\n+  \/\/ Check for overflow.\n+  if (outer_size < size) {\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -277,0 +277,4 @@\n+JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))\n+  return (jfloat)x;\n+JRT_END\n+\n@@ -310,4 +314,0 @@\n-JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))\n-  return (jfloat)x;\n-JRT_END\n-\n@@ -454,0 +454,80 @@\n+\/\/ Reference implementation at src\/java.base\/share\/classes\/java\/lang\/Float.java:floatToFloat16\n+JRT_LEAF(jshort, SharedRuntime::f2hf(jfloat  x))\n+  jint doppel = SharedRuntime::f2i(x);\n+  jshort sign_bit = (jshort) ((doppel & 0x80000000) >> 16);\n+  if (g_isnan(x))\n+    return (jshort)(sign_bit | 0x7c00 | (doppel & 0x007fe000) >> 13 | (doppel & 0x00001ff0) >> 4 | (doppel & 0x0000000f));\n+\n+  jfloat abs_f = (x >= 0.0f) ? x : (x * -1.0f);\n+\n+  \/\/ Overflow threshold is halffloat max value + 1\/2 ulp\n+  if (abs_f >= (65504.0f + 16.0f)) {\n+    return (jshort)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n+  }\n+\n+  \/\/ Smallest magnitude of Halffloat is 0x1.0p-24, half-way or smaller rounds to zero\n+  if (abs_f <= (pow(2, -24) * 0.5f)) { \/\/ Covers float zeros and subnormals.\n+    return sign_bit; \/\/ Positive or negative zero\n+  }\n+\n+  jint exp = 0x7f800000 & doppel;\n+\n+  \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+  \/\/ the difference exp_delta = E_min - exp.  This is the excess\n+  \/\/ shift value, in addition to 13, to be used in the\n+  \/\/ computations below. Further the (hidden) msb with value 1\n+  \/\/ in f must be involved as well\n+  jint exp_delta = 0;\n+  jint msb = 0x00000000;\n+  if (exp < -14) {\n+    exp_delta = -14 - exp;\n+    exp = -15;\n+    msb = 0x00800000;\n+  }\n+  jint f_signif_bits = ((doppel & 0x007fffff) | msb);\n+\n+  \/\/ Significand bits as if using rounding to zero\n+  jshort signif_bits = (jshort)(f_signif_bits >> (13 + exp_delta));\n+\n+  jint lsb = f_signif_bits & (1 << (13 + exp_delta));\n+  jint round  = f_signif_bits & (1 << (12 + exp_delta));\n+  jint sticky = f_signif_bits & ((1 << (12 + exp_delta)) - 1);\n+\n+  if (round != 0 && ((lsb | sticky) != 0 )) {\n+    signif_bits++;\n+  }\n+\n+  return (jshort)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+JRT_END\n+\n+\/\/ Reference implementation at src\/java.base\/share\/classes\/java\/lang\/Float.java:float16ToFloat\n+JRT_LEAF(jfloat, SharedRuntime::hf2f(jshort x))\n+  \/\/ Halffloat format has 1 signbit, 5 exponent bits and\n+  \/\/ 10 significand bits\n+  jint hf_arg = (jint)x;\n+  jint hf_sign_bit = 0x8000 & hf_arg;\n+  jint hf_exp_bits = 0x7c00 & hf_arg;\n+  jint hf_significand_bits = 0x03ff & hf_arg;\n+\n+  jint significand_shift = 13; \/\/difference between float and halffloat precision\n+\n+  jfloat sign = (hf_sign_bit != 0) ? -1.0f : 1.0f;\n+\n+  \/\/ Extract halffloat exponent, remove its bias\n+  jint hf_exp = (hf_exp_bits >> 10) - 15;\n+\n+  if (hf_exp == -15) {\n+    \/\/ For subnormal values, return 2^-24 * significand bits\n+    return (sign * (pow(2,-24)) * hf_significand_bits);\n+  }else if (hf_exp == 16) {\n+    return (hf_significand_bits == 0) ? sign * float_infinity : (SharedRuntime::i2f((hf_sign_bit << 16) | 0x7f800000 |\n+           (hf_significand_bits << significand_shift)));\n+  }\n+\n+  \/\/ Add the bias of float exponent and shift\n+  int float_exp_bits = (hf_exp + 127) << (24 - 1);\n+\n+  \/\/ Combine sign, exponent and significand bits\n+  return SharedRuntime::i2f((hf_sign_bit << 16) | float_exp_bits | (hf_significand_bits << significand_shift));\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":84,"deletions":4,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -133,0 +133,3 @@\n+  static jfloat  hf2f(jshort  x);\n+  static jshort  f2hf(jfloat  x);\n+  static jfloat  i2f (jint    x);\n@@ -135,1 +138,0 @@\n-  static jfloat  i2f (jint    x);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1235,1 +1235,0 @@\n-  assert(event->should_commit(), \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -650,0 +650,1 @@\n+  MutexLocker::post_initialize();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -261,1 +261,0 @@\n-  assert(event->should_commit(), \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-    fs = new (ResourceObj::C_HEAP, mtInternal) fileStream(path);\n+    fs = new (mtInternal) fileStream(path);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+#define INT32_FORMAT_X           \"0x%\"        PRIx32\n@@ -116,0 +117,1 @@\n+#define UINT32_FORMAT_X          \"0x%\"        PRIx32\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -671,1 +671,1 @@\n-  fileStream* file = new(ResourceObj::C_HEAP, mtInternal) fileStream(try_name);\n+  fileStream* file = new (mtInternal) fileStream(try_name);\n@@ -689,1 +689,1 @@\n-  file = new(ResourceObj::C_HEAP, mtInternal) fileStream(try_name);\n+  file = new (mtInternal) fileStream(try_name);\n@@ -706,1 +706,1 @@\n-    _outer_xmlStream = new(ResourceObj::C_HEAP, mtInternal) xmlStream(file);\n+    _outer_xmlStream = new(mtInternal) xmlStream(file);\n@@ -948,1 +948,1 @@\n-    defaultStream::instance = new(ResourceObj::C_HEAP, mtInternal) defaultStream();\n+    defaultStream::instance = new(mtInternal) defaultStream();\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-class outputStream : public ResourceObj {\n+class outputStream : public CHeapObjBase {\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_PARSE_INTEGER_HPP\n+#define SHARE_UTILITIES_PARSE_INTEGER_HPP\n+\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include <errno.h>\n+#include <limits>\n+#include <stdlib.h>\n+\n+\/\/ *************************************************************************\n+\/\/ ** Attention compatibility!                                            **\n+\/\/ ** These functions are used to parse JVM arguments (-XX). Be careful   **\n+\/\/ ** with behavioral changes here.                                       **\n+\/\/ *************************************************************************\n+\n+\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ signed 32-bit\n+inline bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  \/\/ Don't use strtol -- on 64-bit builds, \"long\" could be either 32- or 64-bits\n+  \/\/ so the range tests could be tautological and might cause compiler warnings.\n+  STATIC_ASSERT(sizeof(long long) >= 8); \/\/ C++ specification\n+  errno = 0; \/\/ errno is thread safe\n+  long long v = strtoll(s, endptr, base);\n+  if (errno != 0 || v < min_jint || v > max_jint) {\n+    return false;\n+  }\n+  *result = static_cast<T>(v);\n+  return true;\n+}\n+\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ unsigned 32-bit\n+inline bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  if (s[0] == '-') {\n+    return false;\n+  }\n+  \/\/ Don't use strtoul -- same reason as above.\n+  STATIC_ASSERT(sizeof(unsigned long long) >= 8); \/\/ C++ specification\n+  errno = 0; \/\/ errno is thread safe\n+  unsigned long long v = strtoull(s, endptr, base);\n+  if (errno != 0 || v > max_juint) {\n+    return false;\n+  }\n+  *result = static_cast<T>(v);\n+  return true;\n+}\n+\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ signed 64-bit\n+inline bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  errno = 0; \/\/ errno is thread safe\n+  *result = strtoll(s, endptr, base);\n+  return errno == 0;\n+}\n+\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ unsigned 64-bit\n+inline bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  if (s[0] == '-') {\n+    return false;\n+  }\n+  errno = 0; \/\/ errno is thread safe\n+  *result = strtoull(s, endptr, base);\n+  return errno == 0;\n+}\n+\n+\n+\/\/ Helper for parse_memory_size\n+template<typename T>\n+inline bool multiply_by_1k(T& n) {\n+  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n+      n <= std::numeric_limits<T>::max() \/ 1024) {\n+    n *= 1024;\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ Parses a memory size in the form \"<number>[<unit>]\" with valid units being\n+\/\/ \"k\", \"K\", \"m\", \"M\", \"g\", \"G\", \"t\", \"T\". Unit omitted means bytes. If unit is given,\n+\/\/ no space is allowed between number and unit. Number can be in either decimal form\n+\/\/ or in hexadecimal form, the latter must start with \"0x\".\n+\/\/\n+\/\/ Valid template arguments for T are signed\/unsigned 32\/64-bit values.\n+\/\/\n+\/\/ This function will parse until it encounters unparseable parts, then\n+\/\/ stop. If it read no valid memory size, it will fail.\n+\/\/\n+\/\/ Example: \"1024M:oom\" will yield true, result=1G, endptr pointing to \":oom\"\n+\n+template<typename T>\n+static bool parse_integer(const char *s, char **endptr, T* result) {\n+\n+  if (!isdigit(s[0]) && s[0] != '-') {\n+    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n+    return false;\n+  }\n+\n+  T n = 0;\n+  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n+                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n+  char* remainder;\n+\n+  if (!parse_integer_impl<T>(s, &remainder, (is_hex ? 16 : 10), &n)) {\n+    return false;\n+  }\n+  \/\/ Nothing parsed? That is an error too.\n+  if (remainder == s) {\n+    return false;\n+  }\n+\n+  switch (*remainder) {\n+    case 'T': case 't':\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n+    case 'G': case 'g':\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n+    case 'M': case 'm':\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n+    case 'K': case 'k':\n+      if (!multiply_by_1k(n)) return false;\n+      remainder ++; \/\/ shave off parsed unit char\n+      break;\n+    default:\n+      \/\/ nothing. Return remainder unparsed.\n+      break;\n+  };\n+\n+  *result = n;\n+  *endptr = remainder;\n+  return true;\n+}\n+\n+\/\/ Same as parse_integer(const char *s, char **endptr, T* result), but does not allow unrecognizable\n+\/\/ characters. No remainder are allowed here.\n+\/\/ Example: \"100m\" - okay, \"100m:oom\" -> not okay\n+template<typename T>\n+static bool parse_integer(const char *s, T* result) {\n+  char* remainder;\n+  bool rc = parse_integer(s, &remainder, result);\n+  rc = rc && (*remainder == '\\0');\n+  return rc;\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_PARSE_INTEGER_HPP\n","filename":"src\/hotspot\/share\/utilities\/parseInteger.hpp","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -52,2 +52,959 @@\n-final class AESCrypt extends SymmetricCipher implements AESConstants\n-{\n+final class AESCrypt extends SymmetricCipher implements AESConstants {\n+    \/\/\n+    \/\/ Pre-computed tables, which are copied or derived from FIPS 197.\n+    \/\/\n+\n+    \/\/ the pre-computed substitution table (S-box), 256 bytes\n+    private static final byte[] S = {\n+            (byte)0x63, (byte)0x7C, (byte)0x77, (byte)0x7B,\n+            (byte)0xF2, (byte)0x6B, (byte)0x6F, (byte)0xC5,\n+            (byte)0x30, (byte)0x01, (byte)0x67, (byte)0x2B,\n+            (byte)0xFE, (byte)0xD7, (byte)0xAB, (byte)0x76,\n+            (byte)0xCA, (byte)0x82, (byte)0xC9, (byte)0x7D,\n+            (byte)0xFA, (byte)0x59, (byte)0x47, (byte)0xF0,\n+            (byte)0xAD, (byte)0xD4, (byte)0xA2, (byte)0xAF,\n+            (byte)0x9C, (byte)0xA4, (byte)0x72, (byte)0xC0,\n+            (byte)0xB7, (byte)0xFD, (byte)0x93, (byte)0x26,\n+            (byte)0x36, (byte)0x3F, (byte)0xF7, (byte)0xCC,\n+            (byte)0x34, (byte)0xA5, (byte)0xE5, (byte)0xF1,\n+            (byte)0x71, (byte)0xD8, (byte)0x31, (byte)0x15,\n+            (byte)0x04, (byte)0xC7, (byte)0x23, (byte)0xC3,\n+            (byte)0x18, (byte)0x96, (byte)0x05, (byte)0x9A,\n+            (byte)0x07, (byte)0x12, (byte)0x80, (byte)0xE2,\n+            (byte)0xEB, (byte)0x27, (byte)0xB2, (byte)0x75,\n+            (byte)0x09, (byte)0x83, (byte)0x2C, (byte)0x1A,\n+            (byte)0x1B, (byte)0x6E, (byte)0x5A, (byte)0xA0,\n+            (byte)0x52, (byte)0x3B, (byte)0xD6, (byte)0xB3,\n+            (byte)0x29, (byte)0xE3, (byte)0x2F, (byte)0x84,\n+            (byte)0x53, (byte)0xD1, (byte)0x00, (byte)0xED,\n+            (byte)0x20, (byte)0xFC, (byte)0xB1, (byte)0x5B,\n+            (byte)0x6A, (byte)0xCB, (byte)0xBE, (byte)0x39,\n+            (byte)0x4A, (byte)0x4C, (byte)0x58, (byte)0xCF,\n+            (byte)0xD0, (byte)0xEF, (byte)0xAA, (byte)0xFB,\n+            (byte)0x43, (byte)0x4D, (byte)0x33, (byte)0x85,\n+            (byte)0x45, (byte)0xF9, (byte)0x02, (byte)0x7F,\n+            (byte)0x50, (byte)0x3C, (byte)0x9F, (byte)0xA8,\n+            (byte)0x51, (byte)0xA3, (byte)0x40, (byte)0x8F,\n+            (byte)0x92, (byte)0x9D, (byte)0x38, (byte)0xF5,\n+            (byte)0xBC, (byte)0xB6, (byte)0xDA, (byte)0x21,\n+            (byte)0x10, (byte)0xFF, (byte)0xF3, (byte)0xD2,\n+            (byte)0xCD, (byte)0x0C, (byte)0x13, (byte)0xEC,\n+            (byte)0x5F, (byte)0x97, (byte)0x44, (byte)0x17,\n+            (byte)0xC4, (byte)0xA7, (byte)0x7E, (byte)0x3D,\n+            (byte)0x64, (byte)0x5D, (byte)0x19, (byte)0x73,\n+            (byte)0x60, (byte)0x81, (byte)0x4F, (byte)0xDC,\n+            (byte)0x22, (byte)0x2A, (byte)0x90, (byte)0x88,\n+            (byte)0x46, (byte)0xEE, (byte)0xB8, (byte)0x14,\n+            (byte)0xDE, (byte)0x5E, (byte)0x0B, (byte)0xDB,\n+            (byte)0xE0, (byte)0x32, (byte)0x3A, (byte)0x0A,\n+            (byte)0x49, (byte)0x06, (byte)0x24, (byte)0x5C,\n+            (byte)0xC2, (byte)0xD3, (byte)0xAC, (byte)0x62,\n+            (byte)0x91, (byte)0x95, (byte)0xE4, (byte)0x79,\n+            (byte)0xE7, (byte)0xC8, (byte)0x37, (byte)0x6D,\n+            (byte)0x8D, (byte)0xD5, (byte)0x4E, (byte)0xA9,\n+            (byte)0x6C, (byte)0x56, (byte)0xF4, (byte)0xEA,\n+            (byte)0x65, (byte)0x7A, (byte)0xAE, (byte)0x08,\n+            (byte)0xBA, (byte)0x78, (byte)0x25, (byte)0x2E,\n+            (byte)0x1C, (byte)0xA6, (byte)0xB4, (byte)0xC6,\n+            (byte)0xE8, (byte)0xDD, (byte)0x74, (byte)0x1F,\n+            (byte)0x4B, (byte)0xBD, (byte)0x8B, (byte)0x8A,\n+            (byte)0x70, (byte)0x3E, (byte)0xB5, (byte)0x66,\n+            (byte)0x48, (byte)0x03, (byte)0xF6, (byte)0x0E,\n+            (byte)0x61, (byte)0x35, (byte)0x57, (byte)0xB9,\n+            (byte)0x86, (byte)0xC1, (byte)0x1D, (byte)0x9E,\n+            (byte)0xE1, (byte)0xF8, (byte)0x98, (byte)0x11,\n+            (byte)0x69, (byte)0xD9, (byte)0x8E, (byte)0x94,\n+            (byte)0x9B, (byte)0x1E, (byte)0x87, (byte)0xE9,\n+            (byte)0xCE, (byte)0x55, (byte)0x28, (byte)0xDF,\n+            (byte)0x8C, (byte)0xA1, (byte)0x89, (byte)0x0D,\n+            (byte)0xBF, (byte)0xE6, (byte)0x42, (byte)0x68,\n+            (byte)0x41, (byte)0x99, (byte)0x2D, (byte)0x0F,\n+            (byte)0xB0, (byte)0x54, (byte)0xBB, (byte)0x16,\n+    };\n+\n+    \/\/ the pre-computed substitution table (inverse S-box), 256 bytes\n+    private static final byte[] Si = {\n+            (byte)0x52, (byte)0x09, (byte)0x6A, (byte)0xD5,\n+            (byte)0x30, (byte)0x36, (byte)0xA5, (byte)0x38,\n+            (byte)0xBF, (byte)0x40, (byte)0xA3, (byte)0x9E,\n+            (byte)0x81, (byte)0xF3, (byte)0xD7, (byte)0xFB,\n+            (byte)0x7C, (byte)0xE3, (byte)0x39, (byte)0x82,\n+            (byte)0x9B, (byte)0x2F, (byte)0xFF, (byte)0x87,\n+            (byte)0x34, (byte)0x8E, (byte)0x43, (byte)0x44,\n+            (byte)0xC4, (byte)0xDE, (byte)0xE9, (byte)0xCB,\n+            (byte)0x54, (byte)0x7B, (byte)0x94, (byte)0x32,\n+            (byte)0xA6, (byte)0xC2, (byte)0x23, (byte)0x3D,\n+            (byte)0xEE, (byte)0x4C, (byte)0x95, (byte)0x0B,\n+            (byte)0x42, (byte)0xFA, (byte)0xC3, (byte)0x4E,\n+            (byte)0x08, (byte)0x2E, (byte)0xA1, (byte)0x66,\n+            (byte)0x28, (byte)0xD9, (byte)0x24, (byte)0xB2,\n+            (byte)0x76, (byte)0x5B, (byte)0xA2, (byte)0x49,\n+            (byte)0x6D, (byte)0x8B, (byte)0xD1, (byte)0x25,\n+            (byte)0x72, (byte)0xF8, (byte)0xF6, (byte)0x64,\n+            (byte)0x86, (byte)0x68, (byte)0x98, (byte)0x16,\n+            (byte)0xD4, (byte)0xA4, (byte)0x5C, (byte)0xCC,\n+            (byte)0x5D, (byte)0x65, (byte)0xB6, (byte)0x92,\n+            (byte)0x6C, (byte)0x70, (byte)0x48, (byte)0x50,\n+            (byte)0xFD, (byte)0xED, (byte)0xB9, (byte)0xDA,\n+            (byte)0x5E, (byte)0x15, (byte)0x46, (byte)0x57,\n+            (byte)0xA7, (byte)0x8D, (byte)0x9D, (byte)0x84,\n+            (byte)0x90, (byte)0xD8, (byte)0xAB, (byte)0x00,\n+            (byte)0x8C, (byte)0xBC, (byte)0xD3, (byte)0x0A,\n+            (byte)0xF7, (byte)0xE4, (byte)0x58, (byte)0x05,\n+            (byte)0xB8, (byte)0xB3, (byte)0x45, (byte)0x06,\n+            (byte)0xD0, (byte)0x2C, (byte)0x1E, (byte)0x8F,\n+            (byte)0xCA, (byte)0x3F, (byte)0x0F, (byte)0x02,\n+            (byte)0xC1, (byte)0xAF, (byte)0xBD, (byte)0x03,\n+            (byte)0x01, (byte)0x13, (byte)0x8A, (byte)0x6B,\n+            (byte)0x3A, (byte)0x91, (byte)0x11, (byte)0x41,\n+            (byte)0x4F, (byte)0x67, (byte)0xDC, (byte)0xEA,\n+            (byte)0x97, (byte)0xF2, (byte)0xCF, (byte)0xCE,\n+            (byte)0xF0, (byte)0xB4, (byte)0xE6, (byte)0x73,\n+            (byte)0x96, (byte)0xAC, (byte)0x74, (byte)0x22,\n+            (byte)0xE7, (byte)0xAD, (byte)0x35, (byte)0x85,\n+            (byte)0xE2, (byte)0xF9, (byte)0x37, (byte)0xE8,\n+            (byte)0x1C, (byte)0x75, (byte)0xDF, (byte)0x6E,\n+            (byte)0x47, (byte)0xF1, (byte)0x1A, (byte)0x71,\n+            (byte)0x1D, (byte)0x29, (byte)0xC5, (byte)0x89,\n+            (byte)0x6F, (byte)0xB7, (byte)0x62, (byte)0x0E,\n+            (byte)0xAA, (byte)0x18, (byte)0xBE, (byte)0x1B,\n+            (byte)0xFC, (byte)0x56, (byte)0x3E, (byte)0x4B,\n+            (byte)0xC6, (byte)0xD2, (byte)0x79, (byte)0x20,\n+            (byte)0x9A, (byte)0xDB, (byte)0xC0, (byte)0xFE,\n+            (byte)0x78, (byte)0xCD, (byte)0x5A, (byte)0xF4,\n+            (byte)0x1F, (byte)0xDD, (byte)0xA8, (byte)0x33,\n+            (byte)0x88, (byte)0x07, (byte)0xC7, (byte)0x31,\n+            (byte)0xB1, (byte)0x12, (byte)0x10, (byte)0x59,\n+            (byte)0x27, (byte)0x80, (byte)0xEC, (byte)0x5F,\n+            (byte)0x60, (byte)0x51, (byte)0x7F, (byte)0xA9,\n+            (byte)0x19, (byte)0xB5, (byte)0x4A, (byte)0x0D,\n+            (byte)0x2D, (byte)0xE5, (byte)0x7A, (byte)0x9F,\n+            (byte)0x93, (byte)0xC9, (byte)0x9C, (byte)0xEF,\n+            (byte)0xA0, (byte)0xE0, (byte)0x3B, (byte)0x4D,\n+            (byte)0xAE, (byte)0x2A, (byte)0xF5, (byte)0xB0,\n+            (byte)0xC8, (byte)0xEB, (byte)0xBB, (byte)0x3C,\n+            (byte)0x83, (byte)0x53, (byte)0x99, (byte)0x61,\n+            (byte)0x17, (byte)0x2B, (byte)0x04, (byte)0x7E,\n+            (byte)0xBA, (byte)0x77, (byte)0xD6, (byte)0x26,\n+            (byte)0xE1, (byte)0x69, (byte)0x14, (byte)0x63,\n+            (byte)0x55, (byte)0x21, (byte)0x0C, (byte)0x7D,\n+    };\n+\n+    \/\/ pre-computed tables (T-box)\n+    private static final int[] T1 = {\n+            0xC66363A5, 0xF87C7C84, 0xEE777799, 0xF67B7B8D,\n+            0xFFF2F20D, 0xD66B6BBD, 0xDE6F6FB1, 0x91C5C554,\n+            0x60303050, 0x02010103, 0xCE6767A9, 0x562B2B7D,\n+            0xE7FEFE19, 0xB5D7D762, 0x4DABABE6, 0xEC76769A,\n+            0x8FCACA45, 0x1F82829D, 0x89C9C940, 0xFA7D7D87,\n+            0xEFFAFA15, 0xB25959EB, 0x8E4747C9, 0xFBF0F00B,\n+            0x41ADADEC, 0xB3D4D467, 0x5FA2A2FD, 0x45AFAFEA,\n+            0x239C9CBF, 0x53A4A4F7, 0xE4727296, 0x9BC0C05B,\n+            0x75B7B7C2, 0xE1FDFD1C, 0x3D9393AE, 0x4C26266A,\n+            0x6C36365A, 0x7E3F3F41, 0xF5F7F702, 0x83CCCC4F,\n+            0x6834345C, 0x51A5A5F4, 0xD1E5E534, 0xF9F1F108,\n+            0xE2717193, 0xABD8D873, 0x62313153, 0x2A15153F,\n+            0x0804040C, 0x95C7C752, 0x46232365, 0x9DC3C35E,\n+            0x30181828, 0x379696A1, 0x0A05050F, 0x2F9A9AB5,\n+            0x0E070709, 0x24121236, 0x1B80809B, 0xDFE2E23D,\n+            0xCDEBEB26, 0x4E272769, 0x7FB2B2CD, 0xEA75759F,\n+            0x1209091B, 0x1D83839E, 0x582C2C74, 0x341A1A2E,\n+            0x361B1B2D, 0xDC6E6EB2, 0xB45A5AEE, 0x5BA0A0FB,\n+            0xA45252F6, 0x763B3B4D, 0xB7D6D661, 0x7DB3B3CE,\n+            0x5229297B, 0xDDE3E33E, 0x5E2F2F71, 0x13848497,\n+            0xA65353F5, 0xB9D1D168, 0x00000000, 0xC1EDED2C,\n+            0x40202060, 0xE3FCFC1F, 0x79B1B1C8, 0xB65B5BED,\n+            0xD46A6ABE, 0x8DCBCB46, 0x67BEBED9, 0x7239394B,\n+            0x944A4ADE, 0x984C4CD4, 0xB05858E8, 0x85CFCF4A,\n+            0xBBD0D06B, 0xC5EFEF2A, 0x4FAAAAE5, 0xEDFBFB16,\n+            0x864343C5, 0x9A4D4DD7, 0x66333355, 0x11858594,\n+            0x8A4545CF, 0xE9F9F910, 0x04020206, 0xFE7F7F81,\n+            0xA05050F0, 0x783C3C44, 0x259F9FBA, 0x4BA8A8E3,\n+            0xA25151F3, 0x5DA3A3FE, 0x804040C0, 0x058F8F8A,\n+            0x3F9292AD, 0x219D9DBC, 0x70383848, 0xF1F5F504,\n+            0x63BCBCDF, 0x77B6B6C1, 0xAFDADA75, 0x42212163,\n+            0x20101030, 0xE5FFFF1A, 0xFDF3F30E, 0xBFD2D26D,\n+            0x81CDCD4C, 0x180C0C14, 0x26131335, 0xC3ECEC2F,\n+            0xBE5F5FE1, 0x359797A2, 0x884444CC, 0x2E171739,\n+            0x93C4C457, 0x55A7A7F2, 0xFC7E7E82, 0x7A3D3D47,\n+            0xC86464AC, 0xBA5D5DE7, 0x3219192B, 0xE6737395,\n+            0xC06060A0, 0x19818198, 0x9E4F4FD1, 0xA3DCDC7F,\n+            0x44222266, 0x542A2A7E, 0x3B9090AB, 0x0B888883,\n+            0x8C4646CA, 0xC7EEEE29, 0x6BB8B8D3, 0x2814143C,\n+            0xA7DEDE79, 0xBC5E5EE2, 0x160B0B1D, 0xADDBDB76,\n+            0xDBE0E03B, 0x64323256, 0x743A3A4E, 0x140A0A1E,\n+            0x924949DB, 0x0C06060A, 0x4824246C, 0xB85C5CE4,\n+            0x9FC2C25D, 0xBDD3D36E, 0x43ACACEF, 0xC46262A6,\n+            0x399191A8, 0x319595A4, 0xD3E4E437, 0xF279798B,\n+            0xD5E7E732, 0x8BC8C843, 0x6E373759, 0xDA6D6DB7,\n+            0x018D8D8C, 0xB1D5D564, 0x9C4E4ED2, 0x49A9A9E0,\n+            0xD86C6CB4, 0xAC5656FA, 0xF3F4F407, 0xCFEAEA25,\n+            0xCA6565AF, 0xF47A7A8E, 0x47AEAEE9, 0x10080818,\n+            0x6FBABAD5, 0xF0787888, 0x4A25256F, 0x5C2E2E72,\n+            0x381C1C24, 0x57A6A6F1, 0x73B4B4C7, 0x97C6C651,\n+            0xCBE8E823, 0xA1DDDD7C, 0xE874749C, 0x3E1F1F21,\n+            0x964B4BDD, 0x61BDBDDC, 0x0D8B8B86, 0x0F8A8A85,\n+            0xE0707090, 0x7C3E3E42, 0x71B5B5C4, 0xCC6666AA,\n+            0x904848D8, 0x06030305, 0xF7F6F601, 0x1C0E0E12,\n+            0xC26161A3, 0x6A35355F, 0xAE5757F9, 0x69B9B9D0,\n+            0x17868691, 0x99C1C158, 0x3A1D1D27, 0x279E9EB9,\n+            0xD9E1E138, 0xEBF8F813, 0x2B9898B3, 0x22111133,\n+            0xD26969BB, 0xA9D9D970, 0x078E8E89, 0x339494A7,\n+            0x2D9B9BB6, 0x3C1E1E22, 0x15878792, 0xC9E9E920,\n+            0x87CECE49, 0xAA5555FF, 0x50282878, 0xA5DFDF7A,\n+            0x038C8C8F, 0x59A1A1F8, 0x09898980, 0x1A0D0D17,\n+            0x65BFBFDA, 0xD7E6E631, 0x844242C6, 0xD06868B8,\n+            0x824141C3, 0x299999B0, 0x5A2D2D77, 0x1E0F0F11,\n+            0x7BB0B0CB, 0xA85454FC, 0x6DBBBBD6, 0x2C16163A,\n+    };\n+\n+    private static final int[] T2 = {\n+            0xA5C66363, 0x84F87C7C, 0x99EE7777, 0x8DF67B7B,\n+            0x0DFFF2F2, 0xBDD66B6B, 0xB1DE6F6F, 0x5491C5C5,\n+            0x50603030, 0x03020101, 0xA9CE6767, 0x7D562B2B,\n+            0x19E7FEFE, 0x62B5D7D7, 0xE64DABAB, 0x9AEC7676,\n+            0x458FCACA, 0x9D1F8282, 0x4089C9C9, 0x87FA7D7D,\n+            0x15EFFAFA, 0xEBB25959, 0xC98E4747, 0x0BFBF0F0,\n+            0xEC41ADAD, 0x67B3D4D4, 0xFD5FA2A2, 0xEA45AFAF,\n+            0xBF239C9C, 0xF753A4A4, 0x96E47272, 0x5B9BC0C0,\n+            0xC275B7B7, 0x1CE1FDFD, 0xAE3D9393, 0x6A4C2626,\n+            0x5A6C3636, 0x417E3F3F, 0x02F5F7F7, 0x4F83CCCC,\n+            0x5C683434, 0xF451A5A5, 0x34D1E5E5, 0x08F9F1F1,\n+            0x93E27171, 0x73ABD8D8, 0x53623131, 0x3F2A1515,\n+            0x0C080404, 0x5295C7C7, 0x65462323, 0x5E9DC3C3,\n+            0x28301818, 0xA1379696, 0x0F0A0505, 0xB52F9A9A,\n+            0x090E0707, 0x36241212, 0x9B1B8080, 0x3DDFE2E2,\n+            0x26CDEBEB, 0x694E2727, 0xCD7FB2B2, 0x9FEA7575,\n+            0x1B120909, 0x9E1D8383, 0x74582C2C, 0x2E341A1A,\n+            0x2D361B1B, 0xB2DC6E6E, 0xEEB45A5A, 0xFB5BA0A0,\n+            0xF6A45252, 0x4D763B3B, 0x61B7D6D6, 0xCE7DB3B3,\n+            0x7B522929, 0x3EDDE3E3, 0x715E2F2F, 0x97138484,\n+            0xF5A65353, 0x68B9D1D1, 0x00000000, 0x2CC1EDED,\n+            0x60402020, 0x1FE3FCFC, 0xC879B1B1, 0xEDB65B5B,\n+            0xBED46A6A, 0x468DCBCB, 0xD967BEBE, 0x4B723939,\n+            0xDE944A4A, 0xD4984C4C, 0xE8B05858, 0x4A85CFCF,\n+            0x6BBBD0D0, 0x2AC5EFEF, 0xE54FAAAA, 0x16EDFBFB,\n+            0xC5864343, 0xD79A4D4D, 0x55663333, 0x94118585,\n+            0xCF8A4545, 0x10E9F9F9, 0x06040202, 0x81FE7F7F,\n+            0xF0A05050, 0x44783C3C, 0xBA259F9F, 0xE34BA8A8,\n+            0xF3A25151, 0xFE5DA3A3, 0xC0804040, 0x8A058F8F,\n+            0xAD3F9292, 0xBC219D9D, 0x48703838, 0x04F1F5F5,\n+            0xDF63BCBC, 0xC177B6B6, 0x75AFDADA, 0x63422121,\n+            0x30201010, 0x1AE5FFFF, 0x0EFDF3F3, 0x6DBFD2D2,\n+            0x4C81CDCD, 0x14180C0C, 0x35261313, 0x2FC3ECEC,\n+            0xE1BE5F5F, 0xA2359797, 0xCC884444, 0x392E1717,\n+            0x5793C4C4, 0xF255A7A7, 0x82FC7E7E, 0x477A3D3D,\n+            0xACC86464, 0xE7BA5D5D, 0x2B321919, 0x95E67373,\n+            0xA0C06060, 0x98198181, 0xD19E4F4F, 0x7FA3DCDC,\n+            0x66442222, 0x7E542A2A, 0xAB3B9090, 0x830B8888,\n+            0xCA8C4646, 0x29C7EEEE, 0xD36BB8B8, 0x3C281414,\n+            0x79A7DEDE, 0xE2BC5E5E, 0x1D160B0B, 0x76ADDBDB,\n+            0x3BDBE0E0, 0x56643232, 0x4E743A3A, 0x1E140A0A,\n+            0xDB924949, 0x0A0C0606, 0x6C482424, 0xE4B85C5C,\n+            0x5D9FC2C2, 0x6EBDD3D3, 0xEF43ACAC, 0xA6C46262,\n+            0xA8399191, 0xA4319595, 0x37D3E4E4, 0x8BF27979,\n+            0x32D5E7E7, 0x438BC8C8, 0x596E3737, 0xB7DA6D6D,\n+            0x8C018D8D, 0x64B1D5D5, 0xD29C4E4E, 0xE049A9A9,\n+            0xB4D86C6C, 0xFAAC5656, 0x07F3F4F4, 0x25CFEAEA,\n+            0xAFCA6565, 0x8EF47A7A, 0xE947AEAE, 0x18100808,\n+            0xD56FBABA, 0x88F07878, 0x6F4A2525, 0x725C2E2E,\n+            0x24381C1C, 0xF157A6A6, 0xC773B4B4, 0x5197C6C6,\n+            0x23CBE8E8, 0x7CA1DDDD, 0x9CE87474, 0x213E1F1F,\n+            0xDD964B4B, 0xDC61BDBD, 0x860D8B8B, 0x850F8A8A,\n+            0x90E07070, 0x427C3E3E, 0xC471B5B5, 0xAACC6666,\n+            0xD8904848, 0x05060303, 0x01F7F6F6, 0x121C0E0E,\n+            0xA3C26161, 0x5F6A3535, 0xF9AE5757, 0xD069B9B9,\n+            0x91178686, 0x5899C1C1, 0x273A1D1D, 0xB9279E9E,\n+            0x38D9E1E1, 0x13EBF8F8, 0xB32B9898, 0x33221111,\n+            0xBBD26969, 0x70A9D9D9, 0x89078E8E, 0xA7339494,\n+            0xB62D9B9B, 0x223C1E1E, 0x92158787, 0x20C9E9E9,\n+            0x4987CECE, 0xFFAA5555, 0x78502828, 0x7AA5DFDF,\n+            0x8F038C8C, 0xF859A1A1, 0x80098989, 0x171A0D0D,\n+            0xDA65BFBF, 0x31D7E6E6, 0xC6844242, 0xB8D06868,\n+            0xC3824141, 0xB0299999, 0x775A2D2D, 0x111E0F0F,\n+            0xCB7BB0B0, 0xFCA85454, 0xD66DBBBB, 0x3A2C1616,\n+    };\n+\n+    private static final int[] T3 = {\n+            0x63A5C663, 0x7C84F87C, 0x7799EE77, 0x7B8DF67B,\n+            0xF20DFFF2, 0x6BBDD66B, 0x6FB1DE6F, 0xC55491C5,\n+            0x30506030, 0x01030201, 0x67A9CE67, 0x2B7D562B,\n+            0xFE19E7FE, 0xD762B5D7, 0xABE64DAB, 0x769AEC76,\n+            0xCA458FCA, 0x829D1F82, 0xC94089C9, 0x7D87FA7D,\n+            0xFA15EFFA, 0x59EBB259, 0x47C98E47, 0xF00BFBF0,\n+            0xADEC41AD, 0xD467B3D4, 0xA2FD5FA2, 0xAFEA45AF,\n+            0x9CBF239C, 0xA4F753A4, 0x7296E472, 0xC05B9BC0,\n+            0xB7C275B7, 0xFD1CE1FD, 0x93AE3D93, 0x266A4C26,\n+            0x365A6C36, 0x3F417E3F, 0xF702F5F7, 0xCC4F83CC,\n+            0x345C6834, 0xA5F451A5, 0xE534D1E5, 0xF108F9F1,\n+            0x7193E271, 0xD873ABD8, 0x31536231, 0x153F2A15,\n+            0x040C0804, 0xC75295C7, 0x23654623, 0xC35E9DC3,\n+            0x18283018, 0x96A13796, 0x050F0A05, 0x9AB52F9A,\n+            0x07090E07, 0x12362412, 0x809B1B80, 0xE23DDFE2,\n+            0xEB26CDEB, 0x27694E27, 0xB2CD7FB2, 0x759FEA75,\n+            0x091B1209, 0x839E1D83, 0x2C74582C, 0x1A2E341A,\n+            0x1B2D361B, 0x6EB2DC6E, 0x5AEEB45A, 0xA0FB5BA0,\n+            0x52F6A452, 0x3B4D763B, 0xD661B7D6, 0xB3CE7DB3,\n+            0x297B5229, 0xE33EDDE3, 0x2F715E2F, 0x84971384,\n+            0x53F5A653, 0xD168B9D1, 0x00000000, 0xED2CC1ED,\n+            0x20604020, 0xFC1FE3FC, 0xB1C879B1, 0x5BEDB65B,\n+            0x6ABED46A, 0xCB468DCB, 0xBED967BE, 0x394B7239,\n+            0x4ADE944A, 0x4CD4984C, 0x58E8B058, 0xCF4A85CF,\n+            0xD06BBBD0, 0xEF2AC5EF, 0xAAE54FAA, 0xFB16EDFB,\n+            0x43C58643, 0x4DD79A4D, 0x33556633, 0x85941185,\n+            0x45CF8A45, 0xF910E9F9, 0x02060402, 0x7F81FE7F,\n+            0x50F0A050, 0x3C44783C, 0x9FBA259F, 0xA8E34BA8,\n+            0x51F3A251, 0xA3FE5DA3, 0x40C08040, 0x8F8A058F,\n+            0x92AD3F92, 0x9DBC219D, 0x38487038, 0xF504F1F5,\n+            0xBCDF63BC, 0xB6C177B6, 0xDA75AFDA, 0x21634221,\n+            0x10302010, 0xFF1AE5FF, 0xF30EFDF3, 0xD26DBFD2,\n+            0xCD4C81CD, 0x0C14180C, 0x13352613, 0xEC2FC3EC,\n+            0x5FE1BE5F, 0x97A23597, 0x44CC8844, 0x17392E17,\n+            0xC45793C4, 0xA7F255A7, 0x7E82FC7E, 0x3D477A3D,\n+            0x64ACC864, 0x5DE7BA5D, 0x192B3219, 0x7395E673,\n+            0x60A0C060, 0x81981981, 0x4FD19E4F, 0xDC7FA3DC,\n+            0x22664422, 0x2A7E542A, 0x90AB3B90, 0x88830B88,\n+            0x46CA8C46, 0xEE29C7EE, 0xB8D36BB8, 0x143C2814,\n+            0xDE79A7DE, 0x5EE2BC5E, 0x0B1D160B, 0xDB76ADDB,\n+            0xE03BDBE0, 0x32566432, 0x3A4E743A, 0x0A1E140A,\n+            0x49DB9249, 0x060A0C06, 0x246C4824, 0x5CE4B85C,\n+            0xC25D9FC2, 0xD36EBDD3, 0xACEF43AC, 0x62A6C462,\n+            0x91A83991, 0x95A43195, 0xE437D3E4, 0x798BF279,\n+            0xE732D5E7, 0xC8438BC8, 0x37596E37, 0x6DB7DA6D,\n+            0x8D8C018D, 0xD564B1D5, 0x4ED29C4E, 0xA9E049A9,\n+            0x6CB4D86C, 0x56FAAC56, 0xF407F3F4, 0xEA25CFEA,\n+            0x65AFCA65, 0x7A8EF47A, 0xAEE947AE, 0x08181008,\n+            0xBAD56FBA, 0x7888F078, 0x256F4A25, 0x2E725C2E,\n+            0x1C24381C, 0xA6F157A6, 0xB4C773B4, 0xC65197C6,\n+            0xE823CBE8, 0xDD7CA1DD, 0x749CE874, 0x1F213E1F,\n+            0x4BDD964B, 0xBDDC61BD, 0x8B860D8B, 0x8A850F8A,\n+            0x7090E070, 0x3E427C3E, 0xB5C471B5, 0x66AACC66,\n+            0x48D89048, 0x03050603, 0xF601F7F6, 0x0E121C0E,\n+            0x61A3C261, 0x355F6A35, 0x57F9AE57, 0xB9D069B9,\n+            0x86911786, 0xC15899C1, 0x1D273A1D, 0x9EB9279E,\n+            0xE138D9E1, 0xF813EBF8, 0x98B32B98, 0x11332211,\n+            0x69BBD269, 0xD970A9D9, 0x8E89078E, 0x94A73394,\n+            0x9BB62D9B, 0x1E223C1E, 0x87921587, 0xE920C9E9,\n+            0xCE4987CE, 0x55FFAA55, 0x28785028, 0xDF7AA5DF,\n+            0x8C8F038C, 0xA1F859A1, 0x89800989, 0x0D171A0D,\n+            0xBFDA65BF, 0xE631D7E6, 0x42C68442, 0x68B8D068,\n+            0x41C38241, 0x99B02999, 0x2D775A2D, 0x0F111E0F,\n+            0xB0CB7BB0, 0x54FCA854, 0xBBD66DBB, 0x163A2C16,\n+    };\n+\n+    private static final int[] T4 = {\n+            0x6363A5C6, 0x7C7C84F8, 0x777799EE, 0x7B7B8DF6,\n+            0xF2F20DFF, 0x6B6BBDD6, 0x6F6FB1DE, 0xC5C55491,\n+            0x30305060, 0x01010302, 0x6767A9CE, 0x2B2B7D56,\n+            0xFEFE19E7, 0xD7D762B5, 0xABABE64D, 0x76769AEC,\n+            0xCACA458F, 0x82829D1F, 0xC9C94089, 0x7D7D87FA,\n+            0xFAFA15EF, 0x5959EBB2, 0x4747C98E, 0xF0F00BFB,\n+            0xADADEC41, 0xD4D467B3, 0xA2A2FD5F, 0xAFAFEA45,\n+            0x9C9CBF23, 0xA4A4F753, 0x727296E4, 0xC0C05B9B,\n+            0xB7B7C275, 0xFDFD1CE1, 0x9393AE3D, 0x26266A4C,\n+            0x36365A6C, 0x3F3F417E, 0xF7F702F5, 0xCCCC4F83,\n+            0x34345C68, 0xA5A5F451, 0xE5E534D1, 0xF1F108F9,\n+            0x717193E2, 0xD8D873AB, 0x31315362, 0x15153F2A,\n+            0x04040C08, 0xC7C75295, 0x23236546, 0xC3C35E9D,\n+            0x18182830, 0x9696A137, 0x05050F0A, 0x9A9AB52F,\n+            0x0707090E, 0x12123624, 0x80809B1B, 0xE2E23DDF,\n+            0xEBEB26CD, 0x2727694E, 0xB2B2CD7F, 0x75759FEA,\n+            0x09091B12, 0x83839E1D, 0x2C2C7458, 0x1A1A2E34,\n+            0x1B1B2D36, 0x6E6EB2DC, 0x5A5AEEB4, 0xA0A0FB5B,\n+            0x5252F6A4, 0x3B3B4D76, 0xD6D661B7, 0xB3B3CE7D,\n+            0x29297B52, 0xE3E33EDD, 0x2F2F715E, 0x84849713,\n+            0x5353F5A6, 0xD1D168B9, 0x00000000, 0xEDED2CC1,\n+            0x20206040, 0xFCFC1FE3, 0xB1B1C879, 0x5B5BEDB6,\n+            0x6A6ABED4, 0xCBCB468D, 0xBEBED967, 0x39394B72,\n+            0x4A4ADE94, 0x4C4CD498, 0x5858E8B0, 0xCFCF4A85,\n+            0xD0D06BBB, 0xEFEF2AC5, 0xAAAAE54F, 0xFBFB16ED,\n+            0x4343C586, 0x4D4DD79A, 0x33335566, 0x85859411,\n+            0x4545CF8A, 0xF9F910E9, 0x02020604, 0x7F7F81FE,\n+            0x5050F0A0, 0x3C3C4478, 0x9F9FBA25, 0xA8A8E34B,\n+            0x5151F3A2, 0xA3A3FE5D, 0x4040C080, 0x8F8F8A05,\n+            0x9292AD3F, 0x9D9DBC21, 0x38384870, 0xF5F504F1,\n+            0xBCBCDF63, 0xB6B6C177, 0xDADA75AF, 0x21216342,\n+            0x10103020, 0xFFFF1AE5, 0xF3F30EFD, 0xD2D26DBF,\n+            0xCDCD4C81, 0x0C0C1418, 0x13133526, 0xECEC2FC3,\n+            0x5F5FE1BE, 0x9797A235, 0x4444CC88, 0x1717392E,\n+            0xC4C45793, 0xA7A7F255, 0x7E7E82FC, 0x3D3D477A,\n+            0x6464ACC8, 0x5D5DE7BA, 0x19192B32, 0x737395E6,\n+            0x6060A0C0, 0x81819819, 0x4F4FD19E, 0xDCDC7FA3,\n+            0x22226644, 0x2A2A7E54, 0x9090AB3B, 0x8888830B,\n+            0x4646CA8C, 0xEEEE29C7, 0xB8B8D36B, 0x14143C28,\n+            0xDEDE79A7, 0x5E5EE2BC, 0x0B0B1D16, 0xDBDB76AD,\n+            0xE0E03BDB, 0x32325664, 0x3A3A4E74, 0x0A0A1E14,\n+            0x4949DB92, 0x06060A0C, 0x24246C48, 0x5C5CE4B8,\n+            0xC2C25D9F, 0xD3D36EBD, 0xACACEF43, 0x6262A6C4,\n+            0x9191A839, 0x9595A431, 0xE4E437D3, 0x79798BF2,\n+            0xE7E732D5, 0xC8C8438B, 0x3737596E, 0x6D6DB7DA,\n+            0x8D8D8C01, 0xD5D564B1, 0x4E4ED29C, 0xA9A9E049,\n+            0x6C6CB4D8, 0x5656FAAC, 0xF4F407F3, 0xEAEA25CF,\n+            0x6565AFCA, 0x7A7A8EF4, 0xAEAEE947, 0x08081810,\n+            0xBABAD56F, 0x787888F0, 0x25256F4A, 0x2E2E725C,\n+            0x1C1C2438, 0xA6A6F157, 0xB4B4C773, 0xC6C65197,\n+            0xE8E823CB, 0xDDDD7CA1, 0x74749CE8, 0x1F1F213E,\n+            0x4B4BDD96, 0xBDBDDC61, 0x8B8B860D, 0x8A8A850F,\n+            0x707090E0, 0x3E3E427C, 0xB5B5C471, 0x6666AACC,\n+            0x4848D890, 0x03030506, 0xF6F601F7, 0x0E0E121C,\n+            0x6161A3C2, 0x35355F6A, 0x5757F9AE, 0xB9B9D069,\n+            0x86869117, 0xC1C15899, 0x1D1D273A, 0x9E9EB927,\n+            0xE1E138D9, 0xF8F813EB, 0x9898B32B, 0x11113322,\n+            0x6969BBD2, 0xD9D970A9, 0x8E8E8907, 0x9494A733,\n+            0x9B9BB62D, 0x1E1E223C, 0x87879215, 0xE9E920C9,\n+            0xCECE4987, 0x5555FFAA, 0x28287850, 0xDFDF7AA5,\n+            0x8C8C8F03, 0xA1A1F859, 0x89898009, 0x0D0D171A,\n+            0xBFBFDA65, 0xE6E631D7, 0x4242C684, 0x6868B8D0,\n+            0x4141C382, 0x9999B029, 0x2D2D775A, 0x0F0F111E,\n+            0xB0B0CB7B, 0x5454FCA8, 0xBBBBD66D, 0x16163A2C,\n+    };\n+\n+\n+    \/\/ pre-computed inverse tables (inverse T-box)\n+    private static final int[] T5 = {\n+            0x51F4A750, 0x7E416553, 0x1A17A4C3, 0x3A275E96,\n+            0x3BAB6BCB, 0x1F9D45F1, 0xACFA58AB, 0x4BE30393,\n+            0x2030FA55, 0xAD766DF6, 0x88CC7691, 0xF5024C25,\n+            0x4FE5D7FC, 0xC52ACBD7, 0x26354480, 0xB562A38F,\n+            0xDEB15A49, 0x25BA1B67, 0x45EA0E98, 0x5DFEC0E1,\n+            0xC32F7502, 0x814CF012, 0x8D4697A3, 0x6BD3F9C6,\n+            0x038F5FE7, 0x15929C95, 0xBF6D7AEB, 0x955259DA,\n+            0xD4BE832D, 0x587421D3, 0x49E06929, 0x8EC9C844,\n+            0x75C2896A, 0xF48E7978, 0x99583E6B, 0x27B971DD,\n+            0xBEE14FB6, 0xF088AD17, 0xC920AC66, 0x7DCE3AB4,\n+            0x63DF4A18, 0xE51A3182, 0x97513360, 0x62537F45,\n+            0xB16477E0, 0xBB6BAE84, 0xFE81A01C, 0xF9082B94,\n+            0x70486858, 0x8F45FD19, 0x94DE6C87, 0x527BF8B7,\n+            0xAB73D323, 0x724B02E2, 0xE31F8F57, 0x6655AB2A,\n+            0xB2EB2807, 0x2FB5C203, 0x86C57B9A, 0xD33708A5,\n+            0x302887F2, 0x23BFA5B2, 0x02036ABA, 0xED16825C,\n+            0x8ACF1C2B, 0xA779B492, 0xF307F2F0, 0x4E69E2A1,\n+            0x65DAF4CD, 0x0605BED5, 0xD134621F, 0xC4A6FE8A,\n+            0x342E539D, 0xA2F355A0, 0x058AE132, 0xA4F6EB75,\n+            0x0B83EC39, 0x4060EFAA, 0x5E719F06, 0xBD6E1051,\n+            0x3E218AF9, 0x96DD063D, 0xDD3E05AE, 0x4DE6BD46,\n+            0x91548DB5, 0x71C45D05, 0x0406D46F, 0x605015FF,\n+            0x1998FB24, 0xD6BDE997, 0x894043CC, 0x67D99E77,\n+            0xB0E842BD, 0x07898B88, 0xE7195B38, 0x79C8EEDB,\n+            0xA17C0A47, 0x7C420FE9, 0xF8841EC9, 0x00000000,\n+            0x09808683, 0x322BED48, 0x1E1170AC, 0x6C5A724E,\n+            0xFD0EFFFB, 0x0F853856, 0x3DAED51E, 0x362D3927,\n+            0x0A0FD964, 0x685CA621, 0x9B5B54D1, 0x24362E3A,\n+            0x0C0A67B1, 0x9357E70F, 0xB4EE96D2, 0x1B9B919E,\n+            0x80C0C54F, 0x61DC20A2, 0x5A774B69, 0x1C121A16,\n+            0xE293BA0A, 0xC0A02AE5, 0x3C22E043, 0x121B171D,\n+            0x0E090D0B, 0xF28BC7AD, 0x2DB6A8B9, 0x141EA9C8,\n+            0x57F11985, 0xAF75074C, 0xEE99DDBB, 0xA37F60FD,\n+            0xF701269F, 0x5C72F5BC, 0x44663BC5, 0x5BFB7E34,\n+            0x8B432976, 0xCB23C6DC, 0xB6EDFC68, 0xB8E4F163,\n+            0xD731DCCA, 0x42638510, 0x13972240, 0x84C61120,\n+            0x854A247D, 0xD2BB3DF8, 0xAEF93211, 0xC729A16D,\n+            0x1D9E2F4B, 0xDCB230F3, 0x0D8652EC, 0x77C1E3D0,\n+            0x2BB3166C, 0xA970B999, 0x119448FA, 0x47E96422,\n+            0xA8FC8CC4, 0xA0F03F1A, 0x567D2CD8, 0x223390EF,\n+            0x87494EC7, 0xD938D1C1, 0x8CCAA2FE, 0x98D40B36,\n+            0xA6F581CF, 0xA57ADE28, 0xDAB78E26, 0x3FADBFA4,\n+            0x2C3A9DE4, 0x5078920D, 0x6A5FCC9B, 0x547E4662,\n+            0xF68D13C2, 0x90D8B8E8, 0x2E39F75E, 0x82C3AFF5,\n+            0x9F5D80BE, 0x69D0937C, 0x6FD52DA9, 0xCF2512B3,\n+            0xC8AC993B, 0x10187DA7, 0xE89C636E, 0xDB3BBB7B,\n+            0xCD267809, 0x6E5918F4, 0xEC9AB701, 0x834F9AA8,\n+            0xE6956E65, 0xAAFFE67E, 0x21BCCF08, 0xEF15E8E6,\n+            0xBAE79BD9, 0x4A6F36CE, 0xEA9F09D4, 0x29B07CD6,\n+            0x31A4B2AF, 0x2A3F2331, 0xC6A59430, 0x35A266C0,\n+            0x744EBC37, 0xFC82CAA6, 0xE090D0B0, 0x33A7D815,\n+            0xF104984A, 0x41ECDAF7, 0x7FCD500E, 0x1791F62F,\n+            0x764DD68D, 0x43EFB04D, 0xCCAA4D54, 0xE49604DF,\n+            0x9ED1B5E3, 0x4C6A881B, 0xC12C1FB8, 0x4665517F,\n+            0x9D5EEA04, 0x018C355D, 0xFA877473, 0xFB0B412E,\n+            0xB3671D5A, 0x92DBD252, 0xE9105633, 0x6DD64713,\n+            0x9AD7618C, 0x37A10C7A, 0x59F8148E, 0xEB133C89,\n+            0xCEA927EE, 0xB761C935, 0xE11CE5ED, 0x7A47B13C,\n+            0x9CD2DF59, 0x55F2733F, 0x1814CE79, 0x73C737BF,\n+            0x53F7CDEA, 0x5FFDAA5B, 0xDF3D6F14, 0x7844DB86,\n+            0xCAAFF381, 0xB968C43E, 0x3824342C, 0xC2A3405F,\n+            0x161DC372, 0xBCE2250C, 0x283C498B, 0xFF0D9541,\n+            0x39A80171, 0x080CB3DE, 0xD8B4E49C, 0x6456C190,\n+            0x7BCB8461, 0xD532B670, 0x486C5C74, 0xD0B85742,\n+    };\n+\n+    private static final int[] T6 = {\n+            0x5051F4A7, 0x537E4165, 0xC31A17A4, 0x963A275E,\n+            0xCB3BAB6B, 0xF11F9D45, 0xABACFA58, 0x934BE303,\n+            0x552030FA, 0xF6AD766D, 0x9188CC76, 0x25F5024C,\n+            0xFC4FE5D7, 0xD7C52ACB, 0x80263544, 0x8FB562A3,\n+            0x49DEB15A, 0x6725BA1B, 0x9845EA0E, 0xE15DFEC0,\n+            0x02C32F75, 0x12814CF0, 0xA38D4697, 0xC66BD3F9,\n+            0xE7038F5F, 0x9515929C, 0xEBBF6D7A, 0xDA955259,\n+            0x2DD4BE83, 0xD3587421, 0x2949E069, 0x448EC9C8,\n+            0x6A75C289, 0x78F48E79, 0x6B99583E, 0xDD27B971,\n+            0xB6BEE14F, 0x17F088AD, 0x66C920AC, 0xB47DCE3A,\n+            0x1863DF4A, 0x82E51A31, 0x60975133, 0x4562537F,\n+            0xE0B16477, 0x84BB6BAE, 0x1CFE81A0, 0x94F9082B,\n+            0x58704868, 0x198F45FD, 0x8794DE6C, 0xB7527BF8,\n+            0x23AB73D3, 0xE2724B02, 0x57E31F8F, 0x2A6655AB,\n+            0x07B2EB28, 0x032FB5C2, 0x9A86C57B, 0xA5D33708,\n+            0xF2302887, 0xB223BFA5, 0xBA02036A, 0x5CED1682,\n+            0x2B8ACF1C, 0x92A779B4, 0xF0F307F2, 0xA14E69E2,\n+            0xCD65DAF4, 0xD50605BE, 0x1FD13462, 0x8AC4A6FE,\n+            0x9D342E53, 0xA0A2F355, 0x32058AE1, 0x75A4F6EB,\n+            0x390B83EC, 0xAA4060EF, 0x065E719F, 0x51BD6E10,\n+            0xF93E218A, 0x3D96DD06, 0xAEDD3E05, 0x464DE6BD,\n+            0xB591548D, 0x0571C45D, 0x6F0406D4, 0xFF605015,\n+            0x241998FB, 0x97D6BDE9, 0xCC894043, 0x7767D99E,\n+            0xBDB0E842, 0x8807898B, 0x38E7195B, 0xDB79C8EE,\n+            0x47A17C0A, 0xE97C420F, 0xC9F8841E, 0x00000000,\n+            0x83098086, 0x48322BED, 0xAC1E1170, 0x4E6C5A72,\n+            0xFBFD0EFF, 0x560F8538, 0x1E3DAED5, 0x27362D39,\n+            0x640A0FD9, 0x21685CA6, 0xD19B5B54, 0x3A24362E,\n+            0xB10C0A67, 0x0F9357E7, 0xD2B4EE96, 0x9E1B9B91,\n+            0x4F80C0C5, 0xA261DC20, 0x695A774B, 0x161C121A,\n+            0x0AE293BA, 0xE5C0A02A, 0x433C22E0, 0x1D121B17,\n+            0x0B0E090D, 0xADF28BC7, 0xB92DB6A8, 0xC8141EA9,\n+            0x8557F119, 0x4CAF7507, 0xBBEE99DD, 0xFDA37F60,\n+            0x9FF70126, 0xBC5C72F5, 0xC544663B, 0x345BFB7E,\n+            0x768B4329, 0xDCCB23C6, 0x68B6EDFC, 0x63B8E4F1,\n+            0xCAD731DC, 0x10426385, 0x40139722, 0x2084C611,\n+            0x7D854A24, 0xF8D2BB3D, 0x11AEF932, 0x6DC729A1,\n+            0x4B1D9E2F, 0xF3DCB230, 0xEC0D8652, 0xD077C1E3,\n+            0x6C2BB316, 0x99A970B9, 0xFA119448, 0x2247E964,\n+            0xC4A8FC8C, 0x1AA0F03F, 0xD8567D2C, 0xEF223390,\n+            0xC787494E, 0xC1D938D1, 0xFE8CCAA2, 0x3698D40B,\n+            0xCFA6F581, 0x28A57ADE, 0x26DAB78E, 0xA43FADBF,\n+            0xE42C3A9D, 0x0D507892, 0x9B6A5FCC, 0x62547E46,\n+            0xC2F68D13, 0xE890D8B8, 0x5E2E39F7, 0xF582C3AF,\n+            0xBE9F5D80, 0x7C69D093, 0xA96FD52D, 0xB3CF2512,\n+            0x3BC8AC99, 0xA710187D, 0x6EE89C63, 0x7BDB3BBB,\n+            0x09CD2678, 0xF46E5918, 0x01EC9AB7, 0xA8834F9A,\n+            0x65E6956E, 0x7EAAFFE6, 0x0821BCCF, 0xE6EF15E8,\n+            0xD9BAE79B, 0xCE4A6F36, 0xD4EA9F09, 0xD629B07C,\n+            0xAF31A4B2, 0x312A3F23, 0x30C6A594, 0xC035A266,\n+            0x37744EBC, 0xA6FC82CA, 0xB0E090D0, 0x1533A7D8,\n+            0x4AF10498, 0xF741ECDA, 0x0E7FCD50, 0x2F1791F6,\n+            0x8D764DD6, 0x4D43EFB0, 0x54CCAA4D, 0xDFE49604,\n+            0xE39ED1B5, 0x1B4C6A88, 0xB8C12C1F, 0x7F466551,\n+            0x049D5EEA, 0x5D018C35, 0x73FA8774, 0x2EFB0B41,\n+            0x5AB3671D, 0x5292DBD2, 0x33E91056, 0x136DD647,\n+            0x8C9AD761, 0x7A37A10C, 0x8E59F814, 0x89EB133C,\n+            0xEECEA927, 0x35B761C9, 0xEDE11CE5, 0x3C7A47B1,\n+            0x599CD2DF, 0x3F55F273, 0x791814CE, 0xBF73C737,\n+            0xEA53F7CD, 0x5B5FFDAA, 0x14DF3D6F, 0x867844DB,\n+            0x81CAAFF3, 0x3EB968C4, 0x2C382434, 0x5FC2A340,\n+            0x72161DC3, 0x0CBCE225, 0x8B283C49, 0x41FF0D95,\n+            0x7139A801, 0xDE080CB3, 0x9CD8B4E4, 0x906456C1,\n+            0x617BCB84, 0x70D532B6, 0x74486C5C, 0x42D0B857,\n+    };\n+\n+    private static final int[] T7 = {\n+            0xA75051F4, 0x65537E41, 0xA4C31A17, 0x5E963A27,\n+            0x6BCB3BAB, 0x45F11F9D, 0x58ABACFA, 0x03934BE3,\n+            0xFA552030, 0x6DF6AD76, 0x769188CC, 0x4C25F502,\n+            0xD7FC4FE5, 0xCBD7C52A, 0x44802635, 0xA38FB562,\n+            0x5A49DEB1, 0x1B6725BA, 0x0E9845EA, 0xC0E15DFE,\n+            0x7502C32F, 0xF012814C, 0x97A38D46, 0xF9C66BD3,\n+            0x5FE7038F, 0x9C951592, 0x7AEBBF6D, 0x59DA9552,\n+            0x832DD4BE, 0x21D35874, 0x692949E0, 0xC8448EC9,\n+            0x896A75C2, 0x7978F48E, 0x3E6B9958, 0x71DD27B9,\n+            0x4FB6BEE1, 0xAD17F088, 0xAC66C920, 0x3AB47DCE,\n+            0x4A1863DF, 0x3182E51A, 0x33609751, 0x7F456253,\n+            0x77E0B164, 0xAE84BB6B, 0xA01CFE81, 0x2B94F908,\n+            0x68587048, 0xFD198F45, 0x6C8794DE, 0xF8B7527B,\n+            0xD323AB73, 0x02E2724B, 0x8F57E31F, 0xAB2A6655,\n+            0x2807B2EB, 0xC2032FB5, 0x7B9A86C5, 0x08A5D337,\n+            0x87F23028, 0xA5B223BF, 0x6ABA0203, 0x825CED16,\n+            0x1C2B8ACF, 0xB492A779, 0xF2F0F307, 0xE2A14E69,\n+            0xF4CD65DA, 0xBED50605, 0x621FD134, 0xFE8AC4A6,\n+            0x539D342E, 0x55A0A2F3, 0xE132058A, 0xEB75A4F6,\n+            0xEC390B83, 0xEFAA4060, 0x9F065E71, 0x1051BD6E,\n+            0x8AF93E21, 0x063D96DD, 0x05AEDD3E, 0xBD464DE6,\n+            0x8DB59154, 0x5D0571C4, 0xD46F0406, 0x15FF6050,\n+            0xFB241998, 0xE997D6BD, 0x43CC8940, 0x9E7767D9,\n+            0x42BDB0E8, 0x8B880789, 0x5B38E719, 0xEEDB79C8,\n+            0x0A47A17C, 0x0FE97C42, 0x1EC9F884, 0x00000000,\n+            0x86830980, 0xED48322B, 0x70AC1E11, 0x724E6C5A,\n+            0xFFFBFD0E, 0x38560F85, 0xD51E3DAE, 0x3927362D,\n+            0xD9640A0F, 0xA621685C, 0x54D19B5B, 0x2E3A2436,\n+            0x67B10C0A, 0xE70F9357, 0x96D2B4EE, 0x919E1B9B,\n+            0xC54F80C0, 0x20A261DC, 0x4B695A77, 0x1A161C12,\n+            0xBA0AE293, 0x2AE5C0A0, 0xE0433C22, 0x171D121B,\n+            0x0D0B0E09, 0xC7ADF28B, 0xA8B92DB6, 0xA9C8141E,\n+            0x198557F1, 0x074CAF75, 0xDDBBEE99, 0x60FDA37F,\n+            0x269FF701, 0xF5BC5C72, 0x3BC54466, 0x7E345BFB,\n+            0x29768B43, 0xC6DCCB23, 0xFC68B6ED, 0xF163B8E4,\n+            0xDCCAD731, 0x85104263, 0x22401397, 0x112084C6,\n+            0x247D854A, 0x3DF8D2BB, 0x3211AEF9, 0xA16DC729,\n+            0x2F4B1D9E, 0x30F3DCB2, 0x52EC0D86, 0xE3D077C1,\n+            0x166C2BB3, 0xB999A970, 0x48FA1194, 0x642247E9,\n+            0x8CC4A8FC, 0x3F1AA0F0, 0x2CD8567D, 0x90EF2233,\n+            0x4EC78749, 0xD1C1D938, 0xA2FE8CCA, 0x0B3698D4,\n+            0x81CFA6F5, 0xDE28A57A, 0x8E26DAB7, 0xBFA43FAD,\n+            0x9DE42C3A, 0x920D5078, 0xCC9B6A5F, 0x4662547E,\n+            0x13C2F68D, 0xB8E890D8, 0xF75E2E39, 0xAFF582C3,\n+            0x80BE9F5D, 0x937C69D0, 0x2DA96FD5, 0x12B3CF25,\n+            0x993BC8AC, 0x7DA71018, 0x636EE89C, 0xBB7BDB3B,\n+            0x7809CD26, 0x18F46E59, 0xB701EC9A, 0x9AA8834F,\n+            0x6E65E695, 0xE67EAAFF, 0xCF0821BC, 0xE8E6EF15,\n+            0x9BD9BAE7, 0x36CE4A6F, 0x09D4EA9F, 0x7CD629B0,\n+            0xB2AF31A4, 0x23312A3F, 0x9430C6A5, 0x66C035A2,\n+            0xBC37744E, 0xCAA6FC82, 0xD0B0E090, 0xD81533A7,\n+            0x984AF104, 0xDAF741EC, 0x500E7FCD, 0xF62F1791,\n+            0xD68D764D, 0xB04D43EF, 0x4D54CCAA, 0x04DFE496,\n+            0xB5E39ED1, 0x881B4C6A, 0x1FB8C12C, 0x517F4665,\n+            0xEA049D5E, 0x355D018C, 0x7473FA87, 0x412EFB0B,\n+            0x1D5AB367, 0xD25292DB, 0x5633E910, 0x47136DD6,\n+            0x618C9AD7, 0x0C7A37A1, 0x148E59F8, 0x3C89EB13,\n+            0x27EECEA9, 0xC935B761, 0xE5EDE11C, 0xB13C7A47,\n+            0xDF599CD2, 0x733F55F2, 0xCE791814, 0x37BF73C7,\n+            0xCDEA53F7, 0xAA5B5FFD, 0x6F14DF3D, 0xDB867844,\n+            0xF381CAAF, 0xC43EB968, 0x342C3824, 0x405FC2A3,\n+            0xC372161D, 0x250CBCE2, 0x498B283C, 0x9541FF0D,\n+            0x017139A8, 0xB3DE080C, 0xE49CD8B4, 0xC1906456,\n+            0x84617BCB, 0xB670D532, 0x5C74486C, 0x5742D0B8,\n+    };\n+\n+    private static final int[] T8 = {\n+            0xF4A75051, 0x4165537E, 0x17A4C31A, 0x275E963A,\n+            0xAB6BCB3B, 0x9D45F11F, 0xFA58ABAC, 0xE303934B,\n+            0x30FA5520, 0x766DF6AD, 0xCC769188, 0x024C25F5,\n+            0xE5D7FC4F, 0x2ACBD7C5, 0x35448026, 0x62A38FB5,\n+            0xB15A49DE, 0xBA1B6725, 0xEA0E9845, 0xFEC0E15D,\n+            0x2F7502C3, 0x4CF01281, 0x4697A38D, 0xD3F9C66B,\n+            0x8F5FE703, 0x929C9515, 0x6D7AEBBF, 0x5259DA95,\n+            0xBE832DD4, 0x7421D358, 0xE0692949, 0xC9C8448E,\n+            0xC2896A75, 0x8E7978F4, 0x583E6B99, 0xB971DD27,\n+            0xE14FB6BE, 0x88AD17F0, 0x20AC66C9, 0xCE3AB47D,\n+            0xDF4A1863, 0x1A3182E5, 0x51336097, 0x537F4562,\n+            0x6477E0B1, 0x6BAE84BB, 0x81A01CFE, 0x082B94F9,\n+            0x48685870, 0x45FD198F, 0xDE6C8794, 0x7BF8B752,\n+            0x73D323AB, 0x4B02E272, 0x1F8F57E3, 0x55AB2A66,\n+            0xEB2807B2, 0xB5C2032F, 0xC57B9A86, 0x3708A5D3,\n+            0x2887F230, 0xBFA5B223, 0x036ABA02, 0x16825CED,\n+            0xCF1C2B8A, 0x79B492A7, 0x07F2F0F3, 0x69E2A14E,\n+            0xDAF4CD65, 0x05BED506, 0x34621FD1, 0xA6FE8AC4,\n+            0x2E539D34, 0xF355A0A2, 0x8AE13205, 0xF6EB75A4,\n+            0x83EC390B, 0x60EFAA40, 0x719F065E, 0x6E1051BD,\n+            0x218AF93E, 0xDD063D96, 0x3E05AEDD, 0xE6BD464D,\n+            0x548DB591, 0xC45D0571, 0x06D46F04, 0x5015FF60,\n+            0x98FB2419, 0xBDE997D6, 0x4043CC89, 0xD99E7767,\n+            0xE842BDB0, 0x898B8807, 0x195B38E7, 0xC8EEDB79,\n+            0x7C0A47A1, 0x420FE97C, 0x841EC9F8, 0x00000000,\n+            0x80868309, 0x2BED4832, 0x1170AC1E, 0x5A724E6C,\n+            0x0EFFFBFD, 0x8538560F, 0xAED51E3D, 0x2D392736,\n+            0x0FD9640A, 0x5CA62168, 0x5B54D19B, 0x362E3A24,\n+            0x0A67B10C, 0x57E70F93, 0xEE96D2B4, 0x9B919E1B,\n+            0xC0C54F80, 0xDC20A261, 0x774B695A, 0x121A161C,\n+            0x93BA0AE2, 0xA02AE5C0, 0x22E0433C, 0x1B171D12,\n+            0x090D0B0E, 0x8BC7ADF2, 0xB6A8B92D, 0x1EA9C814,\n+            0xF1198557, 0x75074CAF, 0x99DDBBEE, 0x7F60FDA3,\n+            0x01269FF7, 0x72F5BC5C, 0x663BC544, 0xFB7E345B,\n+            0x4329768B, 0x23C6DCCB, 0xEDFC68B6, 0xE4F163B8,\n+            0x31DCCAD7, 0x63851042, 0x97224013, 0xC6112084,\n+            0x4A247D85, 0xBB3DF8D2, 0xF93211AE, 0x29A16DC7,\n+            0x9E2F4B1D, 0xB230F3DC, 0x8652EC0D, 0xC1E3D077,\n+            0xB3166C2B, 0x70B999A9, 0x9448FA11, 0xE9642247,\n+            0xFC8CC4A8, 0xF03F1AA0, 0x7D2CD856, 0x3390EF22,\n+            0x494EC787, 0x38D1C1D9, 0xCAA2FE8C, 0xD40B3698,\n+            0xF581CFA6, 0x7ADE28A5, 0xB78E26DA, 0xADBFA43F,\n+            0x3A9DE42C, 0x78920D50, 0x5FCC9B6A, 0x7E466254,\n+            0x8D13C2F6, 0xD8B8E890, 0x39F75E2E, 0xC3AFF582,\n+            0x5D80BE9F, 0xD0937C69, 0xD52DA96F, 0x2512B3CF,\n+            0xAC993BC8, 0x187DA710, 0x9C636EE8, 0x3BBB7BDB,\n+            0x267809CD, 0x5918F46E, 0x9AB701EC, 0x4F9AA883,\n+            0x956E65E6, 0xFFE67EAA, 0xBCCF0821, 0x15E8E6EF,\n+            0xE79BD9BA, 0x6F36CE4A, 0x9F09D4EA, 0xB07CD629,\n+            0xA4B2AF31, 0x3F23312A, 0xA59430C6, 0xA266C035,\n+            0x4EBC3774, 0x82CAA6FC, 0x90D0B0E0, 0xA7D81533,\n+            0x04984AF1, 0xECDAF741, 0xCD500E7F, 0x91F62F17,\n+            0x4DD68D76, 0xEFB04D43, 0xAA4D54CC, 0x9604DFE4,\n+            0xD1B5E39E, 0x6A881B4C, 0x2C1FB8C1, 0x65517F46,\n+            0x5EEA049D, 0x8C355D01, 0x877473FA, 0x0B412EFB,\n+            0x671D5AB3, 0xDBD25292, 0x105633E9, 0xD647136D,\n+            0xD7618C9A, 0xA10C7A37, 0xF8148E59, 0x133C89EB,\n+            0xA927EECE, 0x61C935B7, 0x1CE5EDE1, 0x47B13C7A,\n+            0xD2DF599C, 0xF2733F55, 0x14CE7918, 0xC737BF73,\n+            0xF7CDEA53, 0xFDAA5B5F, 0x3D6F14DF, 0x44DB8678,\n+            0xAFF381CA, 0x68C43EB9, 0x24342C38, 0xA3405FC2,\n+            0x1DC37216, 0xE2250CBC, 0x3C498B28, 0x0D9541FF,\n+            0xA8017139, 0x0CB3DE08, 0xB4E49CD8, 0x56C19064,\n+            0xCB84617B, 0x32B670D5, 0x6C5C7448, 0xB85742D0,\n+    };\n+\n+    private static final int[] U1 = {\n+            0x00000000, 0x0E090D0B, 0x1C121A16, 0x121B171D,\n+            0x3824342C, 0x362D3927, 0x24362E3A, 0x2A3F2331,\n+            0x70486858, 0x7E416553, 0x6C5A724E, 0x62537F45,\n+            0x486C5C74, 0x4665517F, 0x547E4662, 0x5A774B69,\n+            0xE090D0B0, 0xEE99DDBB, 0xFC82CAA6, 0xF28BC7AD,\n+            0xD8B4E49C, 0xD6BDE997, 0xC4A6FE8A, 0xCAAFF381,\n+            0x90D8B8E8, 0x9ED1B5E3, 0x8CCAA2FE, 0x82C3AFF5,\n+            0xA8FC8CC4, 0xA6F581CF, 0xB4EE96D2, 0xBAE79BD9,\n+            0xDB3BBB7B, 0xD532B670, 0xC729A16D, 0xC920AC66,\n+            0xE31F8F57, 0xED16825C, 0xFF0D9541, 0xF104984A,\n+            0xAB73D323, 0xA57ADE28, 0xB761C935, 0xB968C43E,\n+            0x9357E70F, 0x9D5EEA04, 0x8F45FD19, 0x814CF012,\n+            0x3BAB6BCB, 0x35A266C0, 0x27B971DD, 0x29B07CD6,\n+            0x038F5FE7, 0x0D8652EC, 0x1F9D45F1, 0x119448FA,\n+            0x4BE30393, 0x45EA0E98, 0x57F11985, 0x59F8148E,\n+            0x73C737BF, 0x7DCE3AB4, 0x6FD52DA9, 0x61DC20A2,\n+            0xAD766DF6, 0xA37F60FD, 0xB16477E0, 0xBF6D7AEB,\n+            0x955259DA, 0x9B5B54D1, 0x894043CC, 0x87494EC7,\n+            0xDD3E05AE, 0xD33708A5, 0xC12C1FB8, 0xCF2512B3,\n+            0xE51A3182, 0xEB133C89, 0xF9082B94, 0xF701269F,\n+            0x4DE6BD46, 0x43EFB04D, 0x51F4A750, 0x5FFDAA5B,\n+            0x75C2896A, 0x7BCB8461, 0x69D0937C, 0x67D99E77,\n+            0x3DAED51E, 0x33A7D815, 0x21BCCF08, 0x2FB5C203,\n+            0x058AE132, 0x0B83EC39, 0x1998FB24, 0x1791F62F,\n+            0x764DD68D, 0x7844DB86, 0x6A5FCC9B, 0x6456C190,\n+            0x4E69E2A1, 0x4060EFAA, 0x527BF8B7, 0x5C72F5BC,\n+            0x0605BED5, 0x080CB3DE, 0x1A17A4C3, 0x141EA9C8,\n+            0x3E218AF9, 0x302887F2, 0x223390EF, 0x2C3A9DE4,\n+            0x96DD063D, 0x98D40B36, 0x8ACF1C2B, 0x84C61120,\n+            0xAEF93211, 0xA0F03F1A, 0xB2EB2807, 0xBCE2250C,\n+            0xE6956E65, 0xE89C636E, 0xFA877473, 0xF48E7978,\n+            0xDEB15A49, 0xD0B85742, 0xC2A3405F, 0xCCAA4D54,\n+            0x41ECDAF7, 0x4FE5D7FC, 0x5DFEC0E1, 0x53F7CDEA,\n+            0x79C8EEDB, 0x77C1E3D0, 0x65DAF4CD, 0x6BD3F9C6,\n+            0x31A4B2AF, 0x3FADBFA4, 0x2DB6A8B9, 0x23BFA5B2,\n+            0x09808683, 0x07898B88, 0x15929C95, 0x1B9B919E,\n+            0xA17C0A47, 0xAF75074C, 0xBD6E1051, 0xB3671D5A,\n+            0x99583E6B, 0x97513360, 0x854A247D, 0x8B432976,\n+            0xD134621F, 0xDF3D6F14, 0xCD267809, 0xC32F7502,\n+            0xE9105633, 0xE7195B38, 0xF5024C25, 0xFB0B412E,\n+            0x9AD7618C, 0x94DE6C87, 0x86C57B9A, 0x88CC7691,\n+            0xA2F355A0, 0xACFA58AB, 0xBEE14FB6, 0xB0E842BD,\n+            0xEA9F09D4, 0xE49604DF, 0xF68D13C2, 0xF8841EC9,\n+            0xD2BB3DF8, 0xDCB230F3, 0xCEA927EE, 0xC0A02AE5,\n+            0x7A47B13C, 0x744EBC37, 0x6655AB2A, 0x685CA621,\n+            0x42638510, 0x4C6A881B, 0x5E719F06, 0x5078920D,\n+            0x0A0FD964, 0x0406D46F, 0x161DC372, 0x1814CE79,\n+            0x322BED48, 0x3C22E043, 0x2E39F75E, 0x2030FA55,\n+            0xEC9AB701, 0xE293BA0A, 0xF088AD17, 0xFE81A01C,\n+            0xD4BE832D, 0xDAB78E26, 0xC8AC993B, 0xC6A59430,\n+            0x9CD2DF59, 0x92DBD252, 0x80C0C54F, 0x8EC9C844,\n+            0xA4F6EB75, 0xAAFFE67E, 0xB8E4F163, 0xB6EDFC68,\n+            0x0C0A67B1, 0x02036ABA, 0x10187DA7, 0x1E1170AC,\n+            0x342E539D, 0x3A275E96, 0x283C498B, 0x26354480,\n+            0x7C420FE9, 0x724B02E2, 0x605015FF, 0x6E5918F4,\n+            0x44663BC5, 0x4A6F36CE, 0x587421D3, 0x567D2CD8,\n+            0x37A10C7A, 0x39A80171, 0x2BB3166C, 0x25BA1B67,\n+            0x0F853856, 0x018C355D, 0x13972240, 0x1D9E2F4B,\n+            0x47E96422, 0x49E06929, 0x5BFB7E34, 0x55F2733F,\n+            0x7FCD500E, 0x71C45D05, 0x63DF4A18, 0x6DD64713,\n+            0xD731DCCA, 0xD938D1C1, 0xCB23C6DC, 0xC52ACBD7,\n+            0xEF15E8E6, 0xE11CE5ED, 0xF307F2F0, 0xFD0EFFFB,\n+            0xA779B492, 0xA970B999, 0xBB6BAE84, 0xB562A38F,\n+            0x9F5D80BE, 0x91548DB5, 0x834F9AA8, 0x8D4697A3,\n+    };\n+\n+    private static final int[] U2 = {\n+            0x00000000, 0x0B0E090D, 0x161C121A, 0x1D121B17,\n+            0x2C382434, 0x27362D39, 0x3A24362E, 0x312A3F23,\n+            0x58704868, 0x537E4165, 0x4E6C5A72, 0x4562537F,\n+            0x74486C5C, 0x7F466551, 0x62547E46, 0x695A774B,\n+            0xB0E090D0, 0xBBEE99DD, 0xA6FC82CA, 0xADF28BC7,\n+            0x9CD8B4E4, 0x97D6BDE9, 0x8AC4A6FE, 0x81CAAFF3,\n+            0xE890D8B8, 0xE39ED1B5, 0xFE8CCAA2, 0xF582C3AF,\n+            0xC4A8FC8C, 0xCFA6F581, 0xD2B4EE96, 0xD9BAE79B,\n+            0x7BDB3BBB, 0x70D532B6, 0x6DC729A1, 0x66C920AC,\n+            0x57E31F8F, 0x5CED1682, 0x41FF0D95, 0x4AF10498,\n+            0x23AB73D3, 0x28A57ADE, 0x35B761C9, 0x3EB968C4,\n+            0x0F9357E7, 0x049D5EEA, 0x198F45FD, 0x12814CF0,\n+            0xCB3BAB6B, 0xC035A266, 0xDD27B971, 0xD629B07C,\n+            0xE7038F5F, 0xEC0D8652, 0xF11F9D45, 0xFA119448,\n+            0x934BE303, 0x9845EA0E, 0x8557F119, 0x8E59F814,\n+            0xBF73C737, 0xB47DCE3A, 0xA96FD52D, 0xA261DC20,\n+            0xF6AD766D, 0xFDA37F60, 0xE0B16477, 0xEBBF6D7A,\n+            0xDA955259, 0xD19B5B54, 0xCC894043, 0xC787494E,\n+            0xAEDD3E05, 0xA5D33708, 0xB8C12C1F, 0xB3CF2512,\n+            0x82E51A31, 0x89EB133C, 0x94F9082B, 0x9FF70126,\n+            0x464DE6BD, 0x4D43EFB0, 0x5051F4A7, 0x5B5FFDAA,\n+            0x6A75C289, 0x617BCB84, 0x7C69D093, 0x7767D99E,\n+            0x1E3DAED5, 0x1533A7D8, 0x0821BCCF, 0x032FB5C2,\n+            0x32058AE1, 0x390B83EC, 0x241998FB, 0x2F1791F6,\n+            0x8D764DD6, 0x867844DB, 0x9B6A5FCC, 0x906456C1,\n+            0xA14E69E2, 0xAA4060EF, 0xB7527BF8, 0xBC5C72F5,\n+            0xD50605BE, 0xDE080CB3, 0xC31A17A4, 0xC8141EA9,\n+            0xF93E218A, 0xF2302887, 0xEF223390, 0xE42C3A9D,\n+            0x3D96DD06, 0x3698D40B, 0x2B8ACF1C, 0x2084C611,\n+            0x11AEF932, 0x1AA0F03F, 0x07B2EB28, 0x0CBCE225,\n+            0x65E6956E, 0x6EE89C63, 0x73FA8774, 0x78F48E79,\n+            0x49DEB15A, 0x42D0B857, 0x5FC2A340, 0x54CCAA4D,\n+            0xF741ECDA, 0xFC4FE5D7, 0xE15DFEC0, 0xEA53F7CD,\n+            0xDB79C8EE, 0xD077C1E3, 0xCD65DAF4, 0xC66BD3F9,\n+            0xAF31A4B2, 0xA43FADBF, 0xB92DB6A8, 0xB223BFA5,\n+            0x83098086, 0x8807898B, 0x9515929C, 0x9E1B9B91,\n+            0x47A17C0A, 0x4CAF7507, 0x51BD6E10, 0x5AB3671D,\n+            0x6B99583E, 0x60975133, 0x7D854A24, 0x768B4329,\n+            0x1FD13462, 0x14DF3D6F, 0x09CD2678, 0x02C32F75,\n+            0x33E91056, 0x38E7195B, 0x25F5024C, 0x2EFB0B41,\n+            0x8C9AD761, 0x8794DE6C, 0x9A86C57B, 0x9188CC76,\n+            0xA0A2F355, 0xABACFA58, 0xB6BEE14F, 0xBDB0E842,\n+            0xD4EA9F09, 0xDFE49604, 0xC2F68D13, 0xC9F8841E,\n+            0xF8D2BB3D, 0xF3DCB230, 0xEECEA927, 0xE5C0A02A,\n+            0x3C7A47B1, 0x37744EBC, 0x2A6655AB, 0x21685CA6,\n+            0x10426385, 0x1B4C6A88, 0x065E719F, 0x0D507892,\n+            0x640A0FD9, 0x6F0406D4, 0x72161DC3, 0x791814CE,\n+            0x48322BED, 0x433C22E0, 0x5E2E39F7, 0x552030FA,\n+            0x01EC9AB7, 0x0AE293BA, 0x17F088AD, 0x1CFE81A0,\n+            0x2DD4BE83, 0x26DAB78E, 0x3BC8AC99, 0x30C6A594,\n+            0x599CD2DF, 0x5292DBD2, 0x4F80C0C5, 0x448EC9C8,\n+            0x75A4F6EB, 0x7EAAFFE6, 0x63B8E4F1, 0x68B6EDFC,\n+            0xB10C0A67, 0xBA02036A, 0xA710187D, 0xAC1E1170,\n+            0x9D342E53, 0x963A275E, 0x8B283C49, 0x80263544,\n+            0xE97C420F, 0xE2724B02, 0xFF605015, 0xF46E5918,\n+            0xC544663B, 0xCE4A6F36, 0xD3587421, 0xD8567D2C,\n+            0x7A37A10C, 0x7139A801, 0x6C2BB316, 0x6725BA1B,\n+            0x560F8538, 0x5D018C35, 0x40139722, 0x4B1D9E2F,\n+            0x2247E964, 0x2949E069, 0x345BFB7E, 0x3F55F273,\n+            0x0E7FCD50, 0x0571C45D, 0x1863DF4A, 0x136DD647,\n+            0xCAD731DC, 0xC1D938D1, 0xDCCB23C6, 0xD7C52ACB,\n+            0xE6EF15E8, 0xEDE11CE5, 0xF0F307F2, 0xFBFD0EFF,\n+            0x92A779B4, 0x99A970B9, 0x84BB6BAE, 0x8FB562A3,\n+            0xBE9F5D80, 0xB591548D, 0xA8834F9A, 0xA38D4697,\n+    };\n+\n+    private static final int[] U3 = {\n+            0x00000000, 0x0D0B0E09, 0x1A161C12, 0x171D121B,\n+            0x342C3824, 0x3927362D, 0x2E3A2436, 0x23312A3F,\n+            0x68587048, 0x65537E41, 0x724E6C5A, 0x7F456253,\n+            0x5C74486C, 0x517F4665, 0x4662547E, 0x4B695A77,\n+            0xD0B0E090, 0xDDBBEE99, 0xCAA6FC82, 0xC7ADF28B,\n+            0xE49CD8B4, 0xE997D6BD, 0xFE8AC4A6, 0xF381CAAF,\n+            0xB8E890D8, 0xB5E39ED1, 0xA2FE8CCA, 0xAFF582C3,\n+            0x8CC4A8FC, 0x81CFA6F5, 0x96D2B4EE, 0x9BD9BAE7,\n+            0xBB7BDB3B, 0xB670D532, 0xA16DC729, 0xAC66C920,\n+            0x8F57E31F, 0x825CED16, 0x9541FF0D, 0x984AF104,\n+            0xD323AB73, 0xDE28A57A, 0xC935B761, 0xC43EB968,\n+            0xE70F9357, 0xEA049D5E, 0xFD198F45, 0xF012814C,\n+            0x6BCB3BAB, 0x66C035A2, 0x71DD27B9, 0x7CD629B0,\n+            0x5FE7038F, 0x52EC0D86, 0x45F11F9D, 0x48FA1194,\n+            0x03934BE3, 0x0E9845EA, 0x198557F1, 0x148E59F8,\n+            0x37BF73C7, 0x3AB47DCE, 0x2DA96FD5, 0x20A261DC,\n+            0x6DF6AD76, 0x60FDA37F, 0x77E0B164, 0x7AEBBF6D,\n+            0x59DA9552, 0x54D19B5B, 0x43CC8940, 0x4EC78749,\n+            0x05AEDD3E, 0x08A5D337, 0x1FB8C12C, 0x12B3CF25,\n+            0x3182E51A, 0x3C89EB13, 0x2B94F908, 0x269FF701,\n+            0xBD464DE6, 0xB04D43EF, 0xA75051F4, 0xAA5B5FFD,\n+            0x896A75C2, 0x84617BCB, 0x937C69D0, 0x9E7767D9,\n+            0xD51E3DAE, 0xD81533A7, 0xCF0821BC, 0xC2032FB5,\n+            0xE132058A, 0xEC390B83, 0xFB241998, 0xF62F1791,\n+            0xD68D764D, 0xDB867844, 0xCC9B6A5F, 0xC1906456,\n+            0xE2A14E69, 0xEFAA4060, 0xF8B7527B, 0xF5BC5C72,\n+            0xBED50605, 0xB3DE080C, 0xA4C31A17, 0xA9C8141E,\n+            0x8AF93E21, 0x87F23028, 0x90EF2233, 0x9DE42C3A,\n+            0x063D96DD, 0x0B3698D4, 0x1C2B8ACF, 0x112084C6,\n+            0x3211AEF9, 0x3F1AA0F0, 0x2807B2EB, 0x250CBCE2,\n+            0x6E65E695, 0x636EE89C, 0x7473FA87, 0x7978F48E,\n+            0x5A49DEB1, 0x5742D0B8, 0x405FC2A3, 0x4D54CCAA,\n+            0xDAF741EC, 0xD7FC4FE5, 0xC0E15DFE, 0xCDEA53F7,\n+            0xEEDB79C8, 0xE3D077C1, 0xF4CD65DA, 0xF9C66BD3,\n+            0xB2AF31A4, 0xBFA43FAD, 0xA8B92DB6, 0xA5B223BF,\n+            0x86830980, 0x8B880789, 0x9C951592, 0x919E1B9B,\n+            0x0A47A17C, 0x074CAF75, 0x1051BD6E, 0x1D5AB367,\n+            0x3E6B9958, 0x33609751, 0x247D854A, 0x29768B43,\n+            0x621FD134, 0x6F14DF3D, 0x7809CD26, 0x7502C32F,\n+            0x5633E910, 0x5B38E719, 0x4C25F502, 0x412EFB0B,\n+            0x618C9AD7, 0x6C8794DE, 0x7B9A86C5, 0x769188CC,\n+            0x55A0A2F3, 0x58ABACFA, 0x4FB6BEE1, 0x42BDB0E8,\n+            0x09D4EA9F, 0x04DFE496, 0x13C2F68D, 0x1EC9F884,\n+            0x3DF8D2BB, 0x30F3DCB2, 0x27EECEA9, 0x2AE5C0A0,\n+            0xB13C7A47, 0xBC37744E, 0xAB2A6655, 0xA621685C,\n+            0x85104263, 0x881B4C6A, 0x9F065E71, 0x920D5078,\n+            0xD9640A0F, 0xD46F0406, 0xC372161D, 0xCE791814,\n+            0xED48322B, 0xE0433C22, 0xF75E2E39, 0xFA552030,\n+            0xB701EC9A, 0xBA0AE293, 0xAD17F088, 0xA01CFE81,\n+            0x832DD4BE, 0x8E26DAB7, 0x993BC8AC, 0x9430C6A5,\n+            0xDF599CD2, 0xD25292DB, 0xC54F80C0, 0xC8448EC9,\n+            0xEB75A4F6, 0xE67EAAFF, 0xF163B8E4, 0xFC68B6ED,\n+            0x67B10C0A, 0x6ABA0203, 0x7DA71018, 0x70AC1E11,\n+            0x539D342E, 0x5E963A27, 0x498B283C, 0x44802635,\n+            0x0FE97C42, 0x02E2724B, 0x15FF6050, 0x18F46E59,\n+            0x3BC54466, 0x36CE4A6F, 0x21D35874, 0x2CD8567D,\n+            0x0C7A37A1, 0x017139A8, 0x166C2BB3, 0x1B6725BA,\n+            0x38560F85, 0x355D018C, 0x22401397, 0x2F4B1D9E,\n+            0x642247E9, 0x692949E0, 0x7E345BFB, 0x733F55F2,\n+            0x500E7FCD, 0x5D0571C4, 0x4A1863DF, 0x47136DD6,\n+            0xDCCAD731, 0xD1C1D938, 0xC6DCCB23, 0xCBD7C52A,\n+            0xE8E6EF15, 0xE5EDE11C, 0xF2F0F307, 0xFFFBFD0E,\n+            0xB492A779, 0xB999A970, 0xAE84BB6B, 0xA38FB562,\n+            0x80BE9F5D, 0x8DB59154, 0x9AA8834F, 0x97A38D46,\n+    };\n+\n+    private static final int[] U4 = {\n+            0x00000000, 0x090D0B0E, 0x121A161C, 0x1B171D12,\n+            0x24342C38, 0x2D392736, 0x362E3A24, 0x3F23312A,\n+            0x48685870, 0x4165537E, 0x5A724E6C, 0x537F4562,\n+            0x6C5C7448, 0x65517F46, 0x7E466254, 0x774B695A,\n+            0x90D0B0E0, 0x99DDBBEE, 0x82CAA6FC, 0x8BC7ADF2,\n+            0xB4E49CD8, 0xBDE997D6, 0xA6FE8AC4, 0xAFF381CA,\n+            0xD8B8E890, 0xD1B5E39E, 0xCAA2FE8C, 0xC3AFF582,\n+            0xFC8CC4A8, 0xF581CFA6, 0xEE96D2B4, 0xE79BD9BA,\n+            0x3BBB7BDB, 0x32B670D5, 0x29A16DC7, 0x20AC66C9,\n+            0x1F8F57E3, 0x16825CED, 0x0D9541FF, 0x04984AF1,\n+            0x73D323AB, 0x7ADE28A5, 0x61C935B7, 0x68C43EB9,\n+            0x57E70F93, 0x5EEA049D, 0x45FD198F, 0x4CF01281,\n+            0xAB6BCB3B, 0xA266C035, 0xB971DD27, 0xB07CD629,\n+            0x8F5FE703, 0x8652EC0D, 0x9D45F11F, 0x9448FA11,\n+            0xE303934B, 0xEA0E9845, 0xF1198557, 0xF8148E59,\n+            0xC737BF73, 0xCE3AB47D, 0xD52DA96F, 0xDC20A261,\n+            0x766DF6AD, 0x7F60FDA3, 0x6477E0B1, 0x6D7AEBBF,\n+            0x5259DA95, 0x5B54D19B, 0x4043CC89, 0x494EC787,\n+            0x3E05AEDD, 0x3708A5D3, 0x2C1FB8C1, 0x2512B3CF,\n+            0x1A3182E5, 0x133C89EB, 0x082B94F9, 0x01269FF7,\n+            0xE6BD464D, 0xEFB04D43, 0xF4A75051, 0xFDAA5B5F,\n+            0xC2896A75, 0xCB84617B, 0xD0937C69, 0xD99E7767,\n+            0xAED51E3D, 0xA7D81533, 0xBCCF0821, 0xB5C2032F,\n+            0x8AE13205, 0x83EC390B, 0x98FB2419, 0x91F62F17,\n+            0x4DD68D76, 0x44DB8678, 0x5FCC9B6A, 0x56C19064,\n+            0x69E2A14E, 0x60EFAA40, 0x7BF8B752, 0x72F5BC5C,\n+            0x05BED506, 0x0CB3DE08, 0x17A4C31A, 0x1EA9C814,\n+            0x218AF93E, 0x2887F230, 0x3390EF22, 0x3A9DE42C,\n+            0xDD063D96, 0xD40B3698, 0xCF1C2B8A, 0xC6112084,\n+            0xF93211AE, 0xF03F1AA0, 0xEB2807B2, 0xE2250CBC,\n+            0x956E65E6, 0x9C636EE8, 0x877473FA, 0x8E7978F4,\n+            0xB15A49DE, 0xB85742D0, 0xA3405FC2, 0xAA4D54CC,\n+            0xECDAF741, 0xE5D7FC4F, 0xFEC0E15D, 0xF7CDEA53,\n+            0xC8EEDB79, 0xC1E3D077, 0xDAF4CD65, 0xD3F9C66B,\n+            0xA4B2AF31, 0xADBFA43F, 0xB6A8B92D, 0xBFA5B223,\n+            0x80868309, 0x898B8807, 0x929C9515, 0x9B919E1B,\n+            0x7C0A47A1, 0x75074CAF, 0x6E1051BD, 0x671D5AB3,\n+            0x583E6B99, 0x51336097, 0x4A247D85, 0x4329768B,\n+            0x34621FD1, 0x3D6F14DF, 0x267809CD, 0x2F7502C3,\n+            0x105633E9, 0x195B38E7, 0x024C25F5, 0x0B412EFB,\n+            0xD7618C9A, 0xDE6C8794, 0xC57B9A86, 0xCC769188,\n+            0xF355A0A2, 0xFA58ABAC, 0xE14FB6BE, 0xE842BDB0,\n+            0x9F09D4EA, 0x9604DFE4, 0x8D13C2F6, 0x841EC9F8,\n+            0xBB3DF8D2, 0xB230F3DC, 0xA927EECE, 0xA02AE5C0,\n+            0x47B13C7A, 0x4EBC3774, 0x55AB2A66, 0x5CA62168,\n+            0x63851042, 0x6A881B4C, 0x719F065E, 0x78920D50,\n+            0x0FD9640A, 0x06D46F04, 0x1DC37216, 0x14CE7918,\n+            0x2BED4832, 0x22E0433C, 0x39F75E2E, 0x30FA5520,\n+            0x9AB701EC, 0x93BA0AE2, 0x88AD17F0, 0x81A01CFE,\n+            0xBE832DD4, 0xB78E26DA, 0xAC993BC8, 0xA59430C6,\n+            0xD2DF599C, 0xDBD25292, 0xC0C54F80, 0xC9C8448E,\n+            0xF6EB75A4, 0xFFE67EAA, 0xE4F163B8, 0xEDFC68B6,\n+            0x0A67B10C, 0x036ABA02, 0x187DA710, 0x1170AC1E,\n+            0x2E539D34, 0x275E963A, 0x3C498B28, 0x35448026,\n+            0x420FE97C, 0x4B02E272, 0x5015FF60, 0x5918F46E,\n+            0x663BC544, 0x6F36CE4A, 0x7421D358, 0x7D2CD856,\n+            0xA10C7A37, 0xA8017139, 0xB3166C2B, 0xBA1B6725,\n+            0x8538560F, 0x8C355D01, 0x97224013, 0x9E2F4B1D,\n+            0xE9642247, 0xE0692949, 0xFB7E345B, 0xF2733F55,\n+            0xCD500E7F, 0xC45D0571, 0xDF4A1863, 0xD647136D,\n+            0x31DCCAD7, 0x38D1C1D9, 0x23C6DCCB, 0x2ACBD7C5,\n+            0x15E8E6EF, 0x1CE5EDE1, 0x07F2F0F3, 0x0EFFFBFD,\n+            0x79B492A7, 0x70B999A9, 0x6BAE84BB, 0x62A38FB5,\n+            0x5D80BE9F, 0x548DB591, 0x4F9AA883, 0x4697A38D,\n+    };\n+\n+    private static final int[] rcon = {\n+            0x00000001, 0x00000002, 0x00000004, 0x00000008,\n+            0x00000010, 0x00000020, 0x00000040, 0x00000080,\n+            0x0000001B, 0x00000036, 0x0000006C, 0x000000D8,\n+            0x000000AB, 0x0000004D, 0x0000009A, 0x0000002F,\n+            0x0000005E, 0x000000BC, 0x00000063, 0x000000C6,\n+            0x00000097, 0x00000035, 0x0000006A, 0x000000D4,\n+            0x000000B3, 0x0000007D, 0x000000FA, 0x000000EF,\n+            0x000000C5, 0x00000091,\n+    };\n+\n@@ -138,203 +1095,0 @@\n-    private static int[]\n-        alog = new int[256],\n-        log  = new int[256];\n-\n-    private static final byte[]\n-        S  = new byte[256],\n-        Si = new byte[256];\n-\n-    private static final int[]\n-        T1 = new int[256],\n-        T2 = new int[256],\n-        T3 = new int[256],\n-        T4 = new int[256],\n-        T5 = new int[256],\n-        T6 = new int[256],\n-        T7 = new int[256],\n-        T8 = new int[256];\n-\n-    private static final int[]\n-        U1 = new int[256],\n-        U2 = new int[256],\n-        U3 = new int[256],\n-        U4 = new int[256];\n-\n-    private static final byte[] rcon = new byte[30];\n-\n-\n-    \/\/ Static code - to initialise S-boxes and T-boxes\n-    static\n-    {\n-        int ROOT = 0x11B;\n-        int i, j = 0;\n-\n-        \/\/\n-        \/\/ produce log and alog tables, needed for multiplying in the\n-        \/\/ field GF(2^m) (generator = 3)\n-        \/\/\n-        alog[0] = 1;\n-        for (i = 1; i < 256; i++)\n-        {\n-            j = (alog[i-1] << 1) ^ alog[i-1];\n-            if ((j & 0x100) != 0) {\n-                j ^= ROOT;\n-            }\n-            alog[i] = j;\n-        }\n-        for (i = 1; i < 255; i++) {\n-            log[alog[i]] = i;\n-        }\n-        byte[][] A = new byte[][]\n-        {\n-            {1, 1, 1, 1, 1, 0, 0, 0},\n-            {0, 1, 1, 1, 1, 1, 0, 0},\n-            {0, 0, 1, 1, 1, 1, 1, 0},\n-            {0, 0, 0, 1, 1, 1, 1, 1},\n-            {1, 0, 0, 0, 1, 1, 1, 1},\n-            {1, 1, 0, 0, 0, 1, 1, 1},\n-            {1, 1, 1, 0, 0, 0, 1, 1},\n-            {1, 1, 1, 1, 0, 0, 0, 1}\n-        };\n-        byte[] B = new byte[] { 0, 1, 1, 0, 0, 0, 1, 1};\n-\n-        \/\/\n-        \/\/ substitution box based on F^{-1}(x)\n-        \/\/\n-        int t;\n-        byte[][] box = new byte[256][8];\n-        box[1][7] = 1;\n-        for (i = 2; i < 256; i++) {\n-            j = alog[255 - log[i]];\n-            for (t = 0; t < 8; t++) {\n-                box[i][t] = (byte)((j >>> (7 - t)) & 0x01);\n-            }\n-        }\n-        \/\/\n-        \/\/ affine transform:  box[i] <- B + A*box[i]\n-        \/\/\n-        byte[][] cox = new byte[256][8];\n-        for (i = 0; i < 256; i++) {\n-            for (t = 0; t < 8; t++) {\n-                cox[i][t] = B[t];\n-                for (j = 0; j < 8; j++) {\n-                    cox[i][t] ^= (byte)(A[t][j] * box[i][j]);\n-                }\n-            }\n-        }\n-        \/\/\n-        \/\/ S-boxes and inverse S-boxes\n-        \/\/\n-        for (i = 0; i < 256; i++) {\n-            S[i] = (byte)(cox[i][0] << 7);\n-            for (t = 1; t < 8; t++) {\n-                    S[i] ^= (byte)(cox[i][t] << (7-t));\n-            }\n-            Si[S[i] & 0xFF] = (byte) i;\n-        }\n-        \/\/\n-        \/\/ T-boxes\n-        \/\/\n-        byte[][] G = new byte[][] {\n-            {2, 1, 1, 3},\n-            {3, 2, 1, 1},\n-            {1, 3, 2, 1},\n-            {1, 1, 3, 2}\n-        };\n-        byte[][] AA = new byte[4][8];\n-        for (i = 0; i < 4; i++) {\n-            for (j = 0; j < 4; j++) AA[i][j] = G[i][j];\n-            AA[i][i+4] = 1;\n-        }\n-        byte pivot, tmp;\n-        byte[][] iG = new byte[4][4];\n-        for (i = 0; i < 4; i++) {\n-            pivot = AA[i][i];\n-            if (pivot == 0) {\n-                t = i + 1;\n-                while ((AA[t][i] == 0) && (t < 4)) {\n-                    t++;\n-                }\n-                if (t == 4) {\n-                    throw new RuntimeException(\"G matrix is not invertible\");\n-                }\n-                else {\n-                    for (j = 0; j < 8; j++) {\n-                        tmp = AA[i][j];\n-                        AA[i][j] = AA[t][j];\n-                        AA[t][j] = tmp;\n-                    }\n-                    pivot = AA[i][i];\n-                }\n-            }\n-            for (j = 0; j < 8; j++) {\n-                if (AA[i][j] != 0) {\n-                    AA[i][j] = (byte)\n-                        alog[(255 + log[AA[i][j] & 0xFF] - log[pivot & 0xFF])\n-                        % 255];\n-                }\n-            }\n-            for (t = 0; t < 4; t++) {\n-                if (i != t) {\n-                    for (j = i+1; j < 8; j++) {\n-                        AA[t][j] ^= (byte)(mul(AA[i][j], AA[t][i]));\n-                    }\n-                    AA[t][i] = 0;\n-                }\n-            }\n-        }\n-        for (i = 0; i < 4; i++) {\n-            for (j = 0; j < 4; j++) {\n-                iG[i][j] = AA[i][j + 4];\n-            }\n-        }\n-\n-        int s;\n-        for (t = 0; t < 256; t++) {\n-            s = S[t];\n-            T1[t] = mul4(s, G[0]);\n-            T2[t] = mul4(s, G[1]);\n-            T3[t] = mul4(s, G[2]);\n-            T4[t] = mul4(s, G[3]);\n-\n-            s = Si[t];\n-            T5[t] = mul4(s, iG[0]);\n-            T6[t] = mul4(s, iG[1]);\n-            T7[t] = mul4(s, iG[2]);\n-            T8[t] = mul4(s, iG[3]);\n-\n-            U1[t] = mul4(t, iG[0]);\n-            U2[t] = mul4(t, iG[1]);\n-            U3[t] = mul4(t, iG[2]);\n-            U4[t] = mul4(t, iG[3]);\n-        }\n-        \/\/\n-        \/\/ round constants\n-        \/\/\n-        rcon[0] = 1;\n-        int r = 1;\n-        for (t = 1; t < 30; t++) {\n-            r = mul(2, r);\n-            rcon[t] = (byte) r;\n-        }\n-        log = null;\n-        alog = null;\n-    }\n-\n-    \/\/ multiply two elements of GF(2^m)\n-    private static final int mul (int a, int b) {\n-        return (a != 0 && b != 0) ?\n-            alog[(log[a & 0xFF] + log[b & 0xFF]) % 255] :\n-            0;\n-    }\n-\n-    \/\/ convenience method used in generating Transposition boxes\n-    private static final int mul4 (int a, byte[] b) {\n-        if (a == 0) return 0;\n-        a = log[a & 0xFF];\n-        int a0 = (b[0] != 0) ? alog[(a + log[b[0] & 0xFF]) % 255] & 0xFF : 0;\n-        int a1 = (b[1] != 0) ? alog[(a + log[b[1] & 0xFF]) % 255] & 0xFF : 0;\n-        int a2 = (b[2] != 0) ? alog[(a + log[b[2] & 0xFF]) % 255] & 0xFF : 0;\n-        int a3 = (b[3] != 0) ? alog[(a + log[b[3] & 0xFF]) % 255] & 0xFF : 0;\n-        return a0 << 24 | a1 << 16 | a2 << 8 | a3;\n-    }\n-\n@@ -342,3 +1096,3 @@\n-    static final boolean isKeySizeValid(int len) {\n-        for (int i = 0; i < AES_KEYSIZES.length; i++) {\n-            if (len == AES_KEYSIZES[i]) {\n+    static boolean isKeySizeValid(int len) {\n+        for (int aesKeysize : AES_KEYSIZES) {\n+            if (len == aesKeysize) {\n@@ -382,1 +1136,1 @@\n-                    (in[inOffset++] & 0xFF)        ) ^ K[keyOffset++];\n+                    (in[inOffset]   & 0xFF)        ) ^ K[keyOffset++];\n@@ -423,1 +1177,1 @@\n-        tt = K[keyOffset++];\n+        tt = K[keyOffset];\n@@ -574,1 +1328,1 @@\n-             T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset++];\n+             T7[(t1>>> 8)&0xFF] ^ T8[(t0     )&0xFF] ^ K[keyOffset];\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AESCrypt.java","additions":965,"deletions":211,"binary":false,"changes":1176,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,2 @@\n-        if (type2 == null || (v != Version.NTLM && nonce == null)) {\n+        if (type2 == null || (v != Version.NTLM && nonce == null) ||\n+                (nonce != null && nonce.length != 8)) {\n@@ -122,1 +123,1 @@\n-                    \"type2 and nonce cannot be null\");\n+                    \"type2 cannot be null, and nonce must be 8-byte long\");\n","filename":"src\/java.base\/share\/classes\/com\/sun\/security\/ntlm\/Client.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-        void writeSecurityBuffer(int offset, byte[] data) {\n+        void writeSecurityBuffer(int offset, byte[] data) throws NTLMException {\n@@ -229,1 +229,1 @@\n-                writeShort(offset+4, current);\n+                writeInt(offset+4, current);\n@@ -232,0 +232,4 @@\n+                if (len > 65535) {\n+                    throw new NTLMException(NTLMException.INVALID_INPUT,\n+                            \"Invalid data length \" + len);\n+                }\n@@ -237,1 +241,1 @@\n-                writeShort(offset+4, current);\n+                writeInt(offset+4, current);\n@@ -243,1 +247,1 @@\n-        void writeSecurityBuffer(int offset, String str, boolean unicode) {\n+        void writeSecurityBuffer(int offset, String str, boolean unicode) throws NTLMException {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/security\/ntlm\/NTLM.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+    \/**\n+     * If an invalid input is provided.\n+     *\/\n+    public static final int INVALID_INPUT = 7;\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/security\/ntlm\/NTLMException.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-        if (nonce == null) {\n+        if (nonce == null || nonce.length != 8) {\n@@ -90,1 +90,1 @@\n-                    \"nonce cannot be null\");\n+                    \"nonce must be 8-byte long\");\n","filename":"src\/java.base\/share\/classes\/com\/sun\/security\/ntlm\/Server.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-        if (markpos < 0)\n+        if (markpos == -1)\n@@ -309,1 +309,1 @@\n-            if (len >= getBufIfOpen().length && markpos < 0) {\n+            if (len >= getBufIfOpen().length && markpos == -1) {\n@@ -430,1 +430,1 @@\n-            if (markpos <0)\n+            if (markpos == -1)\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,2 @@\n-    private byte bytearr[] = new byte[80];\n-    private char chararr[] = new char[80];\n+    private byte[] bytearr = new byte[80];\n+    private char[] chararr = new char[80];\n@@ -248,4 +248,1 @@\n-        int ch = in.read();\n-        if (ch < 0)\n-            throw new EOFException();\n-        return (ch != 0);\n+        return readUnsignedByte() != 0;\n@@ -271,4 +268,1 @@\n-        int ch = in.read();\n-        if (ch < 0)\n-            throw new EOFException();\n-        return (byte)(ch);\n+        return (byte) readUnsignedByte();\n@@ -318,5 +312,1 @@\n-        int ch1 = in.read();\n-        int ch2 = in.read();\n-        if ((ch1 | ch2) < 0)\n-            throw new EOFException();\n-        return (short)((ch1 << 8) + (ch2 << 0));\n+        return (short) readUnsignedShort();\n@@ -343,0 +333,1 @@\n+        InputStream in = this.in;\n@@ -368,5 +359,1 @@\n-        int ch1 = in.read();\n-        int ch2 = in.read();\n-        if ((ch1 | ch2) < 0)\n-            throw new EOFException();\n-        return (char)((ch1 << 8) + (ch2 << 0));\n+        return (char) readUnsignedShort();\n@@ -393,0 +380,1 @@\n+        InputStream in = this.in;\n@@ -402,1 +390,1 @@\n-    private byte readBuffer[] = new byte[8];\n+    private final byte[] readBuffer = new byte[8];\n@@ -477,1 +465,1 @@\n-    private char lineBuffer[];\n+    private char[] lineBuffer;\n@@ -508,1 +496,1 @@\n-        char buf[] = lineBuffer;\n+        char[] buf = lineBuffer;\n@@ -637,1 +625,1 @@\n-                    char2 = (int) bytearr[count-1];\n+                    char2 = bytearr[count-1];\n@@ -650,2 +638,2 @@\n-                    char2 = (int) bytearr[count-2];\n-                    char3 = (int) bytearr[count-1];\n+                    char2 = bytearr[count-2];\n+                    char3 = bytearr[count-1];\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":15,"deletions":27,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-import static java.io.ObjectStreamField.*;\n@@ -1596,1 +1595,1 @@\n-            appendClassSignature(sb, paramTypes[i]);\n+            sb.append(paramTypes[i].descriptorString());\n@@ -1599,1 +1598,1 @@\n-        appendClassSignature(sb, retType);\n+        sb.append(retType.descriptorString());\n@@ -1913,1 +1912,1 @@\n-            signature = getClassSignature(field.getType());\n+            signature = field.getType().descriptorString();\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,52 +127,0 @@\n-    \/**\n-     * Returns JVM type signature for given primitive.\n-     *\/\n-    private static String getPrimitiveSignature(Class<?> cl) {\n-        if (cl == Integer.TYPE)\n-            return \"I\";\n-        else if (cl == Byte.TYPE)\n-            return \"B\";\n-        else if (cl == Long.TYPE)\n-            return \"J\";\n-        else if (cl == Float.TYPE)\n-            return \"F\";\n-        else if (cl == Double.TYPE)\n-            return \"D\";\n-        else if (cl == Short.TYPE)\n-            return \"S\";\n-        else if (cl == Character.TYPE)\n-            return \"C\";\n-        else if (cl == Boolean.TYPE)\n-            return \"Z\";\n-        else if (cl == Void.TYPE)\n-            return \"V\";\n-        else\n-            throw new InternalError();\n-    }\n-\n-    \/**\n-     * Returns JVM type signature for given class.\n-     *\/\n-    static String getClassSignature(Class<?> cl) {\n-        if (cl.isPrimitive()) {\n-            return getPrimitiveSignature(cl);\n-        } else {\n-            return appendClassSignature(new StringBuilder(), cl).toString();\n-        }\n-    }\n-\n-    static StringBuilder appendClassSignature(StringBuilder sbuf, Class<?> cl) {\n-        while (cl.isArray()) {\n-            sbuf.append('[');\n-            cl = cl.getComponentType();\n-        }\n-\n-        if (cl.isPrimitive()) {\n-            sbuf.append(getPrimitiveSignature(cl));\n-        } else {\n-            sbuf.append('L').append(cl.getName().replace('.', '\/')).append(';');\n-        }\n-\n-        return sbuf;\n-    }\n-\n@@ -193,1 +141,1 @@\n-        signature = getClassSignature(ftype).intern();\n+        signature = ftype.descriptorString().intern();\n@@ -350,1 +298,1 @@\n-            typeSignature = sig = getClassSignature(type).intern();\n+            typeSignature = sig = type.descriptorString().intern();\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamField.java","additions":3,"deletions":55,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n- * <dd>The two floating-point values represent the the same IEEE 754\n+ * <dd>The two floating-point values represent the same IEEE 754\n@@ -175,2 +175,2 @@\n- * exponent}, and significand components of the\n- * floating-point values are the same. Under this relation:\n+ * exponent}, and significand components of the floating-point values\n+ * are the same. Under this relation:\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1016,1 +1016,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n@@ -1091,1 +1091,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,2 +47,64 @@\n- * <p>\n- * An application cannot create its own instance of this class.\n+ *\n+ * <p>An application cannot create its own instance of this class.\n+ *\n+ * <h2><a id=\"shutdown\">Shutdown Sequence<\/a><\/h2>\n+ *\n+ * <p>The Java Virtual Machine initiates the <i>shutdown sequence<\/i> in response\n+ * to one of several events:\n+ * <ol>\n+ * <li>when the number of {@linkplain Thread#isAlive() live} non-daemon threads drops to zero\n+ * for the first time (see note below on the JNI Invocation API);<\/li>\n+ * <li>when the {@link #exit Runtime.exit} or {@link System#exit System.exit} method is called\n+ * for the first time; or<\/li>\n+ * <li>when some external event occurs, such as an interrupt or a signal is received from\n+ * the operating system.<\/li>\n+ * <\/ol>\n+ *\n+ * <p>At the beginning of the shutdown sequence, the registered shutdown hooks are\n+ * {@linkplain Thread#start started} in some unspecified order. They run concurrently\n+ * with any daemon or non-daemon threads that were {@linkplain Thread#isAlive() alive}\n+ * at the beginning of the shutdown sequence.\n+ *\n+ * <p>After the shutdown sequence has begun, registration and de-registration of shutdown hooks\n+ * with {@link #addShutdownHook addShutdownHook} and {@link #removeShutdownHook removeShutdownHook}\n+ * is prohibited. However, creating and starting new threads is permitted. New threads run\n+ * concurrently with the registered shutdown hooks and with any daemon or non-daemon threads\n+ * that are already running.\n+ *\n+ * <p>The shutdown sequence finishes when all shutdown hooks have terminated. At this point,\n+ * the Java Virtual Machine terminates as described below.\n+ *\n+ * <p>It is possible that one or more shutdown hooks do not terminate, for example, because\n+ * of an infinite loop. In this case, the shutdown sequence will never finish. Other threads\n+ * and shutdown hooks continue to run and can terminate the JVM via the {@link #halt halt} method.\n+ *\n+ * <p>Prior to the beginning of the shutdown sequence, it is possible for a program to start\n+ * a shutdown hook by calling its {@link Thread#start start} method explicitly. If this occurs, the\n+ * behavior of the shutdown sequence is unspecified.\n+ *\n+ * <h2><a id=\"termination\">Java Virtual Machine Termination<\/a><\/h2>\n+ *\n+ * <p>The JVM terminates when the shutdown sequence finishes or when {@link #halt halt} is called.\n+ * In contrast to {@link #exit exit}, the {@link #halt halt} method does not initiate the\n+ * shutdown sequence.\n+ *\n+ * <p>When the JVM terminates, all threads are immediately prevented from executing any further\n+ * Java code. This includes shutdown hooks as well as daemon and non-daemon threads. The\n+ * threads' current methods do not complete normally or abruptly; no {@code finally} clause\n+ * of any method is executed, nor is any {@linkplain Thread.UncaughtExceptionHandler\n+ * uncaught exception handler}.\n+ *\n+ * @implNote\n+ * Native code typically uses the\n+ * <a href=\"{@docRoot}\/..\/specs\/jni\/invocation.html\">JNI Invocation API<\/a>\n+ * to control launching and termination of the JVM. Such native code invokes the\n+ * <a href=\"{@docRoot}\/..\/specs\/jni\/invocation.html#jni_createjavavm\">{@code JNI_CreateJavaVM}<\/a>\n+ * function to launch the JVM. Subsequently, the native code invokes the\n+ * <a href=\"{@docRoot}\/..\/specs\/jni\/invocation.html#destroyjavavm\">{@code DestroyJavaVM}<\/a>\n+ * function to await termination of that JVM. The {@code DestroyJavaVM} function is responsible\n+ * for initiating the shutdown sequence when the number of {@linkplain Thread#isAlive() live}\n+ * non-daemon threads first drops to zero. When the shutdown sequence completes and the JVM\n+ * terminates, control is returned to the native code that invoked {@code DestroyJavaVM}. This\n+ * behavior differs from the {@link #exit exit} or {@link #halt halt} methods. These methods\n+ * typically terminate the OS process hosting the JVM and do not interact with the JNI Invocation\n+ * API.\n@@ -51,0 +113,1 @@\n+ * @jls     12.8 Program Exit\n@@ -75,9 +138,4 @@\n-     * Terminates the currently running Java virtual machine by initiating its\n-     * shutdown sequence.  This method never returns normally.  The argument\n-     * serves as a status code; by convention, a nonzero status code indicates\n-     * abnormal termination.\n-     *\n-     * <p> All registered {@linkplain #addShutdownHook shutdown hooks}, if any,\n-     * are started in some unspecified order and allowed to run concurrently\n-     * until they finish.  Once this is done the virtual machine\n-     * {@linkplain #halt halts}.\n+     * Initiates the <a href=\"#shutdown\">shutdown sequence<\/a> of the Java Virtual Machine.\n+     * This method blocks indefinitely; it never returns or throws an exception (that is, it\n+     * does not complete either normally or abruptly). The argument serves as a status code;\n+     * by convention, a nonzero status code indicates abnormal termination.\n@@ -88,2 +146,5 @@\n-     * will block indefinitely. If this method is invoked from a shutdown\n-     * hook the system will deadlock.\n+     * simply block indefinitely.\n+     *\n+     * <p> Because this method always blocks indefinitely, if it is invoked from\n+     * a shutdown hook, it will prevent that shutdown hook from terminating.\n+     * Consequently, this will prevent the shutdown sequence from finishing.\n@@ -121,34 +182,14 @@\n-     * <p> The Java virtual machine <i>shuts down<\/i> in response to two kinds\n-     * of events:\n-     *\n-     *   <ul>\n-     *\n-     *   <li> The program <i>exits<\/i> normally, when the last non-daemon\n-     *   thread exits or when the {@link #exit exit} (equivalently,\n-     *   {@link System#exit(int) System.exit}) method is invoked, or\n-     *\n-     *   <li> The virtual machine is <i>terminated<\/i> in response to a\n-     *   user interrupt, such as typing {@code ^C}, or a system-wide event,\n-     *   such as user logoff or system shutdown.\n-     *\n-     *   <\/ul>\n-     *\n-     * <p> A <i>shutdown hook<\/i> is simply an initialized but unstarted\n-     * thread.  When the virtual machine begins its shutdown sequence it will\n-     * start all registered shutdown hooks in some unspecified order and let\n-     * them run concurrently.  When all the hooks have finished it will then\n-     * halt. Note that daemon threads will continue to run during the shutdown\n-     * sequence, as will non-daemon threads if shutdown was initiated by\n-     * invoking the {@link #exit exit} method.\n-     *\n-     * <p> Once the shutdown sequence has begun it can be stopped only by\n-     * invoking the {@link #halt halt} method, which forcibly\n-     * terminates the virtual machine.\n-     *\n-     * <p> Once the shutdown sequence has begun it is impossible to register a\n-     * new shutdown hook or de-register a previously-registered hook.\n-     * Attempting either of these operations will cause an\n-     * {@link IllegalStateException} to be thrown.\n-     *\n-     * <p> Shutdown hooks run at a delicate time in the life cycle of a virtual\n-     * machine and should therefore be coded defensively.  They should, in\n+     * <p> A <i>shutdown hook<\/i> is simply an initialized but unstarted thread. Shutdown hooks\n+     * are started at the beginning of the <a href=\"#shutdown\">shutdown sequence<\/a>.\n+     * Registration and de-registration of shutdown hooks is disallowed once the shutdown\n+     * sequence has begun.\n+     * <p>\n+     * Uncaught exceptions are handled in shutdown hooks just as in any other thread, as\n+     * specified in {@link Thread.UncaughtExceptionHandler}. After the uncaught exception\n+     * handler has completed, the shutdown hook is considered to have terminated and is not\n+     * treated differently from a hook that has terminated without having thrown an\n+     * uncaught exception.\n+     *\n+     * @apiNote\n+     * Shutdown hooks run at a delicate time in the life cycle of a virtual\n+     * machine and should therefore be coded defensively. They should, in\n@@ -156,3 +197,3 @@\n-     * as possible.  They should also not rely blindly upon services that may\n-     * have registered their own shutdown hooks and therefore may themselves in\n-     * the process of shutting down.  Attempts to use other thread-based\n+     * as possible. They should also not rely blindly upon services that may\n+     * have registered their own shutdown hooks and therefore may themselves be\n+     * in the process of shutting down. Attempts to use other thread-based\n@@ -161,3 +202,3 @@\n-     *\n-     * <p> Shutdown hooks should also finish their work quickly.  When a\n-     * program invokes {@link #exit exit} the expectation is\n+     * <p>\n+     * Shutdown hooks should also finish their work quickly.  When a\n+     * program invokes {@link #exit exit}, the expectation is\n@@ -166,2 +207,2 @@\n-     * underlying operating system may only allow a fixed amount of time in\n-     * which to shut down and exit.  It is therefore inadvisable to attempt any\n+     * underlying operating system may only allow a limited amount of time in\n+     * which to shut down and exit. It is therefore inadvisable to attempt any\n@@ -171,18 +212,0 @@\n-     * <p> Uncaught exceptions are handled in shutdown hooks just as in any\n-     * other thread, by invoking the\n-     * {@link ThreadGroup#uncaughtException uncaughtException} method of the\n-     * thread's {@link ThreadGroup} object. The default implementation of this\n-     * method prints the exception's stack trace to {@link System#err} and\n-     * terminates the thread; it does not cause the virtual machine to exit or\n-     * halt.\n-     *\n-     * <p> In rare circumstances the virtual machine may <i>abort<\/i>, that is,\n-     * stop running without shutting down cleanly.  This occurs when the\n-     * virtual machine is terminated externally, for example with the\n-     * {@code SIGKILL} signal on Unix or the {@code TerminateProcess} call on\n-     * Microsoft Windows.  The virtual machine may also abort if a native\n-     * method goes awry by, for example, corrupting internal data structures or\n-     * attempting to access nonexistent memory.  If the virtual machine aborts\n-     * then no guarantee can be made about whether or not any shutdown hooks\n-     * will be run.\n-     *\n@@ -193,3 +216,3 @@\n-     *          If the specified hook has already been registered,\n-     *          or if it can be determined that the hook is already running or\n-     *          has already been run\n+     *          If the same hook (compared using {@code ==}) as the specified hook has\n+     *          already been registered, or if it can be determined that the hook is\n+     *          already running or has already been run\n@@ -198,2 +221,1 @@\n-     *          If the virtual machine is already in the process\n-     *          of shutting down\n+     *          If the shutdown sequence has already begun\n@@ -221,0 +243,3 @@\n+     * Hooks are compared using {@code ==}.\n+     * Registration and de-registration of shutdown hooks is disallowed\n+     * once the shutdown sequence has begun.\n@@ -228,2 +253,1 @@\n-     *          If the virtual machine is already in the process of shutting\n-     *          down\n+     *          If the shutdown sequence has already begun\n@@ -249,8 +273,9 @@\n-     * Forcibly terminates the currently running Java virtual machine.  This\n-     * method never returns normally.\n-     *\n-     * <p> This method should be used with extreme caution.  Unlike the\n-     * {@link #exit exit} method, this method does not cause shutdown\n-     * hooks to be started.  If the shutdown sequence has already been\n-     * initiated then this method does not wait for any running\n-     * shutdown hooks to finish their work.\n+     * Immediately <a href=\"#termination\">terminates<\/a> the Java Virtual Machine. Termination\n+     * is unconditional and immediate. This method does not initiate the\n+     * <a href=\"#shutdown\">shutdown sequence<\/a>, nor does it wait for the shutdown sequence\n+     * to finish if it is already in progress. This method never returns normally.\n+     *\n+     * @apiNote\n+     * This method should be used with extreme caution. Using it may circumvent or disrupt\n+     * any cleanup actions intended to be performed by shutdown hooks, possibly leading to\n+     * data corruption.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Runtime.java","additions":113,"deletions":88,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -1888,3 +1888,4 @@\n-     * Terminates the currently running Java Virtual Machine. The\n-     * argument serves as a status code; by convention, a nonzero status\n-     * code indicates abnormal termination.\n+     * Initiates the <a href=\"Runtime.html#shutdown\">shutdown sequence<\/a> of the\n+     * Java Virtual Machine. This method always blocks indefinitely. The argument\n+     * serves as a status code; by convention, a nonzero status code indicates\n+     * abnormal termination.\n@@ -1892,2 +1893,2 @@\n-     * This method calls the {@code exit} method in class\n-     * {@code Runtime}. This method never returns normally.\n+     * This method calls the {@code exit} method in class {@code Runtime}. This\n+     * method never returns normally.\n@@ -1895,2 +1896,1 @@\n-     * The call {@code System.exit(n)} is effectively equivalent to\n-     * the call:\n+     * The call {@code System.exit(n)} is effectively equivalent to the call:\n@@ -1901,5 +1901,5 @@\n-     * @param      status   exit status.\n-     * @throws  SecurityException\n-     *        if a security manager exists and its {@code checkExit}\n-     *        method doesn't allow exit with the specified status.\n-     * @see        java.lang.Runtime#exit(int)\n+     * @param  status exit status.\n+     * @throws SecurityException\n+     *         if a security manager exists and its {@code checkExit} method\n+     *         doesn't allow exit with the specified status.\n+     * @see    java.lang.Runtime#exit(int)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -66,5 +65,10 @@\n- * <p> {@code Thread} defines constructors and a {@link Builder} to create threads\n- * that execute {@link Runnable} tasks. {@linkplain  #start() Starting} a thread\n- * schedules it to execute concurrently with the thread that caused it to start.\n- * The newly started thread invokes the task's {@link Runnable#run() run} method.\n- * Thread defines the {@link #join() join} method to wait for a thread to terminate.\n+ * <p> {@code Thread} defines constructors and a {@link Builder} to create threads.\n+ * {@linkplain #start() Starting} a thread schedules it to execute its {@link #run() run}\n+ * method. The newly started thread executes concurrently with the thread that caused\n+ * it to start.\n+ *\n+ * <p> A thread <i>terminates<\/i> if either its {@code run} method completes normally,\n+ * or if its {@code run} method completes abruptly and the appropriate {@linkplain\n+ * Thread.UncaughtExceptionHandler uncaught exception handler} completes normally or\n+ * abruptly. With no code left to run, the thread has completed execution. The\n+ * {@link #join() join} method can be used to wait for a thread to terminate.\n@@ -97,5 +101,3 @@\n- * The Java virtual machine terminates when all started non-daemon threads have\n- * terminated. Unstarted non-daemon threads do not prevent the Java virtual machine\n- * from terminating. The Java virtual machine can also be terminated by invoking\n- * the {@linkplain Runtime#exit(int)} method, in which case it will terminate even\n- * if there are non-daemon threads still running.\n+ * The <a href=\"Runtime.html#shutdown\">shutdown sequence<\/a> begins when all started\n+ * non-daemon threads have terminated. Unstarted non-daemon threads do not prevent\n+ * the shutdown sequence from beginning.\n@@ -127,3 +129,4 @@\n- * <p> Virtual threads are daemon threads and so do not prevent the Java virtual\n- * machine from terminating. Virtual threads have a fixed {@linkplain #getPriority()\n- * thread priority} that cannot be changed.\n+ * <p> Virtual threads are daemon threads and so do not prevent the\n+ * <a href=\"Runtime.html#shutdown\">shutdown sequence<\/a> from beginning.\n+ * Virtual threads have a fixed {@linkplain #getPriority() thread priority}\n+ * that cannot be changed.\n@@ -2203,2 +2206,2 @@\n-     * The Java virtual machine terminates when all started non-daemon threads have\n-     * terminated.\n+     * The <a href=\"Runtime.html#shutdown\">shutdown sequence<\/a> begins when all\n+     * started non-daemon threads have terminated.\n@@ -2206,1 +2209,1 @@\n-     * The daemon status of a virtual thread is always {@code true} and cannot be\n+     * <p> The daemon status of a virtual thread is always {@code true} and cannot be\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamException;\n+import java.io.StreamCorruptedException;\n@@ -1050,0 +1054,9 @@\n+    \/**\n+     * Accept no subclasses.\n+     *\/\n+    private static BigInteger toStrictBigInteger(BigInteger val) {\n+        return (val.getClass() == BigInteger.class) ?\n+            val :\n+            new BigInteger(val.toByteArray().clone());\n+    }\n+\n@@ -1059,2 +1072,2 @@\n-        intVal = val;\n-        intCompact = compactValFor(val);\n+        intVal = toStrictBigInteger(val);\n+        intCompact = compactValFor(intVal);\n@@ -1074,1 +1087,1 @@\n-        this(val,0,mc);\n+        this(toStrictBigInteger(val), 0, mc);\n@@ -1088,2 +1101,2 @@\n-        this.intVal = unscaledVal;\n-        this.intCompact = compactValFor(unscaledVal);\n+        this.intVal = toStrictBigInteger(unscaledVal);\n+        this.intCompact = compactValFor(this.intVal);\n@@ -1107,0 +1120,1 @@\n+        unscaledVal = toStrictBigInteger(unscaledVal);\n@@ -4256,0 +4270,2 @@\n+        private static final long scaleOffset\n+                = unsafe.objectFieldOffset(BigDecimal.class, \"scale\");\n@@ -4257,2 +4273,4 @@\n-        static void setIntCompact(BigDecimal bd, long val) {\n-            unsafe.putLong(bd, intCompactOffset, val);\n+        static void setIntValAndScale(BigDecimal bd, BigInteger intVal, int scale) {\n+            unsafe.putReference(bd, intValOffset, intVal);\n+            unsafe.putInt(bd, scaleOffset, scale);\n+            unsafe.putLong(bd, intCompactOffset, compactValFor(intVal));\n@@ -4277,7 +4295,7 @@\n-        \/\/ Read in all fields\n-        s.defaultReadObject();\n-        \/\/ validate possibly bad fields\n-        if (intVal == null) {\n-            String message = \"BigDecimal: null intVal in stream\";\n-            throw new java.io.StreamCorruptedException(message);\n-        \/\/ [all values of scale are now allowed]\n+        \/\/ prepare to read the fields\n+        ObjectInputStream.GetField fields = s.readFields();\n+        BigInteger serialIntVal = (BigInteger) fields.get(\"intVal\", null);\n+\n+        \/\/ Validate field data\n+        if (serialIntVal == null) {\n+            throw new StreamCorruptedException(\"Null or missing intVal in BigDecimal stream\");\n@@ -4285,1 +4303,16 @@\n-        UnsafeHolder.setIntCompact(this, compactValFor(intVal));\n+        \/\/ Validate provenance of serialIntVal object\n+        serialIntVal = toStrictBigInteger(serialIntVal);\n+\n+        \/\/ Any integer value is valid for scale\n+        int serialScale = fields.get(\"scale\", 0);\n+\n+        UnsafeHolder.setIntValAndScale(this, serialIntVal, serialScale);\n+    }\n+\n+    \/**\n+     * Serialization without data not supported for this class.\n+     *\/\n+    @java.io.Serial\n+    private void readObjectNoData()\n+        throws ObjectStreamException {\n+        throw new InvalidObjectException(\"Deserialized BigDecimal objects need data\");\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":48,"deletions":15,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.InvalidObjectException;\n@@ -36,0 +37,1 @@\n+import java.io.ObjectStreamException;\n@@ -871,0 +873,4 @@\n+    * @implNote Due to the nature of the underlying algorithm,\n+    *          and depending on the size of {@code this},\n+    *          this method could consume a large amount of memory, up to\n+    *          exhaustion of available heap space, or could run for a long time.\n@@ -3883,0 +3889,5 @@\n+     * @throws ArithmeticException {@code this} is too large.\n+     * @implNote Due to the nature of the underlying primality test algorithm,\n+     *          and depending on the size of {@code this} and {@code certainty},\n+     *          this method could consume a large amount of memory, up to\n+     *          exhaustion of available heap space, or could run for a long time.\n@@ -4830,3 +4841,2 @@\n-        \/\/ Read the alternate persistent fields that we care about\n-        int sign = fields.get(\"signum\", -2);\n-        byte[] magnitude = (byte[])fields.get(\"magnitude\", null);\n+        \/\/ Read and validate the alternate persistent fields that we\n+        \/\/ care about, signum and magnitude\n@@ -4834,1 +4844,2 @@\n-        \/\/ Validate signum\n+        \/\/ Read and validate signum\n+        int sign = fields.get(\"signum\", -2);\n@@ -4841,0 +4852,4 @@\n+\n+        \/\/ Read and validate magnitude\n+        byte[] magnitude = (byte[])fields.get(\"magnitude\", null);\n+        magnitude = magnitude.clone(); \/\/ defensive copy\n@@ -4849,0 +4864,7 @@\n+        \/\/ Equivalent to checkRange() on mag local without assigning\n+        \/\/ this.mag field\n+        if (mag.length > MAX_MAG_LENGTH ||\n+            (mag.length == MAX_MAG_LENGTH && mag[0] < 0)) {\n+            throw new java.io.StreamCorruptedException(\"BigInteger: Out of the supported range\");\n+        }\n+\n@@ -4850,1 +4872,2 @@\n-        UnsafeHolder.putSign(this, sign);\n+        UnsafeHolder.putSignAndMag(this, sign, mag);\n+    }\n@@ -4852,9 +4875,7 @@\n-        \/\/ Calculate mag field from magnitude and discard magnitude\n-        UnsafeHolder.putMag(this, mag);\n-        if (mag.length >= MAX_MAG_LENGTH) {\n-            try {\n-                checkRange();\n-            } catch (ArithmeticException e) {\n-                throw new java.io.StreamCorruptedException(\"BigInteger: Out of the supported range\");\n-            }\n-        }\n+    \/**\n+     * Serialization without data not supported for this class.\n+     *\/\n+    @java.io.Serial\n+    private void readObjectNoData()\n+        throws ObjectStreamException {\n+        throw new InvalidObjectException(\"Deserialized BigInteger objects need data\");\n@@ -4872,1 +4893,1 @@\n-        static void putSign(BigInteger bi, int sign) {\n+        static void putSignAndMag(BigInteger bi, int sign, int[] magnitude) {\n@@ -4874,3 +4895,0 @@\n-        }\n-\n-        static void putMag(BigInteger bi, int[] magnitude) {\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":36,"deletions":18,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -507,4 +507,17 @@\n-                                        \"this handler\");\n-        } else if (host != null && u.isBuiltinStreamHandler(this)) {\n-            String s = IPAddressUtil.checkHostString(host);\n-            if (s != null) throw new IllegalArgumentException(s);\n+                    \"this handler\");\n+        }\n+        \/\/ if early parsing, perform additional checks here rather than waiting\n+        \/\/ for openConnection()\n+        boolean earlyURLParsing = IPAddressUtil.earlyURLParsing();\n+        boolean isBuiltInHandler = u.isBuiltinStreamHandler(this);\n+        if (host != null && isBuiltInHandler) {\n+            String errMsg = IPAddressUtil.checkHostString(host);\n+            if (errMsg != null) throw new IllegalArgumentException(errMsg);\n+        }\n+        if (userInfo != null && isBuiltInHandler && earlyURLParsing) {\n+            String errMsg = IPAddressUtil.checkUserInfo(userInfo);\n+            if (errMsg != null) throw new IllegalArgumentException(errMsg);\n+        }\n+        if (authority != null && isBuiltInHandler && earlyURLParsing) {\n+            String errMsg = IPAddressUtil.checkAuth(authority);\n+            if (errMsg != null) throw new IllegalArgumentException(errMsg);\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLStreamHandler.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -144,1 +144,8 @@\n-        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n+        try {\n+            cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n+        } catch (Throwable t) {\n+            \/\/ Prevent leak if the Deallocator or Cleaner fail for any reason\n+            UNSAFE.freeMemory(base);\n+            Bits.unreserveMemory(size, cap);\n+            throw t;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -153,4 +153,5 @@\n- * float  {@link #getFloat()}\n- * float  {@link #getFloat(int) getFloat(int index)}\n- *  void  {@link #putFloat(float) putFloat(float f)}\n- *  void  {@link #putFloat(int,float) putFloat(int index, float f)}<\/pre><\/blockquote>\n+ * float      {@link #getFloat()}\n+ * float      {@link #getFloat(int) getFloat(int index)}\n+ * ByteBuffer {@link #putFloat(float) putFloat(float f)}\n+ * ByteBuffer {@link #putFloat(int,float) putFloat(int index, float f)}\n+ * <\/pre><\/blockquote>\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -531,0 +531,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -546,0 +550,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -562,0 +570,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -577,0 +589,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -596,0 +612,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -616,0 +636,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/DatagramChannel.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -149,1 +149,3 @@\n- * therefore unspecified.\n+ * therefore unspecified.  In this mode the behavior of the method to\n+ * {@linkplain #write(ByteBuffer,long) write at a given position} is also\n+ * system-dependent.\n@@ -196,1 +198,3 @@\n-     *     therefore unspecified. This option may not be used in conjunction\n+     *     therefore unspecified. The effect of {@linkplain\n+     *     #write(ByteBuffer,long) writing at a given position} with this option\n+     *     present is unspecified. This option may not be used in conjunction\n@@ -375,0 +379,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -386,0 +394,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -397,0 +409,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -415,0 +431,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -432,0 +452,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -449,0 +473,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -788,0 +816,3 @@\n+     * <p> If the file is open in <a href=\"#append-mode\">append mode<\/a>, then\n+     * the effect of invoking this method is unspecified.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -78,0 +82,4 @@\n+     *\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/SeekableByteChannel.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,0 +606,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -612,0 +615,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -619,0 +625,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -627,0 +636,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -633,0 +645,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n@@ -640,0 +655,3 @@\n+     * @throws  ClosedChannelException      {@inheritDoc}\n+     * @throws  AsynchronousCloseException  {@inheritDoc}\n+     * @throws  ClosedByInterruptException  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/SocketChannel.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -313,0 +313,2 @@\n+     *\n+     * @throws  ClosedChannelException {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractSelectableChannel.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.access.JavaSecurityPropertiesAccess;\n@@ -66,0 +67,3 @@\n+    \/* cache a copy for recording purposes *\/\n+    private static Properties initialSecurityProperties;\n+\n@@ -82,0 +86,7 @@\n+        \/\/ Set up JavaSecurityPropertiesAccess in SharedSecrets\n+        SharedSecrets.setJavaSecurityPropertiesAccess(new JavaSecurityPropertiesAccess() {\n+            @Override\n+            public Properties getInitialProperties() {\n+                return initialSecurityProperties;\n+            }\n+        });\n@@ -107,0 +118,8 @@\n+        initialSecurityProperties = (Properties) props.clone();\n+        if (sdebug != null) {\n+            for (String key : props.stringPropertyNames()) {\n+                sdebug.println(\"Initial security property: \" + key + \"=\" +\n+                    props.getProperty(key));\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-     * the array will not affect this UnsolvedPermission.\n+     * the array will not affect this UnresolvedPermission.\n@@ -168,0 +168,6 @@\n+        \/\/ Perform a defensive copy and reassign certs if we have a non-null\n+        \/\/ reference\n+        if (certs != null) {\n+            certs = certs.clone();\n+        }\n+\n@@ -171,0 +177,1 @@\n+\n@@ -173,1 +180,1 @@\n-            for (int i=0; i<certs.length; i++) {\n+            for (int i = 0; i < certs.length; i++) {\n@@ -176,3 +183,3 @@\n-                    \/\/ entire cert array\n-                    this.certs = certs.clone();\n-                    break;\n+                    \/\/ entire cert array.  No further processing is necessary.\n+                    this.certs = certs;\n+                    return;\n@@ -182,12 +189,9 @@\n-            if (this.certs == null) {\n-                \/\/ Go through the list of certs and see if all the certs are\n-                \/\/ signer certs.\n-                int i = 0;\n-                int count = 0;\n-                while (i < certs.length) {\n-                    count++;\n-                    while (((i+1) < certs.length) &&\n-                           ((X509Certificate)certs[i]).getIssuerX500Principal().equals(\n-                               ((X509Certificate)certs[i+1]).getSubjectX500Principal())) {\n-                        i++;\n-                    }\n+            \/\/ Go through the list of certs and see if all the certs are\n+            \/\/ signer certs.\n+            int i = 0;\n+            int count = 0;\n+            while (i < certs.length) {\n+                count++;\n+                while (((i + 1) < certs.length) &&\n+                       ((X509Certificate)certs[i]).getIssuerX500Principal().equals(\n+                           ((X509Certificate)certs[i + 1]).getSubjectX500Principal())) {\n@@ -196,5 +200,8 @@\n-                if (count == certs.length) {\n-                    \/\/ All the certs are signer certs, so we store the entire\n-                    \/\/ array\n-                    this.certs = certs.clone();\n-                }\n+                i++;\n+            }\n+            if (count == certs.length) {\n+                \/\/ All the certs are signer certs, so we store the entire\n+                \/\/ array.  No further processing is needed.\n+                this.certs = certs;\n+                return;\n+            }\n@@ -202,17 +209,10 @@\n-                if (this.certs == null) {\n-                    \/\/ extract the signer certs\n-                    ArrayList<java.security.cert.Certificate> signerCerts =\n-                        new ArrayList<>();\n-                    i = 0;\n-                    while (i < certs.length) {\n-                        signerCerts.add(certs[i]);\n-                        while (((i+1) < certs.length) &&\n-                            ((X509Certificate)certs[i]).getIssuerX500Principal().equals(\n-                              ((X509Certificate)certs[i+1]).getSubjectX500Principal())) {\n-                            i++;\n-                        }\n-                        i++;\n-                    }\n-                    this.certs =\n-                        new java.security.cert.Certificate[signerCerts.size()];\n-                    signerCerts.toArray(this.certs);\n+            \/\/ extract the signer certs\n+            ArrayList<java.security.cert.Certificate> signerCerts =\n+                new ArrayList<>();\n+            i = 0;\n+            while (i < certs.length) {\n+                signerCerts.add(certs[i]);\n+                while (((i + 1) < certs.length) &&\n+                    ((X509Certificate)certs[i]).getIssuerX500Principal().equals(\n+                      ((X509Certificate)certs[i + 1]).getSubjectX500Principal())) {\n+                    i++;\n@@ -220,0 +220,1 @@\n+                i++;\n@@ -221,0 +222,3 @@\n+            this.certs =\n+                new java.security.cert.Certificate[signerCerts.size()];\n+            signerCerts.toArray(this.certs);\n@@ -313,0 +317,1 @@\n+    @Override\n@@ -333,0 +338,1 @@\n+    @Override\n@@ -405,1 +411,1 @@\n-\n+    @Override\n@@ -425,0 +431,1 @@\n+    @Override\n@@ -494,0 +501,1 @@\n+    @Override\n@@ -505,1 +513,1 @@\n-\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/security\/UnresolvedPermission.java","additions":49,"deletions":41,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -355,0 +355,5 @@\n+    \/**\n+     * RegEx to parse number part of a compact number text\n+     *\/\n+    private transient Pattern numberPattern;\n+\n@@ -591,2 +596,2 @@\n-            int iPart = getIntegerPart(number, divisor);\n-            if (checkIncrement(iPart, compactDataIndex, divisor)) {\n+            double val = getNumberValue(number, divisor);\n+            if (checkIncrement(val, compactDataIndex, divisor)) {\n@@ -594,1 +599,1 @@\n-                iPart = getIntegerPart(number, divisor);\n+                val = getNumberValue(number, divisor);\n@@ -596,2 +601,2 @@\n-            String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);\n-            String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);\n+            String prefix = getAffix(false, true, isNegative, compactDataIndex, val);\n+            String suffix = getAffix(false, false, isNegative, compactDataIndex, val);\n@@ -601,1 +606,1 @@\n-                if (!placeHolderPatterns.get(compactDataIndex).get(iPart).isEmpty()) {\n+                if (!placeHolderPatterns.get(compactDataIndex).get(val).isEmpty()) {\n@@ -664,2 +669,2 @@\n-            int iPart = getIntegerPart(number, divisor);\n-            if (checkIncrement(iPart, compactDataIndex, divisor)) {\n+            double val = getNumberValue(number, divisor);\n+            if (checkIncrement(val, compactDataIndex, divisor)) {\n@@ -667,1 +672,1 @@\n-                iPart = getIntegerPart(number, divisor);\n+                val = getNumberValue(number, divisor);\n@@ -669,2 +674,2 @@\n-            String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);\n-            String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);\n+            String prefix = getAffix(false, true, isNegative, compactDataIndex, val);\n+            String suffix = getAffix(false, false, isNegative, compactDataIndex, val);\n@@ -673,1 +678,1 @@\n-                if (!placeHolderPatterns.get(compactDataIndex).get(iPart).isEmpty()) {\n+                if (!placeHolderPatterns.get(compactDataIndex).get(val).isEmpty()) {\n@@ -763,2 +768,2 @@\n-            int iPart = getIntegerPart(number.doubleValue(), divisor.doubleValue());\n-            if (checkIncrement(iPart, compactDataIndex, divisor.doubleValue())) {\n+            double val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n+            if (checkIncrement(val, compactDataIndex, divisor.doubleValue())) {\n@@ -766,1 +771,1 @@\n-                iPart = getIntegerPart(number.doubleValue(), divisor.doubleValue());\n+                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -768,2 +773,2 @@\n-            String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);\n-            String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);\n+            String prefix = getAffix(false, true, isNegative, compactDataIndex, val);\n+            String suffix = getAffix(false, false, isNegative, compactDataIndex, val);\n@@ -772,1 +777,1 @@\n-                if (!placeHolderPatterns.get(compactDataIndex).get(iPart).isEmpty()) {\n+                if (!placeHolderPatterns.get(compactDataIndex).get(val).isEmpty()) {\n@@ -834,2 +839,2 @@\n-            int iPart = getIntegerPart(number.doubleValue(), divisor.doubleValue());\n-            if (checkIncrement(iPart, compactDataIndex, divisor.doubleValue())) {\n+            double val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n+            if (checkIncrement(val, compactDataIndex, divisor.doubleValue())) {\n@@ -837,1 +842,1 @@\n-                iPart = getIntegerPart(number.doubleValue(), divisor.doubleValue());\n+                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -839,2 +844,2 @@\n-            String prefix = getAffix(false, true, isNegative, compactDataIndex, iPart);\n-            String suffix = getAffix(false, false, isNegative, compactDataIndex, iPart);\n+            String prefix = getAffix(false, true, isNegative, compactDataIndex, val);\n+            String suffix = getAffix(false, false, isNegative, compactDataIndex, val);\n@@ -843,1 +848,1 @@\n-                if (!placeHolderPatterns.get(compactDataIndex).get(iPart).isEmpty()) {\n+                if (!placeHolderPatterns.get(compactDataIndex).get(val).isEmpty()) {\n@@ -882,1 +887,1 @@\n-    private String getAffix(boolean isExpanded, boolean isPrefix, boolean isNegative, int compactDataIndex, int iPart) {\n+    private String getAffix(boolean isExpanded, boolean isPrefix, boolean isNegative, int compactDataIndex, double val) {\n@@ -887,1 +892,1 @@\n-                .get(compactDataIndex).get(iPart);\n+                .get(compactDataIndex).get(val);\n@@ -1590,2 +1595,2 @@\n-            String positivePrefix = getAffix(true, true, false, compactIndex, (int)num);\n-            String negativePrefix = getAffix(true, true, true, compactIndex, (int)num);\n+            String positivePrefix = getAffix(true, true, false, compactIndex, num);\n+            String negativePrefix = getAffix(true, true, true, compactIndex, num);\n@@ -1739,1 +1744,0 @@\n-    private static final Pattern DIGITS = Pattern.compile(\"\\\\p{Nd}+\");\n@@ -1748,0 +1752,3 @@\n+        if (numberPattern == null) {\n+            numberPattern = Pattern.compile(\"[\\\\Q\" + symbols.getDecimalSeparator() + \"\\\\E\\\\p{Nd}]+\");\n+        }\n@@ -1751,1 +1758,1 @@\n-            Matcher m = DIGITS.matcher(text);\n+            Matcher m = numberPattern.matcher(text);\n@@ -1754,2 +1761,1 @@\n-                int cp = digits.codePointAt(0);\n-                if (Character.isDigit(cp)) {\n+                if (Character.isDigit(digits.codePointAt(0))) {\n@@ -1757,0 +1763,1 @@\n+                        .filter(cp -> cp != symbols.getDecimalSeparator())\n@@ -1912,4 +1919,4 @@\n-            String positivePrefix = getAffix(true, true, false, compactIndex, (int)num);\n-            String negativePrefix = getAffix(true, true, true, compactIndex, (int)num);\n-            String positiveSuffix = getAffix(true, false, false, compactIndex, (int)num);\n-            String negativeSuffix = getAffix(true, false, true, compactIndex, (int)num);\n+            String positivePrefix = getAffix(true, true, false, compactIndex, num);\n+            String negativePrefix = getAffix(true, true, true, compactIndex, num);\n+            String positiveSuffix = getAffix(true, false, false, compactIndex, num);\n+            String negativeSuffix = getAffix(true, false, true, compactIndex, num);\n@@ -2410,3 +2417,4 @@\n-    private int getIntegerPart(double number, double divisor) {\n-        return BigDecimal.valueOf(number)\n-                .divide(BigDecimal.valueOf(divisor), roundingMode).intValue();\n+    private double getNumberValue(double number, double divisor) {\n+        var num = BigDecimal.valueOf(number)\n+                .divide(BigDecimal.valueOf(divisor), roundingMode);\n+        return getMaximumFractionDigits() > 0 ? num.doubleValue() : num.intValue();\n@@ -2415,3 +2423,3 @@\n-    \/\/ Checks whether the iPart is incremented by the BigDecimal division in\n-    \/\/ getIntegerPart(), and affects the compact number index.\n-    private boolean checkIncrement(int iPart, int index, double divisor) {\n+    \/\/ Checks whether the val is incremented by the BigDecimal division in\n+    \/\/ getNumberValue(), and affects the compact number index.\n+    private boolean checkIncrement(double val, int index, double divisor) {\n@@ -2422,1 +2430,1 @@\n-                return Math.log10(iPart) == Math.log10(nextDiv) - Math.log10(divisor);\n+                return Math.log10(val) == Math.log10(nextDiv) - Math.log10(divisor);\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":51,"deletions":43,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -156,2 +156,2 @@\n-     * If (count == 0) this throws a NumberFormatException, which\n-     * mimics Long.parseLong().\n+     * If (count == 0) this returns 0.0,\n+     * unlike Double.parseDouble(\"\") which throws NumberFormatException.\n@@ -174,1 +174,2 @@\n-     * If (count == 0) this returns 0, unlike Long.parseLong().\n+     * If (count == 0) this returns 0,\n+     * unlike Long.parseLong(\"\") which throws NumberFormatException.\n@@ -198,0 +199,5 @@\n+    \/**\n+     * Utility routine to get the value of the digit list.\n+     * If (count == 0) this does not throw a NumberFormatException,\n+     * unlike BigDecimal(\"\").\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2434,1 +2434,0 @@\n-            int cutoverGap = 0;\n@@ -2450,3 +2449,1 @@\n-                int realDayOfYear = (int)(fixedDate - fixedDateJan1) + 1;\n-                cutoverGap = dayOfYear - realDayOfYear;\n-                dayOfYear = realDayOfYear;\n+                dayOfYear = (int)(fixedDate - fixedDateJan1) + 1;\n","filename":"src\/java.base\/share\/classes\/java\/util\/GregorianCalendar.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2121,1 +2121,0 @@\n-        Era era = date.getEra();\n","filename":"src\/java.base\/share\/classes\/java\/util\/JapaneseImperialCalendar.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import java.util.Properties;\n+\n+public interface JavaSecurityPropertiesAccess {\n+    Properties getInitialProperties();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaSecurityPropertiesAccess.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import java.security.Security;\n@@ -86,0 +87,1 @@\n+    private static JavaSecurityPropertiesAccess javaSecurityPropertiesAccess;\n@@ -346,0 +348,13 @@\n+    public static void setJavaSecurityPropertiesAccess(JavaSecurityPropertiesAccess jspa) {\n+        javaSecurityPropertiesAccess = jspa;\n+    }\n+\n+    public static JavaSecurityPropertiesAccess getJavaSecurityPropertiesAccess() {\n+        var access = javaSecurityPropertiesAccess;\n+        if (access == null) {\n+            ensureClassInitialized(Security.class);\n+            access = javaSecurityPropertiesAccess;\n+        }\n+        return access;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+    private static final String JAVA_LOCALE_USE_OLD_ISO_CODES;\n@@ -77,0 +78,1 @@\n+        JAVA_LOCALE_USE_OLD_ISO_CODES = getProperty(props, \"java.locale.useOldISOCodes\", \"\");\n@@ -246,0 +248,11 @@\n+\n+    \/**\n+     * {@return the {@code java.locale.useOldISOCodes} system property}\n+     *\n+     * <strong>{@link SecurityManager#checkPropertyAccess} is NOT checked\n+     * in this method. The caller of this method should take care to ensure\n+     * that the returned property is not made accessible to untrusted code.<\/strong>\n+     *\/\n+    public static String javaLocaleUseOldISOCodes() {\n+        return JAVA_LOCALE_USE_OLD_ISO_CODES;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StaticProperty.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-    \/\/FIXME @IntrinsicCandidate\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n- *      {@link java.nio.file.FileSystems#newFileSystem\n- *      FileSystems.newFileSystem(URI.create(\"jrt:\/\"))}.\n+ *      {@link java.nio.file.FileSystems#getFileSystem\n+ *      FileSystems.getFileSystem(URI.create(\"jrt:\/\"))}.\n@@ -167,0 +167,1 @@\n+        jdk.jfr,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -430,0 +430,10 @@\n+    \/\/ excluded delims: \"<>\\\" \" - we don't include % and # here\n+    private static final long L_EXCLUDED_DELIMS = 0x5000000500000000L;\n+    private static final long H_EXCLUDED_DELIMS = 0x0L;\n+    \/\/ unwise \"{}|\\\\^[]`\";\n+    private static final long L_UNWISE = 0x0L;\n+    private static final long H_UNWISE = 0x3800000178000000L;\n+    private static final long L_FRAGMENT = 0x0000000800000000L;\n+    private static final long H_FRAGMENT = 0x0L;\n+    private static final long L_QUERY = 0x8000000000000000L;\n+    private static final long H_QUERY = 0x0L;\n@@ -482,1 +492,5 @@\n-    private static String checkUserInfo(String str) {\n+    \/\/ Check user-info component.\n+    \/\/ This method returns an error message if a problem\n+    \/\/ is found. The caller is expected to use that message to\n+    \/\/ throw an exception.\n+    public static String checkUserInfo(String str) {\n@@ -484,2 +498,2 @@\n-        int index = scan(str, L_EXCLUDE & ~L_COLON,\n-                H_EXCLUDE & ~H_COLON);\n+        int index = scan(str, MASKS.L_USERINFO_MASK,\n+                MASKS.H_USERINFO_MASK);\n@@ -501,2 +515,1 @@\n-                            L_NON_PRINTABLE | L_IPV6_DELIMS,\n-                            H_NON_PRINTABLE | H_IPV6_DELIMS);\n+                            MASKS.L_SCOPE_MASK, MASKS.H_SCOPE_MASK);\n@@ -512,1 +525,2 @@\n-            index = scan(str, L_EXCLUDE, H_EXCLUDE);\n+            index = scan(str, L_EXCLUDE | MASKS.L_HOSTNAME_MASK,\n+                    H_EXCLUDE | MASKS.H_HOSTNAME_MASK, OTHERS);\n@@ -521,1 +535,8 @@\n-    private static String checkAuth(String str) {\n+    \/\/ Simple checks for the authority component.\n+    \/\/ Deeper checks on the various parts of a server-based\n+    \/\/ authority component may be performed by calling\n+    \/\/ #checkAuthority(URL url)\n+    \/\/ This method returns an error message if a problem\n+    \/\/ is found. The caller is expected to use that message to\n+    \/\/ throw an exception.\n+    public static String checkAuth(String str) {\n@@ -532,2 +553,5 @@\n-    \/\/ check authority of hierarchical URL. Appropriate for\n-    \/\/ HTTP-like protocol handlers\n+    \/\/ check authority of hierarchical (server based) URL.\n+    \/\/ Appropriate for HTTP-like protocol handlers\n+    \/\/ This method returns an error message if a problem\n+    \/\/ is found. The caller is expected to use that message to\n+    \/\/ throw an exception.\n@@ -549,2 +573,6 @@\n-    \/\/ minimal syntax checks - deeper check may be performed\n-    \/\/ by the appropriate protocol handler\n+    \/\/ minimal syntax checks if delayed parsing is\n+    \/\/ enabled - deeper check will be performed\n+    \/\/ later by the appropriate protocol handler\n+    \/\/ This method returns an error message if a problem\n+    \/\/ is found. The caller is expected to use that message to\n+    \/\/ throw an exception.\n@@ -554,6 +582,12 @@\n-        int index = scan(s = url.getUserInfo(),\n-                L_NON_PRINTABLE | L_SLASH,\n-                H_NON_PRINTABLE | H_SLASH);\n-        if (index >= 0) {\n-            return \"Illegal character found in authority: \"\n-                    + describeChar(s.charAt(index));\n+        boolean earlyURLParsing = earlyURLParsing();\n+        String userInfo = url.getUserInfo();\n+        if (earlyURLParsing) {\n+            if ((s = checkUserInfo(userInfo)) != null) return s;\n+        } else {\n+            int index = scan(s = userInfo,\n+                    L_NON_PRINTABLE | L_SLASH,\n+                    H_NON_PRINTABLE | H_SLASH);\n+            if (index >= 0) {\n+                return \"Illegal character found in authority: \"\n+                        + describeChar(s.charAt(index));\n+            }\n@@ -561,1 +595,2 @@\n-        if ((s = checkHostString(url.getHost())) != null) {\n+        String host = url.getHost();\n+        if ((s = checkHostString(host)) != null) {\n@@ -567,0 +602,4 @@\n+    \/\/ Check host component.\n+    \/\/ This method returns an error message if a problem\n+    \/\/ is found. The caller is expected to use that message to\n+    \/\/ throw an exception.\n@@ -569,7 +608,12 @@\n-        int index = scan(host,\n-                L_NON_PRINTABLE | L_SLASH,\n-                H_NON_PRINTABLE | H_SLASH,\n-                OTHERS);\n-        if (index >= 0) {\n-            return \"Illegal character found in host: \"\n-                    + describeChar(host.charAt(index));\n+        if (earlyURLParsing()) {\n+            \/\/ also validate IPv6 literal format if present\n+            return checkHost(host);\n+        } else {\n+            int index = scan(host,\n+                    MASKS.L_HOSTNAME_MASK,\n+                    MASKS.H_HOSTNAME_MASK,\n+                    OTHERS);\n+            if (index >= 0) {\n+                return \"Illegal character found in host: \"\n+                        + describeChar(host.charAt(index));\n+            }\n@@ -806,0 +850,8 @@\n+    public static boolean earlyURLParsing() {\n+        return !MASKS.DELAY_URL_PARSING_SP_VALUE;\n+    }\n+\n+    public static boolean delayURLParsing() {\n+        return MASKS.DELAY_URL_PARSING_SP_VALUE;\n+    }\n+\n@@ -820,0 +872,29 @@\n+    private static class MASKS {\n+        private static final String DELAY_URL_PARSING_SP = \"jdk.net.url.delayParsing\";\n+        private static final boolean DELAY_URL_PARSING_SP_VALUE;\n+        static final long L_USERINFO_MASK = L_EXCLUDE & ~L_COLON;\n+        static final long H_USERINFO_MASK = H_EXCLUDE & ~H_COLON;\n+        static final long L_HOSTNAME_MASK;\n+        static final long H_HOSTNAME_MASK;\n+        static final long L_SCOPE_MASK;\n+        static final long H_SCOPE_MASK;\n+        static {\n+            var value = GetPropertyAction.privilegedGetProperty(\n+                    DELAY_URL_PARSING_SP, \"false\");\n+            DELAY_URL_PARSING_SP_VALUE = value.isEmpty()\n+                    || Boolean.parseBoolean(value);\n+            if (DELAY_URL_PARSING_SP_VALUE) {\n+                L_HOSTNAME_MASK = L_NON_PRINTABLE | L_SLASH;\n+                H_HOSTNAME_MASK = H_NON_PRINTABLE | H_SLASH;\n+                L_SCOPE_MASK = L_NON_PRINTABLE | L_IPV6_DELIMS;\n+                H_SCOPE_MASK = H_NON_PRINTABLE | H_IPV6_DELIMS;\n+            } else {\n+                \/\/ the hostname mask can also forbid [ ] brackets, because IPv6 should be\n+                \/\/ checked early before the mask is used when earlier parsing checks are performed\n+                L_HOSTNAME_MASK = L_NON_PRINTABLE | L_SLASH | L_UNWISE | L_EXCLUDED_DELIMS;\n+                H_HOSTNAME_MASK = H_NON_PRINTABLE | H_SLASH | H_UNWISE | H_EXCLUDED_DELIMS;\n+                L_SCOPE_MASK = L_NON_PRINTABLE | L_IPV6_DELIMS | L_SLASH | L_BACKSLASH | L_FRAGMENT | L_QUERY;\n+                H_SCOPE_MASK = H_NON_PRINTABLE | H_IPV6_DELIMS | H_SLASH | H_BACKSLASH | H_FRAGMENT | H_QUERY;\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":106,"deletions":25,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.OptionalInt;\n@@ -249,0 +250,13 @@\n+\n+    public OptionalInt findInt(String k) {\n+        try {\n+            String s = findValue(k);\n+            if (s == null) {\n+                return OptionalInt.empty();\n+            }\n+            return OptionalInt.of(Integer.parseInt(s));\n+        } catch (Throwable t) {\n+            return OptionalInt.empty();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/HeaderParser.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,4 @@\n-                assert (n - i >= 2);\n+                if (n - i < 2) {\n+                    throw new IllegalArgumentException(\"Malformed escape pair: \" + s);\n+                }\n+\n@@ -203,2 +206,2 @@\n-                } catch (NumberFormatException e) {\n-                    throw new IllegalArgumentException();\n+                } catch (NumberFormatException | IndexOutOfBoundsException e) {\n+                    throw new IllegalArgumentException(\"Malformed escape pair: \" + s);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/ParseUtil.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.OptionalInt;\n@@ -130,0 +131,1 @@\n+     * -2: the server provided \"Connection: keep-alive\" and timeout=0\n@@ -906,4 +908,2 @@\n-                        keepAliveTimeout = p.findInt(\"timeout\", -1);\n-                        if (keepAliveTimeout < -1) {\n-                            \/\/ if the server specified a negative (invalid) value\n-                            \/\/ then we set to -1, which is equivalent to no value\n+                        OptionalInt timeout = p.findInt(\"timeout\");\n+                        if (timeout.isEmpty()) {\n@@ -911,0 +911,10 @@\n+                        } else {\n+                            keepAliveTimeout = timeout.getAsInt();\n+                            if (keepAliveTimeout < 0) {\n+                                \/\/ if the server specified a negative (invalid) value\n+                                \/\/ then we set to -1, which is equivalent to no value\n+                                keepAliveTimeout = -1;\n+                            } else if (keepAliveTimeout == 0) {\n+                                \/\/ handled specially to mean close connection immediately\n+                                keepAliveTimeout = -2;\n+                            }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -176,0 +176,2 @@\n+                } else if (keepAliveTimeout == -2) {\n+                    keepAliveTimeout = 0;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-    static URL checkURL(URL u) throws IllegalArgumentException {\n+    private static URL checkURL(URL u) throws MalformedURLException {\n@@ -165,2 +165,1 @@\n-                Exception mfue = new MalformedURLException(\"Illegal character in URL\");\n-                throw new IllegalArgumentException(mfue.getMessage(), mfue);\n+                throw new MalformedURLException(\"Illegal character in URL\");\n@@ -169,4 +168,3 @@\n-        String s = IPAddressUtil.checkAuthority(u);\n-        if (s != null) {\n-            Exception mfue = new MalformedURLException(s);\n-            throw new IllegalArgumentException(mfue.getMessage(), mfue);\n+        String errMsg = IPAddressUtil.checkAuthority(u);\n+        if (errMsg != null) {\n+            throw new MalformedURLException(errMsg);\n@@ -182,1 +180,1 @@\n-    public FtpURLConnection(URL url) {\n+    public FtpURLConnection(URL url) throws MalformedURLException {\n@@ -189,1 +187,1 @@\n-    FtpURLConnection(URL url, Proxy p) {\n+    FtpURLConnection(URL url, Proxy p) throws MalformedURLException {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/ftp\/FtpURLConnection.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.net.MalformedURLException;\n@@ -61,1 +62,9 @@\n-        return new FtpURLConnection(u, p);\n+        FtpURLConnection connection = null;\n+        try {\n+            connection = new FtpURLConnection(u, p);\n+        } catch (IllegalArgumentException e) {\n+            var mfue = new MalformedURLException(e.getMessage());\n+            mfue.initCause(e);\n+            throw mfue;\n+        }\n+        return connection;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/ftp\/Handler.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -505,2 +505,1 @@\n-    static void checkBufferPositionAligned(ByteBuffer bb,\n-                                                     int pos, int alignment)\n+    static void checkBufferPositionAligned(ByteBuffer bb, int pos, int alignment)\n@@ -509,2 +508,3 @@\n-        if (bb.alignmentOffset(pos, alignment) != 0) {\n-            throw new IOException(\"Current location of the bytebuffer (\"\n+        final int alignmentOffset = bb.alignmentOffset(pos, alignment);\n+        if (alignmentOffset != 0) {\n+            throw new IOException(\"Current position of the bytebuffer (\"\n@@ -512,1 +512,1 @@\n-                + alignment + \")\");\n+                + alignment + \"): alignment offset = \" + alignmentOffset);\n@@ -516,2 +516,1 @@\n-    static void checkRemainingBufferSizeAligned(int rem,\n-                                                          int alignment)\n+    static void checkRemainingBufferSizeAligned(int rem, int alignment)\n@@ -527,2 +526,1 @@\n-    static void checkChannelPositionAligned(long position,\n-                                                      int alignment)\n+    static void checkChannelPositionAligned(long position, int alignment)\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Util.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1672,11 +1672,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -1796,11 +1785,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -1969,11 +1947,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2099,11 +2066,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2238,11 +2194,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2367,11 +2312,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2529,11 +2463,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n@@ -2660,11 +2583,0 @@\n-            @Override\n-            void dispose() {\n-                if (cipher != null) {\n-                    try {\n-                        cipher.doFinal();\n-                    } catch (Exception e) {\n-                        \/\/ swallow all types of exceptions.\n-                    }\n-                }\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLCipher.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+        recordLock.lock();\n@@ -259,0 +260,3 @@\n+            if (isClosed) {\n+                return null;\n+            }\n@@ -267,0 +271,2 @@\n+        } finally {\n+            recordLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketInputRecord.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.io.OutputStream;\n@@ -31,0 +30,1 @@\n+import java.io.OutputStream;\n@@ -82,1 +82,1 @@\n-    public void write(byte tag, byte[] buf) throws IOException {\n+    public DerOutputStream write(byte tag, byte[] buf) throws IOException {\n@@ -86,0 +86,1 @@\n+        return this;\n@@ -97,1 +98,1 @@\n-    public void write(byte tag, DerOutputStream out) throws IOException {\n+    public DerOutputStream write(byte tag, DerOutputStream out) throws IOException {\n@@ -101,0 +102,1 @@\n+        return this;\n@@ -120,1 +122,1 @@\n-    public void writeImplicit(byte tag, DerOutputStream value)\n+    public DerOutputStream writeImplicit(byte tag, DerOutputStream value)\n@@ -124,0 +126,1 @@\n+        return this;\n@@ -129,1 +132,1 @@\n-    public void putDerValue(DerValue val) throws IOException {\n+    public DerOutputStream putDerValue(DerValue val) throws IOException {\n@@ -131,0 +134,1 @@\n+        return this;\n@@ -144,1 +148,1 @@\n-    public void putBoolean(boolean val) throws IOException {\n+    public DerOutputStream putBoolean(boolean val) throws IOException {\n@@ -152,0 +156,1 @@\n+        return this;\n@@ -158,1 +163,1 @@\n-    public void putEnumerated(int i) throws IOException {\n+    public DerOutputStream putEnumerated(int i) throws IOException {\n@@ -161,0 +166,1 @@\n+        return this;\n@@ -168,1 +174,1 @@\n-    public void putInteger(BigInteger i) throws IOException {\n+    public DerOutputStream putInteger(BigInteger i) throws IOException {\n@@ -173,0 +179,1 @@\n+        return this;\n@@ -180,1 +187,1 @@\n-    public void putInteger(byte[] buf) throws IOException {\n+    public DerOutputStream putInteger(byte[] buf) throws IOException {\n@@ -184,0 +191,1 @@\n+        return this;\n@@ -190,2 +198,2 @@\n-    public void putInteger(Integer i) throws IOException {\n-        putInteger(i.intValue());\n+    public DerOutputStream putInteger(Integer i) throws IOException {\n+        return putInteger(i.intValue());\n@@ -198,1 +206,1 @@\n-    public void putInteger(int i) throws IOException {\n+    public DerOutputStream putInteger(int i) throws IOException {\n@@ -201,0 +209,1 @@\n+        return this;\n@@ -253,1 +262,1 @@\n-    public void putBitString(byte[] bits) throws IOException {\n+    public DerOutputStream putBitString(byte[] bits) throws IOException {\n@@ -258,0 +267,1 @@\n+        return this;\n@@ -266,1 +276,1 @@\n-    public void putUnalignedBitString(BitArray ba) throws IOException {\n+    public DerOutputStream putUnalignedBitString(BitArray ba) throws IOException {\n@@ -273,0 +283,1 @@\n+        return this;\n@@ -281,2 +292,2 @@\n-    public void putTruncatedUnalignedBitString(BitArray ba) throws IOException {\n-        putUnalignedBitString(ba.truncate());\n+    public DerOutputStream putTruncatedUnalignedBitString(BitArray ba) throws IOException {\n+        return putUnalignedBitString(ba.truncate());\n@@ -290,2 +301,2 @@\n-    public void putOctetString(byte[] octets) throws IOException {\n-        write(DerValue.tag_OctetString, octets);\n+    public DerOutputStream putOctetString(byte[] octets) throws IOException {\n+        return write(DerValue.tag_OctetString, octets);\n@@ -298,1 +309,1 @@\n-    public void putNull() throws IOException {\n+    public DerOutputStream putNull() throws IOException {\n@@ -301,0 +312,1 @@\n+        return this;\n@@ -307,1 +319,1 @@\n-    public void putOID(ObjectIdentifier oid) throws IOException {\n+    public DerOutputStream putOID(ObjectIdentifier oid) throws IOException {\n@@ -309,0 +321,1 @@\n+        return this;\n@@ -316,1 +329,1 @@\n-    public void putSequence(DerValue[] seq) throws IOException {\n+    public DerOutputStream putSequence(DerValue[] seq) throws IOException {\n@@ -323,1 +336,1 @@\n-        write(DerValue.tag_Sequence, bytes);\n+        return write(DerValue.tag_Sequence, bytes);\n@@ -333,1 +346,1 @@\n-    public void putSet(DerValue[] set) throws IOException {\n+    public DerOutputStream putSet(DerValue[] set) throws IOException {\n@@ -340,1 +353,1 @@\n-        write(DerValue.tag_Set, bytes);\n+        return write(DerValue.tag_Set, bytes);\n@@ -353,2 +366,2 @@\n-    public void putOrderedSetOf(byte tag, DerEncoder[] set) throws IOException {\n-        putOrderedSet(tag, set, lexOrder);\n+    public DerOutputStream putOrderedSetOf(byte tag, DerEncoder[] set) throws IOException {\n+        return putOrderedSet(tag, set, lexOrder);\n@@ -367,2 +380,2 @@\n-    public void putOrderedSet(byte tag, DerEncoder[] set) throws IOException {\n-        putOrderedSet(tag, set, tagOrder);\n+    public DerOutputStream putOrderedSet(byte tag, DerEncoder[] set) throws IOException {\n+        return putOrderedSet(tag, set, tagOrder);\n@@ -389,1 +402,1 @@\n-    private void putOrderedSet(byte tag, DerEncoder[] set,\n+    private DerOutputStream putOrderedSet(byte tag, DerEncoder[] set,\n@@ -409,2 +422,1 @@\n-        write(tag, bytes);\n-\n+        return write(tag, bytes);\n@@ -416,2 +428,2 @@\n-    public void putUTF8String(String s) throws IOException {\n-        writeString(s, DerValue.tag_UTF8String, UTF_8);\n+    public DerOutputStream putUTF8String(String s) throws IOException {\n+        return writeString(s, DerValue.tag_UTF8String, UTF_8);\n@@ -423,2 +435,2 @@\n-    public void putPrintableString(String s) throws IOException {\n-        writeString(s, DerValue.tag_PrintableString, US_ASCII);\n+    public DerOutputStream putPrintableString(String s) throws IOException {\n+        return writeString(s, DerValue.tag_PrintableString, US_ASCII);\n@@ -430,1 +442,1 @@\n-    public void putT61String(String s) throws IOException {\n+    public DerOutputStream putT61String(String s) throws IOException {\n@@ -435,1 +447,1 @@\n-        writeString(s, DerValue.tag_T61String, ISO_8859_1);\n+        return writeString(s, DerValue.tag_T61String, ISO_8859_1);\n@@ -441,2 +453,2 @@\n-    public void putIA5String(String s) throws IOException {\n-        writeString(s, DerValue.tag_IA5String, US_ASCII);\n+    public DerOutputStream putIA5String(String s) throws IOException {\n+        return writeString(s, DerValue.tag_IA5String, US_ASCII);\n@@ -448,2 +460,2 @@\n-    public void putBMPString(String s) throws IOException {\n-        writeString(s, DerValue.tag_BMPString, UTF_16BE);\n+    public DerOutputStream putBMPString(String s) throws IOException {\n+        return writeString(s, DerValue.tag_BMPString, UTF_16BE);\n@@ -455,2 +467,2 @@\n-    public void putGeneralString(String s) throws IOException {\n-        writeString(s, DerValue.tag_GeneralString, US_ASCII);\n+    public DerOutputStream putGeneralString(String s) throws IOException {\n+        return writeString(s, DerValue.tag_GeneralString, US_ASCII);\n@@ -467,1 +479,1 @@\n-    private void writeString(String s, byte stringTag, Charset charset)\n+    private DerOutputStream writeString(String s, byte stringTag, Charset charset)\n@@ -474,0 +486,1 @@\n+        return this;\n@@ -482,2 +495,2 @@\n-    public void putUTCTime(Date d) throws IOException {\n-        putTime(d, DerValue.tag_UtcTime);\n+    public DerOutputStream putUTCTime(Date d) throws IOException {\n+        return putTime(d, DerValue.tag_UtcTime);\n@@ -492,2 +505,2 @@\n-    public void putGeneralizedTime(Date d) throws IOException {\n-        putTime(d, DerValue.tag_GeneralizedTime);\n+    public DerOutputStream putGeneralizedTime(Date d) throws IOException {\n+        return putTime(d, DerValue.tag_GeneralizedTime);\n@@ -503,1 +516,1 @@\n-    private void putTime(Date d, byte tag) throws IOException {\n+    private DerOutputStream putTime(Date d, byte tag) throws IOException {\n@@ -530,0 +543,1 @@\n+        return this;\n@@ -566,17 +580,0 @@\n-    \/**\n-     * Put the tag of the attribute in the stream.\n-     *\n-     * @param tagClass the tag class type, one of UNIVERSAL, CONTEXT,\n-     *        APPLICATION or PRIVATE\n-     * @param form if true, the value is constructed, otherwise it is\n-     * primitive.\n-     * @param val the tag value\n-     *\/\n-    public void putTag(byte tagClass, boolean form, byte val) {\n-        byte tag = (byte)(tagClass | val);\n-        if (form) {\n-            tag |= (byte)0x20;\n-        }\n-        write(tag);\n-    }\n-\n@@ -593,0 +590,10 @@\n+    \/**\n+     * Write a DerEncoder onto the output stream.\n+     * @param encoder the DerEncoder\n+     * @throws IOException on output error\n+     *\/\n+    public DerOutputStream write(DerEncoder encoder) throws IOException {\n+        encoder.derEncode(this);\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DerOutputStream.java","additions":73,"deletions":66,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,0 +350,35 @@\n+    \/\/ Partial Public key validation as described in NIST SP 800-186 Appendix D.1.1.1.\n+    \/\/ The extra step in the full validation (described in Appendix D.1.1.2) is implemented\n+    \/\/ as sun.security.ec.ECOperations#checkOrder inside the jdk.crypto.ec module.\n+    public static void validatePublicKey(ECPoint point, ECParameterSpec spec)\n+            throws InvalidKeyException {\n+        BigInteger p;\n+        if (spec.getCurve().getField() instanceof ECFieldFp f) {\n+            p = f.getP();\n+        } else {\n+            throw new InvalidKeyException(\"Only curves over prime fields are supported\");\n+        }\n+\n+        \/\/ 1. If Q is the point at infinity, output REJECT\n+        if (point.equals(ECPoint.POINT_INFINITY)) {\n+            throw new InvalidKeyException(\"Public point is at infinity\");\n+        }\n+        \/\/ 2. Verify that x and y are integers in the interval [0, p-1]. Output REJECT if verification fails.\n+        BigInteger x = point.getAffineX();\n+        if (x.signum() < 0 || x.compareTo(p) >= 0) {\n+            throw new InvalidKeyException(\"Public point x is not in the interval [0, p-1]\");\n+        }\n+        BigInteger y = point.getAffineY();\n+        if (y.signum() < 0 || y.compareTo(p) >= 0) {\n+            throw new InvalidKeyException(\"Public point y is not in the interval [0, p-1]\");\n+        }\n+        \/\/ 3. Verify that (x, y) is a point on the W_a,b by checking that (x, y) satisfies the defining\n+        \/\/ equation y^2 = x^3 + a x + b where computations are carried out in GF(p). Output REJECT\n+        \/\/ if verification fails.\n+        BigInteger left = y.modPow(BigInteger.TWO, p);\n+        BigInteger right = x.pow(3).add(spec.getCurve().getA().multiply(x)).add(spec.getCurve().getB()).mod(p);\n+        if (!left.equals(right)) {\n+            throw new InvalidKeyException(\"Public point is not on the curve\");\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ECUtil.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -332,1 +332,2 @@\n-        BigInteger mod = BigInteger.valueOf(1 << bitsPerLimb);\n+        assert bitsPerLimb < 32;\n+        long limbMask = (1L << bitsPerLimb) - 1;\n@@ -334,1 +335,1 @@\n-            limbs[i] = v.mod(mod).longValue();\n+            limbs[i] = v.intValue() & limbMask;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -497,1 +497,1 @@\n-        int  d1, d2, d3, d4;\n+        int  d1, d2, d3;\n@@ -510,1 +510,0 @@\n-            d4 = (d3 % 365) + 1;\n@@ -520,1 +519,0 @@\n-            d4 = CalendarUtils.mod(d3, 365) + 1;\n","filename":"src\/java.base\/share\/classes\/sun\/util\/calendar\/BaseCalendar.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.util.StaticProperty;\n@@ -37,1 +38,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -104,0 +104,2 @@\n+     * The system property \"java.locale.useOldISOCodes\" is not security sensitive,\n+     * so no need to ensure privileged access here.\n@@ -105,2 +107,1 @@\n-    private static final boolean OLD_ISO_CODES = GetPropertyAction.privilegedGetProperties()\n-            .getProperty(\"java.locale.useOldISOCodes\", \"false\")\n+    private static final boolean OLD_ISO_CODES = StaticProperty.javaLocaleUseOldISOCodes()\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1379,1 +1379,1 @@\n-# JNDI Object Factories Filter\n+# Global JNDI Object Factories Filter\n@@ -1385,1 +1385,2 @@\n-# with the same format as jdk.serialFilter.\n+# with the same format as jdk.serialFilter. Limit patterns specified in the filter property\n+# are unused.\n@@ -1387,3 +1388,3 @@\n-# Each pattern is matched against the factory class name to allow or disallow it's\n-# instantiation. The access to a factory class is allowed unless the filter returns\n-# REJECTED.\n+# Each class name pattern is matched against the factory class name to allow or disallow its\n+# instantiation. The access to a factory class is allowed if the filter returns\n+# ALLOWED.\n@@ -1401,0 +1402,52 @@\n+#\n+# Protocol Specific JNDI\/LDAP Object Factories Filter\n+#\n+# This filter is used by the JNDI\/LDAP provider implementation in the JDK to further control the\n+# set of object factory classes which will be allowed to instantiate objects from object\n+# references bound to LDAP contexts. The factory class named by the reference instance will\n+# be matched against this filter. The filter property supports pattern-based filter syntax\n+# with the same format as jdk.serialFilter. Limit patterns specified in the filter property\n+# are unused.\n+#\n+# Each class name pattern is matched against the factory class name to allow or disallow its\n+# instantiation. The access to a factory class is allowed only when it is not rejected by this filter\n+# or by the global filter defined by \"jdk.jndi.object.factoriesFilter\", and at least one of these\n+# two filters returns ALLOWED.\n+#\n+# Note: This property is currently used by the JDK Reference implementation.\n+# It is not guaranteed to be examined and used by other implementations.\n+#\n+# If the system property jdk.jndi.ldap.object.factoriesFilter is also specified, it supersedes\n+# the security property value defined here. The default value of the property is\n+# \"java.naming\/com.sun.jndi.ldap.**;!*\".\n+#\n+# The default pattern value allows any object factory class defined in the java.naming module\n+# to be specified by the reference instance, but rejects any other.\n+#jdk.jndi.ldap.object.factoriesFilter=java.naming\/com.sun.jndi.ldap.**;!*\n+\n+#\n+# Protocol Specific JNDI\/RMI Object Factories Filter\n+#\n+# This filter is used by the JNDI\/RMI provider implementation in the JDK to further control the\n+# set of object factory classes which will be allowed to instantiate objects from object\n+# references bound to RMI names. The factory class named by the reference instance will\n+# be matched against this filter. The filter property supports pattern-based filter syntax\n+# with the same format as jdk.serialFilter. Limit patterns specified in the filter property\n+# are unused.\n+#\n+# Each class name pattern is matched against the factory class name to allow or disallow its\n+# instantiation. The access to a factory class is allowed only when it is not rejected by this filter\n+# or by the global filter defined by \"jdk.jndi.object.factoriesFilter\", and at least one of these\n+# two filters returns ALLOWED.\n+#\n+# Note: This property is currently used by the JDK Reference implementation.\n+# It is not guaranteed to be examined and used by other implementations.\n+#\n+# If the system property jdk.jndi.rmi.object.factoriesFilter is also specified, it supersedes\n+# the security property value defined here. The default value of the property is\n+# \"jdk.naming.rmi\/com.sun.jndi.rmi.**;!*\".\n+#\n+# The default pattern value allows any object factory class defined in the jdk.naming.rmi module\n+# to be specified by the reference instance, but rejects any other.\n+#jdk.jndi.rmi.object.factoriesFilter=jdk.naming.rmi\/com.sun.jndi.rmi.**;!*\n+\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":58,"deletions":5,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2022d\n+tzdata2022e\n","filename":"src\/java.base\/share\/data\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2257,0 +2257,11 @@\n+# From Issam Al-Zuwairi (2022-10-05):\n+# The Council of Ministers in Jordan decided Wednesday 5th October 2022,\n+# that daylight saving time (DST) will be throughout the year....\n+#\n+# From Brian Inglis (2022-10-06):\n+# https:\/\/petra.gov.jo\/Include\/InnerPage.jsp?ID=45567&lang=en&name=en_news\n+#\n+# From Paul Eggert (2022-10-05):\n+# Like Syria, model this as a transition from EEST +03 (DST) to plain +03\n+# (non-DST) at the point where DST would otherwise have ended.\n+\n@@ -2288,2 +2299,2 @@\n-Rule\tJordan\t2014\tmax\t-\tOct\tlastFri\t0:00s\t0\t-\n-Rule\tJordan\t2022\tmax\t-\tFeb\tlastThu\t24:00\t1:00\tS\n+Rule\tJordan\t2014\t2022\t-\tOct\tlastFri\t0:00s\t0\t-\n+Rule\tJordan\t2022\tonly\t-\tFeb\tlastThu\t24:00\t1:00\tS\n@@ -2292,1 +2303,2 @@\n-\t\t\t2:00\tJordan\tEE%sT\n+\t\t\t2:00\tJordan\tEE%sT\t2022 Oct 28 0:00s\n+\t\t\t3:00\t-\t+03\n@@ -3841,2 +3853,9 @@\n-# From Arthur David Olson (2012-03-27):\n-# Assume last Friday in March going forward XXX.\n+# From Steffen Thorsen (2022-10-05):\n+# Syria is adopting year-round DST, starting this autumn....\n+# From https:\/\/www.enabbaladi.net\/archives\/607812\n+# \"This [the decision] came after the weekly government meeting today,\n+# Tuesday 4 October ...\"\n+#\n+# From Paul Eggert (2022-10-05):\n+# Like Jordan, model this as a transition from EEST +03 (DST) to plain +03\n+# (non-DST) at the point where DST would otherwise have ended.\n@@ -3848,2 +3867,2 @@\n-Rule\tSyria\t2012\tmax\t-\tMar\tlastFri\t0:00\t1:00\tS\n-Rule\tSyria\t2009\tmax\t-\tOct\tlastFri\t0:00\t0\t-\n+Rule\tSyria\t2012\t2022\t-\tMar\tlastFri\t0:00\t1:00\tS\n+Rule\tSyria\t2009\t2022\t-\tOct\tlastFri\t0:00\t0\t-\n@@ -3853,1 +3872,2 @@\n-\t\t\t2:00\tSyria\tEE%sT\n+\t\t\t2:00\tSyria\tEE%sT\t2022 Oct 28 0:00\n+\t\t\t3:00\t-\t+03\n","filename":"src\/java.base\/share\/data\/tzdata\/asia","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3420,1 +3420,1 @@\n-Zone\tAfrica\/Ceuta\t-0:21:16 -\tLMT\t1900 Dec 31 23:38:44\n+Zone\tAfrica\/Ceuta\t-0:21:16 -\tLMT\t1901 Jan  1  0:00u\n","filename":"src\/java.base\/share\/data\/tzdata\/europe","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-Zone America\/Chicago\t-5:50:36 -\tLMT\t1883 Nov 18 12:09:24\n+Zone America\/Chicago\t-5:50:36 -\tLMT\t1883 Nov 18 18:00u\n@@ -474,1 +474,1 @@\n-Zone America\/North_Dakota\/Center -6:45:12 - LMT\t1883 Nov 18 12:14:48\n+Zone America\/North_Dakota\/Center -6:45:12 - LMT\t1883 Nov 18 19:00u\n@@ -484,1 +484,1 @@\n-Zone America\/North_Dakota\/New_Salem -6:45:39 - LMT\t1883 Nov 18 12:14:21\n+Zone America\/North_Dakota\/New_Salem -6:45:39 - LMT 1883 Nov 18 19:00u\n@@ -501,1 +501,1 @@\n-Zone America\/North_Dakota\/Beulah -6:47:07 - LMT\t1883 Nov 18 12:12:53\n+Zone America\/North_Dakota\/Beulah -6:47:07 - LMT\t1883 Nov 18 19:00u\n@@ -533,1 +533,1 @@\n-Zone America\/Denver\t-6:59:56 -\tLMT\t1883 Nov 18 12:00:04\n+Zone America\/Denver\t-6:59:56 -\tLMT\t1883 Nov 18 19:00u\n@@ -586,1 +586,1 @@\n-Zone America\/Los_Angeles -7:52:58 -\tLMT\t1883 Nov 18 12:07:02\n+Zone America\/Los_Angeles -7:52:58 -\tLMT\t1883 Nov 18 20:00u\n@@ -848,1 +848,1 @@\n-Zone America\/Phoenix\t-7:28:18 -\tLMT\t1883 Nov 18 11:31:42\n+Zone America\/Phoenix\t-7:28:18 -\tLMT\t1883 Nov 18 19:00u\n@@ -876,1 +876,1 @@\n-Zone America\/Boise\t-7:44:49 -\tLMT\t1883 Nov 18 12:15:11\n+Zone America\/Boise\t-7:44:49 -\tLMT\t1883 Nov 18 20:00u\n@@ -948,1 +948,1 @@\n-Zone America\/Indiana\/Indianapolis -5:44:38 - LMT\t1883 Nov 18 12:15:22\n+Zone America\/Indiana\/Indianapolis -5:44:38 - LMT 1883 Nov 18 18:00u\n@@ -968,1 +968,1 @@\n-Zone America\/Indiana\/Marengo -5:45:23 -\tLMT\t1883 Nov 18 12:14:37\n+Zone America\/Indiana\/Marengo -5:45:23 -\tLMT\t1883 Nov 18 18:00u\n@@ -992,1 +992,1 @@\n-Zone America\/Indiana\/Vincennes -5:50:07 - LMT\t1883 Nov 18 12:09:53\n+Zone America\/Indiana\/Vincennes -5:50:07 - LMT\t1883 Nov 18 18:00u\n@@ -1012,1 +1012,1 @@\n-Zone America\/Indiana\/Tell_City -5:47:03 - LMT\t1883 Nov 18 12:12:57\n+Zone America\/Indiana\/Tell_City -5:47:03 - LMT\t1883 Nov 18 18:00u\n@@ -1029,1 +1029,1 @@\n-Zone America\/Indiana\/Petersburg -5:49:07 - LMT\t1883 Nov 18 12:10:53\n+Zone America\/Indiana\/Petersburg -5:49:07 - LMT\t1883 Nov 18 18:00u\n@@ -1051,1 +1051,1 @@\n-Zone America\/Indiana\/Knox -5:46:30 -\tLMT\t1883 Nov 18 12:13:30\n+Zone America\/Indiana\/Knox -5:46:30 -\tLMT\t1883 Nov 18 18:00u\n@@ -1067,1 +1067,1 @@\n-Zone America\/Indiana\/Winamac -5:46:25 - LMT\t1883 Nov 18 12:13:35\n+Zone America\/Indiana\/Winamac -5:46:25 - LMT\t1883 Nov 18 18:00u\n@@ -1078,1 +1078,1 @@\n-Zone America\/Indiana\/Vevay -5:40:16 -\tLMT\t1883 Nov 18 12:19:44\n+Zone America\/Indiana\/Vevay -5:40:16 -\tLMT\t1883 Nov 18 18:00u\n@@ -1114,1 +1114,1 @@\n-Zone America\/Kentucky\/Louisville -5:43:02 -\tLMT\t1883 Nov 18 12:16:58\n+Zone America\/Kentucky\/Louisville -5:43:02 - LMT\t1883 Nov 18 18:00u\n@@ -1148,1 +1148,1 @@\n-Zone America\/Kentucky\/Monticello -5:39:24 - LMT\t1883 Nov 18 12:20:36\n+Zone America\/Kentucky\/Monticello -5:39:24 - LMT\t1883 Nov 18 18:00u\n@@ -2643,0 +2643,2 @@\n+Rule\tMexico\t1931\tonly\t-\tMay\t1\t23:00\t1:00\tD\n+Rule\tMexico\t1931\tonly\t-\tOct\t1\t0:00\t0\tS\n@@ -2659,1 +2661,1 @@\n-Zone America\/Cancun\t-5:47:04 -\tLMT\t1922 Jan  1  0:12:56\n+Zone America\/Cancun\t-5:47:04 -\tLMT\t1922 Jan  1  6:00u\n@@ -2665,1 +2667,1 @@\n-Zone America\/Merida\t-5:58:28 -\tLMT\t1922 Jan  1  0:01:32\n+Zone America\/Merida\t-5:58:28 -\tLMT\t1922 Jan  1  6:00u\n@@ -2679,1 +2681,1 @@\n-Zone America\/Matamoros\t-6:40:00 -\tLMT\t1921 Dec 31 23:20:00\n+Zone America\/Matamoros\t-6:30:00 -\tLMT\t1922 Jan  1  6:00u\n@@ -2685,1 +2687,1 @@\n-Zone America\/Monterrey\t-6:41:16 -\tLMT\t1921 Dec 31 23:18:44\n+Zone America\/Monterrey\t-6:41:16 -\tLMT\t1922 Jan  1  6:00u\n@@ -2690,1 +2692,1 @@\n-Zone America\/Mexico_City -6:36:36 -\tLMT\t1922 Jan  1  0:23:24\n+Zone America\/Mexico_City -6:36:36 -\tLMT\t1922 Jan  1  7:00u\n@@ -2693,3 +2695,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2703,1 +2703,1 @@\n-Zone America\/Ojinaga\t-6:57:40 -\tLMT\t1922 Jan  1  0:02:20\n+Zone America\/Ojinaga\t-6:57:40 -\tLMT\t1922 Jan  1  7:00u\n@@ -2706,3 +2706,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2715,1 +2713,1 @@\n-Zone America\/Chihuahua\t-7:04:20 -\tLMT\t1921 Dec 31 23:55:40\n+Zone America\/Chihuahua\t-7:04:20 -\tLMT\t1922 Jan  1  7:00u\n@@ -2718,3 +2716,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2726,1 +2722,1 @@\n-Zone America\/Hermosillo\t-7:23:52 -\tLMT\t1921 Dec 31 23:36:08\n+Zone America\/Hermosillo\t-7:23:52 -\tLMT\t1922 Jan  1  7:00u\n@@ -2729,3 +2725,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2766,1 +2760,1 @@\n-Zone America\/Mazatlan\t-7:05:40 -\tLMT\t1921 Dec 31 23:54:20\n+Zone America\/Mazatlan\t-7:05:40 -\tLMT\t1922 Jan  1  7:00u\n@@ -2769,3 +2763,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2778,1 +2770,1 @@\n-Zone America\/Bahia_Banderas\t-7:01:00 -\tLMT\t1921 Dec 31 23:59:00\n+Zone America\/Bahia_Banderas -7:01:00 -\tLMT\t1922 Jan  1  7:00u\n@@ -2781,3 +2773,1 @@\n-\t\t\t-7:00\t-\tMST\t1931 May  1 23:00\n-\t\t\t-6:00\t-\tCST\t1931 Oct\n-\t\t\t-7:00\t-\tMST\t1932 Apr  1\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2791,1 +2781,1 @@\n-Zone America\/Tijuana\t-7:48:04 -\tLMT\t1922 Jan  1  0:11:56\n+Zone America\/Tijuana\t-7:48:04 -\tLMT\t1922 Jan  1  7:00u\n","filename":"src\/java.base\/share\/data\/tzdata\/northamerica","additions":37,"deletions":47,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -20,1 +20,1 @@\n-for the specific language governing rights and limitations under the License. \n+for the specific language governing rights and limitations under the License.\n@@ -62,1 +62,1 @@\n-    means a work that combines Covered Software with other material, in \n+    means a work that combines Covered Software with other material, in\n","filename":"src\/java.base\/share\/legal\/public_suffix.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-[http:\/\/openjdk.java.net\/jeps\/330] for complete details.\n+[https:\/\/openjdk.org\/jeps\/330] for complete details.\n@@ -4114,2 +4114,1 @@\n-261\\f[R]\n-[https:\/\/openjdk.java.net\/jeps\/261#Relaxed\\-strong\\-encapsulation].\n+261\\f[R] [https:\/\/openjdk.org\/jeps\/261#Relaxed\\-strong\\-encapsulation].\n@@ -4117,2 +4116,2 @@\n-[https:\/\/openjdk.java.net\/jeps\/396] and made obsolete in JDK 17 by\n-\\f[B]JEP 403\\f[R] [https:\/\/openjdk.java.net\/jeps\/403].\n+[https:\/\/openjdk.org\/jeps\/396] and made obsolete in JDK 17 by \\f[B]JEP\n+403\\f[R] [https:\/\/openjdk.org\/jeps\/403].\n@@ -4395,1 +4394,1 @@\n-[https:\/\/bugs.openjdk.java.net\/secure\/attachment\/75649\/JVM_CodeHeap_StateAnalytics_V2.pdf]\n+[https:\/\/bugs.openjdk.org\/secure\/attachment\/75649\/JVM_CodeHeap_StateAnalytics_V2.pdf]\n","filename":"src\/java.base\/share\/man\/java.1","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -102,4 +102,4 @@\n-                p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));\n-                q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));\n-                w = p\/q;\n-                return x+x*w;\n+            p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));\n+            q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));\n+            w = p\/q;\n+            return x+x*w;\n","filename":"src\/java.base\/share\/native\/libfdlibm\/e_asin.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -200,1 +200,2 @@\n-            for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j]; q[i] = fw;\n+            for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];\n+            q[i] = fw;\n","filename":"src\/java.base\/share\/native\/libfdlibm\/k_rem_pio2.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+#define JLI_Snprintf            snprintf\n+\n@@ -91,1 +93,0 @@\n-int JLI_Snprintf(char *buffer, size_t size, const char *format, ...);\n@@ -101,1 +102,0 @@\n-#define JLI_Snprintf                    snprintf\n","filename":"src\/java.base\/share\/native\/libjli\/jli_util.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -561,1 +561,1 @@\n-                        } else if (buildNumber > 17676) {\n+                        } else if (buildNumber > 17762) {\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,32 +478,0 @@\n-\/*\n- * windows snprintf does not guarantee a null terminator in the buffer,\n- * if the computed size is equal to or greater than the buffer size,\n- * as well as error conditions. This function guarantees a null terminator\n- * under all these conditions. An unreasonable buffer or size will return\n- * an error value. Under all other conditions this function will return the\n- * size of the bytes actually written minus the null terminator, similar\n- * to ansi snprintf api. Thus when calling this function the caller must\n- * ensure storage for the null terminator.\n- *\/\n-int\n-JLI_Snprintf(char* buffer, size_t size, const char* format, ...) {\n-    int rc;\n-    va_list vl;\n-    if (size == 0 || buffer == NULL)\n-        return -1;\n-    buffer[0] = '\\0';\n-    va_start(vl, format);\n-    rc = vsnprintf(buffer, size, format, vl);\n-    va_end(vl);\n-    \/* force a null terminator, if something is amiss *\/\n-    if (rc < 0) {\n-        \/* apply ansi semantics *\/\n-        buffer[size - 1] = '\\0';\n-        return (int)size;\n-    } else if (rc == size) {\n-        \/* force a null terminator *\/\n-        buffer[size - 1] = '\\0';\n-    }\n-    return rc;\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libjli\/java_md.c","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -37,2 +37,1 @@\n-#include <Mswsock.h>\n-#pragma comment(lib, \"Mswsock.lib\")\n+#include <Mswsock.h> \/\/ Requires Mswsock.lib\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-           the previous focused compoent which is A, then endComposition is called on A,\n+           the previous focused component which is A, then endComposition is called on A,\n@@ -469,1 +469,1 @@\n-           Use package private mthod 'resetCompositionState' if you want the\n+           Use package private method 'resetCompositionState' if you want the\n","filename":"src\/java.desktop\/aix\/classes\/sun\/awt\/X11InputMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * This is intially based on hotspot\/src\/os\/aix\/vm\/{loadlib,porting}_aix.{hpp,cpp}\n+ * This is initially based on hotspot\/src\/os\/aix\/vm\/{loadlib,porting}_aix.{hpp,cpp}\n@@ -35,1 +35,1 @@\n- * This function tries to mimick dladdr(3) on Linux\n+ * This function tries to mimic dladdr(3) on Linux\n@@ -53,1 +53,1 @@\n-  void *dli_fbase;       \/* doesn't make sence on AIX *\/\n+  void *dli_fbase;       \/* doesn't make sense on AIX *\/\n","filename":"src\/java.desktop\/aix\/native\/libawt\/porting_aix.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -995,1 +995,1 @@\n-    \/\/ The code set the IC mode that the preedit state is not initialied\n+    \/\/ The code set the IC mode that the preedit state is not initialized\n","filename":"src\/java.desktop\/aix\/native\/libawt_xawt\/awt\/awt_InputMethod.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n- * Untill the issue is fixed in ALSA\n+ * Until the issue is fixed in ALSA\n","filename":"src\/java.desktop\/linux\/native\/libjsound\/PLATFORM_API_LinuxOS_ALSA_MidiIn.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-            \/\/ call calback function for the device\n+            \/\/ call callback function for the device\n","filename":"src\/java.desktop\/linux\/native\/libjsound\/PLATFORM_API_LinuxOS_ALSA_MidiUtils.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-                            \/* $$mp 2003-09-14: The following cast shouln't be necessary. Instead, the\n+                            \/* $$mp 2003-09-14: The following cast shouldn't be necessary. Instead, the\n@@ -484,1 +484,1 @@\n-    \/* $$mp 2003-09-14: The following cast shouln't be necessary. Instead, the\n+    \/* $$mp 2003-09-14: The following cast shouldn't be necessary. Instead, the\n","filename":"src\/java.desktop\/linux\/native\/libjsound\/PLATFORM_API_LinuxOS_ALSA_Ports.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -460,1 +460,1 @@\n-     * As of Java 2 platform v 1.4 this method should not be used or overriden.\n+     * As of Java 2 platform v 1.4 this method should not be used or overridden.\n@@ -552,2 +552,2 @@\n-        \/\/ Everytime a hierarchy is change we need to check if the button if moved on or from\n-        \/\/ a toolbar. If that is the case, we need to re-set the border of the button.\n+        \/\/ Every time a hierarchy is changed we need to check if the button is moved on or from\n+        \/\/ the toolbar. If that is the case, we need to re-set the border of the button.\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaButtonUI.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-    \/\/ above elminates the border. Sadly we can't easily change either one, so\n+    \/\/ above eliminates the border. Sadly we can't easily change either one, so\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaCaret.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-     * Hilight _but do not select_ the next item in the list.\n+     * Highlight _but do not select_ the next item in the list.\n@@ -368,1 +368,1 @@\n-     * Hilight _but do not select_ the previous item in the list.\n+     * Highlight _but do not select_ the previous item in the list.\n@@ -473,1 +473,1 @@\n-                        width - (insets.left + insets.right + buttonSize) + 4,\n+                        width - (insets.left + insets.right + buttonSize) + 3,\n@@ -478,1 +478,1 @@\n-                        width - (insets.left + insets.right + buttonSize) + 4,\n+                        width - (insets.left + insets.right + buttonSize) + 3,\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaComboBoxUI.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-     * image that can be streched from its middles.\n+     * image that can be stretched from its middles.\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaImageFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-            \/\/ to front and select it manualy. (vm)\n+            \/\/ to front and select it manually. (vm)\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaInternalFramePaneUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -700,1 +700,1 @@\n-            \/\/ You can additionaly define OptionPane.messageFont which will\n+            \/\/ You can additionally define OptionPane.messageFont which will\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaLookAndFeel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-     * BasicOptionPaneUI expects that its buttons are layed out with\n+     * BasicOptionPaneUI expects that its buttons are laid out with\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaOptionPaneUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -869,1 +869,1 @@\n-    \/\/ Syncronizes the ToolTip text for the components within the spinner\n+    \/\/ Synchronizes the ToolTip text for the components within the spinner\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaSpinnerUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-\/\/ Transient variables (recalculated each time TabbedPane is layed out)\n+\/\/ Transient variables (recalculated each time TabbedPane is laid out)\n@@ -2246,1 +2246,1 @@\n-            \/\/ the visible compnent if the currently selected tab\n+            \/\/ the visible component if the currently selected tab\n@@ -2745,1 +2745,1 @@\n-            \/\/ the visible compnent if the currently selected tab\n+            \/\/ the visible component if the currently selected tab\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaTabbedPaneCopyFromBasicUI.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * insertion caret at the begining of a text field when it gets clicked on.\n+ * insertion caret at the beginning of a text field when it gets clicked on.\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaTextFieldFormattedUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    \/* ToolBarBorder and drag-off handle, based loosly on MetalBumps *\/\n+    \/* ToolBarBorder and drag-off handle, based loosely on MetalBumps *\/\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaToolBarUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-     * Callback from JavaMenuUpdater.m -- called when menu item is hilighted.\n+     * Callback from JavaMenuUpdater.m -- called when menu item is highlighted.\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/ScreenMenu.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-        public synchronized void get(int count, char[] indicies, int[] values)\n+        public synchronized void get(int count, char[] indices, int[] values)\n@@ -233,1 +233,1 @@\n-                int code = indicies[i];\n+                int code = indices[i];\n@@ -237,1 +237,1 @@\n-                    char low = indicies[i + 1];\n+                    char low = indices[i + 1];\n@@ -257,2 +257,2 @@\n-                        unmappedChars = new char[indicies.length];\n-                        unmappedCharIndices = new int[indicies.length];\n+                        unmappedChars = new char[indices.length];\n+                        unmappedCharIndices = new int[indices.length];\n@@ -260,1 +260,1 @@\n-                    unmappedChars[missed] = indicies[i];\n+                    unmappedChars[missed] = indices[i];\n@@ -263,1 +263,1 @@\n-                        unmappedChars[++missed] = indicies[++i];\n+                        unmappedChars[++missed] = indices[++i];\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCharToGlyphMapper.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-     * it all programatically.  The intention is end users will use things\n+     * it all programmatically.  The intention is end users will use things\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CFontConfiguration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-        boolean succeded = false;\n+        boolean succeeded = false;\n@@ -372,1 +372,1 @@\n-                succeded = surfaceData.xorSurfacePixels(sg2d, srcPixels, x, y, w, h, ((XORComposite) composite).getXorColor().getRGB());\n+                succeeded = surfaceData.xorSurfacePixels(sg2d, srcPixels, x, y, w, h, ((XORComposite) composite).getXorColor().getRGB());\n@@ -374,1 +374,1 @@\n-                succeded = false;\n+                succeeded = false;\n@@ -378,1 +378,1 @@\n-        if (succeded == false) {\n+        if (succeeded == false) {\n@@ -388,1 +388,1 @@\n-                    succeded = osxsd.xorSurfacePixels(sg2d, srcPixels, 0, 0, w, h, ((XORComposite) composite).getXorColor().getRGB());\n+                    succeeded = osxsd.xorSurfacePixels(sg2d, srcPixels, 0, 0, w, h, ((XORComposite) composite).getXorColor().getRGB());\n@@ -391,1 +391,1 @@\n-                    succeded = false;\n+                    succeeded = false;\n@@ -396,1 +396,1 @@\n-            if (succeded == false) {\n+            if (succeeded == false) {\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/CompositeCRenderer.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    \/\/ these are for callbacks when pixes have been touched\n+    \/\/ these are for callbacks when pixels have been touched\n@@ -508,1 +508,1 @@\n-        \/\/ we need to substract the transX and transY to move it\n+        \/\/ we need to subtract the transX and transY to move it\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/OSXOffScreenSurfaceData.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -840,1 +840,1 @@\n-    \/\/ the method below is overriden by CPeerSurface to check the last peer used to draw\n+    \/\/ the method below is overridden by CPeerSurface to check the last peer used to draw\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/OSXSurfaceData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-     * requiering when needed (i.e. when the window geometry is changed).\n+     * requerying when needed (i.e. when the window geometry is changed).\n@@ -1370,1 +1370,1 @@\n-            focusLog.fine((becomesFocused?\"gaining\":\"loosing\") + \" focus window: \" + this);\n+            focusLog.fine((becomesFocused?\"gaining\":\"losing\") + \" focus window: \" + this);\n@@ -1408,1 +1408,1 @@\n-            \/\/ late window focus lost event - ingoring\n+            \/\/ late window focus lost event - ignoring\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/LWWindowPeer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-            \/\/ maxosx always returns property list for\n+            \/\/ macosx always returns property list for\n@@ -163,1 +163,1 @@\n-            \/\/ regular string that allows to translate data to target represantation\n+            \/\/ regular string that allows to translate data to target representation\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CDataTransferer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-        \/\/ This code actually works, even under the (non-existant) multiple-selections, because we only draw a union outline\n+        \/\/ This code actually works, even under the (non-existent) multiple-selections, because we only draw a union outline\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CDragSourceContextPeer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    \/\/ handleFocusEvent is called when the applet becames focused\/unfocused.\n+    \/\/ handleFocusEvent is called when the applet becomes focused\/unfocused.\n@@ -126,1 +126,1 @@\n-            \/\/ it won't be invoced if focuse is moved to a html element\n+            \/\/ it won't be invoked if focus is moved to an html element\n@@ -178,1 +178,1 @@\n-        \/\/ If globalFocusedWindow is located at inactive parent window or null, we have swithed to\n+        \/\/ If globalFocusedWindow is located at inactive parent window or null, we have switched to\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CEmbeddedFrame.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-     * recomended to not use any external lock in action. If the current\n+     * recommended to not use any external lock in action. If the current\n@@ -145,1 +145,1 @@\n-     * recomended to not use any external lock in action. If the current\n+     * recommended to not use any external lock in action. If the current\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CFRetainedResource.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-     * enabled for the focussed component, incoming events of certain types\n+     * enabled for the focused component, incoming events of certain types\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CInputMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,8 @@\n+        if ((jeventType == MouseEvent.MOUSE_PRESSED) && (jbuttonNumber > MouseEvent.NOBUTTON)) {\n+            \/\/ 8294426: NSEvent.nsToJavaModifiers returns 0 on M2 MacBooks if the event is generated\n+            \/\/  via tapping (not pressing) on a trackpad\n+            \/\/  (System Preferences -> Trackpad -> Tap to click must be turned on).\n+            \/\/ So let's set the modifiers manually.\n+            jmodifiers |= MouseEvent.getMaskForButton(jbuttonNumber);\n+        }\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformResponder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-    \/\/ Loger to report issues happened during execution but that do not affect functionality\n+    \/\/ Logger to report issues happened during execution but that do not affect functionality\n@@ -1109,1 +1109,1 @@\n-        \/\/ Fix for 7150349: ingore \"gained\" notifications when the app is inactive.\n+        \/\/ Fix for 7150349: ignore \"gained\" notifications when the app is inactive.\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformWindow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-    \/\/ TODO: need consitent way for doing that both with global as well as with local coordinates.\n+    \/\/ TODO: need consistent way for doing that both with global as well as with local coordinates.\n@@ -1053,1 +1053,1 @@\n-    \/\/ style and color to determine what kind of Java hilighting needs to be done.\n+    \/\/ style and color to determine what kind of Java highlighting needs to be done.\n@@ -1264,1 +1264,1 @@\n-\/* This method returns the first frame of rects for theRange in screen coordindate system.\n+\/* This method returns the first frame of rects for theRange in screen coordinate system.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTView.m","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -552,1 +552,1 @@\n-\/\/ Orders window's childs based on the current focus state\n+\/\/ Orders window children based on the current focus state\n@@ -688,1 +688,1 @@\n-\/\/ Hides\/shows window's childs during iconify\/de-iconify operation\n+\/\/ Hides\/shows window children during iconify\/de-iconify operation\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTWindow.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    \/\/ This byzantine workaround is necesary, or else directories won't open in Finder\n+    \/\/ This byzantine workaround is necessary, or else directories won't open in Finder\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CDesktopPeer.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -559,1 +559,1 @@\n-        \/\/ Drag success must acount for DragOperationNone:\n+        \/\/ Drag success must account for DragOperationNone:\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CDragSource.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * Convert the mode string to the more convinient bits per pixel value\n+ * Convert the mode string to the more convenient bits per pixel value\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CGraphicsDevice.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-\/\/  Native side of the Quartz text pipe, paints on Quartz Surface Datas.\n+\/\/  Native side of the Quartz text pipe, paints on Quartz Surface Data.\n@@ -318,1 +318,1 @@\n-    aquiring transform arrays from JNI, filling buffers, or striking glyphs. All resources or memory\n+    acquiring transform arrays from JNI, filling buffers, or striking glyphs. All resources or memory\n@@ -320,1 +320,1 @@\n-    is to be handled in the stage it occurs in, and is to return immediatly after freeing it's resources.\n+    is to be handled in the stage it occurs in, and is to return immediately after freeing its resources.\n@@ -414,1 +414,1 @@\n-\/\/ already caculated from GlyphVector, or we simply ask Core Graphics to make some advances for us. Pre-calculated positions\n+\/\/ already calculated from GlyphVector, or we simply ask Core Graphics to make some advances for us. Pre-calculated positions\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CTextPipe.m","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-\/\/ Global debugging flag (for drag-and-drop) - this can be overriden locally per file:\n+\/\/ Global debugging flag (for drag-and-drop) - this can be overridden locally per file:\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/DnDUtilities.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    \/\/ Used as a cached image ref created from the isdo.dataprovider. This is only a chached image, and it might become invalid\n+    \/\/ Used as a cached image ref created from the isdo.dataprovider. This is only a cached image, and it might become invalid\n@@ -98,1 +98,1 @@\n-    \/\/ Cached instance of CGDataProvider. dataProvider is alloced the first time a bitmap context is created, providing the\n+    \/\/ Cached instance of CGDataProvider. dataProvider is allocated the first time a bitmap context is created, providing the\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/ImageSurfaceData.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -770,1 +770,1 @@\n-\/\/ 3. go through the color table and calculate Euclidian distance between the true color and the indexed colors\n+\/\/ 3. go through the color table and calculate Euclidean distance between the true color and the indexed colors\n@@ -1025,1 +1025,1 @@\n-            size_t extraBytesPerRow = 0; \/\/ these are the extra bytesPerRow used for alignement\n+            size_t extraBytesPerRow = 0; \/\/ these are the extra bytesPerRow used for alignment\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/ImageSurfaceData.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-    \/\/ to produce a good hash key. After some analysis, it looks like Thomas's Wang integer hasing algorithm\n-    \/\/ seems a nice trade off between performance and effectivness.\n+    \/\/ to produce a good hash key. After some analysis, it looks like Thomas's Wang integer hashing algorithm\n+    \/\/ seems a nice trade-off between performance and effectiveness.\n@@ -687,1 +687,1 @@\n-                \/\/ We need to flip both y coefficeints to flip the offset point into the java coordinate system.\n+                \/\/ We need to flip both y coefficients to flip the offset point into the java coordinate system.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/QuartzSurfaceData.m","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-#pragma mark --- Canvas Managment ---\n+#pragma mark --- Canvas Management ---\n@@ -731,1 +731,1 @@\n-#pragma mark --- GlyphInfo Filling and Canvas Managment ---\n+#pragma mark --- GlyphInfo Filling and Canvas Management ---\n@@ -840,1 +840,1 @@\n- * expectations in the Sun text rasterizer memory managment code.\n+ * expectations in the Sun text rasterizer memory management code.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CGGlyphImages.m","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -768,1 +768,1 @@\n-                \/\/ Note : pDst is already addjusted for offsets using PtrAddBytes above\n+                \/\/ Note : pDst is already adjusted for offsets using PtrAddBytes above\n@@ -836,1 +836,1 @@\n-             * performing copyArea, thats why we use drawTex2Tex and\n+             * performing copyArea, that's why we use drawTex2Tex and\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLBlitLoops.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    \/\/ It is guranteed that metal supported GPU is available macOS 10.14 onwards\n+    \/\/ It is guaranteed that metal supported GPU is available since macOS 10.14\n@@ -138,1 +138,1 @@\n-            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_getMTLConfigInfo: could not initialze MTLContext.\");\n+            J2dRlsTraceLn(J2D_TRACE_ERROR, \"MTLGraphicsConfig_getMTLConfigInfo: could not initialize MTLContext.\");\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLGraphicsConfig.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                    \"MTLLayer.blitTexture: uninitialized (mtlc=%p, javaLayer=%p, buffer=%p, devide=%p)\", self.ctx,\n+                    \"MTLLayer.blitTexture: uninitialized (mtlc=%p, javaLayer=%p, buffer=%p, device=%p)\", self.ctx,\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLLayer.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -949,1 +949,1 @@\n- * commit earlier encoded commmands\n+ * commit earlier encoded commands\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderQueue.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -539,1 +539,1 @@\n-    \/\/ This buffer is resued multiple times to encode draw calls of a triangle list\n+    \/\/ This buffer is reused multiple times to encode draw calls of a triangle list\n@@ -557,1 +557,1 @@\n-    \/\/ This is the max no of vertices (of struct Vertex - 8 bytes) we can accomodate in 4KB\n+    \/\/ This is the max no of vertices (of struct Vertex - 8 bytes) we can accommodate in 4KB\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderer.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-        \/\/ cases we are creating seperate tile and scan the source\n+        \/\/ cases we are creating a separate tile and scan the source\n@@ -258,1 +258,1 @@\n-        \/\/ can update source pointers, in case of D3D we ar doing memcpy.\n+        \/\/ can update source pointers, in case of D3D we are doing memcpy.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLVertexCache.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-\/\/ Utility struct to transfer rendering paramenters\n+\/\/ Utility struct to transfer rendering parameters\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/RenderOptions.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    \/\/ $$fb 2002-04-04: It is responsability of the application developer to\n+    \/\/ $$fb 2002-04-04: It is the responsibility of the application developer to\n","filename":"src\/java.desktop\/macosx\/native\/libjsound\/PLATFORM_API_MacOSX_MidiOut.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-                        \"Attempt to close a non-existant connection.\";\n+                        \"Attempt to close a non-existent connection.\";\n","filename":"src\/java.desktop\/macosx\/native\/libjsound\/PLATFORM_API_MacOSX_MidiUtils.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-            UTIL_IsBigEndianPlatform());    \/\/ native endianess\n+            UTIL_IsBigEndianPlatform());    \/\/ native endianness\n@@ -851,1 +851,1 @@\n-            \/\/ request HAL for Float32 with native endianess\n+            \/\/ request HAL for Float32 with native endianness\n","filename":"src\/java.desktop\/macosx\/native\/libjsound\/PLATFORM_API_MacOSX_PCM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-        \/\/      Loos like the splash->screenData contains inappropriate data\n+        \/\/      Looks like the splash->screenData contains inappropriate data\n","filename":"src\/java.desktop\/macosx\/native\/libsplashscreen\/splashscreen_sys.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-     * if the lentgh attribute is set.\n+     * if the length attribute is set.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/decoder\/ArrayElementHandler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-     * Returns the array of readed objects.\n+     * Returns the array of read objects.\n@@ -235,1 +235,1 @@\n-     * @return the array of readed objects\n+     * @return the array of read objects\n@@ -242,1 +242,1 @@\n-     * Adds the object to the list of readed objects.\n+     * Adds the object to the list of read objects.\n@@ -244,1 +244,1 @@\n-     * @param object  the object that is readed from XML document\n+     * @param object  the object that is read from XML document\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/decoder\/DocumentHandler.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-     * @throws IllegalAccessException if the field is not accesible\n+     * @throws IllegalAccessException if the field is not accessible\n@@ -168,1 +168,1 @@\n-     * @throws IllegalAccessException if the field is not accesible\n+     * @throws IllegalAccessException if the field is not accessible\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/decoder\/FieldElementHandler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-     * Adds the argument to the list of readed objects.\n+     * Adds the argument to the list of read objects.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/decoder\/JavaElementHandler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-     * @throws IllegalAccessException    if the property is not accesible\n+     * @throws IllegalAccessException    if the property is not accessible\n@@ -190,1 +190,1 @@\n-     * @throws IllegalAccessException    if the property is not accesible\n+     * @throws IllegalAccessException    if the property is not accessible\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/decoder\/PropertyElementHandler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-            throw new IllegalStateException(\"Could not add chararcter to evaluated string element\");\n+            throw new IllegalStateException(\"Could not add character to evaluated string element\");\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/decoder\/StringElementHandler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        choser = new Choice();\n+        chooser = new Choice();\n@@ -73,1 +73,1 @@\n-            choser.addItem(colorNames[i]);\n+            chooser.addItem(colorNames[i]);\n@@ -75,2 +75,2 @@\n-        add(choser);\n-        choser.reshape(ourWidth,0,100,30);\n+        add(chooser);\n+        chooser.reshape(ourWidth,0,100,30);\n@@ -129,2 +129,2 @@\n-        if (e.target == choser) {\n-            changeColor(colors[choser.getSelectedIndex()]);\n+        if (e.target == chooser) {\n+            changeColor(colors[chooser.getSelectedIndex()]);\n@@ -160,1 +160,1 @@\n-        choser.select(active);\n+        chooser.select(active);\n@@ -229,1 +229,1 @@\n-    private Choice choser;\n+    private Choice chooser;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/editors\/ColorEditor.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,3 +68,3 @@\n-    private List<Method> methods;\n-    private Map<String,PropertyInfo> properties;\n-    private Map<String,EventSetInfo> eventSets;\n+    private volatile List<Method> methods;\n+    private volatile Map<String,PropertyInfo> properties;\n+    private volatile Map<String,EventSetInfo> eventSets;\n@@ -77,1 +77,2 @@\n-        if (this.methods == null) {\n+        List<Method> methods = this.methods;\n+        if (methods == null) {\n@@ -79,2 +80,4 @@\n-                if (this.methods == null) {\n-                    this.methods = MethodInfo.get(this.type);\n+                methods = this.methods;\n+                if (methods == null) {\n+                    methods = MethodInfo.get(this.type);\n+                    this.methods = methods;\n@@ -84,1 +87,1 @@\n-        return this.methods;\n+        return methods;\n@@ -88,1 +91,2 @@\n-        if (this.properties == null) {\n+        Map<String, PropertyInfo> properties = this.properties;\n+        if (properties == null) {\n@@ -90,2 +94,4 @@\n-                if (this.properties == null) {\n-                    this.properties = PropertyInfo.get(this.type);\n+                properties = this.properties;\n+                if (properties == null) {\n+                    properties = PropertyInfo.get(this.type);\n+                    this.properties = properties;\n@@ -95,1 +101,1 @@\n-        return this.properties;\n+        return properties;\n@@ -99,1 +105,2 @@\n-        if (this.eventSets == null) {\n+        Map<String, EventSetInfo> eventSets = this.eventSets;\n+        if (eventSets == null) {\n@@ -101,2 +108,4 @@\n-                if (this.eventSets == null) {\n-                    this.eventSets = EventSetInfo.get(this.type);\n+                eventSets = this.eventSets;\n+                if (eventSets == null) {\n+                    eventSets = EventSetInfo.get(this.type);\n+                    this.eventSets = eventSets;\n@@ -106,1 +115,1 @@\n-        return this.eventSets;\n+        return eventSets;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/introspect\/ClassInfo.java","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -658,1 +658,1 @@\n-            \/\/ the colorModel and sampleModel will be initialzed\n+            \/\/ the colorModel and sampleModel will be initialized\n@@ -2085,1 +2085,1 @@\n-     * Verifies whether the byte array contans a unc path.\n+     * Verifies whether the byte array contains a unc path.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/bmp\/BMPImageReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    private static String[] entensions = {\"bmp\"};\n+    private static String[] extensions = {\"bmp\"};\n@@ -51,1 +51,1 @@\n-              entensions,\n+              extensions,\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/bmp\/BMPImageReaderSpi.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,2 +327,5 @@\n-            throw new IOException(\"Image can not be encoded with compression type \"\n-                                  + BMPCompressionTypes.getName(compressionType));\n+            throw new\n+            IOException(\"Image can not be encoded with compression type \"\n+                        + BMPCompressionTypes.getName(compressionType)\n+                        + \" and \" + colorModel.getPixelSize()\n+                        + \" bits per pixel\");\n@@ -986,1 +989,1 @@\n-                    \/\/\/ be inclued in the next encoding\/run\n+                    \/\/\/ be included in the next encoding\/run\n@@ -1145,1 +1148,1 @@\n-                    \/\/ runCount wont be > 254 since 256\/255 case will\n+                    \/\/ runCount won't be > 254 since 256\/255 case will\n@@ -1418,2 +1421,2 @@\n-     * encodeed with using default compression without cahnge color resolution.\n-     * For example, TYPE_USHORT_565_RGB may be encodeed only by using BI_BITFIELDS\n+     * encoded using default compression without change of color resolution.\n+     * For example, TYPE_USHORT_565_RGB may be encoded only by using BI_BITFIELDS\n@@ -1455,1 +1458,0 @@\n-        int biType = imgType.getBufferedImageType();\n@@ -1457,0 +1459,4 @@\n+        if (bpp != 0 && bpp != 1 && bpp != 4 && bpp != 8 &&\n+            bpp != 15 && bpp != 16 && bpp != 24 && bpp != 32) {\n+            return false;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/bmp\/BMPImageWriter.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    private static String[] entensions = {\"bmp\"};\n+    private static String[] extensions = {\"bmp\"};\n@@ -56,1 +56,1 @@\n-              entensions,\n+              extensions,\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/bmp\/BMPImageWriterSpi.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * The strLen table to give quick access to the lenght of an expanded\n+ * The strLen table to give quick access to the length of an expanded\n@@ -76,1 +76,1 @@\n-     * @return 0xFFFF if no space in table left for addition of predecesor\n+     * @return 0xFFFF if no space in table left for addition of predecessor\n@@ -106,1 +106,1 @@\n-     * @param b the character that follws the index prefix\n+     * @param b the character that follows the index prefix\n@@ -154,1 +154,1 @@\n-     * previous return. Succesive negative return values should be negated and\n+     * previous return. Successive negative return values should be negated and\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/common\/LZWStringTable.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-            return 0; \/\/ default transparnt pixel\n+            return 0; \/\/ default transparent pixel\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/common\/PaletteBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,5 @@\n+import java.awt.image.ColorModel;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.MultiPixelPackedSampleModel;\n+import java.awt.image.PixelInterleavedSampleModel;\n+import java.awt.image.SampleModel;\n@@ -39,0 +44,1 @@\n+\n@@ -46,0 +52,1 @@\n+\n@@ -47,5 +54,0 @@\n-import java.awt.image.ColorModel;\n-import java.awt.image.IndexColorModel;\n-import java.awt.image.MultiPixelPackedSampleModel;\n-import java.awt.image.PixelInterleavedSampleModel;\n-import java.awt.image.SampleModel;\n@@ -657,0 +659,6 @@\n+            if (ignoreMetadata) {\n+                stream.skipBytes(length);\n+                continue;\n+            }\n+            byte[] subBlockData =\n+                ReaderUtil.staggeredReadByteStream(stream, length);\n@@ -659,1 +667,2 @@\n-            stream.readFully(newData, data.length, length);\n+            System.arraycopy(subBlockData, 0, newData,\n+                             data.length, length);\n@@ -662,1 +671,0 @@\n-\n@@ -697,2 +705,3 @@\n-                            new byte[3*numLCTEntries];\n-                        stream.readFully(imageMetadata.localColorTable);\n+                            ReaderUtil.\n+                                staggeredReadByteStream(stream,\n+                                                       (3 * numLCTEntries));\n@@ -729,17 +738,21 @@\n-                        imageMetadata.hasPlainTextExtension = true;\n-                        imageMetadata.textGridLeft =\n-                            stream.readUnsignedShort();\n-                        imageMetadata.textGridTop =\n-                            stream.readUnsignedShort();\n-                        imageMetadata.textGridWidth =\n-                            stream.readUnsignedShort();\n-                        imageMetadata.textGridHeight =\n-                            stream.readUnsignedShort();\n-                        imageMetadata.characterCellWidth =\n-                            stream.readUnsignedByte();\n-                        imageMetadata.characterCellHeight =\n-                            stream.readUnsignedByte();\n-                        imageMetadata.textForegroundColor =\n-                            stream.readUnsignedByte();\n-                        imageMetadata.textBackgroundColor =\n-                            stream.readUnsignedByte();\n+                        if (!ignoreMetadata) {\n+                            imageMetadata.hasPlainTextExtension = true;\n+                            imageMetadata.textGridLeft =\n+                                    stream.readUnsignedShort();\n+                            imageMetadata.textGridTop =\n+                                    stream.readUnsignedShort();\n+                            imageMetadata.textGridWidth =\n+                                    stream.readUnsignedShort();\n+                            imageMetadata.textGridHeight =\n+                                    stream.readUnsignedShort();\n+                            imageMetadata.characterCellWidth =\n+                                    stream.readUnsignedByte();\n+                            imageMetadata.characterCellHeight =\n+                                    stream.readUnsignedByte();\n+                            imageMetadata.textForegroundColor =\n+                                    stream.readUnsignedByte();\n+                            imageMetadata.textBackgroundColor =\n+                                    stream.readUnsignedByte();\n+                        } else {\n+                            stream.skipBytes(length);\n+                        }\n@@ -749,2 +762,5 @@\n-                        if (imageMetadata.comments == null) {\n-                            imageMetadata.comments = new ArrayList<>();\n+                        if (!ignoreMetadata) {\n+                            if (imageMetadata.comments == null) {\n+                                imageMetadata.comments = new ArrayList<>();\n+                            }\n+                            imageMetadata.comments.add(comment);\n@@ -752,1 +768,0 @@\n-                        imageMetadata.comments.add(comment);\n@@ -755,0 +770,2 @@\n+                        int offset = 0;\n+                        byte[] blockData = new byte[0];\n@@ -757,7 +774,12 @@\n-\n-                        \/\/ read available data\n-                        byte[] blockData = new byte[blockSize];\n-                        stream.readFully(blockData);\n-\n-                        int offset = copyData(blockData, 0, applicationID);\n-                        offset = copyData(blockData, offset, authCode);\n+                        if (!ignoreMetadata) {\n+                            \/\/ read available data\n+                            blockData =\n+                                ReaderUtil.staggeredReadByteStream(stream,\n+                                                                   blockSize);\n+\n+                            offset =\n+                                copyData(blockData, 0, applicationID);\n+                            offset = copyData(blockData, offset, authCode);\n+                        } else {\n+                            stream.skipBytes(blockSize);\n+                        }\n@@ -767,1 +789,2 @@\n-                        if (offset < blockSize) {\n+                        if (!ignoreMetadata &&\n+                            offset < blockSize) {\n@@ -772,2 +795,4 @@\n-                            System.arraycopy(blockData, offset, data, 0, len);\n-                            System.arraycopy(applicationData, 0, data, len,\n+                            System.arraycopy(blockData, offset,\n+                                             data, 0, len);\n+                            System.arraycopy(applicationData, 0,\n+                                             data, len,\n@@ -779,6 +804,13 @@\n-                        \/\/ Init lists if necessary\n-                        if (imageMetadata.applicationIDs == null) {\n-                            imageMetadata.applicationIDs = new ArrayList<>();\n-                            imageMetadata.authenticationCodes =\n-                                new ArrayList<>();\n-                            imageMetadata.applicationData = new ArrayList<>();\n+                        if (!ignoreMetadata) {\n+                            \/\/ Init lists if necessary\n+                            if (imageMetadata.applicationIDs == null) {\n+                                imageMetadata.applicationIDs =\n+                                    new ArrayList<>();\n+                                imageMetadata.authenticationCodes =\n+                                    new ArrayList<>();\n+                                imageMetadata.applicationData =\n+                                    new ArrayList<>();\n+                            }\n+                            imageMetadata.applicationIDs.add(applicationID);\n+                            imageMetadata.authenticationCodes.add(authCode);\n+                            imageMetadata.applicationData.add(applicationData);\n@@ -786,3 +818,0 @@\n-                        imageMetadata.applicationIDs.add(applicationID);\n-                        imageMetadata.authenticationCodes.add(authCode);\n-                        imageMetadata.applicationData.add(applicationData);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/gif\/GIFImageReader.java","additions":78,"deletions":49,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -635,1 +635,1 @@\n-                       greyscale images but explicitly reseting it here\n+                       greyscale images but explicitly resetting it here\n@@ -662,1 +662,1 @@\n-            \/\/ Set the Logical Screen Desriptor if not set.\n+            \/\/ Set the Logical Screen Descriptor if not set.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/gif\/GIFImageWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-          \"The number of bits of color resolution, beteen 1 and 8\" },\n+          \"The number of bits of color resolution, between 1 and 8\" },\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/gif\/GIFStreamMetadataFormatResources.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-    \/** Define Heirarchical progression *\/\n+    \/** Define Hierarchical progression *\/\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEG.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1391,1 +1391,1 @@\n-     * IJG libray.  It is much simpler to parse out this\n+     * IJG library.  It is much simpler to parse out this\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-\"The chunk wil be ignored.\");\n+\"The chunk will be ignored.\");\n@@ -341,1 +341,1 @@\n-\"The chunk wil be ignored.\");\n+\"The chunk will be ignored.\");\n@@ -1687,1 +1687,1 @@\n-             * equality of the palette lengh and number of possible palette\n+             * equality of the palette length and number of possible palette\n@@ -1754,1 +1754,1 @@\n-                \/\/ wich can be used as destination\n+                \/\/ which can be used as destination\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/png\/PNGImageReader.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1778,1 +1778,1 @@\n-     * Accrding to PNG spec, keywords are restricted to 1 to 79 bytes\n+     * According to PNG spec, keywords are restricted to 1 to 79 bytes\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/png\/PNGMetadata.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-     * {@code isCompressionLossless} are provided to accomodate\n+     * {@code isCompressionLossless} are provided to accommodate\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFCompressor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1435,1 +1435,1 @@\n-        \/\/ have to search the preceeding element.\n+        \/\/ have to search the preceding element.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFFaxDecompressor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        { \"TIFFField\/number\", \"The tag number asociated with the field\" },\n+        { \"TIFFField\/number\", \"The tag number associated with the field\" },\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFImageMetadataFormatResources.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-    private boolean isTiled; \/\/ Whether the image is tiled (true) or stipped (false).\n+    private boolean isTiled; \/\/ Whether the image is tiled (true) or stripped (false).\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFImageWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-                \/\/ Intialize the JPEG writer to one that supports stream\n+                \/\/ Initialize the JPEG writer to one that supports stream\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFJPEGCompressor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    \/\/ Intialize instance variables according to an analysis of the\n+    \/\/ Initialize instance variables according to an analysis of the\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFOldJPEGDecompressor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-     * CCITT RLE (Run Lenth Encoding).\n+     * CCITT RLE (Run Length Encoding).\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFRLECompressor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    private static String[] entensions = {\"wbmp\"};\n+    private static String[] extensions = {\"wbmp\"};\n@@ -53,1 +53,1 @@\n-              entensions,\n+              extensions,\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/wbmp\/WBMPImageReaderSpi.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    private static String[] entensions = {\"wbmp\"};\n+    private static String[] extensions = {\"wbmp\"};\n@@ -55,1 +55,1 @@\n-              entensions,\n+              extensions,\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/wbmp\/WBMPImageWriterSpi.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * public API and its API may change in incompatable ways between dot dot\n+ * public API and its API may change in incompatible ways between dot dot\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/SwingUtilities3.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-     * @param sFactor Amount to sacle saturation\n+     * @param sFactor Amount to scale saturation\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKColorType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-            \/* We should return correrct WidgetType if the seperator is inserted\n+            \/* We should return correct WidgetType if the separator is inserted\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKEngine.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -983,0 +983,20 @@\n+\n+        @Override\n+        public Vector<File> getDirectories() {\n+            Vector<File> files = super.getDirectories();\n+\n+            \/*\n+             * Delete the \"\/..\" file entry from file chooser directory list in\n+             * GTK LAF if current directory is root and files vector contains\n+             * \"\/..\" entry.\n+             *\n+             * It is not possible to go beyond root directory.\n+             *\/\n+            File crntDir = getFileChooser().getCurrentDirectory();\n+            FileSystemView fsv = getFileChooser().getFileSystemView();\n+            if (crntDir != null && fsv.isFileSystemRoot(crntDir) &&\n+                files.contains(new File(\"\/..\"))) {\n+                    files.removeElementAt(0);\n+            }\n+            return files;\n+        }\n@@ -1366,1 +1386,1 @@\n-            \/\/ are parented getName is overriden to force the name to be\n+            \/\/ are parented getName is overridden to force the name to be\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKFileChooserUI.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1359,1 +1359,1 @@\n-        \/\/ wigdet. LABEL in this case.\n+        \/\/ widget. LABEL in this case.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-     * Overriden to empty the MouseMotionListener.\n+     * Overridden to empty the MouseMotionListener.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifComboBoxUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-                            \/\/ The Border on the verticall scrollbar matches\n+                            \/\/ The Border on the vertical scrollbar matches\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifScrollPaneUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-     * PENDING(jeff) - rewrite JSplitPane so that this ins't needed\n+     * PENDING(jeff) - rewrite JSplitPane so that this isn't needed\n@@ -188,1 +188,1 @@\n-     * overriden from super to create a different MouseHandler.\n+     * overridden from super to create a different MouseHandler.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifSplitPaneDivider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    \/** List of Receivers and Transmitters that opened the device implicitely.\n+    \/** List of Receivers and Transmitters that opened the device implicitly.\n@@ -130,1 +130,1 @@\n-            \/\/ double calls to doOpens() will be catched by the open flag.\n+            \/\/ double calls to doOpens() will be caught by the open flag.\n@@ -152,1 +152,1 @@\n-    \/** Close the device for an object that implicitely opened it.\n+    \/** Close the device for an object that implicitly opened it.\n@@ -155,3 +155,3 @@\n-     * do not know if their device has been opened implicitely because of them, they call this\n-     * method in any case. This method now is able to seperate Receivers\/Transmitters that opened\n-     * the device implicitely from those that didn't by looking up the R\/T in the\n+     * do not know if their device has been opened implicitly because of them, they call this\n+     * method in any case. This method now is able to separate Receivers\/Transmitters that opened\n+     * the device implicitly from those that didn't by looking up the R\/T in the\n@@ -161,1 +161,1 @@\n-     * @param object The object that might have been opening the device implicitely (for now,\n+     * @param object The object that might have been opening the device implicitly (for now,\n@@ -345,1 +345,1 @@\n-    \/** Return the list of objects that have opened the device implicitely.\n+    \/** Return the list of objects that have opened the device implicitly.\n@@ -437,1 +437,1 @@\n-        (which opens the device implicitely).\n+        (which opens the device implicitly).\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/AbstractMidiDevice.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * big\/litle endian fixed\/floating point byte buffers and float buffers.\n+ * big\/little endian fixed\/floating point byte buffers and float buffers.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/AudioFloatConverter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * big\/litle endian fixed\/floating stereo\/mono\/multi-channel audio streams and\n+ * big\/little endian fixed\/floating stereo\/mono\/multi-channel audio streams and\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/AudioFloatFormatConverter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-     * (ICMS) Names of persons or orginizations who commissioned the file.\n+     * (ICMS) Names of persons or organizations who commissioned the file.\n@@ -97,1 +97,1 @@\n-     * (ISRC) Name of person or orginization who supplied\n+     * (ISRC) Name of person or organization who supplied\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/DLSInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1022,1 +1022,1 @@\n-                                                    \" and frame lengh of \" + getFrameLength());\n+                                                    \" and frame length of \" + getFrameLength());\n@@ -1044,1 +1044,1 @@\n-                    \/\/ if we got this far, we can instanciate the thread\n+                    \/\/ if we got this far, we can instantiate the thread\n@@ -1074,1 +1074,1 @@\n-                                                    \" and frame lengh of \" + getFrameLength());\n+                                                    \" and frame length of \" + getFrameLength());\n@@ -1215,1 +1215,1 @@\n-                throw new IllegalArgumentException(\"End position \" + end + \"  preceeds start position \" + start);\n+                throw new IllegalArgumentException(\"End position \" + end + \"  precedes start position \" + start);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/DirectAudioDevice.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-     * threshhold between playing as a Clip and streaming\n+     * threshold between playing as a Clip and streaming\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/JavaSoundAudioClip.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-     * dropped completly.\n+     * dropped completely.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/Printer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -785,1 +785,1 @@\n-            if (Printer.err) Printer.err(\"RealTimeSequencer.implClose() called, but playThread not instanciated!\");\n+            if (Printer.err) Printer.err(\"RealTimeSequencer.implClose() called, but playThread not instantiated!\");\n@@ -819,1 +819,1 @@\n-            if (Printer.err) Printer.err(\"RealTimeSequencer.implStart() called, but playThread not instanciated!\");\n+            if (Printer.err) Printer.err(\"RealTimeSequencer.implStart() called, but playThread not instantiated!\");\n@@ -832,1 +832,1 @@\n-            if (Printer.err) Printer.err(\"RealTimeSequencer.implStop() called, but playThread not instanciated!\");\n+            if (Printer.err) Printer.err(\"RealTimeSequencer.implStop() called, but playThread not instantiated!\");\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/RealTimeSequencer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1476,1 +1476,1 @@\n-                rpnChange(1, 64 << 7);  \/\/ Channel fine tunning\n+                rpnChange(1, 64 << 7);  \/\/ Channel fine tuning\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftChannel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        \/\/ 15 bit shift was choosed because\n+        \/\/ 15 bit shift was chosen because\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftLinearResampler2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    \/\/ A private class thats contains a ModelChannelMixer and it's private buffers.\n+    \/\/ A private class that contains a ModelChannelMixer and it's private buffers.\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftMainMixer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-                    + getFormat() + \" and frame lengh of \" + getFrameLength());\n+                    + getFormat() + \" and frame length of \" + getFrameLength());\n@@ -361,1 +361,1 @@\n-                                + \" and frame lengh of \" + getFrameLength());\n+                                + \" and frame length of \" + getFrameLength());\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftMixingClip.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -692,1 +692,1 @@\n-        \/\/ seperate connection blocks : Init time, Midi Time, Midi\/Control Time,\n+        \/\/ separate connection blocks : Init time, Midi Time, Midi\/Control Time,\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftPerformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-        \/\/ Now seqence the track streams\n+        \/\/ Now sequence the track streams\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/StandardMidiFileWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-     * The class is usefull for use with SequenceInputStream to prevent\n+     * The class is useful for use with SequenceInputStream to prevent\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SunFileWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    \/\/A key withing the cache\n+    \/\/A key within the cache\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/AWTKeyStroke.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6228,1 +6228,1 @@\n-     * Value indicates whether overriden.\n+     * Value indicates whether overridden.\n@@ -6304,1 +6304,1 @@\n-            \/\/ Throws if not overriden.\n+            \/\/ Throws if not overridden.\n@@ -10159,1 +10159,1 @@\n-     * The method is overriden in the java.awt.Container to handle non-opaque\n+     * The method is overridden in the java.awt.Container to handle non-opaque\n@@ -10428,1 +10428,1 @@\n-        \/\/ This method gets overriden in the Container. Obviously, a plain\n+        \/\/ This method gets overridden in the Container. Obviously, a plain\n@@ -10531,1 +10531,1 @@\n-    \/\/ Note that the method is overriden in the Window class,\n+    \/\/ Note that the method is overridden in the Window class,\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Component.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4122,1 +4122,1 @@\n-     * This method is overriden to handle opaque children in non-opaque\n+     * This method is overridden to handle opaque children in non-opaque\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Container.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-     * getFirstComponent or getLastComponent. These methods may be overriden in\n+     * getFirstComponent or getLastComponent. These methods may be overridden in\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/ContainerOrderFocusTraversalPolicy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-     * underestimate depending on the specific text and rendering conext.\n+     * underestimate depending on the specific text and rendering context.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/FontMetrics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @author Bill Spitzak (orignial NeWS &amp; OLIT implementation)\n+ * @author Bill Spitzak (original NeWS &amp; OLIT implementation)\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GridBagConstraints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n- * @author Bill Spitzak (orignial NeWS &amp; OLIT implementation)\n+ * @author Bill Spitzak (original NeWS &amp; OLIT implementation)\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GridBagLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n-     * Adds a separator line, or a hypen, to the menu at the current position.\n+     * Adds a separator line, or a hyphen, to the menu at the current position.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Menu.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -850,1 +850,1 @@\n-     * that method is not overriden), then this results in a call to the\n+     * that method is not overridden), then this results in a call to the\n@@ -886,1 +886,1 @@\n-     * that method is not overriden), then this results in a call to the\n+     * that method is not overridden), then this results in a call to the\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Toolkit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,4 +74,4 @@\n- * The details of this class are not important for simple applets, which draw in\n- * a default color space or manipulate and display imported images with a known\n- * color space. At most, such applets would need to get one of the default color\n- * spaces via {@link ColorSpace#getInstance}.\n+ * The details of this class are not important for simple applications, which\n+ * draw in a default color space or manipulate and display imported images with\n+ * a known color space. At most, such applications would need to get one of the\n+ * default color spaces via {@link ColorSpace#getInstance}.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ColorSpace.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1076,2 +1076,2 @@\n-     * This method is useful for advanced applets or applications which need to\n-     * access profile data directly.\n+     * This method is useful for advanced applications which need to access\n+     * profile data directly.\n@@ -1102,2 +1102,2 @@\n-     * This method is useful for advanced applets or applications which need to\n-     * access profile data directly.\n+     * This method is useful for advanced applications which need to access\n+     * profile data directly.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-            \/\/ cant happen ...\n+            \/\/ can't happen ...\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/dnd\/DragGestureRecognizer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3905,6 +3905,6 @@\n-        long bits = Double.doubleToLongBits(m00);\n-        bits = bits * 31 + Double.doubleToLongBits(m01);\n-        bits = bits * 31 + Double.doubleToLongBits(m02);\n-        bits = bits * 31 + Double.doubleToLongBits(m10);\n-        bits = bits * 31 + Double.doubleToLongBits(m11);\n-        bits = bits * 31 + Double.doubleToLongBits(m12);\n+        long bits = hash(m00);\n+        bits = bits * 31 + hash(m01);\n+        bits = bits * 31 + hash(m02);\n+        bits = bits * 31 + hash(m10);\n+        bits = bits * 31 + hash(m11);\n+        bits = bits * 31 + hash(m12);\n@@ -3914,0 +3914,10 @@\n+    \/**\n+     * Returns a hash code for the given value, with negative zero\n+     * collapsed to the single positive zero.\n+     *\/\n+    private static long hash(double m) {\n+        long h = Double.doubleToLongBits(m);\n+        if (h == 0x8000000000000000L) h = 0;    \/\/ Replace -0 by +0.\n+        return h;\n+    }\n+\n@@ -3931,2 +3941,11 @@\n-        return ((m00 == a.m00) && (m01 == a.m01) && (m02 == a.m02) &&\n-                (m10 == a.m10) && (m11 == a.m11) && (m12 == a.m12));\n+        return equals(m00, a.m00) && equals(m01, a.m01) &&\n+               equals(m02, a.m02) && equals(m10, a.m10) &&\n+               equals(m11, a.m11) && equals(m12, a.m12);\n+    }\n+\n+    \/**\n+     * Compares the given floating point values, with negative zero\n+     * considered equals to positive zero.\n+     *\/\n+    private static boolean equals(double a, double b) {\n+        return (a == b) || (Double.isNaN(a) && Double.isNaN(b));\n@@ -3935,1 +3954,1 @@\n-    \/* Serialization support.  A readObject method is neccessary because\n+    \/* Serialization support.  A readObject method is necessary because\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/AffineTransform.java","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1306,1 +1306,1 @@\n-         * and rigth bottom corner coordinates\n+         * and right bottom corner coordinates\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Arc2D.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1412,1 +1412,1 @@\n-        \/\/ Trivially reject non-existant rectangles\n+        \/\/ Trivially reject non-existent rectangles\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/CubicCurve2D.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2309,1 +2309,1 @@\n-             * by virtue of adding opposing Infinte values.\n+             * by virtue of adding opposing Infinite values.\n@@ -2381,1 +2381,1 @@\n-             * by virtue of adding opposing Infinte values.\n+             * by virtue of adding opposing Infinite values.\n@@ -2459,1 +2459,1 @@\n-             * by virtue of adding opposing Infinte values.\n+             * by virtue of adding opposing Infinite values.\n@@ -2530,1 +2530,1 @@\n-             * by virtue of adding opposing Infinte values.\n+             * by virtue of adding opposing Infinite values.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Path2D.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1101,1 +1101,1 @@\n-        \/\/ Trivially reject non-existant rectangles\n+        \/\/ Trivially reject non-existent rectangles\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/QuadCurve2D.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * The only method which needs to be defined to create a useable image\n+ * The only method which needs to be defined to create a usable image\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/RGBImageFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-        int size = scanlineStride * (h - 1) + \/\/ fisrt (h - 1) scans\n+        int size = scanlineStride * (h - 1) + \/\/ first (h - 1) scans\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/Raster.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-     * Note that for beans which are applets, it is the caller's responsiblity\n+     * Note that for beans which are applets, it is the caller's responsibility\n@@ -288,1 +288,1 @@\n-                    \/\/ Now get the URL correponding to the resource name.\n+                    \/\/ Now get the URL corresponding to the resource name.\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/Beans.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-            \/\/ Asssume the listeners are in the same order and that there are no gaps.\n+            \/\/ Assume the listeners are in the same order and that there are no gaps.\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/DefaultPersistenceDelegate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1158,1 +1158,1 @@\n-        \/\/ For overriden methods we need to find the most derived version.\n+        \/\/ For overridden methods we need to find the most derived version.\n@@ -1211,1 +1211,1 @@\n-     * Used in the contructors of the EventSetDescriptor,\n+     * Used in the constructors of the EventSetDescriptor,\n@@ -1232,1 +1232,1 @@\n-     * Note tht either or both \"Class\" objects may represent interfaces.\n+     * Note that either or both \"Class\" objects may represent interfaces.\n@@ -1236,1 +1236,1 @@\n-        \/\/ primtitive type there is a unqiue Class object, so\n+        \/\/ primtitive type there is a unique Class object, so\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/Introspector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -339,1 +339,1 @@\n-of the Map insterface exclusively. Attatching the persistence delegates\n+of the Map interface exclusively. Attaching the persistence delegates\n@@ -1152,1 +1152,1 @@\n-\/* XXX - doens't seem to work. Debug later.\n+\/* XXX - doesn't seem to work. Debug later.\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/MetaData.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-     * <li>Primitive expresssion: {@code 2}\n+     * <li>Primitive expression: {@code 2}\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/PropertyEditor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.beans.*;\n+import java.util.ArrayList;\n@@ -256,1 +256,1 @@\n-            listeners = new java.util.Vector<>();\n+            listeners = new ArrayList<>();\n@@ -258,1 +258,1 @@\n-        listeners.addElement(listener);\n+        listeners.add(listener);\n@@ -276,1 +276,1 @@\n-        listeners.removeElement(listener);\n+        listeners.remove(listener);\n@@ -283,1 +283,1 @@\n-        java.util.Vector<PropertyChangeListener> targets;\n+        ArrayList<PropertyChangeListener> targets;\n@@ -288,1 +288,1 @@\n-            targets = unsafeClone(listeners);\n+            targets = new ArrayList<>(listeners);\n@@ -294,1 +294,1 @@\n-            PropertyChangeListener target = targets.elementAt(i);\n+            PropertyChangeListener target = targets.get(i);\n@@ -299,5 +299,0 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private <T> java.util.Vector<T> unsafeClone(java.util.Vector<T> v) {\n-        return (java.util.Vector<T>)v.clone();\n-    }\n-\n@@ -308,1 +303,1 @@\n-    private java.util.Vector<PropertyChangeListener> listeners;\n+    private ArrayList<PropertyChangeListener> listeners;\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/PropertyEditorSupport.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * overriden to provide more explicit information on chosen topics.\n+ * overridden to provide more explicit information on chosen topics.\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/SimpleBeanInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-     * Analagous to {@code java.lang.ClassLoader.getResourceAsStream()},\n+     * Analogous to {@code java.lang.ClassLoader.getResourceAsStream()},\n@@ -94,1 +94,1 @@\n-     * Analagous to {@code java.lang.ClassLoader.getResource()}, this\n+     * Analogous to {@code java.lang.ClassLoader.getResource()}, this\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-     * Contruct a BeanContextEvent\n+     * Construct a BeanContextEvent\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * Contruct a BeanContextMembershipEvent\n+     * Construct a BeanContextMembershipEvent\n@@ -80,1 +80,1 @@\n-     * Contruct a BeanContextMembershipEvent\n+     * Construct a BeanContextMembershipEvent\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextMembershipEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1330,1 +1330,1 @@\n-             * accidential serialization of the BeanContext by a badly\n+             * accidental serialization of the BeanContext by a badly\n@@ -1344,1 +1344,1 @@\n-             * accidential serialization of the BeanContext by a badly\n+             * accidental serialization of the BeanContext by a badly\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/beancontext\/BeanContextSupport.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-     * Returns the number of characters (valid indicies).\n+     * Returns the number of characters (valid indices).\n","filename":"src\/java.desktop\/share\/classes\/javax\/accessibility\/AccessibleText.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * indicies\/offsets into a larger body of text that the {@code String} comes\n+ * indices\/offsets into a larger body of text that the {@code String} comes\n","filename":"src\/java.desktop\/share\/classes\/javax\/accessibility\/AccessibleTextSequence.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-     * DOMException are publically documented as such on IIOMetadataNode.\n+     * DOMException are publicly documented as such on IIOMetadataNode.\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/metadata\/IIOMetadataNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        &lt;!-- The number of bits of color resolution, beteen 1 and 8 --&gt;\n+        &lt;!-- The number of bits of color resolution, between 1 and 8 --&gt;\n@@ -139,1 +139,1 @@\n-color table, and extension information assciated with a single image\n+color table, and extension information associated with a single image\n@@ -158,1 +158,1 @@\n-(<code>doNotDispose<\/code>), be restored to the backgound color as\n+(<code>doNotDispose<\/code>), be restored to the background color as\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/metadata\/doc-files\/gif_metadata.html","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1114,1 +1114,1 @@\n-          &lt;!-- The tag number asociated with the field --&gt;\n+          &lt;!-- The tag number associated with the field --&gt;\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/metadata\/doc-files\/tiff_metadata.html","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    \/* The data for the publically defined tables, as specified in ITU T.81\n+    \/* The data for the publicly defined tables, as specified in ITU T.81\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/plugins\/jpeg\/JPEGHuffmanTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * dynamically accoring to application policy.  For example, in a\n+ * dynamically according to application policy.  For example, in a\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/spi\/PartiallyOrderedSet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,0 +203,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -211,0 +214,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -219,0 +225,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -227,0 +236,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -241,0 +253,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -245,0 +260,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -249,0 +267,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -265,0 +286,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -269,0 +293,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -283,0 +310,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -287,0 +317,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -321,0 +354,4 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     * @throws java.io.UTFDataFormatException {@inheritDoc}\n+     *\/\n@@ -343,0 +380,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -360,0 +400,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -364,0 +407,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -380,0 +426,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -396,0 +445,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -412,0 +464,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -428,0 +483,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -444,0 +502,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -644,0 +705,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n@@ -666,0 +730,3 @@\n+    \/**\n+     * @throws EOFException {@inheritDoc}\n+     *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageInputStreamImpl.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-     * Otheriwse, the bytes written will be:\n+     * Otherwise, the bytes written will be:\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageOutputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,0 +159,3 @@\n+    \/**\n+     * @throws UTFDataFormatException {@inheritDoc}\n+     *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageOutputStreamImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-        \/\/ NOTE that alot of error checking is duplicated\n+        \/\/ NOTE that a lot of error checking is duplicated\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/MemoryCacheImageOutputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1067,1 +1067,1 @@\n-     * instead throws a {@code MidiUnavailableException}, with the catched\n+     * instead throws a {@code MidiUnavailableException}, with the caught\n@@ -1481,1 +1481,1 @@\n-                \/\/ And of cource, the device has to be able to provide\n+                \/\/ And of course, the device has to be able to provide\n","filename":"src\/java.desktop\/share\/classes\/javax\/sound\/midi\/MidiSystem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1271,1 +1271,1 @@\n-     * Sets the seleted state of the button from the action.  This is defined\n+     * Sets the selected state of the button from the action.  This is defined\n@@ -1646,2 +1646,2 @@\n-     * on intervals less than the threshhold will be ignored and no\n-     * corresponding action event generated.  By default the threshhold is 0,\n+     * on intervals less than the threshold will be ignored and no\n+     * corresponding action event generated.  By default the threshold is 0,\n@@ -1651,1 +1651,1 @@\n-     * in a dialog), this threshhold should be set to an appropriate\n+     * in a dialog), this threshold should be set to an appropriate\n@@ -1655,1 +1655,1 @@\n-     * @param threshhold the amount of time required between mouse\n+     * @param threshold the amount of time required between mouse\n@@ -1657,1 +1657,1 @@\n-     * @throws   IllegalArgumentException if threshhold &lt; 0\n+     * @throws   IllegalArgumentException if threshold &lt; 0\n@@ -1660,3 +1660,3 @@\n-    public void setMultiClickThreshhold(long threshhold) {\n-        if (threshhold < 0) {\n-            throw new IllegalArgumentException(\"threshhold must be >= 0\");\n+    public void setMultiClickThreshhold(long threshold) {\n+        if (threshold < 0) {\n+            throw new IllegalArgumentException(\"threshold must be >= 0\");\n@@ -1664,1 +1664,1 @@\n-        this.multiClickThreshhold = threshhold;\n+        this.multiClickThreshhold = threshold;\n@@ -2664,1 +2664,1 @@\n-         * Return the number of characters (valid indicies)\n+         * Return the number of characters (valid indices)\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/AbstractButton.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-     * are specified by a closed interval index0, index1 -- the enpoints\n+     * are specified by a closed interval index0, index1 -- the endpoints\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/AbstractListModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * Do NOT create an annonymous inner class that extends this!  If you do\n+ * Do NOT create an anonymous inner class that extends this!  If you do,\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ActionPropertyChangeListener.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -501,3 +501,3 @@\n-     * The relative axis values, PAGE_AXIS and LINE_AXIS are converted\n-     * to their absolute couterpart given the target's ComponentOrientation\n-     * value.  The absolute axes, X_AXIS and Y_AXIS are returned unmodified.\n+     * The relative axis values, PAGE_AXIS and LINE_AXIS, are converted\n+     * to their absolute counterpart given the target's ComponentOrientation\n+     * value.  The absolute axes, X_AXIS and Y_AXIS, are returned unmodified.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/BoxLayout.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    \/\/ PaintManager.show is overriden to show directly from the\n+    \/\/ PaintManager.show is overridden to show directly from the\n@@ -152,2 +152,2 @@\n-        \/\/ dipose can be invoked at any random time. To avoid\n-        \/\/ threading dependancies we do the actual diposing via an\n+        \/\/ dispose can be invoked at any random time. To avoid\n+        \/\/ threading dependencies we do the actual disposing via an\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/BufferStrategyPaintManager.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-     * @param m an isntance of {@code ButtonModel}\n+     * @param m an instance of {@code ButtonModel}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ButtonGroup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -369,1 +369,1 @@\n-           to their cannonical values so that the next set command always works\n+           to their canonical values so that the next set command always works\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultListSelectionModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1038,2 +1038,2 @@\n-            \/\/ We either weren't sorted, or to much changed, sort it all or\n-            \/\/ this is the first row added and we have to update diffeent caches\n+            \/\/ We either weren't sorted, or too much changed, sort it all or\n+            \/\/ this is the first row added and we have to update different caches\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultRowSorter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1654,1 +1654,1 @@\n-         * will be combined.  For example, a group that layed things out\n+         * will be combined.  For example, a group that laid things out\n@@ -2463,1 +2463,1 @@\n-        \/\/ How children are layed out.\n+        \/\/ How children are laid out.\n@@ -3594,1 +3594,1 @@\n-        \/\/ Component being layed out\n+        \/\/ Component being laid out\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/GroupLayout.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-        \/\/ work the contentPane must be opaque, therefor the RootPane can\n+        \/\/ work the contentPane must be opaque, therefore the RootPane can\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JApplet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,2 +248,2 @@\n-     * The icon for checkboxs comes from the look and feel,\n-     * not the Action; this is overriden to do nothing.\n+     * The icon for checkboxes comes from the look and feel,\n+     * not the Action; this is overridden to do nothing.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JCheckBox.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-     * Overriden to return true, JCheckBoxMenuItem supports\n+     * Overridden to return true, JCheckBoxMenuItem supports\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JCheckBoxMenuItem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1724,1 +1724,1 @@\n-         * Sets the combo box editor's accessible name and descripton\n+         * Sets the combo box editor's accessible name and description\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComboBox.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1121,1 +1121,1 @@\n-                \/\/ Will ocassionaly happen in 1.2, especially when printing.\n+                \/\/ Will occasionally happen in 1.2, especially when printing.\n@@ -3485,1 +3485,1 @@\n-                \/\/ registerKeyboardAction(null) would essentialy remove\n+                \/\/ registerKeyboardAction(null) would essentially remove\n@@ -3506,1 +3506,1 @@\n-        \/\/ Does nothing, our enabledness is determiend from our asociated\n+        \/\/ Does nothing, our enabledness is determined from our associated\n@@ -4285,1 +4285,1 @@\n-        \/\/ overriden in DelegateContainer on osx.\n+        \/\/ overridden in DelegateContainer on osx.\n@@ -5211,1 +5211,1 @@\n-                \/\/ look to see if the parent (and therefor this component)\n+                \/\/ look to see if the parent (and therefore this component)\n@@ -5410,1 +5410,1 @@\n-    \/\/ subclasses inside the package, but whose inheritance hierarhcy includes\n+    \/\/ subclasses inside the package, but whose inheritance hierarchy includes\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComponent.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -676,1 +676,1 @@\n-        \/\/ work the contentPane must be opaque, therefor the RootPane can\n+        \/\/ work the contentPane must be opaque, therefore the RootPane can\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JDialog.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -787,1 +787,1 @@\n-     * This method can be overriden to further manipulate the dialog,\n+     * This method can be overridden to further manipulate the dialog,\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JFileChooser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-        \/\/ work the contentPane must be opaque, therefor the RootPane can\n+        \/\/ work the contentPane must be opaque, therefore the RootPane can\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JFrame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1083,1 +1083,1 @@\n-           want focus, then it will get transfered there later.\n+           want focus, then it will get transferred there later.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JInternalFrame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1246,1 +1246,1 @@\n-         * Return the number of characters (valid indicies)\n+         * Return the number of characters (valid indices)\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JLabel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -532,1 +532,1 @@\n-            \/\/\/ Short circut the counting when we have them all\n+            \/\/\/ Short-circuit the counting when we have them all\n@@ -558,1 +558,1 @@\n-            \/\/\/ Short circut the counting when we have them all\n+            \/\/\/ Short-circuit the counting when we have them all\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JLayeredPane.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -974,2 +974,2 @@\n-     * Defines the way list cells are layed out. Consider a {@code JList}\n-     * with five cells. Cells can be layed out in one of the following ways:\n+     * Defines the way list cells are laid out. Consider a {@code JList}\n+     * with five cells. Cells can be laid out in one of the following ways:\n@@ -1005,1 +1005,1 @@\n-     *     <td>Cells are layed out vertically in a single column.\n+     *     <td>Cells are laid out vertically in a single column.\n@@ -1008,1 +1008,1 @@\n-     *     <td>Cells are layed out horizontally, wrapping to a new row as\n+     *     <td>Cells are laid out horizontally, wrapping to a new row as\n@@ -1015,1 +1015,1 @@\n-     *     <td>Cells are layed out vertically, wrapping to a new column as\n+     *     <td>Cells are laid out vertically, wrapping to a new column as\n@@ -1038,1 +1038,1 @@\n-            = \"Defines the way list cells are layed out.\")\n+            = \"Defines the way list cells are laid out.\")\n@@ -3637,1 +3637,1 @@\n-                        \/\/ This can happen if the component isn't visisble\n+                        \/\/ This can happen if the component isn't visible\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JList.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-     * Overriden to do nothing. We want JMenu to be focusable, but\n+     * Overridden to do nothing. We want JMenu to be focusable, but\n@@ -201,1 +201,1 @@\n-     * do nothing. We don't invoke <code>setFocusable(true)<\/code> after\n+     * to do nothing. We don't invoke <code>setFocusable(true)<\/code> after\n@@ -1113,1 +1113,1 @@\n-    \/\/ Overriden to do nothing, JMenu doesn't support an accelerator\n+    \/\/ Overridden to do nothing, JMenu doesn't support an accelerator\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JMenu.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-     * Returns an point which has been adjusted to take into account of the\n+     * Returns an point which has been adjusted to take into account the\n@@ -338,1 +338,1 @@\n-     * This adustment may be cancelled by invoking the application with\n+     * This adjustment may be cancelled by invoking the application with\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JPopupMenu.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-     * Overriden to return true, JRadioButtonMenuItem supports\n+     * Overridden to return true, JRadioButtonMenuItem supports\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JRadioButtonMenuItem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-            \/\/ A binding to a disabled action is treated as a nonexistant\n+            \/\/ A binding to a disabled action is treated as a non-existent\n@@ -1850,1 +1850,1 @@\n-         * Returns the number of characters (valid indicies)\n+         * Returns the number of characters (valid indices)\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSpinner.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -424,2 +424,2 @@\n-    \/\/ Logicaly, the above is a Hashtable<Class<?>, TableCellRenderer>.\n-    \/\/ It is declared otherwise to accomodate using UIDefaults.\n+    \/\/ Logically, the above is a Hashtable<Class<?>, TableCellRenderer>.\n+    \/\/ It is declared otherwise to accommodate using UIDefaults.\n@@ -433,2 +433,2 @@\n-    \/\/ Logicaly, the above is a Hashtable<Class<?>, TableCellEditor>.\n-    \/\/ It is declared otherwise to accomodate using UIDefaults.\n+    \/\/ Logically, the above is a Hashtable<Class<?>, TableCellEditor>.\n+    \/\/ It is declared otherwise to accommodate using UIDefaults.\n@@ -3177,1 +3177,1 @@\n-            \/\/ JTable behaves like a layout manger - but one in which the\n+            \/\/ JTable behaves like a layout manager - but one in which the\n@@ -3188,1 +3188,1 @@\n-            \/\/ If the delta cannot be completely accomodated, then the\n+            \/\/ If the delta cannot be completely accommodated, then the\n@@ -7304,1 +7304,1 @@\n-                    \/\/   wherein three colums and one row selected\n+                    \/\/   wherein three columns and one row selected\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTable.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -667,1 +667,1 @@\n-        \",colums=\" + columns +\n+        \",columns=\" + columns +\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTextArea.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-     * Overriden to return true, JToggleButton supports\n+     * Overridden to return true, JToggleButton supports\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JToggleButton.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3304,1 +3304,1 @@\n-     * Returns an array of integers specifying the indexs of the\n+     * Returns an array of integers specifying the indices of the\n@@ -3313,1 +3313,1 @@\n-            int[]       indexs = new int[count - 1];\n+            int[]       indices = new int[count - 1];\n@@ -3317,1 +3317,1 @@\n-                indexs[counter - 1] = model.getIndexOfChild\n+                indices[counter - 1] = model.getIndexOfChild\n@@ -3320,1 +3320,1 @@\n-                if(indexs[counter - 1] < 0)\n+                if(indices[counter - 1] < 0)\n@@ -3323,1 +3323,1 @@\n-            return indexs;\n+            return indices;\n@@ -3330,1 +3330,1 @@\n-     * for each of the indices in <code>indexs<\/code>. If <code>indexs<\/code>\n+     * for each of the indices in <code>indices<\/code>. If <code>indices<\/code>\n@@ -3334,2 +3334,2 @@\n-    private TreePath getPathForIndexs(int[] indexs) {\n-        if(indexs == null)\n+    private TreePath getPathForIndexs(int[] indices) {\n+        if(indices == null)\n@@ -3343,1 +3343,1 @@\n-        int          count = indexs.length;\n+        int          count = indices.length;\n@@ -3351,1 +3351,1 @@\n-            parent = model.getChild(parent, indexs[counter]);\n+            parent = model.getChild(parent, indices[counter]);\n@@ -3397,1 +3397,1 @@\n-         * This is overriden to do nothing; {@code EmptySelectionModel}\n+         * This is overridden to do nothing; {@code EmptySelectionModel}\n@@ -3405,1 +3405,1 @@\n-         * This is overriden to do nothing; {@code EmptySelectionModel}\n+         * This is overridden to do nothing; {@code EmptySelectionModel}\n@@ -3413,1 +3413,1 @@\n-         * This is overriden to do nothing; {@code EmptySelectionModel}\n+         * This is overridden to do nothing; {@code EmptySelectionModel}\n@@ -3421,1 +3421,1 @@\n-         * This is overriden to do nothing; {@code EmptySelectionModel}\n+         * This is overridden to do nothing; {@code EmptySelectionModel}\n@@ -3431,1 +3431,1 @@\n-         * This is overriden to do nothing; {@code EmptySelectionModel}\n+         * This is overridden to do nothing; {@code EmptySelectionModel}\n@@ -3441,1 +3441,1 @@\n-         * This is overriden to do nothing; {@code EmptySelectionModel}\n+         * This is overridden to do nothing; {@code EmptySelectionModel}\n@@ -3451,1 +3451,1 @@\n-         * This is overriden to do nothing; {@code EmptySelectionModel}\n+         * This is overridden to do nothing; {@code EmptySelectionModel}\n@@ -3462,1 +3462,1 @@\n-         * This is overriden to do nothing; {@code EmptySelectionModel}\n+         * This is overridden to do nothing; {@code EmptySelectionModel}\n@@ -3473,1 +3473,1 @@\n-         * This is overriden to do nothing; {@code EmptySelectionModel}\n+         * This is overridden to do nothing; {@code EmptySelectionModel}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTree.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1698,1 +1698,1 @@\n-    \/\/ reason we call into paintForceDoubleBuffered to diregard whether or\n+    \/\/ reason we call into paintForceDoubleBuffered to disregard whether or\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JViewport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-        \/\/ work the contentPane must be opaque, therefor the RootPane can\n+        \/\/ work the contentPane must be opaque, therefore the RootPane can\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JWindow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-  * Here's a description of the symantics of how keyboard dispatching should work\n-  * atleast as I understand it.\n+  * Here's a description of the semantics of how keyboard dispatching should work\n+  * at least as I understand it.\n@@ -48,1 +48,1 @@\n-  * This is where things start to get interesting.  First, KeyStokes defined with the\n+  * This is where things start to get interesting.  First, KeyStrokes defined with the\n@@ -113,1 +113,1 @@\n-           \/\/ Then add the old compoennt and the new compoent to the vector\n+           \/\/ Then add the old component and the new component to the vector\n@@ -204,1 +204,1 @@\n-      * to see if any chidren (or subchildren) of the specified container\n+      * to see if any children (or subchildren) of the specified container\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/KeyboardManager.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        \/\/ ancestors which share a parent. Compute the ancestory lists for\n+        \/\/ ancestors which share a parent. Compute the ancestry lists for\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/LayoutComparator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-            \/\/ case where the developer has overriden isFocusTraversable to\n+            \/\/ case where the developer has overridden isFocusTraversable to\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/LayoutFocusTraversalPolicy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-     * the <code>Popup<\/code> at. Based on screen size, or other paramaters,\n+     * the <code>Popup<\/code> at. Based on screen size, or other parameters,\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/Popup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-     * the <code>Popup<\/code> at. Based on screen size, or other paramaters,\n+     * the <code>Popup<\/code> at. Based on screen size, or other parameters,\n@@ -1000,1 +1000,1 @@\n-            \/\/ painting to work the contentPane must be opaque, therefor the\n+            \/\/ painting to work the contentPane must be opaque, therefore the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/PopupFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -930,1 +930,1 @@\n-         * Returns the number of characters (valid indicies)\n+         * Returns the number of characters (valid indices)\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ProgressMonitor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-     * Object responsible for hanlding core paint functionality.\n+     * Object responsible for handling core paint functionality.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-         * Returns the identifer (in the model) of the entry.\n+         * Returns the identifier (in the model) of the entry.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RowFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-     * getFirstComponent or getLastComponent. These methods may be overriden in\n+     * getFirstComponent or getLastComponent. These methods may be overridden in\n@@ -228,1 +228,1 @@\n-                        log.fine(\"### Transfered focus down-cycle to \" + retComp +\n+                        log.fine(\"### Transferred focus down-cycle to \" + retComp +\n@@ -240,1 +240,1 @@\n-                    log.fine(\"### Transfered focus to \" + retComp + \" in the FTP provider \" + cont);\n+                    log.fine(\"### Transferred focus to \" + retComp + \" in the FTP provider \" + cont);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SortingFocusTraversalPolicy.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-     * Indiciates if we've checked the system property for suppressing\n+     * Indicates if we've checked the system property for suppressing\n@@ -857,1 +857,1 @@\n-     * Check whether MouseEvent contains speficied mouse button or\n+     * Check whether MouseEvent contains specified mouse button or\n@@ -864,1 +864,1 @@\n-     * @return true if the anEvent contains speficied mouseButton or\n+     * @return true if the anEvent contains specified mouseButton or\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SwingUtilities.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-     * handler for {@code process} mehtod.\n+     * Handler for {@code process} method.\n@@ -478,1 +478,1 @@\n-     * For example, the following invokations:\n+     * For example, the following invocations:\n@@ -723,1 +723,1 @@\n-         * DONE is a speacial case\n+         * DONE is a special case\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SwingWorker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-        \/\/ translate into the co-ordinate system of the pageFormat\n+        \/\/ translate into the coordinate system of the pageFormat\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/TablePrintable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-    \/\/    actionPerformed, and thus we'ld end up queing a bunch of Runnables\n+    \/\/    actionPerformed, and thus we'd end up queueing a bunch of Runnables\n@@ -441,1 +441,1 @@\n-     * @return the {@code Timer}'s intial delay, in milliseconds\n+     * @return the {@code Timer}'s initial delay, in milliseconds\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/Timer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1109,1 +1109,1 @@\n-         *              paramaters to the constructor in class c\n+         *              parameters to the constructor in class c\n@@ -1125,1 +1125,1 @@\n-         *              paramaters to the static method in class c\n+         *              parameters to the static method in class c\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/UIDefaults.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-        \/\/ Only include windows on Windows boxs.\n+        \/\/ Only include windows on Windows boxes.\n@@ -646,1 +646,1 @@\n-     * class. This value can be overriden by setting the\n+     * class. This value can be overridden by setting the\n@@ -690,1 +690,1 @@\n-     * Look and Feel (JLF).  This value can be overriden by setting the\n+     * Look and Feel (JLF).  This value can be overridden by setting the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/UIManager.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * In the Swing component set, borders supercede Insets as the\n+ * In the Swing component set, borders supersede Insets as the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/Border.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -708,1 +708,1 @@\n-51, 51, 51, \/\/ eigth row\n+51, 51, 51, \/\/ eighth row\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/colorchooser\/DefaultSwatchChooserPanel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * using the list.  It is the responsiblity of the class using the\n+ * using the list.  It is the responsibility of the class using the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/event\/EventListenerList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * and all references to rows and columns are in the co-ordinate\n+ * and all references to rows and columns are in the coordinate\n@@ -170,1 +170,1 @@\n-     * co-ordinate system. When <I>column<\/I> is ALL_COLUMNS, all cells in the\n+     * coordinate system. When <I>column<\/I> is ALL_COLUMNS, all cells in the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/event\/TableModelEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-            \/\/ overhead associated with java.io.File. Therefor we've stuck\n+            \/\/ overhead associated with java.io.File. Therefore we've stuck\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/filechooser\/FileNameExtensionFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-         * @param titleJustification the justification fro the title\n+         * @param titleJustification the justification for the title\n@@ -379,1 +379,1 @@\n-         * @param titleJustification the justification fro the title\n+         * @param titleJustification the justification for the title\n@@ -395,1 +395,1 @@\n-         * @param titleJustification the justification fro the title\n+         * @param titleJustification the justification for the title\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/BorderUIResource.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-     * @param v a {@code boolean} determining the visibilty of the popup\n+     * @param v a {@code boolean} determining the visibility of the popup\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/ComboBoxUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-         * focus, this method is overriden to return {@code false}.\n+         * focus, this method is overridden to return {@code false}.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicArrowButton.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -433,1 +433,1 @@\n-     * As of Java 2 platform v 1.4 this method should not be used or overriden.\n+     * As of Java 2 platform v 1.4 this method should not be used or overridden.\n@@ -479,1 +479,1 @@\n-    \/\/ Method signature defined here overriden in subclasses.\n+    \/\/ Method signature defined here overridden in subclasses.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicButtonUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n- * overide <code>installKeyboardActions<\/code> to add actions in response to\n+ * override <code>installKeyboardActions<\/code> to add actions in response to\n@@ -172,1 +172,1 @@\n-     * The time factor to treate the series of typed alphanumeric key\n+     * The time factor to treat the series of typed alphanumeric key\n@@ -709,1 +709,1 @@\n-    \/\/ Syncronizes the ToolTip text for the components within the combo box to be the\n+    \/\/ Synchronizes the ToolTip text for the components within the combo box to be the\n@@ -1667,1 +1667,1 @@\n-                    \/\/ forse selection of list item\n+                    \/\/ force selection of list item\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicComboBoxUI.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-    \/\/ Overriden PopupMenuListener notification methods to inform combo box\n+    \/\/ Overridden PopupMenuListener notification methods to inform combo box\n@@ -711,1 +711,1 @@\n-    \/\/ begin Event Listenters\n+    \/\/ begin Event Listeners\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicComboPopup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -495,1 +495,1 @@\n-     * busy when it is running a separate (interruptable)\n+     * busy when it is running a separate (interruptible)\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicDirectoryModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1594,1 +1594,1 @@\n-         * @param c  The component holding the data to be transfered.  This\n+         * @param c  The component holding the data to be transferred.  This\n@@ -1597,1 +1597,1 @@\n-         * @return  The representation of the data to be transfered.\n+         * @return  The representation of the data to be transferred.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicFileChooserUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-         * Overriden to return our own slimmed down style sheet.\n+         * Overridden to return our own slimmed down style sheet.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicHTML.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-     * the list is layed out horizontally.\n+     * the list is laid out horizontally.\n@@ -145,1 +145,1 @@\n-     * The time factor to treate the series of typed alphanumeric key\n+     * The time factor to treat the series of typed alphanumeric key\n@@ -1475,1 +1475,1 @@\n-     * Invoked when the list is layed out horizontally to determine how\n+     * Invoked when the list is laid out horizontally to determine how\n@@ -3031,1 +3031,1 @@\n-         * @param c  The component holding the data to be transfered.  This\n+         * @param c  The component holding the data to be transferred.  This\n@@ -3034,1 +3034,1 @@\n-         * @return  The representation of the data to be transfered.\n+         * @return  The representation of the data to be transferred.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicListUI.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -639,1 +639,1 @@\n-        \/\/ *** ProgessBar value objects\n+        \/\/ *** ProgressBar value objects\n@@ -1154,1 +1154,1 @@\n-            \/\/ You can additionaly define OptionPane.messageFont which will\n+            \/\/ You can additionally define OptionPane.messageFont which will\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicLookAndFeel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -572,1 +572,1 @@\n-        \/\/ Take into account mimimal text offset.\n+        \/\/ Take into account minimal text offset.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicMenuItemUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-     * The mininum width of {@code JOptionPane}.\n+     * The minimum width of {@code JOptionPane}.\n@@ -87,1 +87,1 @@\n-     * The mininum height of {@code JOptionPane}.\n+     * The minimum height of {@code JOptionPane}.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicOptionPaneUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.awt.event.*;\n@@ -31,1 +30,0 @@\n-import javax.swing.border.*;\n@@ -36,3 +34,0 @@\n-import java.util.Enumeration;\n-import java.util.HashSet;\n-import java.util.Set;\n@@ -58,2 +53,0 @@\n-    private KeyListener keyListener = null;\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicRadioButtonUI.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n-        \/\/ the same size and therefor can be created as CONSTANT_ASCENT.\n+        \/\/ the same size and therefore can be created as CONSTANT_ASCENT.\n@@ -1168,1 +1168,1 @@\n-        \/\/ ChangeListener: This is added to the vieport, and hsb\/vsb models.\n+        \/\/ ChangeListener: This is added to the viewport, and hsb\/vsb models.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicScrollPaneUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-    \/** Property chane listener *\/\n+    \/** Property change listener *\/\n@@ -142,1 +142,1 @@\n-     * Whther or not sameLabelBaselines is up to date.\n+     * Whether or not sameLabelBaselines is up to date.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSliderUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -425,1 +425,1 @@\n-     * overriden this method, then you'll probably want to override\n+     * overridden this method, then you'll probably want to override\n@@ -1098,1 +1098,1 @@\n-        \/\/ Syncronizes the ToolTip text for the components within the spinner\n+        \/\/ Synchronizes the ToolTip text for the components within the spinner\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSpinnerUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-        \/\/ but that could result in the layed out size being different from\n+        \/\/ but that could result in the laid out size being different from\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneDivider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1381,1 +1381,1 @@\n-        \/** Axis, 0 for horizontal, or 1 for veritcal. *\/\n+        \/** Axis, 0 for horizontal, or 1 for vertical. *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-\/\/ Transient variables (recalculated each time TabbedPane is layed out)\n+\/\/ Transient variables (recalculated each time TabbedPane is laid out)\n@@ -2882,1 +2882,1 @@\n-            \/\/ the visible compnent if the currently selected tab\n+            \/\/ the visible component if the currently selected tab\n@@ -3424,1 +3424,1 @@\n-            \/\/ the visible compnent if the currently selected tab\n+            \/\/ the visible component if the currently selected tab\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTabbedPaneUI.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-                \/\/ about unitialized values. In this case, these\n+                \/\/ about uninitialized values. In this case, these\n@@ -1447,3 +1447,3 @@\n-        \/\/ be backward compatable and try to update the row height, we're\n-        \/\/ therefor NOT going to adjust the row height based on font.  If the\n-        \/\/ developer changes the font, it's there responsability to update\n+        \/\/ be backward compatible and try to update the row height, we're\n+        \/\/ therefore NOT going to adjust the row height based on font.  If the\n+        \/\/ developer changes the font, it's their responsibility to update\n@@ -2210,1 +2210,1 @@\n-         * @param c  The component holding the data to be transfered.  This\n+         * @param c  The component holding the data to be transferred.  This\n@@ -2213,1 +2213,1 @@\n-         * @return  The representation of the data to be transfered.\n+         * @return  The representation of the data to be transferred.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTableUI.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -140,2 +140,1 @@\n-     * Creates the view for an element.  Returns a WrappedPlainView or\n-     * PlainView.\n+     * Creates a view for an element.\n@@ -144,1 +143,1 @@\n-     * @return the view\n+     * @return the view for the element\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTextAreaUI.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-     * Creates a view (FieldView) based on an element.\n+     * Creates a view for an element.\n@@ -89,1 +89,1 @@\n-     * @return the view\n+     * @return the view for the element\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTextFieldUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -946,1 +946,1 @@\n-                \/\/ Probably haven't been layed out yet, force some sort of\n+                \/\/ Probably haven't been laid out yet, force some sort of\n@@ -2483,1 +2483,1 @@\n-         * @param c  The component holding the data to be transfered.  This\n+         * @param c  The component holding the data to be transferred.  This\n@@ -2503,1 +2503,1 @@\n-         * @param comp  The component holding the data to be transfered.  This\n+         * @param comp  The component holding the data to be transferred.  This\n@@ -2506,1 +2506,1 @@\n-         * @return  The representation of the data to be transfered.\n+         * @return  The representation of the data to be transferred.\n@@ -2519,1 +2519,1 @@\n-         * the data that was transfered if the action was MOVE.\n+         * the data that was transferred if the action was MOVE.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTextUI.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-     * Overriden so that the text will not be rendered as shifted for\n+     * Overridden so that the text will not be rendered as shifted for\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicToggleButtonUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    \/** Reponsible for telling the TreeState the size needed for a node. *\/\n+    \/** Responsible for telling the TreeState the size needed for a node. *\/\n@@ -205,1 +205,1 @@\n-     * The time factor to treate the series of typed alphanumeric key\n+     * The time factor to treat the series of typed alphanumeric key\n@@ -860,3 +860,3 @@\n-        \/\/ be backward compatable and try to update the row height, we're\n-        \/\/ therefor NOT going to adjust the row height based on font.  If the\n-        \/\/ developer changes the font, it's there responsibility to update\n+        \/\/ be backward compatible and try to update the row height, we're\n+        \/\/ therefore NOT going to adjust the row height based on font.  If the\n+        \/\/ developer changes the font, it's their responsibility to update\n@@ -1179,1 +1179,1 @@\n-     * Invoked before unstallation of UI.\n+     * Invoked before uninstallation of UI.\n@@ -3681,1 +3681,1 @@\n-         * @param c  The component holding the data to be transfered.  This\n+         * @param c  The component holding the data to be transferred.  This\n@@ -3684,1 +3684,1 @@\n-         * @return  The representation of the data to be transfered.\n+         * @return  The representation of the data to be transferred.\n@@ -4838,1 +4838,1 @@\n-                    \/* Aparently people don't like wrapping;( *\/\n+                    \/* Apparently people don't like wrapping;( *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTreeUI.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-            \/\/ The preferred and minimum sizes are overriden and padded by\n+            \/\/ The preferred and minimum sizes are overridden and padded by\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalComboBoxEditor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1269,3 +1269,1 @@\n-            if (!getFileChooser().getCurrentDirectory().equals(f)) {\n-                getFileChooser().setCurrentDirectory(f);\n-            }\n+            getFileChooser().setCurrentDirectory(f);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalFileChooserUI.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-     * Overriden to create a Font with the size coming from the desktop\n+     * Overridden to create a Font with the size coming from the desktop\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalFontDesktopProperty.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -773,1 +773,1 @@\n-            \/\/ the top\/left dark higlight - some of this will get overwritten\n+            \/\/ the top\/left dark highlight - some of this will get overwritten\n@@ -966,4 +966,4 @@\n-            g.drawLine(1,0, 14,0); \/\/ top outter edge\n-            g.drawLine(15,1, 15,14); \/\/ right outter edge\n-            g.drawLine(1,15, 14,15); \/\/ bottom outter edge\n-            g.drawLine(0,1, 0,14); \/\/ left outter edge\n+            g.drawLine(1,0, 14,0); \/\/ top outer edge\n+            g.drawLine(15,1, 15,14); \/\/ right outer edge\n+            g.drawLine(1,15, 14,15); \/\/ bottom outer edge\n+            g.drawLine(0,1, 0,14); \/\/ left outer edge\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalIconFactory.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-        \/\/ only. When we needs to call revalidate\/repaint with other styles\n+        \/\/ only. When we need to call revalidate\/repaint with other styles\n@@ -318,1 +318,1 @@\n-        \/\/ imediatly and it will cause the revalidate\/repaint at the proper\n+        \/\/ immediately and it will cause the revalidate\/repaint at the proper\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalRootPaneUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-                            \/\/ by simply swaping the i and j axis.\n+                            \/\/ by simply swapping the i and j axis.\n@@ -271,1 +271,1 @@\n-                            \/\/ by simply swaping the i and j axis.\n+                            \/\/ by simply swapping the i and j axis.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalSplitPaneDivider.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    \/\/ Contants identifying the various Fonts that are Theme can support\n+    \/\/ Constants identifying the various Fonts that a Theme can support\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalTheme.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-     * Overriden to enable picking up the system fonts, if applicable.\n+     * Overridden to enable picking up the system fonts, if applicable.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/OceanTheme.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-            \/\/ can not give a right answer as painter sould not be used outside\n+            \/\/ cannot give the right answer as painter should not be used outside\n@@ -460,1 +460,1 @@\n-                    \/\/This could be a normal occurance if you use a property\n+                    \/\/This could be a normal occurrence if you use a property\n@@ -648,1 +648,1 @@\n-                \/\/ todo: destination inserts need to take into acount scale factor for high dpi. Note: You can use f for this, I think\n+                \/\/ todo: destination inserts need to take into account scale factor for high dpi. Note: You can use f for this, I think\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/AbstractRegionPainter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-     * @return The opactity for the effect, 0.0f -> 1.0f\n+     * @return The opacity for the effect, 0.0f -> 1.0f\n@@ -66,1 +66,1 @@\n-     * @param dst The dstination image to paint effect result into. If this is null then a new image will be created\n+     * @param dst The destination image to paint effect result into. If this is null then a new image will be created\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/Effect.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-     * @param dst    The destination image to draw blured src image into, null if you want a new one created\n+     * @param dst    The destination image to draw blurred src image into, null if you want a new one created\n@@ -65,1 +65,1 @@\n-     * @return The blured image\n+     * @return The blurred image\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/EffectUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-            \/\/ finaly put new in map\n+            \/\/ finally put new in map\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/ImageCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-     * Paints using the algorightm specified by <code>paintType<\/code>.\n+     * Paints using the algorithm specified by <code>paintType<\/code>.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/ImageScalingHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-     * @param dst The dstination image to paint effect result into. If this is null then a new image will be created\n+     * @param dst The destination image to paint effect result into. If this is null then a new image will be created\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/InnerShadowEffect.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -513,1 +513,1 @@\n-     * example \"Button.background\" --> \"Button[Enabled].backgound\"\n+     * example \"Button.background\" --> \"Button[Enabled].background\"\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/NimbusLookAndFeel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -339,1 +339,1 @@\n-            \/\/states. I do need to popuplate this temp list now though, so that\n+            \/\/states. I do need to populate this temp list now though, so that\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/NimbusStyle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-        \/\/ Don't RTL flip JSpliders as they handle it internaly\n+        \/\/ Don't RTL flip JSliders as they handle it internally\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/SynthPainterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-     * I would prefer to use UIResource instad of this.\n+     * I would prefer to use UIResource instead of this.\n@@ -201,1 +201,1 @@\n-        \/\/ Overriden to do nothing, all our painting is done from update\/paint.\n+        \/\/ Overridden to do nothing, all our painting is done from update\/paint.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthEditorPaneUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-     * A convience method that will reset the Style of StyleContext if\n+     * A convenience method that will reset the Style of StyleContext if\n@@ -731,0 +731,2 @@\n+        table.put(\"PasswordField.echoChar\", '*');\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthLookAndFeel.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-            \/\/ we should update the maximal text witdh\n+            \/\/ we should update the maximal text width\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthMenuItemLayoutHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,2 +127,2 @@\n-     * understand. This is used when forwarding to beans persistance to know\n-     * when we hsould stop forwarding.\n+     * understand. This is used when forwarding to beans persistence to know\n+     * when we should stop forwarding.\n@@ -165,1 +165,1 @@\n-     * Object references outside the scope of persistance.\n+     * Object references outside the scope of persistence.\n@@ -284,1 +284,1 @@\n-     * Returns true if we are forwarding to persistance.\n+     * Returns true if we are forwarding to persistence.\n@@ -291,1 +291,1 @@\n-     * Handles beans persistance.\n+     * Handles beans persistence.\n@@ -667,1 +667,1 @@\n-            throw new SAXException(\"color: you must specificy a value\");\n+            throw new SAXException(\"color: you must specify a value\");\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthParser.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -70,0 +70,13 @@\n+    \/**\n+     * Installs the necessary properties on the JPasswordField.\n+     *\/\n+    @Override\n+    protected void installDefaults() {\n+        super.installDefaults();\n+        String prefix = getPropertyPrefix();\n+        Character echoChar = (Character)UIManager.getDefaults().get(prefix + \".echoChar\");\n+        if (echoChar != null) {\n+            LookAndFeel.installProperty(getComponent(), \"echoChar\", echoChar);\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthPasswordFieldUI.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * represents the size of the slider the last time it was layed out.\n+     * represents the size of the slider the last time it was laid out.\n@@ -65,1 +65,1 @@\n-     * the slider has not changed sizes since being last layed out. If necessary\n+     * the slider has not changed sizes since being last laid out. If necessary\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthSliderUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-     * overriden this method, then you'll probably want to override\n+     * overridden this method, then you'll probably want to override\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthSpinnerUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+    private Color dividerDraggingColor;\n+\n@@ -92,0 +94,2 @@\n+        dividerDraggingColor = UIManager.getColor(\"SplitPaneDivider.draggingColor\");\n+\n@@ -259,0 +263,13 @@\n+    private void setDividerDraggingColor(Graphics g, int loc) {\n+        if (!isContinuousLayout() && getLastDragLocation() != -1 &&\n+               dividerDraggingColor != null) {\n+\n+            g.setColor(dividerDraggingColor);\n+            if (getOrientation() == JSplitPane.HORIZONTAL_SPLIT) {\n+                g.fillRect(loc, 0, dividerSize - 1, splitPane.getHeight() - 1);\n+            } else {\n+                g.fillRect(0, loc, splitPane.getWidth() - 1, dividerSize - 1);\n+            }\n+        }\n+    }\n+\n@@ -268,0 +285,1 @@\n+                setDividerDraggingColor(g, 0);\n@@ -348,0 +366,1 @@\n+\n@@ -350,0 +369,1 @@\n+\n@@ -357,0 +377,1 @@\n+            setDividerDraggingColor(g, getLastDragLocation());\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthSplitPaneUI.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -782,0 +782,8 @@\n+            } else if (c instanceof JCheckBox) {\n+                if (UIManager.getColor(\"CheckBox.disabledText\") != null) {\n+                    return UIManager.getColor(\"CheckBox.disabledText\");\n+                }\n+            } else if (c instanceof JRadioButton) {\n+                if (UIManager.getColor(\"RadioButton.disabledText\") != null) {\n+                    return UIManager.getColor(\"RadioButton.disabledText\");\n+                }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthStyle.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-     * while a negative overlap indicates tha tabs should overlap left\/up.<\/p>\n+     * while a negative overlap indicates that tabs should overlap left\/up.<\/p>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthTabbedPaneUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-        \/\/ Overriden to do nothing, all our painting is done from update\/paint.\n+        \/\/ Overridden to do nothing, all our painting is done from update\/paint.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthTextAreaUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        \/\/ Overriden to do nothing, all our painting is done from update\/paint.\n+        \/\/ Overridden to do nothing, all our painting is done from update\/paint.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthTextFieldUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-        \/\/ a border to be set. JViewport.setBorder is overriden to throw\n+        \/\/ a border to be set. JViewport.setBorder is overridden to throw\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthViewportUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -637,1 +637,1 @@\n-      <td>How the buttons should be layed out, one of\n+      <td>How the buttons should be laid out, one of\n@@ -1295,1 +1295,1 @@\n-from where it would normally be layed out. This is \t    only used when\n+from where it would normally be laid out. This is \t    only used when\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/doc-files\/componentProperties.html","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -532,1 +532,1 @@\n-      <dd>Identifer of a previously defined SynthGraphicsUtils object\n+      <dd>Identifier of a previously defined SynthGraphicsUtils object\n@@ -876,3 +876,3 @@\n-      <dd>Path to the image. Path to the image.  If SynthLookAndFeel.load is\n-    passed a Class this will use the Class method getResource (with with the\n-    Class suplied to the load method). If load is passed a URL this will use the\n+      <dd>Path to the image.  If SynthLookAndFeel.load is\n+    passed a Class this will use the Class method getResource (with the\n+    Class supplied to the load method). If load is passed a URL this will use the\n@@ -1003,1 +1003,1 @@\n-      Beans persistance can be used to embed any Object. This is\n+      Beans persistence can be used to embed any Object. This is\n@@ -1005,1 +1005,1 @@\n-      for other arbritrary objects as well. Refer to <a\n+      for other arbitrary objects as well. Refer to <a\n@@ -1008,1 +1008,1 @@\n-      for details on beans persistance.\n+      for details on beans persistence.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/doc-files\/synthFileFormat.html","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * {@code Region} and therefor only one {@code SynthStyle}. {@code SynthStyle}\n+ * {@code Region} and therefore only one {@code SynthStyle}. {@code SynthStyle}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-     * Returns an array of indicies of all selected columns.\n-     * @return an array of integers containing the indicies of all\n+     * Returns an array of indices of all selected columns.\n+     * @return an array of integers containing the indices of all\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/table\/TableColumnModel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1280,1 +1280,1 @@\n-                    \/\/ this may overwrite anothers threads cached\n+                    \/\/ this may overwrite another threads cached\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/AsyncBoxView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -754,1 +754,1 @@\n-     * @param axis the axis being layed out\n+     * @param axis the axis being laid out\n@@ -827,1 +827,1 @@\n-     * @param axis the axis being layed out\n+     * @param axis the axis being laid out\n@@ -1119,1 +1119,1 @@\n-     * are layed out from left to right, so that the <code>View<\/code>\n+     * are laid out from left to right, so that the <code>View<\/code>\n@@ -1127,1 +1127,1 @@\n-     * indicating the <code>View<\/code>s are layed out in\n+     * indicating the <code>View<\/code>s are laid out in\n@@ -1129,1 +1129,1 @@\n-     * indicating the <code>View<\/code>s are layed out in ascending order.\n+     * indicating the <code>View<\/code>s are laid out in ascending order.\n@@ -1143,1 +1143,1 @@\n-     *          are layed out in descending order; otherwise false\n+     *          are laid out in descending order; otherwise false\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/BoxView.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n- *     <code>childAllocation<\/code> after offseting\n+ *     <code>childAllocation<\/code> after offsetting\n@@ -766,1 +766,1 @@\n-     * <code>View<\/code>s are layed out from left to right,\n+     * <code>View<\/code>s are laid out from left to right,\n@@ -775,1 +775,1 @@\n-     * <code>View<\/code>s are layed out in descending order.\n+     * <code>View<\/code>s are laid out in descending order.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/CompositeView.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-     * navigating throught the field.\n+     * navigating through the field.\n@@ -663,1 +663,1 @@\n-         * the cursor position is adusted from this position.\n+         * the cursor position is adjusted from this position.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultFormatter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -592,1 +592,1 @@\n-     * is cretaed. When a number of ranges should be damaged\n+     * is created. When a number of ranges should be damaged\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultHighlighter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2275,1 +2275,1 @@\n-                \/\/ Create the newChild, a duplicate of the elment at\n+                \/\/ Create the newChild, a duplicate of the element at\n@@ -2281,1 +2281,1 @@\n-                \/\/ if at end of fracture, or offseting index.\n+                \/\/ if at end of fracture, or offsetting index.\n@@ -2433,1 +2433,1 @@\n-                \/\/ Update index incase something added\/removed.\n+                \/\/ Update index in case something added\/removed.\n@@ -2456,1 +2456,1 @@\n-                \/\/ else nothin to do.\n+                \/\/ else nothing to do.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultStyledDocument.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -538,1 +538,1 @@\n-     * &nbsp;     \/\/ do someting with text\n+     * &nbsp;     \/\/ do something with text\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/Document.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-     * Overridden to make growth policy less agressive for large\n+     * Overridden to make growth policy less aggressive for large\n@@ -774,1 +774,1 @@\n-        \/\/ Find the indexs of the end points.\n+        \/\/ Find the indices of the end points.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/GapContent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1028,1 +1028,1 @@\n-        \/\/we parse conent to the right of the rightmost TAB only.\n+        \/\/we parse content to the right of the rightmost TAB only.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/GlyphView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-     * also kept upto date with the non-literal characters, that is\n+     * also kept up to date with the non-literal characters, that is\n@@ -583,1 +583,1 @@\n-     * Overriden to update the mask after invoking supers implementation.\n+     * Overridden to update the mask after invoking supers implementation.\n@@ -591,1 +591,1 @@\n-     * Overriden to unconditionally allow the replace if\n+     * Overridden to unconditionally allow the replace if\n@@ -625,1 +625,1 @@\n-     * Overriden in an attempt to honor the literals.\n+     * Overridden in an attempt to honor the literals.\n@@ -779,1 +779,1 @@\n-     * Updates the interal bitset from <code>iterator<\/code>. This will\n+     * Updates the internal bitset from <code>iterator<\/code>. This will\n@@ -952,1 +952,1 @@\n-     * Overriden to return an instance of <code>ExtendedReplaceHolder<\/code>.\n+     * Overridden to return an instance of <code>ExtendedReplaceHolder<\/code>.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/InternationalFormatter.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3690,1 +3690,1 @@\n-         * two indicies.\n+         * two indices.\n@@ -3961,1 +3961,1 @@\n-     * <code>processInputMethodEvent<\/code> has been overriden.\n+     * <code>processInputMethodEvent<\/code> has been overridden.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/JTextComponent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -698,1 +698,1 @@\n-     * This is overriden to return true for a partial match.\n+     * This is overridden to return true for a partial match.\n@@ -724,1 +724,1 @@\n-     *     the literals.  For example, in pasing in 5551212 into ###-####\n+     *     the literals.  For example, in passing in 5551212 into ###-####\n@@ -834,1 +834,1 @@\n-    \/\/ Interal classes used to represent the mask.\n+    \/\/ Internal classes used to represent the mask.\n@@ -847,1 +847,1 @@\n-         * Returns true if <code>aChar<\/code> is a valid reprensentation of\n+         * Returns true if <code>aChar<\/code> is a valid representation of\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/MaskFormatter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-            \/\/ Don't skip the decimal, it causes wierd behavior\n+            \/\/ Don't skip the decimal, it causes weird behavior\n@@ -353,1 +353,1 @@\n-     * Overriden to toggle the value if the positive\/minus sign\n+     * Overridden to toggle the value if the positive\/minus sign\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/NumberFormatter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-     * @param ls the value is a factor of the line hight\n+     * @param ls the value is a factor of the line height\n@@ -307,1 +307,1 @@\n-     * Typically the <code>View<\/code>s are layed out\n+     * Typically the <code>View<\/code>s are laid out\n@@ -317,1 +317,1 @@\n-     * layed out in descending order.\n+     * laid out in descending order.\n@@ -319,1 +319,1 @@\n-     * This will return true if the text is layed out right\n+     * This will return true if the text is laid out right\n@@ -325,1 +325,1 @@\n-     * @return true if the text is layed out right to left at\n+     * @return true if the text is laid out right to left at\n@@ -934,1 +934,1 @@\n-         * @param axis the axis being layed out.\n+         * @param axis the axis being laid out.\n@@ -1140,1 +1140,1 @@\n-            \/\/ This is expensive, but are views are not necessarily layed\n+            \/\/ This is expensive, but are views are not necessarily laid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/ParagraphView.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * This exception is to report the failure of state invarient\n+ * This exception is to report the failure of state invariant\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/StateInvariantError.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -339,1 +339,1 @@\n-     * this... so this class trys to hack a solution\n+     * this... so this class tries to hack a solution\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/StringContent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -608,1 +608,1 @@\n-     * have been registered wit the\n+     * have been registered with the\n@@ -807,1 +807,1 @@\n-     * when held in the compact sharable form.\n+     * when held in the compact shareable form.\n@@ -1038,1 +1038,1 @@\n-         * If not overriden, the resolving parent defaults to\n+         * If not overridden, the resolving parent defaults to\n@@ -1535,1 +1535,1 @@\n-         * If not overriden, the resolving parent defaults to\n+         * If not overridden, the resolving parent defaults to\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/StyleContext.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-     * @param axis the axis being layed out.\n+     * @param axis the axis being laid out.\n@@ -408,1 +408,1 @@\n-     * column requirements are not satisified, the needs of the\n+     * column requirements are not satisfied, the needs of the\n@@ -724,1 +724,1 @@\n-         * @param axis the axis being layed out.\n+         * @param axis the axis being laid out.\n@@ -768,1 +768,1 @@\n-         * @param axis the axis being layed out.\n+         * @param axis the axis being laid out.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/TableView.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1251,1 +1251,1 @@\n-     * This implementation assumes the views are layed out in a logical\n+     * This implementation assumes the views are laid out in a logical\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/Utilities.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-        \/\/ if the parent is null then propogate down the view tree\n+        \/\/ if the parent is null then propagate down the view tree\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/View.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-            \/\/ should damge a little more intelligently.\n+            \/\/ should damage a little more intelligently.\n@@ -658,1 +658,1 @@\n-     * fit withing the horizontal space allocated.\n+     * fit within the horizontal space allocated.\n@@ -660,2 +660,2 @@\n-     * state of it's own and sharing the state of the outer class\n-     * with it's sibblings.\n+     * state of its own and sharing the state of the outer class\n+     * with its siblings.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/WrappedPlainView.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-     * obtained a key will be retured that should be passed to\n+     * obtained a key will be returned that should be passed to\n@@ -945,1 +945,1 @@\n-             * Return the number of characters (valid indicies)\n+             * Return the number of characters (valid indices)\n@@ -1429,1 +1429,1 @@\n-         * Overriden to update the grid when validating.\n+         * Overridden to update the grid when validating.\n@@ -1437,1 +1437,1 @@\n-         * Overriden to only alloc instances of TableRowElementInfos.\n+         * Overridden to only alloc instances of TableRowElementInfos.\n@@ -2474,1 +2474,1 @@\n-             * Overriden to invalidate the table as well as\n+             * Overridden to invalidate the table as well as\n@@ -2616,1 +2616,1 @@\n-             * Overriden to invalidate the TableRowElementInfo as well as\n+             * Overridden to invalidate the TableRowElementInfo as well as\n@@ -2682,1 +2682,1 @@\n-         * will be invoked within a <code>readLock<\/code>. If this is overriden\n+         * will be invoked within a <code>readLock<\/code>. If this is overridden\n@@ -2990,1 +2990,1 @@\n-                    \/\/ Elements that represented this, so, we should foward\n+                    \/\/ Elements that represented this, so, we should forward\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/AccessibleHTML.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-     * @param axis the axis being layed out\n+     * @param axis the axis being laid out\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/BlockView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1065,1 +1065,1 @@\n-     * The hashtable and the static initalization block below,\n+     * The hashtable and the static initialization block below,\n@@ -1775,1 +1775,1 @@\n-     * is intended to act as a convertor to\/from other attribute\n+     * is intended to act as a converter to\/from other attribute\n@@ -1779,3 +1779,3 @@\n-     * a string to whatever format is appropriate a given key\n-     * (i.e. these convertors are stored in a map using the\n-     * CSS.Attribute as a key and the CssValue as the value).\n+     * a string to whatever format is appropriate for a given key\n+     * (i.e. these converters are stored in a map using the\n+     * CSS.Attribute as the key and the CssValue as the value).\n@@ -3254,1 +3254,1 @@\n-         * <code>names<\/code> give the 4 instrinsic property names.\n+         * <code>names<\/code> give the 4 intrinsic property names.\n@@ -3625,1 +3625,1 @@\n-     * we need StyleSheet for resolving lenght units. (see\n+     * we need StyleSheet for resolving length units. (see\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/CSS.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-     * Negative factor values decrease brigthness (ie, 1.0 turns into black).\n+     * Negative factor values decrease brightness (ie, 1.0 turns into black).\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/CSSBorder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-        \/\/ PENDING: make this more effecient.\n+        \/\/ PENDING: make this more efficient.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/CSSParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-     * @param axis the axis being layed out\n+     * @param axis the axis being laid out\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/FrameSetView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1403,1 +1403,1 @@\n-                \/\/ section, it is necessary to set the corrsponding flag.\n+                \/\/ section, it is necessary to set the corresponding flag.\n@@ -2393,1 +2393,1 @@\n-         * a BadLocationException when API changes are alloced) if inserting\n+         * a BadLocationException when API changes are allocated) if inserting\n@@ -2804,1 +2804,1 @@\n-                    \/\/ this is needed incase an implied-p is needed. If\n+                    \/\/ this is needed in case an implied-p is needed. If\n@@ -4041,1 +4041,1 @@\n-                \/\/ This attemps to clean it up.\n+                \/\/ This attempts to clean it up.\n@@ -4340,1 +4340,1 @@\n-         * used alot, it is cached. *\/\n+         * used a lot, it is cached. *\/\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLDocument.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n- * be overriden to change this.  The batching of work is done\n+ * be overridden to change this.  The batching of work is done\n@@ -1419,1 +1419,1 @@\n-                    \/\/ getNextVisualPositionFrom is overriden to always return\n+                    \/\/ getNextVisualPositionFrom is overridden to always return\n@@ -2462,1 +2462,1 @@\n-         * obtained a key will be retured that should be passed to\n+         * obtained a key will be returned that should be passed to\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLEditorKit.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -815,1 +815,1 @@\n-            \/\/ Have to output any tags after firstIndex that still remaing,\n+            \/\/ Have to output any tags after firstIndex that still remaining,\n@@ -1195,1 +1195,1 @@\n-     * Writes the line separator. This is overriden to make sure we don't\n+     * Writes the line separator. This is overridden to make sure we don't\n@@ -1208,1 +1208,1 @@\n-     * This method is overriden to map any character entities, such as\n+     * This method is overridden to map any character entities, such as\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-     * <code>ALT<\/code> attribute. This is overriden to return\n+     * <code>ALT<\/code> attribute. This is overridden to return\n@@ -976,1 +976,1 @@\n-                        \/\/ initialy synchronize\n+                        \/\/ initially synchronize\n@@ -1056,1 +1056,1 @@\n-     * the attribute specified an alt attribute. It overriden a handle of\n+     * the attribute specified an alt attribute. It overridden a handle of\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/ImageView.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-     * @throws IOException if I\/O error occured.\n+     * @throws IOException if I\/O error occurred.\n@@ -414,1 +414,1 @@\n-     * @throws IOException if I\/O error occured.\n+     * @throws IOException if I\/O error occurred.\n@@ -436,1 +436,1 @@\n-     * @param needsIndenting indention will be added if {@code needsIndenting} is {@code true}\n+     * @param needsIndenting indentation will be added if {@code needsIndenting} is {@code true}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/MinimalHTMLWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-           to their cannonical values so that the next set command always works\n+           to their canonical values so that the next set command always works\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/OptionListModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n- * The semantics for when a CSS style should overide visual attributes\n+ * The semantics for when a CSS style should override visual attributes\n@@ -346,1 +346,1 @@\n-     * @throws java.io.IOException if I\/O error occured.\n+     * @throws java.io.IOException if I\/O error occurred.\n@@ -1821,2 +1821,0 @@\n-    static final Border noBorder = new EmptyBorder(0,0,0,0);\n-\n@@ -2247,1 +2245,1 @@\n-            \/\/ deside on what side draw bullets, etc.\n+            \/\/ decide on what side draw bullets, etc.\n@@ -2522,1 +2520,0 @@\n-        URL imageurl;\n@@ -2850,1 +2847,1 @@\n-         * If not overriden, the resolving parent defaults to\n+         * If not overridden, the resolving parent defaults to\n@@ -3226,2 +3223,0 @@\n-    static final int DEFAULT_FONT_SIZE = 3;\n-\n@@ -3358,1 +3353,1 @@\n-                    \/\/ general mechanism is definately needed.\n+                    \/\/ general mechanism is definitely needed.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/StyleSheet.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -387,1 +387,1 @@\n-     * column requirements are not satisified, the needs of the\n+     * column requirements are not satisfied, the needs of the\n@@ -636,1 +636,1 @@\n-     * @param axis the axis being layed out\n+     * @param axis the axis being laid out\n@@ -679,1 +679,1 @@\n-     * @param axis the axis being layed out\n+     * @param axis the axis being laid out\n@@ -1527,1 +1527,1 @@\n-         * @param axis the axis being layed out\n+         * @param axis the axis being laid out\n@@ -1578,1 +1578,1 @@\n-         * @param axis the axis being layed out\n+         * @param axis the axis being laid out\n@@ -1720,1 +1720,1 @@\n-         * @param axis the axis being layed out\n+         * @param axis the axis being laid out\n@@ -1773,1 +1773,1 @@\n-         * @param axis the axis being layed out.\n+         * @param axis the axis being laid out.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/TableView.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -548,1 +548,1 @@\n-           <font> tag in the context of <ul> and <ol> We additonally\n+           <font> tag in the context of <ul> and <ol> We additionally\n@@ -690,1 +690,1 @@\n-        \/\/ close out the tags by outputing end tags and then\n+        \/\/ close out the tags by outputting end tags and then\n@@ -706,0 +706,6 @@\n+                } else if (s.terminate()) {\n+                    \/\/ Since the current tag is not valid in current context\n+                    \/\/ as otherwise s.advance(elem) would have returned true\n+                    \/\/ so check if the stack is to be terminated\n+                    \/\/ in which case return false\n+                    return false;\n@@ -807,1 +813,1 @@\n-        \/\/ Avoid putting something wierd in the head of the document.\n+        \/\/ Avoid putting something weird in the head of the document.\n@@ -1636,1 +1642,1 @@\n-        \/\/ ignore all data upto the close bracket '>'\n+        \/\/ ignore all data up to the close bracket '>'\n@@ -1910,1 +1916,1 @@\n-                \/\/ Since closing out a center tag can have real wierd\n+                \/\/ Since closing out a center tag can have real weird\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/parser\/Parser.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n- * the stack, when an end tag is enountered an element is popped\n- * of the stack.\n+ * the stack, when an end tag is encountered an element is popped\n+ * off the stack.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/parser\/TagStack.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-    \/\/ Local methods that subclassers may wish to use that are primarly\n+    \/\/ Local methods that subclassers may wish to use that are primarily\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/tree\/AbstractLayoutCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * a <code>TreeCellEditor<\/code> that will be layed out according\n+ * a <code>TreeCellEditor<\/code> that will be laid out according\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/tree\/DefaultTreeCellEditor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-     * @param node the node to be removed from it's parrent\n+     * @param node the node to be removed from its parent\n@@ -352,1 +352,1 @@\n-      * @param childIndices     indexes of removed childs\n+      * @param childIndices     indexes of removed children\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/tree\/DefaultTreeModel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -914,1 +914,1 @@\n-                            \/\/ find the actual selection pathes corresponded to the\n+                            \/\/ find the actual selection paths corresponded to the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/tree\/DefaultTreeSelectionModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-     * Ensures that all the path components in path are expanded, accept\n+     * Ensures that all the path components in path are expanded, except\n@@ -648,1 +648,1 @@\n-     * Returns true if succesful in finding the path.\n+     * Returns true if successful in finding the path.\n@@ -772,1 +772,1 @@\n-        \/\/ Overriden DefaultMutableTreeNode methods\n+        \/\/ Overridden DefaultMutableTreeNode methods\n@@ -1093,1 +1093,1 @@\n-        \/\/ the number of children). I prefer this though, making determing\n+        \/\/ the number of children). I prefer this though, making determining\n@@ -1276,1 +1276,1 @@\n-         * Adjusts the child indexs of the receivers children by\n+         * Adjusts the child indices of the receivers children by\n@@ -1484,1 +1484,1 @@\n-        \/** Parent thats children are being enumerated. *\/\n+        \/** Parent whose children are being enumerated. *\/\n@@ -1538,1 +1538,1 @@\n-         * and if not succesful <code>findNextValidParent<\/code>.\n+         * and if not successful <code>findNextValidParent<\/code>.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/tree\/FixedHeightLayoutCache.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-                   child indexs that are passed in. *\/\n+                   child indices that are passed in. *\/\n@@ -433,1 +433,1 @@\n-                    \/\/ Null indicies for root indicates it changed.\n+                    \/\/ Null indices for root indicates it changed.\n@@ -697,1 +697,1 @@\n-     * Retursn the bounds for row, <code>row<\/code> by reference in\n+     * Returns the bounds for row, <code>row<\/code> by reference in\n@@ -754,1 +754,1 @@\n-      * cells, nor update the selection if it needs to be.  If succesful\n+      * cells, nor update the selection if it needs to be.  If successful\n@@ -889,1 +889,1 @@\n-      * automaticly adjusts the locations.\n+      * automatically adjusts the locations.\n@@ -951,1 +951,1 @@\n-     * Returns true if succesful in finding the path.\n+     * Returns true if successful in finding the path.\n@@ -1038,1 +1038,1 @@\n-        \/\/ Overriden DefaultMutableTreeNode methods\n+        \/\/ Overridden DefaultMutableTreeNode methods\n@@ -1618,1 +1618,1 @@\n-        \/** Parent thats children are being enumerated. *\/\n+        \/** Parent whose children are being enumerated. *\/\n@@ -1668,1 +1668,1 @@\n-         * and if not succesful <code>findNextValidParent<\/code>.\n+         * and if not successful <code>findNextValidParent<\/code>.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/tree\/VariableHeightLayoutCache.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-     * Retreives the value from the defaults table with key\n+     * Retrieves the value from the defaults table with key\n@@ -241,1 +241,1 @@\n-     * Retreives the value from the defaults table with key\n+     * Retrieves the value from the defaults table with key\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/undo\/AbstractUndoableEdit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-    \/\/ These three functions consitute RFE 4100710. Do not remove.\n+    \/\/ These three functions constitute RFE 4100710. Do not remove.\n@@ -418,1 +418,1 @@\n-     * for ususal, non-embedded components.\n+     * for usual, non-embedded components.\n@@ -483,1 +483,1 @@\n-     * for ususal, non-embedded components.\n+     * for usual, non-embedded components.\n@@ -540,1 +540,1 @@\n-     * This method should be overriden in subclasses. It is\n+     * This method should be overridden in subclasses. It is\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/EmbeddedFrame.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-                \/\/ case, we'll just use the originial heavyweight.\n+                \/\/ case, we'll just use the original heavyweight.\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/GlobalCursorManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-     * @Depricated replaced by {@link #getScaleFactorX()} and\n+     * @Deprecated replaced by {@link #getScaleFactorX()} and\n@@ -174,1 +174,1 @@\n-     * @Depricated replaced by {@link #notifyDisplayChanged(double, double)}\n+     * @Deprecated replaced by {@link #notifyDisplayChanged(double, double)}\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/LightweightFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * component willl still receive it's events.\n+ * component will still receive its events.\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/ModalExclude.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-        \/\/ coversion loop\n+        \/\/ conversion loop\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/PlatformFont.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1480,2 +1480,2 @@\n-     * serie of paint events, a serie of Java focus events, which then\n-     * generate a serie of paint events which then are processed -\n+     * series of paint events, a series of Java focus events, which then\n+     * generate a series of paint events which then are processed -\n@@ -1537,1 +1537,1 @@\n-            \/\/ resulted in native requests?  Therefor, check native events again.\n+            \/\/ resulted in native requests?  Therefore, check native events again.\n@@ -1979,1 +1979,1 @@\n-     * the X11 systems. On MS Windows this method is overriden in WToolkit\n+     * the X11 systems. On MS Windows this method is overridden in WToolkit\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/SunToolkit.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-     * to be publically exposing this class, so no need to waste work\n+     * to be publicly exposing this class, so no need to waste work\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/Symbol.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-            throw new InvalidDnDOperationException(\"only ACTION_LINK is permissable for transfer of java.rmi.Remote objects\");\n+            throw new InvalidDnDOperationException(\"only ACTION_LINK is permissible for transfer of java.rmi.Remote objects\");\n@@ -284,1 +284,1 @@\n-            throw new IOException(\"no native data was transfered\");\n+            throw new IOException(\"no native data was transferred\");\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/dnd\/SunDropTargetContextPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -584,1 +584,1 @@\n-             * values and chop out a miniscule curve piece.\n+             * values and chop out a minuscule curve piece.\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/geom\/Order3.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n- * {@code ExecutableInputMethodManager} and executes it as a deamon\n+ * {@code ExecutableInputMethodManager} and executes it as a daemon\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/im\/ExecutableInputMethodManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    \/\/ the current client component is kept until the user focusses on a different\n+    \/\/ the current client component is kept until the user focuses on a different\n@@ -785,2 +785,2 @@\n-     * Turns off the native IM. The native IM is diabled when\n-     * the deactive method of InputMethod is called. It is\n+     * Turns off the native IM. The native IM is disabled when\n+     * the deactivate method of InputMethod is called. It is\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/im\/InputContext.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-        \/\/ REMIND:  Be careful!  Is this called everytime there is a\n+        \/\/ REMIND:  Be careful!  Is this called every time there is a\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/ImageRepresentation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-     * Returned value indicates whether the library initailization was\n-     * succeded.\n+     * Returned value indicates whether the library initialization\n+     * succeeded.\n@@ -71,1 +71,1 @@\n-     * There could be number of reasons to failure:\n+     * There could be a number of reasons for failure:\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/ImagingLib.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-     * Origin is the coodinate in the new Raster's coordinate system of\n+     * Origin is the coordinate in the new Raster's coordinate system of\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/IntegerComponentRaster.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-     * Origin is the coodinate in the new Raster's coordinate system of\n+     * Origin is the coordinate in the new Raster's coordinate system of\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/IntegerInterleavedRaster.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-     * Origin is the coodinate in the new Raster's coordinate system of\n+     * Origin is the coordinate in the new Raster's coordinate system of\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/ShortComponentRaster.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-     * Origin is the coodinate in the new Raster's coordinate system of\n+     * Origin is the coordinate in the new Raster's coordinate system of\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/ShortInterleavedRaster.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-     * Tracks loss of surface contents; queriable by user to see whether\n+     * Tracks loss of surface contents; queryable by user to see whether\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/VolatileSurfaceManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -513,1 +513,1 @@\n-     * from its {@code call} method. If invokation is interrupted then Thread.currentThread().isInterrupted() will\n+     * from its {@code call} method. If invocation is interrupted then Thread.currentThread().isInterrupted() will\n@@ -526,1 +526,1 @@\n-     * If invokation is interrupted then Thread.currentThread().isInterrupted() will\n+     * If invocation is interrupted then Thread.currentThread().isInterrupted() will\n@@ -564,1 +564,1 @@\n-         * @return the result of {@code task}'s invokation\n+         * @return the result of {@code task}'s invocation\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/shell\/ShellFolder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -580,1 +580,1 @@\n-             * However, benefits are neglible and some fonts have incorrect\n+             * However, benefits are negligible and some fonts have incorrect\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CMap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-            \/\/ NOTE:  The performace of the following code may\n+            \/\/ NOTE:  The performance of the following code may\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/Decoration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-     * to distingish these. Possibly if a user adds fonts to the JRE font\n+     * to distinguish these. Possibly if a user adds fonts to the JRE font\n@@ -105,1 +105,1 @@\n-     * strike obtained from this Font2D satifies the needs of the next\n+     * strike obtained from this Font2D satisfies the needs of the next\n@@ -257,1 +257,1 @@\n-     * required with its attendant consequences for MP scaleability.\n+     * required with its attendant consequences for MP scalability.\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/Font2D.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * Once all referers no longer have a reference to the Font2D it\n+ * Once all referrers no longer have a reference to the Font2D it\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/Font2DHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-     * Therefore this is very convinient place to register\n+     * Therefore this is very convenient place to register\n@@ -119,1 +119,1 @@\n-     * syncronized keyword is not needed.\n+     * synchronized keyword is not needed.\n@@ -132,1 +132,1 @@\n-    protected long nativeScaler = 0; \/\/used by decendants\n+    protected long nativeScaler = 0; \/\/used by descendants\n@@ -152,1 +152,1 @@\n-     *   GlyphInfo object. Because Strike and drawing releated logic does\n+     *   GlyphInfo object. Because Strike and drawing related logic does\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontScaler.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-     * @return the layed out glyphvector, if result was passed in, it is returned\n+     * @return the laid out glyphvector, if result was passed in, it is returned\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * to be very lightweight and finalization is a comparitively expensive\n+ * to be very lightweight and finalization is a comparatively expensive\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * particular, Hiragana, Katakana, and Han characters will appear in seperate\n+ * particular, Hiragana, Katakana, and Han characters will appear in separate\n@@ -92,1 +92,1 @@\n-     * of the given characetrs.\n+     * of the given characters.\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/ScriptRun.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-     * is requested and the surface is some non-standard type or hardward\n+     * is requested and the surface is some non-standard type or hardware\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StandardGlyphVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-For scaleability and ease of use, a key goal is multi-threaded read\n+For scalability and ease of use, a key goal is multi-threaded read\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StrikeCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1689,1 +1689,1 @@\n-     * the isAbsolute() check is needed since that's whats stored in the\n+     * the isAbsolute() check is needed since that's what's stored in the\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/SunFontManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n- * An instance stores some information from the font file to faciliate\n+ * An instance stores some information from the font file to facilitate\n@@ -63,1 +63,1 @@\n- * for a typical font. Systems with mutiple locales sometimes have up to 400\n+ * for a typical font. Systems with multiple locales sometimes have up to 400\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/TrueTypeFont.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-               (namely we have omited MM aka \"Multiple Master\", OsF aka \"Oldstyle figures\",\n+               (namely we have omitted MM aka \"Multiple Master\", OsF aka \"Oldstyle figures\",\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/Type1Font.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -525,1 +525,1 @@\n-        \/\/ First see if we can find an overwriteable source shape\n+        \/\/ First see if we can find an overwritable source shape\n@@ -1573,1 +1573,1 @@\n-     * If the currrent transform is Cx, the result of composition\n+     * If the current transform is Cx, the result of composition\n@@ -1786,1 +1786,1 @@\n-     * When Graphics2D is constructed for a component, the backgroung color is\n+     * When Graphics2D is constructed for a component, the background color is\n@@ -2577,1 +2577,1 @@\n-     * vertical padding factors for antialising and interpolation may\n+     * vertical padding factors for antialiasing and interpolation may\n@@ -2842,1 +2842,1 @@\n-                    \/\/ only the relevent portion of the tile\n+                    \/\/ only the relevant portion of the tile\n@@ -3636,1 +3636,1 @@\n-     * that this object will not be useable after it is disposed.\n+     * that this object will not be usable after it is disposed.\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SunGraphics2D.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-     * and tries to update it if it is stale or non-existant and the\n+     * and tries to update it if it is stale or non-existent and the\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SurfaceDataProxy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-                    System.err.print(\"GraphicsPrimitive timetamps \");\n+                    System.err.print(\"GraphicsPrimitive timestamps \");\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/loops\/GraphicsPrimitive.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- *   2. locate an instance of a primitve based on characteristics\n+ *   2. locate an instance of a primitive based on characteristics\n@@ -96,1 +96,1 @@\n-     * Ensure that noone can instantiate this class.\n+     * Ensure that no one can instantiate this class.\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/loops\/GraphicsPrimitiveMgr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1085,1 +1085,1 @@\n-     * can represent without dropouts occuring.\n+     * can represent without dropouts occurring.\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DMarlinRenderingEngine.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -693,1 +693,1 @@\n-            \/\/ use substraction to avoid integer overflow:\n+            \/\/ use subtraction to avoid integer overflow:\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Helpers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-            \/\/ 34 occurences\n+            \/\/ 34 occurrences\n@@ -137,1 +137,1 @@\n-            \/\/ 1561 occurences\n+            \/\/ 1561 occurrences\n@@ -152,1 +152,1 @@\n-            \/\/ 14 occurences\n+            \/\/ 14 occurrences\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MergeSort.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-        \/\/ use substraction to avoid integer overflow:\n+        \/\/ use subtraction to avoid integer overflow:\n@@ -626,1 +626,1 @@\n-            \/\/ if context is maked as DIRTY:\n+            \/\/ if context is marked as DIRTY:\n@@ -828,1 +828,1 @@\n-        int lastY = -1; \/\/ last emited row\n+        int lastY = -1; \/\/ last emitted row\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Renderer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-        \/\/ if context is maked as DIRTY:\n+        \/\/ if context is marked as DIRTY:\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/RendererContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1081,1 +1081,1 @@\n-        \/\/ number of splitted curves\n+        \/\/ number of split curves\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/TransformingPathConsumer2D.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    \/\/ Text with a height greater than the threshhold will be\n+    \/\/ Text with a height greater than the threshold will be\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/OutlineTextRenderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * to be very lightweight and finalization is a comparitively expensive\n+ * to be very lightweight and finalization is a comparatively expensive\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/ShapeSpanIterator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-                \/\/ may blit b\/g colour (including white) where it shoudn't.\n+                \/\/ may blit b\/g colour (including white) where it shouldn't.\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PSPathGraphics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-       \/\/enable priviledges so initProps can access system properties,\n+       \/\/enable privileges so initProps can access system properties,\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PSPrinterJob.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1637,1 +1637,1 @@\n-     * If the currrent transform is Cx, the result of composition\n+     * If the current transform is Cx, the result of composition\n@@ -1693,1 +1693,1 @@\n-     * When Graphics2D is constructed for a component, the backgroung color is\n+     * When Graphics2D is constructed for a component, the background color is\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PeekGraphics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -827,1 +827,1 @@\n-             * backwards compatibility. We emulate this by createing\n+             * backwards compatibility. We emulate this by creating\n@@ -979,1 +979,1 @@\n-         * until we can rendevous with the application's thread and\n+         * until we can rendezvous with the application's thread and\n@@ -981,1 +981,1 @@\n-         * drawing. When the application is done drawing we rendevous\n+         * drawing. When the application is done drawing we rendezvous\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PrintJob2D.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1521,1 +1521,1 @@\n-     * If the currrent transform is Cx, the result of composition\n+     * If the current transform is Cx, the result of composition\n@@ -1577,1 +1577,1 @@\n-     * When Graphics2D is constructed for a component, the backgroung color is\n+     * When Graphics2D is constructed for a component, the background color is\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/ProxyGraphics2D.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * graphics calls are forwared to another Graphics instance\n+ * graphics calls are forwarded to another Graphics instance\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/ProxyPrintGraphics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -841,1 +841,1 @@\n-                w = owner; \/\/ use the one specifed by the app\n+                w = owner; \/\/ use the one specified by the app\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/RasterPrinterJob.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-     * @param args accumulated argumets to process.\n+     * @param args accumulated arguments to process.\n@@ -108,1 +108,1 @@\n-     * This implementation calls {@code run(List<T> args)} mehtod\n+     * This implementation calls {@code run(List<T> args)} method\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/AccumulativeRunnable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n- * <li>Invoke <code>paint<\/code> to draw the cached reprensentation at\n+ * <li>Invoke <code>paint<\/code> to draw the cached representation at\n@@ -59,2 +59,2 @@\n- * <li>Invoke <code>getImage<\/code> to get the cached reprensentation and\n- *     draw the image yourself.  This is primarly useful when you are not\n+ * <li>Invoke <code>getImage<\/code> to get the cached representation and\n+ *     draw the image yourself.  This is primarily useful when you are not\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/CachedPainter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-     * For some look and feels check boxs and radio buttons typically\n+     * For some look and feels check boxes and radio buttons typically\n@@ -119,1 +119,1 @@\n-     * For some look and feels check boxs and radio buttons typically\n+     * For some look and feels check boxes and radio buttons typically\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/DefaultLayoutStyle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * public API and its API may change in incompatable ways between dot dot\n+ * public API and its API may change in incompatible ways between dot dot\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/DefaultLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import java.text.NumberFormat;\n@@ -1124,2 +1125,5 @@\n-        JFileChooser chooser;\n-        DateFormat df;\n+        private final JFileChooser chooser;\n+        private final DateFormat df;\n+        private final MessageFormat mf = new MessageFormat(\"\");\n+        private final NumberFormat nf = NumberFormat.getNumberInstance();\n+        private static final double baseFileSize = 1000.0;\n@@ -1131,0 +1135,1 @@\n+            nf.setMinimumFractionDigits(1);\n@@ -1192,2 +1197,12 @@\n-            } else if (value instanceof Long) {\n-                long len = ((Long) value) \/ 1024L;\n+            } else if (value instanceof final Long len) {\n+                \/*\n+                 * This code block is relevant to Linux.\n+                 * File size is displayed up to 1 decimal precision.\n+                 * Base-10 number system is used for formatting file size\n+                 * similar to how it's formatted in file managers on Linux.\n+                 * Empty file size is shown as 0.0 KB,\n+                 * 1-100-byte files are shown as 0.1 KB,\n+                 * 101-200-byte files are shown as 0.2 KB and so on.\n+                 *\/\n+                Object[] displayedFileSize = new Object[1];\n+\n@@ -1195,3 +1210,2 @@\n-                    text = MessageFormat.format(kiloByteString, len + 1);\n-                } else if (len < 1024L) {\n-                    text = MessageFormat.format(kiloByteString, (len == 0L) ? 1L : len);\n+                    updateMessageFormatPattern(kiloByteString);\n+                    displayedFileSize[0] = roundToOneDecimalPlace(len);\n@@ -1199,3 +1213,4 @@\n-                    len \/= 1024L;\n-                    if (len < 1024L) {\n-                        text = MessageFormat.format(megaByteString, len);\n+                    double kbVal = roundToOneDecimalPlace(len);\n+                    if (kbVal < baseFileSize) {\n+                        updateMessageFormatPattern(kiloByteString);\n+                        displayedFileSize[0] = kbVal;\n@@ -1203,2 +1218,8 @@\n-                        len \/= 1024L;\n-                        text = MessageFormat.format(gigaByteString, len);\n+                        double mbVal = roundToOneDecimalPlace(Math.ceil(kbVal));\n+                        if (mbVal < baseFileSize) {\n+                            updateMessageFormatPattern(megaByteString);\n+                            displayedFileSize[0] = mbVal;\n+                        } else {\n+                            updateMessageFormatPattern(gigaByteString);\n+                            displayedFileSize[0] = roundToOneDecimalPlace(Math.ceil(mbVal));\n+                        }\n@@ -1207,0 +1228,1 @@\n+                text = mf.format(displayedFileSize);\n@@ -1219,0 +1241,17 @@\n+\n+        private void updateMessageFormatPattern(String pattern) {\n+            mf.applyPattern(pattern);\n+            mf.setFormat(0, nf);\n+        }\n+\n+        \/**\n+         * Rounds a value to one decimal place. It's used to format\n+         * file size similar to how it's formatted in file managers on Linux.\n+         * For example, the file size of 1200 bytes is rounded to 1.2 KB.\n+         *\n+         * @param fileSize the file size to round to one decimal place\n+         * @return file size rounded to one decimal place\n+         *\/\n+        private static double roundToOneDecimalPlace(double fileSize) {\n+            return Math.ceil(fileSize \/ 100.0d) \/ 10.0d;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/FilePane.java","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-     * @Depricated replaced by\n+     * @Deprecated replaced by\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/LightweightContent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-            \/\/ we should update the maximal text witdh\n+            \/\/ we should update the maximal text width\n@@ -834,1 +834,1 @@\n-     * @return maximal vaule.\n+     * @return maximal value.\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/MenuItemLayoutHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n- * public API and its API may change in incompatable ways between dot dot\n+ * public API and its API may change in incompatible ways between dot dot\n@@ -1519,1 +1519,1 @@\n-     * Returns true if the given event is corrent gesture for\n+     * Returns true if the given event is current gesture for\n@@ -1567,1 +1567,1 @@\n-             * dispathing thread\n+             * dispatching thread\n@@ -1782,1 +1782,1 @@\n-     * not map to a valid {@code Integer}, or can not be convered from\n+     * not map to a valid {@code Integer}, or cannot be converted from\n@@ -1795,1 +1795,1 @@\n-     * {@code Integer}, or can not be convered from a {@code String}\n+     * {@code Integer}, or cannot be converted from a {@code String}\n@@ -1809,1 +1809,1 @@\n-     * not map to a valid {@code Integer}, or can not be convered from\n+     * not map to a valid {@code Integer}, or can not be converted from\n@@ -1826,1 +1826,1 @@\n-     * {@code Integer}, or can not be convered from a {@code String}\n+     * {@code Integer}, or can not be converted from a {@code String}\n@@ -2209,1 +2209,1 @@\n-     * @param model  corresponing tree model\n+     * @param model  corresponding tree model\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/SwingUtilities2.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-     * Paints using the algorightm specified by <code>paintType<\/code>.\n+     * Paints using the algorithm specified by <code>paintType<\/code>.\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/plaf\/synth\/Paint9Painter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * shoud be considered an implementation detail, and subject to change.\n+ * should be considered an implementation detail, and subject to change.\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/plaf\/synth\/SynthFileChooserUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * shoud be considered an implementation detail, and subject to change.\n+ * should be considered an implementation detail, and subject to change.\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/plaf\/synth\/SynthFileChooserUIImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -772,1 +772,1 @@\n-                         * documents it is often for consequent positons to have\n+                         * documents it is often for consequent positions to have\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/text\/TextComponentPrintable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -513,1 +513,1 @@\n-     It differs from the HotJava body.content in that it doesnt\n+     It differs from the HotJava body.content in that it doesn't\n","filename":"src\/java.desktop\/share\/data\/dtdbuilder\/html32.dtd","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,0 +23,21 @@\n+\n+Copyright (C) 1996-2022 by David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2007-2022 by Dereg Clegg and Michael Toftdal.\n+Copyright (C) 1996-2022 by Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2004-2022 by Masatake YAMATO and Redhat K.K.\n+Copyright (C) 2007-2022 by Derek Clegg and Michael Toftdal.\n+Copyright (C) 2007-2022 by David Turner.\n+Copyright (C) 2022 by David Turner, Robert Wilhelm, Werner Lemberg, and Moazin Khatti.\n+Copyright (C) 2007-2022 by Rahul Bhalerao <rahul.bhalerao@redhat.com>, <b.rahul.pm@gmail.com>.\n+Copyright (C) 2008-2022 by David Turner, Robert Wilhelm, Werner Lemberg, and suzuki toshiya.\n+Copyright (C) 2019-2022 by Nikhil Ramakrishnan, David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright (C) 2009-2022 by Oran Agra and Mickey Gabel.\n+Copyright (C) 2004-2022 by David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.\n+Copyright (C) 2004-2022 by Masatake YAMATO, Red Hat K.K.,\n+Copyright (C) 2003-2022 by Masatake YAMATO, Redhat K.K.,\n+Copyright (C) 2013-2022 by Google, Inc.\n+Copyright (C) 2018-2022 by David Turner, Robert Wilhelm, Dominik Rttsches, and Werner Lemberg.\n+Copyright (C) 2005-2022 by David Turner, Robert Wilhelm, and Werner Lemberg.\n+Copyright 2013 by Google, Inc.\n+\n+\n@@ -536,40 +557,28 @@\n-#########################################################################\n-\n---- fthash.c and fthash.h are covered by the following notices ---\n-\n-\/*\n- * Copyright 2000 Computing Research Labs, New Mexico State University\n- * Copyright 2001-2015\n- *   Francesco Zappa Nardelli\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a\n- * copy of this software and associated documentation files (the \"Software\"),\n- * to deal in the Software without restriction, including without limitation\n- * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n- * and\/or sell copies of the Software, and to permit persons to whom the\n- * Software is furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n- * THE COMPUTING RESEARCH LAB OR NEW MEXICO STATE UNIVERSITY BE LIABLE FOR ANY\n- * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n- * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n- * THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n- *\/\n-\n-  \/**************************************************************************\n-   *\n-   * This file is based on code from bdf.c,v 1.22 2000\/03\/16 20:08:50\n-   *\n-   * taken from Mark Leisher's xmbdfed package\n-   *\n-   *\/\n-   \n-#########################################################################\n-\n-\n---- FreeType 2 PSaux module is covered by the following notices ---\n+```\n+\n+### Additional Freetype Attributions\n+```\n+\n+---------------------------------\n+The below license applies to the following files:\n+libfreetype\/src\/psaux\/psarrst.c\n+libfreetype\/src\/psaux\/psarrst.h\n+libfreetype\/src\/psaux\/psblues.c\n+libfreetype\/src\/psaux\/psblues.h\n+libfreetype\/src\/psaux\/pserror.c\n+libfreetype\/src\/psaux\/pserror.h\n+libfreetype\/src\/psaux\/psfixed.h\n+libfreetype\/src\/psaux\/psfont.c\n+libfreetype\/src\/psaux\/psfont.h\n+libfreetype\/src\/psaux\/psft.c\n+libfreetype\/src\/psaux\/psft.h\n+libfreetype\/src\/psaux\/psglue.h\n+libfreetype\/src\/psaux\/pshints.c\n+libfreetype\/src\/psaux\/pshints.h\n+libfreetype\/src\/psaux\/psintrp.c\n+libfreetype\/src\/psaux\/psintrp.h\n+libfreetype\/src\/psaux\/psread.c\n+libfreetype\/src\/psaux\/psread.h\n+libfreetype\/src\/psaux\/psstack.c\n+libfreetype\/src\/psaux\/psstack.h\n+libfreetype\/src\/psaux\/pstypes.h\n@@ -606,1 +615,0 @@\n-#########################################################################\n@@ -610,0 +618,33 @@\n+### MIT License\n+```\n+\n+---------------------------------\n+The below license applies to the following files:\n+libfreetype\/include\/freetype\/internal\/fthash.h\n+libfreetype\/src\/base\/fthash.c\n+\n+Copyright 2000 Computing Research Labs, New Mexico State University\n+Copyright 2001-2015\n+\n+  Francesco Zappa Nardelli\n+\n+Permission is hereby granted, free of charge, to any person obtaining a\n+copy of this software and associated documentation files (the \"Software\"),\n+to deal in the Software without restriction, including without limitation\n+the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+and\/or sell copies of the Software, and to permit persons to whom the\n+Software is furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n+THE COMPUTING RESEARCH LAB OR NEW MEXICO STATE UNIVERSITY BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT\n+OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n+THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+\n+\n+```\n","filename":"src\/java.desktop\/share\/legal\/freetype.md","additions":82,"deletions":41,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-https:\/\/github.com\/harfbuzz\/harfbuzz\/blob\/master\/COPYING\n+https:\/\/github.com\/harfbuzz\/harfbuzz\/blob\/4.4.1\/COPYING\n@@ -13,4 +13,4 @@\n-Copyright  2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020  Google, Inc.\n-Copyright  2018,2019,2020  Ebrahim Byagowi\n-Copyright  2019,2020  Facebook, Inc. \n-Copyright  2012  Mozilla Foundation\n+Copyright  2010-2022  Google, Inc.\n+Copyright  2018-2020  Ebrahim Byagowi\n+Copyright  2019-2020  Facebook, Inc.\n+Copyright  2012-2015  Mozilla Foundation.\n@@ -18,1 +18,1 @@\n-Copyright  2008,2010  Nokia Corporation and\/or its subsidiary(-ies)\n+Copyright  2008-2010  Nokia Corporation and\/or its subsidiary(-ies)\n@@ -22,1 +22,1 @@\n-Copyright  2006  Behdad Esfahbod\n+Copyright  2005-2022 Behdad Esfahbod\n@@ -24,1 +24,1 @@\n-Copyright  2004,2007,2008,2009,2010  Red Hat, Inc.\n+Copyright  2004-2013  Red Hat, Inc.\n@@ -26,0 +26,4 @@\n+Copyright  2016  Elie Roux <elie.roux@telecom-bretagne.eu>\n+Copyright  2018-2019 Adobe Inc.\n+Copyright  2018  Khaled Hosny\n+Copyright  2016  Igalia S.L.\n@@ -52,0 +56,4 @@\n+---------------------------------\n+The below license applies to the following files:\n+libharfbuzz\/hb-ucd.cc\n+\n","filename":"src\/java.desktop\/share\/legal\/harfbuzz.md","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-IJG is not affiliated with the official ISO JPEG standards committee. \n+IJG is not affiliated with the official ISO JPEG standards committee.\n","filename":"src\/java.desktop\/share\/legal\/jpeg.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * outBuf must be large enough to conatin all the rectangles.\n+ * outBuf must be large enough to contain all the rectangles.\n","filename":"src\/java.desktop\/share\/native\/common\/awt\/utility\/rect.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1038,1 +1038,1 @@\n-    \/\/ a part of desitination buffer into an intermediate texture\n+    \/\/ a part of destination buffer into an intermediate texture\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/OGLTextRenderer.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n- * (in the case of non-antialiased primitives) everytime the current color\n+ * (in the case of non-antialiased primitives) every time the current color\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/OGLVertexCache.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,3 @@\n+#define IS_MUL_OVERFLOW(m, n) \\\n+        ((m) != 0 && (n) != 0 && (((size_t)((m)*(n))) != (((size_t)(m)) * ((size_t)(n)))))\n+\n@@ -50,1 +53,3 @@\n-    (IS_SAFE_SIZE_T(m) && IS_SAFE_SIZE_T(n) && ((m) == 0 || (n) == 0 || (size_t)(n) <= (SIZE_MAX \/ (size_t)(m))))\n+    (IS_SAFE_SIZE_T(m) && IS_SAFE_SIZE_T(n) && \\\n+     ((m) == 0 || (n) == 0 || (size_t)(n) <= (SIZE_MAX \/ (size_t)(m))) && \\\n+     !IS_MUL_OVERFLOW(m, n))\n","filename":"src\/java.desktop\/share\/native\/include\/sizecalc.h","additions":7,"deletions":2,"binary":false,"changes":9,"previous_filename":"src\/java.base\/share\/native\/libjava\/sizecalc.h","status":"renamed"},{"patch":"@@ -52,1 +52,1 @@\n-            \/* integer oveflow *\/                           \\\n+            \/* integer overflow *\/                           \\\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/awt_ImageRep.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * will check for the existance of the \"DecodeDeclared\" keyword\n+ * will check for the existence of the \"DecodeDeclared\" keyword\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/cvutils\/img_anycm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * will check for the existance of the \"DitherDeclared\" keyword\n+ * will check for the existence of the \"DitherDeclared\" keyword\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/cvutils\/img_fsdither.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n- * intensity thereby causing an occasionaly dark pixel when rendering\n+ * intensity thereby causing an occasionally dark pixel when rendering\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/cvutils\/img_ordclruns.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- * will check for the existance of the \"DitherDeclared\" keyword\n+ * will check for the existence of the \"DitherDeclared\" keyword\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/cvutils\/img_orddither.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-     * Start reading the image data. First we get the intial code size\n+     * Start reading the image data. First we get the initial code size\n@@ -173,1 +173,1 @@\n-    \/* Temproray storage for decompression *\/\n+    \/* Temporary storage for decompression *\/\n","filename":"src\/java.desktop\/share\/native\/libawt\/awt\/image\/gif\/gifdecoder.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1673,1 +1673,1 @@\n- * when text is drawn ontop of translucent background color. The standard\n+ * when text is drawn on top of translucent background color. The standard\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/LoopMacros.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -936,1 +936,1 @@\n- * In our case, initialy K is chosen as 1\/(2^DF_CUB_STEPS) this value is taken\n+ * In our case, initially K is chosen as 1\/(2^DF_CUB_STEPS) this value is taken\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/ProcessPath.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-     * and the glyphlist will be homogenous. This test and the position\n+     * and the glyphlist will be homogeneous. This test and the position\n@@ -535,1 +535,1 @@\n-     * heterogenous.\n+     * heterogeneous.\n@@ -538,1 +538,1 @@\n-     * heterogenous\n+     * heterogeneous\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/DrawGlyphList.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-   To simplify work with debuging version of freetype we define\n+   To simplify work with debugging version of freetype we define\n@@ -1278,1 +1278,1 @@\n-    \/* first usage - allocate space and intialize all fields *\/\n+    \/* first usage - allocate space and initialize all fields *\/\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/freetypeScaler.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- *                image to be copyed.\n+ *                image to be copied.\n@@ -47,1 +47,1 @@\n- *                image to be copyed.\n+ *                image to be copied.\n@@ -49,1 +49,1 @@\n- *                image to be copyed.\n+ *                image to be copied.\n@@ -51,1 +51,1 @@\n- *                image to be copyed.\n+ *                image to be copied.\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageConvCopyEdge_Bit.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- *                image to be copyed.\n+ *                image to be copied.\n@@ -47,1 +47,1 @@\n- *                image to be copyed.\n+ *                image to be copied.\n@@ -49,1 +49,1 @@\n- *                image to be copyed.\n+ *                image to be copied.\n@@ -51,1 +51,1 @@\n- *                image to be copyed.\n+ *                image to be copied.\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_c_ImageConvCopyEdge.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *      mlib_ImageConvVersion - Get Conv* funtions version\n+ *      mlib_ImageConvVersion - Get Conv* functions version\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_c_ImageConvVersion.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1338,1 +1338,1 @@\n-\/* Data Fomat Conversion ( format ) *\/\n+\/* Data Format Conversion ( format ) *\/\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_image_proto.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Macroses defined below are wrappers for alloc functions\n+ * Macros defined below are wrappers for alloc functions\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/safe_alloc.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-    \/* check the mask is contigious *\/\n+    \/* check the mask is contiguous *\/\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/splashscreen_gfx_impl.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-            \/** The action to be performed upon clicking the baloon. *\/\n+            \/** The action to be performed upon clicking the balloon. *\/\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/InfoWindow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        boolean overriden = false;\n+        boolean overridden = false;\n@@ -126,1 +126,1 @@\n-                overriden = true;\n+                overridden = true;\n@@ -178,1 +178,1 @@\n-            if (!overriden) {\n+            if (!overridden) {\n@@ -185,1 +185,1 @@\n-        putEmbedderRegistryEntry(embedder, overriden, version, proxy);\n+        putEmbedderRegistryEntry(embedder, overridden, version, proxy);\n@@ -267,1 +267,1 @@\n-        boolean overriden = false;\n+        boolean overridden = false;\n@@ -300,1 +300,1 @@\n-                overriden = true;\n+                overridden = true;\n@@ -317,1 +317,1 @@\n-        putEmbedderRegistryEntry(embedded, overriden, version, proxy);\n+        putEmbedderRegistryEntry(embedded, overridden, version, proxy);\n@@ -570,1 +570,1 @@\n-         * if drop immediatelly follows (see BugTraq ID 4395290).\n+         * if drop immediately follows (see BugTraq ID 4395290).\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/MotifDnDDropTargetProtocol.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-     * Removes atom from the list. Does nothing if arrays doesn't conaint this atom.\n+     * Removes atom from the list. Does nothing if arrays doesn't contain this atom.\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XAtomList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-     * are received by the window they actualy happened on, not the grabber.\n+     * are received by the window they actually happened on, not the grabber.\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XAwtState.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -484,2 +484,2 @@\n-     * returns item thats mapped coordinates contain\n-     * specified point, null of none.\n+     * returns item which mapped coordinates contain\n+     * the specified point, null if none.\n@@ -890,1 +890,1 @@\n-     * Overriden utility functions of XWindow\n+     * Overridden utility functions of XWindow\n@@ -942,1 +942,1 @@\n-     * This function needs to be overriden since\n+     * This function needs to be overridden since\n@@ -944,1 +944,1 @@\n-     * so events can not be processed using standart means\n+     * so events cannot be processed using standard means\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XBaseMenuWindow.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -486,1 +486,1 @@\n-     * The lock should be acquired untill all operations with XSizeHints are completed.\n+     * The lock should be acquired until all operations with XSizeHints are completed.\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XBaseWindow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-     * Implementaion of interface methods\n+     * Implementation of interface methods\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XCheckboxMenuItemPeer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-    \/\/ TODO: copied directly from XButtonPeer.  Should probabaly be shared\n+    \/\/ TODO: copied directly from XButtonPeer.  Should probably be shared\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XCheckboxPeer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        \/\/ the largest cursor size that could be dislpayed\n+        \/\/ the largest cursor size that could be displayed\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XCustomCursor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-        \/\/ Just get the atom. If it has already been retrived\n+        \/\/ Just get the atom. If it has already been retrieved\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XDataTransferer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -719,1 +719,1 @@\n-    \/\/ This method gets overriden in XFramePeer & XDialogPeer.\n+    \/\/ This method gets overridden in XFramePeer & XDialogPeer.\n@@ -1207,1 +1207,1 @@\n-        \/\/ If this is Window and its owner Frame is active we can be sure request succedded.\n+        \/\/ If this is Window and its owner Frame is active we can be sure request succeeded.\n@@ -1223,1 +1223,1 @@\n-            \/\/ Right now, because policy is unknown we can't be sure we succedded\n+            \/\/ Right now, because policy is unknown we can't be sure we succeeded\n@@ -1290,1 +1290,1 @@\n-             * definetely before the Frame gets FocusIn event (when this method is called).\n+             * definitely before the Frame gets FocusIn event (when this method is called).\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XDecoratedPeer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-        boolean overriden = false;\n+        boolean overridden = false;\n@@ -138,1 +138,1 @@\n-                overriden = true;\n+                overridden = true;\n@@ -146,1 +146,1 @@\n-        if (overriden && version >= 4) {\n+        if (overridden && version >= 4) {\n@@ -267,1 +267,1 @@\n-        putEmbedderRegistryEntry(embedder, overriden, version, proxy);\n+        putEmbedderRegistryEntry(embedder, overridden, version, proxy);\n@@ -323,1 +323,1 @@\n-        boolean overriden = false;\n+        boolean overridden = false;\n@@ -339,1 +339,1 @@\n-                overriden = true;\n+                overridden = true;\n@@ -347,1 +347,1 @@\n-        if (overriden && version >= 4) {\n+        if (overridden && version >= 4) {\n@@ -405,1 +405,1 @@\n-        putEmbedderRegistryEntry(embedded, overriden, version, proxy);\n+        putEmbedderRegistryEntry(embedded, overridden, version, proxy);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XDnDDropTargetProtocol.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-        private final boolean overriden;\n+        private final boolean overridden;\n@@ -281,2 +281,2 @@\n-        EmbedderRegistryEntry(boolean overriden, int version, long proxy) {\n-            this.overriden = overriden;\n+        EmbedderRegistryEntry(boolean overridden, int version, long proxy) {\n+            this.overridden = overridden;\n@@ -287,1 +287,1 @@\n-            return overriden;\n+            return overridden;\n@@ -302,1 +302,1 @@\n-                                                  boolean overriden,\n+                                                  boolean overridden,\n@@ -307,1 +307,1 @@\n-                                 new EmbedderRegistryEntry(overriden, version,\n+                                 new EmbedderRegistryEntry(overridden, version,\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XDropTargetProtocol.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-        \/\/ Unimplemeneted: Check for min\/max hints for non-resizable\n+        \/\/ Unimplemented: Check for min\/max hints for non-resizable\n@@ -261,1 +261,1 @@\n-              \/\/ Either lightweight or excessive requiest - all events are generated.\n+              \/\/ Either lightweight or excessive request - all events are generated.\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XEmbedChildProxyPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -567,1 +567,1 @@\n-                throw new RuntimeException(\"Didn't receive event \" + XEmbedHelper.msgidToString(event) + \" but recevied \" + XEmbedHelper.msgidToString(eventReceived));\n+                throw new RuntimeException(\"Didn't receive event \" + XEmbedHelper.msgidToString(event) + \" but received \" + XEmbedHelper.msgidToString(eventReceived));\n@@ -570,1 +570,1 @@\n-                    xembedLog.finer(\"Successfully recevied \" + XEmbedHelper.msgidToString(event));\n+                    xembedLog.finer(\"Successfully received \" + XEmbedHelper.msgidToString(event));\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XEmbedServerTester.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -715,1 +715,1 @@\n-     * We cann't update savedDir here now since it used very often\n+     * We can't update savedDir here now since it used very often\n@@ -799,1 +799,1 @@\n-            \/\/ Actually in Motif implementation lost file value which was saved after prevously showing\n+            \/\/ Actually in Motif implementation lost file value which was saved after previously showing\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XFileDialogPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-     * @return preffered icon size calculated from specific icon\n+     * @return preferred icon size calculated from specific icon\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XIconWindow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-     * Auxilliary Functions; note the duplicate definitions for left and right\n+     * Auxiliary Functions; note the duplicate definitions for left and right\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XKeySymConstants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1662,1 +1662,1 @@\n-     * The bug is due to incorrent caching of the list item size\n+     * The bug is due to incorrect caching of the list item size\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XListPeer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-     * Events in extra_mask are selected for on owning windows (exsiting\n+     * Events in extra_mask are selected for on owning windows (existing\n@@ -209,1 +209,1 @@\n-                log.fine(\"client messags = \" + xce);\n+                log.fine(\"client messages = \" + xce);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XMSelection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-     * Implementaion of interface methods\n+     * Implementation of interface methods\n@@ -135,1 +135,1 @@\n-     * So we need to synchronize indicies in 'items'\n+     * So we need to synchronize indices in 'items'\n@@ -193,1 +193,1 @@\n-     * Overriden initialization\n+     * Overridden initialization\n@@ -362,1 +362,1 @@\n-     * Overriden XBaseMenuWindow functions\n+     * Overridden XBaseMenuWindow functions\n@@ -376,1 +376,1 @@\n-     * Overriden XWindow general-purpose functions\n+     * Overridden XWindow general-purpose functions\n@@ -403,1 +403,1 @@\n-     * Overriden XWindow painting & printing\n+     * Overridden XWindow painting & printing\n@@ -453,1 +453,1 @@\n-     * Overriden XBaseMenuWindow event handling\n+     * Overridden XBaseMenuWindow event handling\n@@ -498,1 +498,1 @@\n-     * Overriden XWindow keyboard processing\n+     * Overridden XWindow keyboard processing\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XMenuBarPeer.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-     * Implementaion of interface methods\n+     * Implementation of interface methods\n@@ -272,1 +272,1 @@\n-     * This function should be overriden simply to\n+     * This function should be overridden simply to\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XMenuItemPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-     * Implementaion of interface methods\n+     * Implementation of interface methods\n@@ -146,1 +146,1 @@\n-     * Overriden behaviour\n+     * Overridden behaviour\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XMenuPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-     * Overriden initialization\n+     * Overridden initialization\n@@ -328,1 +328,1 @@\n-     * Can be overriden for popup menus and tear-off menus\n+     * Can be overridden for popup menus and tear-off menus\n@@ -336,1 +336,1 @@\n-     * Can be overriden for popup menus and tear-off menus.\n+     * Can be overridden for popup menus and tear-off menus.\n@@ -357,1 +357,1 @@\n-     * This function is overriden in XPopupMenuPeer\n+     * This function is overridden in XPopupMenuPeer\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XMenuWindow.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-     * Overriden XMenuWindow caption-painting functions\n+     * Overridden XMenuWindow caption-painting functions\n@@ -223,1 +223,1 @@\n-     * Can be overriden for popup menus and tear-off menus\n+     * Can be overridden for popup menus and tear-off menus\n@@ -250,1 +250,1 @@\n-     * Can be overriden for popup menus and tear-off menus.\n+     * Can be overridden for popup menus and tear-off menus.\n@@ -273,1 +273,1 @@\n-     * Overriden XBaseMenuWindow functions\n+     * Overridden XBaseMenuWindow functions\n@@ -306,1 +306,1 @@\n-     * Overriden XWindow general-purpose functions\n+     * Overridden XWindow general-purpose functions\n@@ -316,1 +316,1 @@\n-     * Overriden XWindow keyboard processing\n+     * Overridden XWindow keyboard processing\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XPopupMenuPeer.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -804,1 +804,1 @@\n-            \/\/ in thermo, slider_size is 0 ans is ignored\n+            \/\/ in thermo, slider_size is 0 and is ignored\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XScrollbar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -726,1 +726,1 @@\n-                        \/\/ The property will be None in case of convertion failure.\n+                        \/\/ The property will be None in case of conversion failure.\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XSelection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1247,1 +1247,1 @@\n-    \/\/ now). They are only dispatched as correctly as possible\/neccessary.\n+    \/\/ now). They are only dispatched as correctly as possible\/necessary.\n@@ -1368,1 +1368,1 @@\n-        \/\/ side-effect. If mouse is draged from outside to inside of TextArea,\n+        \/\/ side-effect. If mouse is dragged from outside to inside of TextArea,\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XTextAreaPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1491,1 +1491,1 @@\n-                    log.fine(\"Catched exception, timeStamp may not be correct (ie = \" + ie + \")\");\n+                    log.fine(\"Caught exception, timeStamp may not be correct (ie = \" + ie + \")\");\n@@ -1909,1 +1909,1 @@\n-     * @param interval an interal in milliseconds\n+     * @param interval an interval in milliseconds\n@@ -2402,1 +2402,1 @@\n-                            \/\/ OOPS ConfigureNotify event catched\n+                            \/\/ OOPS ConfigureNotify event caught\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XToolkit.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-                log.finer(\"Getting of _DT_SM_WINDOW_INFO is not successfull\");\n+                log.finer(\"Getting of _DT_SM_WINDOW_INFO is not successful\");\n@@ -470,1 +470,1 @@\n-                    log.finer(\"Getting of _DT_SM_STATE_INFO is not successfull\");\n+                    log.finer(\"Getting of _DT_SM_STATE_INFO is not successful\");\n@@ -658,1 +658,1 @@\n-                log.finer(\"Erorr getting XA_ICEWM_WINOPTHINT property\");\n+                log.finer(\"Error getting XA_ICEWM_WINOPTHINT property\");\n@@ -1157,1 +1157,1 @@\n-              \/* FALLTROUGH *\/\n+              \/* FALLTHROUGH *\/\n@@ -1164,1 +1164,1 @@\n-              \/* FALLTROUGH *\/\n+              \/* FALLTHROUGH *\/\n@@ -1299,1 +1299,1 @@\n-     * see a huge nagative bottom inset.  There's no clean solution for\n+     * see a huge negative bottom inset.  There's no clean solution for\n@@ -1541,1 +1541,1 @@\n-     * time to let the WM hava a chance to move us.\n+     * time to let the WM have a chance to move us.\n@@ -1673,1 +1673,1 @@\n-                       * top-level assume taht it's the \"lining\" window and\n+                       * top-level assume that it's the \"lining\" window and\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWM.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -448,1 +448,1 @@\n-    \/\/ overriden in XCanvasPeer\n+    \/\/ overridden in XCanvasPeer\n@@ -535,1 +535,1 @@\n-    \/\/used by Peers to avoid flickering withing paint()\n+    \/\/used by Peers to avoid flickering within paint()\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWindow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -433,1 +433,1 @@\n-        \/\/It's overriden in XDecoratedPeer\n+        \/\/It's overridden in XDecoratedPeer\n@@ -489,1 +489,1 @@\n-    \/\/Note that this function is overriden in XDecoratedPeer so event\n+    \/\/Note that this function is overridden in XDecoratedPeer so event\n@@ -568,1 +568,1 @@\n-     * Retrives real native focused window and converts it into Java peer.\n+     * Retrieves real native focused window and converts it into Java peer.\n@@ -578,1 +578,1 @@\n-     * Retrives real native focused window and converts it into Java window.\n+     * Retrieves real native focused window and converts it into Java window.\n@@ -768,1 +768,1 @@\n-            \/\/ moved or not. The client should consider the position as unkown\n+            \/\/ moved or not. The client should consider the position as unknown\n@@ -1202,1 +1202,1 @@\n-        \/\/ We are not currently aware of existance of such a property.\n+        \/\/ We are not currently aware of existence of such a property.\n@@ -1946,1 +1946,1 @@\n-        \/\/ If this is Window and its owner Frame is active we can be sure request succedded.\n+        \/\/ If this is Window and its owner Frame is active we can be sure request succeeded.\n@@ -1971,1 +1971,1 @@\n-    \/\/ This method is to be overriden in XDecoratedPeer.\n+    \/\/ This method is to be overridden in XDecoratedPeer.\n@@ -2229,1 +2229,1 @@\n-            \/\/ see comment above for more inforamtion.\n+            \/\/ see comment above for more information.\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWindowPeer.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -409,1 +409,1 @@\n-        \/\/ The state mask does not support button indicies > 5, so we need to\n+        \/\/ The state mask does not support button indices > 5, so we need to\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XlibUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -428,1 +428,1 @@\n-         * it has to be the inital (empty) state for the latter two, not\n+         * it has to be the initial (empty) state for the latter two, not\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11FontManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-     * with Java3D beta1, a NoSuchMethod execption is thrown and\n+     * with Java3D beta1, a NoSuchMethod exception is thrown and\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,3 +101,3 @@\n-        \/* If the last XIC focussed component has a different peer as the\n-           current focussed component, change the XIC focus to the newly\n-           focussed component.\n+        \/* If the last XIC focused component has a different peer as the\n+           current focused component, change the XIC focus to the newly\n+           focused component.\n@@ -128,1 +128,1 @@\n-           the previous focused compoent which is A, then endComposition is called on A,\n+           the previous focused component which is A, then endComposition is called on A,\n@@ -349,1 +349,1 @@\n-           Use package private mthod 'resetCompositionState' if you want the\n+           Use package private method 'resetCompositionState' if you want the\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11InputMethod.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-            \/\/ needs to reset the last xic focussed component.\n+            \/\/ needs to reset the last xic focused component.\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11InputMethodBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-         * will fall through this code, but the regisration code will\n+         * will fall through this code, but the registration code will\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/FontConfigManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-     * We only look for scaleable fonts, so we can just replace the 0's\n+     * We only look for scalable fonts, so we can just replace the 0's\n@@ -194,1 +194,1 @@\n-     * No matches means even the scaleable version wasn't found. This is\n+     * No matches means even the scalable version wasn't found. This is\n@@ -196,1 +196,1 @@\n-     * One match means only the scaleable version we started with was found\n+     * One match means only the scalable version we started with was found\n@@ -198,1 +198,1 @@\n-     * Two matches apparently means as well as the above, a scaleable\n+     * Two matches apparently means as well as the above, a scalable\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/NativeFont.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-     * to be publically exposing this class, so no need to waste work\n+     * to be publicly exposing this class, so no need to waste work\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/X11Dingbats.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-     * to be publically exposing this class, so no need to waste work\n+     * to be publicly exposing this class, so no need to waste work\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/X11GB18030_0.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-     * to be publically exposing this class, so no need to waste work\n+     * to be publicly exposing this class, so no need to waste work\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/X11GB18030_1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-     * to be publically exposing this class, so no need to waste work\n+     * to be publicly exposing this class, so no need to waste work\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/X11SunUnicode_0.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-                \/\/ will accidently cause the surrogate-aware nio charset to treat\n+                \/\/ will accidentally cause the surrogate-aware nio charset to treat\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XMap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-     * Seperates lcd and grayscale glyphs queued for upload, and sets the\n+     * Separates lcd and grayscale glyphs queued for upload, and sets the\n@@ -216,1 +216,1 @@\n-     * Copies the glyph-images into a continous buffer, required for uploading.\n+     * Copies the glyph-images into a continuous buffer, required for uploading.\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRGlyphCache.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        \/* TODO: Does it make sence to cache results? *\/\n+        \/* TODO: Does it make sense to cache results? *\/\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRGlyphCacheEntry.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    \/\/ Workarround for a bug in libXrender.\n+    \/\/ Workaround for a bug in libXrender.\n@@ -125,1 +125,1 @@\n-                         * glyphs using integer coordinates, therefor we sum all\n+                         * glyphs using integer coordinates, therefore we sum all\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRTextRenderer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -517,1 +517,1 @@\n-                    \/\/ some Matrox Millenium and ATI Radeon boards) is\n+                    \/\/ some Matrox Millennium and ATI Radeon boards) is\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/x11\/X11SurfaceData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-                    throw new InternalError(\"Surface not cachable\");\n+                    throw new InternalError(\"Surface not cacheable\");\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRPaints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -347,1 +347,1 @@\n-     * CopyArea is implemented using the \"old\" X11 GC, therefor clip and\n+     * CopyArea is implemented using the \"old\" X11 GC, therefore clip and\n@@ -396,1 +396,1 @@\n-     * Returns the XRender SurfaceType which is able to fullfill the specified\n+     * Returns the XRender SurfaceType which is able to fulfill the specified\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRSurfaceData.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-     * Returns the XRender picture Format which is required to fullfill the\n+     * Returns the XRender picture Format which is required to fulfill the\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n- * are created on a host plaform for them to be located by the JRE they will\n+ * are created on a host platform for them to be located by the JRE they will\n@@ -1019,1 +1019,1 @@\n-         * Next create separate C arrrays of length nfonts for family file etc.\n+         * Next create separate C arrays of length nfonts for family file etc.\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/fontpath.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-\/* Cached shared image, one for all surface datas. *\/\n+\/* Cached shared image, one for all surface data. *\/\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11SurfaceData.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-     * medialib library was sucessfuly loaded.\n+     * medialib library was successfully loaded.\n","filename":"src\/java.desktop\/unix\/native\/libawt\/awt\/awt_Mlib.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-         * to JNI_TRUE if any Shm error has occured.\n+         * to JNI_TRUE if any Shm error has occurred.\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/awt_GraphicsEnv.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-\/* Solaris XIM Extention *\/\n+\/* Solaris XIM Extension *\/\n@@ -1016,1 +1016,1 @@\n-    \/\/ The code set the IC mode that the preedit state is not initialied\n+    \/\/ The code set the IC mode that the preedit state is not initialized\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/awt_InputMethod.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-\/* The xrender pipleine requires libXrender.so version 0.9.3 or later. *\/\n+\/* The xrender pipeline requires libXrender.so version 0.9.3 or later. *\/\n@@ -180,1 +180,1 @@\n-                  \/\/ we successfuly read the library version\n+                  \/\/ we successfully read the library version\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/java2d\/x11\/XRBackendNative.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -385,1 +385,1 @@\n-\/\/ is highly recomended to use aging algorithm (set static poll timeout\n+\/\/ is highly recommended to use aging algorithm (set static poll timeout\n@@ -848,1 +848,1 @@\n-     * If XTest is asked to press a non-existant mouse button\n+     * If XTest is asked to press a non-existent mouse button\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/xawt\/XToolkit.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1130,1 +1130,1 @@\n- * time to let the WM hava a chance to move us\n+ * time to let the WM have a chance to move us\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/xawt\/XWindow.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-        \/\/map the splash co-ordinates as per system scale\n+        \/\/map the splash coordinates as per system scale\n","filename":"src\/java.desktop\/unix\/native\/libsplashscreen\/splashscreen_sys.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-     * An enumeration of the Windows compoent parts\n+     * An enumeration of the Windows component parts\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/TMSchema.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-     *         - somewhere inbetween if border is compound and\n+     *         - somewhere in between if border is compound and\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsButtonUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-     * the overriden paintText methods of the ButtonUI delegates will call this static method.\n+     * the overridden paintText methods of the ButtonUI delegates will call this static method.\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsGraphicsUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -511,1 +511,1 @@\n-                    \/\/ outter left arc\n+                    \/\/ outer left arc\n@@ -514,1 +514,1 @@\n-                    \/\/ outter right arc\n+                    \/\/ outer right arc\n@@ -538,1 +538,1 @@\n-                    \/\/ outter left arc\n+                    \/\/ outer left arc\n@@ -547,1 +547,1 @@\n-                    \/\/ outter right arc\n+                    \/\/ outer right arc\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsIconFactory.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-        \/\/ XXX - some of these doens't seem to be used\n+        \/\/ XXX - some of these doesn't seem to be used\n@@ -648,1 +648,1 @@\n-            \/\/ W2K keyboard navigation hidding.\n+            \/\/ W2K keyboard navigation hiding.\n@@ -2434,1 +2434,1 @@\n-            \/\/ Make sure property change listener is readded each time\n+            \/\/ Make sure property change listener is re-added each time\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsLookAndFeel.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-     * Because these need to be registed just for use when printing,\n+     * Because these need to be registered just for use when printing,\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/Win32FontManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-     * default graphics configuraiton, so this is just a precaution.\n+     * default graphics configuration, so this is just a precaution.\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/Win32GraphicsConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -197,2 +197,2 @@\n-                \/\/ but the DataFlavor.allHtmlFlavor format is avialable\n-                \/\/ we belive that the user knows how to represent\n+                \/\/ but the DataFlavor.allHtmlFlavor format is available\n+                \/\/ we believe that the user knows how to represent\n@@ -200,1 +200,1 @@\n-                \/\/ system specific manner. Therefor, we use this data\n+                \/\/ system specific manner. Therefore, we use this data\n@@ -588,1 +588,1 @@\n-     * SourceURL:http:\/\/sun.com\/\\r\\n  -- base URL for related referenses\n+     * SourceURL:http:\/\/sun.com\/\\r\\n  -- base URL for related references\n@@ -707,1 +707,1 @@\n-    private String stBaseURL; \/\/ SourceURL -- base URL for related referenses\n+    private String stBaseURL; \/\/ SourceURL -- base URL for related references\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WDataTransferer.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    \/\/ supress calling native setMinSize()\n+    \/\/ suppress calling native setMinSize()\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WEmbeddedFramePeer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,3 +306,3 @@\n-        \/\/ When the last focussed component peer is different from the\n-        \/\/ current focussed component or if they are different client\n-        \/\/ (active or passive), disable native IME for the old focussed\n+        \/\/ When the last focused component peer is different from the\n+        \/\/ current focused component or if they are different client\n+        \/\/ (active or passive), disable native IME for the old focused\n@@ -356,1 +356,1 @@\n-        \/\/ focussed component has a different peer as the last focussed component.\n+        \/\/ focused component has a different peer as the last focused component.\n@@ -395,1 +395,1 @@\n-     * Calling stopListening to give other input method the keybaord input\n+     * Calling stopListening to give other input method the keyboard input\n@@ -432,1 +432,1 @@\n-               bar if it is on. One typical senario this method\n+               bar if it is on. One typical scenario this method\n@@ -539,1 +539,1 @@\n-            \/\/ set Hilight Information\n+            \/\/ set Highlight Information\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WInputMethod.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-             * Work on a point in case there is asymetric scaling\n+             * Work on a point in case there is asymmetric scaling\n@@ -1125,1 +1125,1 @@\n-                \/\/ may blit b\/g colour (including white) where it shoudn't.\n+                \/\/ may blit b\/g colour (including white) where it shouldn't.\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPathGraphics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-            \/\/ that component.  The event coorinates are going to have to be\n+            \/\/ that component.  The event coordinates are going to have to be\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPopupMenuPeer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-     * and set them into the driver's DEVMODE structure and intialise\n+     * and set them into the driver's DEVMODE structure and initialise\n@@ -389,2 +389,2 @@\n-     * its storage reclaimation marginally.\n-     * It won't make the native resources be release any more quickly, but\n+     * its storage reclamation marginally.\n+     * It won't make the native resources be released any more quickly, but\n@@ -1410,1 +1410,1 @@\n-    \/* Make sure printer DC is intialised and that info about the printer\n+    \/* Make sure printer DC is initialised and that info about the printer\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPrinterJob.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    \/\/ Returns width for vertial scrollbar as SM_CXHSCROLL,\n+    \/\/ Returns width for vertical scrollbar as SM_CXHSCROLL,\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WScrollbarPeer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-    \/\/ should be overriden in WDialogPeer\n+    \/\/ should be overridden in WDialogPeer\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WWindowPeer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-     * to be publically exposing this class, so no need to waste work\n+     * to be publicly exposing this class, so no need to waste work\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WingDings.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-            \/\/ no need to lock, noone has reference to this instance yet\n+            \/\/ no need to lock, no one has reference to this instance yet\n","filename":"src\/java.desktop\/windows\/classes\/sun\/java2d\/d3d\/D3DRenderQueue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -546,1 +546,1 @@\n-                                       \"cound not reset the device\");\n+                                       \"could not reset the device\");\n@@ -551,1 +551,1 @@\n-            \/\/ thos in the default pool since the device is released\n+            \/\/ those in the default pool since the device is released\n@@ -571,1 +571,1 @@\n-                \"D3DContext::ConfigureContext: cound not reset the device\");\n+                \"D3DContext::ConfigureContext: could not reset the device\");\n@@ -1071,1 +1071,1 @@\n-    \/\/ resore the transform\n+    \/\/ restore the transform\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DContext.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-    \/\/ let the mananger know that we're entering the fs mode, it will\n+    \/\/ let the manager know that we're entering the fs mode, it will\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DGraphicsDevice.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    \/\/ when defaul pool resources are to be released\n+    \/\/ when default pool resources are to be released\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DResourceManager.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -959,1 +959,1 @@\n-    \/\/ Genereate Shader to fill Antialiased parallelograms\n+    \/\/ Generate Shader to fill Antialiased parallelograms\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DShaderGen.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-    \/\/ everytime around in case another shader blew away the contents\n+    \/\/ every time around in case another shader blew away the contents\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DTextRenderer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-    \/\/ correct configuration of devices after contruction of the\n+    \/\/ correct configuration of devices after construction of the\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/Devices.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-         *         be destroyed immediatelly. They will be deleted in\n+         *         be destroyed immediately. They will be deleted in\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/GDIHashtable.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1063,1 +1063,1 @@\n-            iconSize = iconSize > MAX_ICON_SIZE ? MAX_ICON_SIZE : iconSize;\n+            iconSize = (iconSize <= 0 || iconSize > MAX_ICON_SIZE) ? MAX_ICON_SIZE : iconSize;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/ShellFolder2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-#error Multiple defintions of CATCH_BAD_ALLOC_RET\n+#error Multiple definitions of CATCH_BAD_ALLOC_RET\n@@ -78,1 +78,1 @@\n-#error Multiple defintions of CATCH_BAD_ALLOC_RET_NO_JNI\n+#error Multiple definitions of CATCH_BAD_ALLOC_RET_NO_JNI\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/alloc.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-        \/\/ By convension null label means empty string\n+        \/\/ By convention null label means empty string\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Button.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-        \/\/ By convension null label means empty string\n+        \/\/ By convention null label means empty string\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Checkbox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-             * choice must be determinded in its creation, when the parent\n+             * choice must be determined in its creation, when the parent\n@@ -514,1 +514,1 @@\n-    \/\/ WM_MOUSEMOVE has been dedected on the list since it has been dropped down.\n+    \/\/ WM_MOUSEMOVE has been detected on the list since it has been dropped down.\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Choice.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2196,1 +2196,1 @@\n-        \/\/ thread which needs to complete initialization, but cant.\n+        \/\/ thread which needs to complete initialization, but can't.\n@@ -2965,1 +2965,1 @@\n-    UINT javaKey;               \/\/ depends on input langauge (kbd layout)\n+    UINT javaKey;               \/\/ depends on input language (kbd layout)\n@@ -3102,1 +3102,1 @@\n-    \/\/   3. Map Unicode char to Java VK via two auxilary tables.\n+    \/\/   3. Map Unicode char to Java VK via two auxiliary tables.\n@@ -4041,1 +4041,1 @@\n-               The last two paremeters are set to equal since we don't have recommendations for\n+               The last two parameters are set to equal since we don't have recommendations for\n@@ -4120,1 +4120,1 @@\n-    \/\/ attrubute value definition in WInputMethod.java must be equal to that in IMM.H\n+    \/\/ attribute value definition in WInputMethod.java must be equal to that in IMM.H\n@@ -4963,1 +4963,1 @@\n-     * This should not be happend if all children are recorded\n+     * This should not be happening if all children are recorded\n@@ -5891,1 +5891,1 @@\n-                   event (if any) accodingly.  *\/\n+                   event (if any) accordingly.  *\/\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    mrConsume,      \/* consume msg & terminate routing immediatly,\n+    mrConsume,      \/* consume msg & terminate routing immediately,\n@@ -546,1 +546,1 @@\n-                                     BOOL synthethic);\n+                                     BOOL synthetic);\n@@ -743,1 +743,1 @@\n-     * When the flag is ON, focus is restored immidiately after the proxy loses it.\n+     * When the flag is ON, focus is restored immediately after the proxy loses it.\n@@ -852,1 +852,1 @@\n-     * the creations of themselfs are in progress.\n+     * the creations of themselves are in progress.\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-     * WaitMessage will return immediatelly as we selectively get messages from\n+     * WaitMessage will return immediately as we selectively get messages from\n@@ -250,1 +250,1 @@\n-     * Fix for the BugTraq ID 4327064 - inter-jvm DnD crashes the droping jvm.\n+     * Fix for the BugTraq ID 4327064 - inter-jvm DnD crashes the dropping jvm.\n@@ -421,1 +421,1 @@\n-                    \/\/ Fail immediatelly to avoid memory access violation.\n+                    \/\/ Fail immediately to avoid memory access violation.\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DataTransferer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -536,1 +536,1 @@\n-    \/\/ TODO BEGIN: On NT4, some setttings don't trigger WM_SETTINGCHANGE --\n+    \/\/ TODO BEGIN: On NT4, some settings don't trigger WM_SETTINGCHANGE --\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DesktopProperties.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    \/\/ Dialog inherits icon from its owner dinamically\n+    \/\/ Dialog inherits icon from its owner dynamically\n@@ -409,1 +409,1 @@\n-        \/\/Non-resizable dialogs without explicitely set icon\n+        \/\/Non-resizable dialogs without explicitly set icon\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Dialog.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    \/\/ some methods called on Tookit thread\n+    \/\/ some methods called on Toolkit thread\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Dialog.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-    \/\/ if we are'nt yet visible, defer until the parent is!\n+    \/\/ if we aren't yet visible, defer until the parent is!\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDT.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1207,1 +1207,1 @@\n-         under NT 4.0 & 98 does the value actaully represent the new value. *\/\n+         under NT 4.0 & 98 does the value actually represent the new value. *\/\n@@ -1887,1 +1887,1 @@\n- * WDefaultFontCharset native methos\n+ * WDefaultFontCharset native methods\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Font.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1178,1 +1178,1 @@\n-    \/\/when reseting from specific icon to class icon\n+    \/\/when resetting from specific icon to class icon\n@@ -1191,1 +1191,1 @@\n-    \/\/when reseting from specific icon to class icon\n+    \/\/when resetting from specific icon to class icon\n@@ -1786,1 +1786,1 @@\n-    \/\/ global refs ans smbs are deleted in _SetMenuBar()\n+    \/\/ global refs and smbs are deleted in _SetMenuBar()\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Frame.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-    \/* used so that calls to ::MoveWindow in SetMenuBar don't propogate\n+    \/* used so that calls to ::MoveWindow in SetMenuBar don't propagate\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Frame.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-     * NOTE: we don't syncronize access to the reference counter.\n+     * NOTE: we don't synchronize access to the reference counter.\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_GDIObject.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-       Senario 1:\n+       Scenario 1:\n@@ -284,1 +284,1 @@\n-       Senario 2:\n+       Scenario 2:\n@@ -288,1 +288,1 @@\n-       Senario 3:\n+       Scenario 3:\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_InputTextInfor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-     * if WM_PAINT was recieving when we can not paint\n-     * then setup m_needPaint end when can call this function\n+     * if WM_PAINT was received when we cannot paint\n+     * then setup m_needPaint and when can paint call this function\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Label.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-                \/\/ If we recieve on of these two notifications, the dialog\n+                \/\/ If we receive one of these two notifications, the dialog\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintDialog.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2294,1 +2294,1 @@\n-     * be creater than zero and we just need to NULL terminate\n+     * be greater than zero and we just need to NULL terminate\n@@ -2405,1 +2405,1 @@\n-     * longer than the GDI maximum font lenght then\n+     * longer than the GDI maximum font length then\n@@ -3173,1 +3173,1 @@\n-                \/\/ If we recieve on of these two notifications, the dialog\n+                \/\/ If we receive one of these two notifications, the dialog\n@@ -3482,1 +3482,1 @@\n-     * declared to be portait.\n+     * declared to be portrait.\n@@ -3523,1 +3523,1 @@\n-     * portait mode while Windows returns the paper\n+     * portrait mode while Windows returns the paper\n@@ -3526,1 +3526,1 @@\n-     * flip the width and height to get a portait\n+     * flip the width and height to get a portrait\n@@ -3703,1 +3703,1 @@\n- * and set them into the PageFormat insance provided.\n+ * and set them into the PageFormat instance provided.\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-            \/\/ Calling <::PeekMessage> is not so good desision but is the only one\n+            \/\/ Calling <::PeekMessage> is not so good decision but is the only one\n@@ -357,1 +357,1 @@\n-    \/\/ and won't cause a wrap, since we have substracted 1 in the\n+    \/\/ and won't cause a wrap, since we have subtracted 1 in the\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Scrollbar.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -738,1 +738,1 @@\n- * In responce to EM_SETBKGNDCOLOR rich edit changes\n+ * In response to EM_SETBKGNDCOLOR rich edit changes\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_TextComponent.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1043,1 +1043,1 @@\n-          \/\/ Create an artifical MouseExit message if the mouse left to\n+          \/\/ Create an artificial MouseExit message if the mouse left to\n@@ -1085,3 +1085,3 @@\n-      \/\/ In other thread these APIs does not work correctly even if\n-      \/\/ it returs with no error. (This restriction is not documented)\n-      \/\/ So we must use thse messages to call these APIs in main thread.\n+      \/\/ In other threads these APIs do not work correctly even if\n+      \/\/ it returns with no error. (This restriction is not documented)\n+      \/\/ So we must use these messages to call these APIs in main thread.\n@@ -1180,1 +1180,1 @@\n-          may need to commit it in the furture\n+          may need to commit it in the future\n@@ -1606,1 +1606,1 @@\n-     * Modal loop may not exit immediatelly after WM_CANCELMODE, so it still can\n+     * Modal loop may not exit immediately after WM_CANCELMODE, so it still can\n@@ -3203,2 +3203,2 @@\n- * The fuction intended for access to an IME API. It posts IME message to the queue and\n- * waits untill the message processing is completed.\n+ * The function intended for access to an IME API. It posts IME message to the queue and\n+ * waits until the message processing is completed.\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Toolkit.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -432,1 +432,1 @@\n-    \/\/ The windows api GetKeyState() when read would provide the key state of the requrested key\n+    \/\/ The windows api GetKeyState() when read would provide the key state of the requested key\n@@ -623,1 +623,1 @@\n-     * This should not be happend if all tray icons are recorded\n+     * This should not be happening if all tray icons are recorded\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_TrayIcon.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -581,1 +581,1 @@\n- * Deterine which device the HWND exists on and return the\n+ * Determine which device the HWND exists on and return the\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsDevice.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-        \/\/else to see if it only inludes \"EUDC.TTE\"\n+        \/\/else to see if it only includes \"EUDC.TTE\"\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -741,1 +741,1 @@\n-                \/\/ Retrive the owner of the warning window.\n+                \/\/ Retrieve the owner of the warning window.\n@@ -2000,1 +2000,1 @@\n-            \/\/Fixed 6355340: Contents of frame are not layed out properly on maximize\n+            \/\/Fixed 6355340: Contents of frame are not laid out properly on maximize\n@@ -2743,1 +2743,1 @@\n-    \/\/Does nothing for windows, is overriden for frames and dialogs\n+    \/\/Does nothing for windows, is overridden for frames and dialogs\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Window.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-    void moveToDefaultLocation(); \/* moves Window to X,Y specified by Window Manger *\/\n+    void moveToDefaultLocation(); \/* moves Window to X,Y specified by Window Manager *\/\n@@ -372,2 +372,2 @@\n-    HICON m_hIcon;            \/* Icon for this window. It can be set explicitely or inherited from the owner *\/\n-    HICON m_hIconSm;          \/* Small icon for this window. It can be set explicitely or inherited from the owner *\/\n+    HICON m_hIcon;            \/* Icon for this window. It can be set explicitly or inherited from the owner *\/\n+    HICON m_hIconSm;          \/* Small icon for this window. It can be set explicitly or inherited from the owner *\/\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Window.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-    \/\/ $$fb 2002-04-04: It is responsability of the application developer to\n+    \/\/ $$fb 2002-04-04: It is the responsibility of the application developer to\n","filename":"src\/java.desktop\/windows\/native\/libjsound\/PLATFORM_API_WinOS_MidiOut.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -534,1 +534,1 @@\n-        \/\/map the splash co-ordinates as per system scale\n+        \/\/map the splash coordinates as per system scale\n","filename":"src\/java.desktop\/windows\/native\/libsplashscreen\/splashscreen_sys.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import javax.naming.spi.*;\n@@ -39,0 +38,2 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n@@ -79,2 +80,2 @@\n-            obj = DirectoryManager.getObjectInstance(obj, cn, homeCtx,\n-                homeCtx.envprops, attrs);\n+            obj = NamingManagerHelper.getDirObjectInstance(obj, cn, homeCtx,\n+                    homeCtx.envprops, attrs, ObjectFactoriesFilter::checkLdapFilter);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapBindingEnumeration.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import javax.naming.spi.*;\n@@ -57,0 +56,2 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n@@ -1114,2 +1115,2 @@\n-            return DirectoryManager.getObjectInstance(obj, name,\n-                this, envprops, attrs);\n+            return NamingManagerHelper.getDirObjectInstance(obj, name, this,\n+                    envprops, attrs, ObjectFactoriesFilter::checkLdapFilter);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapCtx.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import javax.naming.spi.*;\n@@ -36,0 +35,2 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n@@ -119,2 +120,2 @@\n-                obj = NamingManager.getObjectInstance(ref, null, null, env);\n-\n+                obj = NamingManagerHelper.getObjectInstance(ref, null, null,\n+                        env, ObjectFactoriesFilter::checkLdapFilter);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapReferralContext.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import javax.naming.spi.*;\n@@ -40,0 +39,2 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n@@ -137,1 +138,1 @@\n-                obj = DirectoryManager.getObjectInstance(\n+                obj = NamingManagerHelper.getDirObjectInstance(\n@@ -139,1 +140,1 @@\n-                    homeCtx.envprops, attrs);\n+                    homeCtx.envprops, attrs, ObjectFactoriesFilter::checkLdapFilter);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapSearchEnumeration.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,422 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.naming.internal;\n+\n+import javax.naming.Context;\n+import javax.naming.Name;\n+import javax.naming.NamingException;\n+import javax.naming.RefAddr;\n+import javax.naming.Reference;\n+import javax.naming.Referenceable;\n+import javax.naming.StringRefAddr;\n+import javax.naming.directory.Attributes;\n+import javax.naming.spi.DirObjectFactory;\n+import javax.naming.spi.ObjectFactory;\n+import javax.naming.spi.ObjectFactoryBuilder;\n+import java.net.MalformedURLException;\n+import java.util.Hashtable;\n+import java.util.function.Predicate;\n+\n+public class NamingManagerHelper {\n+\n+    public static Object getObjectInstance(Object refInfo, Name name, Context nameCtx,\n+                                           Hashtable<?,?> environment,\n+                                           Predicate<Class<?>> factoryFilter) throws Exception {\n+        ObjectFactory factory;\n+\n+        \/\/ Use builder if installed\n+        ObjectFactoryBuilder builder = getObjectFactoryBuilder();\n+        if (builder != null) {\n+            \/\/ builder must return non-null factory\n+            factory = builder.createObjectFactory(refInfo, environment);\n+            return factory.getObjectInstance(refInfo, name, nameCtx,\n+                    environment);\n+        }\n+\n+        \/\/ Use reference if possible\n+        Reference ref = null;\n+        if (refInfo instanceof Reference) {\n+            ref = (Reference) refInfo;\n+        } else if (refInfo instanceof Referenceable) {\n+            ref = ((Referenceable)(refInfo)).getReference();\n+        }\n+\n+        Object answer;\n+\n+        if (ref != null) {\n+            String f = ref.getFactoryClassName();\n+            if (f != null) {\n+                \/\/ if reference identifies a factory, use exclusively\n+\n+                factory = getObjectFactoryFromReference(ref, f, factoryFilter);\n+                if (factory != null) {\n+                    return factory.getObjectInstance(ref, name, nameCtx,\n+                            environment);\n+                }\n+                \/\/ No factory found, so return original refInfo.\n+                \/\/ That could happen if:\n+                \/\/  - a factory class is not in a class path and reference does\n+                \/\/    not contain a URL for it\n+                \/\/  - a factory class is available but object factory filters\n+                \/\/    disallow its usage\n+                return refInfo;\n+\n+            } else {\n+                \/\/ if reference has no factory, check for addresses\n+                \/\/ containing URLs\n+\n+                answer = processURLAddrs(ref, name, nameCtx, environment);\n+                if (answer != null) {\n+                    return answer;\n+                }\n+            }\n+        }\n+\n+        \/\/ try using any specified factories\n+        answer =\n+                createObjectFromFactories(refInfo, name, nameCtx, environment);\n+        return (answer != null) ? answer : refInfo;\n+    }\n+\n+\n+    public static Object getDirObjectInstance(Object refInfo, Name name, Context nameCtx,\n+                      Hashtable<?,?> environment, Attributes attrs,\n+                      Predicate<Class<?>> factoryFilter) throws Exception {\n+        ObjectFactory factory;\n+\n+        ObjectFactoryBuilder builder = getObjectFactoryBuilder();\n+        if (builder != null) {\n+            \/\/ builder must return non-null factory\n+            factory = builder.createObjectFactory(refInfo, environment);\n+            if (factory instanceof DirObjectFactory) {\n+                return ((DirObjectFactory)factory).getObjectInstance(\n+                        refInfo, name, nameCtx, environment, attrs);\n+            } else {\n+                return factory.getObjectInstance(refInfo, name, nameCtx,\n+                        environment);\n+            }\n+        }\n+\n+        \/\/ use reference if possible\n+        Reference ref = null;\n+        if (refInfo instanceof Reference) {\n+            ref = (Reference) refInfo;\n+        } else if (refInfo instanceof Referenceable) {\n+            ref = ((Referenceable)(refInfo)).getReference();\n+        }\n+\n+        Object answer;\n+\n+        if (ref != null) {\n+            String f = ref.getFactoryClassName();\n+            if (f != null) {\n+                \/\/ if reference identifies a factory, use exclusively\n+\n+                factory = getObjectFactoryFromReference(ref, f, factoryFilter);\n+                if (factory instanceof DirObjectFactory) {\n+                    return ((DirObjectFactory)factory).getObjectInstance(\n+                            ref, name, nameCtx, environment, attrs);\n+                } else if (factory != null) {\n+                    return factory.getObjectInstance(ref, name, nameCtx,\n+                            environment);\n+                }\n+                \/\/ No factory found, so return original refInfo.\n+                \/\/ That could happen if:\n+                \/\/  - a factory class is not in a class path and reference does\n+                \/\/    not contain a URL for it\n+                \/\/  - a factory class is available but object factory filters\n+                \/\/    disallow its usage\n+                return refInfo;\n+\n+            } else {\n+                \/\/ if reference has no factory, check for addresses\n+                \/\/ containing URLs\n+                \/\/ ignore name & attrs params; not used in URL factory\n+                \/\/ RMI references from '\n+                answer = processURLAddrs(ref, name, nameCtx, environment);\n+                if (answer != null) {\n+                    return answer;\n+                }\n+            }\n+        }\n+\n+        \/\/ try using any specified factories\n+        answer = createObjectFromFactories(refInfo, name, nameCtx,\n+                environment, attrs);\n+        return (answer != null) ? answer : refInfo;\n+    }\n+\n+    \/**\n+     * Retrieves the ObjectFactory for the object identified by a reference,\n+     * using the reference's factory class name and factory codebase\n+     * to load in the factory's class.\n+     * @param ref The non-null reference to use.\n+     * @param factoryName The non-null class name of the factory.\n+     * @return The object factory for the object identified by ref; null\n+     * if unable to load the factory.\n+     *\/\n+    static ObjectFactory getObjectFactoryFromReference(\n+            Reference ref, String factoryName, Predicate<Class<?>> filter)\n+            throws IllegalAccessException,\n+            InstantiationException,\n+            MalformedURLException {\n+        Class<?> clas = null;\n+\n+        \/\/ Try to use current class loader\n+        try {\n+            clas = helper.loadClassWithoutInit(factoryName);\n+            \/\/ Validate factory's class with the objects factory serial filter\n+            if (!filter.test(clas)) {\n+                return null;\n+            }\n+        } catch (ClassNotFoundException e) {\n+            \/\/ ignore and continue\n+            \/\/ e.printStackTrace();\n+        }\n+        \/\/ All other exceptions are passed up.\n+\n+        \/\/ Not in class path; try to use codebase\n+        String codebase;\n+        if (clas == null &&\n+                (codebase = ref.getFactoryClassLocation()) != null) {\n+            try {\n+                clas = helper.loadClass(factoryName, codebase);\n+                \/\/ Validate factory's class with the objects factory serial filter\n+                if (clas == null || !filter.test(clas)) {\n+                    return null;\n+                }\n+            } catch (ClassNotFoundException e) {\n+            }\n+        }\n+\n+        @SuppressWarnings(\"deprecation\") \/\/ Class.newInstance\n+        ObjectFactory result = (clas != null) ? (ObjectFactory) clas.newInstance() : null;\n+        return result;\n+    }\n+\n+    \/**\n+     * Creates an object using the factories specified in the\n+     * {@code Context.OBJECT_FACTORIES} property of the environment\n+     * or of the provider resource file associated with {@code nameCtx}.\n+     *\n+     * @return factory created; null if cannot create\n+     *\/\n+    private static Object createObjectFromFactories(Object obj, Name name,\n+                                                    Context nameCtx, Hashtable<?,?> environment, Attributes attrs)\n+            throws Exception {\n+\n+        FactoryEnumeration factories = ResourceManager.getFactories(\n+                Context.OBJECT_FACTORIES, environment, nameCtx);\n+\n+        if (factories == null)\n+            return null;\n+\n+        ObjectFactory factory;\n+        Object answer = null;\n+        \/\/ Try each factory until one succeeds\n+        while (answer == null && factories.hasMore()) {\n+            factory = (ObjectFactory)factories.next();\n+            if (factory instanceof DirObjectFactory) {\n+                answer = ((DirObjectFactory)factory).\n+                        getObjectInstance(obj, name, nameCtx, environment, attrs);\n+            } else {\n+                answer =\n+                        factory.getObjectInstance(obj, name, nameCtx, environment);\n+            }\n+        }\n+        return answer;\n+    }\n+\n+    \/*\n+     * Ref has no factory.  For each address of type \"URL\", try its URL\n+     * context factory.  Returns null if unsuccessful in creating and\n+     * invoking a factory.\n+     *\/\n+    static Object processURLAddrs(Reference ref, Name name, Context nameCtx,\n+                                  Hashtable<?,?> environment)\n+            throws NamingException {\n+\n+        for (int i = 0; i < ref.size(); i++) {\n+            RefAddr addr = ref.get(i);\n+            if (addr instanceof StringRefAddr &&\n+                    addr.getType().equalsIgnoreCase(\"URL\")) {\n+\n+                String url = (String)addr.getContent();\n+                Object answer = processURL(url, name, nameCtx, environment);\n+                if (answer != null) {\n+                    return answer;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static Object processURL(Object refInfo, Name name,\n+                                     Context nameCtx, Hashtable<?,?> environment)\n+            throws NamingException {\n+        Object answer;\n+\n+        \/\/ If refInfo is a URL string, try to use its URL context factory\n+        \/\/ If no context found, continue to try object factories.\n+        if (refInfo instanceof String) {\n+            String url = (String)refInfo;\n+            String scheme = getURLScheme(url);\n+            if (scheme != null) {\n+                answer = getURLObject(scheme, refInfo, name, nameCtx,\n+                        environment);\n+                if (answer != null) {\n+                    return answer;\n+                }\n+            }\n+        }\n+\n+        \/\/ If refInfo is an array of URL strings,\n+        \/\/ try to find a context factory for any one of its URLs.\n+        \/\/ If no context found, continue to try object factories.\n+        if (refInfo instanceof String[]) {\n+            String[] urls = (String[])refInfo;\n+            for (int i = 0; i <urls.length; i++) {\n+                String scheme = getURLScheme(urls[i]);\n+                if (scheme != null) {\n+                    answer = getURLObject(scheme, refInfo, name, nameCtx,\n+                            environment);\n+                    if (answer != null)\n+                        return answer;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static String getURLScheme(String str) {\n+        int colon_posn = str.indexOf(':');\n+        int slash_posn = str.indexOf('\/');\n+\n+        if (colon_posn > 0 && (slash_posn == -1 || colon_posn < slash_posn))\n+            return str.substring(0, colon_posn);\n+        return null;\n+    }\n+\n+    \/**\n+     * Creates an object for the given URL scheme id using\n+     * the supplied urlInfo.\n+     * <p>\n+     * If urlInfo is null, the result is a context for resolving URLs\n+     * with the scheme id 'scheme'.\n+     * If urlInfo is a URL, the result is a context named by the URL.\n+     * Names passed to this context is assumed to be relative to this\n+     * context (i.e. not a URL). For example, if urlInfo is\n+     * \"ldap:\/\/ldap.wiz.com\/o=Wiz,c=us\", the resulting context will\n+     * be that pointed to by \"o=Wiz,c=us\" on the server 'ldap.wiz.com'.\n+     * Subsequent names that can be passed to this context will be\n+     * LDAP names relative to this context (e.g. cn=\"Barbs Jensen\").\n+     * If urlInfo is an array of URLs, the URLs are assumed\n+     * to be equivalent in terms of the context to which they refer.\n+     * The resulting context is like that of the single URL case.\n+     * If urlInfo is of any other type, that is handled by the\n+     * context factory for the URL scheme.\n+     * @param scheme the URL scheme id for the context\n+     * @param urlInfo information used to create the context\n+     * @param name name of this object relative to {@code nameCtx}\n+     * @param nameCtx Context whose provider resource file will be searched\n+     *          for package prefix values (or null if none)\n+     * @param environment Environment properties for creating the context\n+     * @see javax.naming.InitialContext\n+     *\/\n+    private static Object getURLObject(String scheme, Object urlInfo,\n+                                       Name name, Context nameCtx,\n+                                       Hashtable<?,?> environment)\n+            throws NamingException {\n+\n+        \/\/ e.g. \"ftpURLContextFactory\"\n+        ObjectFactory factory = (ObjectFactory)ResourceManager.getFactory(\n+                Context.URL_PKG_PREFIXES, environment, nameCtx,\n+                \".\" + scheme + \".\" + scheme + \"URLContextFactory\", DEFAULT_PKG_PREFIX);\n+\n+        if (factory == null)\n+            return null;\n+\n+        \/\/ Found object factory\n+        try {\n+            return factory.getObjectInstance(urlInfo, name, nameCtx, environment);\n+        } catch (NamingException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            NamingException ne = new NamingException();\n+            ne.setRootCause(e);\n+            throw ne;\n+        }\n+    }\n+\n+    \/**\n+     * Creates an object using the factories specified in the\n+     * {@code Context.OBJECT_FACTORIES} property of the environment\n+     * or of the provider resource file associated with {@code nameCtx}.\n+     *\n+     * @return factory created; null if cannot create\n+     *\/\n+    private static Object createObjectFromFactories(Object obj, Name name,\n+                                                    Context nameCtx, Hashtable<?,?> environment) throws Exception {\n+\n+        FactoryEnumeration factories = ResourceManager.getFactories(\n+                Context.OBJECT_FACTORIES, environment, nameCtx);\n+\n+        if (factories == null)\n+            return null;\n+\n+        \/\/ Try each factory until one succeeds\n+        ObjectFactory factory;\n+        Object answer = null;\n+        while (answer == null && factories.hasMore()) {\n+            factory = (ObjectFactory)factories.next();\n+            answer = factory.getObjectInstance(obj, name, nameCtx, environment);\n+        }\n+        return answer;\n+    }\n+\n+    public static synchronized void setObjectFactoryBuilder(\n+            ObjectFactoryBuilder builder) throws NamingException {\n+        if (object_factory_builder != null)\n+            throw new IllegalStateException(\"ObjectFactoryBuilder already set\");\n+\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager security = System.getSecurityManager();\n+        if (security != null) {\n+            security.checkSetFactory();\n+        }\n+        object_factory_builder = builder;\n+    }\n+\n+    public static synchronized ObjectFactoryBuilder getObjectFactoryBuilder() {\n+        return object_factory_builder;\n+    }\n+\n+    private static final String DEFAULT_PKG_PREFIX = \"com.sun.jndi.url\";\n+    static final VersionHelper helper = VersionHelper.getVersionHelper();\n+\n+    private static ObjectFactoryBuilder object_factory_builder = null;\n+\n+}\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/naming\/internal\/NamingManagerHelper.java","additions":422,"deletions":0,"binary":false,"changes":422,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-     * If the filter result is not {@linkplain Status#REJECTED REJECTED}, the filter will\n+     * If the filter result is {@linkplain Status#ALLOWED ALLOWED}, the filter will\n@@ -56,1 +56,1 @@\n-     * @param factoryClass objects factory class\n+     * @param serialClass objects factory class\n@@ -59,2 +59,2 @@\n-    public static boolean canInstantiateObjectsFactory(Class<?> factoryClass) {\n-        return checkInput(() -> factoryClass);\n+    public static boolean checkGlobalFilter(Class<?> serialClass) {\n+        return checkInput(GLOBAL_FILTER, () -> serialClass);\n@@ -63,3 +63,42 @@\n-    private static boolean checkInput(FactoryInfo factoryInfo) {\n-        Status result = GLOBAL.checkInput(factoryInfo);\n-        return result != Status.REJECTED;\n+    \/**\n+     * Checks if the factory filters allow the given factory class for LDAP.\n+     * This method combines the global and LDAP specific filter results to determine\n+     * if the given factory class is allowed.\n+     * The given factory class is rejected if any of these two filters reject\n+     * it, or if none of them allow it.\n+     *\n+     * @param serialClass objects factory class\n+     * @return true - if the factory is allowed to be instantiated; false - otherwise\n+     *\/\n+    public static boolean checkLdapFilter(Class<?> serialClass) {\n+        return checkInput(LDAP_FILTER, () -> serialClass);\n+    }\n+\n+    \/**\n+     * Checks if the factory filters allow the given factory class for RMI.\n+     * This method combines the global and RMI specific filter results to determine\n+     * if the given factory class is allowed.\n+     * The given factory class is rejected if any of these two filters reject\n+     * it, or if none of them allow it.\n+     *\n+     * @param serialClass objects factory class\n+     * @return true - if the factory is allowed to be instantiated; false - otherwise\n+     *\/\n+    public static boolean checkRmiFilter(Class<?> serialClass) {\n+        return checkInput(RMI_FILTER, () -> serialClass);\n+    }\n+\n+    private static boolean checkInput(ConfiguredFilter filter, FactoryInfo serialClass) {\n+        var globalFilter = GLOBAL_FILTER.filter();\n+        var specificFilter = filter.filter();\n+        Status globalResult = globalFilter.checkInput(serialClass);\n+\n+        \/\/ Check if a specific filter is the global one\n+        if (filter == GLOBAL_FILTER) {\n+            return globalResult == Status.ALLOWED;\n+        }\n+        return switch (globalResult) {\n+            case ALLOWED -> specificFilter.checkInput(serialClass) != Status.REJECTED;\n+            case REJECTED -> false;\n+            case UNDECIDED -> specificFilter.checkInput(serialClass) == Status.ALLOWED;\n+        };\n@@ -100,1 +139,12 @@\n-    private static final String FACTORIES_FILTER_PROPNAME = \"jdk.jndi.object.factoriesFilter\";\n+    private static final String GLOBAL_FACTORIES_FILTER_PROPNAME =\n+            \"jdk.jndi.object.factoriesFilter\";\n+\n+    \/\/ System property name that contains the patterns to filter LDAP object factory\n+    \/\/ names\n+    private static final String LDAP_FACTORIES_FILTER_PROPNAME =\n+            \"jdk.jndi.ldap.object.factoriesFilter\";\n+\n+    \/\/ System property name that contains the patterns to filter RMI object factory\n+    \/\/ names\n+    private static final String RMI_FACTORIES_FILTER_PROPNAME =\n+            \"jdk.jndi.rmi.object.factoriesFilter\";\n@@ -102,2 +152,3 @@\n-    \/\/ Default system property value that allows the load of any object factory classes\n-    private static final String DEFAULT_SP_VALUE = \"*\";\n+    \/\/ Default system property value that allows the load of any object factory\n+    \/\/ classes\n+    private static final String DEFAULT_GLOBAL_SP_VALUE = \"*\";\n@@ -105,3 +156,63 @@\n-    \/\/ System wide object factories filter constructed from the system property\n-    private static final ObjectInputFilter GLOBAL =\n-            ObjectInputFilter.Config.createFilter(getFilterPropertyValue());\n+    \/\/ Default system property value that allows the load of any object factory\n+    \/\/ class provided by the JDK LDAP provider implementation\n+    private static final String DEFAULT_LDAP_SP_VALUE =\n+            \"java.naming\/com.sun.jndi.ldap.**;!*\";\n+\n+    \/\/ Default system property value that allows the load of any object factory\n+    \/\/ class provided by the JDK RMI provider implementation\n+    private static final String DEFAULT_RMI_SP_VALUE =\n+            \"jdk.naming.rmi\/com.sun.jndi.rmi.**;!*\";\n+\n+    \/\/ A system-wide global object factories filter constructed from the system\n+    \/\/ property\n+    private static final ConfiguredFilter GLOBAL_FILTER =\n+            initializeFilter(GLOBAL_FACTORIES_FILTER_PROPNAME, DEFAULT_GLOBAL_SP_VALUE);\n+\n+    \/\/ A system-wide LDAP specific object factories filter constructed from the system\n+    \/\/ property\n+    private static final ConfiguredFilter LDAP_FILTER =\n+            initializeFilter(LDAP_FACTORIES_FILTER_PROPNAME, DEFAULT_LDAP_SP_VALUE);\n+\n+    \/\/ A system-wide RMI specific object factories filter constructed from the system\n+    \/\/ property\n+    private static final ConfiguredFilter RMI_FILTER =\n+            initializeFilter(RMI_FACTORIES_FILTER_PROPNAME, DEFAULT_RMI_SP_VALUE);\n+\n+    \/\/ Record for storing a factory filter configuration\n+    private interface ConfiguredFilter {\n+        ObjectInputFilter filter();\n+    }\n+\n+    \/\/ Record to store an object input filter constructed from a valid filter\n+    \/\/ pattern string\n+    private record ValidFilter(ObjectInputFilter filter)\n+            implements ConfiguredFilter {\n+    }\n+\n+    \/\/ Record to store parsing results for a filter with\n+    \/\/ illegal or malformed pattern string\n+    private record InvalidFilter(String filterPropertyName,\n+                                 IllegalArgumentException error)\n+            implements ConfiguredFilter {\n+\n+        @Override\n+        public ObjectInputFilter filter() {\n+            \/\/ Report a filter property name and an error message\n+            throw new IllegalArgumentException(filterPropertyName +\n+                    \": \" + error.getMessage());\n+        }\n+    }\n+\n+    \/\/ Read filter pattern value from a system\/security property\n+    \/\/ and create a filter record from it (valid or invalid).\n+    private static ConfiguredFilter initializeFilter(String filterPropertyName,\n+                                                     String filterDefaultValue) {\n+        try {\n+            var filter = ObjectInputFilter.Config.createFilter(\n+                    getFilterPropertyValue(filterPropertyName,\n+                            filterDefaultValue));\n+            return new ValidFilter(filter);\n+        } catch (IllegalArgumentException iae) {\n+            return new InvalidFilter(filterPropertyName, iae);\n+        }\n+    }\n@@ -110,3 +221,4 @@\n-    private static String getFilterPropertyValue() {\n-        String propVal = SecurityProperties.privilegedGetOverridable(FACTORIES_FILTER_PROPNAME);\n-        return propVal != null ? propVal : DEFAULT_SP_VALUE;\n+    private static String getFilterPropertyValue(String propertyName,\n+                                                 String defaultValue) {\n+        String propVal = SecurityProperties.privilegedGetOverridable(propertyName);\n+        return propVal != null ? propVal : defaultValue;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/naming\/internal\/ObjectFactoriesFilter.java","additions":129,"deletions":17,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -416,0 +416,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -420,0 +424,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -424,0 +432,3 @@\n+    \/**\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -428,0 +439,3 @@\n+    \/**\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -432,0 +446,3 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     *\/\n@@ -436,0 +453,3 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     *\/\n@@ -440,0 +460,3 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     *\/\n@@ -444,0 +467,3 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     *\/\n@@ -472,0 +498,5 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     * @throws  NotContextException {@inheritDoc}\n+     * @throws  ContextNotEmptyException {@inheritDoc}\n+     *\/\n@@ -476,0 +507,5 @@\n+    \/**\n+     * @throws  NameNotFoundException {@inheritDoc}\n+     * @throws  NotContextException {@inheritDoc}\n+     * @throws  ContextNotEmptyException {@inheritDoc}\n+     *\/\n@@ -480,0 +516,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -484,0 +524,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  javax.naming.directory.InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -554,0 +598,3 @@\n+    \/**\n+     * @throws OperationNotSupportedException {@inheritDoc}\n+     *\/\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/InitialContext.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,0 +477,2 @@\n+      *\n+      * @throws OperationNotSupportedException {@inheritDoc}\n@@ -487,0 +489,2 @@\n+      *\n+      * @throws OperationNotSupportedException {@inheritDoc}\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/BasicAttribute.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -184,0 +184,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -189,0 +192,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -194,0 +200,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -199,0 +208,3 @@\n+    \/**\n+     * @throws  AttributeModificationException {@inheritDoc}\n+     *\/\n@@ -204,0 +216,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -209,0 +225,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -214,0 +234,3 @@\n+    \/**\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -219,0 +242,3 @@\n+    \/**\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -224,0 +250,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -229,0 +259,4 @@\n+    \/**\n+     * @throws  NameAlreadyBoundException {@inheritDoc}\n+     * @throws  InvalidAttributesException {@inheritDoc}\n+     *\/\n@@ -234,0 +268,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -238,0 +275,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -242,0 +282,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -247,0 +290,3 @@\n+    \/**\n+     * @throws  OperationNotSupportedException {@inheritDoc}\n+     *\/\n@@ -290,0 +336,4 @@\n+    \/**\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     *\/\n@@ -299,0 +349,4 @@\n+    \/**\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     *\/\n@@ -308,0 +362,4 @@\n+    \/**\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     *\/\n@@ -319,0 +377,4 @@\n+    \/**\n+     * @throws  InvalidSearchControlsException {@inheritDoc}\n+     * @throws  InvalidSearchFilterException {@inheritDoc}\n+     *\/\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/directory\/InitialDirContext.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import javax.naming.Reference;\n-import javax.naming.Referenceable;\n@@ -39,0 +37,2 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n@@ -157,86 +157,2 @@\n-\n-            ObjectFactory factory;\n-\n-            ObjectFactoryBuilder builder = getObjectFactoryBuilder();\n-            if (builder != null) {\n-                \/\/ builder must return non-null factory\n-                factory = builder.createObjectFactory(refInfo, environment);\n-                if (factory instanceof DirObjectFactory) {\n-                    return ((DirObjectFactory)factory).getObjectInstance(\n-                        refInfo, name, nameCtx, environment, attrs);\n-                } else {\n-                    return factory.getObjectInstance(refInfo, name, nameCtx,\n-                        environment);\n-                }\n-            }\n-\n-            \/\/ use reference if possible\n-            Reference ref = null;\n-            if (refInfo instanceof Reference) {\n-                ref = (Reference) refInfo;\n-            } else if (refInfo instanceof Referenceable) {\n-                ref = ((Referenceable)(refInfo)).getReference();\n-            }\n-\n-            Object answer;\n-\n-            if (ref != null) {\n-                String f = ref.getFactoryClassName();\n-                if (f != null) {\n-                    \/\/ if reference identifies a factory, use exclusively\n-\n-                    factory = getObjectFactoryFromReference(ref, f);\n-                    if (factory instanceof DirObjectFactory) {\n-                        return ((DirObjectFactory)factory).getObjectInstance(\n-                            ref, name, nameCtx, environment, attrs);\n-                    } else if (factory != null) {\n-                        return factory.getObjectInstance(ref, name, nameCtx,\n-                                                         environment);\n-                    }\n-                    \/\/ No factory found, so return original refInfo.\n-                    \/\/ Will reach this point if factory class is not in\n-                    \/\/ class path and reference does not contain a URL for it\n-                    return refInfo;\n-\n-                } else {\n-                    \/\/ if reference has no factory, check for addresses\n-                    \/\/ containing URLs\n-                    \/\/ ignore name & attrs params; not used in URL factory\n-\n-                    answer = processURLAddrs(ref, name, nameCtx, environment);\n-                    if (answer != null) {\n-                        return answer;\n-                    }\n-                }\n-            }\n-\n-            \/\/ try using any specified factories\n-            answer = createObjectFromFactories(refInfo, name, nameCtx,\n-                                               environment, attrs);\n-            return (answer != null) ? answer : refInfo;\n-    }\n-\n-    private static Object createObjectFromFactories(Object obj, Name name,\n-            Context nameCtx, Hashtable<?,?> environment, Attributes attrs)\n-        throws Exception {\n-\n-        FactoryEnumeration factories = ResourceManager.getFactories(\n-            Context.OBJECT_FACTORIES, environment, nameCtx);\n-\n-        if (factories == null)\n-            return null;\n-\n-        ObjectFactory factory;\n-        Object answer = null;\n-        \/\/ Try each factory until one succeeds\n-        while (answer == null && factories.hasMore()) {\n-            factory = (ObjectFactory)factories.next();\n-            if (factory instanceof DirObjectFactory) {\n-                answer = ((DirObjectFactory)factory).\n-                    getObjectInstance(obj, name, nameCtx, environment, attrs);\n-            } else {\n-                answer =\n-                    factory.getObjectInstance(obj, name, nameCtx, environment);\n-            }\n-        }\n-        return answer;\n+            return NamingManagerHelper.getDirObjectInstance(refInfo, name, nameCtx,\n+                    environment, attrs, ObjectFactoriesFilter::checkGlobalFilter);\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/DirectoryManager.java","additions":5,"deletions":89,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.net.MalformedURLException;\n@@ -35,0 +34,1 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n@@ -81,5 +81,0 @@\n-    \/**\n-     * Package-private; used by DirectoryManager and NamingManager.\n-     *\/\n-    private static ObjectFactoryBuilder object_factory_builder = null;\n-\n@@ -114,1 +109,1 @@\n-    public static synchronized void setObjectFactoryBuilder(\n+    public static void setObjectFactoryBuilder(\n@@ -116,9 +111,1 @@\n-        if (object_factory_builder != null)\n-            throw new IllegalStateException(\"ObjectFactoryBuilder already set\");\n-\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkSetFactory();\n-        }\n-        object_factory_builder = builder;\n+        NamingManagerHelper.setObjectFactoryBuilder(builder);\n@@ -130,88 +117,2 @@\n-    static synchronized ObjectFactoryBuilder getObjectFactoryBuilder() {\n-        return object_factory_builder;\n-    }\n-\n-\n-    \/**\n-     * Retrieves the ObjectFactory for the object identified by a reference,\n-     * using the reference's factory class name and factory codebase\n-     * to load in the factory's class.\n-     * @param ref The non-null reference to use.\n-     * @param factoryName The non-null class name of the factory.\n-     * @return The object factory for the object identified by ref; null\n-     * if unable to load the factory.\n-     *\/\n-    static ObjectFactory getObjectFactoryFromReference(\n-        Reference ref, String factoryName)\n-        throws IllegalAccessException,\n-        InstantiationException,\n-        MalformedURLException {\n-        Class<?> clas = null;\n-\n-        \/\/ Try to use current class loader\n-        try {\n-            clas = helper.loadClassWithoutInit(factoryName);\n-            \/\/ Validate factory's class with the objects factory serial filter\n-            if (!ObjectFactoriesFilter.canInstantiateObjectsFactory(clas)) {\n-                return null;\n-            }\n-        } catch (ClassNotFoundException e) {\n-            \/\/ ignore and continue\n-            \/\/ e.printStackTrace();\n-        }\n-        \/\/ All other exceptions are passed up.\n-\n-        \/\/ Not in class path; try to use codebase\n-        String codebase;\n-        if (clas == null &&\n-                (codebase = ref.getFactoryClassLocation()) != null) {\n-            try {\n-                clas = helper.loadClass(factoryName, codebase);\n-                \/\/ Validate factory's class with the objects factory serial filter\n-                if (clas == null ||\n-                    !ObjectFactoriesFilter.canInstantiateObjectsFactory(clas)) {\n-                    return null;\n-                }\n-            } catch (ClassNotFoundException e) {\n-            }\n-        }\n-\n-        @SuppressWarnings(\"deprecation\") \/\/ Class.newInstance\n-        ObjectFactory result = (clas != null) ? (ObjectFactory) clas.newInstance() : null;\n-        return result;\n-    }\n-\n-\n-    \/**\n-     * Creates an object using the factories specified in the\n-     * {@code Context.OBJECT_FACTORIES} property of the environment\n-     * or of the provider resource file associated with {@code nameCtx}.\n-     *\n-     * @return factory created; null if cannot create\n-     *\/\n-    private static Object createObjectFromFactories(Object obj, Name name,\n-            Context nameCtx, Hashtable<?,?> environment) throws Exception {\n-\n-        FactoryEnumeration factories = ResourceManager.getFactories(\n-            Context.OBJECT_FACTORIES, environment, nameCtx);\n-\n-        if (factories == null)\n-            return null;\n-\n-        \/\/ Try each factory until one succeeds\n-        ObjectFactory factory;\n-        Object answer = null;\n-        while (answer == null && factories.hasMore()) {\n-            factory = (ObjectFactory)factories.next();\n-            answer = factory.getObjectInstance(obj, name, nameCtx, environment);\n-        }\n-        return answer;\n-    }\n-\n-    private static String getURLScheme(String str) {\n-        int colon_posn = str.indexOf(':');\n-        int slash_posn = str.indexOf('\/');\n-\n-        if (colon_posn > 0 && (slash_posn == -1 || colon_posn < slash_posn))\n-            return str.substring(0, colon_posn);\n-        return null;\n+    static ObjectFactoryBuilder getObjectFactoryBuilder() {\n+        return NamingManagerHelper.getObjectFactoryBuilder();\n@@ -311,54 +212,3 @@\n-        throws Exception\n-    {\n-\n-        ObjectFactory factory;\n-\n-        \/\/ Use builder if installed\n-        ObjectFactoryBuilder builder = getObjectFactoryBuilder();\n-        if (builder != null) {\n-            \/\/ builder must return non-null factory\n-            factory = builder.createObjectFactory(refInfo, environment);\n-            return factory.getObjectInstance(refInfo, name, nameCtx,\n-                environment);\n-        }\n-\n-        \/\/ Use reference if possible\n-        Reference ref = null;\n-        if (refInfo instanceof Reference) {\n-            ref = (Reference) refInfo;\n-        } else if (refInfo instanceof Referenceable) {\n-            ref = ((Referenceable)(refInfo)).getReference();\n-        }\n-\n-        Object answer;\n-\n-        if (ref != null) {\n-            String f = ref.getFactoryClassName();\n-            if (f != null) {\n-                \/\/ if reference identifies a factory, use exclusively\n-\n-                factory = getObjectFactoryFromReference(ref, f);\n-                if (factory != null) {\n-                    return factory.getObjectInstance(ref, name, nameCtx,\n-                                                     environment);\n-                }\n-                \/\/ No factory found, so return original refInfo.\n-                \/\/ Will reach this point if factory class is not in\n-                \/\/ class path and reference does not contain a URL for it\n-                return refInfo;\n-\n-            } else {\n-                \/\/ if reference has no factory, check for addresses\n-                \/\/ containing URLs\n-\n-                answer = processURLAddrs(ref, name, nameCtx, environment);\n-                if (answer != null) {\n-                    return answer;\n-                }\n-            }\n-        }\n-\n-        \/\/ try using any specified factories\n-        answer =\n-            createObjectFromFactories(refInfo, name, nameCtx, environment);\n-        return (answer != null) ? answer : refInfo;\n+        throws Exception {\n+        return NamingManagerHelper.getObjectInstance(refInfo, name, nameCtx,\n+                environment, ObjectFactoriesFilter::checkGlobalFilter);\n@@ -367,62 +217,0 @@\n-    \/*\n-     * Ref has no factory.  For each address of type \"URL\", try its URL\n-     * context factory.  Returns null if unsuccessful in creating and\n-     * invoking a factory.\n-     *\/\n-    static Object processURLAddrs(Reference ref, Name name, Context nameCtx,\n-                                  Hashtable<?,?> environment)\n-            throws NamingException {\n-\n-        for (int i = 0; i < ref.size(); i++) {\n-            RefAddr addr = ref.get(i);\n-            if (addr instanceof StringRefAddr &&\n-                addr.getType().equalsIgnoreCase(\"URL\")) {\n-\n-                String url = (String)addr.getContent();\n-                Object answer = processURL(url, name, nameCtx, environment);\n-                if (answer != null) {\n-                    return answer;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private static Object processURL(Object refInfo, Name name,\n-                                     Context nameCtx, Hashtable<?,?> environment)\n-            throws NamingException {\n-        Object answer;\n-\n-        \/\/ If refInfo is a URL string, try to use its URL context factory\n-        \/\/ If no context found, continue to try object factories.\n-        if (refInfo instanceof String) {\n-            String url = (String)refInfo;\n-            String scheme = getURLScheme(url);\n-            if (scheme != null) {\n-                answer = getURLObject(scheme, refInfo, name, nameCtx,\n-                                      environment);\n-                if (answer != null) {\n-                    return answer;\n-                }\n-            }\n-        }\n-\n-        \/\/ If refInfo is an array of URL strings,\n-        \/\/ try to find a context factory for any one of its URLs.\n-        \/\/ If no context found, continue to try object factories.\n-        if (refInfo instanceof String[]) {\n-            String[] urls = (String[])refInfo;\n-            for (int i = 0; i <urls.length; i++) {\n-                String scheme = getURLScheme(urls[i]);\n-                if (scheme != null) {\n-                    answer = getURLObject(scheme, refInfo, name, nameCtx,\n-                                          environment);\n-                    if (answer != null)\n-                        return answer;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/NamingManager.java","additions":9,"deletions":221,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -99,1 +99,2 @@\n- *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}.\n+ *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}. Limit patterns\n+ *          specified in the filter property are unused.\n@@ -106,0 +107,17 @@\n+ *     <li>{@systemProperty jdk.jndi.ldap.object.factoriesFilter}:\n+ *          <br>The value of this system property defines a filter used by\n+ *          the JDK LDAP provider implementation to further restrict the set of object factory classes which will\n+ *          be allowed to instantiate objects from object references returned by LDAP systems.\n+ *          The factory class named by the {@linkplain javax.naming.Reference reference instance} first will be\n+ *          matched against this specific filter and then against the global filter. The factory class is rejected\n+ *          if any of these two filters reject it, or if none of them allow it.\n+ *          The filter property supports pattern-based filter syntax with the same format as\n+ *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}. Limit patterns\n+ *          specified in the filter property are unused.\n+ *          <br>The default value allows any object factory class provided by the JDK LDAP provider\n+ *          implementation.\n+ *         <br>This system property will be used to filter LDAP specific object factories only if\n+ *         global {@link javax.naming.spi.ObjectFactoryBuilder} is {@linkplain\n+ *         javax.naming.spi.NamingManager#setObjectFactoryBuilder(javax.naming.spi.ObjectFactoryBuilder)\n+ *         not set}.\n+ *     <\/li>\n@@ -136,0 +154,2 @@\n+    exports com.sun.naming.internal to\n+         jdk.naming.rmi;\n","filename":"src\/java.naming\/share\/classes\/module-info.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-        return ConnectionPool.cacheKey(address, null);\n+        return ConnectionPool.cacheKey(true, address, null);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AsyncSSLConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.net.http.HttpHeaders;\n@@ -109,1 +108,1 @@\n-        return ConnectionPool.cacheKey(address, plainConnection.proxyAddr);\n+        return ConnectionPool.cacheKey(true, address, plainConnection.proxyAddr);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AsyncSSLTunnelConnection.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.System.Logger.Level;\n@@ -71,1 +70,1 @@\n-     * case 1: plain TCP not via proxy (destination only)\n+     * case 1: plain TCP not via proxy (destination IP only)\n@@ -73,2 +72,2 @@\n-     * case 3: SSL not via proxy (destination only)\n-     * case 4: SSL over tunnel (destination and proxy)\n+     * case 3: SSL not via proxy (destination IP+hostname only)\n+     * case 4: SSL over tunnel (destination IP+hostname and proxy)\n@@ -79,0 +78,1 @@\n+        final boolean secure;\n@@ -80,1 +80,2 @@\n-        CacheKey(InetSocketAddress destination, InetSocketAddress proxy) {\n+        private CacheKey(boolean secure, InetSocketAddress destination,\n+                         InetSocketAddress proxy) {\n@@ -83,0 +84,1 @@\n+            this.secure = secure;\n@@ -94,0 +96,3 @@\n+            if (this.secure != other.secure) {\n+                return false;\n+            }\n@@ -100,0 +105,11 @@\n+            if (secure && destination != null) {\n+                if (destination.getHostName() != null) {\n+                    if (!destination.getHostName().equalsIgnoreCase(\n+                            other.destination.getHostName())) {\n+                        return false;\n+                    }\n+                } else {\n+                    if (other.destination.getHostName() != null)\n+                        return false;\n+                }\n+            }\n@@ -131,1 +147,1 @@\n-    static CacheKey cacheKey(InetSocketAddress destination,\n+    static CacheKey cacheKey(boolean secure, InetSocketAddress destination,\n@@ -134,1 +150,1 @@\n-        return new CacheKey(destination, proxy);\n+        return new CacheKey(secure, destination, proxy);\n@@ -143,1 +159,1 @@\n-        CacheKey key = new CacheKey(addr, proxy);\n+        CacheKey key = new CacheKey(secure, addr, proxy);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -417,1 +417,1 @@\n-        return new ConnectionPool.CacheKey(address, null);\n+        return ConnectionPool.cacheKey(false, address, null);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        return new ConnectionPool.CacheKey(null, address);\n+        return ConnectionPool.cacheKey(false, null, address);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainProxyConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.time.Duration;\n@@ -37,1 +36,1 @@\n-import java.net.http.HttpHeaders;\n+\n@@ -156,1 +155,1 @@\n-        return new ConnectionPool.CacheKey(null, proxyAddr);\n+        return ConnectionPool.cacheKey(false, null, proxyAddr);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainTunnelingConnection.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -754,3 +754,8 @@\n-        \/\/ TODO: userinfo deprecated. Needs to be removed\n-        hdrs.setHeader(\":authority\", uri.getAuthority());\n-        \/\/ TODO: ensure header names beginning with : not in user headers\n+        String host = uri.getHost();\n+        int port = uri.getPort();\n+        assert host != null;\n+        if (port != -1) {\n+            hdrs.setHeader(\":authority\", host + \":\" + port);\n+        } else {\n+            hdrs.setHeader(\":authority\", host);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -321,1 +321,1 @@\n-     * @throws NullPointerException {@inheritDoc}.\n+     * @throws NullPointerException {@inheritDoc}\n","filename":"src\/java.prefs\/share\/classes\/java\/util\/prefs\/AbstractPreferences.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-#pragma comment(lib, \"secur32.lib\")\n-\n@@ -898,1 +896,1 @@\n-            outName, sizeof(outName) - 1);\n+            outName, (sizeof(outName) \/ sizeof(outName[0])) - 1);\n","filename":"src\/java.security.jgss\/windows\/native\/libsspi_bridge\/sspi.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -14,2 +14,2 @@\n-   Specifically, we only include the XSLTC portion of the source from the Xalan distribution. \n-   The Xalan project has two processors: an interpretive one (Xalan Interpretive) and a \n+   Specifically, we only include the XSLTC portion of the source from the Xalan distribution.\n+   The Xalan project has two processors: an interpretive one (Xalan Interpretive) and a\n@@ -237,7 +237,7 @@\n-Permission to use, copy, modify, and distribute this software and \n-its documentation for any purpose and without fee is hereby granted, \n-provided that the above copyright notice appear in all copies and that \n-both the copyright notice and this permission notice and warranty \n-disclaimer appear in supporting documentation, and that the name of \n-the authors or their employers not be used in advertising or publicity \n-pertaining to distribution of the software without specific, written \n+Permission to use, copy, modify, and distribute this software and\n+its documentation for any purpose and without fee is hereby granted,\n+provided that the above copyright notice appear in all copies and that\n+both the copyright notice and this permission notice and warranty\n+disclaimer appear in supporting documentation, and that the name of\n+the authors or their employers not be used in advertising or publicity\n+pertaining to distribution of the software without specific, written\n@@ -245,8 +245,8 @@\n-The authors and their employers disclaim all warranties with regard to \n-this software, including all implied warranties of merchantability and \n-fitness. In no event shall the authors or their employers be liable for \n-any special, indirect or consequential damages or any damages whatsoever \n-resulting from loss of use, data or profits, whether in an action of \n-contract, negligence or other tortious action, arising out of or in \n-connection with the use or performance of this software.The portions of \n-JLex output which are hard-coded into the JLex source code are (naturally) \n+The authors and their employers disclaim all warranties with regard to\n+this software, including all implied warranties of merchantability and\n+fitness. In no event shall the authors or their employers be liable for\n+any special, indirect or consequential damages or any damages whatsoever\n+resulting from loss of use, data or profits, whether in an action of\n+contract, negligence or other tortious action, arising out of or in\n+connection with the use or performance of this software.The portions of\n+JLex output which are hard-coded into the JLex source code are (naturally)\n","filename":"src\/java.xml\/share\/legal\/xalan.md","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-    \n+\n","filename":"src\/java.xml\/share\/legal\/xerces.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3972,1 +3972,2 @@\n-        Map<Symbol,Symbol> callMap = new HashMap<>();\n+        \/\/ use LinkedHashMap so we generate errors deterministically\n+        Map<Symbol,Symbol> callMap = new LinkedHashMap<>();\n@@ -4001,1 +4002,1 @@\n-                log.error(TreeInfo.diagnosticPositionFor(ctor, tree),\n+                log.error(TreeInfo.diagnosticPositionFor(ctor, tree, false, t -> t.hasTag(IDENT)),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2316,1 +2316,2 @@\n-                    return isIntersectionOrUnionType(pt);\n+                    if (isIntersectionOrUnionType(pt))\n+                        return true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+    private final TransTypes transTypes;\n@@ -120,0 +121,1 @@\n+        transTypes = TransTypes.instance(context);\n@@ -3551,4 +3553,2 @@\n-            Type eType = types.skipTypeVars(tree.expr.type, false);\n-            tree.expr.type = types.erasure(eType);\n-            if (eType.isCompound())\n-                tree.expr = make.TypeCast(types.erasure(iterableType), tree.expr);\n+            tree.expr.type = types.erasure(types.skipTypeVars(tree.expr.type, false));\n+            tree.expr = transTypes.coerce(attrEnv, tree.expr, types.erasure(iterableType));\n@@ -3557,1 +3557,1 @@\n-                                           eType,\n+                                           tree.expr.type,\n@@ -3559,0 +3559,1 @@\n+            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n@@ -3560,1 +3561,1 @@\n-                                            types.erasure(types.asSuper(iterator.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym)),\n+                                            types.erasure(syms.iteratorType),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.function.Predicate;\n@@ -730,0 +731,5 @@\n+        return diagnosticPositionFor(sym, tree, returnNullIfNotFound, null);\n+    }\n+\n+    public static DiagnosticPosition diagnosticPositionFor(final Symbol sym, final JCTree tree, boolean returnNullIfNotFound,\n+            Predicate<? super JCTree> filter) {\n@@ -731,2 +737,2 @@\n-            DiagScanner(Symbol sym) {\n-                super(sym);\n+            DiagScanner(Symbol sym, Predicate<? super JCTree> filter) {\n+                super(sym, filter);\n@@ -736,2 +742,2 @@\n-                if (that.sym == sym) result = that;\n-                else super.visitIdent(that);\n+                if (!checkMatch(that, that.sym))\n+                    super.visitIdent(that);\n@@ -740,2 +746,2 @@\n-                if (that.sym == sym) result = that;\n-                else super.visitSelect(that);\n+                if (!checkMatch(that, that.sym))\n+                    super.visitSelect(that);\n@@ -744,1 +750,1 @@\n-        DiagScanner s = new DiagScanner(sym);\n+        DiagScanner s = new DiagScanner(sym, filter);\n@@ -757,0 +763,1 @@\n+        final Predicate<? super JCTree> filter;\n@@ -759,0 +766,3 @@\n+            this(sym, null);\n+        }\n+        DeclScanner(final Symbol sym, Predicate<? super JCTree> filter) {\n@@ -760,0 +770,1 @@\n+            this.filter = filter;\n@@ -768,2 +779,2 @@\n-            if (that.packge == sym) result = that;\n-            else super.visitTopLevel(that);\n+            if (!checkMatch(that, that.packge))\n+                super.visitTopLevel(that);\n@@ -772,1 +783,1 @@\n-            if (that.sym == sym) result = that;\n+            checkMatch(that, that.sym);\n@@ -776,2 +787,2 @@\n-            if (that.packge == sym) result = that;\n-            else super.visitPackageDef(that);\n+            if (!checkMatch(that, that.packge))\n+                super.visitPackageDef(that);\n@@ -780,2 +791,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitClassDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitClassDef(that);\n@@ -784,2 +795,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitMethodDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitMethodDef(that);\n@@ -788,2 +799,2 @@\n-            if (that.sym == sym) result = that;\n-            else super.visitVarDef(that);\n+            if (!checkMatch(that, that.sym))\n+                super.visitVarDef(that);\n@@ -792,2 +803,10 @@\n-            if (that.type != null && that.type.tsym == sym) result = that;\n-            else super.visitTypeParameter(that);\n+            if (that.type == null || !checkMatch(that, that.type.tsym))\n+                super.visitTypeParameter(that);\n+        }\n+\n+        protected boolean checkMatch(JCTree that, Symbol thatSym) {\n+            if (thatSym == this.sym && (filter == null || filter.test(that))) {\n+                result = that;\n+                return true;\n+            }\n+            return false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":39,"deletions":20,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import javax.tools.JavaCompiler;\n+import javax.tools.StandardLocation;\n+\n@@ -62,0 +65,72 @@\n+ * <h3>Options and Environment Variables<\/h3>\n+ *\n+ * The full set of options and environment variables supported by <em>javac<\/em>\n+ * is given in the <a href=\"..\/specs\/man\/javac.html\"><em>javac Tool Guide<\/em><\/a>.\n+ * However, there are some restrictions when the compiler is invoked through\n+ * its API.\n+ *\n+ * <ul>\n+ *     <li><p>The {@code -J} option is not supported.\n+ *          Any necessary VM options must be set in the VM used to invoke the API.\n+ *          {@code IllegalArgumentException} will be thrown if the option\n+ *          is used when invoking the tool through the {@code JavaCompiler} API;\n+ *          an error will be reported if the option is used when invoking\n+ *          <em>javac<\/em> through the {@link java.util.spi.ToolProvider ToolProvider}\n+ *          or legacy {@link com.sun.tools.javac.Main Main} API.\n+ *\n+ *     <li><p>The \"classpath wildcard\" feature is not supported.\n+ *          The feature is only supported by the native launcher.\n+ *          When invoking the tool through its API, all necessary jar\n+ *          files should be included directly in the {@code --class-path}\n+ *          option, or the {@code CLASSPATH} environment variable.\n+ *          When invoking the tool through its API, all components of the\n+ *          class path will be taken literally, and will be ignored if there\n+ *          is no matching directory or file. The {@code -Xlint:paths}\n+ *          option can be used to generate warnings about missing components.\n+ *\n+ * <\/ul>\n+ *\n+ * The following restrictions apply when invoking the compiler through\n+ * the {@link JavaCompiler} interface.\n+ *\n+ * <ul>\n+ *     <li><p>Argument files (so-called @-files) are not supported.\n+ *          The content of any such files should be included directly\n+ *          in the list of options provided when invoking the tool\n+ *          though this API.\n+ *          {@code IllegalArgumentException} will be thrown if\n+ *          the option is used when invoking the tool through this API.\n+ *\n+ *     <li><p>The environment variable {@code JDK_JAVAC_OPTIONS} is not supported.\n+ *          Any options defined in the environment variable should be included\n+ *          directly in the list of options provided when invoking the\n+ *          API; any values in the environment variable will be ignored.\n+ *\n+ *     <li><p>Options that are just used to obtain information (such as\n+ *          {@code --help}, {@code --help-extended}, {@code --version} and\n+ *          {@code --full-version}) are not supported.\n+ *          {@link IllegalArgumentException} will be thrown if any of\n+ *          these options are used when invoking the tool through this API.\n+ *\n+ *      <li>Path-related options depend on the file manager being used\n+ *          when calling {@link JavaCompiler#getTask}. The \"standard\"\n+ *          options, such as {@code --class-path}, {@code --module-path},\n+ *          and so on are available when using the default file manager,\n+ *          or one derived from it. These options may not be available\n+ *          and different options may be available, when using a different\n+ *          file manager.\n+ *          {@link IllegalArgumentException} will be thrown if any option\n+ *          that is unknown to the tool or the file manager is used when\n+ *          invoking the tool through this API.\n+ * <\/ul>\n+ *\n+ * Note that the {@code CLASSPATH} environment variable <em>is<\/em> honored\n+ * when invoking the compiler through its API, although such use is discouraged.\n+ * An environment variable cannot be unset once a VM has been started,\n+ * and so it is recommended to ensure that the environment variable is not set\n+ * when starting a VM that will be used to invoke the compiler.\n+ * However, if a value has been set, any such value can be overridden by\n+ * using the {@code --class-path} option when invoking the compiler,\n+ * or setting {@link StandardLocation#CLASS_PATH} in the file manager\n+ * when invoking the compiler through the {@link JavaCompiler} interface.\n+ *\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,3 +212,0 @@\n-            \/\/\n-            \/\/ PKCS11 does not support GCM mode as the author made the comment,\n-            \/\/ so the macBits is unlikely to be zero. It's only a place holder.\n@@ -221,0 +218,7 @@\n+                \/\/ NSS allocates MAC keys even if macBits is zero\n+                if (out.hClientMacSecret != CK_INVALID_HANDLE) {\n+                    token.p11.C_DestroyObject(session.id(), out.hClientMacSecret);\n+                }\n+                if (out.hServerMacSecret != CK_INVALID_HANDLE) {\n+                    token.p11.C_DestroyObject(session.id(), out.hServerMacSecret);\n+                }\n@@ -232,0 +236,2 @@\n+                assert out.hClientKey == 0;\n+                assert out.hServerKey == 0;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11TlsKeyMaterialGenerator.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -466,2 +466,1 @@\n-            throw new SignatureException(\"Curve not supported: \" +\n-                params.toString());\n+            throw new SignatureException(\"Curve not supported: \" + params);\n@@ -483,0 +482,20 @@\n+        ECPoint w = publicKey.getW();\n+        ECParameterSpec params = publicKey.getParams();\n+\n+        \/\/ Partial public key validation\n+        try {\n+            ECUtil.validatePublicKey(w, params);\n+        } catch (InvalidKeyException e) {\n+            return false;\n+        }\n+\n+        ECDSAOperations ops = ECDSAOperations.forParameters(params)\n+                .orElseThrow(() -> new SignatureException(\"Curve not supported: \" + params));\n+\n+        \/\/ Full public key validation, only necessary when h != 1.\n+        if (params.getCofactor() != 1) {\n+            if (!ops.getEcOperations().checkOrder(w)) {\n+                return false;\n+            }\n+        }\n+\n@@ -489,10 +508,1 @@\n-\n-        byte[] digest = getDigestValue();\n-\n-        Optional<ECDSAOperations> opsOpt =\n-            ECDSAOperations.forParameters(publicKey.getParams());\n-        if (opsOpt.isEmpty()) {\n-            throw new SignatureException(\"Curve not supported: \" +\n-                publicKey.getParams().toString());\n-        }\n-        return opsOpt.get().verifySignedDigest(digest, sig, publicKey.getW());\n+        return ops.verifySignedDigest(getDigestValue(), sig, w);\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECDSASignature.java","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.util.ArrayUtil;\n@@ -36,0 +37,1 @@\n+import java.security.spec.ECPoint;\n@@ -307,3 +309,1 @@\n-        p.getX().setValue(p.getY()).setProduct(two);\n-        p.getY().setSum(p.getX());\n-        p.getY().setReduced();\n+        p.getY().setProduct(three);\n@@ -316,2 +316,1 @@\n-        t3.setValue(t2).setProduct(two);\n-        t2.setSum(t3);\n+        t2.setProduct(three);\n@@ -320,1 +319,0 @@\n-        t2.setReduced();\n@@ -323,3 +321,1 @@\n-        t3.setValue(p.getZ()).setProduct(two);\n-        p.getZ().setReduced();\n-        p.getZ().setSum(t3);\n+        p.getZ().setProduct(three);\n@@ -385,3 +381,1 @@\n-        p.getX().setReduced();\n-        p.getZ().setValue(p.getX()).setProduct(two);\n-        p.getX().setSum(p.getZ());\n+        p.getX().setProduct(three);\n@@ -393,3 +387,1 @@\n-        t1.setValue(t2).setProduct(two);\n-        t2.setSum(t1);\n-        t2.setReduced();\n+        t2.setProduct(three);\n@@ -399,3 +391,1 @@\n-        p.getY().setReduced();\n-        t1.setValue(p.getY()).setProduct(two);\n-        p.getY().setSum(t1);\n+        p.getY().setProduct(three);\n@@ -403,2 +393,1 @@\n-        t1.setValue(t0).setProduct(two);\n-        t0.setSum(t1);\n+        t0.setProduct(three);\n@@ -416,2 +405,2 @@\n-        t1.setValue(t3).setProduct(t0);\n-        p.getZ().setSum(t1);\n+        t3.setProduct(t0);\n+        p.getZ().setSum(t3);\n@@ -456,1 +445,0 @@\n-        p.getZ().setValue(p.getX()).setProduct(two);\n@@ -458,2 +446,2 @@\n-        p.getX().setSum(p.getZ());\n-        p.getX().setReduced();\n+        p.getX().setProduct(three);\n+\n@@ -464,3 +452,1 @@\n-        t1.setValue(t2).setSum(t2);\n-        t2.setSum(t1);\n-        t2.setReduced();\n+        t2.setProduct(three);\n@@ -470,2 +456,1 @@\n-        p.getY().setReduced();\n-        t1.setValue(p.getY()).setSum(p.getY());\n+        p.getY().setProduct(three);\n@@ -473,3 +458,1 @@\n-        p.getY().setSum(t1);\n-        t1.setValue(t0).setProduct(two);\n-        t0.setSum(t1);\n+        t0.setProduct(three);\n@@ -487,1 +470,0 @@\n-        t1.setValue(t3).setProduct(t0);\n@@ -489,1 +471,4 @@\n-        p.getZ().setSum(t1);\n+        t3.setProduct(t0);\n+        p.getZ().setSum(t3);\n+\n+    }\n@@ -491,0 +476,12 @@\n+    \/\/ The extra step in the Full Public key validation as described in\n+    \/\/ NIST SP 800-186 Appendix D.1.1.2\n+    public boolean checkOrder(ECPoint point) {\n+        BigInteger x = point.getAffineX();\n+        BigInteger y = point.getAffineY();\n+\n+        \/\/ Verify that n Q = INFINITY. Output REJECT if verification fails.\n+        IntegerFieldModuloP field = this.getField();\n+        AffinePoint ap = new AffinePoint(field.getElement(x), field.getElement(y));\n+        byte[] scalar = this.orderField.getSize().toByteArray();\n+        ArrayUtil.reverse(scalar);\n+        return isNeutral(this.multiply(ap, scalar));\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-        if (xLSB != x.asBigInteger().mod(BigInteger.valueOf(2)).intValue()) {\n+        if (xLSB != (x.asBigInteger().intValue() & 1)) {\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/Ed25519Operations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,1 +130,1 @@\n-        if (xLSB != x.asBigInteger().mod(TWO).intValue()) {\n+        if (xLSB != (x.asBigInteger().intValue() & 1)) {\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ed\/Ed448Operations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -13,2 +13,12 @@\n-always successfully open the dump. This is due to kernel, library (shared\n-objects or DLLs) mismatch between core dump machine and debugger machine.\n+always successfully open the core dump. This is due to library (shared\n+objects or DLLs) mismatches between the core dump machine and the debugger machine.\n+For this reason you should first consider using one of the following approaches to\n+debugging the core dump rather than transporting it to a different machine:\n+<ul>\n+  <li>Remote login to the machine that the core dump was produced on,\n+    and use <a href=\"clhsdb.html\">CLHSDB - SA command line HSDB interface<\/a>.\n+  <li>Use SA remote debugging support to remotely debug the core directly on the machine\n+    it was produced on. This is done by first running <b>jhsdb debugd<\/b> on the machine with\n+    the core dump, and then attaching to it from another machine by using the jhsdb\n+    <b>--connect<\/b> argument. See the <b>jhsdb<\/b> man page for details.\n+<\/ul>\n@@ -18,4 +28,6 @@\n-In most platforms, core dumps do not contain text (a.k.a) Code pages.\n-There pages are to be read from executable and shared objects (or DLLs).\n-Therefore it is important to have matching executable and shared object\n-files in debugger machine. \n+With transported core dumps, SA may produce an error message or throw\n+an exception (such as for a missing hotspot symbol) when opening the core dump.\n+Environment variable <b>LIBSAPROC_DEBUG<\/b> may be set to any value\n+to help debug the root casue of these failures. With <b>LIBSAPROC_DEBUG<\/b> set, SA prints many\n+messages in standard error which can be useful for further debugging. Note that\n+<b>LIBSAPROC_DEBUG<\/b> is not supported on Windows.\n@@ -24,2 +36,0 @@\n-<h3>Solaris transported core dumps<\/h3>\n-\n@@ -27,11 +37,11 @@\n-Debuggers on Solaris (and Linux) use two additional shared objects\n-<b>rtld_db.so<\/b> and <b>libthread_db.so<\/b>. rtld_db.so is used to\n-read information on shared objects from the core dump. libthread_db.so\n-is used to get information on threads from the core dump. rtld_db.so\n-evolves along with rtld.so (the runtime linker library) and libthread_db.so\n-evolves along with libthread.so (user land multithreading library). \n-Hence, debugger machine should have right version of rtld_db.so and\n-libthread_db.so to open the core dump successfully. More details on\n-these debugger libraries can be found in \n-<a href=\"http:\/\/docs.sun.com\/app\/docs\/doc\/817-1984\/\">\n-Solaris Linkers and Libraries Guide - 817-1984<\/a>\n+On most platforms, core dumps do not contain text (code) pages.\n+Their pages are instead read from the executable and shared objects (or DLLs).\n+Therefore it is important to have a matching java executable and shared object\n+files on the debugger machine. The best way to guarantee this match is to match the\n+debugger machine to that of core dump machine. This means having the same\n+OS version and libraries, and also having the same version of the JDK. It also means having\n+the OS libraries and JDK installed in the same locations on both machines. However, often\n+this isn't an option, and instead you need to copy the libraries and java installation from\n+the machine where the core dump was produced to the debugger machine, and you need\n+to tell SA where these are all located. That is done differently for each\n+OS type, and is described in the following sections.\n@@ -40,2 +50,1 @@\n-<h3>Solaris SA against transported core dumps<\/h3>\n-\n+<h3>Using transported core dumps on Linux<\/h3>\n@@ -43,9 +52,9 @@\n-With transported core dumps, you may get \"rtld_db failures\" or\n-\"libthread_db failures\" or SA may just throw some other error\n-(hotspot symbol is missing) when opening the core dump. \n-Environment variable <b>LIBSAPROC_DEBUG<\/b> may be set to any value\n-to debug such scenarios. With this env. var set, SA prints many\n-messages in standard error which can be useful for further debugging.\n-SA on Solaris uses <b>libproc.so<\/b> library. This library also\n-prints debug messages with env. var <b>LIBPROC_DEBUG<\/b>. But,\n-setting LIBSAPROC_DEBUG results in setting LIBPROC_DEBUG as well.\n+On Linux, SA parses core and shared library ELF files. But, you\n+may still face problems with transported core dumps, because matching shared\n+objects may not be in the path(s) specified in core dump file. To\n+workaround this, you can define environment variable <b>SA_ALTROOT<\/b>\n+to be the directory where shared libraries are kept. In this directory you should\n+copy all the needed JDK libraries, and any other user JNI libraries that were used.\n+You should also copy any referenced linux\n+libraries from the core dump machine, unless they are identical to what are\n+installed on the debugger machine.\n@@ -54,5 +63,5 @@\n-The best possible way to debug a transported core dump is to match the\n-debugger machine to that of core dump machine. i.e., have same Kernel\n-and libthread patch level between the machines. mdb (Solaris modular\n-debugger) may be used to find the Kernel patch level of core dump\n-machine and debugger machine may be brought to the same level.\n+ You can also use <b>SA_ALTROOT<\/b> to specify a path mapping. For example, if you\n+ set <b>SA_ALTROOT=\/altroot<\/b>, then <b>\/altroot<\/b> will be prepended to any path found\n+ in the core file, and also prepended to any subdir with the root part stripped off. For example,\n+ when looking up <b>\/usr\/lib\/libfoo.so<\/b>, SA will try to find <b>\/altroot\/usr\/lib\/libfoo.so<\/b>,\n+ <b>\/altroot\/lib\/libfoo.so<\/b>, and <b>\/altroot\/libfoo.so<\/b>.\n@@ -60,0 +69,2 @@\n+\n+<h3>Using transported core dumps on Windows<\/h3>\n@@ -61,5 +72,9 @@\n-If the matching machine is \"far off\" in your network, then\n-<ul>\n-<li>consider using rlogin and <a href=\"clhsdb.html\">CLHSDB - SA command line HSDB interface<\/a> or\n-<li>use SA remote debugging and debug the core from core machine remotely.\n-<\/ul>\n+ If the debugger machine and core dump machine have identical Windows libraries, then you only\n+ need to point SA to the location of the JDK <b>java.exe<\/b> and libraries. This is done by making\n+ sure the <b>bin<\/b> and <b>bin\/server<\/b> directories are included in the <b>PATH<\/b>\n+ environment variable. Something like the following should work if <b>JAVA_HOME<\/b>\n+ is setup:\n+ <\/p>\n+\n+<p>\n+ set PATH=%JAVA_HOME%\\bin;%JAVA_HOME%\\bin\\server;%PATH%\n@@ -69,8 +84,3 @@\n-But, it may not be feasible to find matching machine to debug. \n-If so, you can copy all application shared objects (and libthread_db.so, if needed) from the core dump \n-machine into your debugger machine's directory, say, \/export\/applibs. Now, set <b>SA_ALTROOT<\/b> \n-environment variable to point to \/export\/applibs directory. Note that \/export\/applibs should either \n-contain matching 'full path' of libraries. i.e., \/usr\/lib\/libthread_db.so from core \n-machine should be under \/export\/applibs\/use\/lib directory and \/use\/java\/jre\/lib\/sparc\/client\/libjvm.so \n-from core machine should be under \/export\/applibs\/use\/java\/jre\/lib\/sparc\/client so on or \/export\/applibs \n-should just contain libthread_db.so, libjvm.so etc. directly. \n+You can also include user JNI libraries in <b>PATH<\/b>.\n+If the windows libraries are not identical, then they may also need to be copied\n+to the debugger machine and included in <b>PATH<\/b>.\n@@ -79,0 +89,1 @@\n+<h3>Using transported core dumps on macOS<\/h3>\n@@ -80,5 +91,5 @@\n-Support for transported core dumps is <b>not<\/b> built into the standard version of libproc.so. You need to\n-set <b>LD_LIBRARY_PATH<\/b> env var to point to the path of a specially built version of libproc.so. \n-Note that this version of libproc.so has a special symbol to support transported core dump debugging. \n-In future, we may get this feature built into standard libproc.so -- if that happens, this step (of \n-setting LD_LIBRARY_PATH) can be skipped.\n+ SA normally uses the path to the specified java executable to locate the JDK libraries. It will look\n+ in the following subdirectories for them (relative to the path to the specified java executable):\n+ <b>..\/lib<\/b>, <b>..\/lib\/server<\/b>, <b>..\/jre\/lib<\/b>, and <b>..\/jre\/lib\/server<\/b>. If not found\n+ in any of those locations, it will look in the same subdirectories relative to the <b>JAVA_HOME<\/b>\n+ environment variable, but using <b>JAVA_HOME<\/b> normally should not be necessary.\n@@ -87,1 +98,0 @@\n-<h3>Ignoring libthread_db.so failures<\/h3>\n@@ -89,5 +99,4 @@\n-If you are okay with missing thread related information, you can set \n-<b>SA_IGNORE_THREADDB<\/b> environment variable to any value. With this\n-set, SA ignores libthread_db failure, but you won't be able to get any\n-thread related information. But, you would be able to use SA and get\n-other information.\n+ For locating the user JNI libraries, SA uses <b>DYLD_LIBRARY_PATH<\/b>. It can contain\n+ more than one directory separated by a colon. <b>DYLD_LIBRARY_PATH<\/b> can also be\n+ used for locating the JDK libraries, but it needs to specify the full path to the libraries. SA will\n+ not automatically search subdirs such as <b>lib\/server<\/b> as it does for <b>JAVA_HOME<\/b>.\n@@ -96,1 +105,0 @@\n-<h3>Linux SA against transported core dumps<\/h3>\n@@ -98,8 +106,7 @@\n-On Linux, SA parses core and shared library ELF files. SA <b>does not<\/b> use\n-libthread_db.so or rtld_db.so for core dump debugging (although \n-libthread_db.so is used for live process debugging). But, you\n-may still face problems with transported core dumps, because matching shared\n-objects may not be in the path(s) specified in core dump file. To\n-workaround this, you can define environment variable <b>SA_ALTROOT<\/b>\n-to be the directory where shared libraries are kept. The semantics of\n-this env. variable is same as that for Solaris (please refer above).\n+ For locating the macOS libraries, SA uses <b>SA_ALTROOT<\/b> similar to the linux support,\n+ except it does not use it to map all the subdirs. It just appends <b>SA_ALTROOT<\/b> to the\n+ full path of each macOS library. So if you specify <b>SA_ALTROOT=\/altroot<\/b>, SA will\n+ prepend <b>\/altroot<\/b> to the full path of each macOS library. Note however, due to\n+ <a href=\"https:\/\/bugs.openjdk.org\/browse\/JDK-8249779\">JDK-8249779<\/a> , SA will not\n+ even try to open macOS libraries, so at the moment there is no need to try to match up the\n+ macOS libraries by pointing to them with <b>SA_ALTROOT<\/b>.\n@@ -108,0 +115,4 @@\n+<p>\n+ Note: Starting with macOS 12, core files are no longer working with macOS on the x64 platform.\n+ See <a href=\"https:\/\/bugs.openjdk.org\/browse\/JDK-8294316\">JDK-8294316<\/a>.\n+<\/p>\n","filename":"src\/jdk.hotspot.agent\/doc\/transported_core.html","additions":79,"deletions":68,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-    return context.getRegisterAsAddress(X86ThreadContext.ESP);\n+    return context.getRegisterAsAddress(X86ThreadContext.SP);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/linux_x86\/LinuxX86JavaThreadPDAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import com.sun.net.httpserver.*;\n-import com.sun.net.httpserver.spi.*;\n@@ -58,2 +56,2 @@\n-    long time;\n-    volatile long creationTime; \/\/ time this connection was created\n+    long idleStartTime; \/\/ absolute time in milli seconds, starting when the connection was marked idle\n+    volatile long reqStartedTime; \/\/ time when the request was initiated\n@@ -65,1 +63,1 @@\n-    public enum State {IDLE, REQUEST, RESPONSE};\n+    public enum State {IDLE, REQUEST, RESPONSE, NEWLY_ACCEPTED};\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/HttpConnection.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-    TimeSource time;\n@@ -59,1 +58,0 @@\n-        this.time= (TimeSource)server;\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/SSLStreams.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    private static final int DEFAULT_CLOCK_TICK = 10000 ; \/\/ 10 sec.\n+    private static final int DEFAULT_IDLE_TIMER_SCHEDULE_MILLIS = 10000 ; \/\/ 10 sec.\n@@ -42,2 +42,2 @@\n-    \/* These values must be a reasonable multiple of clockTick *\/\n-    private static final long DEFAULT_IDLE_INTERVAL = 30 ; \/\/ 5 min\n+    private static final long DEFAULT_IDLE_INTERVAL_IN_SECS = 30;\n+    private static final int DEFAULT_MAX_CONNECTIONS = -1 ; \/\/ no limit on maximum connections\n@@ -48,1 +48,3 @@\n-    private static final long DEFAULT_TIMER_MILLIS = 1000;\n+    \/\/ default timer schedule, in milli seconds, for the timer task that's responsible for\n+    \/\/ timing out request\/response if max request\/response time is configured\n+    private static final long DEFAULT_REQ_RSP_TIMER_TASK_SCHEDULE_MILLIS = 1000;\n@@ -52,2 +54,2 @@\n-    private static int clockTick;\n-    private static long idleInterval;\n+    private static long idleTimerScheduleMillis;\n+    private static long idleIntervalMillis;\n@@ -56,0 +58,4 @@\n+    \/\/ the maximum number of connections that the server will allow to be open\n+    \/\/ after which it will no longer \"accept()\" any new connections, till the\n+    \/\/ current connection count goes down due to completion of processing the requests\n+    private static int maxConnections;\n@@ -62,1 +68,1 @@\n-    private static long timerMillis;\n+    private static long reqRspTimerScheduleMillis;\n@@ -73,2 +79,12 @@\n-                    idleInterval = Long.getLong(\"sun.net.httpserver.idleInterval\",\n-                            DEFAULT_IDLE_INTERVAL) * 1000;\n+                    idleIntervalMillis = Long.getLong(\"sun.net.httpserver.idleInterval\",\n+                            DEFAULT_IDLE_INTERVAL_IN_SECS) * 1000;\n+                    if (idleIntervalMillis <= 0) {\n+                        idleIntervalMillis = DEFAULT_IDLE_INTERVAL_IN_SECS * 1000;\n+                    }\n+\n+                    idleTimerScheduleMillis = Long.getLong(\"sun.net.httpserver.clockTick\",\n+                            DEFAULT_IDLE_TIMER_SCHEDULE_MILLIS);\n+                    if (idleTimerScheduleMillis <= 0) {\n+                        \/\/ ignore zero or negative value and use the default schedule\n+                        idleTimerScheduleMillis = DEFAULT_IDLE_TIMER_SCHEDULE_MILLIS;\n+                    }\n@@ -76,2 +92,3 @@\n-                    clockTick = Integer.getInteger(\"sun.net.httpserver.clockTick\",\n-                            DEFAULT_CLOCK_TICK);\n+                    maxConnections = Integer.getInteger(\n+                            \"jdk.httpserver.maxConnections\",\n+                            DEFAULT_MAX_CONNECTIONS);\n@@ -96,2 +113,7 @@\n-                    timerMillis = Long.getLong(\"sun.net.httpserver.timerMillis\",\n-                            DEFAULT_TIMER_MILLIS);\n+                    reqRspTimerScheduleMillis = Long.getLong(\"sun.net.httpserver.timerMillis\",\n+                            DEFAULT_REQ_RSP_TIMER_TASK_SCHEDULE_MILLIS);\n+                    if (reqRspTimerScheduleMillis <= 0) {\n+                        \/\/ ignore any negative or zero value for this configuration and reset\n+                        \/\/ to default schedule\n+                        reqRspTimerScheduleMillis = DEFAULT_REQ_RSP_TIMER_TASK_SCHEDULE_MILLIS;\n+                    }\n@@ -153,2 +175,13 @@\n-    static long getIdleInterval() {\n-        return idleInterval;\n+    \/**\n+     * {@return Returns the maximum duration, in milli seconds, a connection can be idle}\n+     *\/\n+    static long getIdleIntervalMillis() {\n+        return idleIntervalMillis;\n+    }\n+\n+    \/**\n+     * {@return Returns the schedule, in milli seconds, for the timer task that is responsible\n+     * for managing the idle connections}\n+     *\/\n+    static long getIdleTimerScheduleMillis() {\n+        return idleTimerScheduleMillis;\n@@ -157,2 +190,7 @@\n-    static int getClockTick() {\n-        return clockTick;\n+    \/**\n+     * @return Returns the maximum number of connections that can be open at any given time.\n+     * This method can return a value of 0 or negative to represent that the limit hasn't\n+     * been configured.\n+     *\/\n+    static int getMaxConnections() {\n+        return maxConnections;\n@@ -161,0 +199,4 @@\n+    \/**\n+     * @return Returns the maximum number of connections that can be idle. This method\n+     * can return a value of 0 or negative.\n+     *\/\n@@ -173,0 +215,5 @@\n+    \/**\n+     * @return Returns the maximum amount of time the server will wait for the request to be read\n+     * completely. This method can return a value of 0 or negative to imply no maximum limit has\n+     * been configured.\n+     *\/\n@@ -177,0 +224,5 @@\n+    \/**\n+     * @return Returns the maximum amount of time the server will wait for the response to be generated\n+     * for a request that is being processed. This method can return a value of 0 or negative to\n+     * imply no maximum limit has been configured.\n+     *\/\n@@ -181,2 +233,6 @@\n-    static long getTimerMillis() {\n-        return timerMillis;\n+    \/**\n+     * {@return Returns the timer schedule of the task that's responsible for timing out\n+     * request\/response that have been running longer than any configured timeout}\n+     *\/\n+    static long getReqRspTimerScheduleMillis() {\n+        return reqRspTimerScheduleMillis;\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerConfig.java","additions":76,"deletions":20,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -28,5 +28,15 @@\n-import java.net.*;\n-import java.io.*;\n-import java.nio.channels.*;\n-import java.util.*;\n-import java.util.concurrent.*;\n+import com.sun.net.httpserver.Filter;\n+import com.sun.net.httpserver.Headers;\n+import com.sun.net.httpserver.HttpContext;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import sun.net.httpserver.HttpConnection.State;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n@@ -35,2 +45,10 @@\n-import javax.net.ssl.*;\n-import com.sun.net.httpserver.*;\n+import java.net.BindException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.channels.CancelledKeyException;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n@@ -39,1 +57,9 @@\n-import sun.net.httpserver.HttpConnection.State;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Executor;\n@@ -42,1 +68,1 @@\n-import static sun.net.httpserver.Utils.*;\n+import static sun.net.httpserver.Utils.isValidName;\n@@ -47,1 +73,1 @@\n-class ServerImpl implements TimeSource {\n+class ServerImpl {\n@@ -59,2 +85,5 @@\n-    private Set<HttpConnection> idleConnections;\n-    private Set<HttpConnection> allConnections;\n+    private final Set<HttpConnection> idleConnections;\n+    \/\/ connections which have been accepted() by the server but which haven't\n+    \/\/ yet sent any byte on the connection yet\n+    private final Set<HttpConnection> newlyAcceptedConnections;\n+    private final Set<HttpConnection> allConnections;\n@@ -65,2 +94,2 @@\n-    private Set<HttpConnection> reqConnections;\n-    private Set<HttpConnection> rspConnections;\n+    private final Set<HttpConnection> reqConnections;\n+    private final Set<HttpConnection> rspConnections;\n@@ -68,1 +97,1 @@\n-    private Object lolock = new Object();\n+    private final Object lolock = new Object();\n@@ -73,3 +102,0 @@\n-    private volatile long time;  \/* current time *\/\n-    private volatile long subticks = 0;\n-    private volatile long ticks; \/* number of clock ticks since server started *\/\n@@ -78,2 +104,3 @@\n-    static final int CLOCK_TICK = ServerConfig.getClockTick();\n-    static final long IDLE_INTERVAL = ServerConfig.getIdleInterval();\n+    \/\/ schedule for the timer task that's responsible for idle connection management\n+    static final long IDLE_TIMER_TASK_SCHEDULE = ServerConfig.getIdleTimerScheduleMillis();\n+    static final int MAX_CONNECTIONS = ServerConfig.getMaxConnections();\n@@ -81,4 +108,18 @@\n-    static final long TIMER_MILLIS = ServerConfig.getTimerMillis ();\n-    static final long MAX_REQ_TIME=getTimeMillis(ServerConfig.getMaxReqTime());\n-    static final long MAX_RSP_TIME=getTimeMillis(ServerConfig.getMaxRspTime());\n-    static final boolean timer1Enabled = MAX_REQ_TIME != -1 || MAX_RSP_TIME != -1;\n+    \/\/ schedule for the timer task that's responsible for request\/response timeout management\n+    static final long REQ_RSP_TIMER_SCHEDULE = ServerConfig.getReqRspTimerScheduleMillis();\n+    static final long MAX_REQ_TIME = getTimeMillis(ServerConfig.getMaxReqTime());\n+    static final long MAX_RSP_TIME = getTimeMillis(ServerConfig.getMaxRspTime());\n+    static final boolean reqRspTimeoutEnabled = MAX_REQ_TIME != -1 || MAX_RSP_TIME != -1;\n+    \/\/ the maximum idle duration for a connection which is currently idle but has served\n+    \/\/ some request in the past\n+    static final long IDLE_INTERVAL = ServerConfig.getIdleIntervalMillis();\n+    \/\/ the maximum idle duration for a newly accepted connection which hasn't yet received\n+    \/\/ the first byte of data on that connection\n+    static final long NEWLY_ACCEPTED_CONN_IDLE_INTERVAL;\n+    static {\n+        \/\/ the idle duration of a newly accepted connection is considered to be the least of the\n+        \/\/ configured idle interval and the configured max request time (if any).\n+        NEWLY_ACCEPTED_CONN_IDLE_INTERVAL = MAX_REQ_TIME > 0\n+                ? Math.min(IDLE_INTERVAL, MAX_REQ_TIME)\n+                : IDLE_INTERVAL;\n+    }\n@@ -115,7 +156,8 @@\n-        time = System.currentTimeMillis();\n-        timer = new Timer (\"server-timer\", true);\n-        timer.schedule (new ServerTimerTask(), CLOCK_TICK, CLOCK_TICK);\n-        if (timer1Enabled) {\n-            timer1 = new Timer (\"server-timer1\", true);\n-            timer1.schedule (new ServerTimerTask1(),TIMER_MILLIS,TIMER_MILLIS);\n-            logger.log (Level.DEBUG, \"HttpServer timer1 enabled period in ms: \", TIMER_MILLIS);\n+        newlyAcceptedConnections = Collections.synchronizedSet(new HashSet<>());\n+        timer = new Timer (\"idle-timeout-task\", true);\n+        timer.schedule (new IdleTimeoutTask(), IDLE_TIMER_TASK_SCHEDULE, IDLE_TIMER_TASK_SCHEDULE);\n+        if (reqRspTimeoutEnabled) {\n+            timer1 = new Timer (\"req-rsp-timeout-task\", true);\n+            timer1.schedule (new ReqRspTimeoutTask(), REQ_RSP_TIMER_SCHEDULE, REQ_RSP_TIMER_SCHEDULE);\n+            logger.log(Level.DEBUG, \"HttpServer request\/response timeout task schedule ms: \",\n+                    REQ_RSP_TIMER_SCHEDULE);\n@@ -212,0 +254,1 @@\n+        newlyAcceptedConnections.clear();\n@@ -213,1 +256,1 @@\n-        if (timer1Enabled) {\n+        if (reqRspTimeoutEnabled) {\n@@ -276,4 +319,0 @@\n-    Selector getSelector () {\n-        return selector;\n-    }\n-\n@@ -289,0 +328,64 @@\n+    \/**\n+     * The Dispatcher is responsible for accepting any connections and then using those connections\n+     * to processing any incoming requests. A connection is represented as an instance of\n+     * sun.net.httpserver.HttpConnection.\n+     *\n+     * Connection states:\n+     *  An instance of HttpConnection goes through the following states:\n+     *\n+     *  - NEWLY_ACCEPTED: A connection is marked as newly accepted as soon as the Dispatcher\n+     *    accept()s a connection. A newly accepted connection is added to a newlyAcceptedConnections\n+     *    collection. A newly accepted connection also gets added to the allConnections collection.\n+     *    The newlyAcceptedConnections isn't checked for any size limits, however, if the server is\n+     *    configured with a maximum connection limit, then the elements in the\n+     *    newlyAcceptedConnections will never exceed that configured limit (no explicit size checks\n+     *    are done on the newlyAcceptedConnections collection, since the maximum connection limit\n+     *    applies to connections across different connection states). A connection in NEWLY_ACCEPTED\n+     *    state is considered idle and is eligible for idle connection management.\n+     *\n+     *  - REQUEST: A connection is marked to be in REQUEST state when the request processing starts\n+     *    on that connection. This typically happens when the first byte of data is received on a\n+     *    NEWLY_ACCEPTED connection or when new data arrives on a connection which was previously\n+     *    in IDLE state. When a connection is in REQUEST state, it implies that the connection is\n+     *    active and thus isn't eligible for idle connection management. If the server is configured\n+     *    with a maximum request timeout, then connections in REQUEST state are eligible\n+     *    for Request\/Response timeout management.\n+     *\n+     *  - RESPONSE: A connection is marked to be in RESPONSE state when the server has finished\n+     *    reading the request. A connection is RESPONSE state is considered active and isn't eligible\n+     *    for idle connection management. If the server is configured with a maximum response timeout,\n+     *    then connections in RESPONSE state are eligible for Request\/Response timeout management.\n+     *\n+     *  - IDLE: A connection is marked as IDLE when a request\/response cycle (successfully) completes\n+     *    on that particular connection. Idle connections are held in a idleConnections collection.\n+     *    The idleConnections collection is limited in size and the size is decided by a server\n+     *    configuration. Connections in IDLE state get added to the idleConnections collection only\n+     *    if that collection hasn't reached the configured limit. If a connection has reached IDLE\n+     *    state and there's no more room in the idleConnections collection, then such a connection\n+     *    gets closed. Connections in idleConnections collection are eligible for idle connection\n+     *    management.\n+     *\n+     * Idle connection management:\n+     *  A timer task is responsible for closing idle connections. Each connection that is in a state\n+     *  which is eligible for idle timeout management (see above section on connection states)\n+     *  will have a corresponding idle expiration time associated with it. The idle timeout management\n+     *  task will check the expiration time of each such connection against the current time and will\n+     *  close the connection if the current time is either equal to or past the expiration time.\n+     *\n+     * Request\/Response timeout management:\n+     *  The server can be optionally configured with a maximum request timeout and\/or maximum response\n+     *  timeout. If either of these timeouts have been configured, then an additional timer task is\n+     *  run by the server. This timer task is then responsible for closing connections which have\n+     *  been in REQUEST or RESPONSE state for a period of time that exceeds the respective configured\n+     *  timeouts.\n+     *\n+     * Maximum connection limit management:\n+     *  The server can be optionally configured with a maximum connection limit. A value of 0 or\n+     *  negative integer is ignored and considered to represent no connection limit. In case of a\n+     *  positive integer value, any newly accepted connections will be first checked against the\n+     *  current count of established connections (held by the allConnections collection) and if the\n+     *  configured limit has reached, then the newly accepted connection will be closed immediately\n+     *  (even before setting its state to NEWLY_ACCEPTED or adding it to the newlyAcceptedConnections\n+     *  collection).\n+     *\n+     *\/\n@@ -342,2 +445,1 @@\n-                c.time = getTime() + IDLE_INTERVAL;\n-                idleConnections.add (c);\n+                markIdle(c);\n@@ -390,1 +492,0 @@\n-\n@@ -393,0 +494,10 @@\n+                                if (MAX_CONNECTIONS > 0 && allConnections.size() >= MAX_CONNECTIONS) {\n+                                    \/\/ we've hit max limit of current open connections, so we go\n+                                    \/\/ ahead and close this connection without processing it\n+                                    try {\n+                                        chan.close();\n+                                    } catch (IOException ignore) {\n+                                    }\n+                                    \/\/ move on to next selected key\n+                                    continue;\n+                                }\n@@ -404,1 +515,1 @@\n-                                requestStarted (c);\n+                                markNewlyAccepted(c);\n@@ -415,4 +526,6 @@\n-                                    if (idleConnections.remove(conn)) {\n-                                        \/\/ was an idle connection so add it\n-                                        \/\/ to reqConnections set.\n-                                        requestStarted (conn);\n+                                    if (newlyAcceptedConnections.remove(conn)\n+                                            || idleConnections.remove(conn)) {\n+                                        \/\/ was either a newly accepted connection or an idle\n+                                        \/\/ connection. In either case, we mark that the request\n+                                        \/\/ has now started on this connection.\n+                                        requestStarted(conn);\n@@ -500,0 +613,3 @@\n+        case NEWLY_ACCEPTED:\n+            newlyAcceptedConnections.remove(conn);\n+            break;\n@@ -504,0 +620,1 @@\n+        assert !newlyAcceptedConnections.remove(conn);\n@@ -675,2 +792,2 @@\n-                        int timeoutSeconds = (int) (ServerConfig.getIdleInterval() \/ 1000);\n-                        String val = \"timeout=\" + timeoutSeconds;\n+                        int idleSeconds = (int) (ServerConfig.getIdleIntervalMillis() \/ 1000);\n+                        String val = \"timeout=\" + idleSeconds;\n@@ -817,8 +934,0 @@\n-    long getTicks() {\n-        return ticks;\n-    }\n-\n-    public long getTime() {\n-        return time;\n-    }\n-\n@@ -849,1 +958,1 @@\n-        c.creationTime = getTime();\n+        c.reqStartedTime = System.currentTimeMillis();\n@@ -854,0 +963,12 @@\n+    void markIdle(HttpConnection c) {\n+        c.idleStartTime = System.currentTimeMillis();\n+        c.setState(State.IDLE);\n+        idleConnections.add(c);\n+    }\n+\n+    void markNewlyAccepted(HttpConnection c) {\n+        c.idleStartTime = System.currentTimeMillis();\n+        c.setState(State.NEWLY_ACCEPTED);\n+        newlyAcceptedConnections.add(c);\n+    }\n+\n@@ -865,1 +986,1 @@\n-        c.rspStartedTime = getTime();\n+        c.rspStartedTime = System.currentTimeMillis();\n@@ -879,0 +1000,1 @@\n+     * Responsible for closing connections that have been idle.\n@@ -881,1 +1003,1 @@\n-    class ServerTimerTask extends TimerTask {\n+    class IdleTimeoutTask extends TimerTask {\n@@ -884,2 +1006,1 @@\n-            time = System.currentTimeMillis();\n-            ticks ++;\n+            final long currentTime = System.currentTimeMillis();\n@@ -887,3 +1008,18 @@\n-                for (HttpConnection c : idleConnections) {\n-                    if (c.time <= time) {\n-                        toClose.add (c);\n+                final Iterator<HttpConnection> it = idleConnections.iterator();\n+                while (it.hasNext()) {\n+                    final HttpConnection c = it.next();\n+                    if (currentTime - c.idleStartTime >= IDLE_INTERVAL) {\n+                        toClose.add(c);\n+                        it.remove();\n+                    }\n+                }\n+            }\n+            \/\/ if any newly accepted connection has been idle (i.e. no byte has been sent on that\n+            \/\/ connection during the configured idle timeout period) then close it as well\n+            synchronized (newlyAcceptedConnections) {\n+                final Iterator<HttpConnection> it = newlyAcceptedConnections.iterator();\n+                while (it.hasNext()) {\n+                    final HttpConnection c = it.next();\n+                    if (currentTime - c.idleStartTime >= NEWLY_ACCEPTED_CONN_IDLE_INTERVAL) {\n+                        toClose.add(c);\n+                        it.remove();\n@@ -892,4 +1028,6 @@\n-                for (HttpConnection c : toClose) {\n-                    idleConnections.remove (c);\n-                    allConnections.remove (c);\n-                    c.close();\n+            }\n+            for (HttpConnection c : toClose) {\n+                allConnections.remove(c);\n+                c.close();\n+                if (logger.isLoggable(Level.TRACE)) {\n+                    logger.log(Level.TRACE, \"Closed idle connection \" + c);\n@@ -901,1 +1039,4 @@\n-    class ServerTimerTask1 extends TimerTask {\n+    \/**\n+     * Responsible for closing connections which have timed out while in REQUEST or RESPONSE state\n+     *\/\n+    class ReqRspTimeoutTask extends TimerTask {\n@@ -906,1 +1047,1 @@\n-            time = System.currentTimeMillis();\n+            final long currentTime = System.currentTimeMillis();\n@@ -910,1 +1051,1 @@\n-                        if (c.creationTime + TIMER_MILLIS + MAX_REQ_TIME <= time) {\n+                        if (currentTime - c.reqStartedTime >= MAX_REQ_TIME) {\n@@ -926,1 +1067,1 @@\n-                        if (c.rspStartedTime + TIMER_MILLIS +MAX_RSP_TIME <= time) {\n+                        if (currentTime - c.rspStartedTime >= MAX_RSP_TIME) {\n@@ -941,12 +1082,7 @@\n-    void logStackTrace (String s) {\n-        logger.log (Level.TRACE, s);\n-        StringBuilder b = new StringBuilder ();\n-        StackTraceElement[] e = Thread.currentThread().getStackTrace();\n-        for (int i=0; i<e.length; i++) {\n-            b.append (e[i].toString()).append(\"\\n\");\n-        }\n-        logger.log (Level.TRACE, b.toString());\n-    }\n-\n-    static long getTimeMillis(long secs) {\n-        if (secs == -1) {\n+    \/**\n+     * Converts and returns the passed {@code secs} as milli seconds. If the passed {@code secs}\n+     * is negative or zero or if the conversion from seconds to milli seconds results in a negative\n+     * number, then this method returns -1.\n+     *\/\n+    private static long getTimeMillis(long secs) {\n+        if (secs <= 0) {\n@@ -954,2 +1090,0 @@\n-        } else {\n-            return secs * 1000;\n@@ -957,0 +1091,3 @@\n+        final long milli = secs * 1000;\n+        \/\/ this handles potential numeric overflow that may have happened during conversion\n+        return milli > 0 ? milli : -1;\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":221,"deletions":84,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net.httpserver;\n-\n-interface TimeSource {\n-    public long getTime();\n-}\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/TimeSource.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -29,0 +29,3 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n@@ -36,0 +39,3 @@\n+    private static final String SYS_PROP_MAX_CONNECTIONS = \"jdk.httpserver.maxConnections\";\n+    private static final String DEFAULT_JWEBSERVER_MAX_CONNECTIONS = \"200\";\n+\n@@ -62,0 +68,1 @@\n+        setMaxConnectionsIfNotSet();\n@@ -79,0 +86,12 @@\n+\n+    @SuppressWarnings(\"removal\")\n+    static void setMaxConnectionsIfNotSet() {\n+        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+            if (System.getProperty(SYS_PROP_MAX_CONNECTIONS) != null) {\n+                \/\/ an explicit value has already been set, so we don't override it\n+                return null;\n+            }\n+            System.setProperty(SYS_PROP_MAX_CONNECTIONS, DEFAULT_JWEBSERVER_MAX_CONNECTIONS);\n+            return null;\n+        });\n+    }\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/JWebServer.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+        JWebServer.setMaxConnectionsIfNotSet();\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/Main.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+        F16C,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.amd64\/src\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n+\n+import static java.util.Collections.emptyMap;\n+import static jdk.vm.ci.common.InitTimer.timer;\n+\n+import java.util.EnumSet;\n+import java.util.Map;\n+\n+import jdk.vm.ci.riscv64.RISCV64;\n+import jdk.vm.ci.riscv64.RISCV64.CPUFeature;\n+import jdk.vm.ci.code.Architecture;\n+import jdk.vm.ci.code.RegisterConfig;\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.code.stack.StackIntrospection;\n+import jdk.vm.ci.common.InitTimer;\n+import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;\n+import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;\n+import jdk.vm.ci.hotspot.HotSpotJVMCIBackendFactory;\n+import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;\n+import jdk.vm.ci.hotspot.HotSpotMetaAccessProvider;\n+import jdk.vm.ci.hotspot.HotSpotStackIntrospection;\n+import jdk.vm.ci.meta.ConstantReflectionProvider;\n+import jdk.vm.ci.runtime.JVMCIBackend;\n+\n+public class RISCV64HotSpotJVMCIBackendFactory implements HotSpotJVMCIBackendFactory {\n+\n+    private static EnumSet<RISCV64.CPUFeature> computeFeatures(RISCV64HotSpotVMConfig config) {\n+        \/\/ Configure the feature set using the HotSpot flag settings.\n+        Map<String, Long> constants = config.getStore().getConstants();\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+    }\n+\n+    private static EnumSet<RISCV64.Flag> computeFlags(RISCV64HotSpotVMConfig config) {\n+        EnumSet<RISCV64.Flag> flags = EnumSet.noneOf(RISCV64.Flag.class);\n+\n+        if (config.useConservativeFence) {\n+            flags.add(RISCV64.Flag.UseConservativeFence);\n+        }\n+        if (config.avoidUnalignedAccesses) {\n+            flags.add(RISCV64.Flag.AvoidUnalignedAccesses);\n+        }\n+        if (config.nearCpool) {\n+            flags.add(RISCV64.Flag.NearCpool);\n+        }\n+        if (config.traceTraps) {\n+            flags.add(RISCV64.Flag.TraceTraps);\n+        }\n+        if (config.useRVV) {\n+            flags.add(RISCV64.Flag.UseRVV);\n+        }\n+        if (config.useRVC) {\n+            flags.add(RISCV64.Flag.UseRVC);\n+        }\n+        if (config.useZba) {\n+            flags.add(RISCV64.Flag.UseZba);\n+        }\n+        if (config.useZbb) {\n+            flags.add(RISCV64.Flag.UseZbb);\n+        }\n+        if (config.useRVVForBigIntegerShiftIntrinsics) {\n+            flags.add(RISCV64.Flag.UseRVVForBigIntegerShiftIntrinsics);\n+        }\n+\n+        return flags;\n+    }\n+\n+    private static TargetDescription createTarget(RISCV64HotSpotVMConfig config) {\n+        final int stackFrameAlignment = 16;\n+        final int implicitNullCheckLimit = 4096;\n+        final boolean inlineObjects = true;\n+        Architecture arch = new RISCV64(computeFeatures(config), computeFlags(config));\n+        return new TargetDescription(arch, true, stackFrameAlignment, implicitNullCheckLimit, inlineObjects);\n+    }\n+\n+    protected HotSpotConstantReflectionProvider createConstantReflection(HotSpotJVMCIRuntime runtime) {\n+        return new HotSpotConstantReflectionProvider(runtime);\n+    }\n+\n+    private static RegisterConfig createRegisterConfig(RISCV64HotSpotVMConfig config, TargetDescription target) {\n+        return new RISCV64HotSpotRegisterConfig(target, config.useCompressedOops, config.linuxOs);\n+    }\n+\n+    protected HotSpotCodeCacheProvider createCodeCache(HotSpotJVMCIRuntime runtime, TargetDescription target, RegisterConfig regConfig) {\n+        return new HotSpotCodeCacheProvider(runtime, target, regConfig);\n+    }\n+\n+    protected HotSpotMetaAccessProvider createMetaAccess(HotSpotJVMCIRuntime runtime) {\n+        return new HotSpotMetaAccessProvider(runtime);\n+    }\n+\n+    @Override\n+    public String getArchitecture() {\n+        return \"riscv64\";\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"JVMCIBackend:\" + getArchitecture();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"try\")\n+    public JVMCIBackend createJVMCIBackend(HotSpotJVMCIRuntime runtime, JVMCIBackend host) {\n+        assert host == null;\n+        RISCV64HotSpotVMConfig config = new RISCV64HotSpotVMConfig(runtime.getConfigStore());\n+        TargetDescription target = createTarget(config);\n+\n+        RegisterConfig regConfig;\n+        HotSpotCodeCacheProvider codeCache;\n+        ConstantReflectionProvider constantReflection;\n+        HotSpotMetaAccessProvider metaAccess;\n+        StackIntrospection stackIntrospection;\n+        try (InitTimer t = timer(\"create providers\")) {\n+            try (InitTimer rt = timer(\"create MetaAccess provider\")) {\n+                metaAccess = createMetaAccess(runtime);\n+            }\n+            try (InitTimer rt = timer(\"create RegisterConfig\")) {\n+                regConfig = createRegisterConfig(config, target);\n+            }\n+            try (InitTimer rt = timer(\"create CodeCache provider\")) {\n+                codeCache = createCodeCache(runtime, target, regConfig);\n+            }\n+            try (InitTimer rt = timer(\"create ConstantReflection provider\")) {\n+                constantReflection = createConstantReflection(runtime);\n+            }\n+            try (InitTimer rt = timer(\"create StackIntrospection provider\")) {\n+                stackIntrospection = new HotSpotStackIntrospection(runtime);\n+            }\n+        }\n+        try (InitTimer rt = timer(\"instantiate backend\")) {\n+            return createBackend(metaAccess, codeCache, constantReflection, stackIntrospection);\n+        }\n+    }\n+\n+    protected JVMCIBackend createBackend(HotSpotMetaAccessProvider metaAccess, HotSpotCodeCacheProvider codeCache, ConstantReflectionProvider constantReflection,\n+                    StackIntrospection stackIntrospection) {\n+        return new JVMCIBackend(metaAccess, codeCache, constantReflection, stackIntrospection);\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n+\n+import static jdk.vm.ci.riscv64.RISCV64.x0;\n+import static jdk.vm.ci.riscv64.RISCV64.x1;\n+import static jdk.vm.ci.riscv64.RISCV64.x2;\n+import static jdk.vm.ci.riscv64.RISCV64.x3;\n+import static jdk.vm.ci.riscv64.RISCV64.x4;\n+import static jdk.vm.ci.riscv64.RISCV64.x5;\n+import static jdk.vm.ci.riscv64.RISCV64.x6;\n+import static jdk.vm.ci.riscv64.RISCV64.x7;\n+import static jdk.vm.ci.riscv64.RISCV64.x8;\n+import static jdk.vm.ci.riscv64.RISCV64.x10;\n+import static jdk.vm.ci.riscv64.RISCV64.x11;\n+import static jdk.vm.ci.riscv64.RISCV64.x12;\n+import static jdk.vm.ci.riscv64.RISCV64.x13;\n+import static jdk.vm.ci.riscv64.RISCV64.x14;\n+import static jdk.vm.ci.riscv64.RISCV64.x15;\n+import static jdk.vm.ci.riscv64.RISCV64.x16;\n+import static jdk.vm.ci.riscv64.RISCV64.x17;\n+import static jdk.vm.ci.riscv64.RISCV64.x23;\n+import static jdk.vm.ci.riscv64.RISCV64.x27;\n+import static jdk.vm.ci.riscv64.RISCV64.f10;\n+import static jdk.vm.ci.riscv64.RISCV64.f11;\n+import static jdk.vm.ci.riscv64.RISCV64.f12;\n+import static jdk.vm.ci.riscv64.RISCV64.f13;\n+import static jdk.vm.ci.riscv64.RISCV64.f14;\n+import static jdk.vm.ci.riscv64.RISCV64.f15;\n+import static jdk.vm.ci.riscv64.RISCV64.f16;\n+import static jdk.vm.ci.riscv64.RISCV64.f17;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.vm.ci.riscv64.RISCV64;\n+import jdk.vm.ci.code.Architecture;\n+import jdk.vm.ci.code.CallingConvention;\n+import jdk.vm.ci.code.CallingConvention.Type;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.RegisterArray;\n+import jdk.vm.ci.code.RegisterAttributes;\n+import jdk.vm.ci.code.RegisterConfig;\n+import jdk.vm.ci.code.StackSlot;\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.code.ValueKindFactory;\n+import jdk.vm.ci.common.JVMCIError;\n+import jdk.vm.ci.hotspot.HotSpotCallingConventionType;\n+import jdk.vm.ci.meta.AllocatableValue;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.JavaType;\n+import jdk.vm.ci.meta.PlatformKind;\n+import jdk.vm.ci.meta.Value;\n+import jdk.vm.ci.meta.ValueKind;\n+\n+public class RISCV64HotSpotRegisterConfig implements RegisterConfig {\n+\n+    private final TargetDescription target;\n+\n+    private final RegisterArray allocatable;\n+\n+    \/**\n+     * The caller saved registers always include all parameter registers.\n+     *\/\n+    private final RegisterArray callerSaved;\n+\n+    private final boolean allAllocatableAreCallerSaved;\n+\n+    private final RegisterAttributes[] attributesMap;\n+\n+    @Override\n+    public RegisterArray getAllocatableRegisters() {\n+        return allocatable;\n+    }\n+\n+    @Override\n+    public RegisterArray filterAllocatableRegisters(PlatformKind kind, RegisterArray registers) {\n+        ArrayList<Register> list = new ArrayList<>();\n+        for (Register reg : registers) {\n+            if (target.arch.canStoreValue(reg.getRegisterCategory(), kind)) {\n+                list.add(reg);\n+            }\n+        }\n+\n+        return new RegisterArray(list);\n+    }\n+\n+    @Override\n+    public RegisterAttributes[] getAttributesMap() {\n+        return attributesMap.clone();\n+    }\n+\n+    private final RegisterArray javaGeneralParameterRegisters = new RegisterArray(x11, x12, x13, x14, x15, x16, x17, x10);\n+    private final RegisterArray nativeGeneralParameterRegisters = new RegisterArray(x10, x11, x12, x13, x14, x15, x16, x17);\n+    private final RegisterArray fpParameterRegisters = new RegisterArray(f10, f11, f12, f13, f14, f15, f16, f17);\n+\n+    public static final Register zero = x0;\n+    public static final Register ra = x1;\n+    public static final Register sp = x2;\n+    public static final Register gp = x3;\n+    public static final Register tp = x4;\n+    public static final Register t0 = x5;\n+    public static final Register t1 = x6;\n+    public static final Register t2 = x7;\n+    public static final Register fp = x8;\n+    public static final Register threadRegister = x23;\n+    public static final Register heapBaseRegister = x27;\n+\n+    private static final RegisterArray reservedRegisters = new RegisterArray(zero, ra, sp, gp, tp, t0, t1, t2, fp);\n+\n+    private static RegisterArray initAllocatable(Architecture arch, boolean reserveForHeapBase) {\n+        RegisterArray allRegisters = arch.getAvailableValueRegisters();\n+        Register[] registers = new Register[allRegisters.size() - reservedRegisters.size() - (reserveForHeapBase ? 1 : 0)];\n+        List<Register> reservedRegistersList = reservedRegisters.asList();\n+\n+        int idx = 0;\n+        for (Register reg : allRegisters) {\n+            if (reservedRegistersList.contains(reg)) {\n+                \/\/ skip reserved registers\n+                continue;\n+            }\n+            assert !(reg.equals(zero) || reg.equals(ra) || reg.equals(sp) || reg.equals(gp) || reg.equals(tp) ||\n+                     reg.equals(t0) || reg.equals(t1) || reg.equals(t2) || reg.equals(fp));\n+            if (reserveForHeapBase && reg.equals(heapBaseRegister)) {\n+                \/\/ skip heap base register\n+                continue;\n+            }\n+\n+            registers[idx++] = reg;\n+        }\n+\n+        assert idx == registers.length;\n+        return new RegisterArray(registers);\n+    }\n+\n+    public RISCV64HotSpotRegisterConfig(TargetDescription target, boolean useCompressedOops, boolean linuxOs) {\n+        this(target, initAllocatable(target.arch, useCompressedOops));\n+        assert callerSaved.size() >= allocatable.size();\n+    }\n+\n+    public RISCV64HotSpotRegisterConfig(TargetDescription target, RegisterArray allocatable) {\n+        this.target = target;\n+        this.allocatable = allocatable;\n+\n+        Set<Register> callerSaveSet = new HashSet<>();\n+        allocatable.addTo(callerSaveSet);\n+        fpParameterRegisters.addTo(callerSaveSet);\n+        javaGeneralParameterRegisters.addTo(callerSaveSet);\n+        nativeGeneralParameterRegisters.addTo(callerSaveSet);\n+        callerSaved = new RegisterArray(callerSaveSet);\n+\n+        allAllocatableAreCallerSaved = true;\n+        attributesMap = RegisterAttributes.createMap(this, RISCV64.allRegisters);\n+    }\n+\n+    @Override\n+    public RegisterArray getCallerSaveRegisters() {\n+        return callerSaved;\n+    }\n+\n+    @Override\n+    public RegisterArray getCalleeSaveRegisters() {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean areAllAllocatableRegistersCallerSaved() {\n+        return allAllocatableAreCallerSaved;\n+    }\n+\n+    @Override\n+    public CallingConvention getCallingConvention(Type type, JavaType returnType, JavaType[] parameterTypes, ValueKindFactory<?> valueKindFactory) {\n+        HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;\n+        if (type == HotSpotCallingConventionType.NativeCall) {\n+            return callingConvention(nativeGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);\n+        }\n+        return callingConvention(javaGeneralParameterRegisters, returnType, parameterTypes, hotspotType, valueKindFactory);\n+    }\n+\n+    @Override\n+    public RegisterArray getCallingConventionRegisters(Type type, JavaKind kind) {\n+        HotSpotCallingConventionType hotspotType = (HotSpotCallingConventionType) type;\n+        switch (kind) {\n+            case Boolean:\n+            case Byte:\n+            case Short:\n+            case Char:\n+            case Int:\n+            case Long:\n+            case Object:\n+                return hotspotType == HotSpotCallingConventionType.NativeCall ? nativeGeneralParameterRegisters : javaGeneralParameterRegisters;\n+            case Float:\n+            case Double:\n+                return fpParameterRegisters;\n+            default:\n+                throw JVMCIError.shouldNotReachHere();\n+        }\n+    }\n+\n+    private CallingConvention callingConvention(RegisterArray generalParameterRegisters, JavaType returnType, JavaType[] parameterTypes, HotSpotCallingConventionType type,\n+                    ValueKindFactory<?> valueKindFactory) {\n+        AllocatableValue[] locations = new AllocatableValue[parameterTypes.length];\n+\n+        int currentGeneral = 0;\n+        int currentFP = 0;\n+        int currentStackOffset = 0;\n+\n+        for (int i = 0; i < parameterTypes.length; i++) {\n+            final JavaKind kind = parameterTypes[i].getJavaKind().getStackKind();\n+\n+            switch (kind) {\n+                case Byte:\n+                case Boolean:\n+                case Short:\n+                case Char:\n+                case Int:\n+                case Long:\n+                case Object:\n+                    if (currentGeneral < generalParameterRegisters.size()) {\n+                        Register register = generalParameterRegisters.get(currentGeneral++);\n+                        locations[i] = register.asValue(valueKindFactory.getValueKind(kind));\n+                    }\n+                    break;\n+                case Float:\n+                case Double:\n+                    if (currentFP < fpParameterRegisters.size()) {\n+                        Register register = fpParameterRegisters.get(currentFP++);\n+                        locations[i] = register.asValue(valueKindFactory.getValueKind(kind));\n+                    } else if (currentGeneral < generalParameterRegisters.size()) {\n+                        Register register = generalParameterRegisters.get(currentGeneral++);\n+                        locations[i] = register.asValue(valueKindFactory.getValueKind(kind));\n+                    }\n+                    break;\n+                default:\n+                    throw JVMCIError.shouldNotReachHere();\n+            }\n+\n+            if (locations[i] == null) {\n+                ValueKind<?> valueKind = valueKindFactory.getValueKind(kind);\n+                locations[i] = StackSlot.get(valueKind, currentStackOffset, !type.out);\n+                currentStackOffset += Math.max(valueKind.getPlatformKind().getSizeInBytes(), target.wordSize);\n+            }\n+        }\n+\n+        JavaKind returnKind = returnType == null ? JavaKind.Void : returnType.getJavaKind();\n+        AllocatableValue returnLocation = returnKind == JavaKind.Void ? Value.ILLEGAL : getReturnRegister(returnKind).asValue(valueKindFactory.getValueKind(returnKind.getStackKind()));\n+        return new CallingConvention(currentStackOffset, returnLocation, locations);\n+    }\n+\n+    @Override\n+    public Register getReturnRegister(JavaKind kind) {\n+        switch (kind) {\n+            case Boolean:\n+            case Byte:\n+            case Char:\n+            case Short:\n+            case Int:\n+            case Long:\n+            case Object:\n+                return x10;\n+            case Float:\n+            case Double:\n+                return f10;\n+            case Void:\n+            case Illegal:\n+                return null;\n+            default:\n+                throw new UnsupportedOperationException(\"no return register for type \" + kind);\n+        }\n+    }\n+\n+    @Override\n+    public Register getFrameRegister() {\n+        return x2;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Allocatable: \" + getAllocatableRegisters() + \"%n\" + \"CallerSave:  \" + getCallerSaveRegisters() + \"%n\");\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotRegisterConfig.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n+\n+import jdk.vm.ci.hotspot.HotSpotVMConfigAccess;\n+import jdk.vm.ci.hotspot.HotSpotVMConfigStore;\n+import jdk.vm.ci.services.Services;\n+\n+\/**\n+ * Used to access native configuration details.\n+ *\n+ * All non-static, public fields in this class are so that they can be compiled as constants.\n+ *\/\n+class RISCV64HotSpotVMConfig extends HotSpotVMConfigAccess {\n+\n+    RISCV64HotSpotVMConfig(HotSpotVMConfigStore config) {\n+        super(config);\n+    }\n+\n+    final boolean linuxOs = Services.getSavedProperty(\"os.name\", \"\").startsWith(\"Linux\");\n+\n+    final boolean useCompressedOops = getFlag(\"UseCompressedOops\", Boolean.class);\n+\n+    \/\/ CPU Capabilities\n+\n+    \/*\n+     * These flags are set based on the corresponding command line flags.\n+     *\/\n+    final boolean useConservativeFence = getFlag(\"UseConservativeFence\", Boolean.class);\n+    final boolean avoidUnalignedAccesses = getFlag(\"AvoidUnalignedAccesses\", Boolean.class);\n+    final boolean nearCpool = getFlag(\"NearCpool\", Boolean.class);\n+    final boolean traceTraps = getFlag(\"TraceTraps\", Boolean.class);\n+    final boolean useRVV = getFlag(\"UseRVV\", Boolean.class);\n+    final boolean useRVC = getFlag(\"UseRVC\", Boolean.class);\n+    final boolean useZba = getFlag(\"UseZba\", Boolean.class);\n+    final boolean useZbb = getFlag(\"UseZbb\", Boolean.class);\n+    final boolean useRVVForBigIntegerShiftIntrinsics = getFlag(\"UseRVVForBigIntegerShiftIntrinsics\", Boolean.class);\n+\n+    final long vmVersionFeatures = getFieldValue(\"Abstract_VM_Version::_features\", Long.class, \"uint64_t\");\n+\n+    \/*\n+     * These flags are set if the corresponding support is in the hardware.\n+     *\/\n+    \/\/ Checkstyle: stop\n+    \/\/ CPU feature flags are currently not available in VM_Version\n+    \/\/ Checkstyle: resume\n+\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotVMConfig.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * The RISCV64 HotSpot specific portions of the JVMCI API.\n+ *\/\n+package jdk.vm.ci.hotspot.riscv64;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot.riscv64\/src\/jdk\/vm\/ci\/hotspot\/riscv64\/package-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.riscv64;\n+\n+import java.nio.ByteOrder;\n+import java.util.EnumSet;\n+\n+import jdk.vm.ci.code.Architecture;\n+import jdk.vm.ci.code.CPUFeatureName;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.Register.RegisterCategory;\n+import jdk.vm.ci.code.RegisterArray;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.PlatformKind;\n+\n+\/**\n+ * Represents the RISCV64 architecture.\n+ *\/\n+public class RISCV64 extends Architecture {\n+\n+    public static final RegisterCategory CPU = new RegisterCategory(\"CPU\");\n+\n+    \/\/ General purpose CPU registers\n+    public static final Register x0 = new Register(0, 0, \"x0\", CPU);\n+    public static final Register x1 = new Register(1, 1, \"x1\", CPU);\n+    public static final Register x2 = new Register(2, 2, \"x2\", CPU);\n+    public static final Register x3 = new Register(3, 3, \"x3\", CPU);\n+    public static final Register x4 = new Register(4, 4, \"x4\", CPU);\n+    public static final Register x5 = new Register(5, 5, \"x5\", CPU);\n+    public static final Register x6 = new Register(6, 6, \"x6\", CPU);\n+    public static final Register x7 = new Register(7, 7, \"x7\", CPU);\n+    public static final Register x8 = new Register(8, 8, \"x8\", CPU);\n+    public static final Register x9 = new Register(9, 9, \"x9\", CPU);\n+    public static final Register x10 = new Register(10, 10, \"x10\", CPU);\n+    public static final Register x11 = new Register(11, 11, \"x11\", CPU);\n+    public static final Register x12 = new Register(12, 12, \"x12\", CPU);\n+    public static final Register x13 = new Register(13, 13, \"x13\", CPU);\n+    public static final Register x14 = new Register(14, 14, \"x14\", CPU);\n+    public static final Register x15 = new Register(15, 15, \"x15\", CPU);\n+    public static final Register x16 = new Register(16, 16, \"x16\", CPU);\n+    public static final Register x17 = new Register(17, 17, \"x17\", CPU);\n+    public static final Register x18 = new Register(18, 18, \"x18\", CPU);\n+    public static final Register x19 = new Register(19, 19, \"x19\", CPU);\n+    public static final Register x20 = new Register(20, 20, \"x20\", CPU);\n+    public static final Register x21 = new Register(21, 21, \"x21\", CPU);\n+    public static final Register x22 = new Register(22, 22, \"x22\", CPU);\n+    public static final Register x23 = new Register(23, 23, \"x23\", CPU);\n+    public static final Register x24 = new Register(24, 24, \"x24\", CPU);\n+    public static final Register x25 = new Register(25, 25, \"x25\", CPU);\n+    public static final Register x26 = new Register(26, 26, \"x26\", CPU);\n+    public static final Register x27 = new Register(27, 27, \"x27\", CPU);\n+    public static final Register x28 = new Register(28, 28, \"x28\", CPU);\n+    public static final Register x29 = new Register(29, 29, \"x29\", CPU);\n+    public static final Register x30 = new Register(30, 30, \"x30\", CPU);\n+    public static final Register x31 = new Register(31, 31, \"x31\", CPU);\n+\n+    \/\/ @formatter:off\n+    public static final RegisterArray cpuRegisters = new RegisterArray(\n+        x0,  x1,  x2,  x3,  x4,  x5,  x6,  x7,\n+        x8,  x9,  x10, x11, x12, x13, x14, x15,\n+        x16, x17, x18, x19, x20, x21, x22, x23,\n+        x24, x25, x26, x27, x28, x29, x30, x31\n+    );\n+    \/\/ @formatter:on\n+\n+    public static final RegisterCategory FP = new RegisterCategory(\"FP\");\n+\n+    \/\/ Simd registers\n+    public static final Register f0 = new Register(32, 0, \"f0\", FP);\n+    public static final Register f1 = new Register(33, 1, \"f1\", FP);\n+    public static final Register f2 = new Register(34, 2, \"f2\", FP);\n+    public static final Register f3 = new Register(35, 3, \"f3\", FP);\n+    public static final Register f4 = new Register(36, 4, \"f4\", FP);\n+    public static final Register f5 = new Register(37, 5, \"f5\", FP);\n+    public static final Register f6 = new Register(38, 6, \"f6\", FP);\n+    public static final Register f7 = new Register(39, 7, \"f7\", FP);\n+    public static final Register f8 = new Register(40, 8, \"f8\", FP);\n+    public static final Register f9 = new Register(41, 9, \"f9\", FP);\n+    public static final Register f10 = new Register(42, 10, \"f10\", FP);\n+    public static final Register f11 = new Register(43, 11, \"f11\", FP);\n+    public static final Register f12 = new Register(44, 12, \"f12\", FP);\n+    public static final Register f13 = new Register(45, 13, \"f13\", FP);\n+    public static final Register f14 = new Register(46, 14, \"f14\", FP);\n+    public static final Register f15 = new Register(47, 15, \"f15\", FP);\n+    public static final Register f16 = new Register(48, 16, \"f16\", FP);\n+    public static final Register f17 = new Register(49, 17, \"f17\", FP);\n+    public static final Register f18 = new Register(50, 18, \"f18\", FP);\n+    public static final Register f19 = new Register(51, 19, \"f19\", FP);\n+    public static final Register f20 = new Register(52, 20, \"f20\", FP);\n+    public static final Register f21 = new Register(53, 21, \"f21\", FP);\n+    public static final Register f22 = new Register(54, 22, \"f22\", FP);\n+    public static final Register f23 = new Register(55, 23, \"f23\", FP);\n+    public static final Register f24 = new Register(56, 24, \"f24\", FP);\n+    public static final Register f25 = new Register(57, 25, \"f25\", FP);\n+    public static final Register f26 = new Register(58, 26, \"f26\", FP);\n+    public static final Register f27 = new Register(59, 27, \"f27\", FP);\n+    public static final Register f28 = new Register(60, 28, \"f28\", FP);\n+    public static final Register f29 = new Register(61, 29, \"f29\", FP);\n+    public static final Register f30 = new Register(62, 30, \"f30\", FP);\n+    public static final Register f31 = new Register(63, 31, \"f31\", FP);\n+\n+    \/\/ @formatter:off\n+    public static final RegisterArray fpRegisters = new RegisterArray(\n+        f0,  f1,  f2,  f3,  f4,  f5,  f6,  f7,\n+        f8,  f9,  f10, f11, f12, f13, f14, f15,\n+        f16, f17, f18, f19, f20, f21, f22, f23,\n+        f24, f25, f26, f27, f28, f29, f30, f31\n+    );\n+    \/\/ @formatter:on\n+\n+    \/\/ @formatter:off\n+    public static final RegisterArray allRegisters = new RegisterArray(\n+        x0,  x1,  x2,  x3,  x4,  x5,  x6,  x7,\n+        x8,  x9,  x10, x11, x12, x13, x14, x15,\n+        x16, x17, x18, x19, x20, x21, x22, x23,\n+        x24, x25, x26, x27, x28, x29, x30, x31,\n+\n+        f0,  f1,  f2,  f3,  f4,  f5,  f6,  f7,\n+        f8,  f9,  f10, f11, f12, f13, f14, f15,\n+        f16, f17, f18, f19, f20, f21, f22, f23,\n+        f24, f25, f26, f27, f28, f29, f30, f31\n+    );\n+    \/\/ @formatter:on\n+\n+    \/**\n+     * Basic set of CPU features mirroring what is returned from the mcpuid register. See:\n+     * {@code VM_Version::cpuFeatureFlags}.\n+     *\/\n+    public enum CPUFeature implements CPUFeatureName {\n+        I,\n+        M,\n+        A,\n+        F,\n+        D,\n+        C,\n+        V\n+    }\n+\n+    private final EnumSet<CPUFeature> features;\n+\n+    \/**\n+     * Set of flags to control code emission.\n+     *\/\n+    public enum Flag {\n+        UseConservativeFence,\n+        AvoidUnalignedAccesses,\n+        NearCpool,\n+        TraceTraps,\n+        UseRVV,\n+        UseRVC,\n+        UseZba,\n+        UseZbb,\n+        UseRVVForBigIntegerShiftIntrinsics\n+    }\n+\n+    private final EnumSet<Flag> flags;\n+\n+    public RISCV64(EnumSet<CPUFeature> features, EnumSet<Flag> flags) {\n+        super(\"riscv64\", RISCV64Kind.QWORD, ByteOrder.LITTLE_ENDIAN, true, allRegisters, 0, 0, 8);\n+        this.features = features;\n+        this.flags = flags;\n+    }\n+\n+    @Override\n+    public EnumSet<CPUFeature> getFeatures() {\n+        return features;\n+    }\n+\n+    public EnumSet<Flag> getFlags() {\n+        return flags;\n+    }\n+\n+    @Override\n+    public PlatformKind getPlatformKind(JavaKind javaKind) {\n+        switch (javaKind) {\n+            case Boolean:\n+            case Byte:\n+                return RISCV64Kind.BYTE;\n+            case Short:\n+            case Char:\n+                return RISCV64Kind.WORD;\n+            case Int:\n+                return RISCV64Kind.DWORD;\n+            case Long:\n+            case Object:\n+                return RISCV64Kind.QWORD;\n+            case Float:\n+                return RISCV64Kind.SINGLE;\n+            case Double:\n+                return RISCV64Kind.DOUBLE;\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    @Override\n+    public boolean canStoreValue(RegisterCategory category, PlatformKind platformKind) {\n+        RISCV64Kind kind = (RISCV64Kind) platformKind;\n+        if (kind.isInteger()) {\n+            return category.equals(CPU);\n+        } else if (kind.isFP()) {\n+            return category.equals(FP);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public RISCV64Kind getLargestStorableKind(RegisterCategory category) {\n+        if (category.equals(CPU)) {\n+            return RISCV64Kind.QWORD;\n+        } else if (category.equals(FP)) {\n+            return RISCV64Kind.DOUBLE;\n+        } else {\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.riscv64\/src\/jdk\/vm\/ci\/riscv64\/RISCV64.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.vm.ci.riscv64;\n+\n+import jdk.vm.ci.meta.PlatformKind;\n+\n+public enum RISCV64Kind implements PlatformKind {\n+\n+    \/\/ scalar\n+    BYTE(1),\n+    WORD(2),\n+    DWORD(4),\n+    QWORD(8),\n+    SINGLE(4),\n+    DOUBLE(8);\n+\n+    private final int size;\n+    private final int vectorLength;\n+\n+    private final RISCV64Kind scalar;\n+    private final EnumKey<RISCV64Kind> key = new EnumKey<>(this);\n+\n+    RISCV64Kind(int size) {\n+        this.size = size;\n+        this.scalar = this;\n+        this.vectorLength = 1;\n+    }\n+\n+    RISCV64Kind(int size, RISCV64Kind scalar) {\n+        this.size = size;\n+        this.scalar = scalar;\n+\n+        assert size % scalar.size == 0;\n+        this.vectorLength = size \/ scalar.size;\n+    }\n+\n+    public RISCV64Kind getScalar() {\n+        return scalar;\n+    }\n+\n+    @Override\n+    public int getSizeInBytes() {\n+        return size;\n+    }\n+\n+    @Override\n+    public int getVectorLength() {\n+        return vectorLength;\n+    }\n+\n+    @Override\n+    public Key getKey() {\n+        return key;\n+    }\n+\n+    public boolean isInteger() {\n+        switch (this) {\n+            case BYTE:\n+            case WORD:\n+            case DWORD:\n+            case QWORD:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public boolean isFP() {\n+        switch (this) {\n+            case SINGLE:\n+            case DOUBLE:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    @Override\n+    public char getTypeChar() {\n+        switch (this) {\n+            case BYTE:\n+                return 'b';\n+            case WORD:\n+                return 'w';\n+            case DWORD:\n+                return 'd';\n+            case QWORD:\n+                return 'q';\n+            case SINGLE:\n+                return 'S';\n+            case DOUBLE:\n+                return 'D';\n+            default:\n+                return '-';\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.riscv64\/src\/jdk\/vm\/ci\/riscv64\/RISCV64Kind.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * The RISCV64 platform independent portions of the JVMCI API.\n+ *\/\n+package jdk.vm.ci.riscv64;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.riscv64\/src\/jdk\/vm\/ci\/riscv64\/package-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -42,1 +42,2 @@\n-        jdk.vm.ci.hotspot.amd64.AMD64HotSpotJVMCIBackendFactory;\n+        jdk.vm.ci.hotspot.amd64.AMD64HotSpotJVMCIBackendFactory,\n+        jdk.vm.ci.hotspot.riscv64.RISCV64HotSpotJVMCIBackendFactory;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+\n+@Category({\"Java Development Kit\", \"Security\"})\n+@Label(\"Initial Security Property\")\n+@Name(\"jdk.InitialSecurityProperty\")\n+@Description(\"Initial Security Properties\")\n+public final class InitialSecurityPropertyEvent extends AbstractJDKEvent {\n+    @Label(\"Key\")\n+    public String key;\n+\n+    @Label(\"Value\")\n+    public String value;\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/InitialSecurityPropertyEvent.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -47,1 +47,0 @@\n-import jdk.jfr.internal.EventInstrumentation.SettingInfo;\n@@ -69,1 +68,1 @@\n-    private final ArrayList<SettingInfo> settingInfos = new ArrayList<>();\n+    private final ArrayList<SettingControl> settingControls = new ArrayList<>();\n@@ -166,1 +165,0 @@\n-            int index = settingInfos.size();\n@@ -183,1 +181,1 @@\n-                settingInfos.add(new SettingInfo(FIELD_SETTING_PREFIX + index, index, null, null, settingControl));\n+                settingControls.add(settingControl);\n@@ -311,2 +309,9 @@\n-    public List<SettingInfo> getSettingInfos() {\n-        return settingInfos;\n+    \/**\n+     * A malicious user must never be able to run a callback in the wrong\n+     * context. Methods on SettingControl must therefore never be invoked directly\n+     * by JFR, instead use jdk.jfr.internal.Control.\n+     *\n+     * The returned list is only to be used inside EventConfiguration\n+     *\/\n+    public List<SettingControl> getSettingControls() {\n+        return settingControls;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -63,9 +63,1 @@\n-    record SettingInfo(String fieldName, int index, Type paramType, String methodName, SettingControl settingControl) {\n-        \/**\n-         * A malicious user must never be able to run a callback in the wrong\n-         * context. Methods on SettingControl must therefore never be invoked directly\n-         * by JFR, instead use jdk.jfr.internal.Control.\n-         *\/\n-        public SettingControl settingControl() {\n-            return this.settingControl;\n-        }\n+    record SettingInfo(Type paramType, String methodName) {\n@@ -74,1 +66,1 @@\n-    record FieldInfo(String fieldName, String fieldDescriptor, String internalClassName) {\n+    record FieldInfo(String name, String descriptor) {\n@@ -139,2 +131,2 @@\n-        for (FieldInfo v : fields) {\n-            sb.append(v.fieldDescriptor);\n+        for (FieldInfo field : fields) {\n+            sb.append(field.descriptor);\n@@ -247,2 +239,0 @@\n-                                String fieldName = EventControl.FIELD_SETTING_PREFIX + settingInfos.size();\n-                                int index = settingInfos.size();\n@@ -250,1 +240,1 @@\n-                                settingInfos.add(new SettingInfo(fieldName, index, paramType, m.name, null));\n+                                settingInfos.add(new SettingInfo(paramType, m.name));\n@@ -266,2 +256,0 @@\n-                                String fieldName = EventControl.FIELD_SETTING_PREFIX + settingInfos.size();\n-                                int index = settingInfos.size();\n@@ -269,1 +257,1 @@\n-                                settingInfos.add(new SettingInfo(fieldName, index, paramType, method.getName(), null));\n+                                settingInfos.add(new SettingInfo(paramType, method.getName()));\n@@ -288,2 +276,2 @@\n-        fieldInfos.add(new FieldInfo(\"startTime\", Type.LONG_TYPE.getDescriptor(), classNode.name));\n-        fieldInfos.add(new FieldInfo(\"duration\", Type.LONG_TYPE.getDescriptor(), classNode.name));\n+        fieldInfos.add(new FieldInfo(\"startTime\", Type.LONG_TYPE.getDescriptor()));\n+        fieldInfos.add(new FieldInfo(\"duration\", Type.LONG_TYPE.getDescriptor()));\n@@ -292,1 +280,1 @@\n-                FieldInfo fi = new FieldInfo(field.name, field.desc, classNode.name);\n+                FieldInfo fi = new FieldInfo(field.name, field.desc);\n@@ -306,1 +294,1 @@\n-                            fieldInfos.add(new FieldInfo(fieldName, fieldType.getDescriptor(), internalClassName));\n+                            fieldInfos.add(new FieldInfo(fieldName, fieldType.getDescriptor()));\n@@ -577,1 +565,1 @@\n-                    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), field.fieldName, field.fieldDescriptor);\n+                    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, getInternalClassName(), field.name, field.descriptor);\n@@ -636,2 +624,2 @@\n-            int index = 0;\n-            for (SettingInfo si : settingInfos) {\n+            for (int index = 0; index < settingInfos.size(); index++) {\n+                SettingInfo si = settingInfos.get(index);\n@@ -651,1 +639,0 @@\n-                index++;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":13,"deletions":26,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    public static EventWriterMethod lookupMethod(FieldInfo v) {\n+    public static EventWriterMethod lookupMethod(FieldInfo field) {\n@@ -72,1 +72,1 @@\n-        if (v.fieldName().equals(EventInstrumentation.FIELD_EVENT_THREAD)) {\n+        if (field.name().equals(EventInstrumentation.FIELD_EVENT_THREAD)) {\n@@ -76,1 +76,1 @@\n-            if (v.fieldDescriptor().equals(m.typeDescriptor)) {\n+            if (field.descriptor().equals(m.typeDescriptor)) {\n@@ -80,1 +80,1 @@\n-        throw new Error(\"Unknown type \" + v.fieldDescriptor());\n+        throw new Error(\"Unknown type \" + field.descriptor());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriterMethod.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,3 +42,0 @@\n-    \/\/ JVM signals file changes by doing Object#notify on this object\n-    static final Object FILE_DELTA_CHANGE = new Object();\n-\n@@ -47,0 +44,9 @@\n+    private static class ChunkRotationMonitor {}\n+\n+    \/*\n+     * The JVM uses the chunk rotation monitor to notify Java that a rotation is warranted.\n+     * The monitor type is used to exclude jdk.JavaMonitorWait events from being generated\n+     * when Object.wait() is called on this monitor.\n+     *\/\n+    static final Object CHUNK_ROTATION_MONITOR = new ChunkRotationMonitor();\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-    private EventConfiguration newEventConfiguration(EventType eventType, EventControl ec, SettingControl[] settings) {\n+    private EventConfiguration newEventConfiguration(EventType eventType, EventControl ec) {\n@@ -194,1 +194,1 @@\n-                var argClasses = new Class<?>[] { EventType.class, EventControl.class, SettingControl[].class };\n+                var argClasses = new Class<?>[] { EventType.class, EventControl.class};\n@@ -199,1 +199,1 @@\n-            return cachedEventConfigurationConstructor.newInstance(eventType, ec, settings);\n+            return cachedEventConfigurationConstructor.newInstance(eventType, ec);\n@@ -212,7 +212,1 @@\n-        List<SettingInfo> settingInfos = ec.getSettingInfos();\n-        SettingControl[] settings = new SettingControl[settingInfos.size()];\n-        int index = 0;\n-        for (var settingInfo : settingInfos) {\n-            settings[index++] = settingInfo.settingControl();\n-        }\n-        EventConfiguration configuration = newEventConfiguration(eventType, ec, settings);\n+        EventConfiguration configuration = newEventConfiguration(eventType, ec);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -240,1 +240,5 @@\n-    public boolean isEveryChunk() {\n+    \/**\n+     * Returns true if \"beginChunk\", \"endChunk\" or \"everyChunk\" have\n+     * been set.\n+     *\/\n+    public boolean isChunkTime() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -523,2 +523,2 @@\n-            synchronized (JVM.FILE_DELTA_CHANGE) {\n-                JVM.FILE_DELTA_CHANGE.wait(duration < 10 ? 10 : duration);\n+            synchronized (JVM.CHUNK_ROTATION_MONITOR) {\n+                JVM.CHUNK_ROTATION_MONITOR.wait(duration < 10 ? 10 : duration);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -43,0 +44,1 @@\n+    private static final ReentrantLock lock = new ReentrantLock();\n@@ -69,1 +71,1 @@\n-                        jvm.emitEvent(type.getId(), JVM.counterTime(), 0);\n+                        emitJVMEvent(type);\n@@ -83,0 +85,12 @@\n+        private void emitJVMEvent(PlatformEventType type) {\n+            try {\n+                \/\/ There should only be one thread in native at a time.\n+                \/\/ ReentrantLock is used to avoid JavaMonitorBlocked event\n+                \/\/ from synchronized block.\n+                lock.lock();\n+                jvm.emitEvent(type.getId(), JVM.counterTime(), 0);\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n+\n@@ -224,1 +238,1 @@\n-            if (!es.isEnabled() || es.isEveryChunk()) {\n+            if (!es.isEnabled() || es.isChunkTime()) {\n@@ -291,2 +305,2 @@\n-            synchronized (JVM.FILE_DELTA_CHANGE) {\n-                JVM.FILE_DELTA_CHANGE.notifyAll();\n+            synchronized (JVM.CHUNK_ROTATION_MONITOR) {\n+                JVM.CHUNK_ROTATION_MONITOR.notifyAll();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RequestEngine.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -167,2 +167,12 @@\n-                } else if (finished) {\n-                    throw new IOException(\"No metadata event found in finished chunk.\");\n+                } else {\n+                    if (finished) {\n+                        throw new IOException(\"No metadata event found in finished chunk.\");\n+                    }\n+                    if (chunkSize == HEADER_SIZE) {\n+                        \/\/ This ensures that a non-streaming parser is able\n+                        \/\/ to break out of the loop in case the file is\n+                        \/\/ ended before the first metadata event has\n+                        \/\/ been written. This can happen during a failed crash\n+                        \/\/ dump.\n+                        input.pollWait();\n+                    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkHeader.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    private EventConfiguration(EventType eventType, EventControl eventControl, SettingControl[] settings) {\n+    private EventConfiguration(EventType eventType, EventControl eventControl) {\n@@ -47,1 +47,1 @@\n-        this.settings = settings;\n+        this.settings = eventControl.getSettingControls().toArray(new SettingControl[0]);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventConfiguration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Properties;\n@@ -31,0 +32,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -47,0 +49,1 @@\n+import jdk.jfr.events.InitialSecurityPropertyEvent;\n@@ -110,1 +113,2 @@\n-        DirectBufferStatisticsEvent.class\n+        DirectBufferStatisticsEvent.class,\n+        InitialSecurityPropertyEvent.class,\n@@ -133,0 +137,1 @@\n+    private static final Runnable emitInitialSecurityProperties = JDKEvents::emitInitialSecurityProperties;\n@@ -149,0 +154,1 @@\n+                RequestEngine.addTrustedJDKHook(InitialSecurityPropertyEvent.class, emitInitialSecurityProperties);\n@@ -291,0 +297,1 @@\n+        RequestEngine.removeHook(emitInitialSecurityProperties);\n@@ -303,0 +310,12 @@\n+\n+    private static void emitInitialSecurityProperties() {\n+        Properties p = SharedSecrets.getJavaSecurityPropertiesAccess().getInitialProperties();\n+        if (p != null) {\n+            for (String key : p.stringPropertyNames()) {\n+                InitialSecurityPropertyEvent e = new InitialSecurityPropertyEvent();\n+                e.key = key;\n+                e.value = p.getProperty(key);\n+                e.commit();\n+            }\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -543,1 +543,1 @@\n-    <event name=\"jdk.JitRestart\">\n+    <event name=\"jdk.JITRestart\">\n@@ -712,0 +712,5 @@\n+    <event name=\"jdk.InitialSecurityProperty\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">beginChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -543,1 +543,1 @@\n-    <event name=\"jdk.JitRestart\">\n+    <event name=\"jdk.JITRestart\">\n@@ -712,0 +712,5 @@\n+    <event name=\"jdk.InitialSecurityProperty\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">beginChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,2 +45,1 @@\n-\/\/ AllowSetForegroundWindow\n-#pragma comment(lib, \"user32\")\n+\/\/ AllowSetForegroundWindow - Requires linking with user32\n","filename":"src\/jdk.jpackage\/windows\/native\/applauncher\/WinLauncher.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#pragma comment(lib, \"ole32\")\n+\/\/ Code in this file requires linking with ole32\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/Guid.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#pragma comment(lib, \"msi.lib\")\n+\/\/ Code in this file requires linking with msi.lib\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/MsiCA.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#pragma comment(lib, \"msi.lib\")\n+\/\/ Code in this file requires linking with msi.lib\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/MsiDb.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#pragma comment(lib, \"msi.lib\")\n+\/\/ Code in this file requires linking with msi.lib\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/MsiUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,1 @@\n-\/\/ MessageBox\n-#pragma comment(lib, \"user32\")\n+\/\/ MessageBox - Requires linking with user32\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/WinApp.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n-\/\/ Needed by FileUtils::isDirectoryNotEmpty\n-#pragma comment(lib, \"shlwapi\")\n+\/\/ Needed by FileUtils::isDirectoryNotEmpty - shlwapi\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/WinFileUtils.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#pragma comment(lib, \"Shell32\")\n+\/\/ Requires linking with Shell32\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/WinSysInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#pragma comment(lib, \"advapi32\")\n+\/\/ Requires linking with advapi32\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/WindowsRegistry.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,0 +106,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -136,0 +141,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -176,0 +186,7 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     * @throws ExecutionControl.EngineTerminationException {@inheritDoc}\n+     * @throws ExecutionControl.NotImplementedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/DirectExecutionControl.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,0 +151,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiDefaultExecutionControl.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -119,0 +119,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/RemoteExecutionControl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -108,0 +113,5 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     *\/\n@@ -154,0 +164,7 @@\n+    \/**\n+     * @throws ExecutionControl.UserException {@inheritDoc}\n+     * @throws ExecutionControl.ResolutionException {@inheritDoc}\n+     * @throws ExecutionControl.StoppedException {@inheritDoc}\n+     * @throws ExecutionControl.EngineTerminationException {@inheritDoc}\n+     * @throws ExecutionControl.NotImplementedException {@inheritDoc}\n+     *\/\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/StreamingExecutionControl.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedExceptionAction;\n@@ -53,0 +55,15 @@\n+    private static int findFirstFreePort() {\n+        PrivilegedExceptionAction<DatagramSocket> action = () -> new DatagramSocket(0);\n+        int port;\n+        try {\n+            @SuppressWarnings({\"deprecated\", \"removal\"})\n+            DatagramSocket ds = AccessController.doPrivileged(action);\n+            try (DatagramSocket ds1 = ds) {\n+                port = ds1.getLocalPort();\n+            }\n+        } catch (Exception x) {\n+            port = 0;\n+        }\n+        return port;\n+    }\n+\n@@ -77,1 +94,4 @@\n-                ports[random.nextInt(capacity)] = port;\n+                \/\/ don't remove the last port\n+                int remove = random.nextInt(capacity);\n+                if ((remove +1) % capacity == index) remove = index;\n+                ports[index = remove] = port;\n@@ -93,1 +113,2 @@\n-    int lastport = 0;\n+    int lastport = findFirstFreePort();\n+    int lastSystemAllocated = lastport;\n@@ -150,0 +171,1 @@\n+            lastSystemAllocated = lastport;\n@@ -155,2 +177,4 @@\n-        boolean farEnough = Integer.bitCount(lastseen ^ lastport) > BIT_DEVIATION\n-                            && Math.abs(lastport - lastseen) > deviation;\n+        boolean farEnough = farEnough(lastseen);\n+        if (farEnough && lastSystemAllocated > 0) {\n+            farEnough = farEnough(lastSystemAllocated);\n+        }\n@@ -171,0 +195,1 @@\n+            lastSystemAllocated = lastport;\n@@ -199,3 +224,1 @@\n-                SocketException e = new SocketException(x.getMessage());\n-                e.initCause(x);\n-                throw e;\n+                throw new SocketException(x.getMessage(), x);\n@@ -221,0 +244,5 @@\n+    private boolean farEnough(int port) {\n+        return Integer.bitCount(port ^ lastport) > BIT_DEVIATION\n+                && Math.abs(port - lastport) > deviation;\n+    }\n+\n@@ -224,2 +252,16 @@\n-            int port = EphemeralPortRange.LOWER\n-                    + random.nextInt(EphemeralPortRange.RANGE);\n+            int port;\n+            boolean suitable;\n+            boolean recycled;\n+            int maxrandom = MAX_RANDOM_TRIES;\n+            do {\n+                port = EphemeralPortRange.LOWER\n+                        + random.nextInt(EphemeralPortRange.RANGE);\n+                recycled = history.contains(port);\n+                suitable = lastport == 0 || (farEnough(port) && !recycled);\n+            } while (maxrandom-- > 0 && !suitable);\n+\n+            \/\/ if no suitable port was found, try again\n+            \/\/ this means we might call random MAX_RANDOM_TRIES x MAX_RANDOM_TRIES\n+            \/\/ times - but that should be OK with MAX_RANDOM_TRIES = 5.\n+            if (!suitable) continue;\n+\n@@ -232,0 +274,2 @@\n+                        lastport = s.getLocalPort();\n+                        if (!recycled) history.add(port);\n@@ -238,1 +282,4 @@\n-                return new DatagramSocket(port);\n+                DatagramSocket s = new DatagramSocket(port);\n+                lastport = s.getLocalPort();\n+                if (!recycled) history.add(port);\n+                return s;\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DNSDatagramSocketFactory.java","additions":58,"deletions":11,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -733,1 +733,1 @@\n-            timeoutLeft -= System.currentTimeMillis() - start;\n+            timeoutLeft -= (int) (System.currentTimeMillis() - start);\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsClient.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n+\n@@ -501,2 +504,2 @@\n-            return NamingManager.getObjectInstance(obj, name, this,\n-                                                   environment);\n+            return NamingManagerHelper.getObjectInstance(obj, name, this,\n+                    environment, ObjectFactoriesFilter::checkRmiFilter);\n","filename":"src\/jdk.naming.rmi\/share\/classes\/com\/sun\/jndi\/rmi\/registry\/RegistryContext.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,2 @@\n- *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}.\n+ *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}. Limit patterns\n+ *          specified in the filter property are unused.\n@@ -46,0 +47,13 @@\n+ *     <li>{@systemProperty jdk.jndi.rmi.object.factoriesFilter}:\n+ *          <br>The value of this system property defines a filter used by\n+ *          the JDK RMI provider implementation to further restrict the set of object factory classes which will\n+ *          be allowed to instantiate objects from object references returned by RMI systems.\n+ *          The factory class named by the {@linkplain javax.naming.Reference reference instance} first will be\n+ *          matched against this specific filter and then against the global filter. The factory class is rejected\n+ *          if any of these two filters reject it, or if none of them allow it.\n+ *          The filter property supports pattern-based filter syntax with the same format as\n+ *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}. Limit patterns\n+ *          specified in the filter property are unused.\n+ *          <br>The default value allows any object factory class provided by the JDK RMI provider\n+ *          implementation.\n+ *     <\/li>\n","filename":"src\/jdk.naming.rmi\/share\/classes\/module-info.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -62,3 +62,1 @@\n-            for (InputNode n : nodeList) {\n-                nodes.add(n);\n-            }\n+            nodes.addAll(nodeList);\n@@ -91,1 +89,1 @@\n-        return new Action[]{(Action) SelectBytecodesAction.findObject(SelectBytecodesAction.class, true)};\n+        return new Action[]{SelectBytecodesAction.findObject(SelectBytecodesAction.class, true)};\n@@ -96,1 +94,1 @@\n-        return (Action) SelectBytecodesAction.findObject(SelectBytecodesAction.class, true);\n+        return SelectBytecodesAction.findObject(SelectBytecodesAction.class, true);\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/BytecodeNode.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.io.Serializable;\n@@ -37,1 +36,1 @@\n-import org.openide.util.*;\n+import org.openide.util.NbBundle;\n@@ -65,1 +64,1 @@\n-        this.add(BorderLayout.CENTER, treeView);\n+        add(BorderLayout.CENTER, treeView);\n@@ -112,5 +111,0 @@\n-    @Override\n-    public Object writeReplace() {\n-        return new ResolvableHelper();\n-    }\n-\n@@ -159,9 +153,0 @@\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return BytecodeViewTopComponent.getDefault();\n-        }\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/BytecodeViewTopComponent.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        private String bciString;\n+        private final String bciString;\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/MethodNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    private Set<InputNode> nodes;\n+    private final Set<InputNode> nodes;\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/java\/com\/sun\/hotspot\/igv\/bytecodes\/SelectBytecodesCookie.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+                <attr name=\"position\" intvalue=\"1\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/Bytecodes\/src\/main\/resources\/com\/sun\/hotspot\/igv\/bytecodes\/layer.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -29,1 +30,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -48,4 +48,4 @@\n-    private BlockWidget from;\n-    private BlockWidget to;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final BlockWidget from;\n+    private final BlockWidget to;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -53,1 +53,0 @@\n-    private InputBlockEdge edge;\n@@ -60,1 +59,0 @@\n-        this.edge = edge;\n@@ -65,5 +63,1 @@\n-        points = new ArrayList<Point>();\n-    }\n-\n-    public InputBlockEdge getEdge() {\n-        return edge;\n+        points = new ArrayList<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/BlockConnectionWidget.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,5 +30,1 @@\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.Font;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n+import java.awt.*;\n@@ -46,3 +42,3 @@\n-    private InputBlock block;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final InputBlock block;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -50,1 +46,0 @@\n-    private boolean root;\n@@ -126,9 +121,1 @@\n-        return root;\n-    }\n-\n-    public void setCluster(Cluster c) {\n-        cluster = c;\n-    }\n-\n-    public void setRoot(boolean b) {\n-        root = b;\n+        return false;\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/BlockWidget.java","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputBlockEdge;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.data.InputBlockEdge;\n@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.data.services.InputGraphProvider;\n@@ -31,0 +30,1 @@\n+import com.sun.hotspot.igv.data.services.InputGraphProvider;\n@@ -39,6 +39,1 @@\n-import org.netbeans.api.visual.action.ActionFactory;\n-import org.netbeans.api.visual.action.MoveProvider;\n-import org.netbeans.api.visual.action.RectangularSelectDecorator;\n-import org.netbeans.api.visual.action.RectangularSelectProvider;\n-import org.netbeans.api.visual.action.SelectProvider;\n-import org.netbeans.api.visual.action.WidgetAction;\n+import org.netbeans.api.visual.action.*;\n@@ -47,3 +42,0 @@\n-import org.netbeans.api.visual.router.RouterFactory;\n-import org.netbeans.api.visual.widget.LayerWidget;\n-import org.netbeans.api.visual.widget.Widget;\n@@ -54,0 +46,1 @@\n+import org.netbeans.api.visual.router.RouterFactory;\n@@ -55,0 +48,2 @@\n+import org.netbeans.api.visual.widget.LayerWidget;\n+import org.netbeans.api.visual.widget.Widget;\n@@ -62,1 +57,1 @@\n-    private HashSet<BlockWidget> selection;\n+    private final HashSet<BlockWidget> selection;\n@@ -64,6 +59,5 @@\n-    private LayerWidget edgeLayer;\n-    private LayerWidget mainLayer;\n-    private LayerWidget selectLayer;\n-    private WidgetAction hoverAction = this.createWidgetHoverAction();\n-    private WidgetAction selectAction = new DoubleClickSelectAction(this);\n-    private WidgetAction moveAction = ActionFactory.createMoveAction(null, this);\n+    private final LayerWidget edgeLayer;\n+    private final LayerWidget mainLayer;\n+    private final WidgetAction hoverAction = createWidgetHoverAction();\n+    private final WidgetAction selectAction = new DoubleClickSelectAction(this);\n+    private final WidgetAction moveAction = ActionFactory.createMoveAction(null, this);\n@@ -72,1 +66,1 @@\n-        selection = new HashSet<BlockWidget>();\n+        selection = new HashSet<>();\n@@ -74,2 +68,2 @@\n-        this.getInputBindings().setZoomActionModifiers(0);\n-        this.setLayout(LayoutFactory.createAbsoluteLayout());\n+        getInputBindings().setZoomActionModifiers(0);\n+        setLayout(LayoutFactory.createAbsoluteLayout());\n@@ -78,1 +72,1 @@\n-        this.addChild(mainLayer);\n+        addChild(mainLayer);\n@@ -81,1 +75,1 @@\n-        this.addChild(edgeLayer);\n+        addChild(edgeLayer);\n@@ -83,2 +77,2 @@\n-        selectLayer = new LayerWidget(this);\n-        this.addChild(selectLayer);\n+        LayerWidget selectLayer = new LayerWidget(this);\n+        addChild(selectLayer);\n@@ -86,4 +80,4 @@\n-        this.getActions().addAction(hoverAction);\n-        this.getActions().addAction(selectAction);\n-        this.getActions().addAction(ActionFactory.createRectangularSelectAction(this, selectLayer, this));\n-        this.getActions().addAction(ActionFactory.createMouseCenteredZoomAction(1.1));\n+        getActions().addAction(hoverAction);\n+        getActions().addAction(selectAction);\n+        getActions().addAction(ActionFactory.createRectangularSelectAction(this, selectLayer, this));\n+        getActions().addAction(ActionFactory.createMouseCenteredZoomAction(1.1));\n@@ -98,1 +92,1 @@\n-        ArrayList<InputBlock> blocks = new ArrayList<InputBlock>(this.getNodes());\n+        ArrayList<InputBlock> blocks = new ArrayList<>(getNodes());\n@@ -103,1 +97,1 @@\n-        ArrayList<InputBlockEdge> edges = new ArrayList<InputBlockEdge>(this.getEdges());\n+        ArrayList<InputBlockEdge> edges = new ArrayList<>(getEdges());\n@@ -116,2 +110,2 @@\n-            this.setEdgeSource(e, e.getFrom());\n-            this.setEdgeTarget(e, e.getTo());\n+            setEdgeSource(e, e.getFrom());\n+            setEdgeTarget(e, e.getTo());\n@@ -120,1 +114,1 @@\n-        GraphLayout<InputBlock, InputBlockEdge> layout = new HierarchicalGraphLayout<InputBlock, InputBlockEdge>();\/\/GridGraphLayout();\n+        GraphLayout<InputBlock, InputBlockEdge> layout = new HierarchicalGraphLayout<>();\n@@ -124,1 +118,1 @@\n-        this.validate();\n+        validate();\n@@ -138,1 +132,1 @@\n-            Set<InputNode> inputNodes = new HashSet<InputNode>();\n+            Set<InputNode> inputNodes = new HashSet<>();\n@@ -158,0 +152,1 @@\n+    @Override\n@@ -162,0 +157,1 @@\n+    @Override\n@@ -166,0 +162,1 @@\n+    @Override\n@@ -188,2 +185,2 @@\n-    public void movementStarted(Widget widget) {\n-    }\n+    @Override\n+    public void movementStarted(Widget widget) {}\n@@ -191,2 +188,3 @@\n-    public void movementFinished(Widget widget) {\n-    }\n+    @Override\n+\n+    public void movementFinished(Widget widget) {}\n@@ -194,0 +192,1 @@\n+    @Override\n@@ -198,0 +197,1 @@\n+    @Override\n@@ -199,1 +199,2 @@\n-        if (selection.contains(widget)) {\n+        assert widget instanceof BlockWidget;\n+        if (selection.contains((BlockWidget) widget)) {\n@@ -214,0 +215,1 @@\n+    @Override\n@@ -222,0 +224,1 @@\n+    @Override\n@@ -235,1 +238,1 @@\n-        for (InputBlock b : this.getNodes()) {\n+        for (InputBlock b : getNodes()) {\n@@ -260,0 +263,1 @@\n+    @Override\n@@ -269,0 +273,1 @@\n+    @Override\n@@ -285,0 +290,1 @@\n+    @Override\n@@ -286,1 +292,1 @@\n-        Widget w = this.findWidget(edge);\n+        Widget w = findWidget(edge);\n@@ -293,0 +299,1 @@\n+    @Override\n@@ -294,1 +301,1 @@\n-        Widget w = this.findWidget(edge);\n+        Widget w = findWidget(edge);\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowScene.java","additions":51,"deletions":44,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.io.Serializable;\n@@ -54,3 +53,2 @@\n-        this.setLayout(new BorderLayout());\n-        this.associateLookup(scene.getLookup());\n-\n+        setLayout(new BorderLayout());\n+        associateLookup(scene.getLookup());\n@@ -59,1 +57,1 @@\n-        this.add(panel, BorderLayout.CENTER);\n+        add(panel, BorderLayout.CENTER);\n@@ -117,5 +115,0 @@\n-    @Override\n-    public Object writeReplace() {\n-        return new ResolvableHelper();\n-    }\n-\n@@ -133,9 +126,0 @@\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return ControlFlowTopComponent.getDefault();\n-        }\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/ControlFlowTopComponent.java","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,5 +27,1 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Port;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import com.sun.hotspot.igv.layout.*;\n@@ -34,7 +30,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n@@ -51,2 +41,1 @@\n-    public HierarchicalGraphLayout() {\n-    }\n+    public HierarchicalGraphLayout() {}\n@@ -56,2 +45,2 @@\n-        private VertexWrapper from;\n-        private VertexWrapper to;\n+        private final VertexWrapper from;\n+        private final VertexWrapper to;\n@@ -81,1 +70,1 @@\n-            return new ArrayList<Point>();\n+            return new ArrayList<>();\n@@ -95,3 +84,3 @@\n-        private N node;\n-        private UniversalGraph<N, E> graph;\n-        private Port slot;\n+        private final N node;\n+        private final UniversalGraph<N, E> graph;\n+        private final Port slot;\n@@ -125,0 +114,1 @@\n+            assert w.getBounds() != null;\n@@ -154,3 +144,3 @@\n-        Set<LinkWrapper> links = new LinkedHashSet<LinkWrapper>();\n-        Set<VertexWrapper> vertices = new LinkedHashSet<VertexWrapper>();\n-        Map<N, VertexWrapper> vertexMap = new HashMap<N, VertexWrapper>();\n+        Set<LinkWrapper> links = new LinkedHashSet<>();\n+        Set<VertexWrapper> vertices = new LinkedHashSet<>();\n+        Map<N, VertexWrapper> vertexMap = new HashMap<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/java\/com\/sun\/hotspot\/igv\/controlflow\/HierarchicalGraphLayout.java","additions":13,"deletions":23,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -13,0 +13,1 @@\n+                <attr name=\"position\" intvalue=\"2\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/ControlFlow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/controlflow\/layer.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.List;\n@@ -33,0 +32,1 @@\n+import java.util.List;\n@@ -48,2 +48,2 @@\n-    private InstanceContent content;\n-    private FolderChildren children;\n+    private final InstanceContent content;\n+    private final FolderChildren children;\n@@ -52,1 +52,1 @@\n-    private static Map<InputGraph, GraphNode> graphNode = new HashMap<>();\n+    private static final Map<InputGraph, GraphNode> graphNode = new HashMap<>();\n@@ -131,6 +131,3 @@\n-            content.add(new RemoveCookie() {\n-                @Override\n-                public void remove() {\n-                    children.destroyNodes(children.getNodes());\n-                    folderElement.getParent().removeElement(folderElement);\n-                }\n+            content.add((RemoveCookie) () -> {\n+                children.destroyNodes(children.getNodes());\n+                folderElement.getParent().removeElement(folderElement);\n@@ -166,1 +163,1 @@\n-        return (folder != null && folder instanceof GraphDocument);\n+        return (folder instanceof GraphDocument);\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/FolderNode.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,6 +26,1 @@\n-import com.sun.hotspot.igv.coordinator.actions.CloneGraphAction;\n-import com.sun.hotspot.igv.coordinator.actions.DiffGraphAction;\n-import com.sun.hotspot.igv.coordinator.actions.DiffGraphCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphCloneCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphOpenCookie;\n-import com.sun.hotspot.igv.coordinator.actions.GraphRemoveCookie;\n+import com.sun.hotspot.igv.coordinator.actions.*;\n@@ -40,6 +35,1 @@\n-import org.openide.nodes.AbstractNode;\n-import org.openide.nodes.Children;\n-import org.openide.nodes.NodeAdapter;\n-import org.openide.nodes.NodeEvent;\n-import org.openide.nodes.NodeMemberEvent;\n-import org.openide.nodes.Sheet;\n+import org.openide.nodes.*;\n@@ -135,1 +125,1 @@\n-        return new Action[]{(Action) DiffGraphAction.findObject(DiffGraphAction.class, true), (Action) CloneGraphAction.findObject(CloneGraphAction.class, true), (Action) OpenAction.findObject(OpenAction.class, true)};\n+        return new Action[]{DiffGraphAction.findObject(DiffGraphAction.class, true), CloneGraphAction.findObject(CloneGraphAction.class, true), OpenAction.findObject(OpenAction.class, true)};\n@@ -140,1 +130,1 @@\n-        return (Action) OpenAction.findObject(OpenAction.class, true);\n+        return OpenAction.findObject(OpenAction.class, true);\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/GraphNode.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.io.Serializable;\n@@ -69,2 +68,0 @@\n-    private Server server;\n-    private Server binaryServer;\n@@ -141,2 +138,1 @@\n-        server = new Server(getDocument(), callback, false);\n-        binaryServer = new Server(getDocument(), callback, true);\n+        new Server(callback);\n@@ -289,9 +285,0 @@\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return OutlineTopComponent.getDefault();\n-        }\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponent.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.data.serialization.BinaryParser;\n@@ -34,1 +33,0 @@\n-import java.awt.event.ActionEvent;\n@@ -36,1 +34,0 @@\n-import java.io.FileNotFoundException;\n@@ -42,0 +39,1 @@\n+import javax.swing.Action;\n@@ -45,1 +43,0 @@\n-import javax.swing.Action;\n@@ -48,4 +45,1 @@\n-import org.openide.util.Exceptions;\n-import org.openide.util.RequestProcessor;\n-import org.openide.util.HelpCtx;\n-import org.openide.util.NbBundle;\n+import org.openide.util.*;\n@@ -53,1 +47,0 @@\n-import org.openide.util.Utilities;\n@@ -68,1 +61,1 @@\n-                return f.getName().toLowerCase().endsWith(\".xml\") || f.getName().toLowerCase().endsWith(\".bgv\") || f.isDirectory();\n+                return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n@@ -73,1 +66,1 @@\n-                return \"Graph files (*.xml, *.bgv)\";\n+                return \"Graph files (*.xml)\";\n@@ -105,2 +98,1 @@\n-                                } catch (IOException ex) {\n-                                }\n+                                } catch (IOException ignored) {}\n@@ -118,2 +110,0 @@\n-                    } else if (file.getName().endsWith(\".bgv\")) {\n-                        parser = new BinaryParser(channel, monitor, component.getDocument(), null);\n@@ -129,7 +119,4 @@\n-                                        SwingUtilities.invokeLater(new Runnable(){\n-                                                @Override\n-                                                public void run() {\n-                                                    component.requestActive();\n-                                                    component.getDocument().addGraphDocument(document);\n-                                                }\n-                                            });\n+                                        SwingUtilities.invokeLater(() -> {\n+                                            component.requestActive();\n+                                            component.getDocument().addGraphDocument(document);\n+                                        });\n@@ -145,2 +132,0 @@\n-                } catch (FileNotFoundException ex) {\n-                    Exceptions.printStackTrace(ex);\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/ImportAction.java","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n@@ -31,1 +29,0 @@\n-import javax.swing.KeyStroke;\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/RemoveAllAction.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n@@ -31,1 +29,0 @@\n-import javax.swing.KeyStroke;\n@@ -34,2 +31,0 @@\n-import org.openide.util.NbBundle.Messages;\n-import org.openide.util.actions.CallableSystemAction;\n@@ -37,0 +32,1 @@\n+import org.openide.util.actions.CallableSystemAction;\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAllAction.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n@@ -34,1 +33,5 @@\n-import java.io.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.Writer;\n+import java.nio.file.Files;\n@@ -40,1 +43,0 @@\n-import org.openide.util.actions.CookieAction;\n@@ -55,1 +57,0 @@\n-        final OutlineTopComponent component = OutlineTopComponent.findInstance();\n@@ -87,1 +88,1 @@\n-                try (Writer writer = new OutputStreamWriter(new FileOutputStream(file))) {\n+                try (Writer writer = new OutputStreamWriter(Files.newOutputStream(file.toPath()))) {\n@@ -91,2 +92,0 @@\n-            } catch (FileNotFoundException e) {\n-                e.printStackTrace();\n@@ -95,1 +94,0 @@\n-\n@@ -100,4 +98,0 @@\n-    protected int mode() {\n-        return CookieAction.MODE_SOME;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAsAction.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    \n+\n@@ -49,0 +49,1 @@\n+            <attr name=\"position\" intvalue=\"50\"\/>\n@@ -99,1 +100,1 @@\n-        \n+\n@@ -101,0 +102,1 @@\n+            <attr name=\"position\" intvalue=\"100\"\/>\n@@ -133,1 +135,1 @@\n-        \n+\n@@ -135,0 +137,1 @@\n+            <attr name=\"position\" intvalue=\"150\"\/>\n@@ -151,1 +154,1 @@\n-        \n+\n@@ -162,0 +165,1 @@\n+            <attr name=\"position\" intvalue=\"200\"\/>\n@@ -164,0 +168,1 @@\n+                <attr name=\"position\" intvalue=\"1\"\/>\n@@ -168,0 +173,1 @@\n+            <attr name=\"position\" intvalue=\"250\"\/>\n@@ -170,0 +176,1 @@\n+                <attr name=\"position\" intvalue=\"4\"\/>\n@@ -191,0 +198,1 @@\n+            <attr name=\"position\" intvalue=\"300\"\/>\n@@ -217,1 +225,1 @@\n-    \n+\n@@ -222,1 +230,1 @@\n-        <folder name=\"Modes\">  \n+        <folder name=\"Modes\">\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/layer.xml","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    private T object;\n+    private final T object;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/ChangedEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    private List<L> listener;\n+    private final List<L> listener;\n@@ -48,4 +48,0 @@\n-    \/**\n-     * Remove listener\n-     * @param l\n-     *\/\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Event.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    private List<FolderElement> elements;\n-    private ChangedEvent<GraphDocument> changedEvent;\n+    private final List<FolderElement> elements;\n+    private final ChangedEvent<GraphDocument> changedEvent;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/GraphDocument.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-    private final List<FolderElement> elements;\n@@ -36,1 +35,0 @@\n-\n@@ -38,1 +36,1 @@\n-    private transient ChangedEvent<Group> changedEvent;\n+    private final transient ChangedEvent<Group> changedEvent;\n@@ -42,1 +40,0 @@\n-        elements = new ArrayList<>();\n@@ -47,1 +44,1 @@\n-        \/\/ Ensure that name and type are never null\n+        \/\/ Ensure that name is never null\n@@ -49,5 +46,0 @@\n-        getProperties().setProperty(\"type\", \"\");\n-    }\n-\n-    public void fireChangedEvent() {\n-        changedEvent.fire();\n@@ -70,2 +62,5 @@\n-    public List<FolderElement> getElements() {\n-        return Collections.unmodifiableList(elements);\n+    public void addElement(FolderElement element) {\n+        assert element instanceof InputGraph;\n+        graphs.add((InputGraph) element);\n+        element.setParent(this);\n+        getChangedEvent().fire();\n@@ -74,2 +69,6 @@\n-    public int getGraphsCount() {\n-        return elements.size();\n+    @Override\n+    public void removeElement(FolderElement element) {\n+        assert element instanceof InputGraph;\n+        if (graphs.remove((InputGraph) element)) {\n+            getChangedEvent().fire();\n+        }\n@@ -79,5 +78,3 @@\n-    public void addElement(FolderElement element) {\n-        elements.add(element);\n-        if (element instanceof InputGraph) {\n-            graphs.add((InputGraph) element);\n-        } else {\n+    public List<FolderElement> getElements() {\n+        return Collections.unmodifiableList(graphs);\n+    }\n@@ -85,3 +82,2 @@\n-        }\n-        element.setParent(this);\n-        changedEvent.fire();\n+    public List<InputGraph> getGraphs() {\n+        return Collections.unmodifiableList(graphs);\n@@ -92,5 +88,2 @@\n-        for (FolderElement e : elements) {\n-            if (e instanceof InputGraph) {\n-                InputGraph g = (InputGraph) e;\n-                result.addAll(g.getNodesAsSet());\n-            }\n+        for (InputGraph g : graphs) {\n+            result.addAll(g.getNodesAsSet());\n@@ -105,1 +98,1 @@\n-        for (FolderElement g : elements) {\n+        for (FolderElement g : getElements()) {\n@@ -124,1 +117,1 @@\n-        for (FolderElement e : elements) {\n+        for (FolderElement e : getElements()) {\n@@ -137,1 +130,1 @@\n-        for (FolderElement e : elements) {\n+        for (FolderElement e : getElements()) {\n@@ -147,10 +140,0 @@\n-    public InputGraph getLastGraph() {\n-        InputGraph lastGraph = null;\n-        for (FolderElement e : elements) {\n-            if (e instanceof InputGraph) {\n-                lastGraph = (InputGraph) e;\n-            }\n-        }\n-        return lastGraph;\n-    }\n-\n@@ -161,15 +144,0 @@\n-\n-    @Override\n-    public void removeElement(FolderElement element) {\n-        if (elements.remove(element)) {\n-            if (element instanceof InputGraph) {\n-                graphs.remove((InputGraph) element);\n-            }\n-            changedEvent.fire();\n-        }\n-    }\n-\n-    public List<InputGraph> getGraphs() {\n-        return graphs;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Group.java","additions":24,"deletions":56,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -35,3 +35,3 @@\n-    private String name;\n-    private InputGraph graph;\n-    private Set<InputBlock> successors;\n+    private final String name;\n+    private final InputGraph graph;\n+    private final Set<InputBlock> successors;\n@@ -52,1 +52,1 @@\n-        if (o == null || (!(o instanceof InputBlock))) {\n+        if ((!(o instanceof InputBlock))) {\n@@ -116,3 +116,1 @@\n-        if (!successors.contains(b)) {\n-            successors.add(b);\n-        }\n+        successors.add(b);\n@@ -121,2 +119,2 @@\n-    void setArtificial(boolean artificial) {\n-        this.artificial = artificial;\n+    void setArtificial() {\n+        this.artificial = true;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBlock.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-    private InputBlock from;\n-    private InputBlock to;\n+    private final InputBlock from;\n+    private final InputBlock to;\n@@ -41,1 +41,1 @@\n-    private String label;\n+    private final String label;\n@@ -73,1 +73,1 @@\n-        if (obj != null && obj instanceof InputBlockEdge) {\n+        if (obj instanceof InputBlockEdge) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBlockEdge.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,4 +32,4 @@\n-    private int bci;\n-    private String name;\n-    private String operands;\n-    private String comment;\n+    private final int bci;\n+    private final String name;\n+    private final String operands;\n+    private final String comment;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputBytecode.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n-import java.util.WeakHashMap;\n-import java.lang.ref.WeakReference;\n+import java.util.Objects;\n@@ -43,8 +42,3 @@\n-    public static final Comparator<InputEdge> OUTGOING_COMPARATOR = new Comparator<InputEdge>(){\n-\n-        @Override\n-            public int compare(InputEdge o1, InputEdge o2) {\n-                if(o1.getFromIndex() == o2.getFromIndex()) {\n-                    return o1.getTo() - o2.getTo();\n-                }\n-                return o1.getFromIndex() - o2.getFromIndex();\n+    public static final Comparator<InputEdge> OUTGOING_COMPARATOR = (o1, o2) -> {\n+            if (o1.getFromIndex() == o2.getFromIndex()) {\n+                return o1.getTo() - o2.getTo();\n@@ -52,3 +46,2 @@\n-    };\n-\n-    public static final Comparator<InputEdge> INGOING_COMPARATOR = new Comparator<InputEdge>(){\n+            return o1.getFromIndex() - o2.getFromIndex();\n+        };\n@@ -56,6 +49,3 @@\n-        @Override\n-            public int compare(InputEdge o1, InputEdge o2) {\n-                if(o1.getToIndex() == o2.getToIndex()) {\n-                    return o1.getFrom() - o2.getFrom();\n-                }\n-                return o1.getToIndex() - o2.getToIndex();\n+    public static final Comparator<InputEdge> INGOING_COMPARATOR = (o1, o2) -> {\n+            if (o1.getToIndex() == o2.getToIndex()) {\n+                return o1.getFrom() - o2.getFrom();\n@@ -63,1 +53,2 @@\n-    };\n+            return o1.getToIndex() - o2.getToIndex();\n+        };\n@@ -73,8 +64,0 @@\n-    public InputEdge(char toIndex, int from, int to) {\n-        this((char) 0, toIndex, from, to, null, null);\n-    }\n-\n-    public InputEdge(char fromIndex, char toIndex, int from, int to) {\n-        this(fromIndex, toIndex, from, to, null, null);\n-    }\n-\n@@ -91,25 +74,0 @@\n-    static WeakHashMap<InputEdge, WeakReference<InputEdge>> immutableCache = new WeakHashMap<>();\n-\n-    public static synchronized InputEdge createImmutable(char fromIndex, char toIndex, int from, int to, String label, String type) {\n-        InputEdge edge = new InputEdge(fromIndex, toIndex, from, to, label, type, State.IMMUTABLE);\n-        WeakReference<InputEdge> result = immutableCache.get(edge);\n-        if (result != null) {\n-            InputEdge edge2 = result.get();\n-            if (edge2 != null) {\n-                return edge2;\n-            }\n-        }\n-        immutableCache.put(edge, new WeakReference<>(edge));\n-        return edge;\n-    }\n-\n-    public InputEdge(char fromIndex, char toIndex, int from, int to, String label, String type, State state) {\n-        this.toIndex = toIndex;\n-        this.fromIndex = fromIndex;\n-        this.from = from;\n-        this.to = to;\n-        this.state = state;\n-        this.label = label;\n-        this.type = type;\n-    }\n-\n@@ -157,1 +115,1 @@\n-        if (o == null || !(o instanceof InputEdge)) {\n+        if (!(o instanceof InputEdge)) {\n@@ -164,1 +122,1 @@\n-            return conn2.label == label && conn2.state == state;\n+            return Objects.equals(conn2.label, label) && conn2.state == state;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputEdge.java","additions":14,"deletions":56,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    private Map<Integer, InputNode> nodes;\n-    private List<InputEdge> edges;\n+    private final Map<Integer, InputNode> nodes;\n+    private final List<InputEdge> edges;\n@@ -38,3 +38,3 @@\n-    private Map<String, InputBlock> blocks;\n-    private List<InputBlockEdge> blockEdges;\n-    private Map<Integer, InputBlock> nodeToBlock;\n+    private final Map<String, InputBlock> blocks;\n+    private final List<InputBlockEdge> blockEdges;\n+    private final Map<Integer, InputBlock> nodeToBlock;\n@@ -67,1 +67,1 @@\n-        return this.isDiffGraph;\n+        return isDiffGraph;\n@@ -117,1 +117,1 @@\n-            result.put(n, new ArrayList<InputEdge>());\n+            result.put(n, new ArrayList<>());\n@@ -178,10 +178,0 @@\n-    public void setEdge(int fromIndex, int toIndex, int from, int to) {\n-        assert fromIndex == ((char)fromIndex) : \"Downcast must be safe\";\n-        assert toIndex == ((char)toIndex) : \"Downcast must be safe\";\n-\n-        InputEdge edge = new InputEdge((char)fromIndex, (char)toIndex, from, to);\n-        if(!this.getEdges().contains(edge)) {\n-            this.addEdge(edge);\n-        }\n-    }\n-\n@@ -307,1 +297,1 @@\n-        b.setArtificial(true);\n+        b.setArtificial();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputGraph.java","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -38,4 +38,4 @@\n-    private String name;\n-    private int bci;\n-    private String shortName;\n-    private List<InputMethod> inlined;\n+    private final String name;\n+    private final int bci;\n+    private final String shortName;\n+    private final List<InputMethod> inlined;\n@@ -43,2 +43,2 @@\n-    private Group group;\n-    private List<InputBytecode> bytecodes;\n+    private final Group group;\n+    private final List<InputBytecode> bytecodes;\n@@ -58,1 +58,1 @@\n-        if (o == null || (!(o instanceof InputMethod))) {\n+        if ((!(o instanceof InputMethod))) {\n@@ -61,2 +61,1 @@\n-\n-        final InputMethod im = (InputMethod)o;\n+        final InputMethod im = (InputMethod) o;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputMethod.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.List;\n-\n@@ -37,31 +33,0 @@\n-    private List<InputGraph> subgraphs;\n-\n-    public static final Comparator<InputNode> COMPARATOR = new Comparator<InputNode>() {\n-        @Override\n-        public int compare(InputNode o1, InputNode o2) {\n-            return o1.getId() - o2.getId();\n-        }\n-    };\n-\n-    public static Comparator<InputNode> getPropertyComparator(final String propertyName) {\n-        return new Comparator<InputNode>() {\n-\n-            @Override\n-            public int compare(InputNode o1, InputNode o2) {\n-\n-                int i1 = 0;\n-                try {\n-                    i1 = Integer.parseInt(o1.getProperties().get(propertyName));\n-                } catch(NumberFormatException e) {\n-                }\n-\n-                int i2 = 0;\n-                try {\n-                    i2 = Integer.parseInt(o2.getProperties().get(propertyName));\n-                } catch(NumberFormatException e) {\n-                }\n-\n-                return i1 - i2;\n-            }\n-        };\n-    }\n@@ -86,11 +51,0 @@\n-    public void addSubgraph(InputGraph graph) {\n-        if (subgraphs == null) {\n-            subgraphs = new ArrayList<>();\n-        }\n-        subgraphs.add(graph);\n-    }\n-\n-    public List<InputGraph> getSubgraphs() {\n-        return subgraphs;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/InputNode.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        if (o == null || !(o instanceof Pair)) {\n+        if (!(o instanceof Pair<?, ?>)) {\n@@ -64,1 +64,1 @@\n-        Pair<?,?> obj = (Pair<?,?>) o;\n+        Pair<?, ?> obj = (Pair<?, ?>) o;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Pair.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.Map.Entry;\n@@ -191,1 +190,1 @@\n-        private PropertyMatcher matcher;\n+        private final PropertyMatcher matcher;\n@@ -213,2 +212,2 @@\n-        private String name;\n-        private String value;\n+        private final String name;\n+        private final String value;\n@@ -243,2 +242,2 @@\n-        private String name;\n-        private Pattern valuePattern;\n+        private final String name;\n+        private final Pattern valuePattern;\n@@ -315,7 +314,4 @@\n-        pairs.sort(new Comparator<String[]>() {\n-            @Override\n-            public int compare(String[] o1, String[] o2) {\n-                assert o1.length == 2;\n-                assert o2.length == 2;\n-                return o1[0].compareTo(o2[0]);\n-            }\n+        pairs.sort((o1, o2) -> {\n+            assert o1.length == 2;\n+            assert o2.length == 2;\n+            return o1[0].compareTo(o2[0]);\n@@ -340,1 +336,1 @@\n-        private Collection<T> objects;\n+        private final Collection<T> objects;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Properties.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    private String name;\n-    private String value;\n+    private final String name;\n+    private final String value;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Property.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    private List<InputNode> sourceNodes;\n-    private Set<Integer> set;\n+    private final List<InputNode> sourceNodes;\n+    private final Set<Integer> set;\n@@ -59,1 +59,1 @@\n-        public Source getSource();\n+        Source getSource();\n@@ -62,5 +62,0 @@\n-    public void addSourceNodes(Source s) {\n-        for (InputNode n : s.getSourceNodes()) {\n-            addSourceNode(n);\n-        }\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Source.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,937 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.hotspot.igv.data.serialization;\n-\n-import com.sun.hotspot.igv.data.*;\n-import com.sun.hotspot.igv.data.Properties;\n-import com.sun.hotspot.igv.data.services.GroupCallback;\n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.ReadableByteChannel;\n-import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import javax.swing.SwingUtilities;\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-public class BinaryParser implements GraphParser {\n-    private static final int BEGIN_GROUP = 0x00;\n-    private static final int BEGIN_GRAPH = 0x01;\n-    private static final int CLOSE_GROUP = 0x02;\n-\n-    private static final int POOL_NEW = 0x00;\n-    private static final int POOL_STRING = 0x01;\n-    private static final int POOL_ENUM = 0x02;\n-    private static final int POOL_CLASS = 0x03;\n-    private static final int POOL_METHOD = 0x04;\n-    private static final int POOL_NULL = 0x05;\n-    private static final int POOL_NODE_CLASS = 0x06;\n-    private static final int POOL_FIELD = 0x07;\n-    private static final int POOL_SIGNATURE = 0x08;\n-\n-    private static final int KLASS = 0x00;\n-    private static final int ENUM_KLASS = 0x01;\n-\n-    private static final int PROPERTY_POOL = 0x00;\n-    private static final int PROPERTY_INT = 0x01;\n-    private static final int PROPERTY_LONG = 0x02;\n-    private static final int PROPERTY_DOUBLE = 0x03;\n-    private static final int PROPERTY_FLOAT = 0x04;\n-    private static final int PROPERTY_TRUE = 0x05;\n-    private static final int PROPERTY_FALSE = 0x06;\n-    private static final int PROPERTY_ARRAY = 0x07;\n-    private static final int PROPERTY_SUBGRAPH = 0x08;\n-\n-    private static final String NO_BLOCK = \"noBlock\";\n-\n-    private final GroupCallback callback;\n-    private final List<Object> constantPool;\n-    private final ByteBuffer buffer;\n-    private final ReadableByteChannel channel;\n-    private final GraphDocument rootDocument;\n-    private final Deque<Folder> folderStack;\n-    private final Deque<byte[]> hashStack;\n-    private final ParseMonitor monitor;\n-\n-    private MessageDigest digest;\n-\n-    private enum Length {\n-        S,\n-        M,\n-        L\n-    }\n-\n-    private interface LengthToString {\n-        String toString(Length l);\n-    }\n-\n-    private abstract static class Member implements LengthToString {\n-        public final Klass holder;\n-        public final int accessFlags;\n-        public final String name;\n-        public Member(Klass holder, String name, int accessFlags) {\n-            this.holder = holder;\n-            this.accessFlags = accessFlags;\n-            this.name = name;\n-        }\n-    }\n-\n-    private static class Method extends Member {\n-        public final Signature signature;\n-        public final byte[] code;\n-        public Method(String name, Signature signature, byte[] code, Klass holder, int accessFlags) {\n-            super(holder, name, accessFlags);\n-            this.signature = signature;\n-            this.code = code;\n-        }\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(holder).append('.').append(name).append('(');\n-            for (int i = 0; i < signature.argTypes.length; i++) {\n-                if (i > 0) {\n-                    sb.append(\", \");\n-                }\n-                sb.append(signature.argTypes[i]);\n-            }\n-            sb.append(')');\n-            return sb.toString();\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case M:\n-                    return holder.toString(Length.L) + \".\" + name;\n-                case S:\n-                    return holder.toString(Length.S) + \".\" + name;\n-                default:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class Signature {\n-        public final String returnType;\n-        public final String[] argTypes;\n-        public Signature(String returnType, String[] argTypes) {\n-            this.returnType = returnType;\n-            this.argTypes = argTypes;\n-        }\n-    }\n-\n-    private static class Field extends Member {\n-        public final String type;\n-        public Field(String type, Klass holder, String name, int accessFlags) {\n-            super(holder, name, accessFlags);\n-            this.type = type;\n-        }\n-        @Override\n-        public String toString() {\n-            return holder + \".\" + name;\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case M:\n-                    return holder.toString(Length.L) + \".\" + name;\n-                case S:\n-                    return holder.toString(Length.S) + \".\" + name;\n-                default:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class Klass implements LengthToString {\n-        public final String name;\n-        public final String simpleName;\n-        public Klass(String name) {\n-            this.name = name;\n-            String simple;\n-            try {\n-                simple = name.substring(name.lastIndexOf('.') + 1);\n-            } catch (IndexOutOfBoundsException ioobe) {\n-                simple = name;\n-            }\n-            this.simpleName = simple;\n-        }\n-        @Override\n-        public String toString() {\n-            return name;\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case S:\n-                    return simpleName;\n-                default:\n-                case L:\n-                case M:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    private static class EnumKlass extends Klass {\n-        public final String[] values;\n-        public EnumKlass(String name, String[] values) {\n-            super(name);\n-            this.values = values;\n-        }\n-    }\n-\n-    private static class Port {\n-        public final boolean isList;\n-        public final String name;\n-        private Port(boolean isList, String name) {\n-            this.isList = isList;\n-            this.name = name;\n-        }\n-    }\n-\n-    private static class TypedPort extends Port {\n-        public final EnumValue type;\n-        private TypedPort(boolean isList, String name, EnumValue type) {\n-            super(isList, name);\n-            this.type = type;\n-        }\n-    }\n-\n-    private static class NodeClass {\n-        public final String className;\n-        public final String nameTemplate;\n-        public final List<TypedPort> inputs;\n-        public final List<Port> sux;\n-        private NodeClass(String className, String nameTemplate, List<TypedPort> inputs, List<Port> sux) {\n-            this.className = className;\n-            this.nameTemplate = nameTemplate;\n-            this.inputs = inputs;\n-            this.sux = sux;\n-        }\n-        @Override\n-        public String toString() {\n-            return className;\n-        }\n-    }\n-\n-    private static class EnumValue implements LengthToString {\n-        public EnumKlass enumKlass;\n-        public int ordinal;\n-        public EnumValue(EnumKlass enumKlass, int ordinal) {\n-            this.enumKlass = enumKlass;\n-            this.ordinal = ordinal;\n-        }\n-        @Override\n-        public String toString() {\n-            return enumKlass.simpleName + \".\" + enumKlass.values[ordinal];\n-        }\n-        @Override\n-        public String toString(Length l) {\n-            switch(l) {\n-                case S:\n-                    return enumKlass.values[ordinal];\n-                default:\n-                case M:\n-                case L:\n-                    return toString();\n-            }\n-        }\n-    }\n-\n-    public BinaryParser(ReadableByteChannel channel, ParseMonitor monitor, GraphDocument rootDocument, GroupCallback callback) {\n-        this.callback = callback;\n-        constantPool = new ArrayList<>();\n-        buffer = ByteBuffer.allocateDirect(256 * 1024);\n-        buffer.flip();\n-        this.channel = channel;\n-        this.rootDocument = rootDocument;\n-        folderStack = new LinkedList<>();\n-        hashStack = new LinkedList<>();\n-        this.monitor = monitor;\n-        try {\n-            this.digest = MessageDigest.getInstance(\"SHA-1\");\n-        } catch (NoSuchAlgorithmException e) {\n-        }\n-    }\n-\n-    private void fill() throws IOException {\n-        \/\/ All the data between lastPosition and position has been\n-        \/\/ used so add it to the digest.\n-        int position = buffer.position();\n-        buffer.position(lastPosition);\n-        byte[] remaining = new byte[position - buffer.position()];\n-        buffer.get(remaining);\n-        digest.update(remaining);\n-        assert position == buffer.position();\n-\n-        buffer.compact();\n-        if (channel.read(buffer) < 0) {\n-            throw new EOFException();\n-        }\n-        buffer.flip();\n-        lastPosition = buffer.position();\n-    }\n-\n-    private void ensureAvailable(int i) throws IOException {\n-        if (i > buffer.capacity()) {\n-            throw new IllegalArgumentException(String.format(\"Can not request %d bytes: buffer capacity is %d\", i, buffer.capacity()));\n-        }\n-        while (buffer.remaining() < i) {\n-            fill();\n-        }\n-    }\n-\n-    private int readByte() throws IOException {\n-        ensureAvailable(1);\n-        return ((int)buffer.get()) & 0xff;\n-    }\n-\n-    private int readInt() throws IOException {\n-        ensureAvailable(4);\n-        return buffer.getInt();\n-    }\n-\n-    private char readShort() throws IOException {\n-        ensureAvailable(2);\n-        return buffer.getChar();\n-    }\n-\n-    private long readLong() throws IOException {\n-        ensureAvailable(8);\n-        return buffer.getLong();\n-    }\n-\n-    private double readDouble() throws IOException {\n-        ensureAvailable(8);\n-        return buffer.getDouble();\n-    }\n-\n-    private float readFloat() throws IOException {\n-        ensureAvailable(4);\n-        return buffer.getFloat();\n-    }\n-\n-    private String readString() throws IOException {\n-        return new String(readBytes(), UTF_8).intern();\n-    }\n-\n-    private byte[] readBytes() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return null;\n-        }\n-        byte[] b = new byte[len];\n-        int bytesRead = 0;\n-        while (bytesRead < b.length) {\n-            int toRead = Math.min(b.length - bytesRead, buffer.capacity());\n-            ensureAvailable(toRead);\n-            buffer.get(b, bytesRead, toRead);\n-            bytesRead += toRead;\n-        }\n-        return b;\n-    }\n-\n-    private String readIntsToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        ensureAvailable(len * 4);\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(buffer.getInt());\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private String readDoublesToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        ensureAvailable(len * 8);\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(buffer.getDouble());\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private String readPoolObjectsToString() throws IOException {\n-        int len = readInt();\n-        if (len < 0) {\n-            return \"null\";\n-        }\n-        StringBuilder sb = new StringBuilder().append('[');\n-        for (int i = 0; i < len; i++) {\n-            sb.append(readPoolObject(Object.class));\n-            if (i < len - 1) {\n-                sb.append(\", \");\n-            }\n-        }\n-        sb.append(']');\n-        return sb.toString().intern();\n-    }\n-\n-    private <T> T readPoolObject(Class<T> klass) throws IOException {\n-        int type = readByte();\n-        if (type == POOL_NULL) {\n-            return null;\n-        }\n-        if (type == POOL_NEW) {\n-            return (T) addPoolEntry(klass);\n-        }\n-        assert assertObjectType(klass, type);\n-        char index = readShort();\n-        if (index < 0 || index >= constantPool.size()) {\n-            throw new IOException(\"Invalid constant pool index : \" + index);\n-        }\n-        Object obj = constantPool.get(index);\n-        return (T) obj;\n-    }\n-\n-    private boolean assertObjectType(Class<?> klass, int type) {\n-        switch(type) {\n-            case POOL_CLASS:\n-                return klass.isAssignableFrom(EnumKlass.class);\n-            case POOL_ENUM:\n-                return klass.isAssignableFrom(EnumValue.class);\n-            case POOL_METHOD:\n-                return klass.isAssignableFrom(Method.class);\n-            case POOL_STRING:\n-                return klass.isAssignableFrom(String.class);\n-            case POOL_NODE_CLASS:\n-                return klass.isAssignableFrom(NodeClass.class);\n-            case POOL_FIELD:\n-                return klass.isAssignableFrom(Field.class);\n-            case POOL_SIGNATURE:\n-                return klass.isAssignableFrom(Signature.class);\n-            case POOL_NULL:\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    private Object addPoolEntry(Class<?> klass) throws IOException {\n-        char index = readShort();\n-        int type = readByte();\n-        assert assertObjectType(klass, type) : \"Wrong object type : \" + klass + \" != \" + type;\n-        Object obj;\n-        switch(type) {\n-            case POOL_CLASS: {\n-                String name = readString();\n-                int klasstype = readByte();\n-                if (klasstype == ENUM_KLASS) {\n-                    int len = readInt();\n-                    String[] values = new String[len];\n-                    for (int i = 0; i < len; i++) {\n-                        values[i] = readPoolObject(String.class);\n-                    }\n-                    obj = new EnumKlass(name, values);\n-                } else if (klasstype == KLASS) {\n-                    obj = new Klass(name);\n-                } else {\n-                    throw new IOException(\"unknown klass type : \" + klasstype);\n-                }\n-                break;\n-            }\n-            case POOL_ENUM: {\n-                EnumKlass enumClass = readPoolObject(EnumKlass.class);\n-                int ordinal = readInt();\n-                obj = new EnumValue(enumClass, ordinal);\n-                break;\n-            }\n-            case POOL_NODE_CLASS: {\n-                String className = readString();\n-                String nameTemplate = readString();\n-                int inputCount = readShort();\n-                List<TypedPort> inputs = new ArrayList<>(inputCount);\n-                for (int i = 0; i < inputCount; i++) {\n-                    boolean isList = readByte() != 0;\n-                    String name = readPoolObject(String.class);\n-                    EnumValue inputType = readPoolObject(EnumValue.class);\n-                    inputs.add(new TypedPort(isList, name, inputType));\n-                }\n-                int suxCount = readShort();\n-                List<Port> sux = new ArrayList<>(suxCount);\n-                for (int i = 0; i < suxCount; i++) {\n-                    boolean isList = readByte() != 0;\n-                    String name = readPoolObject(String.class);\n-                    sux.add(new Port(isList, name));\n-                }\n-                obj = new NodeClass(className, nameTemplate, inputs, sux);\n-                break;\n-            }\n-            case POOL_METHOD: {\n-                Klass holder = readPoolObject(Klass.class);\n-                String name = readPoolObject(String.class);\n-                Signature sign = readPoolObject(Signature.class);\n-                int flags = readInt();\n-                byte[] code = readBytes();\n-                obj = new Method(name, sign, code, holder, flags);\n-                break;\n-            }\n-            case POOL_FIELD: {\n-                Klass holder = readPoolObject(Klass.class);\n-                String name = readPoolObject(String.class);\n-                String fType = readPoolObject(String.class);\n-                int flags = readInt();\n-                obj = new Field(fType, holder, name, flags);\n-                break;\n-            }\n-            case POOL_SIGNATURE: {\n-                int argc = readShort();\n-                String[] args = new String[argc];\n-                for (int i = 0; i < argc; i++) {\n-                    args[i] = readPoolObject(String.class);\n-                }\n-                String returnType = readPoolObject(String.class);\n-                obj = new Signature(returnType, args);\n-                break;\n-            }\n-            case POOL_STRING: {\n-                obj = readString();\n-                break;\n-            }\n-            default:\n-                throw new IOException(\"unknown pool type\");\n-        }\n-        while (constantPool.size() <= index) {\n-            constantPool.add(null);\n-        }\n-        constantPool.set(index, obj);\n-        return obj;\n-    }\n-\n-    private Object readPropertyObject() throws IOException {\n-        int type = readByte();\n-        switch (type) {\n-            case PROPERTY_INT:\n-                return readInt();\n-            case PROPERTY_LONG:\n-                return readLong();\n-            case PROPERTY_FLOAT:\n-                return readFloat();\n-            case PROPERTY_DOUBLE:\n-                return readDouble();\n-            case PROPERTY_TRUE:\n-                return Boolean.TRUE;\n-            case PROPERTY_FALSE:\n-                return Boolean.FALSE;\n-            case PROPERTY_POOL:\n-                return readPoolObject(Object.class);\n-            case PROPERTY_ARRAY:\n-                int subType = readByte();\n-                switch(subType) {\n-                    case PROPERTY_INT:\n-                        return readIntsToString();\n-                    case PROPERTY_DOUBLE:\n-                        return readDoublesToString();\n-                    case PROPERTY_POOL:\n-                        return readPoolObjectsToString();\n-                    default:\n-                        throw new IOException(\"Unknown type\");\n-                }\n-            case PROPERTY_SUBGRAPH:\n-                InputGraph graph = parseGraph(\"\");\n-                new Group(null).addElement(graph);\n-                return graph;\n-            default:\n-                throw new IOException(\"Unknown type\");\n-        }\n-    }\n-\n-    @Override\n-    public GraphDocument parse() throws IOException {\n-        folderStack.push(rootDocument);\n-        hashStack.push(null);\n-        if (monitor != null) {\n-            monitor.setState(\"Starting parsing\");\n-        }\n-        try {\n-            while(true) {\n-                parseRoot();\n-            }\n-        } catch (EOFException e) {\n-\n-        }\n-        if (monitor != null) {\n-            monitor.setState(\"Finished parsing\");\n-        }\n-        return rootDocument;\n-    }\n-\n-    private void parseRoot() throws IOException {\n-        int type = readByte();\n-        switch(type) {\n-            case BEGIN_GRAPH: {\n-                final Folder parent = folderStack.peek();\n-                final InputGraph graph = parseGraph();\n-                SwingUtilities.invokeLater(new Runnable(){\n-                    @Override\n-                    public void run() {\n-                        parent.addElement(graph);\n-                    }\n-                });\n-                break;\n-            }\n-            case BEGIN_GROUP: {\n-                final Folder parent = folderStack.peek();\n-                final Group group = parseGroup(parent);\n-                if (callback == null || parent instanceof Group) {\n-                    SwingUtilities.invokeLater(new Runnable(){\n-                        @Override\n-                        public void run() {\n-                            parent.addElement(group);\n-                        }\n-                    });\n-                }\n-                folderStack.push(group);\n-                hashStack.push(null);\n-                if (callback != null && parent instanceof GraphDocument) {\n-                    callback.started(group);\n-                }\n-                break;\n-            }\n-            case CLOSE_GROUP: {\n-                if (folderStack.isEmpty()) {\n-                    throw new IOException(\"Unbalanced groups\");\n-                }\n-                folderStack.pop();\n-                hashStack.pop();\n-                break;\n-            }\n-            default:\n-                throw new IOException(\"unknown root : \" + type);\n-        }\n-    }\n-\n-    private Group parseGroup(Folder parent) throws IOException {\n-        String name = readPoolObject(String.class);\n-        String shortName = readPoolObject(String.class);\n-        if (monitor != null) {\n-            monitor.setState(shortName);\n-        }\n-        Method method = readPoolObject(Method.class);\n-        int bci = readInt();\n-        Group group = new Group(parent);\n-        group.getProperties().setProperty(\"name\", name);\n-        parseProperties(group.getProperties());\n-        if (method != null) {\n-            InputMethod inMethod = new InputMethod(group, method.name, shortName, bci);\n-            inMethod.setBytecodes(\"TODO\");\n-            group.setMethod(inMethod);\n-        }\n-        return group;\n-    }\n-\n-    int lastPosition = 0;\n-\n-    private InputGraph parseGraph() throws IOException {\n-        if (monitor != null) {\n-            monitor.updateProgress();\n-        }\n-        String title = readPoolObject(String.class);\n-        digest.reset();\n-        lastPosition = buffer.position();\n-        InputGraph graph = parseGraph(title);\n-\n-        int position = buffer.position();\n-        buffer.position(lastPosition);\n-        byte[] remaining = new byte[position - buffer.position()];\n-        buffer.get(remaining);\n-        digest.update(remaining);\n-        assert position == buffer.position();\n-        lastPosition = buffer.position();\n-\n-        byte[] d = digest.digest();\n-        byte[] hash = hashStack.peek();\n-        if (hash != null && Arrays.equals(hash, d)) {\n-            graph.getProperties().setProperty(\"_isDuplicate\", \"true\");\n-        } else {\n-            hashStack.pop();\n-            hashStack.push(d);\n-        }\n-        return graph;\n-    }\n-\n-    private void parseProperties(Properties properties) throws IOException {\n-        int propCount = readShort();\n-        for (int j = 0; j < propCount; j++) {\n-            String key = readPoolObject(String.class);\n-            Object value = readPropertyObject();\n-            properties.setProperty(key, value != null ? value.toString() : \"null\");\n-        }\n-    }\n-\n-    private InputGraph parseGraph(String title) throws IOException {\n-        InputGraph graph = new InputGraph(title);\n-        parseProperties(graph.getProperties());\n-        parseNodes(graph);\n-        parseBlocks(graph);\n-        graph.ensureNodesInBlocks();\n-        for (InputNode node : graph.getNodes()) {\n-            node.internProperties();\n-        }\n-        return graph;\n-    }\n-\n-    private void parseBlocks(InputGraph graph) throws IOException {\n-        int blockCount = readInt();\n-        List<Edge> edges = new LinkedList<>();\n-        for (int i = 0; i < blockCount; i++) {\n-            int id = readInt();\n-            String name = id >= 0 ? Integer.toString(id) : NO_BLOCK;\n-            InputBlock block = graph.addBlock(name);\n-            int nodeCount = readInt();\n-            for (int j = 0; j < nodeCount; j++) {\n-                int nodeId = readInt();\n-                if (nodeId < 0) {\n-                    continue;\n-                }\n-                final Properties properties = graph.getNode(nodeId).getProperties();\n-                final String oldBlock = properties.get(\"block\");\n-                if(oldBlock != null) {\n-                    properties.setProperty(\"block\", oldBlock + \", \" + name);\n-                } else {\n-                    block.addNode(nodeId);\n-                    properties.setProperty(\"block\", name);\n-                }\n-            }\n-            int edgeCount = readInt();\n-            for (int j = 0; j < edgeCount; j++) {\n-                int to = readInt();\n-                edges.add(new Edge(id, to));\n-            }\n-        }\n-        for (Edge e : edges) {\n-            String fromName = e.from >= 0 ? Integer.toString(e.from) : NO_BLOCK;\n-            String toName = e.to >= 0 ? Integer.toString(e.to) : NO_BLOCK;\n-            graph.addBlockEdge(graph.getBlock(fromName), graph.getBlock(toName));\n-        }\n-    }\n-\n-    private void parseNodes(InputGraph graph) throws IOException {\n-        int count = readInt();\n-        Map<String, Object> props = new HashMap<>();\n-        List<Edge> inputEdges = new ArrayList<>(count);\n-        List<Edge> succEdges = new ArrayList<>(count);\n-        for (int i = 0; i < count; i++) {\n-            int id = readInt();\n-            InputNode node = new InputNode(id);\n-            final Properties properties = node.getProperties();\n-            NodeClass nodeClass = readPoolObject(NodeClass.class);\n-            int preds = readByte();\n-            if (preds > 0) {\n-                properties.setProperty(\"hasPredecessor\", \"true\");\n-            }\n-            properties.setProperty(\"idx\", Integer.toString(id));\n-            int propCount = readShort();\n-            for (int j = 0; j < propCount; j++) {\n-                String key = readPoolObject(String.class);\n-                if (key.equals(\"hasPredecessor\") || key.equals(\"name\") || key.equals(\"class\") || key.equals(\"id\") || key.equals(\"idx\")) {\n-                    key = \"!data.\" + key;\n-                }\n-                Object value = readPropertyObject();\n-                if (value instanceof InputGraph) {\n-                    InputGraph subgraph = (InputGraph) value;\n-                    subgraph.getProperties().setProperty(\"name\", node.getId() + \":\" + key);\n-                    node.addSubgraph((InputGraph) value);\n-                } else {\n-                    properties.setProperty(key, value != null ? value.toString() : \"null\");\n-                    props.put(key, value);\n-                }\n-            }\n-            ArrayList<Edge> currentEdges = new ArrayList<>();\n-            int portNum = 0;\n-            for (TypedPort p : nodeClass.inputs) {\n-                if (p.isList) {\n-                    int size = readShort();\n-                    for (int j = 0; j < size; j++) {\n-                        int in = readInt();\n-                        if (in >= 0) {\n-                            Edge e = new Edge(in, id, (char) (preds + portNum), p.name + \"[\" + j + \"]\", p.type.toString(Length.S), true);\n-                            currentEdges.add(e);\n-                            inputEdges.add(e);\n-                            portNum++;\n-                        }\n-                    }\n-                } else {\n-                    int in = readInt();\n-                    if (in >= 0) {\n-                        Edge e = new Edge(in, id, (char) (preds + portNum), p.name, p.type.toString(Length.S), true);\n-                        currentEdges.add(e);\n-                        inputEdges.add(e);\n-                        portNum++;\n-                    }\n-                }\n-\n-            }\n-            portNum = 0;\n-            for (Port p : nodeClass.sux) {\n-                if (p.isList) {\n-                    int size = readShort();\n-                    for (int j = 0; j < size; j++) {\n-                        int sux = readInt();\n-                        if (sux >= 0) {\n-                            Edge e = new Edge(id, sux, (char) portNum, p.name + \"[\" + j + \"]\", \"Successor\", false);\n-                            currentEdges.add(e);\n-                            succEdges.add(e);\n-                            portNum++;\n-                        }\n-                    }\n-                } else {\n-                    int sux = readInt();\n-                    if (sux >= 0) {\n-                        Edge e = new Edge(id, sux, (char) portNum, p.name, \"Successor\", false);\n-                        currentEdges.add(e);\n-                        succEdges.add(e);\n-                        portNum++;\n-                    }\n-                }\n-            }\n-            properties.setProperty(\"name\", createName(currentEdges, props, nodeClass.nameTemplate));\n-            properties.setProperty(\"class\", nodeClass.className);\n-            switch (nodeClass.className) {\n-                case \"BeginNode\":\n-                    properties.setProperty(\"shortName\", \"B\");\n-                    break;\n-                case \"EndNode\":\n-                    properties.setProperty(\"shortName\", \"E\");\n-                    break;\n-            }\n-            graph.addNode(node);\n-            props.clear();\n-        }\n-\n-        Set<InputNode> nodesWithSuccessor = new HashSet<>();\n-\n-        for (Edge e : succEdges) {\n-            assert !e.input;\n-            char fromIndex = e.num;\n-            nodesWithSuccessor.add(graph.getNode(e.from));\n-            char toIndex = 0;\n-            graph.addEdge(InputEdge.createImmutable(fromIndex, toIndex, e.from, e.to, e.label, e.type));\n-        }\n-        for (Edge e : inputEdges) {\n-            assert e.input;\n-            char fromIndex = (char) (nodesWithSuccessor.contains(graph.getNode(e.from)) ? 1 : 0);\n-            char toIndex = e.num;\n-            graph.addEdge(InputEdge.createImmutable(fromIndex, toIndex, e.from, e.to, e.label, e.type));\n-        }\n-    }\n-\n-    static final Pattern templatePattern = Pattern.compile(\"\\\\{(p|i)#([a-zA-Z0-9$_]+)(\/(l|m|s))?\\\\}\");\n-\n-    private String createName(List<Edge> edges, Map<String, Object> properties, String template) {\n-        Matcher m = templatePattern.matcher(template);\n-        StringBuffer sb = new StringBuffer();\n-        while (m.find()) {\n-            String name = m.group(2);\n-            String type = m.group(1);\n-            String result;\n-            switch (type) {\n-                case \"i\":\n-                    StringBuilder inputString = new StringBuilder();\n-                    for(Edge edge : edges) {\n-                        if (edge.label.startsWith(name) && (name.length() == edge.label.length() || edge.label.charAt(name.length()) == '[')) {\n-                            if (inputString.length() > 0) {\n-                                inputString.append(\", \");\n-                            }\n-                            inputString.append(edge.from);\n-                        }\n-                    }\n-                    result = inputString.toString();\n-                    break;\n-                case \"p\":\n-                    Object prop = properties.get(name);\n-                    String length = m.group(4);\n-                    if (prop == null) {\n-                        result = \"?\";\n-                    } else if (length != null && prop instanceof LengthToString) {\n-                        LengthToString lengthProp = (LengthToString) prop;\n-                        switch(length) {\n-                            default:\n-                            case \"l\":\n-                                result = lengthProp.toString(Length.L);\n-                                break;\n-                            case \"m\":\n-                                result = lengthProp.toString(Length.M);\n-                                break;\n-                            case \"s\":\n-                                result = lengthProp.toString(Length.S);\n-                                break;\n-                        }\n-                    } else {\n-                        result = prop.toString();\n-                    }\n-                    break;\n-                default:\n-                    result = \"#?#\";\n-                    break;\n-            }\n-            result = result.replace(\"\\\\\", \"\\\\\\\\\");\n-            result = result.replace(\"$\", \"\\\\$\");\n-            m.appendReplacement(sb, result);\n-        }\n-        m.appendTail(sb);\n-        return sb.toString().intern();\n-    }\n-\n-    private static class Edge {\n-        final int from;\n-        final int to;\n-        final char num;\n-        final String label;\n-        final String type;\n-        final boolean input;\n-        public Edge(int from, int to) {\n-            this(from, to, (char) 0, null, null, false);\n-        }\n-        public Edge(int from, int to, char num, String label, String type, boolean input) {\n-            this.from = from;\n-            this.to = to;\n-            this.label = label != null ? label.intern() : label;\n-            this.type = type != null ? type.intern() : type;\n-            this.num = num;\n-            this.input = input;\n-        }\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/BinaryParser.java","additions":0,"deletions":937,"binary":false,"changes":937,"status":"deleted"},{"patch":"@@ -31,1 +31,1 @@\n-    public GraphDocument parse() throws IOException;\n+    GraphDocument parse() throws IOException;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/GraphParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    public void updateProgress();\n+    void updateProgress();\n@@ -31,1 +31,1 @@\n-    public void setState(String state);\n+    void setState(String state);\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/ParseMonitor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.io.InputStream;\n@@ -42,3 +41,0 @@\n-import javax.xml.transform.Source;\n-import javax.xml.transform.stream.StreamSource;\n-import javax.xml.validation.SchemaFactory;\n@@ -98,6 +94,6 @@\n-    private TopElementHandler<GraphDocument> xmlDocument = new TopElementHandler<>();\n-    private Map<Group, Boolean> differenceEncoding = new HashMap<>();\n-    private Map<Group, InputGraph> lastParsedGraph = new HashMap<>();\n-    private GroupCallback groupCallback;\n-    private HashMap<String, Integer> idCache = new HashMap<>();\n-    private ArrayList<Pair<String, String>> blockConnections = new ArrayList<>();\n+    private final TopElementHandler<GraphDocument> xmlDocument = new TopElementHandler<>();\n+    private final Map<Group, Boolean> differenceEncoding = new HashMap<>();\n+    private final Map<Group, InputGraph> lastParsedGraph = new HashMap<>();\n+    private final GroupCallback groupCallback;\n+    private final HashMap<String, Integer> idCache = new HashMap<>();\n+    private final ArrayList<Pair<String, String>> blockConnections = new ArrayList<>();\n@@ -121,1 +117,1 @@\n-        return id.intValue();\n+        return id;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Parser.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    private InputStream in;\n+    private final InputStream in;\n@@ -55,2 +55,1 @@\n-        } catch (IOException ex) {\n-        }\n+        } catch (IOException ignored) {}\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Printer.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.Properties;\n@@ -42,2 +41,0 @@\n-        private String name;\n-\n@@ -46,1 +43,0 @@\n-            this.name = name;\n@@ -49,3 +45,0 @@\n-        public String getAttributeName() {\n-            return this.getMessage();\n-        }\n@@ -79,2 +72,2 @@\n-        private String name;\n-        private Stack<T> object = new Stack<>();\n+        private final String name;\n+        private final Stack<T> object = new Stack<>();\n@@ -84,4 +77,4 @@\n-        private HashMap<String, ElementHandler<?, ? super T>> hashtable;\n-        private boolean needsText;\n-        private Stack<ElementHandler<P, ?>> parentElement = new Stack<>();\n-        private Stack<P> parentObject = new Stack<>();\n+        private final HashMap<String, ElementHandler<?, ? super T>> hashtable;\n+        private final boolean needsText;\n+        private final Stack<ElementHandler<P, ?>> parentElement = new Stack<>();\n+        private final Stack<P> parentObject = new Stack<>();\n@@ -93,4 +86,0 @@\n-        public ElementHandler<P, ?> getParentElement() {\n-            return parentElement.peek();\n-        }\n-\n@@ -144,9 +133,0 @@\n-        public void processAttributesAsProperties(Properties p) {\n-            int length = attr.getLength();\n-            for (int i = 0; i < length; i++) {\n-                String val = attr.getValue(i);\n-                String localName = attr.getLocalName(i);\n-                p.setProperty(val, localName);\n-            }\n-        }\n-\n@@ -182,2 +162,2 @@\n-    private Stack<ElementHandler> stack;\n-    private ParseMonitor monitor;\n+    private final Stack<ElementHandler> stack;\n+    private final ParseMonitor monitor;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/XMLParser.java","additions":8,"deletions":28,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-    private Writer inner;\n-    private Stack<String> elementStack;\n+    private final Writer inner;\n+    private final Stack<String> elementStack;\n@@ -117,1 +117,1 @@\n-        if (props.iterator().hasNext() == false) {\n+        if (!props.iterator().hasNext()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/XMLWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -29,0 +28,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/ChangedEventTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static org.junit.Assert.*;\n@@ -29,0 +28,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/ControllableChangedListenerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/GroupTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertThat;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertThat;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/InputMethodTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static org.junit.Assert.*;\n@@ -30,0 +29,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PairTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import com.sun.hotspot.igv.data.Properties.InvertPropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.PropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.PropertySelector;\n-import com.sun.hotspot.igv.data.Properties.RegexpPropertyMatcher;\n-import com.sun.hotspot.igv.data.Properties.StringPropertyMatcher;\n+import com.sun.hotspot.igv.data.Properties.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PropertiesTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static org.junit.Assert.*;\n@@ -30,0 +29,1 @@\n+import static org.junit.Assert.*;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/PropertyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -31,0 +30,1 @@\n+import static org.junit.Assert.assertEquals;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/SourceTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,10 +36,0 @@\n-    public static void assertGraphDocumentNotEquals(GraphDocument a, GraphDocument b) {\n-        try {\n-            assertGraphDocumentEquals(a, b);\n-        } catch(AssertionError e) {\n-            return;\n-        }\n-\n-        fail(\"Graphs documents are equal!\");\n-    }\n-\n@@ -64,10 +54,0 @@\n-    public static void assertGroupNotEquals(Group a, Group b) {\n-        try {\n-            assertGroupEquals(a, b);\n-        } catch(AssertionError e) {\n-            return;\n-        }\n-\n-        fail(\"Groups are equal!\");\n-    }\n-\n@@ -76,1 +56,1 @@\n-        if (a.getGraphsCount() != b.getGraphsCount()) {\n+        if (a.getElements().size() != b.getElements().size()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/Util.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,1 +29,4 @@\n-import java.io.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.CharArrayWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n@@ -31,1 +34,0 @@\n-\n@@ -33,0 +35,1 @@\n+import org.junit.*;\n@@ -35,3 +38,0 @@\n-import org.junit.*;\n-import org.openide.util.Exceptions;\n-import org.xml.sax.InputSource;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/ParserTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -290,3 +290,0 @@\n-\n-        Set<InputNode> matched = new HashSet<>();\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Difference\/src\/main\/java\/com\/sun\/hotspot\/igv\/difference\/Difference.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        changedEvent = new ChangedEvent<Filter>(this);\n+        changedEvent = new ChangedEvent<>(this);\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/AbstractFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.hotspot.igv.graph.Connection.ConnectionStyle;\n@@ -29,0 +28,1 @@\n+import com.sun.hotspot.igv.graph.Connection.ConnectionStyle;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/ColorFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-                        slot.getSource().addSourceNodes(f.getSource());\n+                        slot.getSource().addSourceNode(f.getInputNode());\n@@ -133,1 +133,1 @@\n-                                slot.getSource().addSourceNodes(succ.getSource());\n+                                slot.getSource().addSourceNode(succ.getInputNode());\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/CombineFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-import javax.script.*;\n+import javax.script.Bindings;\n+import javax.script.ScriptContext;\n+import javax.script.ScriptEngine;\n+import javax.script.ScriptException;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/CustomFilter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.graph.Diagram;\n@@ -29,0 +28,1 @@\n+import com.sun.hotspot.igv.graph.Diagram;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/RemoveBlockFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,3 +59,3 @@\n-                    if (f.getSource().getSourceNodes().size() > 0) {\n-                        os.getSource().addSourceNodes(f.getSource());\n-                        os.setAssociatedNode(f.getSource().getSourceNodes().get(0));\n+                    if (f.getInputNode() != null) {\n+                        os.getSource().addSourceNode(f.getInputNode());\n+                        os.setAssociatedNode(f.getInputNode());\n@@ -76,3 +76,3 @@\n-                    if (f.getSource().getSourceNodes().size() > 0) {\n-                        is.getSource().addSourceNodes(f.getSource());\n-                        is.setAssociatedNode(f.getSource().getSourceNodes().get(0));\n+                    if (f.getInputNode() != null) {\n+                        is.getSource().addSourceNode(f.getInputNode());\n+                        is.setAssociatedNode(f.getInputNode());\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/SplitFilter.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n-import com.sun.hotspot.igv.graph.*;\n+import com.sun.hotspot.igv.graph.Diagram;\n+import com.sun.hotspot.igv.graph.Figure;\n+import com.sun.hotspot.igv.graph.Selector;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/WarningFilter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,7 +63,1 @@\n-        filter.getChangedEvent().addListener(new ChangedListener<Filter>() {\n-\n-            @Override\n-            public void changed(Filter source) {\n-                update();\n-            }\n-        });\n+        filter.getChangedEvent().addListener(source -> update());\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/java\/com\/sun\/hotspot\/igv\/filterwindow\/FilterNode.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -187,7 +187,1 @@\n-            filterSettings.sort(new Comparator<FilterSetting>() {\n-\n-                @Override\n-                public int compare(FilterSetting o1, FilterSetting o2) {\n-                    return o1.getName().compareTo(o2.getName());\n-                }\n-            });\n+            filterSettings.sort(Comparator.comparing(FilterSetting::getName));\n@@ -271,7 +265,1 @@\n-            sequence.getChangedEvent().addListener(new ChangedListener<FilterChain>() {\n-\n-                @Override\n-                public void changed(FilterChain source) {\n-                    addNotify();\n-                }\n-            });\n+            sequence.getChangedEvent().addListener(source -> addNotify());\n@@ -709,9 +697,0 @@\n-\n-    static final class ResolvableHelper implements Serializable {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        public Object readResolve() {\n-            return FilterTopComponent.getDefault();\n-        }\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/java\/com\/sun\/hotspot\/igv\/filterwindow\/FilterTopComponent.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-    \n+\n@@ -31,0 +31,1 @@\n+                <attr name=\"position\" intvalue=\"3\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/FilterWindow\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filterwindow\/layer.xml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.util.List;\n@@ -28,0 +27,1 @@\n+import java.util.List;\n@@ -42,1 +42,1 @@\n-            l.add(d.getBlock(f.getBlock()));\n+            l.add(f.getBlock());\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/AnySelector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.awt.Dimension;\n@@ -29,0 +28,1 @@\n+import java.awt.Dimension;\n@@ -48,4 +48,0 @@\n-    public Cluster getOuter() {\n-        return null;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Block.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,5 +26,1 @@\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.data.InputBlockEdge;\n-import com.sun.hotspot.igv.data.InputEdge;\n-import com.sun.hotspot.igv.data.InputGraph;\n-import com.sun.hotspot.igv.data.InputNode;\n+import com.sun.hotspot.igv.data.*;\n@@ -32,1 +28,0 @@\n-import com.sun.hotspot.igv.data.Properties.StringPropertyMatcher;\n@@ -34,1 +29,0 @@\n-import java.awt.Color;\n@@ -44,9 +38,8 @@\n-    private Map<InputBlock, Block> blocks;\n-    private InputGraph graph;\n-    private int curId;\n-    private String nodeText;\n-    private String shortNodeText;\n-    private String tinyNodeText;\n-    private final Font font;\n-    private final Font slotFont;\n-    private final Font boldFont;\n+    private final Map<InputBlock, Block> blocks;\n+    private final String nodeText;\n+    private final String shortNodeText;\n+    private final String tinyNodeText;\n+    public static final Font FONT = new Font(\"Arial\", Font.PLAIN, 12);\n+    public static final Font SLOT_FONT = new Font(\"Arial\", Font.PLAIN, 10);\n+    public static final Font BOLD_FONT = FONT.deriveFont(Font.BOLD);\n+\n@@ -58,12 +51,0 @@\n-    public Font getFont() {\n-        return font;\n-    }\n-\n-    public Font getSlotFont() {\n-        return slotFont;\n-    }\n-\n-    public Font getBoldFont() {\n-        return boldFont;\n-    }\n-\n@@ -78,12 +59,4 @@\n-    private Diagram(InputGraph graph, String nodeText, String shortNodeText,\n-                    String tinyNodeText) {\n-        figures = new ArrayList<>();\n-        blocks = new LinkedHashMap<>(8);\n-        this.nodeText = \"\";\n-        this.shortNodeText = \"\";\n-        this.font = new Font(\"Arial\", Font.PLAIN, 12);\n-        this.slotFont = new Font(\"Arial\", Font.PLAIN, 10);\n-        this.boldFont = this.font.deriveFont(Font.BOLD);\n-        this.cfg = false;\n-        this.blockConnections = new HashSet<>();\n-        this.graph = graph;\n+    public Diagram(InputGraph graph, String nodeText, String shortNodeText,\n+                   String tinyNodeText) {\n+        assert graph != null;\n+\n@@ -93,22 +66,5 @@\n-    }\n-\n-    public Block getBlock(InputBlock b) {\n-        assert blocks.containsKey(b);\n-        return blocks.get(b);\n-    }\n-\n-    public boolean hasBlock(InputBlock b) {\n-        return blocks.containsKey(b);\n-    }\n-\n-    public String getNodeText() {\n-        return nodeText;\n-    }\n-\n-    public String getShortNodeText() {\n-        return shortNodeText;\n-    }\n-\n-    public String getTinyNodeText() {\n-        return tinyNodeText;\n-    }\n+        this.figures = new ArrayList<>();\n+        this.blocks = new LinkedHashMap<>(8);\n+        this.blockConnections = new HashSet<>();\n+        this.cfg = false;\n+        int curId = 0;\n@@ -116,2 +72,0 @@\n-    public void updateBlocks() {\n-        blocks.clear();\n@@ -119,37 +73,1 @@\n-            Block curBlock = new Block(b, this);\n-            blocks.put(b, curBlock);\n-        }\n-    }\n-\n-    public Collection<Block> getBlocks() {\n-        return Collections.unmodifiableCollection(blocks.values());\n-    }\n-\n-    public List<Figure> getFigures() {\n-        return Collections.unmodifiableList(figures);\n-    }\n-\n-    public Figure createFigure() {\n-        Figure f = new Figure(this, curId);\n-        curId++;\n-        this.figures.add(f);\n-        return f;\n-    }\n-\n-    public FigureConnection createConnection(InputSlot inputSlot, OutputSlot outputSlot, String label) {\n-        assert inputSlot.getFigure().getDiagram() == this;\n-        assert outputSlot.getFigure().getDiagram() == this;\n-        return new FigureConnection(inputSlot, outputSlot, label);\n-    }\n-\n-    public Map<InputNode, Set<Figure>> calcSourceToFigureRelation() {\n-        Map<InputNode, Set<Figure>> map = new HashMap<>();\n-\n-        for(InputNode node : this.getGraph().getNodes()) {\n-            map.put(node, new HashSet<Figure>());\n-        }\n-\n-        for(Figure f : this.getFigures()) {\n-            for(InputNode node : f.getSource().getSourceNodes()) {\n-                map.get(node).add(f);\n-            }\n+            blocks.put(b, new Block(b, this));\n@@ -158,13 +76,0 @@\n-        return map;\n-    }\n-\n-    public static Diagram createDiagram(InputGraph graph, String nodeText,\n-                                        String shortNodeText,\n-                                        String tinyNodeText) {\n-        if (graph == null) {\n-            return null;\n-        }\n-\n-        Diagram d = new Diagram(graph, nodeText, shortNodeText, tinyNodeText);\n-        d.updateBlocks();\n-\n@@ -174,2 +79,2 @@\n-            Figure f = d.createFigure();\n-            f.getSource().addSourceNode(n);\n+            Figure f = new Figure(this, curId, n);\n+            curId++;\n@@ -177,2 +82,1 @@\n-            f.setSubgraphs(n.getSubgraphs());\n-            f.setBlock(graph.getBlock(n));\n+            f.setBlock(blocks.get(graph.getBlock(n)));\n@@ -180,0 +84,1 @@\n+            this.figures.add(f);\n@@ -183,1 +88,0 @@\n-\n@@ -190,1 +94,0 @@\n-            assert fromFigure != null && toFigure != null;\n@@ -204,1 +107,1 @@\n-            FigureConnection c = d.createConnection(inputSlot, outputSlot, e.getLabel());\n+            FigureConnection c = createConnection(inputSlot, outputSlot, e.getLabel());\n@@ -214,3 +117,3 @@\n-            Block p = d.getBlock(e.getFrom());\n-            Block s = d.getBlock(e.getTo());\n-            d.blockConnections.add(new BlockConnection(p, s, e.getLabel()));\n+            Block p = getBlock(e.getFrom());\n+            Block s = getBlock(e.getTo());\n+            blockConnections.add(new BlockConnection(p, s, e.getLabel()));\n@@ -218,0 +121,1 @@\n+    }\n@@ -219,1 +123,37 @@\n-        return d;\n+    public Block getBlock(InputBlock b) {\n+        assert blocks.containsKey(b);\n+        return blocks.get(b);\n+    }\n+\n+    public boolean hasBlock(InputBlock b) {\n+        return blocks.containsKey(b);\n+    }\n+\n+    public String getNodeText() {\n+        return nodeText;\n+    }\n+\n+    public String getShortNodeText() {\n+        return shortNodeText;\n+    }\n+\n+    public String getTinyNodeText() {\n+        return tinyNodeText;\n+    }\n+\n+    public Collection<Block> getBlocks() {\n+        return Collections.unmodifiableCollection(blocks.values());\n+    }\n+\n+    public Collection<InputBlock> getInputBlocks() {\n+        return Collections.unmodifiableCollection(blocks.keySet());\n+    }\n+\n+    public List<Figure> getFigures() {\n+        return Collections.unmodifiableList(figures);\n+    }\n+\n+    public FigureConnection createConnection(InputSlot inputSlot, OutputSlot outputSlot, String label) {\n+        assert inputSlot.getFigure().getDiagram() == this;\n+        assert outputSlot.getFigure().getDiagram() == this;\n+        return new FigureConnection(inputSlot, outputSlot, label);\n@@ -226,1 +166,1 @@\n-                if (f.getBlock() == b.getInputBlock()) {\n+                if (f.getBlock() == b) {\n@@ -276,8 +216,0 @@\n-    public String getName() {\n-        return graph.getName();\n-    }\n-\n-    public InputGraph getGraph() {\n-        return graph;\n-    }\n-\n@@ -305,18 +237,0 @@\n-    public Figure getRootFigure() {\n-        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(figures);\n-        Figure root = selector.selectSingle(new StringPropertyMatcher(\"name\", \"Root\"));\n-        if (root == null) {\n-            root = selector.selectSingle(new StringPropertyMatcher(\"name\", \"Start\"));\n-        }\n-        if (root == null) {\n-            List<Figure> rootFigures = getRootFigures();\n-            if (rootFigures.size() > 0) {\n-                root = rootFigures.get(0);\n-            } else if (figures.size() > 0) {\n-                root = figures.get(0);\n-            }\n-        }\n-\n-        return root;\n-    }\n-\n@@ -357,10 +271,0 @@\n-\n-    public List<Figure> getRootFigures() {\n-        ArrayList<Figure> rootFigures = new ArrayList<>();\n-        for (Figure f : figures) {\n-            if (f.getPredecessors().size() == 0) {\n-                rootFigures.add(f);\n-            }\n-        }\n-        return rootFigures;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Diagram.java","additions":66,"deletions":162,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import com.sun.hotspot.igv.data.InputBlock;\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -30,1 +28,0 @@\n-import com.sun.hotspot.igv.data.Source;\n@@ -37,1 +34,1 @@\n-public class Figure extends Properties.Entity implements Source.Provider, Vertex {\n+public class Figure extends Properties.Entity implements Vertex {\n@@ -49,2 +46,2 @@\n-    private Source source;\n-    private Diagram diagram;\n+    private final InputNode inputNode;\n+    private final Diagram diagram;\n@@ -52,3 +49,2 @@\n-    private List<Figure> predecessors;\n-    private List<Figure> successors;\n-    private List<InputGraph> subgraphs;\n+    private final List<Figure> predecessors;\n+    private final List<Figure> successors;\n@@ -57,2 +53,2 @@\n-    private int id;\n-    private String idString;\n+    private final int id;\n+    private final String idString;\n@@ -62,1 +58,1 @@\n-    private InputBlock block;\n+    private Block block;\n@@ -135,1 +131,1 @@\n-    protected Figure(Diagram diagram, int id) {\n+    protected Figure(Diagram diagram, int id, InputNode node) {\n@@ -137,5 +133,5 @@\n-        this.source = new Source();\n-        inputSlots = new ArrayList<>(5);\n-        outputSlots = new ArrayList<>(1);\n-        predecessors = new ArrayList<>(6);\n-        successors = new ArrayList<>(6);\n+        this.inputNode = node;\n+        this.inputSlots = new ArrayList<>(5);\n+        this.outputSlots = new ArrayList<>(1);\n+        this.predecessors = new ArrayList<>(6);\n+        this.successors = new ArrayList<>(6);\n@@ -143,2 +139,1 @@\n-        idString = Integer.toString(id);\n-\n+        this.idString = Integer.toString(id);\n@@ -148,1 +143,1 @@\n-        metrics = canvas.getFontMetrics(diagram.getFont().deriveFont(Font.BOLD));\n+        this.metrics = canvas.getFontMetrics(Diagram.FONT.deriveFont(Font.BOLD));\n@@ -175,1 +170,1 @@\n-    public void setBlock(InputBlock block) {\n+    public void setBlock(Block block) {\n@@ -179,1 +174,1 @@\n-    public InputBlock getBlock() {\n+    public Block getBlock() {\n@@ -188,5 +183,1 @@\n-        Set<Figure> result = new HashSet<>();\n-        for (Figure f : getPredecessors()) {\n-            result.add(f);\n-        }\n-        return Collections.unmodifiableSet(result);\n+        return Collections.unmodifiableSet(new HashSet<>(getPredecessors()));\n@@ -196,5 +187,1 @@\n-        Set<Figure> result = new HashSet<>();\n-        for (Figure f : getSuccessors()) {\n-            result.add(f);\n-        }\n-        return Collections.unmodifiableSet(result);\n+        return Collections.unmodifiableSet(new HashSet<>(getSuccessors()));\n@@ -225,8 +212,0 @@\n-    public List<InputGraph> getSubgraphs() {\n-        return subgraphs;\n-    }\n-\n-    public void setSubgraphs(List<InputGraph> subgraphs) {\n-        this.subgraphs = subgraphs;\n-    }\n-\n@@ -247,3 +226,2 @@\n-    @Override\n-    public Source getSource() {\n-        return source;\n+    public InputNode getInputNode() {\n+        return inputNode;\n@@ -258,7 +236,0 @@\n-    public InputSlot createInputSlot(int index) {\n-        InputSlot slot = new InputSlot(this, index);\n-        inputSlots.add(slot);\n-        inputSlots.sort(Slot.slotIndexComparator);\n-        return slot;\n-    }\n-\n@@ -276,3 +247,1 @@\n-        } else if (outputSlots.contains(s)) {\n-            outputSlots.remove(s);\n-        }\n+        } else outputSlots.remove(s);\n@@ -281,1 +250,1 @@\n-    public OutputSlot createOutputSlot() {\n+    public void createOutputSlot() {\n@@ -284,1 +253,0 @@\n-        return slot;\n@@ -348,2 +316,2 @@\n-        for (int i = 0; i < strings.length; i++) {\n-            result.add(getProperties().resolveString(strings[i]));\n+        for (String string : strings) {\n+            result.add(getProperties().resolveString(string));\n@@ -354,1 +322,1 @@\n-            List<String> inputs = new ArrayList<String>(getPredecessors().size());\n+            List<String> inputs = new ArrayList<>(getPredecessors().size());\n@@ -369,1 +337,1 @@\n-        \/\/ Set the \"label\" property of each input node, so that by default\n+        \/\/ Set the \"label\" property of the input node, so that by default\n@@ -372,4 +340,3 @@\n-        for (InputNode n : getSource().getSourceNodes()) {\n-            String label = n.getProperties().resolveString(diagram.getNodeText());\n-            n.getProperties().setProperty(\"label\", label.replaceAll(\"\\\\R\", \" \"));\n-        }\n+        String label = inputNode.getProperties().resolveString(diagram.getNodeText());\n+        inputNode.getProperties().setProperty(\"label\", label.replaceAll(\"\\\\R\", \" \"));\n+\n@@ -393,4 +360,0 @@\n-    public InputNode getFirstSourceNode() {\n-        return getSource().getSourceNodes().get(0);\n-    }\n-\n@@ -402,10 +365,1 @@\n-        if (getSource().getSourceNodes().size() == 0) {\n-            assert false : \"Should never reach here, every figure must have at least one source node!\";\n-            return null;\n-        } else {\n-            final InputBlock inputBlock = diagram.getGraph().getBlock(getFirstSourceNode());\n-            assert inputBlock != null;\n-            Cluster result = diagram.getBlock(inputBlock);\n-            assert result != null;\n-            return result;\n-        }\n+        return block;\n@@ -416,4 +370,2 @@\n-\n-        List<InputNode> sourceNodes = source.getSourceNodes();\n-        if (sourceNodes.size() > 0 && getFirstSourceNode().getProperties().get(\"name\") != null) {\n-            return getFirstSourceNode().getProperties().get(\"name\").equals(\"Root\");\n+        if (inputNode != null && inputNode.getProperties().get(\"name\") != null) {\n+            return inputNode.getProperties().get(\"name\").equals(\"Root\");\n@@ -429,4 +381,0 @@\n-\n-    public Rectangle getBounds() {\n-        return new Rectangle(this.getPosition(), new Dimension(this.getWidth(), this.getHeight()));\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":34,"deletions":86,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.layout.Port;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.layout.Port;\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/FigureConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,18 +81,1 @@\n-    public static final Comparator<Slot> slotIndexComparator = new Comparator<Slot>() {\n-\n-        @Override\n-        public int compare(Slot o1, Slot o2) {\n-            return o1.wantedIndex - o2.wantedIndex;\n-        }\n-    };\n-    public static final Comparator<Slot> slotFigureComparator = new Comparator<Slot>() {\n-\n-        @Override\n-        public int compare(Slot o1, Slot o2) {\n-            return o1.figure.getId() - o2.figure.getId();\n-        }\n-    };\n-\n-    public InputNode getAssociatedNode() {\n-        return associatedNode;\n-    }\n+    public static final Comparator<Slot> slotIndexComparator = Comparator.comparingInt(o -> o.wantedIndex);\n@@ -110,1 +93,1 @@\n-            g.setFont(figure.getDiagram().getSlotFont().deriveFont(Font.BOLD));\n+            g.setFont(Diagram.SLOT_FONT.deriveFont(Font.BOLD));\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Slot.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -38,2 +38,2 @@\n-    private ClusterNode from;\n-    private ClusterNode to;\n+    private final ClusterNode from;\n+    private final ClusterNode to;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterEdge.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -40,4 +40,2 @@\n-    private ClusterInputSlotNode inputSlotNode;\n-    private Link connection;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -46,3 +44,1 @@\n-        this.inputSlotNode = inputSlotNode;\n-        this.connection = c;\n-        this.controlPoints = new ArrayList<Point>();\n+        this.controlPoints = new ArrayList<>();\n@@ -54,8 +50,0 @@\n-    public Link getConnection() {\n-        return connection;\n-    }\n-\n-    public ClusterInputSlotNode getInputSlotNode() {\n-        return inputSlotNode;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterIngoingConnection.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-    private final int SIZE = 0;\n@@ -40,10 +39,3 @@\n-    private Port inputSlot;\n-    private Port outputSlot;\n-    private ClusterNode blockNode;\n-    private InterClusterConnection interBlockConnection;\n-    private Cluster cluster;\n-    private ClusterIngoingConnection conn;\n-\n-    public void setIngoingConnection(ClusterIngoingConnection c) {\n-        conn = c;\n-    }\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n+    private final ClusterNode blockNode;\n@@ -51,4 +43,1 @@\n-    public ClusterIngoingConnection getIngoingConnection() {\n-        return conn;\n-    }\n-    private String id;\n+    private final String id;\n@@ -82,1 +71,1 @@\n-                return \"OutPort of \" + thisNode.toString();\n+                return \"OutPort of \" + thisNode;\n@@ -101,1 +90,1 @@\n-                return \"InPort of \" + thisNode.toString();\n+                return \"InPort of \" + thisNode;\n@@ -110,4 +99,0 @@\n-    public InterClusterConnection getInterBlockConnection() {\n-        return interBlockConnection;\n-    }\n-\n@@ -119,1 +104,1 @@\n-        return new Dimension(SIZE, SIZE);\n+        return new Dimension(0, 0);\n@@ -130,4 +115,0 @@\n-    public void setInterBlockConnection(InterClusterConnection interBlockConnection) {\n-        this.interBlockConnection = interBlockConnection;\n-    }\n-\n@@ -135,1 +116,1 @@\n-        return cluster;\n+        return null;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterInputSlotNode.java","additions":8,"deletions":27,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -32,5 +32,1 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;\n@@ -46,2 +42,1 @@\n-    private Port outputSlot;\n-    private Set<Vertex> subNodes;\n+    private final Set<Vertex> subNodes;\n@@ -50,2 +45,1 @@\n-    private Set<Link> subEdges;\n-    private boolean dirty;\n+    private final Set<Link> subEdges;\n@@ -53,1 +47,1 @@\n-    private String name;\n+    private final String name;\n@@ -62,2 +56,2 @@\n-        this.subNodes = new HashSet<Vertex>();\n-        this.subEdges = new HashSet<Link>();\n+        this.subNodes = new HashSet<>();\n+        this.subEdges = new HashSet<>();\n@@ -65,1 +59,1 @@\n-        position = new Point(0, 0);\n+        this.position = new Point(0, 0);\n@@ -97,2 +91,0 @@\n-\n-\n@@ -117,16 +109,0 @@\n-\n-        outputSlot = new Port() {\n-\n-            public Point getRelativePosition() {\n-                return new Point(size.width \/ 2, 0);\/\/size.height);\n-            }\n-\n-            public Vertex getVertex() {\n-                return widget;\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return \"ClusterOutput(\" + name + \")\";\n-            }\n-        };\n@@ -177,1 +153,1 @@\n-            List<Point> points = new ArrayList<Point>(l.getControlPoints());\n+            List<Point> points = new ArrayList<>(l.getControlPoints());\n@@ -195,4 +171,0 @@\n-    public Port getOutputSlot() {\n-        return outputSlot;\n-    }\n-\n@@ -218,1 +190,1 @@\n-            ArrayList<Point> newArr = new ArrayList<Point>(arr.size());\n+            ArrayList<Point> newArr = new ArrayList<>(arr.size());\n@@ -241,4 +213,0 @@\n-    public void setDirty(boolean b) {\n-        dirty = b;\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterNode.java","additions":9,"deletions":41,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -40,4 +40,2 @@\n-    private ClusterOutputSlotNode outputSlotNode;\n-    private Link connection;\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -46,6 +44,3 @@\n-        this.outputSlotNode = outputSlotNode;\n-        this.connection = c;\n-        this.intermediatePoints = new ArrayList<Point>();\n-\n-        outputSlot = c.getFrom();\n-        inputSlot = outputSlotNode.getInputSlot();\n+        this.intermediatePoints = new ArrayList<>();\n+        this.outputSlot = c.getFrom();\n+        this.inputSlot = outputSlotNode.getInputSlot();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutgoingConnection.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-    private final int SIZE = 0;\n@@ -40,4 +39,3 @@\n-    private Port inputSlot;\n-    private Port outputSlot;\n-    private ClusterNode blockNode;\n-    private boolean root;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n+    private final ClusterNode blockNode;\n@@ -46,1 +44,1 @@\n-    private String id;\n+    private final String id;\n@@ -82,1 +80,1 @@\n-                return \"InPort of \" + thisNode.toString();\n+                return \"InPort of \" + thisNode;\n@@ -91,1 +89,1 @@\n-                p.y = 0;\/\/thisBlockNode.getSize().height;\n+                p.y = 0;\n@@ -101,1 +99,1 @@\n-                return \"OutPort of \" + thisNode.toString();\n+                return \"OutPort of \" + thisNode;\n@@ -107,1 +105,1 @@\n-        return new Dimension(SIZE, SIZE);\n+        return new Dimension(0, 0);\n@@ -130,4 +128,0 @@\n-    public void setRoot(boolean b) {\n-        root = b;\n-    }\n-\n@@ -139,1 +133,1 @@\n-        return root;\n+        return false;\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/ClusterOutputSlotNode.java","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Edge<N, E> {\n-\n-    private E data;\n-    private Node<N, E> source;\n-    private Node<N, E> dest;\n-\n-    protected Edge(Graph<N, E> graph, Node<N, E> source, Node<N, E> dest, E data) {\n-        setData(data);\n-        this.source = source;\n-        this.dest = dest;\n-        assert source != null;\n-        assert dest != null;\n-        assert source.getGraph() == dest.getGraph();\n-        assert source.getGraph() != null;\n-        assert dest.getGraph() != null;\n-    }\n-\n-    public Node<N, E> getSource() {\n-        return source;\n-    }\n-\n-    public Node<N, E> getDest() {\n-        return dest;\n-    }\n-\n-    public E getData() {\n-        return data;\n-    }\n-\n-    public void setData(E e) {\n-        data = e;\n-    }\n-\n-    public void remove() {\n-        source.getGraph().removeEdge(this, null);\n-    }\n-\n-    public boolean isSelfLoop() {\n-        return source == dest;\n-    }\n-\n-    public void reverse() {\n-\n-        \/\/ Remove from current source \/ dest\n-        source.removeOutEdge(this);\n-        dest.removeInEdge(this);\n-\n-        Node<N, E> tmp = source;\n-        source = dest;\n-        dest = tmp;\n-\n-        \/\/ Add to new source \/ dest\n-        source.addOutEdge(this);\n-        dest.addInEdge(this);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Edge (\" + source + \" -- \" + dest + \"): \" + data;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Edge.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,292 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-import java.util.*;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Graph<N, E> {\n-\n-    private HashMap<Object, Node<N, E>> nodes;\n-    private HashMap<Object, Edge<N, E>> edges;\n-    private List<Node<N, E>> nodeList;\n-\n-    public Graph() {\n-        nodes = new HashMap<>();\n-        edges = new HashMap<>();\n-        nodeList = new ArrayList<>();\n-    }\n-\n-    public Node<N, E> createNode(N data, Object key) {\n-        Node<N, E> n = new Node<>(this, data);\n-        assert key == null || !nodes.containsKey(key);\n-        if (key != null) {\n-            nodes.put(key, n);\n-        }\n-        nodeList.add(n);\n-        return n;\n-    }\n-\n-    public Edge<N, E> createEdge(Node<N, E> source, Node<N, E> dest, E data, Object key) {\n-        Edge<N, E> e = new Edge<>(this, source, dest, data);\n-        source.addOutEdge(e);\n-        dest.addInEdge(e);\n-        if (key != null) {\n-            edges.put(key, e);\n-        }\n-        return e;\n-    }\n-\n-    public Node<N, E> getNode(Object key) {\n-        return nodes.get(key);\n-    }\n-\n-    public Edge<N, E> getEdge(Object key) {\n-        return edges.get(key);\n-    }\n-\n-    public Collection<Edge<N, E>> getEdges() {\n-        return Collections.unmodifiableCollection(edges.values());\n-    }\n-\n-    public Collection<Node<N, E>> getNodes() {\n-        return Collections.unmodifiableList(nodeList);\n-    }\n-\n-    public void removeEdge(Edge<N, E> e, Object key) {\n-        assert key == null || edges.containsKey(key);\n-        if (key != null) {\n-            edges.remove(key);\n-        }\n-        e.getSource().removeOutEdge(e);\n-        e.getDest().removeInEdge(e);\n-    }\n-\n-    public class DFSTraversalVisitor {\n-\n-        public void visitNode(Node<N, E> n) {\n-        }\n-\n-        public boolean visitEdge(Edge<N, E> e, boolean backEdge) {\n-            return true;\n-        }\n-    }\n-\n-    public class BFSTraversalVisitor {\n-\n-        public void visitNode(Node<N, E> n, int depth) {\n-        }\n-    }\n-\n-    public List<Node<N, E>> getNodesWithInDegree(int x) {\n-        return getNodesWithInDegree(x, true);\n-    }\n-\n-    public List<Node<N, E>> getNodesWithInDegree(int x, boolean countSelfLoops) {\n-\n-        List<Node<N, E>> result = new ArrayList<>();\n-        for (Node<N, E> n : getNodes()) {\n-            if (n.getInDegree(countSelfLoops) == x) {\n-                result.add(n);\n-            }\n-        }\n-\n-        return result;\n-\n-    }\n-\n-    private void markReachable(Node<N, E> startingNode) {\n-        ArrayList<Node<N, E>> arr = new ArrayList<>();\n-        arr.add(startingNode);\n-        for (Node<N, E> n : getNodes()) {\n-            n.setReachable(false);\n-        }\n-        traverseDFS(arr, new DFSTraversalVisitor() {\n-\n-            @Override\n-            public void visitNode(Node<N, E> n) {\n-                n.setReachable(true);\n-            }\n-        });\n-    }\n-\n-    public void traverseBFS(Node<N, E> startingNode, BFSTraversalVisitor tv, boolean longestPath) {\n-\n-        if (longestPath) {\n-            markReachable(startingNode);\n-        }\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        Queue<Node<N, E>> queue = new LinkedList<>();\n-        queue.add(startingNode);\n-        startingNode.setVisited(true);\n-        int layer = 0;\n-        Node<N, E> lastOfLayer = startingNode;\n-        Node<N, E> lastAdded = null;\n-\n-        while (!queue.isEmpty()) {\n-\n-            Node<N, E> current = queue.poll();\n-            tv.visitNode(current, layer);\n-            current.setActive(false);\n-\n-\n-            for (Edge<N, E> e : current.getOutEdges()) {\n-                if (!e.getDest().isVisited()) {\n-\n-                    boolean allow = true;\n-                    if (longestPath) {\n-                        for (Node<N, E> pred : e.getDest().getPredecessors()) {\n-                            if ((!pred.isVisited() || pred.isActive()) && pred.isReachable()) {\n-                                allow = false;\n-                                break;\n-                            }\n-                        }\n-                    }\n-\n-                    if (allow) {\n-                        queue.offer(e.getDest());\n-                        lastAdded = e.getDest();\n-                        e.getDest().setVisited(true);\n-                        e.getDest().setActive(true);\n-                    }\n-                }\n-            }\n-\n-            if (current == lastOfLayer && !queue.isEmpty()) {\n-                lastOfLayer = lastAdded;\n-                layer++;\n-            }\n-        }\n-    }\n-\n-    public void traverseDFS(DFSTraversalVisitor tv) {\n-        traverseDFS(getNodes(), tv);\n-    }\n-\n-    public void traverseDFS(Collection<Node<N, E>> startingNodes, DFSTraversalVisitor tv) {\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        boolean result = false;\n-        for (Node<N, E> n : startingNodes) {\n-            traverse(tv, n);\n-        }\n-    }\n-\n-    private void traverse(DFSTraversalVisitor tv, Node<N, E> n) {\n-\n-        if (!n.isVisited()) {\n-            n.setVisited(true);\n-            n.setActive(true);\n-            tv.visitNode(n);\n-\n-            for (Edge<N, E> e : n.getOutEdges()) {\n-\n-                Node<N, E> next = e.getDest();\n-                if (next.isActive()) {\n-                    tv.visitEdge(e, true);\n-                } else {\n-                    if (tv.visitEdge(e, false)) {\n-                        traverse(tv, next);\n-                    }\n-                }\n-            }\n-\n-            n.setActive(false);\n-        }\n-\n-    }\n-\n-    public boolean hasCycles() {\n-\n-        for (Node<N, E> n : getNodes()) {\n-            n.setVisited(false);\n-            n.setActive(false);\n-        }\n-\n-        boolean result = false;\n-        for (Node<N, E> n : getNodes()) {\n-            result |= checkCycles(n);\n-            if (result) {\n-                break;\n-            }\n-        }\n-        return result;\n-    }\n-\n-    private boolean checkCycles(Node<N, E> n) {\n-\n-        if (n.isActive()) {\n-            return true;\n-        }\n-\n-        if (!n.isVisited()) {\n-\n-            n.setVisited(true);\n-            n.setActive(true);\n-\n-            for (Node<N, E> succ : n.getSuccessors()) {\n-                if (checkCycles(succ)) {\n-                    return true;\n-                }\n-            }\n-\n-            n.setActive(false);\n-\n-        }\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public String toString() {\n-\n-        StringBuilder s = new StringBuilder();\n-        s.append(\"Nodes: \");\n-        for (Node<N, E> n : getNodes()) {\n-            s.append(n.toString());\n-            s.append(\"\\n\");\n-        }\n-\n-        s.append(\"Edges: \");\n-\n-        for (Edge<N, E> e : getEdges()) {\n-            s.append(e.toString());\n-            s.append(\"\\n\");\n-        }\n-\n-        return s.toString();\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Graph.java","additions":0,"deletions":292,"binary":false,"changes":292,"status":"deleted"},{"patch":"@@ -26,8 +26,0 @@\n-import java.awt.Dimension;\n-import java.awt.Rectangle;\n-import java.awt.Canvas;\n-import java.awt.Font;\n-import java.awt.FontMetrics;\n-import java.util.*;\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n@@ -35,2 +27,3 @@\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import com.sun.hotspot.igv.layout.*;\n+import java.awt.*;\n+import java.util.*;\n@@ -41,1 +34,1 @@\n-    private FontMetrics fontMetrics;\n+    private final FontMetrics fontMetrics;\n@@ -81,1 +74,1 @@\n-            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<Link>());\n+            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<>());\n@@ -86,2 +79,1 @@\n-        manager.doLayout(new LayoutGraph(clusterEdges, new HashSet<>(clusterNode.values())),\n-                         new HashSet<Link>());\n+        manager.doLayout(new LayoutGraph(clusterEdges, new HashSet<>(clusterNode.values())), new HashSet<>());\n@@ -147,1 +139,1 @@\n-            inputLink.put(new AbstractMap.SimpleEntry<Cluster, Cluster>(l.getFromCluster(), l.getToCluster()), l);\n+            inputLink.put(new AbstractMap.SimpleEntry<>(l.getFromCluster(), l.getToCluster()), l);\n@@ -151,1 +143,1 @@\n-            Link l = inputLink.get(new AbstractMap.SimpleEntry<Cluster, Cluster>(ce.getFromCluster(), ce.getToCluster()));\n+            Link l = inputLink.get(new AbstractMap.SimpleEntry<>(ce.getFromCluster(), ce.getToCluster()));\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalCFGLayoutManager.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.*;\n@@ -28,12 +29,1 @@\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.TreeSet;\n-import com.sun.hotspot.igv.layout.Cluster;\n-import com.sun.hotspot.igv.layout.LayoutGraph;\n-import com.sun.hotspot.igv.layout.LayoutManager;\n-import com.sun.hotspot.igv.layout.Link;\n-import com.sun.hotspot.igv.layout.Port;\n-import com.sun.hotspot.igv.layout.Vertex;\n+import java.util.*;\n@@ -56,4 +46,0 @@\n-    public void doLayout(LayoutGraph graph) {\n-        doLayout(graph, new HashSet<Vertex>(), new HashSet<Vertex>(), new HashSet<Link>());\n-    }\n-\n@@ -72,1 +58,1 @@\n-    public void doLayout(LayoutGraph graph, Set<? extends Vertex> firstLayerHint, Set<? extends Vertex> lastLayerHint, Set<? extends Link> importantLinks) {\n+    public void doLayout(LayoutGraph graph) {\n@@ -76,14 +62,13 @@\n-        HashMap<Cluster, List<Vertex>> lists = new HashMap<Cluster, List<Vertex>>();\n-        HashMap<Cluster, List<Link>> listsConnection = new HashMap<Cluster, List<Link>>();\n-        HashMap<Cluster, HashMap<Port, ClusterInputSlotNode>> clusterInputSlotHash = new HashMap<Cluster, HashMap<Port, ClusterInputSlotNode>>();\n-        HashMap<Cluster, HashMap<Port, ClusterOutputSlotNode>> clusterOutputSlotHash = new HashMap<Cluster, HashMap<Port, ClusterOutputSlotNode>>();\n-\n-        HashMap<Cluster, ClusterNode> clusterNodes = new HashMap<Cluster, ClusterNode>();\n-        HashMap<Cluster, Set<ClusterInputSlotNode>> clusterInputSlotSet = new HashMap<Cluster, Set<ClusterInputSlotNode>>();\n-        HashMap<Cluster, Set<ClusterOutputSlotNode>> clusterOutputSlotSet = new HashMap<Cluster, Set<ClusterOutputSlotNode>>();\n-        Set<Link> clusterEdges = new HashSet<Link>();\n-        Set<Link> interClusterEdges = new HashSet<Link>();\n-        HashMap<Link, ClusterOutgoingConnection> linkClusterOutgoingConnection = new HashMap<Link, ClusterOutgoingConnection>();\n-        HashMap<Link, InterClusterConnection> linkInterClusterConnection = new HashMap<Link, InterClusterConnection>();\n-        HashMap<Link, ClusterIngoingConnection> linkClusterIngoingConnection = new HashMap<Link, ClusterIngoingConnection>();\n-        Set<ClusterNode> clusterNodeSet = new HashSet<ClusterNode>();\n+        HashMap<Cluster, List<Link>> listsConnection = new HashMap<>();\n+        HashMap<Cluster, HashMap<Port, ClusterInputSlotNode>> clusterInputSlotHash = new HashMap<>();\n+        HashMap<Cluster, HashMap<Port, ClusterOutputSlotNode>> clusterOutputSlotHash = new HashMap<>();\n+\n+        HashMap<Cluster, ClusterNode> clusterNodes = new HashMap<>();\n+        HashMap<Cluster, Set<ClusterInputSlotNode>> clusterInputSlotSet = new HashMap<>();\n+        HashMap<Cluster, Set<ClusterOutputSlotNode>> clusterOutputSlotSet = new HashMap<>();\n+        Set<Link> clusterEdges = new HashSet<>();\n+        Set<Link> interClusterEdges = new HashSet<>();\n+        HashMap<Link, ClusterOutgoingConnection> linkClusterOutgoingConnection = new HashMap<>();\n+        HashMap<Link, InterClusterConnection> linkInterClusterConnection = new HashMap<>();\n+        HashMap<Link, ClusterIngoingConnection> linkClusterIngoingConnection = new HashMap<>();\n+        Set<ClusterNode> clusterNodeSet = new HashSet<>();\n@@ -94,6 +79,5 @@\n-            lists.put(c, new ArrayList<Vertex>());\n-            listsConnection.put(c, new ArrayList<Link>());\n-            clusterInputSlotHash.put(c, new HashMap<Port, ClusterInputSlotNode>());\n-            clusterOutputSlotHash.put(c, new HashMap<Port, ClusterOutputSlotNode>());\n-            clusterOutputSlotSet.put(c, new TreeSet<ClusterOutputSlotNode>());\n-            clusterInputSlotSet.put(c, new TreeSet<ClusterInputSlotNode>());\n+            listsConnection.put(c, new ArrayList<>());\n+            clusterInputSlotHash.put(c, new HashMap<>());\n+            clusterOutputSlotHash.put(c, new HashMap<>());\n+            clusterOutputSlotSet.put(c, new TreeSet<>());\n+            clusterInputSlotSet.put(c, new TreeSet<>());\n@@ -159,1 +143,1 @@\n-                    outputSlotNode = new ClusterOutputSlotNode(clusterNodes.get(fromCluster), \"Out \" + fromCluster.toString() + \" \" + samePort.toString());\n+                    outputSlotNode = new ClusterOutputSlotNode(clusterNodes.get(fromCluster), \"Out \" + fromCluster.toString() + \" \" + samePort);\n@@ -174,1 +158,1 @@\n-                    inputSlotNode = new ClusterInputSlotNode(clusterNodes.get(toCluster), \"In \" + toCluster.toString() + \" \" + samePort.toString());\n+                    inputSlotNode = new ClusterInputSlotNode(clusterNodes.get(toCluster), \"In \" + toCluster.toString() + \" \" + samePort);\n@@ -179,1 +163,0 @@\n-                inputSlotNode.setIngoingConnection(conn);\n@@ -181,3 +164,1 @@\n-                if (samePort != null) {\n-                    clusterInputSlotHash.get(toCluster).put(samePort, inputSlotNode);\n-                }\n+                clusterInputSlotHash.get(toCluster).put(samePort, inputSlotNode);\n@@ -197,1 +178,1 @@\n-            new Timing(\"Child timing\");\n+            t = new Timing(\"Child timing\");\n@@ -203,1 +184,1 @@\n-            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<Link>());\n+            subManager.doLayout(new LayoutGraph(n.getSubEdges(), n.getSubNodes()), new HashSet<>());\n@@ -238,1 +219,1 @@\n-                List<Point> points = new ArrayList<Point>();\n+                List<Point> points = new ArrayList<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalClusterLayoutManager.java","additions":28,"deletions":47,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -59,3 +59,3 @@\n-    private Combine combine;\n-    private int dummyWidth;\n-    private int dummyHeight;\n+    private final Combine combine;\n+    private final int dummyWidth;\n+    private final int dummyHeight;\n@@ -74,1 +74,0 @@\n-    private HashMap<LayoutEdge, LayoutEdge> bottomEdgeHash;\n@@ -81,1 +80,1 @@\n-    private Set<Link> linksToFollow;\n+    private final Set<Link> linksToFollow;\n@@ -126,1 +125,1 @@\n-    private abstract class AlgorithmPart {\n+    private abstract static class AlgorithmPart {\n@@ -162,4 +161,0 @@\n-    public HierarchicalLayoutManager() {\n-        this(Combine.NONE);\n-    }\n-\n@@ -186,4 +181,0 @@\n-    public int getMaxLayerLength() {\n-        return maxLayerLength;\n-    }\n-\n@@ -219,1 +210,1 @@\n-        doLayout(graph, new HashSet<Link>());\n+        doLayout(graph, new HashSet<>());\n@@ -234,1 +225,0 @@\n-        bottomEdgeHash = new HashMap<>();\n@@ -455,1 +445,0 @@\n-                                \/\/checkPoints(points);\n@@ -479,1 +468,0 @@\n-                            \/\/checkPoints(points);\n@@ -541,14 +529,7 @@\n-    private static class Segment {\n-\n-        public float d;\n-        public int orderNumber = -1;\n-        public ArrayList<LayoutNode> nodes = new ArrayList<>();\n-        public HashSet<Segment> succs = new HashSet<>();\n-        public HashSet<Segment> preds = new HashSet<>();\n-        public Region region;\n-    }\n-    private static final Comparator<Segment> segmentComparator = new Comparator<Segment>() {\n-\n-        @Override\n-        public int compare(Segment s1, Segment s2) {\n-            return s1.orderNumber - s2.orderNumber;\n+    private static final Comparator<LayoutNode> nodePositionComparator = Comparator.comparingInt(n -> n.pos);\n+    private static final Comparator<LayoutNode> nodeProcessingDownComparator = (n1, n2) -> {\n+        int n1VIP = 0;\n+        for (LayoutEdge e : n1.preds) {\n+            if (e.vip) {\n+                n1VIP++;\n+            }\n@@ -556,15 +537,5 @@\n-    };\n-\n-    private static class Region {\n-\n-        public float d;\n-        public int minOrderNumber;\n-        public SortedSet<Segment> segments = new TreeSet<>(segmentComparator);\n-        public HashSet<Region> succs = new HashSet<>(4);\n-        public HashSet<Region> preds = new HashSet<>(4);\n-    }\n-    private static final Comparator<Region> regionComparator = new Comparator<Region>() {\n-\n-        @Override\n-        public int compare(Region r1, Region r2) {\n-            return r1.minOrderNumber - r2.minOrderNumber;\n+        int n2VIP = 0;\n+        for (LayoutEdge e : n2.preds) {\n+            if (e.vip) {\n+                n2VIP++;\n+            }\n@@ -572,6 +543,2 @@\n-    };\n-    private static final Comparator<LayoutNode> nodePositionComparator = new Comparator<LayoutNode>() {\n-\n-        @Override\n-        public int compare(LayoutNode n1, LayoutNode n2) {\n-            return n1.pos - n2.pos;\n+        if (n1VIP != n2VIP) {\n+            return n2VIP - n1VIP;\n@@ -579,25 +546,1 @@\n-    };\n-    private static final Comparator<LayoutNode> nodeProcessingDownComparator = new Comparator<LayoutNode>() {\n-        @Override\n-        public int compare(LayoutNode n1, LayoutNode n2) {\n-            int n1VIP = 0;\n-            for (LayoutEdge e : n1.preds) {\n-                if (e.vip) {\n-                    n1VIP++;\n-                }\n-            }\n-            int n2VIP = 0;\n-            for (LayoutEdge e : n2.preds) {\n-                if (e.vip) {\n-                    n2VIP++;\n-                }\n-            }\n-            if (n1VIP != n2VIP) {\n-                return n2VIP - n1VIP;\n-            }\n-            if (n1.vertex == null) {\n-                if (n2.vertex == null) {\n-                    return 0;\n-                }\n-                return -1;\n-            }\n+        if (n1.vertex == null) {\n@@ -605,1 +548,1 @@\n-                return 1;\n+                return 0;\n@@ -607,1 +550,1 @@\n-            return n1.preds.size() - n2.preds.size();\n+            return -1;\n@@ -609,0 +552,4 @@\n+        if (n2.vertex == null) {\n+            return 1;\n+        }\n+        return n1.preds.size() - n2.preds.size();\n@@ -610,15 +557,5 @@\n-    private static final Comparator<LayoutNode> nodeProcessingUpComparator = new Comparator<LayoutNode>() {\n-\n-        @Override\n-        public int compare(LayoutNode n1, LayoutNode n2) {\n-            int n1VIP = 0;\n-            for (LayoutEdge e : n1.succs) {\n-                if (e.vip) {\n-                    n1VIP++;\n-                }\n-            }\n-            int n2VIP = 0;\n-            for (LayoutEdge e : n2.succs) {\n-                if (e.vip) {\n-                    n2VIP++;\n-                }\n+    private static final Comparator<LayoutNode> nodeProcessingUpComparator = (n1, n2) -> {\n+        int n1VIP = 0;\n+        for (LayoutEdge e : n1.succs) {\n+            if (e.vip) {\n+                n1VIP++;\n@@ -626,8 +563,5 @@\n-            if (n1VIP != n2VIP) {\n-                return n2VIP - n1VIP;\n-            }\n-            if (n1.vertex == null) {\n-                if (n2.vertex == null) {\n-                    return 0;\n-                }\n-                return -1;\n+        }\n+        int n2VIP = 0;\n+        for (LayoutEdge e : n2.succs) {\n+            if (e.vip) {\n+                n2VIP++;\n@@ -635,0 +569,5 @@\n+        }\n+        if (n1VIP != n2VIP) {\n+            return n2VIP - n1VIP;\n+        }\n+        if (n1.vertex == null) {\n@@ -636,1 +575,1 @@\n-                return 1;\n+                return 0;\n@@ -638,1 +577,1 @@\n-            return n1.succs.size() - n2.succs.size();\n+            return -1;\n@@ -640,0 +579,4 @@\n+        if (n2.vertex == null) {\n+            return 1;\n+        }\n+        return n1.succs.size() - n2.succs.size();\n@@ -686,1 +629,1 @@\n-                sweepUp(false);\n+                sweepUp();\n@@ -692,1 +635,1 @@\n-            sweepUp(true);\n+            sweepUp();\n@@ -697,2 +640,0 @@\n-                \/\/               space[i] = new ArrayList<>();\n-                int curX = 0;\n@@ -701,1 +642,0 @@\n-\/\/                    curX += n.width + xOffset;\n@@ -784,1 +724,1 @@\n-        private void sweepUp(boolean onlyDummies) {\n+        private void sweepUp() {\n@@ -794,10 +734,0 @@\n-        private void doubleSweep() {\n-            for (int i = layers.length - 2; i >= 0; i--) {\n-                NodeRow r = new NodeRow(space[i]);\n-                for (LayoutNode n : upProcessingOrder[i]) {\n-                    int optimal = calculateOptimalBoth(n);\n-                    r.insert(n, optimal);\n-                }\n-            }\n-        }\n-\n@@ -817,2 +747,2 @@\n-        private TreeSet<LayoutNode> treeSet;\n-        private ArrayList<Integer> space;\n+        private final TreeSet<LayoutNode> treeSet;\n+        private final ArrayList<Integer> space;\n@@ -835,1 +765,1 @@\n-            LayoutNode leftNeighbor = null;\n+            LayoutNode leftNeighbor;\n@@ -846,1 +776,1 @@\n-                LayoutNode rightNeighbor = null;\n+                LayoutNode rightNeighbor;\n@@ -854,5 +784,1 @@\n-                if (pos > maxX) {\n-                    n.x = maxX;\n-                } else {\n-                    n.x = pos;\n-                }\n+                n.x = Math.min(pos, maxX);\n@@ -866,7 +792,1 @@\n-    private static Comparator<LayoutNode> crossingNodeComparator = new Comparator<LayoutNode>() {\n-\n-        @Override\n-        public int compare(LayoutNode n1, LayoutNode n2) {\n-            return n1.crossingNumber - n2.crossingNumber;\n-        }\n-    };\n+    private static final Comparator<LayoutNode> crossingNodeComparator = Comparator.comparingInt(n -> n.crossingNumber);\n@@ -948,2 +868,1 @@\n-\n-            for (int i = 0; i < layers.length; i++) {\n+            for (List<LayoutNode> layer : layers) {\n@@ -951,1 +870,1 @@\n-                for (LayoutNode n : layers[i]) {\n+                for (LayoutNode n : layer) {\n@@ -1091,1 +1010,1 @@\n-            for (int i = 0; i < layers.length; i++) {\n+            for (List<LayoutNode> layer : layers) {\n@@ -1095,1 +1014,1 @@\n-                for (LayoutNode n : layers[i]) {\n+                for (LayoutNode n : layer) {\n@@ -1102,1 +1021,1 @@\n-                for (LayoutNode n : layers[i]) {\n+                for (LayoutNode n : layer) {\n@@ -1150,7 +1069,1 @@\n-                Comparator<LayoutEdge> comparator = new Comparator<LayoutEdge>() {\n-\n-                    @Override\n-                    public int compare(LayoutEdge e1, LayoutEdge e2) {\n-                        return e1.to.layer - e2.to.layer;\n-                    }\n-                };\n+                Comparator<LayoutEdge> comparator = Comparator.comparingInt(e -> e.to.layer);\n@@ -1168,1 +1081,1 @@\n-                            if (maxLayerLength != -1 && e.to.layer - e.from.layer > maxLayerLength\/* && e.to.preds.size() > 1 && e.from.succs.size() > 1*\/) {\n+                            if (maxLayerLength != -1 && e.to.layer - e.from.layer > maxLayerLength) {\n@@ -1173,1 +1086,1 @@\n-                                LayoutEdge topEdge = null;\n+                                LayoutEdge topEdge;\n@@ -1196,1 +1109,1 @@\n-                                    topEdge.relativeTo = topNode.width \/ 2;\n+                                    topEdge.relativeTo = 0;\n@@ -1203,1 +1116,1 @@\n-                                    bottomNodeHash.put(e.relativeFrom, new HashMap<Integer, LayoutNode>());\n+                                    bottomNodeHash.put(e.relativeFrom, new HashMap<>());\n@@ -1208,1 +1121,1 @@\n-                                LayoutNode bottomNode = null;\n+                                LayoutNode bottomNode;\n@@ -1229,1 +1142,0 @@\n-                                bottomEdgeHash.put(topEdge, bottomEdge);\n@@ -1235,1 +1147,1 @@\n-                                    portHash.put(i, new ArrayList<LayoutEdge>());\n+                                    portHash.put(i, new ArrayList<>());\n@@ -1568,1 +1480,1 @@\n-                int curX = 0;\n+                int curY = 0;\n@@ -1580,2 +1492,2 @@\n-                    startPoints.add(new Point(curWidth, curX));\n-                    startPoints.add(new Point(pos, curX));\n+                    startPoints.add(new Point(curWidth, curY));\n+                    startPoints.add(new Point(pos, curY));\n@@ -1587,2 +1499,2 @@\n-                    node.inOffsets.put(pos, -curX);\n-                    curX += offset;\n+                    node.inOffsets.put(pos, -curY);\n+                    curY += offset;\n@@ -1600,7 +1512,1 @@\n-                if (hasReversedDown) {\n-                    curX = -offset;\n-                } else {\n-                    curX = offset;\n-                }\n-\n-                curX = 0;\n+                int curX = 0;\n@@ -1764,7 +1670,4 @@\n-    private Comparator<Link> linkComparator = new Comparator<Link>() {\n-\n-        @Override\n-        public int compare(Link l1, Link l2) {\n-            if (l1.isVIP() && !l2.isVIP()) {\n-                return -1;\n-            }\n+    private final Comparator<Link> linkComparator = (l1, l2) -> {\n+        if (l1.isVIP() && !l2.isVIP()) {\n+            return -1;\n+        }\n@@ -1772,3 +1675,3 @@\n-            if (!l1.isVIP() && l2.isVIP()) {\n-                return 1;\n-            }\n+        if (!l1.isVIP() && l2.isVIP()) {\n+            return 1;\n+        }\n@@ -1776,13 +1679,10 @@\n-            int result = l1.getFrom().getVertex().compareTo(l2.getFrom().getVertex());\n-            if (result != 0) {\n-                return result;\n-            }\n-            result = l1.getTo().getVertex().compareTo(l2.getTo().getVertex());\n-            if (result != 0) {\n-                return result;\n-            }\n-            result = l1.getFrom().getRelativePosition().x - l2.getFrom().getRelativePosition().x;\n-            if (result != 0) {\n-                return result;\n-            }\n-            result = l1.getTo().getRelativePosition().x - l2.getTo().getRelativePosition().x;\n+        int result = l1.getFrom().getVertex().compareTo(l2.getFrom().getVertex());\n+        if (result != 0) {\n+            return result;\n+        }\n+        result = l1.getTo().getVertex().compareTo(l2.getTo().getVertex());\n+        if (result != 0) {\n+            return result;\n+        }\n+        result = l1.getFrom().getRelativePosition().x - l2.getFrom().getRelativePosition().x;\n+        if (result != 0) {\n@@ -1791,0 +1691,2 @@\n+        result = l1.getTo().getRelativePosition().x - l2.getTo().getRelativePosition().x;\n+        return result;\n@@ -1800,5 +1702,2 @@\n-            Collections.sort(vertices,\n-                             (Vertex a, Vertex b) ->\n-                             a.isRoot() == b.isRoot() ?\n-                             a.compareTo(b) :\n-                             Boolean.compare(b.isRoot(), a.isRoot()));\n+            vertices.sort((Vertex a, Vertex b) ->\n+                    a.isRoot() == b.isRoot() ? a.compareTo(b) : Boolean.compare(b.isRoot(), a.isRoot()));\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":96,"deletions":197,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.layout.Cluster;\n@@ -28,1 +29,0 @@\n-import com.sun.hotspot.igv.layout.Cluster;\n@@ -39,2 +39,2 @@\n-    private Port inputSlot;\n-    private Port outputSlot;\n+    private final Port inputSlot;\n+    private final Port outputSlot;\n@@ -42,2 +42,0 @@\n-    private ClusterInputSlotNode inputSlotNode;\n-    private ClusterOutputSlotNode outputSlotNode;\n@@ -46,2 +44,0 @@\n-        this.outputSlotNode = outputSlotNode;\n-        this.inputSlotNode = inputSlotNode;\n@@ -50,5 +46,1 @@\n-        intermediatePoints = new ArrayList<Point>();\n-    }\n-\n-    public ClusterOutputSlotNode getOutputSlotNode() {\n-        return outputSlotNode;\n+        this.intermediatePoints = new ArrayList<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/InterClusterConnection.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        doLayout(graph, new HashSet<Link>());\n+        doLayout(graph, new HashSet<>());\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LinearLayoutManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.hierarchicallayout;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class Node<N, E> {\n-\n-    private N data;\n-    private List<Edge<N, E>> inEdges;\n-    private List<Edge<N, E>> outEdges;\n-    private boolean visited;\n-    private boolean active;\n-    private boolean reachable;\n-    private Graph<N, E> graph;\n-\n-    protected boolean isVisited() {\n-        return visited;\n-    }\n-\n-    protected void setVisited(boolean b) {\n-        visited = b;\n-    }\n-\n-    protected boolean isReachable() {\n-        return reachable;\n-    }\n-\n-    protected void setReachable(boolean b) {\n-        reachable = b;\n-    }\n-\n-    protected boolean isActive() {\n-        return active;\n-    }\n-\n-    protected void setActive(boolean b) {\n-        active = b;\n-    }\n-\n-    public int getInDegree() {\n-        return getInDegree(true);\n-    }\n-\n-    public int getInDegree(boolean countSelfLoops) {\n-        if (countSelfLoops) {\n-            return inEdges.size();\n-        } else {\n-            int cnt = 0;\n-            for (Edge<N, E> e : inEdges) {\n-                if (e.getSource() != this) {\n-                    cnt++;\n-                }\n-            }\n-            return cnt;\n-        }\n-    }\n-\n-    public int getOutDegree() {\n-        return outEdges.size();\n-    }\n-\n-    protected Node(Graph<N, E> graph, N data) {\n-        setData(data);\n-        this.graph = graph;\n-        inEdges = new ArrayList<>();\n-        outEdges = new ArrayList<>();\n-    }\n-\n-    protected void addInEdge(Edge<N, E> e) {\n-        inEdges.add(e);\n-    }\n-\n-    public Graph<N, E> getGraph() {\n-        return graph;\n-    }\n-\n-    protected void addOutEdge(Edge<N, E> e) {\n-        outEdges.add(e);\n-    }\n-\n-    protected void removeInEdge(Edge<N, E> e) {\n-        \/\/assert inEdges.contains(e);\n-        inEdges.remove(e);\n-    }\n-\n-    protected void removeOutEdge(Edge<N, E> e) {\n-        \/\/assert outEdges.contains(e);\n-        outEdges.remove(e);\n-    }\n-\n-    public List<Edge<N, E>> getInEdges() {\n-        return Collections.unmodifiableList(inEdges);\n-    }\n-\n-    public List<Edge<N, E>> getOutEdges() {\n-        return Collections.unmodifiableList(outEdges);\n-    }\n-\n-    public List<Node<N, E>> getSuccessors() {\n-        ArrayList<Node<N, E>> succ = new ArrayList<>();\n-        for (Edge<N, E> e : getOutEdges()) {\n-            Node<N, E> n = e.getDest();\n-            if (!succ.contains(n)) {\n-                succ.add(n);\n-            }\n-        }\n-        return succ;\n-    }\n-\n-    public List<Node<N, E>> getPredecessors() {\n-        ArrayList<Node<N, E>> pred = new ArrayList<>();\n-        for (Edge<N, E> e : getInEdges()) {\n-            Node<N, E> n = e.getSource();\n-            if (!pred.contains(n)) {\n-                pred.add(n);\n-            }\n-        }\n-        return pred;\n-    }\n-\n-    public N getData() {\n-        return data;\n-    }\n-\n-    public void setData(N d) {\n-        data = d;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"Node: \" + data;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Node.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -34,1 +34,1 @@\n-    private String name;\n+    private final String name;\n@@ -52,1 +52,1 @@\n-        System.out.println(toString());\n+        System.out.println();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/Timing.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    public Cluster getOuter();\n+    void setBounds(Rectangle r);\n@@ -38,1 +38,1 @@\n-    public void setBounds(Rectangle r);\n+    Set<? extends Cluster> getSuccessors();\n@@ -40,3 +40,1 @@\n-    public Set<? extends Cluster> getSuccessors();\n-\n-    public Dimension getNodeOffset();\n+    Dimension getNodeOffset();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Cluster.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,5 +34,5 @@\n-    private Set<? extends Link> links;\n-    private SortedSet<Vertex> vertices;\n-    private HashMap<Vertex, Set<Port>> inputPorts;\n-    private HashMap<Vertex, Set<Port>> outputPorts;\n-    private HashMap<Port, Set<Link>> portLinks;\n+    private final Set<? extends Link> links;\n+    private final SortedSet<Vertex> vertices;\n+    private final HashMap<Vertex, Set<Port>> inputPorts;\n+    private final HashMap<Vertex, Set<Port>> outputPorts;\n+    private final HashMap<Port, Set<Link>> portLinks;\n@@ -41,1 +41,1 @@\n-        this(links, new HashSet<Vertex>());\n+        this(links, new HashSet<>());\n@@ -64,2 +64,2 @@\n-                outputPorts.put(v1, new HashSet<Port>(1));\n-                inputPorts.put(v1, new HashSet<Port>(3));\n+                outputPorts.put(v1, new HashSet<>(1));\n+                inputPorts.put(v1, new HashSet<>(3));\n@@ -73,2 +73,2 @@\n-                outputPorts.put(v2, new HashSet<Port>(1));\n-                inputPorts.put(v2, new HashSet<Port>(3));\n+                outputPorts.put(v2, new HashSet<>(1));\n+                inputPorts.put(v2, new HashSet<>(3));\n@@ -83,1 +83,1 @@\n-                portLinks.put(p2, new HashSet<Link>(3));\n+                portLinks.put(p2, new HashSet<>(3));\n@@ -95,2 +95,2 @@\n-                outputPorts.put(v, new HashSet<Port>(1));\n-                inputPorts.put(v, new HashSet<Port>(3));\n+                outputPorts.put(v, new HashSet<>(1));\n+                inputPorts.put(v, new HashSet<>(3));\n@@ -98,1 +98,0 @@\n-                vertices.contains(v);\n@@ -187,1 +186,1 @@\n-        return findRootVertices(new HashSet<Vertex>());\n+        return findRootVertices(new HashSet<>());\n@@ -192,1 +191,1 @@\n-        SortedSet<Cluster> clusters = new TreeSet<Cluster>();\n+        SortedSet<Cluster> clusters = new TreeSet<>();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/LayoutGraph.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public void doLayout(LayoutGraph graph);\n+    void doLayout(LayoutGraph graph);\n@@ -36,1 +36,1 @@\n-    public void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks);\n+    void doLayout(LayoutGraph graph, Set<? extends Link> importantLinks);\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/LayoutManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    public Port getFrom();\n+    Port getFrom();\n@@ -37,1 +37,1 @@\n-    public Cluster getFromCluster();\n+    Cluster getFromCluster();\n@@ -39,1 +39,1 @@\n-    public Port getTo();\n+    Port getTo();\n@@ -41,1 +41,1 @@\n-    public Cluster getToCluster();\n+    Cluster getToCluster();\n@@ -43,1 +43,1 @@\n-    public boolean isVIP();\n+    boolean isVIP();\n@@ -45,1 +45,1 @@\n-    public List<Point> getControlPoints();\n+    List<Point> getControlPoints();\n@@ -47,1 +47,1 @@\n-    public void setControlPoints(List<Point> list);\n+    void setControlPoints(List<Point> list);\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Link.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public Vertex getVertex();\n+    Vertex getVertex();\n@@ -36,1 +36,1 @@\n-    public Point getRelativePosition();\n+    Point getRelativePosition();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Port.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    public Dimension getSize();\n+    Dimension getSize();\n@@ -37,1 +37,1 @@\n-    public Point getPosition();\n+    Point getPosition();\n@@ -39,1 +39,1 @@\n-    public void setPosition(Point p);\n+    void setPosition(Point p);\n@@ -41,1 +41,1 @@\n-    public boolean isRoot();\n+    boolean isRoot();\n@@ -43,1 +43,1 @@\n-    public Cluster getCluster();\n+    Cluster getCluster();\n","filename":"src\/utils\/IdealGraphVisualizer\/Layout\/src\/main\/java\/com\/sun\/hotspot\/igv\/layout\/Vertex.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n-import com.sun.hotspot.igv.data.serialization.BinaryParser;\n@@ -36,1 +34,0 @@\n-    private final boolean binary;\n@@ -38,1 +35,0 @@\n-    private final GraphDocument rootDocument;\n@@ -41,1 +37,1 @@\n-    public Client(SocketChannel socket, GraphDocument rootDocument, GroupCallback callback, boolean  binary) {\n+    public Client(SocketChannel socket, GroupCallback callback) {\n@@ -44,2 +40,0 @@\n-        this.binary = binary;\n-        this.rootDocument = rootDocument;\n@@ -54,7 +48,2 @@\n-            if (binary) {\n-                new BinaryParser(channel, null, rootDocument, callback).parse();\n-            } else {\n-                \/\/ signal readiness to client VM (old protocol)\n-                channel.socket().getOutputStream().write('y');\n-                new Parser(channel, null, callback).parse();\n-            }\n+            channel.socket().getOutputStream().write('y');\n+            new Parser(channel, null, callback).parse();\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Client.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n@@ -45,1 +44,0 @@\n-    private final boolean binary;\n@@ -47,1 +45,0 @@\n-    private final GraphDocument rootDocument;\n@@ -52,3 +49,1 @@\n-    public Server(GraphDocument rootDocument, GroupCallback callback, boolean binary) {\n-        this.binary = binary;\n-        this.rootDocument = rootDocument;\n+    public Server(GroupCallback callback) {\n@@ -62,2 +57,1 @@\n-\n-        int curPort = Integer.parseInt(Settings.get().get(binary ? Settings.PORT_BINARY : Settings.PORT, binary ? Settings.PORT_BINARY_DEFAULT : Settings.PORT_DEFAULT));\n+        int curPort = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n@@ -70,2 +64,1 @@\n-\n-        int curPort = Integer.parseInt(Settings.get().get(binary ? Settings.PORT_BINARY : Settings.PORT, binary ? Settings.PORT_BINARY_DEFAULT : Settings.PORT_DEFAULT));\n+        int curPort = Integer.parseInt(Settings.get().get(Settings.PORT, Settings.PORT_DEFAULT));\n@@ -77,1 +70,1 @@\n-            NotifyDescriptor message = new NotifyDescriptor.Message(\"Could not create server. Listening for incoming binary data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n+            NotifyDescriptor message = new NotifyDescriptor.Message(\"Could not create server. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n@@ -93,1 +86,1 @@\n-                        RequestProcessor.getDefault().post(new Client(clientSocket, rootDocument, callback, binary), 0, Thread.MAX_PRIORITY);\n+                        RequestProcessor.getDefault().post(new Client(clientSocket, callback), 0, Thread.MAX_PRIORITY);\n@@ -96,1 +89,1 @@\n-                        NotifyDescriptor message = new NotifyDescriptor.Message(\"Error during listening for incoming connections. Listening for incoming binary data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n+                        NotifyDescriptor message = new NotifyDescriptor.Message(\"Error during listening for incoming connections. Listening for incoming data is disabled.\", NotifyDescriptor.ERROR_MESSAGE);\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Server.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,5 +38,5 @@\n-    private static SelectionCoordinator singleInstance = new SelectionCoordinator();\n-    private Set<Object> selectedObjects;\n-    private Set<Object> highlightedObjects;\n-    private ChangedEvent<SelectionCoordinator> selectedChangedEvent;\n-    private ChangedEvent<SelectionCoordinator> highlightedChangedEvent;\n+    private static final SelectionCoordinator singleInstance = new SelectionCoordinator();\n+    private final Set<Integer> selectedObjects;\n+    private final Set<Integer> highlightedObjects;\n+    private final ChangedEvent<SelectionCoordinator> selectedChangedEvent;\n+    private final ChangedEvent<SelectionCoordinator> highlightedChangedEvent;\n@@ -55,1 +55,1 @@\n-    public Set<Object> getSelectedObjects() {\n+    public Set<Integer> getSelectedObjects() {\n@@ -59,1 +59,1 @@\n-    public Set<Object> getHighlightedObjects() {\n+    public Set<Integer> getHighlightedObjects() {\n@@ -71,29 +71,0 @@\n-    public void addHighlighted(Object o) {\n-        if (!highlightedObjects.contains(o)) {\n-            highlightedObjects.add(o);\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeHighlighted(Object o) {\n-        if (highlightedObjects.contains(o)) {\n-            highlightedObjects.remove(o);\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void addAllHighlighted(Set<? extends Object> s) {\n-        int oldSize = highlightedObjects.size();\n-        highlightedObjects.addAll(s);\n-        if (oldSize != highlightedObjects.size()) {\n-            highlightedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeAllHighlighted(Set<? extends Object> s) {\n-        int oldSize = highlightedObjects.size();\n-        highlightedObjects.removeAll(s);\n-        if (oldSize != highlightedObjects.size()) {\n-            highlightedObjectsChanged();\n-        }\n-    }\n@@ -101,22 +72,1 @@\n-    private void highlightedObjectsChanged() {\n-        highlightedChangedEvent.fire();\n-\n-    }\n-\n-    public void addAllSelected(Set<? extends Object> s) {\n-        int oldSize = selectedObjects.size();\n-        selectedObjects.addAll(s);\n-        if (oldSize != selectedObjects.size()) {\n-            selectedObjectsChanged();\n-        }\n-    }\n-\n-    public void removeAllSelected(Set<? extends Object> s) {\n-        int oldSize = selectedObjects.size();\n-        selectedObjects.removeAll(s);\n-        if (oldSize != selectedObjects.size()) {\n-            selectedObjectsChanged();\n-        }\n-    }\n-\n-    public void setSelectedObjects(Set<? extends Object> s) {\n+    public void setSelectedObjects(Set<Integer> s) {\n@@ -126,5 +76,1 @@\n-        selectedObjectsChanged();\n-    }\n-\n-    private void selectedObjectsChanged() {\n-        selectedChangedEvent.fire();\n+        getSelectedChangedEvent().fire();\n@@ -133,1 +79,1 @@\n-    public void setHighlightedObjects(Set<? extends Object> s) {\n+    public void setHighlightedObjects(Set<Integer> s) {\n@@ -135,3 +81,3 @@\n-        this.highlightedObjects.clear();\n-        this.highlightedObjects.addAll(s);\n-        highlightedObjectsChanged();\n+        highlightedObjects.clear();\n+        highlightedObjects.addAll(s);\n+        getHighlightedChangedEvent().fire();\n","filename":"src\/utils\/IdealGraphVisualizer\/SelectionCoordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/selectioncoordinator\/SelectionCoordinator.java","additions":13,"deletions":67,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import com.ibm.wala.util.graph.Graph;\n+import com.ibm.wala.util.graph.dominators.Dominators;\n+import com.ibm.wala.util.graph.impl.SlowSparseNumberedGraph;\n@@ -36,3 +39,0 @@\n-import com.ibm.wala.util.graph.Graph;\n-import com.ibm.wala.util.graph.impl.SlowSparseNumberedGraph;\n-import com.ibm.wala.util.graph.dominators.Dominators;\n@@ -125,7 +125,1 @@\n-    private static final Comparator<InputEdge> edgeComparator = new Comparator<InputEdge>() {\n-\n-        @Override\n-        public int compare(InputEdge o1, InputEdge o2) {\n-            return o1.getToIndex() - o2.getToIndex();\n-        }\n-    };\n+    private static final Comparator<InputEdge> edgeComparator = Comparator.comparingInt(InputEdge::getToIndex);\n@@ -176,1 +170,1 @@\n-            Set<Node> blockTerminators = new HashSet<Node>();\n+            Set<Node> blockTerminators = new HashSet<>();\n@@ -286,1 +280,1 @@\n-        controlSuccs.put(n, Arrays.asList(s));\n+        controlSuccs.put(n, Collections.singletonList(s));\n@@ -291,1 +285,1 @@\n-        controlSuccs.put(p, Arrays.asList(n));\n+        controlSuccs.put(p, Collections.singletonList(n));\n@@ -376,16 +370,13 @@\n-    private static final Comparator<Node> schedulePriority = new Comparator<Node>(){\n-            @Override\n-            public int compare(Node n1, Node n2) {\n-                \/\/ Order by rank, then idx.\n-                int r1 = n1.rank, r2 = n2.rank;\n-                int o1, o2;\n-                if (r1 != r2) { \/\/ Different rank.\n-                    o1 = r1;\n-                    o2 = r2;\n-                } else { \/\/ Same rank, order by idx.\n-                    o1 = Integer.parseInt(n1.inputNode.getProperties().get(\"idx\"));\n-                    o2 = Integer.parseInt(n2.inputNode.getProperties().get(\"idx\"));\n-                }\n-                return Integer.compare(o1, o2);\n-            };\n-        };\n+    private static final Comparator<Node> schedulePriority = (n1, n2) -> {\n+        \/\/ Order by rank, then idx.\n+        int r1 = n1.rank, r2 = n2.rank;\n+        int o1, o2;\n+        if (r1 != r2) { \/\/ Different rank.\n+            o1 = r1;\n+            o2 = r2;\n+        } else { \/\/ Same rank, order by idx.\n+            o1 = Integer.parseInt(n1.inputNode.getProperties().get(\"idx\"));\n+            o2 = Integer.parseInt(n2.inputNode.getProperties().get(\"idx\"));\n+        }\n+        return Integer.compare(o1, o2);\n+    };\n@@ -394,1 +385,1 @@\n-        List<InputNode> schedule = new ArrayList<InputNode>();\n+        List<InputNode> schedule = new ArrayList<>();\n@@ -397,1 +388,1 @@\n-        Queue<Node> ready = new PriorityQueue<Node>(schedulePriority);\n+        Queue<Node> ready = new PriorityQueue<>(schedulePriority);\n@@ -399,1 +390,1 @@\n-        Set<Node> visited = new HashSet<Node>(nodes.size());\n+        Set<Node> visited = new HashSet<>(nodes.size());\n@@ -715,3 +706,1 @@\n-        if (root == null) {\n-            assert false : \"No root found!\";\n-        }\n+        assert root != null : \"No root found!\";\n@@ -756,1 +745,1 @@\n-                edgeMap.put(to, new ArrayList<InputEdge>());\n+                edgeMap.put(to, new ArrayList<>());\n@@ -865,1 +854,1 @@\n-                    nodesPerWarning.put(warning, new HashSet<Node>());\n+                    nodesPerWarning.put(warning, new HashSet<>());\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/java\/com\/sun\/hotspot\/igv\/servercompiler\/ServerCompilerScheduler.java","additions":26,"deletions":37,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-    public static final String PORT_BINARY = \"portBinary\";\n@@ -52,1 +51,0 @@\n-    public static final String PORT_BINARY_DEFAULT = \"4445\";\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/java\/com\/sun\/hotspot\/igv\/settings\/Settings.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    private DoubleClickHandler handler;\n+    private final DoubleClickHandler handler;\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/DoubleClickAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    public void handleDoubleClick(Widget w, WidgetMouseEvent e);\n+    void handleDoubleClick(Widget w, WidgetMouseEvent e);\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/DoubleClickHandler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,208 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.util;\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.JComponent;\n-import org.netbeans.api.visual.widget.Scene;\n-\n-\/**\n- * @author David Kaspar\n- * @author Thomas Wuerthinger\n- *\/\n-public class ExtendedSatelliteComponent extends JComponent implements MouseListener, MouseMotionListener, Scene.SceneListener, ComponentListener {\n-\n-    private Scene scene;\n-    private Image image;\n-    private int imageWidth;\n-    private int imageHeight;\n-\n-    public ExtendedSatelliteComponent(Scene scene) {\n-        this.scene = scene;\n-        setDoubleBuffered(true);\n-        setPreferredSize(new Dimension(128, 128));\n-        addMouseListener(this);\n-        addMouseMotionListener(this);\n-    }\n-\n-    @Override\n-    public void addNotify() {\n-        super.addNotify();\n-        scene.addSceneListener(this);\n-        JComponent viewComponent = scene.getView();\n-        if (viewComponent == null) {\n-            viewComponent = scene.createView();\n-        }\n-        viewComponent.addComponentListener(this);\n-        repaint();\n-    }\n-\n-    @Override\n-    public void removeNotify() {\n-        scene.getView().removeComponentListener(this);\n-        scene.removeSceneListener(this);\n-        super.removeNotify();\n-    }\n-\n-    public void update() {\n-        this.image = null;\n-        repaint();\n-    }\n-\n-    @Override\n-    public void paint(Graphics g) {\n-        Graphics2D gr = (Graphics2D) g;\n-        super.paint(g);\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-\n-        if (image == null || vw != imageWidth || vh != imageHeight) {\n-\n-            imageWidth = vw;\n-            imageHeight = vh;\n-            image = this.createImage(imageWidth, imageHeight);\n-            Graphics2D ig = (Graphics2D) image.getGraphics();\n-            ig.scale(scale, scale);\n-            scene.paint(ig);\n-        }\n-\n-        gr.drawImage(image, vx, vy, this);\n-\n-        JComponent component = scene.getView();\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle viewRectangle = component != null ? component.getVisibleRect() : null;\n-        if (viewRectangle != null) {\n-            Rectangle window = new Rectangle(\n-                    (int) ((double) viewRectangle.x * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.y * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.width * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.height * scale \/ zoomFactor));\n-            window.translate(vx, vy);\n-            gr.setColor(new Color(200, 200, 200, 128));\n-            gr.fill(window);\n-            gr.setColor(Color.BLACK);\n-            gr.drawRect(window.x, window.y, window.width - 1, window.height - 1);\n-        }\n-    }\n-\n-    @Override\n-    public void mouseClicked(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mousePressed(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseReleased(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseEntered(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseExited(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseDragged(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseMoved(MouseEvent e) {\n-    }\n-\n-    private void moveVisibleRect(Point center) {\n-        JComponent component = scene.getView();\n-        if (component == null) {\n-            return;\n-        }\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-        int cx = (int) ((double) (center.x - vx) \/ scale * zoomFactor);\n-        int cy = (int) ((double) (center.y - vy) \/ scale * zoomFactor);\n-\n-        Rectangle visibleRect = component.getVisibleRect();\n-        visibleRect.x = cx - visibleRect.width \/ 2;\n-        visibleRect.y = cy - visibleRect.height \/ 2;\n-        component.scrollRectToVisible(visibleRect);\n-\n-    }\n-\n-    @Override\n-    public void sceneRepaint() {\n-    }\n-\n-    @Override\n-    public void sceneValidating() {\n-    }\n-\n-    @Override\n-    public void sceneValidated() {\n-    }\n-\n-    @Override\n-    public void componentResized(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentMoved(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentShown(ComponentEvent e) {\n-    }\n-\n-    @Override\n-    public void componentHidden(ComponentEvent e) {\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/ExtendedSatelliteComponent.java","additions":0,"deletions":208,"binary":false,"changes":208,"status":"deleted"},{"patch":"@@ -41,1 +41,1 @@\n-    private static Map<Class, LookupHistoryImpl> cache = new HashMap<>();\n+    private static final Map<Class, LookupHistoryImpl> cache = new HashMap<>();\n@@ -45,2 +45,2 @@\n-        private Class<T> klass;\n-        private Result<T> result;\n+        private final Class<T> klass;\n+        private final Result<T> result;\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/LookupHistory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.hotspot.igv.util.StringUtils;\n@@ -48,1 +47,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/PropertiesConverter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -52,1 +51,1 @@\n-                public String getValue() throws IllegalAccessException, InvocationTargetException {\n+                public String getValue() {\n@@ -62,1 +61,1 @@\n-                public void setValue(String arg0) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n+                public void setValue(String arg0) throws IllegalArgumentException {\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/PropertiesSheet.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.awt.geom.*;\n@@ -33,0 +32,2 @@\n+import java.awt.geom.Ellipse2D;\n+import java.awt.geom.Rectangle2D;\n@@ -34,1 +35,4 @@\n-import javax.swing.*;\n+import javax.swing.JComponent;\n+import javax.swing.JViewport;\n+import javax.swing.Scrollable;\n+import javax.swing.SwingConstants;\n@@ -55,1 +59,1 @@\n-    private RangeSliderModel model;\n+    private final RangeSliderModel model;\n@@ -58,1 +62,4 @@\n-    private RangeSliderModel tempModel;\n+    private boolean tempModel = false;\n+    private int tempFirstPos;\n+    private int tempSecondPos;\n+\n@@ -69,1 +76,1 @@\n-    public RangeSlider() {\n+    public RangeSlider(RangeSliderModel newModel) {\n@@ -73,7 +80,0 @@\n-    }\n-\n-    public void setModel(RangeSliderModel newModel) {\n-        if (model != null) {\n-            model.getChangedEvent().removeListener(this);\n-            model.getColorChangedEvent().removeListener(this);\n-        }\n@@ -88,3 +88,3 @@\n-    private RangeSliderModel getPaintingModel() {\n-        if (tempModel != null) {\n-            return tempModel;\n+    private int getFirstPos() {\n+        if (tempModel) {\n+            return tempFirstPos;\n@@ -92,1 +92,8 @@\n-        return model;\n+        return model.getFirstPosition();\n+    }\n+\n+    private int getSecondPos() {\n+        if (tempModel) {\n+            return tempSecondPos;\n+        }\n+        return model.getSecondPosition();\n@@ -136,1 +143,1 @@\n-        d.width = Math.max(d.width, (int)(2 * BAR_CIRCLE_CONNECTOR_SIZE + getPaintingModel().getPositions().size() * (BAR_CIRCLE_SIZE + BAR_CIRCLE_CONNECTOR_SIZE)));\n+        d.width = Math.max(d.width, (int)(2 * BAR_CIRCLE_CONNECTOR_SIZE + model.getPositions().size() * (BAR_CIRCLE_SIZE + BAR_CIRCLE_CONNECTOR_SIZE)));\n@@ -143,1 +150,0 @@\n-\n@@ -158,1 +164,1 @@\n-        assert index >= 0 && index < getPaintingModel().getPositions().size();\n+        assert index >= 0 && index < model.getPositions().size();\n@@ -163,1 +169,1 @@\n-        int size = getPaintingModel().getPositions().size();\n+        int size = model.getPositions().size();\n@@ -189,1 +195,1 @@\n-        if (getPaintingModel() == null || getPaintingModel().getPositions().size() == 0) {\n+        if (model == null || model.getPositions().size() == 0) {\n@@ -193,2 +199,2 @@\n-        int firstPos = getPaintingModel().getFirstPosition();\n-        int secondPos = getPaintingModel().getSecondPosition();\n+        int firstPos = getFirstPos();\n+        int secondPos = getSecondPos();\n@@ -202,1 +208,1 @@\n-        return getHeight() \/ 2 - BAR_HEIGHT \/ 2;\n+        return getHeight() \/ 2.0f - BAR_HEIGHT \/ 2.0f;\n@@ -206,1 +212,1 @@\n-        List<String> list = getPaintingModel().getPositions();\n+        List<String> list = model.getPositions();\n@@ -215,1 +221,1 @@\n-            g.setColor(getPaintingModel().getColors().get(i));\n+            g.setColor(model.getColors().get(i));\n@@ -229,1 +235,1 @@\n-                    g.drawString(curS, startX + (endX - startX) \/ 2 - bounds.width \/ 2, barStartY \/ 2 + bounds.height \/ 2);\n+                    g.drawString(curS, (startX + (endX - startX) \/ 2.0f - bounds.width \/ 2.0f), barStartY \/ 2.0f + bounds.height \/ 2.0f);\n@@ -261,1 +267,1 @@\n-            float destX = getEndXPosition(getPaintingModel().getSecondPosition());\n+            float destX = getEndXPosition(getSecondPos());\n@@ -270,1 +276,1 @@\n-            float destX = getStartXPosition(getPaintingModel().getFirstPosition());\n+            float destX = getStartXPosition(getFirstPos());\n@@ -279,1 +285,1 @@\n-            return p.x > getStartXPosition(getPaintingModel().getFirstPosition()) && p.x < getEndXPosition(getPaintingModel().getSecondPosition());\n+            return p.x > getStartXPosition(getFirstPos()) && p.x < getEndXPosition(getSecondPos());\n@@ -292,3 +298,3 @@\n-            int newIndex = getIndexFromPosition(newFirstX) + 1;\n-            if (newIndex + model.getSecondPosition() - model.getFirstPosition() >= model.getPositions().size()) {\n-                newIndex = model.getPositions().size() - (model.getSecondPosition() - model.getFirstPosition()) - 1;\n+            tempFirstPos = getIndexFromPosition(newFirstX) + 1;\n+            if (tempFirstPos + model.getSecondPosition() - model.getFirstPosition() >= model.getPositions().size()) {\n+                tempFirstPos = model.getPositions().size() - (model.getSecondPosition() - model.getFirstPosition()) - 1;\n@@ -296,2 +302,1 @@\n-            int secondPosition = newIndex + model.getSecondPosition() - model.getFirstPosition();\n-            tempModel.setPositions(newIndex, secondPosition);\n+            tempSecondPos = tempFirstPos + model.getSecondPosition() - model.getFirstPosition();\n@@ -300,4 +305,4 @@\n-            int firstPosition = getIndexFromPosition(e.getPoint().x) + 1;\n-            int secondPosition = model.getSecondPosition();\n-            if (firstPosition > secondPosition) {\n-                firstPosition--;\n+            tempFirstPos = getIndexFromPosition(e.getPoint().x) + 1;\n+            tempSecondPos = model.getSecondPosition();\n+            if (tempFirstPos > tempSecondPos) {\n+                tempFirstPos--;\n@@ -305,1 +310,0 @@\n-            tempModel.setPositions(firstPosition, secondPosition);\n@@ -308,4 +312,4 @@\n-            int firstPosition = model.getFirstPosition();\n-            int secondPosition = getIndexFromPosition(e.getPoint().x);\n-            if (secondPosition < firstPosition) {\n-                secondPosition++;\n+            tempFirstPos = model.getFirstPosition();\n+            tempSecondPos = getIndexFromPosition(e.getPoint().x);\n+            if (tempSecondPos < tempFirstPos) {\n+                tempSecondPos++;\n@@ -313,1 +317,0 @@\n-            tempModel.setPositions(firstPosition, secondPosition);\n@@ -322,1 +325,1 @@\n-        for (int i = 0; i < getPaintingModel().getPositions().size() - 1; i++) {\n+        for (int i = 0; i < model.getPositions().size() - 1; i++) {\n@@ -329,1 +332,1 @@\n-        return getPaintingModel().getPositions().size() - 1;\n+        return model.getPositions().size() - 1;\n@@ -334,1 +337,1 @@\n-        for (int i = 1; i < getPaintingModel().getPositions().size(); i++) {\n+        for (int i = 1; i < model.getPositions().size(); i++) {\n@@ -348,2 +351,0 @@\n-\n-\n@@ -389,1 +390,1 @@\n-        tempModel = model.copy();\n+        tempModel = true;\n@@ -394,1 +395,1 @@\n-        if (model == null || tempModel == null) {\n+        if (model == null || !tempModel) {\n@@ -398,2 +399,2 @@\n-        model.setPositions(tempModel.getFirstPosition(), tempModel.getSecondPosition());\n-        tempModel = null;\n+        model.setPositions(tempFirstPos, tempSecondPos);\n+        tempModel = false;\n@@ -403,2 +404,1 @@\n-    public void mouseEntered(MouseEvent e) {\n-    }\n+    public void mouseEntered(MouseEvent e) { }\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/RangeSlider.java","additions":57,"deletions":57,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-    private ChangedEvent<RangeSliderModel> changedEvent;\n-    private ChangedEvent<RangeSliderModel> colorChangedEvent;\n+    private final ChangedEvent<RangeSliderModel> changedEvent;\n+    private final ChangedEvent<RangeSliderModel> colorChangedEvent;\n@@ -49,2 +49,1 @@\n-        boolean changed = false;\n-        changed |= (positions != model.positions);\n+        boolean changed = (positions != model.positions);\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/RangeSliderModel.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-     *\n+     * <p>\n","filename":"src\/utils\/IdealGraphVisualizer\/Util\/src\/main\/java\/com\/sun\/hotspot\/igv\/util\/StringUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -28,0 +27,1 @@\n+import com.sun.hotspot.igv.data.InputGraph;\n@@ -32,1 +32,0 @@\n-import java.util.List;\n@@ -34,0 +33,1 @@\n+import java.util.List;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/BlockQuickSearch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-import java.awt.event.*;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseWheelListener;\n@@ -73,9 +75,9 @@\n-    private CustomizablePanAction panAction;\n-    private WidgetAction hoverAction;\n-    private WidgetAction selectAction;\n-    private Lookup lookup;\n-    private InstanceContent content;\n-    private Action[] actions;\n-    private Action[] actionsWithSelection;\n-    private LayerWidget connectionLayer;\n-    private JScrollPane scrollPane;\n+    private final CustomizablePanAction panAction;\n+    private final WidgetAction hoverAction;\n+    private final WidgetAction selectAction;\n+    private final Lookup lookup;\n+    private final InstanceContent content;\n+    private final Action[] actions;\n+    private final Action[] actionsWithSelection;\n+    private final LayerWidget connectionLayer;\n+    private final JScrollPane scrollPane;\n@@ -83,2 +85,2 @@\n-    private LayerWidget mainLayer;\n-    private LayerWidget blockLayer;\n+    private final LayerWidget mainLayer;\n+    private final LayerWidget blockLayer;\n@@ -88,0 +90,3 @@\n+    private boolean undoRedoEnabled = true;\n+\n+\n@@ -107,19 +112,0 @@\n-    private PopupMenuProvider popupMenuProvider = new PopupMenuProvider() {\n-\n-        @Override\n-        public JPopupMenu getPopupMenu(Widget widget, Point localLocation) {\n-            return DiagramScene.this.createPopupMenu();\n-        }\n-    };\n-\n-    private RectangularSelectDecorator rectangularSelectDecorator = new RectangularSelectDecorator() {\n-\n-        @Override\n-        public Widget createSelectionWidget() {\n-            Widget widget = new Widget(DiagramScene.this);\n-            widget.setBorder(BorderFactory.createLineBorder(Color.black, 2));\n-            widget.setForeground(Color.red);\n-            return widget;\n-        }\n-    };\n-\n@@ -128,1 +114,1 @@\n-        Widget w = this.findWidget(o);\n+        Widget w = findWidget(o);\n@@ -134,1 +120,1 @@\n-        Widget w = this.findWidget(o);\n+        Widget w = findWidget(o);\n@@ -138,9 +124,0 @@\n-    private static boolean intersects(Set<? extends Object> s1, Set<? extends Object> s2) {\n-        for (Object o : s1) {\n-            if (s2.contains(o)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -148,2 +125,2 @@\n-        double factorWidth = getScrollPane().getViewport().getViewRect().getWidth() \/ getBounds().getWidth() ;\n-        double factorHeight = getScrollPane().getViewport().getViewRect().getHeight() \/ getBounds().getHeight();\n+        double factorWidth = scrollPane.getViewport().getViewRect().getWidth() \/ getBounds().getWidth() ;\n+        double factorHeight = scrollPane.getViewport().getViewRect().getHeight() \/ getBounds().getHeight();\n@@ -216,3 +193,2 @@\n-\n-        boolean b = getUndoRedoEnabled();\n-        setUndoRedoEnabled(false);\n+        boolean enableUndoRedo = undoRedoEnabled;\n+        undoRedoEnabled = false;\n@@ -220,1 +196,1 @@\n-        setUndoRedoEnabled(b);\n+        undoRedoEnabled = enableUndoRedo;\n@@ -223,16 +199,1 @@\n-    private Set<Object> getObjectsFromIdSet(Set<Object> set) {\n-        Set<Object> selectedObjects = new HashSet<>();\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            if (intersects(f.getSource().getSourceNodesAsSet(), set)) {\n-                selectedObjects.add(f);\n-            }\n-\n-            for (Slot s : f.getSlots()) {\n-                if (intersects(s.getSource().getSourceNodesAsSet(), set)) {\n-                    selectedObjects.add(s);\n-                }\n-            }\n-        }\n-        return selectedObjects;\n-    }\n-    private ControllableChangedListener<SelectionCoordinator> highlightedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n+    private final ControllableChangedListener<SelectionCoordinator> highlightedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n@@ -242,2 +203,2 @@\n-            DiagramScene.this.setHighlightedObjects(getObjectsFromIdSet(source.getHighlightedObjects()));\n-            DiagramScene.this.validate();\n+            setHighlightedObjects(idSetToObjectSet(source.getHighlightedObjects()));\n+            validate();\n@@ -246,1 +207,1 @@\n-    private ControllableChangedListener<SelectionCoordinator> selectedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n+    private final ControllableChangedListener<SelectionCoordinator> selectedCoordinatorListener = new ControllableChangedListener<SelectionCoordinator>() {\n@@ -250,2 +211,2 @@\n-            DiagramScene.this.gotoSelection(source.getSelectedObjects());\n-            DiagramScene.this.validate();\n+            gotoSelection(source.getSelectedObjects());\n+            validate();\n@@ -255,45 +216,2 @@\n-    private RectangularSelectProvider rectangularSelectProvider = new RectangularSelectProvider() {\n-\n-        @Override\n-        public void performSelection(Rectangle rectangle) {\n-            if (rectangle.width < 0) {\n-                rectangle.x += rectangle.width;\n-                rectangle.width *= -1;\n-            }\n-\n-            if (rectangle.height < 0) {\n-                rectangle.y += rectangle.height;\n-                rectangle.height *= -1;\n-            }\n-\n-            Set<Object> selectedObjects = new HashSet<>();\n-            for (Figure f : getModel().getDiagramToView().getFigures()) {\n-                FigureWidget w = getWidget(f);\n-                if (w != null) {\n-                    Rectangle r = new Rectangle(w.getBounds());\n-                    r.setLocation(w.getLocation());\n-\n-                    if (r.intersects(rectangle)) {\n-                        selectedObjects.add(f);\n-                    }\n-\n-                    for (Slot s : f.getSlots()) {\n-                        SlotWidget sw = getWidget(s);\n-                        Rectangle r2 = new Rectangle(sw.getBounds());\n-                        r2.setLocation(sw.convertLocalToScene(new Point(0, 0)));\n-\n-                        if (r2.intersects(rectangle)) {\n-                            selectedObjects.add(s);\n-                        }\n-                    }\n-                } else {\n-                    assert false : \"w should not be null here!\";\n-                }\n-            }\n-\n-            setSelectedObjects(selectedObjects);\n-        }\n-    };\n-\n-    public Point getScrollPosition() {\n-        return getScrollPane().getViewport().getViewPosition();\n+    private Point getScrollPosition() {\n+        return scrollPane.getViewport().getViewPosition();\n@@ -302,2 +220,2 @@\n-    public void setScrollPosition(Point p) {\n-        getScrollPane().getViewport().setViewPosition(p);\n+    private void setScrollPosition(Point p) {\n+        scrollPane.getViewport().setViewPosition(p);\n@@ -337,88 +255,0 @@\n-    private ObjectSceneListener selectionChangedListener = new ObjectSceneListener() {\n-\n-        @Override\n-        public void objectAdded(ObjectSceneEvent arg0, Object arg1) {\n-        }\n-\n-        @Override\n-        public void objectRemoved(ObjectSceneEvent arg0, Object arg1) {\n-        }\n-\n-        @Override\n-        public void objectStateChanged(ObjectSceneEvent e, Object o, ObjectState oldState, ObjectState newState) {\n-        }\n-\n-        @Override\n-        public void selectionChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n-            DiagramScene scene = (DiagramScene) e.getObjectScene();\n-            if (scene.isRebuilding()) {\n-                return;\n-            }\n-\n-            content.set(newSet, null);\n-\n-            Set<Integer> nodeSelection = new HashSet<>();\n-            for (Object o : newSet) {\n-                if (o instanceof Properties.Provider) {\n-                    final Properties.Provider provider = (Properties.Provider) o;\n-                    AbstractNode node = new AbstractNode(Children.LEAF) {\n-\n-                        @Override\n-                        protected Sheet createSheet() {\n-                            Sheet s = super.createSheet();\n-                            PropertiesSheet.initializeSheet(provider.getProperties(), s);\n-                            return s;\n-                        }\n-                    };\n-                    node.setDisplayName(provider.getProperties().get(\"name\"));\n-                    content.add(node);\n-                }\n-\n-\n-                if (o instanceof Figure) {\n-                    nodeSelection.addAll(((Figure) o).getSource().getSourceNodesAsSet());\n-                } else if (o instanceof Slot) {\n-                    nodeSelection.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n-                }\n-            }\n-            getModel().setSelectedNodes(nodeSelection);\n-\n-            boolean b = selectedCoordinatorListener.isEnabled();\n-            selectedCoordinatorListener.setEnabled(false);\n-            SelectionCoordinator.getInstance().setSelectedObjects(nodeSelection);\n-            selectedCoordinatorListener.setEnabled(b);\n-\n-        }\n-\n-        @Override\n-        public void highlightingChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n-            Set<Integer> nodeHighlighting = new HashSet<>();\n-            for (Object o : newSet) {\n-                if (o instanceof Figure) {\n-                    nodeHighlighting.addAll(((Figure) o).getSource().getSourceNodesAsSet());\n-                } else if (o instanceof Slot) {\n-                    nodeHighlighting.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n-                }\n-            }\n-            boolean b = highlightedCoordinatorListener.isEnabled();\n-            highlightedCoordinatorListener.setEnabled(false);\n-            SelectionCoordinator.getInstance().setHighlightedObjects(nodeHighlighting);\n-            highlightedCoordinatorListener.setEnabled(true);\n-        }\n-\n-        @Override\n-        public void hoverChanged(ObjectSceneEvent e, Object oldObject, Object newObject) {\n-            Set<Object> newHighlightedObjects = new HashSet<>(DiagramScene.this.getHighlightedObjects());\n-            if (oldObject != null) {\n-                newHighlightedObjects.remove(oldObject);\n-            }\n-            if (newObject != null) {\n-                newHighlightedObjects.add(newObject);\n-            }\n-            DiagramScene.this.setHighlightedObjects(newHighlightedObjects);\n-        }\n-\n-        @Override\n-        public void focusChanged(ObjectSceneEvent arg0, Object arg1, Object arg2) {\n-        }\n-    };\n@@ -427,1 +257,0 @@\n-\n@@ -434,1 +263,1 @@\n-        this.setCheckClipping(true);\n+        setCheckClipping(true);\n@@ -445,1 +274,1 @@\n-        this.getActions().addAction(panAction);\n+        getActions().addAction(panAction);\n@@ -474,1 +303,1 @@\n-        this.getActions().addAction(selectAction);\n+        getActions().addAction(selectAction);\n@@ -477,1 +306,1 @@\n-        this.addChild(blockLayer);\n+        addChild(blockLayer);\n@@ -480,1 +309,1 @@\n-        this.addChild(connectionLayer);\n+        addChild(connectionLayer);\n@@ -483,1 +312,1 @@\n-        this.addChild(mainLayer);\n+        addChild(mainLayer);\n@@ -485,4 +314,4 @@\n-        this.setBorder(BorderFactory.createLineBorder(Color.white, BORDER_SIZE));\n-        this.setLayout(LayoutFactory.createAbsoluteLayout());\n-        this.getActions().addAction(mouseZoomAction);\n-        this.getActions().addAction(ActionFactory.createPopupMenuAction(popupMenuProvider));\n+        setBorder(BorderFactory.createLineBorder(Color.white, BORDER_SIZE));\n+        setLayout(LayoutFactory.createAbsoluteLayout());\n+        getActions().addAction(mouseZoomAction);\n+        getActions().addAction(ActionFactory.createPopupMenuAction((widget, localLocation) -> createPopupMenu()));\n@@ -491,8 +320,138 @@\n-        this.addChild(selectLayer);\n-        this.getActions().addAction(ActionFactory.createRectangularSelectAction(rectangularSelectDecorator, selectLayer, rectangularSelectProvider));\n-\n-        boolean b = this.getUndoRedoEnabled();\n-        this.setUndoRedoEnabled(false);\n-        this.setNewModel(model);\n-        this.setUndoRedoEnabled(b);\n-        this.addObjectSceneListener(selectionChangedListener, ObjectSceneEventType.OBJECT_SELECTION_CHANGED, ObjectSceneEventType.OBJECT_HIGHLIGHTING_CHANGED, ObjectSceneEventType.OBJECT_HOVER_CHANGED);\n+        addChild(selectLayer);\n+        RectangularSelectDecorator rectangularSelectDecorator = () -> {\n+            Widget widget = new Widget(DiagramScene.this);\n+            widget.setBorder(BorderFactory.createLineBorder(Color.black, 2));\n+            widget.setForeground(Color.red);\n+            return widget;\n+        };\n+        RectangularSelectProvider rectangularSelectProvider = rectangle -> {\n+            if (rectangle.width < 0) {\n+                rectangle.x += rectangle.width;\n+                rectangle.width *= -1;\n+            }\n+\n+            if (rectangle.height < 0) {\n+                rectangle.y += rectangle.height;\n+                rectangle.height *= -1;\n+            }\n+\n+            Set<Object> selectedObjects = new HashSet<>();\n+            for (Figure f : getModel().getDiagram().getFigures()) {\n+                FigureWidget w = getWidget(f);\n+                if (w != null) {\n+                    assert w.getBounds() != null;\n+                    Rectangle r = new Rectangle(w.getBounds());\n+                    r.setLocation(w.getLocation());\n+\n+                    if (r.intersects(rectangle)) {\n+                        selectedObjects.add(f);\n+                    }\n+\n+                    for (Slot s : f.getSlots()) {\n+                        SlotWidget sw = getWidget(s);\n+                        assert sw.getBounds() != null;\n+                        Rectangle r2 = new Rectangle(sw.getBounds());\n+                        r2.setLocation(sw.convertLocalToScene(new Point(0, 0)));\n+\n+                        if (r2.intersects(rectangle)) {\n+                            selectedObjects.add(s);\n+                        }\n+                    }\n+                } else {\n+                    assert false : \"w should not be null here!\";\n+                }\n+            }\n+\n+            setSelectedObjects(selectedObjects);\n+        };\n+        getActions().addAction(ActionFactory.createRectangularSelectAction(rectangularSelectDecorator, selectLayer, rectangularSelectProvider));\n+\n+        boolean enableUndoRedo = undoRedoEnabled;\n+        undoRedoEnabled = false;\n+        setNewModel(model);\n+        undoRedoEnabled = enableUndoRedo;\n+        ObjectSceneListener selectionChangedListener = new ObjectSceneListener() {\n+\n+            @Override\n+            public void objectAdded(ObjectSceneEvent arg0, Object arg1) {}\n+\n+            @Override\n+            public void objectRemoved(ObjectSceneEvent arg0, Object arg1) {}\n+\n+            @Override\n+            public void objectStateChanged(ObjectSceneEvent e, Object o, ObjectState oldState, ObjectState newState) {}\n+\n+            @Override\n+            public void selectionChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n+                DiagramScene scene = (DiagramScene) e.getObjectScene();\n+                if (scene.isRebuilding()) {\n+                    return;\n+                }\n+\n+                content.set(newSet, null);\n+\n+                Set<Integer> nodeSelection = new HashSet<>();\n+                for (Object o : newSet) {\n+                    if (o instanceof Properties.Provider) {\n+                        final Properties.Provider provider = (Properties.Provider) o;\n+                        AbstractNode node = new AbstractNode(Children.LEAF) {\n+\n+                            @Override\n+                            protected Sheet createSheet() {\n+                                Sheet s = super.createSheet();\n+                                PropertiesSheet.initializeSheet(provider.getProperties(), s);\n+                                return s;\n+                            }\n+                        };\n+                        node.setDisplayName(provider.getProperties().get(\"name\"));\n+                        content.add(node);\n+                    }\n+\n+\n+                    if (o instanceof Figure) {\n+                        nodeSelection.add(((Figure) o).getInputNode().getId());\n+                    } else if (o instanceof Slot) {\n+                        nodeSelection.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n+                    }\n+                }\n+                getModel().setSelectedNodes(nodeSelection);\n+\n+                boolean b = selectedCoordinatorListener.isEnabled();\n+                selectedCoordinatorListener.setEnabled(false);\n+                SelectionCoordinator.getInstance().setSelectedObjects(nodeSelection);\n+                selectedCoordinatorListener.setEnabled(b);\n+\n+            }\n+\n+            @Override\n+            public void highlightingChanged(ObjectSceneEvent e, Set<Object> oldSet, Set<Object> newSet) {\n+                Set<Integer> nodeHighlighting = new HashSet<>();\n+                for (Object o : newSet) {\n+                    if (o instanceof Figure) {\n+                        nodeHighlighting.add(((Figure) o).getInputNode().getId());\n+                    } else if (o instanceof Slot) {\n+                        nodeHighlighting.addAll(((Slot) o).getSource().getSourceNodesAsSet());\n+                    }\n+                }\n+                highlightedCoordinatorListener.setEnabled(false);\n+                SelectionCoordinator.getInstance().setHighlightedObjects(nodeHighlighting);\n+                highlightedCoordinatorListener.setEnabled(true);\n+            }\n+\n+            @Override\n+            public void hoverChanged(ObjectSceneEvent e, Object oldObject, Object newObject) {\n+                Set<Object> newHighlightedObjects = new HashSet<>(getHighlightedObjects());\n+                if (oldObject != null) {\n+                    newHighlightedObjects.remove(oldObject);\n+                }\n+                if (newObject != null) {\n+                    newHighlightedObjects.add(newObject);\n+                }\n+                setHighlightedObjects(newHighlightedObjects);\n+            }\n+\n+            @Override\n+            public void focusChanged(ObjectSceneEvent arg0, Object arg1, Object arg2) {\n+            }\n+        };\n+        addObjectSceneListener(selectionChangedListener, ObjectSceneEventType.OBJECT_SELECTION_CHANGED, ObjectSceneEventType.OBJECT_HIGHLIGHTING_CHANGED, ObjectSceneEventType.OBJECT_HOVER_CHANGED);\n@@ -505,4 +464,0 @@\n-    public JScrollPane getScrollPane() {\n-        return scrollPane;\n-    }\n-\n@@ -527,1 +482,1 @@\n-        final boolean hidden = !this.getWidget(f, FigureWidget.class).isVisible();\n+        final boolean hidden = !getWidget(f, FigureWidget.class).isVisible();\n@@ -560,1 +515,1 @@\n-    public void setNewModel(DiagramViewModel model) {\n+    private void setNewModel(DiagramViewModel model) {\n@@ -578,1 +533,1 @@\n-        Collection<Object> objects = new ArrayList<>(this.getObjects());\n+        Collection<Object> objects = new ArrayList<>(getObjects());\n@@ -580,1 +535,1 @@\n-            this.removeObject(o);\n+            removeObject(o);\n@@ -583,1 +538,1 @@\n-        Diagram d = getModel().getDiagramToView();\n+        Diagram d = getModel().getDiagram();\n@@ -586,1 +541,1 @@\n-        for (InputBlock b : d.getGraph().getBlocks()) {\n+        for (InputBlock b : d.getInputBlocks()) {\n@@ -593,2 +548,2 @@\n-            if (f.getWidth() > maxWidth.get(f.getBlock())) {\n-                maxWidth.put(f.getBlock(), f.getWidth());\n+            if (f.getWidth() > maxWidth.get(f.getBlock().getInputBlock())) {\n+                maxWidth.put(f.getBlock().getInputBlock(), f.getWidth());\n@@ -599,1 +554,0 @@\n-\n@@ -602,1 +556,1 @@\n-                f.setWidth(maxWidth.get(f.getBlock()));\n+                f.setWidth(maxWidth.get(f.getBlock().getInputBlock()));\n@@ -611,1 +565,1 @@\n-            this.addObject(f, w);\n+            addObject(f, w);\n@@ -631,1 +585,1 @@\n-            for (InputBlock bn : d.getGraph().getBlocks()) {\n+            for (InputBlock bn : d.getInputBlocks()) {\n@@ -634,1 +588,1 @@\n-                this.addObject(bn, w);\n+                addObject(bn, w);\n@@ -640,1 +594,1 @@\n-        this.smallUpdate(true);\n+        smallUpdate(true);\n@@ -643,1 +597,1 @@\n-    public boolean isRebuilding() {\n+    protected boolean isRebuilding() {\n@@ -648,5 +602,5 @@\n-        this.updateHiddenNodes(model.getHiddenNodes(), relayout);\n-        boolean b = this.getUndoRedoEnabled();\n-        this.setUndoRedoEnabled(false);\n-        this.setUndoRedoEnabled(b);\n-        this.validate();\n+        updateHiddenNodes(model.getHiddenNodes(), relayout);\n+        boolean enableUndoRedo = undoRedoEnabled;\n+        undoRedoEnabled = false;\n+        undoRedoEnabled = enableUndoRedo;\n+        validate();\n@@ -675,1 +629,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -697,1 +651,1 @@\n-            doClusteredLayout(figures, edges);\n+            doClusteredLayout(edges);\n@@ -711,1 +665,1 @@\n-    private void doClusteredLayout(HashSet<Figure> figures, HashSet<Connection> edges) {\n+    private void doClusteredLayout(HashSet<Connection> edges) {\n@@ -718,1 +672,1 @@\n-        m.doLayout(new LayoutGraph(edges, figures));\n+        m.doLayout(new LayoutGraph(edges));\n@@ -722,1 +676,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -731,1 +685,1 @@\n-        Map<InputNode, Figure> nodeFig = new HashMap<InputNode, Figure>();\n+        Map<InputNode, Figure> nodeFig = new HashMap<>();\n@@ -733,1 +687,1 @@\n-            InputNode n = f.getFirstSourceNode();\n+            InputNode n = f.getInputNode();\n@@ -741,2 +695,1 @@\n-        Map<Figure, Integer> figureRank =\n-            new HashMap<Figure, Integer>(figures.size());\n+        Map<Figure, Integer> figureRank = new HashMap<>(figures.size());\n@@ -744,1 +697,1 @@\n-        for (InputBlock b : getModel().getGraphToView().getBlocks()) {\n+        for (InputBlock b : diagram.getInputBlocks()) {\n@@ -775,1 +728,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -777,1 +730,1 @@\n-        SceneAnimator animator = this.getSceneAnimator();\n+        SceneAnimator animator = getSceneAnimator();\n@@ -842,1 +795,1 @@\n-        this.validate();\n+        validate();\n@@ -846,1 +799,1 @@\n-    private void processOutputSlot(Set<Pair<Point, Point>> lastLineCache, OutputSlot s, List<Connection> connections, int controlPointIndex, Point lastPoint, LineWidget predecessor, int offx, int offy, SceneAnimator animator) {\n+    private void processOutputSlot(Set<Pair<Point, Point>> lastLineCache, OutputSlot outputSlot, List<Connection> connections, int controlPointIndex, Point lastPoint, LineWidget predecessor, int offx, int offy, SceneAnimator animator) {\n@@ -864,1 +817,1 @@\n-                if (controlPointIndex == 0 && !s.shouldShowName()) {\n+                if (controlPointIndex == 0 && !outputSlot.shouldShowName()) {\n@@ -905,3 +858,1 @@\n-            if (p == specialNullPoint) {\n-            } else if (lastPoint == specialNullPoint) {\n-            } else if (lastPoint != null) {\n+            if (p != specialNullPoint && lastPoint != specialNullPoint && lastPoint != null) {\n@@ -916,2 +867,2 @@\n-                LineWidget w = new LineWidget(this, s, connectionList, p1, p2, predecessor, curAnimator, isBold, isDashed);\n-                w.setVisible(isVisible);\n+                LineWidget lineWidget = new LineWidget(this, outputSlot, connectionList, p1, p2, predecessor, curAnimator, isBold, isDashed);\n+                lineWidget.setVisible(isVisible);\n@@ -920,4 +871,4 @@\n-                newPredecessor = w;\n-                connectionLayer.addChild(w);\n-                this.addObject(new ConnectionSet(connectionList), w);\n-                w.getActions().addAction(hoverAction);\n+                newPredecessor = lineWidget;\n+                connectionLayer.addChild(lineWidget);\n+                addObject(new ConnectionSet(connectionList), lineWidget);\n+                lineWidget.getActions().addAction(hoverAction);\n@@ -926,1 +877,1 @@\n-            processOutputSlot(lastLineCache, s, connectionList, controlPointIndex + 1, p, newPredecessor, offx, offy, animator);\n+            processOutputSlot(lastLineCache, outputSlot, connectionList, controlPointIndex + 1, p, newPredecessor, offx, offy, animator);\n@@ -955,1 +906,1 @@\n-    public void gotoFigures(final List<Figure> figures) {\n+    private void gotoFigures(final List<Figure> figures) {\n@@ -964,0 +915,1 @@\n+                assert r != null;\n@@ -978,1 +930,1 @@\n-    public void gotoBlock(final Block block) {\n+    private void gotoBlock(final Block block) {\n@@ -985,2 +937,1 @@\n-    private Set<Object> idSetToObjectSet(Set<Object> ids) {\n-\n+    private Set<Object> idSetToObjectSet(Set<Integer> ids) {\n@@ -988,2 +939,2 @@\n-        for (Figure f : getModel().getDiagramToView().getFigures()) {\n-            if (DiagramScene.doesIntersect(f.getSource().getSourceNodesAsSet(), ids)) {\n+        for (Figure f : getModel().getDiagram().getFigures()) {\n+            if (ids.contains(f.getInputNode().getId())) {\n@@ -994,1 +945,1 @@\n-                if (DiagramScene.doesIntersect(s.getSource().getSourceNodesAsSet(), ids)) {\n+                if (!Collections.disjoint(s.getSource().getSourceNodesAsSet(), ids)) {\n@@ -1002,1 +953,1 @@\n-    public void gotoSelection(Set<Object> ids) {\n+    private void gotoSelection(Set<Integer> ids) {\n@@ -1005,1 +956,1 @@\n-        Set<Integer> hiddenNodes = new HashSet<>(this.getModel().getHiddenNodes());\n+        Set<Integer> hiddenNodes = new HashSet<>(getModel().getHiddenNodes());\n@@ -1007,1 +958,1 @@\n-        this.getModel().showNot(hiddenNodes);\n+        getModel().setHiddenNodes(hiddenNodes);\n@@ -1017,0 +968,1 @@\n+                assert r != null;\n@@ -1035,1 +987,1 @@\n-        Rectangle viewRect = getScrollPane().getViewport().getViewRect();\n+        Rectangle viewRect = scrollPane.getViewport().getViewRect();\n@@ -1048,1 +1000,1 @@\n-        viewRect.x = Math.min(getScrollPane().getViewport().getViewSize().width - viewRect.width, viewRect.x);\n+        viewRect.x = Math.min(scrollPane.getViewport().getViewSize().width - viewRect.width, viewRect.x);\n@@ -1050,1 +1002,1 @@\n-        viewRect.y = Math.min(getScrollPane().getViewport().getViewSize().height - viewRect.height, viewRect.y);\n+        viewRect.y = Math.min(scrollPane.getViewport().getViewSize().height - viewRect.height, viewRect.y);\n@@ -1052,1 +1004,0 @@\n-\n@@ -1075,22 +1026,1 @@\n-        for (Integer n : f.getSource().getSourceNodesAsSet()) {\n-            if (getModel().getHiddenNodes().contains(n)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public static boolean doesIntersect(Set<?> s1, Set<?> s2) {\n-        if (s1.size() > s2.size()) {\n-            Set<?> tmp = s1;\n-            s1 = s2;\n-            s2 = tmp;\n-        }\n-\n-        for (Object o : s1) {\n-            if (s2.contains(o)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n+        return !getModel().getHiddenNodes().contains(f.getInputNode().getId());\n@@ -1113,1 +1043,1 @@\n-        Diagram diagram = getModel().getDiagramToView();\n+        Diagram diagram = getModel().getDiagram();\n@@ -1116,1 +1046,1 @@\n-        Set<InputBlock> visibleBlocks = new HashSet<InputBlock>();\n+        Set<InputBlock> visibleBlocks = new HashSet<>();\n@@ -1127,1 +1057,1 @@\n-            for (InputBlock b : diagram.getGraph().getBlocks()) {\n+            for (InputBlock b : diagram.getInputBlocks()) {\n@@ -1136,2 +1066,0 @@\n-            boolean hiddenAfter = doesIntersect(f.getSource().getSourceNodesAsSet(), newHiddenNodes);\n-\n@@ -1140,7 +1068,1 @@\n-            if (!hiddenAfter) {\n-                \/\/ Figure is shown\n-                w.setVisible(true);\n-                for (InputNode n : f.getSource().getSourceNodes()) {\n-                    visibleBlocks.add(diagram.getGraph().getBlock(n));\n-                }\n-            } else {\n+            if (newHiddenNodes.contains(f.getInputNode().getId())) {\n@@ -1149,0 +1071,4 @@\n+            } else {\n+                \/\/ Figure is shown\n+                w.setVisible(true);\n+                visibleBlocks.add(f.getBlock().getInputBlock());\n@@ -1171,3 +1097,1 @@\n-                        for (InputNode n : f.getSource().getSourceNodes()) {\n-                            visibleBlocks.add(diagram.getGraph().getBlock(n));\n-                        }\n+                        visibleBlocks.add(f.getBlock().getInputBlock());\n@@ -1189,1 +1113,1 @@\n-                if (f.getBlock().isArtificial()) {\n+                if (f.getBlock().getInputBlock().isArtificial()) {\n@@ -1196,1 +1120,1 @@\n-                visibleBlocks.addAll(diagram.getGraph().getBlocks());\n+                visibleBlocks.addAll(diagram.getInputBlocks());\n@@ -1201,1 +1125,1 @@\n-            for (InputBlock b : diagram.getGraph().getBlocks()) {\n+            for (InputBlock b : diagram.getInputBlocks()) {\n@@ -1209,7 +1133,1 @@\n-                if (visibleAfter) {\n-                    \/\/ Block must be shown\n-                    w.setVisible(true);\n-                } else {\n-                    \/\/ Block must be hidden\n-                    w.setVisible(false);\n-                }\n+                w.setVisible(visibleAfter);\n@@ -1222,1 +1140,1 @@\n-        this.validate();\n+        validate();\n@@ -1228,14 +1146,2 @@\n-        newHiddenNodes.removeAll(f.getSource().getSourceNodesAsSet());\n-        this.model.setHiddenNodes(newHiddenNodes);\n-    }\n-\n-    public void show(final Figure f) {\n-        showFigure(f);\n-    }\n-\n-    public void setSelectedObjects(Object... args) {\n-        Set<Object> set = new HashSet<>();\n-        for (Object o : args) {\n-            set.add(o);\n-        }\n-        super.setSelectedObjects(set);\n+        newHiddenNodes.remove(f.getInputNode().getId());\n+        getModel().setHiddenNodes(newHiddenNodes);\n@@ -1247,0 +1153,1 @@\n+        assert r != null;\n@@ -1258,1 +1165,1 @@\n-            setSelection(Arrays.asList(f));\n+            setSelection(Collections.singletonList(f));\n@@ -1266,1 +1173,1 @@\n-        if (this.getSelectedObjects().isEmpty()) {\n+        if (getSelectedObjects().isEmpty()) {\n@@ -1281,4 +1188,4 @@\n-        private DiagramViewModel oldModel;\n-        private DiagramViewModel newModel;\n-        private Point oldScrollPosition;\n-        private DiagramScene scene;\n+        private final DiagramViewModel oldModel;\n+        private final DiagramViewModel newModel;\n+        private final Point oldScrollPosition;\n+        private final DiagramScene scene;\n@@ -1298,2 +1205,2 @@\n-            boolean b = scene.getUndoRedoEnabled();\n-            scene.setUndoRedoEnabled(false);\n+            boolean enableUndoRedo = scene.undoRedoEnabled;\n+            scene.undoRedoEnabled = false;\n@@ -1303,1 +1210,2 @@\n-            scene.setUndoRedoEnabled(b);\n+            scene.undoRedoEnabled = enableUndoRedo;\n+\n@@ -1309,2 +1217,2 @@\n-            boolean b = scene.getUndoRedoEnabled();\n-            scene.setUndoRedoEnabled(false);\n+            boolean enableUndoRedo = scene.undoRedoEnabled;\n+            scene.undoRedoEnabled = false;\n@@ -1315,7 +1223,1 @@\n-            SwingUtilities.invokeLater(new Runnable() {\n-\n-                @Override\n-                public void run() {\n-                    scene.setScrollPosition(oldScrollPosition);\n-                }\n-            });\n+            SwingUtilities.invokeLater(() -> scene.setScrollPosition(oldScrollPosition));\n@@ -1323,1 +1225,1 @@\n-            scene.setUndoRedoEnabled(b);\n+            scene.undoRedoEnabled = enableUndoRedo;\n@@ -1329,5 +1231,1 @@\n-            if (oldModel.getHiddenNodes().equals(newModel.getHiddenNodes())) {\n-                scene.smallUpdate(false);\n-            } else {\n-                scene.smallUpdate(true);\n-            }\n+            scene.smallUpdate(!oldModel.getHiddenNodes().equals(newModel.getHiddenNodes()));\n@@ -1336,9 +1234,0 @@\n-    private boolean undoRedoEnabled = true;\n-\n-    public void setUndoRedoEnabled(boolean b) {\n-        this.undoRedoEnabled = b;\n-    }\n-\n-    public boolean getUndoRedoEnabled() {\n-        return undoRedoEnabled;\n-    }\n@@ -1375,1 +1264,0 @@\n-\n@@ -1377,1 +1265,0 @@\n-\n@@ -1379,1 +1266,1 @@\n-            this.getUndoRedoManager().undoableEditHappened(new UndoableEditEvent(this, new DiagramUndoRedo(this, this.getScrollPosition(), modelCopy, newModelCopy)));\n+            getUndoRedoManager().undoableEditHappened(new UndoableEditEvent(this, new DiagramUndoRedo(this, getScrollPosition(), modelCopy, newModelCopy)));\n@@ -1381,2 +1268,1 @@\n-\n-        this.modelCopy = newModelCopy;\n+        modelCopy = newModelCopy;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":272,"deletions":386,"binary":false,"changes":658,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.hotspot.igv.data.Properties;\n@@ -38,0 +39,1 @@\n+import java.util.*;\n@@ -39,7 +41,0 @@\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Set;\n@@ -57,1 +52,0 @@\n-    private Set<Integer> onScreenNodes;\n@@ -62,5 +56,5 @@\n-    private InputGraph inputGraph;\n-    private ChangedEvent<DiagramViewModel> diagramChangedEvent;\n-    private ChangedEvent<DiagramViewModel> viewChangedEvent;\n-    private ChangedEvent<DiagramViewModel> hiddenNodesChangedEvent;\n-    private ChangedEvent<DiagramViewModel> viewPropertiesChangedEvent;\n+    private InputGraph cachedInputGraph;\n+    private final ChangedEvent<DiagramViewModel> diagramChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> viewChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> hiddenNodesChangedEvent;\n+    private final ChangedEvent<DiagramViewModel> viewPropertiesChangedEvent;\n@@ -73,1 +67,0 @@\n-    private ChangedListener<FilterChain> filterChainChangedListener = new ChangedListener<FilterChain>() {\n@@ -75,5 +68,1 @@\n-        @Override\n-        public void changed(FilterChain source) {\n-            diagramChanged();\n-        }\n-    };\n+    private final ChangedListener<FilterChain> filterChainChangedListener = source -> updateDiagram();\n@@ -83,1 +72,1 @@\n-        DiagramViewModel result = new DiagramViewModel(group, filterChain, sequenceFilterChain);\n+        DiagramViewModel result = new DiagramViewModel(cachedInputGraph, filterChain, sequenceFilterChain);\n@@ -94,3 +83,0 @@\n-        boolean diagramChanged = false;\n-        boolean viewChanged = false;\n-        boolean viewPropertiesChanged = false;\n@@ -109,2 +95,1 @@\n-        diagramChanged |= (filterChain != newModel.filterChain);\n-        this.filterChain = newModel.filterChain;\n+        boolean diagramChanged = filterChain != newModel.filterChain;\n@@ -112,1 +97,0 @@\n-        this.sequenceFilterChain = newModel.sequenceFilterChain;\n@@ -114,5 +98,2 @@\n-        this.diagram = newModel.diagram;\n-        viewChanged |= (hiddenNodes != newModel.hiddenNodes);\n-        this.hiddenNodes = newModel.hiddenNodes;\n-        viewChanged |= (onScreenNodes != newModel.onScreenNodes);\n-        this.onScreenNodes = newModel.onScreenNodes;\n+\n+        boolean viewChanged = hiddenNodes != newModel.hiddenNodes;\n@@ -120,3 +101,2 @@\n-        this.selectedNodes = newModel.selectedNodes;\n-        viewPropertiesChanged |= (showSea != newModel.showSea);\n-        this.showSea = newModel.showSea;\n+\n+        boolean viewPropertiesChanged = (showSea != newModel.showSea);\n@@ -124,1 +104,0 @@\n-        this.showBlocks = newModel.showBlocks;\n@@ -126,1 +105,0 @@\n-        this.showCFG = newModel.showCFG;\n@@ -128,1 +106,10 @@\n-        this.showNodeHull = newModel.showNodeHull;\n+\n+        filterChain = newModel.filterChain;\n+        sequenceFilterChain = newModel.sequenceFilterChain;\n+        diagram = newModel.diagram;\n+        hiddenNodes = newModel.hiddenNodes;\n+        selectedNodes = newModel.selectedNodes;\n+        showSea = newModel.showSea;\n+        showBlocks = newModel.showBlocks;\n+        showCFG = newModel.showCFG;\n+        showNodeHull = newModel.showNodeHull;\n@@ -201,2 +188,0 @@\n-    public DiagramViewModel(Group g, FilterChain filterChain, FilterChain sequenceFilterChain) {\n-        super(Arrays.asList(\"default\"));\n@@ -204,6 +189,9 @@\n-        this.showSea = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.SEA_OF_NODES;\n-        this.showBlocks = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CLUSTERED_SEA_OF_NODES;\n-        this.showCFG = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CONTROL_FLOW_GRAPH;\n-        this.showNodeHull = true;\n-        this.showEmptyBlocks = true;\n-        this.group = g;\n+    public DiagramViewModel(InputGraph graph, FilterChain filterChain, FilterChain sequenceFilterChain) {\n+        super(Collections.singletonList(\"default\"));\n+\n+        showSea = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.SEA_OF_NODES;\n+        showBlocks = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CLUSTERED_SEA_OF_NODES;\n+        showCFG = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.CONTROL_FLOW_GRAPH;\n+        showNodeHull = true;\n+        showEmptyBlocks = true;\n+        group = graph.getGroup();\n@@ -217,1 +205,0 @@\n-        onScreenNodes = new HashSet<>();\n@@ -225,1 +212,0 @@\n-\n@@ -228,0 +214,2 @@\n+\n+        selectGraph(graph);\n@@ -269,4 +257,0 @@\n-    public Set<Integer> getOnScreenNodes() {\n-        return onScreenNodes;\n-    }\n-\n@@ -276,1 +260,1 @@\n-        for (String s : getPositions()) {\n+        for (String ignored : getPositions()) {\n@@ -314,5 +298,1 @@\n-    public void showNot(final Set<Integer> nodes) {\n-        setHiddenNodes(nodes);\n-    }\n-\n-    public void showFigures(Collection<Figure> f) {\n+    public void showFigures(Collection<Figure> figures) {\n@@ -320,2 +300,2 @@\n-        for (Figure fig : f) {\n-            newHiddenNodes.removeAll(fig.getSource().getSourceNodesAsSet());\n+        for (Figure f : figures) {\n+            newHiddenNodes.remove(f.getInputNode().getId());\n@@ -330,4 +310,2 @@\n-            for (InputNode node : f.getSource().getSourceNodes()) {\n-                if (getSelectedNodes().contains(node.getId())) {\n-                    result.add(f);\n-                }\n+            if (getSelectedNodes().contains(f.getInputNode().getId())) {\n+                result.add(f);\n@@ -344,1 +322,1 @@\n-        final HashSet<Integer> allNodes = new HashSet<>(getGraphToView().getGroup().getAllNodes());\n+        final HashSet<Integer> allNodes = new HashSet<>(getGroup().getAllNodes());\n@@ -354,5 +332,0 @@\n-    public void setOnScreenNodes(Set<Integer> onScreenNodes) {\n-        this.onScreenNodes = onScreenNodes;\n-        viewChangedEvent.fire();\n-    }\n-\n@@ -363,9 +336,1 @@\n-    public void setSequenceFilterChain(FilterChain chain) {\n-        assert chain != null : \"sequenceFilterChain must never be null\";\n-        sequenceFilterChain.getChangedEvent().removeListener(filterChainChangedListener);\n-        sequenceFilterChain = chain;\n-        sequenceFilterChain.getChangedEvent().addListener(filterChainChangedListener);\n-        diagramChanged();\n-    }\n-\n-    private void diagramChanged() {\n+    private void updateDiagram() {\n@@ -373,2 +338,20 @@\n-        diagram = null;\n-        getDiagramChangedEvent().fire();\n+        InputGraph graph = getGraph();\n+        if (graph.getBlocks().isEmpty()) {\n+            Scheduler s = Lookup.getDefault().lookup(Scheduler.class);\n+            graph.clearBlocks();\n+            s.schedule(graph);\n+            graph.ensureNodesInBlocks();\n+        }\n+        diagram = new Diagram(graph,\n+                Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n+                Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n+                Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n+        getFilterChain().apply(diagram, getSequenceFilterChain());\n+        if (graph.isDiffGraph()) {\n+            ColorFilter f = new ColorFilter(\"\");\n+            f.addRule(stateColorRule(\"same\",    Color.white));\n+            f.addRule(stateColorRule(\"changed\", Color.orange));\n+            f.addRule(stateColorRule(\"new\",     Color.green));\n+            f.addRule(stateColorRule(\"deleted\", Color.red));\n+            f.apply(diagram);\n+        }\n@@ -376,0 +359,1 @@\n+        getDiagramChangedEvent().fire();\n@@ -382,8 +366,0 @@\n-    public void setFilterChain(FilterChain chain) {\n-        assert chain != null : \"filterChain must never be null\";\n-        filterChain.getChangedEvent().removeListener(filterChainChangedListener);\n-        filterChain = chain;\n-        filterChain.getChangedEvent().addListener(filterChainChangedListener);\n-        diagramChanged();\n-    }\n-\n@@ -465,25 +441,1 @@\n-    public Diagram getDiagramToView() {\n-\n-        if (diagram == null) {\n-            InputGraph graph = getGraphToView();\n-            if (graph.getBlocks().isEmpty()) {\n-                Scheduler s = Lookup.getDefault().lookup(Scheduler.class);\n-                graph.clearBlocks();\n-                s.schedule(graph);\n-                graph.ensureNodesInBlocks();\n-            }\n-            diagram = Diagram.createDiagram(graph,\n-                                            Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n-                                            Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n-                                            Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n-            getFilterChain().apply(diagram, getSequenceFilterChain());\n-            if (graph.isDiffGraph()) {\n-                ColorFilter f = new ColorFilter(\"\");\n-                f.addRule(stateColorRule(\"same\",    Color.white));\n-                f.addRule(stateColorRule(\"changed\", Color.orange));\n-                f.addRule(stateColorRule(\"new\",     Color.green));\n-                f.addRule(stateColorRule(\"deleted\", Color.red));\n-                f.apply(diagram);\n-           }\n-        }\n-\n+    public Diagram getDiagram() {\n@@ -494,10 +446,2 @@\n-    public InputGraph getGraphToView() {\n-        if (inputGraph == null) {\n-            if (getFirstGraph() != getSecondGraph()) {\n-                inputGraph = Difference.createDiffGraph(getFirstGraph(), getSecondGraph());\n-            } else {\n-                inputGraph = getFirstGraph();\n-            }\n-        }\n-\n-        return inputGraph;\n+    public InputGraph getGraph() {\n+        return cachedInputGraph;\n@@ -508,8 +452,4 @@\n-        inputGraph = null;\n-        diagramChanged();\n-    }\n-\n-    void setSelectedFigures(List<Figure> list) {\n-        Set<Integer> newSelectedNodes = new HashSet<>();\n-        for (Figure f : list) {\n-            newSelectedNodes.addAll(f.getSource().getSourceNodesAsSet());\n+        if (getFirstGraph() != getSecondGraph()) {\n+            cachedInputGraph = Difference.createDiffGraph(getFirstGraph(), getSecondGraph());\n+        } else {\n+            cachedInputGraph = getFirstGraph();\n@@ -517,1 +457,1 @@\n-        this.setSelectedNodes(newSelectedNodes);\n+        updateDiagram();\n@@ -527,1 +467,2 @@\n-        return new Iterable<InputGraph>() {\n+        return () -> new Iterator<InputGraph>() {\n+            int index = getFirstPosition();\n@@ -530,8 +471,3 @@\n-            public Iterator<InputGraph> iterator() {\n-                return new Iterator<InputGraph>() {\n-                    int index = getFirstPosition();\n-\n-                    @Override\n-                    public boolean hasNext() {\n-                        return index + 1 < graphs.size();\n-                    }\n+            public boolean hasNext() {\n+                return index + 1 < graphs.size();\n+            }\n@@ -539,5 +475,3 @@\n-                    @Override\n-                    public InputGraph next() {\n-                        return graphs.get(++index);\n-                    }\n-                };\n+            @Override\n+            public InputGraph next() {\n+                return graphs.get(++index);\n@@ -549,5 +483,2 @@\n-        return new Iterable<InputGraph>() {\n-            @Override\n-            public Iterator<InputGraph> iterator() {\n-                return new Iterator<InputGraph>() {\n-                    int index = getFirstPosition();\n+        return () -> new Iterator<InputGraph>() {\n+            int index = getFirstPosition();\n@@ -555,4 +486,4 @@\n-                    @Override\n-                    public boolean hasNext() {\n-                        return index - 1 > 0;\n-                    }\n+            @Override\n+            public boolean hasNext() {\n+                return index - 1 > 0;\n+            }\n@@ -560,5 +491,3 @@\n-                    @Override\n-                    public InputGraph next() {\n-                        return graphs.get(--index);\n-                    }\n-                };\n+            @Override\n+            public InputGraph next() {\n+                return graphs.get(--index);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":89,"deletions":160,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+\n@@ -70,0 +71,1 @@\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewer.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-            return editor.getModel().getGraphToView();\n+            return editor.getModel().getGraph();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorInputGraphProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.Properties;\n@@ -28,1 +27,0 @@\n-import com.sun.hotspot.igv.data.Properties.PropertyMatcher;\n@@ -79,1 +77,2 @@\n-    public EditorTopComponent(Diagram diagram) {\n+\n+    public EditorTopComponent(InputGraph graph) {\n@@ -122,0 +121,1 @@\n+        add(container, BorderLayout.NORTH);\n@@ -123,4 +123,3 @@\n-        DiagramViewModel diagramViewModel = new DiagramViewModel(diagram.getGraph().getGroup(), filterChain, sequence);\n-        RangeSlider rangeSlider = new RangeSlider();\n-        rangeSlider.setModel(diagramViewModel);\n-        if (diagram.getGraph().getGroup().getGraphsCount() == 1) {\n+        DiagramViewModel diagramViewModel = new DiagramViewModel(graph, filterChain, sequence);\n+        RangeSlider rangeSlider = new RangeSlider(diagramViewModel);\n+        if (diagramViewModel.getGroup().getGraphs().size() == 1) {\n@@ -131,1 +130,0 @@\n-        add(container, BorderLayout.NORTH);\n@@ -140,6 +138,4 @@\n-        diagramViewModel.getDiagramChangedEvent().addListener(source -> {\n-            setDisplayName(getDiagram().getName());\n-            setToolTipText(getDiagram().getGraph().getGroup().getName());\n-            Collection<Object> list = new ArrayList<>();\n-            list.add(new EditorInputGraphProvider(EditorTopComponent.this));\n-            graphContent.set(list, null);\n+        diagramViewModel.getDiagramChangedEvent().addListener(model -> {\n+            setDisplayName(model.getGraph().getName());\n+            setToolTipText(model.getGroup().getName());\n+            graphContent.set(Collections.singletonList(new EditorInputGraphProvider(this)), null);\n@@ -147,1 +143,0 @@\n-        diagramViewModel.selectGraph(diagram.getGraph());\n@@ -149,1 +144,1 @@\n-        Group group = getDiagram().getGraph().getGroup();\n+        Group group = diagramViewModel.getGroup();\n@@ -255,1 +250,1 @@\n-        return getModel().getDiagramToView();\n+        return getModel().getDiagram();\n@@ -331,6 +326,0 @@\n-    public void setSelection(PropertyMatcher matcher) {\n-        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(getDiagram().getFigures());\n-        List<Figure> list = selector.selectMultiple(matcher);\n-        setSelectedFigures(list);\n-    }\n-\n@@ -349,5 +338,2 @@\n-            for (InputNode n : f.getSource().getSourceNodes()) {\n-                if (ids.contains(n.getId())) {\n-                    list.add(f);\n-                    break;\n-                }\n+            if (ids.contains(f.getInputNode().getId())) {\n+                list.add(f);\n@@ -362,1 +348,1 @@\n-            if (f.getBlock() == b) {\n+            if (f.getBlock().getInputBlock() == b) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":15,"deletions":29,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view;\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.JComponent;\n-import org.netbeans.api.visual.widget.Scene;\n-\n-\/**\n- * @author David Kaspar\n- * @author Thomas Wuerthinger\n- *\/\n-public class ExtendedSatelliteComponent extends JComponent implements MouseListener, MouseMotionListener, Scene.SceneListener, ComponentListener {\n-\n-    private DiagramScene scene;\n-    private Image image;\n-    private int imageWidth;\n-    private int imageHeight;\n-\n-    public ExtendedSatelliteComponent(DiagramScene scene) {\n-        this.scene = scene;\n-        setDoubleBuffered(true);\n-        setPreferredSize(new Dimension(128, 128));\n-        addMouseListener(this);\n-        addMouseMotionListener(this);\n-    }\n-\n-    @Override\n-    public void addNotify() {\n-        super.addNotify();\n-        scene.addSceneListener(this);\n-        JComponent viewComponent = scene.getView();\n-        if (viewComponent == null) {\n-            viewComponent = scene.createView();\n-        }\n-        viewComponent.addComponentListener(this);\n-        repaint();\n-    }\n-\n-    @Override\n-    public void removeNotify() {\n-        scene.getView().removeComponentListener(this);\n-        scene.removeSceneListener(this);\n-        super.removeNotify();\n-    }\n-\n-    public void update() {\n-        this.image = null;\n-        if (this.isVisible()) {\n-            repaint();\n-            revalidate();\n-            validate();\n-        }\n-    }\n-\n-    @Override\n-    public void paint(Graphics g) {\n-        Graphics2D gr = (Graphics2D) g;\n-        super.paint(g);\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-\n-        if (image == null || vw != imageWidth || vh != imageHeight) {\n-            imageWidth = vw;\n-            imageHeight = vh;\n-            image = this.createImage(imageWidth, imageHeight);\n-            Graphics2D ig = (Graphics2D) image.getGraphics();\n-            ig.scale(scale, scale);\n-            double oldFactor = scene.getZoomFactor();\n-            scene.setZoomFactor(scale);\n-            scene.paint(ig);\n-            scene.setZoomFactor(oldFactor);\n-        }\n-\n-        gr.drawImage(image, vx, vy, this);\n-\n-        JComponent component = scene.getView();\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle viewRectangle = component != null ? component.getVisibleRect() : null;\n-        if (viewRectangle != null) {\n-            Rectangle window = new Rectangle(\n-                    (int) ((double) viewRectangle.x * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.y * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.width * scale \/ zoomFactor),\n-                    (int) ((double) viewRectangle.height * scale \/ zoomFactor));\n-            window.translate(vx, vy);\n-            gr.setColor(new Color(200, 200, 200, 128));\n-            gr.fill(window);\n-            gr.setColor(Color.BLACK);\n-            gr.drawRect(window.x, window.y, window.width - 1, window.height - 1);\n-        }\n-    }\n-\n-    @Override\n-    public void mouseClicked(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mousePressed(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseReleased(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseEntered(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseExited(MouseEvent e) {\n-    }\n-\n-    @Override\n-    public void mouseDragged(MouseEvent e) {\n-        moveVisibleRect(e.getPoint());\n-    }\n-\n-    @Override\n-    public void mouseMoved(MouseEvent e) {\n-    }\n-\n-    private void moveVisibleRect(Point center) {\n-        JComponent component = scene.getView();\n-        if (component == null) {\n-            return;\n-        }\n-        double zoomFactor = scene.getZoomFactor();\n-        Rectangle bounds = scene.getBounds();\n-        Dimension size = getSize();\n-\n-        double sx = bounds.width > 0 ? (double) size.width \/ bounds.width : 0.0;\n-        double sy = bounds.width > 0 ? (double) size.height \/ bounds.height : 0.0;\n-        double scale = Math.min(sx, sy);\n-\n-        int vw = (int) (scale * bounds.width);\n-        int vh = (int) (scale * bounds.height);\n-        int vx = (size.width - vw) \/ 2;\n-        int vy = (size.height - vh) \/ 2;\n-\n-        int cx = (int) ((double) (center.x - vx) \/ scale * zoomFactor);\n-        int cy = (int) ((double) (center.y - vy) \/ scale * zoomFactor);\n-\n-        Rectangle visibleRect = component.getVisibleRect();\n-        visibleRect.x = cx - visibleRect.width \/ 2;\n-        visibleRect.y = cy - visibleRect.height \/ 2;\n-        component.scrollRectToVisible(visibleRect);\n-\n-        this.repaint();\n-    }\n-\n-    @Override\n-    public void sceneRepaint() {\n-    \/\/repaint ();\n-    }\n-\n-    @Override\n-    public void sceneValidating() {\n-    }\n-\n-    @Override\n-    public void sceneValidated() {\n-    }\n-\n-    @Override\n-    public void componentResized(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentMoved(ComponentEvent e) {\n-        repaint();\n-    }\n-\n-    @Override\n-    public void componentShown(ComponentEvent e) {\n-    }\n-\n-    @Override\n-    public void componentHidden(ComponentEvent e) {\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/ExtendedSatelliteComponent.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -66,6 +66,1 @@\n-        Diagram diagram = Diagram.createDiagram(graph,\n-                                                Settings.get().get(Settings.NODE_TEXT, Settings.NODE_TEXT_DEFAULT),\n-                                                Settings.get().get(Settings.NODE_SHORT_TEXT, Settings.NODE_SHORT_TEXT_DEFAULT),\n-                                                Settings.get().get(Settings.NODE_TINY_TEXT, Settings.NODE_TINY_TEXT_DEFAULT));\n-        EditorTopComponent tc = new EditorTopComponent(diagram);\n-        diagram.setCFG(tc.getModel().getShowCFG());\n+        EditorTopComponent tc = new EditorTopComponent(graph);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/GraphViewerImplementation.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -179,8 +179,5 @@\n-            response.addResult(new Runnable() {\n-                @Override\n-                public void run() {\n-                    Message desc = new NotifyDescriptor.Message(\"An exception occurred during the search, \"\n-                            + \"perhaps due to a malformed query string:\\n\" + msg,\n-                            NotifyDescriptor.WARNING_MESSAGE);\n-                    DialogDisplayer.getDefault().notify(desc);\n-                }\n+            response.addResult(() -> {\n+                Message desc = new Message(\"An exception occurred during the search, \"\n+                        + \"perhaps due to a malformed query string:\\n\" + msg,\n+                        NotifyDescriptor.WARNING_MESSAGE);\n+                DialogDisplayer.getDefault().notify(desc);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/NodeQuickSearch.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-import org.netbeans.api.visual.widget.Widget;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.action.SelectProvider;\n-\n+import java.awt.Point;\n@@ -31,2 +28,3 @@\n-import java.awt.event.KeyEvent;\n-import java.awt.*;\n+import org.netbeans.api.visual.action.SelectProvider;\n+import org.netbeans.api.visual.action.WidgetAction;\n+import org.netbeans.api.visual.widget.Widget;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/CustomSelectAction.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-import javax.swing.JScrollBar;\n@@ -55,2 +54,0 @@\n-import org.netbeans.api.visual.action.WidgetAction.State;\n-import org.netbeans.api.visual.action.WidgetAction.WidgetMouseEvent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/CustomizablePanAction.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-            for (Figure f : editor.getModel().getDiagramToView().getFigures()) {\n+            for (Figure f : editor.getModel().getDiagram().getFigures()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExpandAdjacentAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,6 +36,1 @@\n-import org.openide.util.HelpCtx;\n-import org.openide.util.ImageUtilities;\n-import org.openide.util.Lookup;\n-import org.openide.util.LookupEvent;\n-import org.openide.util.LookupListener;\n-import org.openide.util.NbBundle;\n+import org.openide.util.*;\n@@ -43,1 +38,0 @@\n-import org.openide.util.Utilities;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ExportAction.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        model.showNot(nodes);\n+        model.setHiddenNodes(nodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/HideAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -30,2 +31,0 @@\n-\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/HideDuplicatesAction.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package com.sun.hotspot.igv.view.actions;\n-\n-import org.netbeans.api.visual.action.HoverProvider;\n-import org.netbeans.api.visual.action.WidgetAction;\n-import org.netbeans.api.visual.action.WidgetAction.State;\n-import org.netbeans.api.visual.widget.Widget;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-public class MouseOverAction extends WidgetAction.Adapter {\n-\n-    private long eventID = Integer.MIN_VALUE;\n-    private HoverProvider provider;\n-\n-    public MouseOverAction(HoverProvider provider) {\n-        this.provider = provider;\n-    }\n-\n-    @Override\n-    public State mouseMoved(Widget widget, WidgetMouseEvent event) {\n-        long id = event.getEventID();\n-        if (id != eventID) {\n-            eventID = id;\n-            provider.widgetHovered(widget);\n-        }\n-        return State.REJECTED;\n-    }\n-\n-    @Override\n-    public State mouseExited(Widget widget, WidgetMouseEvent event) {\n-        provider.widgetHovered(null);\n-        return State.REJECTED;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/MouseOverAction.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-import java.awt.*;\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -30,2 +30,0 @@\n-\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/OverviewAction.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -30,2 +31,0 @@\n-\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/PredSuccAction.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -30,2 +31,0 @@\n-\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/SelectionModeAction.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        model.showNot(new HashSet<>());\n+        model.setHiddenNodes(new HashSet<>());\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ShowAllAction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n@@ -30,1 +31,0 @@\n-import javax.swing.Action;\n@@ -32,2 +32,0 @@\n-\n-import com.sun.hotspot.igv.view.EditorTopComponent;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ShowEmptyBlocksAction.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,4 @@\n-import javax.swing.*;\n+import javax.swing.BorderFactory;\n+import javax.swing.DefaultComboBoxModel;\n+import javax.swing.JComboBox;\n+import javax.swing.JTextField;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/ZoomLevelAction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,6 +28,1 @@\n-import java.awt.BasicStroke;\n-import java.awt.Color;\n-import java.awt.Font;\n-import java.awt.Graphics2D;\n-import java.awt.Rectangle;\n-import java.awt.Stroke;\n+import java.awt.*;\n@@ -44,1 +39,0 @@\n-    public static final int BORDER = 20;\n@@ -49,1 +43,0 @@\n-    private Diagram diagram;\n@@ -54,1 +47,0 @@\n-        this.diagram = d;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/BlockWidget.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import com.sun.hotspot.igv.data.InputGraph;\n@@ -28,1 +27,1 @@\n-import com.sun.hotspot.igv.data.services.GraphViewer;\n+import com.sun.hotspot.igv.graph.Diagram;\n@@ -36,1 +35,0 @@\n-import java.awt.event.ActionEvent;\n@@ -40,1 +38,0 @@\n-import javax.swing.AbstractAction;\n@@ -60,1 +57,0 @@\n-import org.openide.util.Lookup;\n@@ -68,1 +64,0 @@\n-    public static final boolean VERTICAL_LAYOUT = true;\n@@ -71,2 +66,0 @@\n-    private Widget leftWidget;\n-    private Widget rightWidget;\n@@ -89,4 +82,0 @@\n-    public Node getNode() {\n-        return node;\n-    }\n-\n@@ -147,1 +136,1 @@\n-            lw.setFont(figure.getDiagram().getFont());\n+            lw.setFont(Diagram.FONT);\n@@ -187,8 +176,0 @@\n-    public Widget getLeftWidget() {\n-        return leftWidget;\n-    }\n-\n-    public Widget getRightWidget() {\n-        return rightWidget;\n-    }\n-\n@@ -199,1 +180,1 @@\n-        Font font = this.figure.getDiagram().getFont();\n+        Font font = Diagram.FONT;\n@@ -202,1 +183,1 @@\n-            font = this.figure.getDiagram().getBoldFont();\n+            font = Diagram.BOLD_FONT;\n@@ -289,21 +270,0 @@\n-        if (getFigure().getSubgraphs() != null) {\n-            menu.addSeparator();\n-            JMenu subgraphs = new JMenu(\"Subgraphs\");\n-            menu.add(subgraphs);\n-\n-            final GraphViewer viewer = Lookup.getDefault().lookup(GraphViewer.class);\n-            for (final InputGraph subgraph : getFigure().getSubgraphs()) {\n-                Action a = new AbstractAction() {\n-\n-                    @Override\n-                    public void actionPerformed(ActionEvent e) {\n-                        viewer.view(subgraph, true);\n-                    }\n-                };\n-\n-                a.setEnabled(true);\n-                a.putValue(Action.NAME, subgraph.getName());\n-                subgraphs.add(a);\n-            }\n-        }\n-\n@@ -386,1 +346,0 @@\n-\n@@ -388,3 +347,3 @@\n-            final Set<Integer> hiddenNodes = new HashSet<>(diagramScene.getModel().getGraphToView().getGroup().getAllNodes());\n-            hiddenNodes.removeAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            final Set<Integer> hiddenNodes = new HashSet<>(diagramScene.getModel().getGroup().getAllNodes());\n+            hiddenNodes.remove(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n@@ -392,1 +351,0 @@\n-\n@@ -394,2 +352,2 @@\n-            hiddenNodes.removeAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            hiddenNodes.remove(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n@@ -398,2 +356,2 @@\n-            hiddenNodes.addAll(this.getFigure().getSource().getSourceNodesAsSet());\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            hiddenNodes.add(this.getFigure().getInputNode().getId());\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":11,"deletions":53,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -61,11 +61,0 @@\n-\/*\n-    protected Point calculateRelativeLocation() {\n-        if (getFigureWidget().getBounds() == null) {\n-            return new Point(0, 0);\n-        }\n-\n-        double x = 0;\n-        List<InputSlot> slots = inputSlot.getFigure().getInputSlots();\n-        assert slots.contains(inputSlot);\n-        return new Point((int) x, (int) (calculateRelativeY(slots.size(), slots.indexOf(inputSlot))));\n-    }*\/\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/InputSlotWidget.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.graph.Block;\n@@ -29,1 +30,0 @@\n-import com.sun.hotspot.igv.graph.Block;\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LineWidget.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.graph.Diagram;\n@@ -31,6 +32,1 @@\n-import java.awt.BasicStroke;\n-import java.awt.Color;\n-import java.awt.Font;\n-import java.awt.Graphics2D;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n+import java.awt.*;\n@@ -38,0 +34,1 @@\n+import java.util.Collections;\n@@ -108,1 +105,1 @@\n-            Font font = this.getSlot().getFigure().getDiagram().getSlotFont();\n+            Font font = Diagram.SLOT_FONT;\n@@ -173,1 +170,1 @@\n-            hiddenNodes = new HashSet<>(diagramScene.getModel().getGraphToView().getGroup().getAllNodes());\n+            hiddenNodes = new HashSet<>(diagramScene.getModel().getGroup().getAllNodes());\n@@ -177,1 +174,1 @@\n-        for (Figure f : diagramScene.getModel().getDiagramToView().getFigures()) {\n+        for (Figure f : diagramScene.getModel().getDiagram().getFigures()) {\n@@ -179,1 +176,1 @@\n-                if (DiagramScene.doesIntersect(s.getSource().getSourceNodesAsSet(), slot.getSource().getSourceNodesAsSet())) {\n+                if (!Collections.disjoint(s.getSource().getSourceNodesAsSet(), slot.getSource().getSourceNodesAsSet())) {\n@@ -181,1 +178,1 @@\n-                    hiddenNodes.removeAll(f.getSource().getSourceNodesAsSet());\n+                    hiddenNodes.remove(f.getInputNode().getId());\n@@ -187,1 +184,1 @@\n-            this.diagramScene.getModel().showNot(hiddenNodes);\n+            this.diagramScene.getModel().setHiddenNodes(hiddenNodes);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/SlotWidget.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,214 +0,0 @@\n-#\n-# Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n-# Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# The Universal Permissive License (UPL), Version 1.0\n-#\n-# Subject to the condition set forth below, permission is hereby granted to\n-# any person obtaining a copy of this software, associated documentation\n-# and\/or data (collectively the \"Software\"), free of charge and under any\n-# and all copyright rights in the Software, and any and all patent rights\n-# owned or freely licensable by each licensor hereunder covering either (i)\n-# the unmodified Software as contributed to or provided by such licensor,\n-# or (ii) the Larger Works (as defined below), to deal in both\n-#\n-# (a) the Software, and\n-#\n-# (b) any piece of software and\/or hardware listed in the lrgrwrks.txt file\n-# if one is included with the Software (each a \"Larger Work\" to which the\n-# Software is contributed by such licensors),\n-#\n-# without restriction, including without limitation the rights to copy,\n-# create derivative works of, display, perform, and distribute the Software\n-# and make, use, sell, offer for sale, import, export, have made, and have\n-# sold the Software and the Larger Work(s), and to sublicense the foregoing\n-# rights on either these or other terms.\n-#\n-# This license is subject to the following condition:\n-#\n-# The above copyright notice and either this complete permission notice or\n-# at a minimum a reference to the UPL must be included in all copies or\n-# substantial portions of the Software.\n-#\n-# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-# NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-# USE OR OTHER DEALINGS IN THE SOFTWARE.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-#\n-\n-# Single gnu makefile for linux and windows (windows requires cygwin and mingw)\n-\n-# Default arch; it is changed below as needed.\n-ARCH\t\t= i386\n-OS\t\t= $(shell uname)\n-AR\t\t= ar\n-\n-## OS = Linux ##\n-ifeq\t\t($(OS),Linux)\n-ifneq           ($(MINGW),)\n-LIB_EXT\t\t= .dll\n-CPPFLAGS += -I$(TARGET_DIR)\/include\n-LDFLAGS += -L$(TARGET_DIR)\/lib\n-OS=windows\n-ifneq           ($(findstring x86_64-,$(MINGW)),)\n-ARCH=amd64\n-else\n-ARCH=i386\n-endif\n-CC \t\t= $(MINGW)-gcc\n-CONFIGURE_ARGS= --host=$(MINGW) --target=$(MINGW)\n-else   #linux\n-CPU             = $(shell uname -m)\n-ARCH1=$(CPU:x86_64=amd64)\n-ARCH=$(ARCH1:i686=i386)\n-ifdef LP64\n-CFLAGS\/amd64\t+= -m64\n-CFLAGS\/ppc64\t+= -m64\n-CFLAGS\/ppc64le  += -m64 -DABI_ELFv2\n-else\n-ARCH=$(ARCH1:amd64=i386)\n-ifneq ($(findstring arm,$(ARCH)),)\n-ARCH=arm\n-endif\n-CFLAGS\/i386\t+= -m32\n-endif\n-CFLAGS\t\t+= $(CFLAGS\/$(ARCH))\n-CFLAGS\t\t+= -fPIC\n-OS\t\t= linux\n-LIB_EXT\t\t= .so\n-CC \t\t= gcc\n-endif\n-CFLAGS\t\t+= -O\n-DLDFLAGS\t+= -shared\n-LDFLAGS         += -ldl\n-OUTFLAGS\t+= -o $@\n-else\n-## OS = AIX ##\n-ifeq\t\t($(OS),AIX)\n-OS              = aix\n-ARCH            = ppc64\n-CC              = xlc_r\n-CFLAGS          += -DAIX -g -qpic=large -q64\n-CFLAGS\/ppc64    += -q64\n-AR              = ar -X64\n-DLDFLAGS        += -qmkshrobj -lz\n-OUTFLAGS        += -o $@\n-LIB_EXT\t\t= .so\n-else\n-## OS = Darwin ##\n-ifeq ($(OS),Darwin)\n-CPU             = $(shell uname -m)\n-ARCH1=$(CPU:x86_64=amd64)\n-ARCH2=$(ARCH1:arm64=aarch64)\n-ARCH=$(ARCH2:i686=i386)\n-CONFIGURE_ARGS\/aarch64= --enable-targets=aarch64-darwin\n-CONFIGURE_ARGS = $(CONFIGURE_ARGS\/$(ARCH))\n-ifdef LP64\n-CFLAGS\/amd64    += -m64\n-else\n-ARCH=$(ARCH2:amd64=i386)\n-CFLAGS\/i386     += -m32\n-endif # LP64\n-ifeq ($(CPU), arm64)\n-CFLAGS\/aarch64  += -m64\n-endif # arm64\n-CFLAGS          += $(CFLAGS\/$(ARCH))\n-CFLAGS          += -fPIC\n-OS              = macosx\n-LIB_EXT         = .dylib\n-CC              = gcc\n-CFLAGS          += -O\n-# CFLAGS        += -DZ_PREFIX\n-DLDFLAGS        += -shared\n-DLDFLAGS        += -lz\n-LDFLAGS         += -ldl\n-OUTFLAGS        += -o $@\n-else\n-## OS = Windows ##\n-OS\t\t= windows\n-CC\t\t= gcc\n-CFLAGS\t\t+=  \/nologo \/MD \/W3 \/WX \/O2 \/Fo$(@:.dll=.obj) \/Gi-\n-CFLAGS\t\t+= LIBARCH=\\\"$(LIBARCH)\\\"\n-DLDFLAGS\t+= \/dll \/subsystem:windows \/incremental:no \\\n-\t\t\t\/export:decode_instruction\n-OUTFLAGS\t+= \/link \/out:$@\n-LIB_EXT\t\t= .dll\n-endif   # Darwin\n-endif   # AIX\n-endif\t# Linux\n-\n-LIBARCH\t\t= $(ARCH)\n-ifdef\t\tLP64\n-LIBARCH64\/i386\t= amd64\n-LIBARCH64\t= $(LIBARCH64\/$(ARCH))\n-ifneq\t\t($(LIBARCH64),)\n-LIBARCH\t\t= $(LIBARCH64)\n-endif   # LIBARCH64\/$(ARCH)\n-endif   # LP64\n-\n-JDKARCH=$(LIBARCH:i386=i586)\n-\n-ifeq            ($(BINUTILS),)\n-# Pop all the way out of the workspace to look for binutils.\n-# ...You probably want to override this setting.\n-BINUTILSDIR\t= $(shell cd build\/binutils;pwd)\n-else\n-BINUTILSDIR\t= $(shell cd $(BINUTILS);pwd)\n-endif\n-\n-CPPFLAGS\t+= -I$(BINUTILSDIR)\/include -I$(BINUTILSDIR)\/bfd -I$(TARGET_DIR)\/bfd\n-CPPFLAGS\t+= -DLIBARCH_$(LIBARCH) -DLIBARCH=\\\"$(LIBARCH)\\\" -DLIB_EXT=\\\"$(LIB_EXT)\\\"\n-\n-TARGET_DIR\t= build\/$(OS)-$(JDKARCH)\n-TARGET\t\t= $(TARGET_DIR)\/hsdis-$(LIBARCH)$(LIB_EXT)\n-\n-SOURCE\t\t= hsdis.c\n-\n-LIBRARIES =\t$(TARGET_DIR)\/bfd\/libbfd.a \\\n-\t\t$(TARGET_DIR)\/opcodes\/libopcodes.a \\\n-\t\t$(TARGET_DIR)\/libiberty\/libiberty.a\n-\n-ifneq ($(MINGW),)\n-LIBRARIES +=\t$(TARGET_DIR)\/zlib\/libz.a\n-endif\n-\n-DEMO_TARGET\t= $(TARGET_DIR)\/hsdis-demo\n-DEMO_SOURCE\t= hsdis-demo.c\n-\n-.PHONY:  all clean demo both\n-\n-all:  $(TARGET)\n-\n-both: all all64\n-\n-%64:\n-\t$(MAKE) LP64=1 ${@:%64=%}\n-\n-demo: $(TARGET) $(DEMO_TARGET)\n-\n-$(LIBRARIES): $(TARGET_DIR) $(TARGET_DIR)\/Makefile\n-\tif [ ! -f $@ ]; then cd $(TARGET_DIR); make all-opcodes; fi\n-\n-$(TARGET_DIR)\/Makefile:\n-\t(cd $(TARGET_DIR); CC=$(CC) CFLAGS=\"$(CFLAGS)\" AR=\"$(AR)\" $(BINUTILSDIR)\/configure --disable-nls $(CONFIGURE_ARGS))\n-\n-$(TARGET): $(SOURCE) $(LIBS) $(LIBRARIES) $(TARGET_DIR)\n-\t$(CC) $(OUTFLAGS) $(CPPFLAGS) $(CFLAGS) $(SOURCE) $(DLDFLAGS) $(LIBRARIES)\n-\n-$(DEMO_TARGET): $(DEMO_SOURCE) $(TARGET) $(TARGET_DIR)\n-\t$(CC) $(OUTFLAGS) -DTARGET_DIR=\\\"$(TARGET_DIR)\\\" $(CPPFLAGS) -g $(CFLAGS\/$(ARCH)) $(DEMO_SOURCE) $(LDFLAGS)\n-\n-$(TARGET_DIR):\n-\t[ -d $@ ] || mkdir -p $@\n-\n-clean:\n-\trm -rf $(TARGET_DIR)\n","filename":"src\/utils\/hsdis\/Makefile","additions":0,"deletions":214,"binary":false,"changes":214,"status":"deleted"},{"patch":"@@ -44,2 +44,2 @@\n-native.spindump.app=spindump\n-native.spindump.args=%p -stdout\n+native.spindump.app=sudo\n+native.spindump.args=spindump %p -stdout\n","filename":"test\/failure_handler\/src\/share\/conf\/mac.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,0 +175,2 @@\n+  OopStorage* _storage;\n+\n@@ -179,1 +181,1 @@\n-  OopStorage _storage;\n+  OopStorage& storage() const { return *_storage; }\n@@ -186,1 +188,1 @@\n-  _storage(\"Test Storage\", mtGC)\n+  _storage(OopStorage::create(\"Test Storage\", mtGC))\n@@ -190,1 +192,2 @@\n-  clear_list(TestAccess::allocation_list(_storage));\n+  clear_list(TestAccess::allocation_list(storage()));\n+  delete _storage;\n@@ -203,1 +206,1 @@\n-    _entries[i] = _storage.allocate();\n+    _entries[i] = storage().allocate();\n@@ -205,1 +208,1 @@\n-    EXPECT_EQ(i + 1, _storage.allocation_count());\n+    EXPECT_EQ(i + 1, storage().allocation_count());\n@@ -236,2 +239,2 @@\n-  EXPECT_EQ(0u, active_count(_storage));\n-  EXPECT_TRUE(is_list_empty(TestAccess::allocation_list(_storage)));\n+  EXPECT_EQ(0u, active_count(storage()));\n+  EXPECT_TRUE(is_list_empty(TestAccess::allocation_list(storage())));\n@@ -239,1 +242,1 @@\n-  oop* ptr = _storage.allocate();\n+  oop* ptr = storage().allocate();\n@@ -241,1 +244,1 @@\n-  EXPECT_EQ(1u, _storage.allocation_count());\n+  EXPECT_EQ(1u, storage().allocation_count());\n@@ -243,3 +246,3 @@\n-  EXPECT_EQ(1u, active_count(_storage));\n-  EXPECT_EQ(1u, _storage.block_count());\n-  EXPECT_EQ(1u, list_length(TestAccess::allocation_list(_storage)));\n+  EXPECT_EQ(1u, active_count(storage()));\n+  EXPECT_EQ(1u, storage().block_count());\n+  EXPECT_EQ(1u, list_length(TestAccess::allocation_list(storage())));\n@@ -247,1 +250,1 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -249,1 +252,1 @@\n-  const OopBlock* block = TestAccess::allocation_list(_storage).chead();\n+  const OopBlock* block = TestAccess::allocation_list(storage()).chead();\n@@ -251,1 +254,1 @@\n-  EXPECT_EQ(block, active_head(_storage));\n+  EXPECT_EQ(block, active_head(storage()));\n@@ -256,2 +259,2 @@\n-  release_entry(_storage, ptr);\n-  EXPECT_EQ(0u, _storage.allocation_count());\n+  release_entry(storage(), ptr);\n+  EXPECT_EQ(0u, storage().allocation_count());\n@@ -259,3 +262,3 @@\n-  EXPECT_EQ(1u, active_count(_storage));\n-  EXPECT_EQ(1u, _storage.block_count());\n-  EXPECT_EQ(1u, list_length(TestAccess::allocation_list(_storage)));\n+  EXPECT_EQ(1u, active_count(storage()));\n+  EXPECT_EQ(1u, storage().block_count());\n+  EXPECT_EQ(1u, list_length(TestAccess::allocation_list(storage())));\n@@ -263,1 +266,1 @@\n-  EXPECT_EQ(1u, empty_block_count(_storage));\n+  EXPECT_EQ(1u, empty_block_count(storage()));\n@@ -265,1 +268,1 @@\n-  const OopBlock* new_block = TestAccess::allocation_list(_storage).chead();\n+  const OopBlock* new_block = TestAccess::allocation_list(storage()).chead();\n@@ -267,1 +270,1 @@\n-  EXPECT_EQ(block, active_head(_storage));\n+  EXPECT_EQ(block, active_head(storage()));\n@@ -277,1 +280,1 @@\n-  AllocationList& allocation_list = TestAccess::allocation_list(_storage);\n+  AllocationList& allocation_list = TestAccess::allocation_list(storage());\n@@ -279,2 +282,2 @@\n-  EXPECT_EQ(0u, active_count(_storage));\n-  EXPECT_EQ(0u, _storage.block_count());\n+  EXPECT_EQ(0u, active_count(storage()));\n+  EXPECT_EQ(0u, storage().block_count());\n@@ -285,5 +288,5 @@\n-    EXPECT_EQ(allocated, _storage.allocation_count());\n-    if (active_count(_storage) != 0) {\n-      EXPECT_EQ(1u, active_count(_storage));\n-      EXPECT_EQ(1u, _storage.block_count());\n-      const OopBlock& block = *TestAccess::active_array(_storage).at(0);\n+    EXPECT_EQ(allocated, storage().allocation_count());\n+    if (active_count(storage()) != 0) {\n+      EXPECT_EQ(1u, active_count(storage()));\n+      EXPECT_EQ(1u, storage().block_count());\n+      const OopBlock& block = *TestAccess::active_array(storage()).at(0);\n@@ -298,1 +301,1 @@\n-    entries[allocated] = _storage.allocate();\n+    entries[allocated] = storage().allocate();\n@@ -301,3 +304,3 @@\n-  EXPECT_EQ(allocated, _storage.allocation_count());\n-  EXPECT_EQ(1u, active_count(_storage));\n-  EXPECT_EQ(1u, _storage.block_count());\n+  EXPECT_EQ(allocated, storage().allocation_count());\n+  EXPECT_EQ(1u, active_count(storage()));\n+  EXPECT_EQ(1u, storage().block_count());\n@@ -305,1 +308,1 @@\n-  const OopBlock& block = *TestAccess::active_array(_storage).at(0);\n+  const OopBlock& block = *TestAccess::active_array(storage()).at(0);\n@@ -310,1 +313,1 @@\n-    release_entry(_storage, entries[i]);\n+    release_entry(storage(), entries[i]);\n@@ -313,1 +316,1 @@\n-    EXPECT_EQ(remaining, _storage.allocation_count());\n+    EXPECT_EQ(remaining, storage().allocation_count());\n@@ -322,1 +325,1 @@\n-  AllocationList& allocation_list = TestAccess::allocation_list(_storage);\n+  AllocationList& allocation_list = TestAccess::allocation_list(storage());\n@@ -324,1 +327,1 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -326,1 +329,1 @@\n-  entries[0] = _storage.allocate();\n+  entries[0] = storage().allocate();\n@@ -328,2 +331,2 @@\n-  EXPECT_EQ(1u, active_count(_storage));\n-  EXPECT_EQ(1u, _storage.block_count());\n+  EXPECT_EQ(1u, active_count(storage()));\n+  EXPECT_EQ(1u, storage().block_count());\n@@ -331,1 +334,1 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -333,1 +336,1 @@\n-  const OopBlock* block = TestAccess::active_array(_storage).at(0);\n+  const OopBlock* block = TestAccess::active_array(storage()).at(0);\n@@ -338,2 +341,2 @@\n-    entries[i] = _storage.allocate();\n-    EXPECT_EQ(i + 1, _storage.allocation_count());\n+    entries[i] = storage().allocate();\n+    EXPECT_EQ(i + 1, storage().allocation_count());\n@@ -341,1 +344,1 @@\n-    EXPECT_EQ(0u, empty_block_count(_storage));\n+    EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -348,1 +351,1 @@\n-      EXPECT_EQ(block, active_head(_storage));\n+      EXPECT_EQ(block, active_head(storage()));\n@@ -355,1 +358,1 @@\n-      EXPECT_EQ(block, active_head(_storage));\n+      EXPECT_EQ(block, active_head(storage()));\n@@ -363,1 +366,1 @@\n-    EXPECT_EQ(block, active_head(_storage));\n+    EXPECT_EQ(block, active_head(storage()));\n@@ -367,3 +370,3 @@\n-    release_entry(_storage, entries[i]);\n-    EXPECT_TRUE(is_allocation_list_sorted(_storage));\n-    EXPECT_EQ(max_entries - (i + 1), total_allocation_count(_storage));\n+    release_entry(storage(), entries[i]);\n+    EXPECT_TRUE(is_allocation_list_sorted(storage()));\n+    EXPECT_EQ(max_entries - (i + 1), total_allocation_count(storage()));\n@@ -372,3 +375,3 @@\n-  EXPECT_EQ(active_count(_storage), list_length(allocation_list));\n-  EXPECT_EQ(active_count(_storage), _storage.block_count());\n-  EXPECT_EQ(active_count(_storage), empty_block_count(_storage));\n+  EXPECT_EQ(active_count(storage()), list_length(allocation_list));\n+  EXPECT_EQ(active_count(storage()), storage().block_count());\n+  EXPECT_EQ(active_count(storage()), empty_block_count(storage()));\n@@ -386,1 +389,1 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -388,1 +391,1 @@\n-  AllocationList& allocation_list = TestAccess::allocation_list(_storage);\n+  AllocationList& allocation_list = TestAccess::allocation_list(storage());\n@@ -390,1 +393,1 @@\n-  EXPECT_EQ(_max_entries, total_allocation_count(_storage));\n+  EXPECT_EQ(_max_entries, total_allocation_count(storage()));\n@@ -397,1 +400,1 @@\n-      release_entry(_storage, _entries[i]);\n+      release_entry(storage(), _entries[i]);\n@@ -400,2 +403,2 @@\n-      EXPECT_EQ(_max_entries - released, total_allocation_count(_storage));\n-      EXPECT_TRUE(is_allocation_list_sorted(_storage));\n+      EXPECT_EQ(_max_entries - released, total_allocation_count(storage()));\n+      EXPECT_TRUE(is_allocation_list_sorted(storage()));\n@@ -405,4 +408,4 @@\n-  EXPECT_EQ(active_count(_storage), list_length(allocation_list));\n-  EXPECT_EQ(active_count(_storage), _storage.block_count());\n-  EXPECT_EQ(0u, total_allocation_count(_storage));\n-  EXPECT_EQ(list_length(allocation_list), empty_block_count(_storage));\n+  EXPECT_EQ(active_count(storage()), list_length(allocation_list));\n+  EXPECT_EQ(active_count(storage()), storage().block_count());\n+  EXPECT_EQ(0u, total_allocation_count(storage()));\n+  EXPECT_EQ(list_length(allocation_list), empty_block_count(storage()));\n@@ -416,1 +419,1 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n@@ -418,1 +421,1 @@\n-  AllocationList& allocation_list = TestAccess::allocation_list(_storage);\n+  AllocationList& allocation_list = TestAccess::allocation_list(storage());\n@@ -420,1 +423,1 @@\n-  EXPECT_EQ(_max_entries, total_allocation_count(_storage));\n+  EXPECT_EQ(_max_entries, total_allocation_count(storage()));\n@@ -429,1 +432,1 @@\n-      release_entry(_storage, _entries[i]);\n+      release_entry(storage(), _entries[i]);\n@@ -433,2 +436,2 @@\n-      EXPECT_EQ(_max_entries - released, total_allocation_count(_storage));\n-      EXPECT_TRUE(is_allocation_list_sorted(_storage));\n+      EXPECT_EQ(_max_entries - released, total_allocation_count(storage()));\n+      EXPECT_TRUE(is_allocation_list_sorted(storage()));\n@@ -436,1 +439,1 @@\n-        _entries[i] = _storage.allocate();\n+        _entries[i] = storage().allocate();\n@@ -438,2 +441,2 @@\n-        EXPECT_EQ(_max_entries - released, total_allocation_count(_storage));\n-        EXPECT_TRUE(is_allocation_list_sorted(_storage));\n+        EXPECT_EQ(_max_entries - released, total_allocation_count(storage()));\n+        EXPECT_TRUE(is_allocation_list_sorted(storage()));\n@@ -444,4 +447,4 @@\n-  EXPECT_EQ(active_count(_storage), list_length(allocation_list));\n-  EXPECT_EQ(active_count(_storage), _storage.block_count());\n-  EXPECT_EQ(0u, total_allocation_count(_storage));\n-  EXPECT_EQ(list_length(allocation_list), empty_block_count(_storage));\n+  EXPECT_EQ(active_count(storage()), list_length(allocation_list));\n+  EXPECT_EQ(active_count(storage()), storage().block_count());\n+  EXPECT_EQ(0u, total_allocation_count(storage()));\n+  EXPECT_EQ(list_length(allocation_list), empty_block_count(storage()));\n@@ -465,2 +468,2 @@\n-    _storage.release(to_release, nrelease);\n-    EXPECT_EQ(_max_entries - nrelease, _storage.allocation_count());\n+    storage().release(to_release, nrelease);\n+    EXPECT_EQ(_max_entries - nrelease, storage().allocation_count());\n@@ -469,2 +472,2 @@\n-      release_entry(_storage, _entries[2 * i + 1], false);\n-      EXPECT_EQ(_max_entries - nrelease - (i + 1), _storage.allocation_count());\n+      release_entry(storage(), _entries[2 * i + 1], false);\n+      EXPECT_EQ(_max_entries - nrelease - (i + 1), storage().allocation_count());\n@@ -472,1 +475,1 @@\n-    EXPECT_TRUE(process_deferred_updates(_storage));\n+    EXPECT_TRUE(process_deferred_updates(storage()));\n@@ -474,1 +477,1 @@\n-    EXPECT_EQ(_storage.block_count(), empty_block_count(_storage));\n+    EXPECT_EQ(storage().block_count(), empty_block_count(storage()));\n@@ -497,1 +500,1 @@\n-  AllocationList& allocation_list = TestAccess::allocation_list(_storage);\n+  AllocationList& allocation_list = TestAccess::allocation_list(storage());\n@@ -499,2 +502,2 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n-  size_t allocated = _storage.allocate(entries, max_entries);\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n+  size_t allocated = storage().allocate(entries, max_entries);\n@@ -507,1 +510,1 @@\n-    EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(entries[i]));\n+    EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, storage().allocation_status(entries[i]));\n@@ -512,2 +515,2 @@\n-  _storage.release(entries, allocated);\n-  EXPECT_EQ(0u, _storage.allocation_count());\n+  storage().release(entries, allocated);\n+  EXPECT_EQ(0u, storage().allocation_count());\n@@ -515,1 +518,1 @@\n-    EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, _storage.allocation_status(entries[i]));\n+    EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, storage().allocation_status(entries[i]));\n@@ -525,1 +528,1 @@\n-    EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(ptr));\n+    EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(ptr));\n@@ -533,1 +536,1 @@\n-    EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(ptr));\n+    EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(ptr));\n@@ -597,1 +600,1 @@\n-      entries[allocated] = _storage.allocate();\n+      entries[allocated] = storage().allocate();\n@@ -607,1 +610,1 @@\n-      VM_CountAtSafepoint<false> op(&_storage, &cl);\n+      VM_CountAtSafepoint<false> op(&storage(), &cl);\n@@ -620,1 +623,1 @@\n-      VM_CountAtSafepoint<true> op(&_storage, &cl);\n+      VM_CountAtSafepoint<true> op(&storage(), &cl);\n@@ -633,1 +636,1 @@\n-    release_entry(_storage, entries[--allocated], false);\n+    release_entry(storage(), entries[--allocated], false);\n@@ -635,1 +638,1 @@\n-  process_deferred_updates(_storage);\n+  process_deferred_updates(storage());\n@@ -654,1 +657,1 @@\n-    for ( ; empty_block_count(_storage) < 2; ++initial_release) {\n+    for ( ; empty_block_count(storage()) < 2; ++initial_release) {\n@@ -656,1 +659,1 @@\n-      release_entry(_storage, _entries[initial_release]);\n+      release_entry(storage(), _entries[initial_release]);\n@@ -661,1 +664,1 @@\n-      release_entry(_storage, _entries[i], false);\n+      release_entry(storage(), _entries[i], false);\n@@ -664,1 +667,1 @@\n-    process_deferred_updates(_storage);\n+    process_deferred_updates(storage());\n@@ -834,1 +837,1 @@\n-  VM_Verify<false> op(&_storage, &vstate);\n+  VM_Verify<false> op(&storage(), &vstate);\n@@ -845,1 +848,1 @@\n-  VM_Verify<true> op(&_storage, &vstate);\n+  VM_Verify<true> op(&storage(), &vstate);\n@@ -856,1 +859,1 @@\n-  VM_VerifyUsingOopsDo op(&_storage, &vstate);\n+  VM_VerifyUsingOopsDo op(&storage(), &vstate);\n@@ -949,1 +952,1 @@\n-  Task<false, false> task(\"test\", &_storage, &vstate);\n+  Task<false, false> task(\"test\", &storage(), &vstate);\n@@ -960,1 +963,1 @@\n-  Task<false, true> task(\"test\", &_storage, &vstate);\n+  Task<false, true> task(\"test\", &storage(), &vstate);\n@@ -971,1 +974,1 @@\n-  TaskUsingOopsDo<false, false> task(\"test\", &_storage, &vstate);\n+  TaskUsingOopsDo<false, false> task(\"test\", &storage(), &vstate);\n@@ -982,1 +985,1 @@\n-  TaskUsingOopsDo<false, true> task(\"test\", &_storage, &vstate);\n+  TaskUsingOopsDo<false, true> task(\"test\", &storage(), &vstate);\n@@ -993,1 +996,1 @@\n-  Task<true, false> task(\"test\", &_storage, &vstate);\n+  Task<true, false> task(\"test\", &storage(), &vstate);\n@@ -1000,1 +1003,1 @@\n-  Task<true, true> task(\"test\", &_storage, &vstate);\n+  Task<true, true> task(\"test\", &storage(), &vstate);\n@@ -1007,1 +1010,1 @@\n-  TaskUsingOopsDo<true, false> task(\"test\", &_storage, &vstate);\n+  TaskUsingOopsDo<true, false> task(\"test\", &storage(), &vstate);\n@@ -1014,1 +1017,1 @@\n-  TaskUsingOopsDo<true, true> task(\"test\", &_storage, &vstate);\n+  TaskUsingOopsDo<true, true> task(\"test\", &storage(), &vstate);\n@@ -1020,2 +1023,2 @@\n-  size_t initial_active_size = active_count(_storage);\n-  EXPECT_EQ(initial_active_size, _storage.block_count());\n+  size_t initial_active_size = active_count(storage());\n+  EXPECT_EQ(initial_active_size, storage().block_count());\n@@ -1024,1 +1027,1 @@\n-  for (size_t i = 0; empty_block_count(_storage) < 3; ++i) {\n+  for (size_t i = 0; empty_block_count(storage()) < 3; ++i) {\n@@ -1026,1 +1029,1 @@\n-    release_entry(_storage, _entries[i]);\n+    release_entry(storage(), _entries[i]);\n@@ -1029,3 +1032,3 @@\n-  EXPECT_EQ(initial_active_size, active_count(_storage));\n-  EXPECT_EQ(initial_active_size, _storage.block_count());\n-  EXPECT_EQ(3u, empty_block_count(_storage));\n+  EXPECT_EQ(initial_active_size, active_count(storage()));\n+  EXPECT_EQ(initial_active_size, storage().block_count());\n+  EXPECT_EQ(3u, empty_block_count(storage()));\n@@ -1034,1 +1037,1 @@\n-    while (_storage.delete_empty_blocks()) {}\n+    while (storage().delete_empty_blocks()) {}\n@@ -1036,3 +1039,3 @@\n-  EXPECT_EQ(0u, empty_block_count(_storage));\n-  EXPECT_EQ(initial_active_size - 3, active_count(_storage));\n-  EXPECT_EQ(initial_active_size - 3, _storage.block_count());\n+  EXPECT_EQ(0u, empty_block_count(storage()));\n+  EXPECT_EQ(initial_active_size - 3, active_count(storage()));\n+  EXPECT_EQ(initial_active_size - 3, storage().block_count());\n@@ -1045,1 +1048,1 @@\n-  release_entry(_storage, released);\n+  release_entry(storage(), released);\n@@ -1047,3 +1050,3 @@\n-  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));\n-  EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, _storage.allocation_status(released));\n-  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));\n+  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, storage().allocation_status(retained));\n+  EXPECT_EQ(OopStorage::UNALLOCATED_ENTRY, storage().allocation_status(released));\n+  EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(garbage));\n@@ -1054,1 +1057,1 @@\n-      release_entry(_storage, _entries[i], false);\n+      release_entry(storage(), _entries[i], false);\n@@ -1060,1 +1063,1 @@\n-    while (_storage.delete_empty_blocks()) {}\n+    while (storage().delete_empty_blocks()) {}\n@@ -1062,3 +1065,3 @@\n-  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, _storage.allocation_status(retained));\n-  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(released));\n-  EXPECT_EQ(OopStorage::INVALID_ENTRY, _storage.allocation_status(garbage));\n+  EXPECT_EQ(OopStorage::ALLOCATED_ENTRY, storage().allocation_status(retained));\n+  EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(released));\n+  EXPECT_EQ(OopStorage::INVALID_ENTRY, storage().allocation_status(garbage));\n@@ -1072,1 +1075,1 @@\n-  EXPECT_EQ(0u, _storage.block_count());\n+  EXPECT_EQ(0u, storage().block_count());\n@@ -1074,1 +1077,1 @@\n-  EXPECT_LT(0u, _storage.total_memory_usage());\n+  EXPECT_LT(0u, storage().total_memory_usage());\n@@ -1076,3 +1079,3 @@\n-  while (_storage.block_count() < goal_blocks) {\n-    size_t this_count = _storage.block_count();\n-    while (_storage.block_count() == this_count) {\n+  while (storage().block_count() < goal_blocks) {\n+    size_t this_count = storage().block_count();\n+    while (storage().block_count() == this_count) {\n@@ -1080,1 +1083,1 @@\n-      entries[allocated] = _storage.allocate();\n+      entries[allocated] = storage().allocate();\n@@ -1084,2 +1087,2 @@\n-    EXPECT_NE(0u, _storage.block_count());\n-    EXPECT_NE(0u, _storage.total_memory_usage());\n+    EXPECT_NE(0u, storage().block_count());\n+    EXPECT_NE(0u, storage().total_memory_usage());\n@@ -1088,2 +1091,2 @@\n-  EXPECT_LT(TestAccess::memory_per_block() * _storage.block_count(),\n-            _storage.total_memory_usage());\n+  EXPECT_LT(TestAccess::memory_per_block() * storage().block_count(),\n+            storage().total_memory_usage());\n@@ -1098,1 +1101,1 @@\n-    release_entry(_storage, _entries[i], false);\n+    release_entry(storage(), _entries[i], false);\n@@ -1104,1 +1107,1 @@\n-    release_entry(_storage, _entries[i], false);\n+    release_entry(storage(), _entries[i], false);\n@@ -1109,1 +1112,1 @@\n-  EXPECT_EQ(expected_entries, _storage.allocation_count());\n+  EXPECT_EQ(expected_entries, storage().allocation_count());\n@@ -1113,1 +1116,1 @@\n-  EXPECT_EQ(expected_blocks, _storage.block_count());\n+  EXPECT_EQ(expected_blocks, storage().block_count());\n@@ -1126,1 +1129,1 @@\n-                      _storage.total_memory_usage());\n+                      storage().total_memory_usage());\n@@ -1128,1 +1131,1 @@\n-    _storage.print_on(&st);\n+    storage().print_on(&st);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage.cpp","additions":155,"deletions":152,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+  OopStorage* _storage;\n+\n@@ -65,0 +67,1 @@\n+  OopStorage& storage() const { return *_storage; }\n@@ -71,1 +74,0 @@\n-  OopStorage _storage;\n@@ -88,1 +90,1 @@\n-  _storage(\"Test Storage\", mtGC)\n+  _storage(OopStorage::create(\"Test Storage\", mtGC))\n@@ -91,1 +93,1 @@\n-    _entries[i] = _storage.allocate();\n+    _entries[i] = storage().allocate();\n@@ -97,1 +99,2 @@\n-  _storage.release(_entries, ARRAY_SIZE(_entries));\n+  storage().release(_entries, ARRAY_SIZE(_entries));\n+  delete _storage;\n@@ -180,1 +183,1 @@\n-    Task task(&_storage, &closure, nthreads);\n+    Task task(&storage(), &closure, nthreads);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage_parperf.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  static void sig_handler(int sig, siginfo_t *info, ucontext_t *context) {\n+  static void sig_handler(int sig) {\n@@ -47,1 +47,1 @@\n-    act.sa_handler = (void (*)(int))sig_handler;\n+    act.sa_handler = sig_handler;\n","filename":"test\/hotspot\/gtest\/runtime\/test_signals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+#define LOG_HERE(s, ...) { printf(s, __VA_ARGS__); printf(\"\\n\"); fflush(stdout); }\n+\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -243,0 +243,1 @@\n+  check_format(INT32_FORMAT_X,         0x123,             \"0x123\");\n@@ -247,0 +248,1 @@\n+  check_format(UINT32_FORMAT_X,        0x123u,            \"0x123\");\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalDefinitions.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm_io.h\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/parseInteger.hpp\"\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+\n+template <typename T> const char* type_name();\n+template <> const char* type_name<uint64_t>() { return \"uint64_t\"; }\n+template <> const char* type_name<uint32_t>() { return \"uint32_t\"; }\n+template <> const char* type_name<int64_t>()  { return \"int64_t\"; }\n+template <> const char* type_name<int32_t>()  { return \"int32_t\"; }\n+\n+\/\/#define LOG(s, ...) LOG_HERE(s, __VA_ARGS__)\n+#define LOG(s, ...)\n+\n+template <typename T>\n+static void do_test_valid(T expected_value, const char* pattern) {\n+  LOG(\"%s: \\\"%s\\\", expect: \" UINT64_FORMAT \"(\" UINT64_FORMAT_X \")\", type_name<T>(), pattern,\n+      (uint64_t)expected_value, (uint64_t)expected_value);\n+  T value = 17;\n+  char* end = nullptr;\n+\n+  stringStream ss;\n+  ss.print_raw(pattern);\n+\n+  bool rc = parse_integer(ss.base(), &end, &value);\n+  ASSERT_TRUE(rc);\n+  ASSERT_EQ(value, expected_value);\n+\n+  rc = parse_integer(ss.base(), &value);\n+  ASSERT_TRUE(rc);\n+  ASSERT_EQ(value, expected_value);\n+\n+  \/\/ Now test with a trailing pattern.\n+  \/\/ parse_memory_size() should return remainder pointer,\n+  \/\/ parse_argument_memory_size() should flatly refuse to parse this.\n+  ss.print(\":-)\");\n+  rc = parse_integer(ss.base(), &end, &value);\n+  ASSERT_TRUE(rc);\n+  ASSERT_EQ(value, expected_value);\n+  ASSERT_EQ(end, ss.base() + strlen(pattern));\n+  ASSERT_EQ(strcmp(end, \":-)\"), 0);\n+\n+  rc = parse_integer(ss.base(), &value);\n+  ASSERT_FALSE(rc);\n+}\n+\n+template <typename T>\n+static void test_valid(T value, bool hex, T scale, const char* unit) {\n+  if ((std::numeric_limits<T>::max() \/ scale) >= value) {\n+    T expected_result = value * scale;\n+    stringStream ss;\n+    if (hex) {\n+      ss.print(UINT64_FORMAT_X \"%s\", (uint64_t)value, unit);  \/\/ e.g. \"0xFFFF\"\n+    } else {\n+      ss.print(UINT64_FORMAT \"%s\", (uint64_t)value, unit);    \/\/ e.g. \"65535\"\n+    }\n+    do_test_valid((T)expected_result, ss.base());\n+  }\n+}\n+\n+template <typename T>\n+static void test_valid_all_units(T value, bool hex) {\n+  test_valid(value, hex, (T)1, \"\");\n+  test_valid(value, hex, (T)K, \"k\");\n+  test_valid(value, hex, (T)K, \"K\");\n+  test_valid(value, hex, (T)M, \"m\");\n+  test_valid(value, hex, (T)M, \"M\");\n+  test_valid(value, hex, (T)G, \"g\");\n+  test_valid(value, hex, (T)G, \"G\");\n+  if (sizeof(T) > 4) {\n+    test_valid(value, hex, (T)((uint64_t)G * 1024), \"t\");\n+    test_valid(value, hex, (T)((uint64_t)G * 1024), \"T\");\n+  }\n+}\n+\n+template <typename T>\n+static void test_valid_all_power_of_twos() {\n+  for (int hex = 0; hex < 3; hex ++) {\n+    for (T i = 1; i != 0; i <<= 2) {\n+      test_valid_all_units(i - 1, hex == 1);\n+      test_valid_all_units(i, hex == 1);\n+      test_valid_all_units(i + 1, hex == 1);\n+    }\n+  }\n+}\n+\n+TEST(ParseMemorySize, positives) {\n+  test_valid_all_power_of_twos<uint64_t>();\n+  test_valid_all_power_of_twos<uint32_t>();\n+  test_valid_all_power_of_twos<int64_t>();\n+  test_valid_all_power_of_twos<int32_t>();\n+}\n+\n+\/\/ Test invalids.\n+\/\/ Note that parse_argument_memory_size is more restrictive than parse_memory_size, because\n+\/\/ the latter accepts trailing content.\n+\n+static void do_test_invalid_both(const char* pattern) {\n+  uint64_t value = 4711;\n+  char* end = nullptr;\n+\n+  LOG(\"%s\\n\", pattern);\n+\n+  bool rc = parse_integer(pattern, &end, &value);\n+  EXPECT_FALSE(rc);\n+  rc = parse_integer(pattern, &value);\n+  EXPECT_FALSE(rc);\n+}\n+\n+static void do_test_invalid_for_parse_arguments(const char* pattern) {\n+  uint64_t value = 4711;\n+  char* end = nullptr;\n+\n+  LOG(\"%s\\n\", pattern);\n+\n+  \/\/ The first overload parses until unrecognized chars are encountered, then\n+  \/\/ returns pointer to string remainder.\n+  bool rc = parse_integer(pattern, &end, &value);\n+  ASSERT_TRUE(rc);\n+  \/\/ The second overload parses everything; unrecognized chars will make it fail.\n+  rc = parse_integer(pattern, &value);\n+  ASSERT_FALSE(rc);\n+}\n+\n+TEST(ParseMemorySize, negatives_both) {\n+  do_test_invalid_both(\"\");\n+  do_test_invalid_both(\"abc\");\n+\n+  do_test_invalid_for_parse_arguments(\"100 M\"); \/\/ parse_memory_size would see \"100\", parse_argument_memory_size would reject it\n+  do_test_invalid_for_parse_arguments(\"100X\");  \/\/ parse_memory_size would see \"100\", parse_argument_memory_size would reject it\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_parse_memory_size.cpp","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -40,1 +40,1 @@\n-gc\/cslocker\/TestCSLocker.java 8293289 linux-x64,macosx-x64\n+gc\/cslocker\/TestCSLocker.java 8293289 generic-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -446,0 +446,1 @@\n+ -runtime\/cds\/appcds\/lambdaForm\/DefaultClassListLFInvokers.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8268883\n+ * @bug 8268883 8293833\n@@ -28,1 +28,2 @@\n- *\n+ *          Error mixing types with -XX:+UseCMoveUnconditionally -XX:+UseVectorCmov\n+ * @requires vm.compiler2.enabled\n@@ -30,0 +31,2 @@\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestCondAddDeadBranch\n+ *                   -XX:+UseCMoveUnconditionally -XX:+UseVectorCmov -XX:MaxVectorSize=32  TestCondAddDeadBranch\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCondAddDeadBranch.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-                 \"test20\",\"test21\", \"test22\"})\n+                 \"test20\", \"test21\", \"test22\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddLNodeIdealizationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,367 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.c2.irTests;\n-\n-import jdk.test.lib.Asserts;\n-import compiler.lib.ir_framework.*;\n-\n-\/*\n- * @test\n- * @bug 8279607\n- * @summary Test that transformation from ~x + c to (c - 1) - x and\n- *          from ~(x + c) to (-c - 1) - x works as intended.\n- * @library \/test\/lib \/\n- * @requires vm.compiler2.enabled\n- * @run driver compiler.c2.irTests.TestIRAddIdealNotXPlusC\n- *\/\n-public class TestIRAddIdealNotXPlusC {\n-\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.XOR_I})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    public int testIntConIsNormal1(int x) {\n-        return ~x + 1234; \/\/ transformed to 1233 - x\n-    }\n-\n-    @Run(test = \"testIntConIsNormal1\")\n-    public void checkTestIntConIsNormal1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(1223, testIntConIsNormal1(10));\n-        Asserts.assertEquals(1233, testIntConIsNormal1(0));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.XOR_I})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    public int testIntConIsNormal2(int x) {\n-        return ~(x + -1234); \/\/ transformed to 1233 - x\n-    }\n-\n-    @Run(test = \"testIntConIsNormal2\")\n-    public void checkTestIntConIsNormal2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(1223, testIntConIsNormal2(10));\n-        Asserts.assertEquals(1233, testIntConIsNormal2(0));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.XOR_L})\n-    @IR(counts = {IRNode.SUB_L, \"1\"})\n-    public long testLongConIsNormal1(long x) {\n-        return ~x + 123_456_789_123L; \/\/ transformed to 123_456_789_122L - x\n-    }\n-\n-    @Run(test = \"testLongConIsNormal1\")\n-    public void checkTestLongConIsNormal1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(113_456_789_122L, testLongConIsNormal1(10_000_000_000L));\n-        Asserts.assertEquals(123_456_789_122L, testLongConIsNormal1(0L));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.XOR_L})\n-    @IR(counts = {IRNode.SUB_L, \"1\"})\n-    public long testLongConIsNormal2(long x) {\n-        return ~(x + -123_456_789_123L); \/\/ transformed to 123_456_789_122L - x\n-    }\n-\n-    @Run(test = \"testLongConIsNormal2\")\n-    public void checkTestLongConIsNormal2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(113_456_789_122L, testLongConIsNormal2(10_000_000_000L));\n-        Asserts.assertEquals(123_456_789_122L, testLongConIsNormal2(0L));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.XOR_I})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    public int testIntConIsZero1(int x) {\n-        return ~x + 0; \/\/ transformed to -1 - x\n-    }\n-\n-    @Run(test = \"testIntConIsZero1\")\n-    public void checkTestIntConIsZero1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(-11, testIntConIsZero1(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.SUB_I})\n-    @IR(counts = {IRNode.XOR_I, \"1\"})\n-    public int testIntConIsZero2(int x) {\n-        return ~(x + 0); \/\/ should not happen, transformed to ~x\n-    }\n-\n-    @Run(test = \"testIntConIsZero2\")\n-    public void checkTestIntConIsZero2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(-11, testIntConIsZero2(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.XOR_L})\n-    @IR(counts = {IRNode.SUB_L, \"1\"})\n-    public long testLongConIsZero1(long x) {\n-        return ~x + 0L; \/\/ transformed to -1 - x\n-    }\n-\n-    @Run(test = \"testLongConIsZero1\")\n-    public void checkTestLongConIsZero1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(-10_000_000_001L, testLongConIsZero1(10_000_000_000L));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.SUB_L})\n-    @IR(counts = {IRNode.XOR_L, \"1\"})\n-    public long testLongConIsZero2(long x) {\n-        return ~(x + 0L); \/\/ should not happen, transformed to ~x\n-    }\n-\n-    @Run(test = \"testLongConIsZero2\")\n-    public void checkTestLongConIsZero2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(-10_000_000_001L, testLongConIsZero2(10_000_000_000L));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.XOR_I})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    public int testIntConIsOne1(int x) {\n-        return ~x + 1; \/\/ transformed to 0 - x\n-    }\n-\n-    @Run(test = \"testIntConIsOne1\")\n-    public void checkTestIntConIsOne1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(-10, testIntConIsOne1(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.XOR_I})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    public int testIntConIsNegOne2(int x) {\n-        return ~(x + -1); \/\/ transformed to 0 - x\n-    }\n-\n-    @Run(test = \"testIntConIsNegOne2\")\n-    public void checkTestIntConIsNegOne2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(-10, testIntConIsNegOne2(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.XOR_L})\n-    @IR(counts = {IRNode.SUB_L, \"1\"})\n-    public long testLongConIsOne1(long x) {\n-        return ~x + 1L; \/\/ transformed to 0 - x\n-    }\n-\n-    @Run(test = \"testLongConIsOne1\")\n-    public void checkTestLongConIsOne1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(-10_000_000_000L, testLongConIsOne1(10_000_000_000L));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.XOR_L})\n-    @IR(counts = {IRNode.SUB_L, \"1\"})\n-    public long testLongConIsNegOne2(long x) {\n-        return ~(x + -1L); \/\/ transformed to 0 - x\n-    }\n-\n-    @Run(test = \"testLongConIsNegOne2\")\n-    public void checkTestLongConIsNegOne2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(-10_000_000_000L, testLongConIsNegOne2(10_000_000_000L));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.XOR_I})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    public int testIntConMinusOneIsUnderflow1(int x) {\n-        return ~x + Integer.MIN_VALUE; \/\/ transformed to Integer.MAX_VALUE - x\n-    }\n-\n-    @Run(test = \"testIntConMinusOneIsUnderflow1\")\n-    public void checkTestIntConMinusOneIsUnderflow1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(2147483637, testIntConMinusOneIsUnderflow1(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.XOR_I})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    public int testIntNegConMinusOneIsUnderflow2(int x) {\n-        return ~(x + Integer.MIN_VALUE); \/\/ transformed to Integer.MAX_VALUE - x\n-    }\n-\n-    @Run(test = \"testIntNegConMinusOneIsUnderflow2\")\n-    public void checkTestIntNegConMinusOneIsUnderflow2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(2147483637, testIntNegConMinusOneIsUnderflow2(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.XOR_L})\n-    @IR(counts = {IRNode.SUB_L, \"1\"})\n-    public long testLongConMinusOneIsUnderflow1(long x) {\n-        return ~x + Long.MIN_VALUE; \/\/ transformed to Long.MAX_VALUE - x\n-    }\n-\n-    @Run(test = \"testLongConMinusOneIsUnderflow1\")\n-    public void checkTestLongConMinusOneIsUnderflow1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(9223372036854775797L, testLongConMinusOneIsUnderflow1(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.XOR_L})\n-    @IR(counts = {IRNode.SUB_L, \"1\"})\n-    public long testLongNegConMinusOneIsUnderflow2(long x) {\n-        return ~(x + Long.MIN_VALUE); \/\/ transformed to Long.MAX_VALUE - x\n-    }\n-\n-    @Run(test = \"testLongNegConMinusOneIsUnderflow2\")\n-    public void checkTestLongNegConMinusOneIsUnderflow2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(9223372036854775797L, testLongNegConMinusOneIsUnderflow2(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.XOR_I})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    public int testIntResultIsUnderflow1(int x) {\n-        return ~x + -2147483638; \/\/ transformed to -2147483639 - x\n-    }\n-\n-    @Run(test = \"testIntResultIsUnderflow1\")\n-    public void checkTestIntResultIsUnderflow1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(Integer.MAX_VALUE, testIntResultIsUnderflow1(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.XOR_I})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    public int testIntResultIsUnderflow2(int x) {\n-        return ~(x + 2147483638); \/\/ transformed to -2147483639 - x\n-    }\n-\n-    @Run(test = \"testIntResultIsUnderflow2\")\n-    public void checkTestIntResultIsUnderflow2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(Integer.MAX_VALUE, testIntResultIsUnderflow2(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.XOR_L})\n-    @IR(counts = {IRNode.SUB_L, \"1\"})\n-    public long testLongResultIsUnderflow1(long x) {\n-        return ~x + -9223372036854775798L; \/\/ transformed to -9223372036854775799L - x\n-    }\n-\n-    @Run(test = \"testLongResultIsUnderflow1\")\n-    public void checkTestLongResultIsUnderflow1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(Long.MAX_VALUE, testLongResultIsUnderflow1(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.XOR_L})\n-    @IR(counts = {IRNode.SUB_L, \"1\"})\n-    public long testLongResultIsUnderflow2(long x) {\n-        return ~(x + 9223372036854775798L); \/\/ transformed to -9223372036854775799L - x\n-    }\n-\n-    @Run(test = \"testLongResultIsUnderflow2\")\n-    public void checkTestLongResultIsUnderflow2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(Long.MAX_VALUE, testLongResultIsUnderflow2(10));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.XOR_I})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    public int testIntResultIsOverflow1(int x) {\n-        return ~x + 2147483637; \/\/ transformed to 2147483646 - x\n-    }\n-\n-    @Run(test = \"testIntResultIsOverflow1\")\n-    public void checkTestIntResultIsOverflow1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(Integer.MIN_VALUE, testIntResultIsOverflow1(-12));\n-    }\n-    @Test\n-    @IR(failOn = {IRNode.ADD_I, IRNode.XOR_I})\n-    @IR(counts = {IRNode.SUB_I, \"1\"})\n-    public int testIntResultIsOverflow2(int x) {\n-        return ~(x + -2147483637); \/\/ transformed to 2147483646 - x\n-    }\n-\n-    @Run(test = \"testIntResultIsOverflow2\")\n-    public void checkTestIntResultIsOverflow2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(Integer.MIN_VALUE, testIntResultIsOverflow2(-12));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.XOR_L})\n-    @IR(counts = {IRNode.SUB_L, \"1\"})\n-    public long testLongResultIsOverflow1(long x) {\n-        return ~x + 9223372036854775797L; \/\/ transformed to 9223372036854775798L - x\n-    }\n-\n-    @Run(test = \"testLongResultIsOverflow1\")\n-    public void checkTestLongResultIsOverflow1(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(Long.MIN_VALUE, testLongResultIsOverflow1(-12));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.ADD_L, IRNode.XOR_L})\n-    @IR(counts = {IRNode.SUB_L, \"1\"})\n-    public long testLongResultIsOverflow2(long x) {\n-        return ~(x + -9223372036854775797L); \/\/ transformed to 9223372036854775798L - x\n-    }\n-\n-    @Run(test = \"testLongResultIsOverflow2\")\n-    public void checkTestLongResultIsOverflow2(RunInfo info) {\n-        assertC2Compiled(info);\n-        Asserts.assertEquals(Long.MIN_VALUE, testLongResultIsOverflow2(-12));\n-    }\n-\n-    private void assertC2Compiled(RunInfo info) {\n-        \/\/ Test VM allows C2 to work\n-        Asserts.assertTrue(info.isC2CompilationEnabled());\n-        if (!info.isWarmUp()) {\n-            \/\/ C2 compilation happens\n-            Asserts.assertTrue(info.isTestC2Compiled());\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIRAddIdealNotXPlusC.java","additions":0,"deletions":367,"binary":false,"changes":367,"status":"deleted"},{"patch":"@@ -177,0 +177,9 @@\n+    @Test\n+    @IR(failOn = {IRNode.CMOVEVD})\n+    private static void testCMoveVDUnsupported() {\n+        int seed = 1001;\n+        for (int i = 0; i < doublec.length; i++) {\n+            doublec[i] = (i % 2 == 0) ? seed + i : seed - i;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8281453\n+ * @summary Convert ~x into -1-x when ~x is used in an arithmetic expression\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.XorINodeIdealizationTests\n+ *\/\n+public class XorINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\", \"test5\", \"test6\",\n+                 \"test7\", \"test8\", \"test9\",\n+                 \"test10\", \"test11\", \"test12\",\n+                 \"test13\", \"test14\", \"test15\",\n+                 \"test16\", \"test17\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+        int c = RunInfo.getRandom().nextInt();\n+        int d = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, 0, 0);\n+        assertResult(a, b, c, d);\n+        assertResult(min, min, min, min);\n+        assertResult(max, max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, int c, int d) {\n+        Asserts.assertEQ(b - a              , test1(a, b));\n+        Asserts.assertEQ(a - b              , test2(a, b));\n+        Asserts.assertEQ(b - a              , test3(a, b));\n+        Asserts.assertEQ(a - b              , test4(a, b));\n+        Asserts.assertEQ(b - a              , test5(a, b));\n+        Asserts.assertEQ(a + 1              , test6(a));\n+        Asserts.assertEQ(a                  , test7(a));\n+        Asserts.assertEQ((b + a) + 1        , test8(a, b));\n+        Asserts.assertEQ((-1 - a) - b       , test9(a, b));\n+        Asserts.assertEQ((b - a) + (-1)     , test10(a, b));\n+        Asserts.assertEQ((b - a) + (-1)     , test11(a, b));\n+        Asserts.assertEQ(~a                 , test12(a));\n+        Asserts.assertEQ(~a                 , test13(a));\n+        Asserts.assertEQ(~a                 , test14(a));\n+        Asserts.assertEQ(~a                 , test15(a));\n+        Asserts.assertEQ((~a + b) + (~a | c), test16(a, b, c));\n+        Asserts.assertEQ(-2023 - a          , test17(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (~x + y) + 1 => y - x\n+    public int test1(int x, int y) {\n+        return (~x + y) + 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + ~y) + 1 => x - y\n+    public int test2(int x, int y) {\n+        return (x + ~y) + 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks ~x + (y + 1) => y - x\n+    public int test3(int x, int y) {\n+        return ~x + (y + 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + 1) + ~y => x - y\n+    public int test4(int x, int y) {\n+        return (x + 1) + ~y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks ~x - ~y => y - x\n+    public int test5(int x, int y) {\n+        return ~x - ~y; \/\/ transformed to y - x\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.XOR})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks 0 - ~x => x + 1\n+    public int test6(int x) {\n+        return 0 - ~x; \/\/ transformed to x + 1\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.XOR, IRNode.ADD})\n+    \/\/ Checks -1 - ~x => x\n+    public int test7(int x) {\n+        return -1 - ~x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.XOR})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks y - ~x => (y + x) + 1\n+    public int test8(int x, int y) {\n+        return y - ~x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.XOR})\n+    @IR(counts = {IRNode.SUB, \"2\"})\n+    \/\/ Checks ~x - y => (-1 - x) -y\n+    public int test9(int x, int y) {\n+        return ~x - y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"})\n+    \/\/ Checks ~x + y => (y - x) + (-1)\n+    public int test10(int x, int y) {\n+        return ~x + y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"})\n+    \/\/ Checks y + ~x => (y - x) + (-1)\n+    public int test11(int x, int y) {\n+        return y + ~x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    \/\/ Checks ~(x + 0) => ~x, should not be transformed into -1-x\n+    public int test12(int x) {\n+        return ~(x + 0);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    \/\/ Checks ~(x - 0) => ~x, should not be transformed into -1-x\n+    public int test13(int x) {\n+        return ~(x - 0);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    \/\/ Checks ~x + 0 => ~x, should not be transformed into -1-x\n+    public int test14(int x) {\n+        return ~x + 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    \/\/ Checks ~x - 0 => ~x, should not be transformed into -1-x\n+    public int test15(int x) {\n+        return ~x - 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    \/\/ Checks ~x + y should NOT be transformed into (y - x) + (-1)\n+    \/\/ because ~x has one non-arithmetic user.\n+    public int test16(int x, int y, int z) {\n+        int u = ~x + y;\n+        int v = ~x | z;\n+        return u + v;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks ~(x + c) => (-c-1) - x\n+    public int test17(int x) {\n+        return ~(x + 2022);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorINodeIdealizationTests.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8281453\n+ * @summary Convert ~x into -1-x when ~x is used in an arithmetic expression\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.XorLNodeIdealizationTests\n+ *\/\n+public class XorLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\", \"test5\", \"test6\",\n+                 \"test7\", \"test8\", \"test9\",\n+                 \"test10\", \"test11\", \"test12\",\n+                 \"test13\", \"test14\", \"test15\",\n+                 \"test16\", \"test17\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+        long c = RunInfo.getRandom().nextLong();\n+        long d = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, 0, 0);\n+        assertResult(a, b, c, d);\n+        assertResult(min, min, min, min);\n+        assertResult(max, max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, long c, long d) {\n+        Asserts.assertEQ(b - a              , test1(a, b));\n+        Asserts.assertEQ(a - b              , test2(a, b));\n+        Asserts.assertEQ(b - a              , test3(a, b));\n+        Asserts.assertEQ(a - b              , test4(a, b));\n+        Asserts.assertEQ(b - a              , test5(a, b));\n+        Asserts.assertEQ(a + 1              , test6(a));\n+        Asserts.assertEQ(a                  , test7(a));\n+        Asserts.assertEQ((b + a) + 1        , test8(a, b));\n+        Asserts.assertEQ((-1 - a) - b       , test9(a, b));\n+        Asserts.assertEQ((b - a) + (-1)     , test10(a, b));\n+        Asserts.assertEQ((b - a) + (-1)     , test11(a, b));\n+        Asserts.assertEQ(~a                 , test12(a));\n+        Asserts.assertEQ(~a                 , test13(a));\n+        Asserts.assertEQ(~a                 , test14(a));\n+        Asserts.assertEQ(~a                 , test15(a));\n+        Asserts.assertEQ((~a + b) + (~a | c), test16(a, b, c));\n+        Asserts.assertEQ(-2023 - a          , test17(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (~x + y) + 1 => y - x\n+    public long test1(long x, long y) {\n+        return (~x + y) + 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + ~y) + 1 => x - y\n+    public long test2(long x, long y) {\n+        return (x + ~y) + 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks ~x + (y + 1) => y - x\n+    public long test3(long x, long y) {\n+        return ~x + (y + 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + 1) + ~y => x - y\n+    public long test4(long x, long y) {\n+        return (x + 1) + ~y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks ~x - ~y => y - x\n+    public long test5(long x, long y) {\n+        return ~x - ~y; \/\/ transformed to y - x\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.XOR})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks 0 - ~x => x + 1\n+    public long test6(long x) {\n+        return 0 - ~x; \/\/ transformed to x + 1\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.XOR, IRNode.ADD})\n+    \/\/ Checks -1 - ~x => x\n+    public long test7(long x) {\n+        return -1 - ~x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.XOR})\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks y - ~x => (y + x) + 1\n+    public long test8(long x, long y) {\n+        return y - ~x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.XOR})\n+    @IR(counts = {IRNode.SUB, \"2\"})\n+    \/\/ Checks ~x - y => (-1 - x) -y\n+    public long test9(long x, long y) {\n+        return ~x - y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"})\n+    \/\/ Checks ~x + y => (y - x) + (-1)\n+    public long test10(long x, long y) {\n+        return ~x + y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"})\n+    \/\/ Checks y + ~x => (y - x) + (-1)\n+    public long test11(long x, long y) {\n+        return y + ~x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    \/\/ Checks ~(x + 0) => ~x, should not be transformed into -1-x\n+    public long test12(long x) {\n+        return ~(x + 0);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    \/\/ Checks ~(x - 0) => ~x, should not be transformed into -1-x\n+    public long test13(long x) {\n+        return ~(x - 0);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    \/\/ Checks ~x + 0 => ~x, should not be transformed into -1-x\n+    public long test14(long x) {\n+        return ~x + 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    \/\/ Checks ~x - 0 => ~x, should not be transformed into -1-x\n+    public long test15(long x) {\n+        return ~x - 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.XOR, \"1\"})\n+    \/\/ Checks ~x + y should NOT be transformed into (y - x) + (-1)\n+    \/\/ because ~x has one non-arithmetic user.\n+    public long test16(long x, long y, long z) {\n+        long u = ~x + y;\n+        long v = ~x | z;\n+        return u + v;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.XOR, IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks ~(x + c) => (-c-1) - x\n+    public long test17(long x) {\n+        return ~(x + 2022);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/XorLNodeIdealizationTests.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -94,0 +94,1 @@\n+        Asserts.assertNotEquals(nmethod.getStart(), 0L);\n@@ -99,0 +100,1 @@\n+        Asserts.assertEquals(nmethod.getStart(), 0L);\n@@ -104,0 +106,1 @@\n+        Asserts.assertEquals(nmethod.getStart(), 0L);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/InvalidateInstalledCodeTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.vm.ci.riscv64.RISCV64;\n@@ -33,0 +34,1 @@\n+import jdk.vm.ci.code.test.riscv64.RISCV64TestAssembler;\n@@ -79,0 +81,2 @@\n+        } else if (arch instanceof RISCV64) {\n+            return new RISCV64TestAssembler(codeCache, config);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/CodeInstallationTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/DataPatchTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/InterpreterFrameSizeTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -37,1 +37,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/MaxOopMapStackOffsetTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -37,1 +37,2 @@\n- * @compile CodeInstallationTest.java TestHotSpotVMConfig.java NativeCallTest.java TestAssembler.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java TestHotSpotVMConfig.java NativeCallTest.java TestAssembler.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/NativeCallTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleCodeInstallationTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleDebugInfoTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\"\n+ * @requires vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\" | vm.simpleArch == \"riscv64\"\n@@ -36,1 +36,2 @@\n- * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.riscv64\n+ * @compile CodeInstallationTest.java DebugInfoTest.java TestAssembler.java TestHotSpotVMConfig.java amd64\/AMD64TestAssembler.java aarch64\/AArch64TestAssembler.java riscv64\/RISCV64TestAssembler.java\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/VirtualObjectDebugInfoTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,542 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.vm.ci.code.test.riscv64;\n+\n+import jdk.vm.ci.code.CallingConvention;\n+import jdk.vm.ci.code.CodeCacheProvider;\n+import jdk.vm.ci.code.DebugInfo;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.RegisterValue;\n+import jdk.vm.ci.code.StackSlot;\n+import jdk.vm.ci.code.site.ConstantReference;\n+import jdk.vm.ci.code.site.DataSectionReference;\n+import jdk.vm.ci.code.test.TestAssembler;\n+import jdk.vm.ci.code.test.TestHotSpotVMConfig;\n+import jdk.vm.ci.hotspot.HotSpotCallingConventionType;\n+import jdk.vm.ci.hotspot.HotSpotConstant;\n+import jdk.vm.ci.hotspot.HotSpotForeignCallTarget;\n+import jdk.vm.ci.meta.AllocatableValue;\n+import jdk.vm.ci.meta.JavaKind;\n+import jdk.vm.ci.meta.VMConstant;\n+import jdk.vm.ci.riscv64.RISCV64;\n+import jdk.vm.ci.riscv64.RISCV64Kind;\n+\n+public class RISCV64TestAssembler extends TestAssembler {\n+\n+    private static final Register scratchRegister = RISCV64.x5;\n+    private static final Register doubleScratch = RISCV64.f5;\n+\n+    public RISCV64TestAssembler(CodeCacheProvider codeCache, TestHotSpotVMConfig config) {\n+        super(codeCache, config,\n+              16 \/* initialFrameSize *\/, 16 \/* stackAlignment *\/,\n+              RISCV64Kind.DWORD \/* narrowOopKind *\/,\n+              \/* registers *\/\n+              RISCV64.x10, RISCV64.x11, RISCV64.x12, RISCV64.x13,\n+              RISCV64.x14, RISCV64.x15, RISCV64.x16, RISCV64.x17);\n+    }\n+\n+    private static int f(int val, int msb, int lsb) {\n+        int nbits = msb - lsb + 1;\n+        assert val >= 0;\n+        assert val < (1 << nbits);\n+        assert msb >= lsb;\n+        return val << lsb;\n+    }\n+\n+    private static int f(Register r, int msb, int lsb) {\n+        assert msb - lsb == 4;\n+        return f(r.encoding, msb, lsb);\n+    }\n+\n+    private static int instructionImmediate(int imm, int rs1, int funct, int rd, int opcode) {\n+        return f(imm, 31, 20) | f(rs1, 19, 15) | f(funct, 14, 12) | f(rd, 11, 7) | f(opcode, 6, 0);\n+    }\n+\n+    private static int instructionRegister(int funct7, int rs2, int rs1, int funct3, int rd, int opcode) {\n+        return f(funct7, 31, 25) | f(rs2, 24, 20) | f(rs1, 19, 15) | f(funct3, 14, 12) | f(rd, 11, 7) | f(opcode, 6, 0);\n+    }\n+\n+    private void emitNop() {\n+        code.emitInt(instructionImmediate(0, 0, 0b000, 0, 0b0010011));\n+    }\n+\n+    private void emitAdd(Register Rd, Register Rm, Register Rn) {\n+        \/\/ ADD\n+        code.emitInt(instructionRegister(0b0000000, Rn.encoding, Rm.encoding, 0b000, Rd.encoding, 0b0110011));\n+    }\n+\n+    private void emitAdd(Register Rd, Register Rn, int imm12) {\n+        \/\/ ADDI\n+        code.emitInt(instructionImmediate(imm12 & 0xfff, Rn.encoding, 0b000, Rd.encoding, 0b0010011));\n+    }\n+\n+    private void emitAddW(Register Rd, Register Rn, int imm12) {\n+        \/\/ ADDIW\n+        code.emitInt(instructionImmediate(imm12 & 0xfff, Rn.encoding, 0b000, Rd.encoding, 0b0011011));\n+    }\n+\n+    private void emitSub(Register Rd, Register Rn, int imm12) {\n+        \/\/ SUBI\n+        emitAdd(Rd, Rn, -imm12);;\n+    }\n+\n+    private void emitSub(Register Rd, Register Rm, Register Rn) {\n+        \/\/ SUB\n+        code.emitInt(instructionRegister(0b0100000, Rn.encoding, Rm.encoding, 0b000, Rd.encoding, 0b0110011));\n+    }\n+\n+    private void emitMv(Register Rd, Register Rn) {\n+        \/\/ MV\n+        code.emitInt(instructionRegister(0b0000000, 0, Rn.encoding, 0b000, Rd.encoding, 0b0110011));\n+    }\n+\n+    private void emitShiftLeft(Register Rd, Register Rn, int shift) {\n+        \/\/ SLLI\n+        code.emitInt(instructionImmediate(shift & 0x3f, Rn.encoding, 0b001, Rd.encoding, 0b0010011));\n+    }\n+\n+    private void emitShiftRight(Register Rd, Register Rn, int shift) {\n+        \/\/ SRLI\n+        code.emitInt(instructionImmediate(shift & 0x3f, Rn.encoding, 0b101, Rd.encoding, 0b0010011));\n+    }\n+\n+    private void emitLui(Register Rd, int imm20) {\n+        \/\/ LUI\n+        code.emitInt(f(imm20, 31, 12) | f(Rd, 11, 7) | f(0b0110111, 6, 0));\n+    }\n+\n+    private void emitAuipc(Register Rd, int imm20) {\n+        \/\/ AUIPC\n+        code.emitInt(f(imm20, 31, 12) | f(Rd, 11, 7) | f(0b0010111, 6, 0));\n+    }\n+\n+    private void emitLoadImmediate(Register Rd, int imm32) {\n+        long upper = imm32, lower = imm32;\n+        lower = (lower << 52) >> 52;\n+        upper -= lower;\n+        upper = (int) upper;\n+        emitLui(Rd, ((int) (upper >> 12)) & 0xfffff);\n+        emitAddW(Rd, Rd, (int) lower);\n+    }\n+\n+    private void emitLoadRegister(Register Rd, RISCV64Kind kind, Register Rn, int offset) {\n+        \/\/ LB\/LH\/LW\/LD (immediate)\n+        assert offset >= 0;\n+        int size = 0;\n+        int opc = 0;\n+        switch (kind) {\n+            case BYTE: size = 0b000; opc = 0b0000011; break;\n+            case WORD: size = 0b001; opc = 0b0000011; break;\n+            case DWORD: size = 0b010; opc = 0b0000011; break;\n+            case QWORD: size = 0b011; opc = 0b0000011; break;\n+            case SINGLE: size = 0b010; opc = 0b0000111; break;\n+            case DOUBLE: size = 0b011; opc = 0b0000111; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f(offset, 31, 20) | f(Rn, 19, 15) | f(size, 14, 12) | f(Rd, 11, 7) | f(opc, 6, 0));\n+    }\n+\n+    private void emitStoreRegister(Register Rd, RISCV64Kind kind, Register Rn, int offset) {\n+        \/\/ SB\/SH\/SW\/SD (immediate)\n+        assert offset >= 0;\n+        int size = 0;\n+        int opc = 0;\n+        switch (kind) {\n+            case BYTE: size = 0b000; opc = 0b0100011; break;\n+            case WORD: size = 0b001; opc = 0b0100011; break;\n+            case DWORD: size = 0b010; opc = 0b0100011; break;\n+            case QWORD: size = 0b011; opc = 0b0100011; break;\n+            case SINGLE: size = 0b010; opc = 0b0100111; break;\n+            case DOUBLE: size = 0b011; opc = 0b0100111; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(f((offset >> 5), 31, 25) | f(Rd, 24, 20) | f(Rn, 19, 15) | f(size, 14, 12) | f((offset & 0x1f), 11, 7) | f(opc, 6, 0));\n+    }\n+\n+    private void emitJalr(Register Rd, Register Rn, int imm) {\n+        code.emitInt(instructionImmediate(imm & 0xfff, Rn.encoding, 0b000, Rd.encoding, 0b1100111));\n+    }\n+\n+    private void emitFmv(Register Rd, RISCV64Kind kind, Register Rn) {\n+        int funct = 0;\n+        switch (kind) {\n+            case SINGLE: funct = 0b1111000; break;\n+            case DOUBLE: funct = 0b1111001; break;\n+            default: throw new IllegalArgumentException();\n+        }\n+        code.emitInt(instructionRegister(funct, 0b00000, Rn.encoding, 0b000, Rd.encoding, 0b1010011));\n+    }\n+\n+    @Override\n+    public void emitGrowStack(int size) {\n+        assert size % 16 == 0;\n+        if (size > -2048 && size < 0) {\n+            emitAdd(RISCV64.x2, RISCV64.x2, -size);\n+        } else if (size == 0) {\n+            \/\/ No-op\n+        } else if (size < 2048) {\n+            emitSub(RISCV64.x2, RISCV64.x2, size);\n+        } else if (size < 65535) {\n+            emitLoadImmediate(scratchRegister, size);\n+            emitSub(RISCV64.x2, RISCV64.x2, scratchRegister);\n+        } else {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    @Override\n+    public void emitPrologue() {\n+        \/\/ Must be patchable by NativeJump::patch_verified_entry\n+        emitNop();\n+        emitAdd(RISCV64.x2, RISCV64.x2, -32); \/\/ addi sp sp -32\n+        emitStoreRegister(RISCV64.x8, RISCV64Kind.QWORD, RISCV64.x2, 0); \/\/ sd x8 sp(0)\n+        emitStoreRegister(RISCV64.x1, RISCV64Kind.QWORD, RISCV64.x2, 8); \/\/ sd x1 sp(8)\n+        emitMv(RISCV64.x8, RISCV64.x2); \/\/ mv x8, x2\n+\n+        setDeoptRescueSlot(newStackSlot(RISCV64Kind.QWORD));\n+    }\n+\n+    @Override\n+    public void emitEpilogue() {\n+        recordMark(config.MARKID_DEOPT_HANDLER_ENTRY);\n+        recordCall(new HotSpotForeignCallTarget(config.handleDeoptStub), 6*4, true, null);\n+        emitCall(0xdeaddeaddeadL);\n+    }\n+\n+    @Override\n+    public void emitCallPrologue(CallingConvention cc, Object... prim) {\n+        emitGrowStack(cc.getStackSize());\n+        frameSize += cc.getStackSize();\n+        AllocatableValue[] args = cc.getArguments();\n+        for (int i = 0; i < args.length; i++) {\n+            emitLoad(args[i], prim[i]);\n+        }\n+    }\n+\n+    @Override\n+    public void emitCallEpilogue(CallingConvention cc) {\n+        emitGrowStack(-cc.getStackSize());\n+        frameSize -= cc.getStackSize();\n+    }\n+\n+    @Override\n+    public void emitCall(long addr) {\n+        emitMovPtrHelper(scratchRegister, addr);\n+        emitJalr(RISCV64.x1, scratchRegister, (int) (addr & 0x3f));\n+    }\n+\n+    @Override\n+    public void emitLoad(AllocatableValue av, Object prim) {\n+        if (av instanceof RegisterValue) {\n+            Register reg = ((RegisterValue) av).getRegister();\n+            if (prim instanceof Float) {\n+                emitLoadFloat(reg, (Float) prim);\n+            } else if (prim instanceof Double) {\n+                emitLoadDouble(reg, (Double) prim);\n+            } else if (prim instanceof Integer) {\n+                emitLoadInt(reg, (Integer) prim);\n+            } else if (prim instanceof Long) {\n+                emitLoadLong(reg, (Long) prim);\n+            }\n+        } else if (av instanceof StackSlot) {\n+            StackSlot slot = (StackSlot) av;\n+            if (prim instanceof Float) {\n+                emitFloatToStack(slot, emitLoadFloat(doubleScratch, (Float) prim));\n+            } else if (prim instanceof Double) {\n+                emitDoubleToStack(slot, emitLoadDouble(doubleScratch, (Double) prim));\n+            } else if (prim instanceof Integer) {\n+                emitIntToStack(slot, emitLoadInt(scratchRegister, (Integer) prim));\n+            } else if (prim instanceof Long) {\n+                emitLongToStack(slot, emitLoadLong(scratchRegister, (Long) prim));\n+            } else {\n+                assert false : \"Unimplemented\";\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown value \" + av);\n+        }\n+    }\n+\n+    private void emitLoad32(Register ret, int addr) {\n+        long upper = addr, lower = addr;\n+        lower = (lower << 52) >> 52;\n+        upper -= lower;\n+        upper = (int) upper;\n+        emitLui(ret, ((int) (upper >> 12)) & 0xfffff);\n+        emitAdd(ret, ret, (int) lower);\n+    }\n+\n+    private void emitMovPtrHelper(Register ret, long addr) {\n+        \/\/ 48-bit VA\n+        assert (addr >> 48) == 0 : \"invalid pointer\" + Long.toHexString(addr);\n+        emitLoad32(ret, (int) (addr >> 17));\n+        emitShiftLeft(ret, ret, 11);\n+        emitAdd(ret, ret, (int) ((addr >> 6) & 0x7ff));\n+        emitShiftLeft(ret, ret, 6);\n+    }\n+\n+    private void emitLoadPointer32(Register ret, int addr) {\n+        emitLoadImmediate(ret, addr);\n+        \/\/ Lui sign-extends the value, which we do not want\n+        emitShiftLeft(ret, ret, 32);\n+        emitShiftRight(ret, ret, 32);\n+    }\n+\n+    private void emitLoadPointer48(Register ret, long addr) {\n+        emitMovPtrHelper(ret, addr);\n+        emitAdd(ret, ret, (int) (addr & 0x3f));\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(HotSpotConstant c) {\n+        recordDataPatchInCode(new ConstantReference((VMConstant) c));\n+\n+        Register ret = newRegister();\n+        if (c.isCompressed()) {\n+            emitLoadPointer32(ret, 0xdeaddead);\n+        } else {\n+            emitLoadPointer48(ret, 0xdeaddeaddeadL);\n+        }\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(Register b, int offset) {\n+        Register ret = newRegister();\n+        emitLoadRegister(ret, RISCV64Kind.QWORD, b, offset & 0xfff);\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadNarrowPointer(DataSectionReference ref) {\n+        recordDataPatchInCode(ref);\n+\n+        Register ret = newRegister();\n+        emitAuipc(ret, 0xdead >> 11);\n+        emitLoadRegister(ret, RISCV64Kind.DWORD, ret, 0xdead & 0x7ff);\n+        \/\/ The value is sign-extendsed, which we do not want\n+        emitShiftLeft(ret, ret, 32);\n+        emitShiftRight(ret, ret, 32);\n+        return ret;\n+    }\n+\n+    @Override\n+    public Register emitLoadPointer(DataSectionReference ref) {\n+        recordDataPatchInCode(ref);\n+\n+        Register ret = newRegister();\n+        emitAuipc(ret, 0xdead >> 11);\n+        emitLoadRegister(ret, RISCV64Kind.QWORD, ret, 0xdead & 0x7ff);\n+        return ret;\n+    }\n+\n+    private Register emitLoadDouble(Register reg, double c) {\n+        DataSectionReference ref = new DataSectionReference();\n+        ref.setOffset(data.position());\n+        data.emitDouble(c);\n+\n+        recordDataPatchInCode(ref);\n+        emitAuipc(scratchRegister, 0xdead >> 11);\n+        emitLoadRegister(scratchRegister, RISCV64Kind.QWORD, scratchRegister, 0xdead & 0x7ff);\n+        if (reg.getRegisterCategory().equals(RISCV64.FP)) {\n+            emitFmv(reg, RISCV64Kind.DOUBLE, scratchRegister);\n+        } else {\n+            emitMv(reg, scratchRegister);\n+        }\n+        return reg;\n+    }\n+\n+    private Register emitLoadFloat(Register reg, float c) {\n+        DataSectionReference ref = new DataSectionReference();\n+        ref.setOffset(data.position());\n+        data.emitFloat(c);\n+\n+        recordDataPatchInCode(ref);\n+        emitAuipc(scratchRegister, 0xdead >> 11);\n+        emitLoadRegister(scratchRegister, RISCV64Kind.DWORD, scratchRegister, 0xdead & 0x7ff);\n+        if (reg.getRegisterCategory().equals(RISCV64.FP)) {\n+            emitFmv(reg, RISCV64Kind.SINGLE, scratchRegister);\n+        } else {\n+            emitMv(reg, scratchRegister);\n+        }\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadFloat(float c) {\n+        Register ret = RISCV64.f10;\n+        return emitLoadFloat(ret, c);\n+    }\n+\n+    private Register emitLoadLong(Register reg, long c) {\n+        long lower = c & 0xffffffff;\n+        lower = lower - ((lower << 44) >> 44);\n+        emitLoad32(reg, (int) ((c >> 32) & 0xffffffff));\n+        emitShiftLeft(reg, reg, 12);\n+        emitAdd(reg, reg, (int) ((lower >> 20) & 0xfff));\n+        emitShiftLeft(reg, reg, 12);\n+        emitAdd(reg, reg, (int) ((c << 44) >> 52));\n+        emitShiftLeft(reg, reg, 8);\n+        emitAdd(reg, reg, (int) (c & 0xff));\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadLong(long c) {\n+        Register ret = newRegister();\n+        return emitLoadLong(ret, c);\n+    }\n+\n+    private Register emitLoadInt(Register reg, int c) {\n+        emitLoadImmediate(reg, c);\n+        return reg;\n+    }\n+\n+    @Override\n+    public Register emitLoadInt(int c) {\n+        Register ret = newRegister();\n+        return emitLoadInt(ret, c);\n+    }\n+\n+    @Override\n+    public Register emitIntArg0() {\n+        return codeCache.getRegisterConfig()\n+            .getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int)\n+            .get(0);\n+    }\n+\n+    @Override\n+    public Register emitIntArg1() {\n+        return codeCache.getRegisterConfig()\n+            .getCallingConventionRegisters(HotSpotCallingConventionType.JavaCall, JavaKind.Int)\n+            .get(1);\n+    }\n+\n+    @Override\n+    public Register emitIntAdd(Register a, Register b) {\n+        emitAdd(a, a, b);\n+        return a;\n+    }\n+\n+    @Override\n+    public void emitTrap(DebugInfo info) {\n+        \/\/ Dereference null pointer\n+        emitAdd(scratchRegister, RISCV64.x0, 0);\n+        recordImplicitException(info);\n+        emitLoadRegister(RISCV64.x0, RISCV64Kind.QWORD, scratchRegister, 0);\n+    }\n+\n+    @Override\n+    public void emitIntRet(Register a) {\n+        emitMv(RISCV64.x10, a);\n+        emitMv(RISCV64.x2, RISCV64.x8);  \/\/ mv sp, x8\n+        emitLoadRegister(RISCV64.x8, RISCV64Kind.QWORD, RISCV64.x2, 0);  \/\/ ld x8 0(sp)\n+        emitLoadRegister(RISCV64.x1, RISCV64Kind.QWORD, RISCV64.x2, 8);  \/\/ ld x1 8(sp)\n+        emitAdd(RISCV64.x2, RISCV64.x2, 32);  \/\/ addi sp sp 32\n+        emitJalr(RISCV64.x0, RISCV64.x1, 0);  \/\/ ret\n+    }\n+\n+    @Override\n+    public void emitFloatRet(Register a) {\n+        assert a == RISCV64.f10 : \"Unimplemented move \" + a;\n+        emitMv(RISCV64.x2, RISCV64.x8);  \/\/ mv sp, x8\n+        emitLoadRegister(RISCV64.x8, RISCV64Kind.QWORD, RISCV64.x2, 0);  \/\/ ld x8 0(sp)\n+        emitLoadRegister(RISCV64.x1, RISCV64Kind.QWORD, RISCV64.x2, 8);  \/\/ ld x1 8(sp)\n+        emitAdd(RISCV64.x2, RISCV64.x2, 32);  \/\/ addi sp sp 32\n+        emitJalr(RISCV64.x0, RISCV64.x1, 0);  \/\/ ret\n+    }\n+\n+    @Override\n+    public void emitPointerRet(Register a) {\n+        emitIntRet(a);\n+    }\n+\n+    @Override\n+    public StackSlot emitPointerToStack(Register a) {\n+        return emitLongToStack(a);\n+    }\n+\n+    @Override\n+    public StackSlot emitNarrowPointerToStack(Register a) {\n+        return emitIntToStack(a);\n+    }\n+\n+    @Override\n+    public Register emitUncompressPointer(Register compressed, long base, int shift) {\n+        if (shift > 0) {\n+            emitShiftLeft(compressed, compressed, shift);\n+        }\n+\n+        if (base != 0) {\n+            emitLoadLong(scratchRegister, base);\n+            emitAdd(compressed, compressed, scratchRegister);\n+        }\n+\n+        return compressed;\n+    }\n+\n+    private StackSlot emitDoubleToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.DOUBLE, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitDoubleToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.DOUBLE);\n+        return emitDoubleToStack(ret, a);\n+    }\n+\n+    private StackSlot emitFloatToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.SINGLE, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitFloatToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.SINGLE);\n+        return emitFloatToStack(ret, a);\n+    }\n+\n+    private StackSlot emitIntToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.DWORD, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitIntToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.DWORD);\n+        return emitIntToStack(ret, a);\n+    }\n+\n+    private StackSlot emitLongToStack(StackSlot slot, Register a) {\n+        emitStoreRegister(a, RISCV64Kind.QWORD, RISCV64.x2, slot.getOffset(frameSize) & 0xfff);\n+        return slot;\n+    }\n+\n+    @Override\n+    public StackSlot emitLongToStack(Register a) {\n+        StackSlot ret = newStackSlot(RISCV64Kind.QWORD);\n+        return emitLongToStack(ret, a);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/riscv64\/RISCV64TestAssembler.java","additions":542,"deletions":0,"binary":false,"changes":542,"status":"added"},{"patch":"@@ -154,0 +154,1 @@\n+    public static final String XOR = START + \"Xor(I|L)\" + MID + END;\n@@ -204,0 +205,1 @@\n+    public static final String VECTOR_MASK_CAST = START + \"VectorMaskCast\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8268017\n+ * @bug 8268017 8293833\n@@ -28,1 +28,2 @@\n- *\n+ *          Error mixing types with -XX:+UseCMoveUnconditionally -XX:+UseVectorCmov\n+ * @requires vm.compiler2.enabled\n@@ -30,0 +31,2 @@\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestCastFFAtPhi -XX:+UseCMoveUnconditionally\n+ *                   -XX:+UseVectorCmov -XX:MaxVectorSize=32 TestCastFFAtPhi\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestCastFFAtPhi.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *      -XX:+IgnoreUnrecognizedVMOptions -XX:StressLongCountedLoop=0\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestRemoveEmptyLoop.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,4 @@\n- * @summary Test various reverse bytes ideal transforms on X86(AVX2, AVX512) and AARCH64(NEON)\n+ * @summary Test various reverse bytes ideal transforms on X86(AVX2, AVX512) and AArch64(NEON).\n+ *          For AArch64(SVE), we have a specific optimization,\n+ *          ReverseBytesV (ReverseBytesV X MASK) MASK => X, which eliminates both ReverseBytesV\n+ *          nodes. The test cases for AArch64(SVE) are in TestReverseByteTransformsSVE.java.\n@@ -42,0 +45,1 @@\n+ * @requires !(vm.cpu.features ~= \".*sve.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestReverseByteTransforms.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-* @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx512dq.*\")\n@@ -90,1 +89,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -107,1 +106,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"}, applyIfCPUFeature = {\"avx512dq\", \"true\"})\n@@ -124,1 +123,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -141,1 +140,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_F2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -158,1 +157,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -175,1 +174,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"}, applyIfCPUFeature = {\"avx512dq\", \"true\"})\n@@ -192,1 +191,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n@@ -209,1 +208,1 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_D2X, \"> 0\"}, applyIfCPUFeature = {\"avx512f\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorFPtoIntCastTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n@@ -26,0 +26,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -35,1 +37,0 @@\n-import jdk.test.lib.Utils;\n@@ -37,2 +38,2 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n@@ -42,1 +43,1 @@\n- * @bug 8273264\n+ * @bug 8273264 8292898\n@@ -44,2 +45,2 @@\n- * @library \/test\/lib\n- * @summary AArch64: [vector] Add missing rules for VectorMaskCast\n+ * @library \/test\/lib \/\n+ * @summary Unify vector mask cast and add missing rules for VectorMaskCast\n@@ -48,1 +49,1 @@\n- * @run testng\/othervm -XX:-TieredCompilation -XX:CompileThreshold=100 compiler.vectorapi.VectorMaskCastTest\n+ * @run driver compiler.vectorapi.VectorMaskCastTest\n@@ -51,1 +52,0 @@\n-\n@@ -59,1 +59,1 @@\n-public class VectorMaskCastTest{\n+public class VectorMaskCastTest {\n@@ -61,1 +61,0 @@\n-    private static final int NUM_ITER = 5000;\n@@ -64,4 +63,6 @@\n-    public static boolean[] genMask() {\n-        boolean[] mask = new boolean[64];\n-        for (int i = 0; i < 64; i ++) {\n-            mask[i] = rd.nextBoolean();\n+    private static final boolean[] mask_arr;\n+\n+    static {\n+        mask_arr = new boolean[64];\n+        for (int i = 0; i < 64; i++) {\n+            mask_arr[i] = rd.nextBoolean();\n@@ -69,1 +70,0 @@\n-        return mask;\n@@ -73,1 +73,3 @@\n-    private static void testByte64ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testByte64ToShort128() {\n@@ -75,1 +77,1 @@\n-        Assert.assertEquals(mByte64.cast(ShortVector.SPECIES_128).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(ShortVector.SPECIES_128).toString(), mByte64.toString());\n@@ -78,1 +80,3 @@\n-    private static void testByte64ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testByte64ToInt256() {\n@@ -80,1 +84,1 @@\n-        Assert.assertEquals(mByte64.cast(IntVector.SPECIES_256).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(IntVector.SPECIES_256).toString(), mByte64.toString());\n@@ -83,1 +87,3 @@\n-    private static void testByte64ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testByte64ToFloat256() {\n@@ -85,1 +91,1 @@\n-        Assert.assertEquals(mByte64.cast(FloatVector.SPECIES_256).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(FloatVector.SPECIES_256).toString(), mByte64.toString());\n@@ -88,1 +94,3 @@\n-    private static void testByte64ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testByte64ToLong512() {\n@@ -90,1 +98,1 @@\n-        Assert.assertEquals(mByte64.cast(LongVector.SPECIES_512).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(LongVector.SPECIES_512).toString(), mByte64.toString());\n@@ -93,1 +101,3 @@\n-    private static void testByte64ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testByte64ToDouble512() {\n@@ -95,1 +105,1 @@\n-        Assert.assertEquals(mByte64.cast(DoubleVector.SPECIES_512).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(DoubleVector.SPECIES_512).toString(), mByte64.toString());\n@@ -98,1 +108,3 @@\n-    private static void testByte128ToShort256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testByte128ToShort256() {\n@@ -100,1 +112,1 @@\n-        Assert.assertEquals(mByte128.cast(ShortVector.SPECIES_256).toString(), mByte128.toString());\n+        Asserts.assertEquals(mByte128.cast(ShortVector.SPECIES_256).toString(), mByte128.toString());\n@@ -103,1 +115,3 @@\n-    private static void testByte128ToInt512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testByte128ToInt512() {\n@@ -105,1 +119,1 @@\n-        Assert.assertEquals(mByte128.cast(IntVector.SPECIES_512).toString(), mByte128.toString());\n+        Asserts.assertEquals(mByte128.cast(IntVector.SPECIES_512).toString(), mByte128.toString());\n@@ -108,1 +122,3 @@\n-    private static void testByte128ToFloat512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testByte128ToFloat512() {\n@@ -110,1 +126,1 @@\n-        Assert.assertEquals(mByte128.cast(FloatVector.SPECIES_512).toString(), mByte128.toString());\n+        Asserts.assertEquals(mByte128.cast(FloatVector.SPECIES_512).toString(), mByte128.toString());\n@@ -113,1 +129,3 @@\n-    private static void testByte256ToShort512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testByte256ToShort512() {\n@@ -115,1 +133,1 @@\n-        Assert.assertEquals(mByte256.cast(ShortVector.SPECIES_512).toString(), mByte256.toString());\n+        Asserts.assertEquals(mByte256.cast(ShortVector.SPECIES_512).toString(), mByte256.toString());\n@@ -119,1 +137,3 @@\n-    private static void testShort64ToInt128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testShort64ToInt128() {\n@@ -121,1 +141,1 @@\n-        Assert.assertEquals(mShort64.cast(IntVector.SPECIES_128).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(IntVector.SPECIES_128).toString(), mShort64.toString());\n@@ -124,1 +144,3 @@\n-    private static void testShort64ToFloat128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testShort64ToFloat128() {\n@@ -126,1 +148,1 @@\n-        Assert.assertEquals(mShort64.cast(FloatVector.SPECIES_128).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(FloatVector.SPECIES_128).toString(), mShort64.toString());\n@@ -129,1 +151,3 @@\n-    private static void testShort64ToLong256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort64ToLong256() {\n@@ -131,1 +155,1 @@\n-        Assert.assertEquals(mShort64.cast(LongVector.SPECIES_256).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(LongVector.SPECIES_256).toString(), mShort64.toString());\n@@ -134,1 +158,3 @@\n-    private static void testShort64ToDouble256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort64ToDouble256() {\n@@ -136,1 +162,1 @@\n-        Assert.assertEquals(mShort64.cast(DoubleVector.SPECIES_256).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(DoubleVector.SPECIES_256).toString(), mShort64.toString());\n@@ -139,1 +165,3 @@\n-    private static void testShort128ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testShort128ToByte64() {\n@@ -141,1 +169,1 @@\n-        Assert.assertEquals(mShort128.cast(ByteVector.SPECIES_64).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(ByteVector.SPECIES_64).toString(), mShort128.toString());\n@@ -144,1 +172,3 @@\n-    private static void testShort128ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort128ToInt256() {\n@@ -146,1 +176,1 @@\n-        Assert.assertEquals(mShort128.cast(IntVector.SPECIES_256).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(IntVector.SPECIES_256).toString(), mShort128.toString());\n@@ -149,1 +179,3 @@\n-    private static void testShort128ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort128ToFloat256() {\n@@ -151,1 +183,1 @@\n-        Assert.assertEquals(mShort128.cast(FloatVector.SPECIES_256).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(FloatVector.SPECIES_256).toString(), mShort128.toString());\n@@ -154,1 +186,3 @@\n-    private static void testShort128ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testShort128ToLong512() {\n@@ -156,1 +190,1 @@\n-        Assert.assertEquals(mShort128.cast(LongVector.SPECIES_512).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(LongVector.SPECIES_512).toString(), mShort128.toString());\n@@ -159,1 +193,3 @@\n-    private static void testShort128ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testShort128ToDouble512() {\n@@ -161,1 +197,1 @@\n-        Assert.assertEquals(mShort128.cast(DoubleVector.SPECIES_512).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(DoubleVector.SPECIES_512).toString(), mShort128.toString());\n@@ -164,1 +200,3 @@\n-    private static void testShort256ToByte128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort256ToByte128() {\n@@ -166,1 +204,1 @@\n-        Assert.assertEquals(mShort256.cast(ByteVector.SPECIES_128).toString(), mShort256.toString());\n+        Asserts.assertEquals(mShort256.cast(ByteVector.SPECIES_128).toString(), mShort256.toString());\n@@ -169,1 +207,3 @@\n-    private static void testShort256ToInt512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testShort256ToInt512() {\n@@ -171,1 +211,1 @@\n-        Assert.assertEquals(mShort256.cast(IntVector.SPECIES_512).toString(), mShort256.toString());\n+        Asserts.assertEquals(mShort256.cast(IntVector.SPECIES_512).toString(), mShort256.toString());\n@@ -174,1 +214,3 @@\n-    private static void testShort256ToFloat512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testShort256ToFloat512() {\n@@ -176,1 +218,1 @@\n-        Assert.assertEquals(mShort256.cast(FloatVector.SPECIES_512).toString(), mShort256.toString());\n+        Asserts.assertEquals(mShort256.cast(FloatVector.SPECIES_512).toString(), mShort256.toString());\n@@ -179,1 +221,3 @@\n-    private static void testShort512ToByte256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testShort512ToByte256() {\n@@ -181,1 +225,1 @@\n-        Assert.assertEquals(mShort512.cast(ByteVector.SPECIES_256).toString(), mShort512.toString());\n+        Asserts.assertEquals(mShort512.cast(ByteVector.SPECIES_256).toString(), mShort512.toString());\n@@ -185,1 +229,3 @@\n-    private static void testInt64ToLong128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testInt64ToLong128() {\n@@ -187,1 +233,1 @@\n-        Assert.assertEquals(mInt64.cast(LongVector.SPECIES_128).toString(), mInt64.toString());\n+        Asserts.assertEquals(mInt64.cast(LongVector.SPECIES_128).toString(), mInt64.toString());\n@@ -190,1 +236,3 @@\n-    private static void testInt64ToDouble128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testInt64ToDouble128() {\n@@ -192,1 +240,1 @@\n-        Assert.assertEquals(mInt64.cast(DoubleVector.SPECIES_128).toString(), mInt64.toString());\n+        Asserts.assertEquals(mInt64.cast(DoubleVector.SPECIES_128).toString(), mInt64.toString());\n@@ -195,1 +243,3 @@\n-    private static void testInt128ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testInt128ToShort64() {\n@@ -197,1 +247,1 @@\n-        Assert.assertEquals(mInt128.cast(ShortVector.SPECIES_64).toString(), mInt128.toString());\n+        Asserts.assertEquals(mInt128.cast(ShortVector.SPECIES_64).toString(), mInt128.toString());\n@@ -200,1 +250,3 @@\n-    private static void testInt128ToLong256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt128ToLong256() {\n@@ -202,1 +254,1 @@\n-        Assert.assertEquals(mInt128.cast(LongVector.SPECIES_256).toString(), mInt128.toString());\n+        Asserts.assertEquals(mInt128.cast(LongVector.SPECIES_256).toString(), mInt128.toString());\n@@ -205,1 +257,3 @@\n-    private static void testInt128ToDouble256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt128ToDouble256() {\n@@ -207,1 +261,1 @@\n-        Assert.assertEquals(mInt128.cast(DoubleVector.SPECIES_256).toString(), mInt128.toString());\n+        Asserts.assertEquals(mInt128.cast(DoubleVector.SPECIES_256).toString(), mInt128.toString());\n@@ -210,1 +264,3 @@\n-    private static void testInt256ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt256ToShort128() {\n@@ -212,1 +268,1 @@\n-        Assert.assertEquals(mInt256.cast(ShortVector.SPECIES_128).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(ShortVector.SPECIES_128).toString(), mInt256.toString());\n@@ -215,1 +271,3 @@\n-    private static void testInt256ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt256ToByte64() {\n@@ -217,1 +275,1 @@\n-        Assert.assertEquals(mInt256.cast(ByteVector.SPECIES_64).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(ByteVector.SPECIES_64).toString(), mInt256.toString());\n@@ -220,1 +278,3 @@\n-    private static void testInt256ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testInt256ToLong512() {\n@@ -222,1 +282,1 @@\n-        Assert.assertEquals(mInt256.cast(LongVector.SPECIES_512).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(LongVector.SPECIES_512).toString(), mInt256.toString());\n@@ -225,1 +285,3 @@\n-    private static void testInt256ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testInt256ToDouble512() {\n@@ -227,1 +289,1 @@\n-        Assert.assertEquals(mInt256.cast(DoubleVector.SPECIES_512).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(DoubleVector.SPECIES_512).toString(), mInt256.toString());\n@@ -230,1 +292,3 @@\n-    private static void testInt512ToShort256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testInt512ToShort256() {\n@@ -232,1 +296,1 @@\n-        Assert.assertEquals(mInt512.cast(ShortVector.SPECIES_256).toString(), mInt512.toString());\n+        Asserts.assertEquals(mInt512.cast(ShortVector.SPECIES_256).toString(), mInt512.toString());\n@@ -235,1 +299,3 @@\n-    private static void testInt512ToByte128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testInt512ToByte128() {\n@@ -237,1 +303,1 @@\n-        Assert.assertEquals(mInt512.cast(ByteVector.SPECIES_128).toString(), mInt512.toString());\n+        Asserts.assertEquals(mInt512.cast(ByteVector.SPECIES_128).toString(), mInt512.toString());\n@@ -241,1 +307,3 @@\n-    private static void testFloat64ToLong128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloat64ToLong128() {\n@@ -243,1 +311,1 @@\n-        Assert.assertEquals(mFloat64.cast(LongVector.SPECIES_128).toString(), mFloat64.toString());\n+        Asserts.assertEquals(mFloat64.cast(LongVector.SPECIES_128).toString(), mFloat64.toString());\n@@ -246,1 +314,3 @@\n-    private static void testFloat64ToDouble128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloat64ToDouble128() {\n@@ -248,1 +318,1 @@\n-        Assert.assertEquals(mFloat64.cast(DoubleVector.SPECIES_128).toString(), mFloat64.toString());\n+        Asserts.assertEquals(mFloat64.cast(DoubleVector.SPECIES_128).toString(), mFloat64.toString());\n@@ -251,1 +321,3 @@\n-    private static void testFloat128ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testFloat128ToShort64() {\n@@ -253,1 +325,1 @@\n-        Assert.assertEquals(mFloat128.cast(ShortVector.SPECIES_64).toString(), mFloat128.toString());\n+        Asserts.assertEquals(mFloat128.cast(ShortVector.SPECIES_64).toString(), mFloat128.toString());\n@@ -256,1 +328,3 @@\n-    private static void testFloat128ToLong256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat128ToLong256() {\n@@ -258,1 +332,1 @@\n-        Assert.assertEquals(mFloat128.cast(LongVector.SPECIES_256).toString(), mFloat128.toString());\n+        Asserts.assertEquals(mFloat128.cast(LongVector.SPECIES_256).toString(), mFloat128.toString());\n@@ -261,1 +335,3 @@\n-    private static void testFloat128ToDouble256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat128ToDouble256() {\n@@ -263,1 +339,1 @@\n-        Assert.assertEquals(mFloat128.cast(DoubleVector.SPECIES_256).toString(), mFloat128.toString());\n+        Asserts.assertEquals(mFloat128.cast(DoubleVector.SPECIES_256).toString(), mFloat128.toString());\n@@ -266,1 +342,3 @@\n-    private static void testFloat256ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat256ToShort128() {\n@@ -268,1 +346,1 @@\n-        Assert.assertEquals(mFloat256.cast(ShortVector.SPECIES_128).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(ShortVector.SPECIES_128).toString(), mFloat256.toString());\n@@ -271,1 +349,3 @@\n-    private static void testFloat256ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat256ToByte64() {\n@@ -273,1 +353,1 @@\n-        Assert.assertEquals(mFloat256.cast(ByteVector.SPECIES_64).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(ByteVector.SPECIES_64).toString(), mFloat256.toString());\n@@ -276,1 +356,3 @@\n-    private static void testFloat256ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testFloat256ToLong512() {\n@@ -278,1 +360,1 @@\n-        Assert.assertEquals(mFloat256.cast(LongVector.SPECIES_512).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(LongVector.SPECIES_512).toString(), mFloat256.toString());\n@@ -281,1 +363,3 @@\n-    private static void testFloat256ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testFloat256ToDouble512() {\n@@ -283,1 +367,1 @@\n-        Assert.assertEquals(mFloat256.cast(DoubleVector.SPECIES_512).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(DoubleVector.SPECIES_512).toString(), mFloat256.toString());\n@@ -286,1 +370,3 @@\n-    private static void testFloat512ToShort256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testFloat512ToShort256() {\n@@ -288,1 +374,1 @@\n-        Assert.assertEquals(mFloat512.cast(ShortVector.SPECIES_256).toString(), mFloat512.toString());\n+        Asserts.assertEquals(mFloat512.cast(ShortVector.SPECIES_256).toString(), mFloat512.toString());\n@@ -291,1 +377,3 @@\n-    private static void testFloat512ToByte128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testFloat512ToByte128() {\n@@ -293,1 +381,1 @@\n-        Assert.assertEquals(mFloat512.cast(ByteVector.SPECIES_128).toString(), mFloat512.toString());\n+        Asserts.assertEquals(mFloat512.cast(ByteVector.SPECIES_128).toString(), mFloat512.toString());\n@@ -297,1 +385,3 @@\n-    private static void testLong128ToInt64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLong128ToInt64() {\n@@ -299,1 +389,1 @@\n-        Assert.assertEquals(mLong128.cast(IntVector.SPECIES_64).toString(), mLong128.toString());\n+        Asserts.assertEquals(mLong128.cast(IntVector.SPECIES_64).toString(), mLong128.toString());\n@@ -302,1 +392,3 @@\n-    private static void testLong128ToFloat64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLong128ToFloat64() {\n@@ -304,1 +396,1 @@\n-        Assert.assertEquals(mLong128.cast(FloatVector.SPECIES_64).toString(), mLong128.toString());\n+        Asserts.assertEquals(mLong128.cast(FloatVector.SPECIES_64).toString(), mLong128.toString());\n@@ -307,1 +399,3 @@\n-    private static void testLong256ToInt128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testLong256ToInt128() {\n@@ -309,1 +403,1 @@\n-        Assert.assertEquals(mLong256.cast(IntVector.SPECIES_128).toString(), mLong256.toString());\n+        Asserts.assertEquals(mLong256.cast(IntVector.SPECIES_128).toString(), mLong256.toString());\n@@ -312,1 +406,3 @@\n-    private static void testLong256ToFloat128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testLong256ToFloat128() {\n@@ -314,1 +410,1 @@\n-        Assert.assertEquals(mLong256.cast(FloatVector.SPECIES_128).toString(), mLong256.toString());\n+        Asserts.assertEquals(mLong256.cast(FloatVector.SPECIES_128).toString(), mLong256.toString());\n@@ -317,1 +413,3 @@\n-    private static void testLong256ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testLong256ToShort64() {\n@@ -319,1 +417,1 @@\n-        Assert.assertEquals(mLong256.cast(ShortVector.SPECIES_64).toString(), mLong256.toString());\n+        Asserts.assertEquals(mLong256.cast(ShortVector.SPECIES_64).toString(), mLong256.toString());\n@@ -322,1 +420,3 @@\n-    private static void testLong512ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testLong512ToInt256() {\n@@ -324,1 +424,1 @@\n-        Assert.assertEquals(mLong512.cast(IntVector.SPECIES_256).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(IntVector.SPECIES_256).toString(), mLong512.toString());\n@@ -327,1 +427,3 @@\n-    private static void testLong512ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testLong512ToFloat256() {\n@@ -329,1 +431,1 @@\n-        Assert.assertEquals(mLong512.cast(FloatVector.SPECIES_256).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(FloatVector.SPECIES_256).toString(), mLong512.toString());\n@@ -332,1 +434,3 @@\n-    private static void testLong512ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testLong512ToShort128() {\n@@ -334,1 +438,1 @@\n-        Assert.assertEquals(mLong512.cast(ShortVector.SPECIES_128).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(ShortVector.SPECIES_128).toString(), mLong512.toString());\n@@ -337,1 +441,3 @@\n-    private static void testLong512ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testLong512ToByte64() {\n@@ -339,1 +445,1 @@\n-        Assert.assertEquals(mLong512.cast(ByteVector.SPECIES_64).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(ByteVector.SPECIES_64).toString(), mLong512.toString());\n@@ -343,1 +449,3 @@\n-    private static void testDouble128ToInt64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDouble128ToInt64() {\n@@ -345,1 +453,1 @@\n-        Assert.assertEquals(mDouble128.cast(IntVector.SPECIES_64).toString(), mDouble128.toString());\n+        Asserts.assertEquals(mDouble128.cast(IntVector.SPECIES_64).toString(), mDouble128.toString());\n@@ -348,1 +456,3 @@\n-    private static void testDouble128ToFloat64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDouble128ToFloat64() {\n@@ -350,1 +460,1 @@\n-        Assert.assertEquals(mDouble128.cast(FloatVector.SPECIES_64).toString(), mDouble128.toString());\n+        Asserts.assertEquals(mDouble128.cast(FloatVector.SPECIES_64).toString(), mDouble128.toString());\n@@ -353,1 +463,3 @@\n-    private static void testDouble256ToInt128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testDouble256ToInt128() {\n@@ -355,1 +467,1 @@\n-        Assert.assertEquals(mDouble256.cast(IntVector.SPECIES_128).toString(), mDouble256.toString());\n+        Asserts.assertEquals(mDouble256.cast(IntVector.SPECIES_128).toString(), mDouble256.toString());\n@@ -358,1 +470,3 @@\n-    private static void testDouble256ToFloat128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testDouble256ToFloat128() {\n@@ -360,1 +474,1 @@\n-        Assert.assertEquals(mDouble256.cast(FloatVector.SPECIES_128).toString(), mDouble256.toString());\n+        Asserts.assertEquals(mDouble256.cast(FloatVector.SPECIES_128).toString(), mDouble256.toString());\n@@ -363,1 +477,3 @@\n-    private static void testDouble256ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testDouble256ToShort64() {\n@@ -365,2 +481,2 @@\n-        Assert.assertEquals(mDouble256.cast(ShortVector.SPECIES_64).toString(), mDouble256.toString());\n-    };\n+        Asserts.assertEquals(mDouble256.cast(ShortVector.SPECIES_64).toString(), mDouble256.toString());\n+    }\n@@ -368,1 +484,3 @@\n-    private static void testDouble512ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testDouble512ToInt256() {\n@@ -370,1 +488,1 @@\n-        Assert.assertEquals(mDouble512.cast(IntVector.SPECIES_256).toString(), mDouble512.toString());\n+        Asserts.assertEquals(mDouble512.cast(IntVector.SPECIES_256).toString(), mDouble512.toString());\n@@ -373,1 +491,3 @@\n-    private static void testDouble512ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testDouble512ToFloat256() {\n@@ -375,1 +495,1 @@\n-        Assert.assertEquals(mDouble512.cast(FloatVector.SPECIES_256).toString(), mDouble512.toString());\n+        Asserts.assertEquals(mDouble512.cast(FloatVector.SPECIES_256).toString(), mDouble512.toString());\n@@ -378,1 +498,3 @@\n-    private static void testDouble512ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testDouble512ToShort128() {\n@@ -380,1 +502,1 @@\n-        Assert.assertEquals(mDouble512.cast(ShortVector.SPECIES_128).toString(), mDouble512.toString());\n+        Asserts.assertEquals(mDouble512.cast(ShortVector.SPECIES_128).toString(), mDouble512.toString());\n@@ -383,1 +505,3 @@\n-    private static void testDouble512ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512vl\", \"true\"})\n+    public static void testDouble512ToByte64() {\n@@ -385,82 +509,8 @@\n-        Assert.assertEquals(mDouble512.cast(ByteVector.SPECIES_64).toString(), mDouble512.toString());\n-    }\n-\n-\n-    @Test\n-    public static void testMaskCast() {\n-        for (int i = 0; i < NUM_ITER; i++) {\n-            boolean[] mask = genMask();\n-            \/\/ Byte\n-            testByte64ToShort128(mask);\n-            testByte64ToInt256(mask);\n-            testByte64ToFloat256(mask);\n-            testByte64ToLong512(mask);\n-            testByte64ToDouble512(mask);\n-            testByte128ToShort256(mask);\n-            testByte128ToInt512(mask);\n-            testByte128ToFloat512(mask);\n-            testByte256ToShort512(mask);\n-\n-            \/\/ Short\n-            testShort64ToInt128(mask);\n-            testShort64ToFloat128(mask);\n-            testShort64ToLong256(mask);\n-            testShort64ToDouble256(mask);\n-            testShort128ToByte64(mask);\n-            testShort128ToInt256(mask);\n-            testShort128ToFloat256(mask);\n-            testShort128ToLong512(mask);\n-            testShort128ToDouble512(mask);\n-            testShort256ToByte128(mask);\n-            testShort256ToInt512(mask);\n-            testShort256ToFloat512(mask);\n-            testShort512ToByte256(mask);\n-\n-            \/\/ Int\n-            testInt64ToLong128(mask);\n-            testInt64ToDouble128(mask);\n-            testInt128ToShort64(mask);\n-            testInt128ToLong256(mask);\n-            testInt128ToDouble256(mask);\n-            testInt256ToShort128(mask);\n-            testInt256ToByte64(mask);\n-            testInt256ToLong512(mask);\n-            testInt256ToDouble512(mask);\n-            testInt512ToShort256(mask);\n-            testInt512ToByte128(mask);\n-\n-            \/\/ Float\n-            testFloat64ToLong128(mask);\n-            testFloat64ToDouble128(mask);\n-            testFloat128ToShort64(mask);\n-            testFloat128ToLong256(mask);\n-            testFloat128ToDouble256(mask);\n-            testFloat256ToShort128(mask);\n-            testFloat256ToByte64(mask);\n-            testFloat256ToLong512(mask);\n-            testFloat256ToDouble512(mask);\n-            testFloat512ToShort256(mask);\n-            testFloat512ToByte128(mask);\n-\n-            \/\/ Long\n-            testLong128ToInt64(mask);\n-            testLong128ToFloat64(mask);\n-            testLong256ToInt128(mask);\n-            testLong256ToFloat128(mask);\n-            testLong256ToShort64(mask);\n-            testLong512ToInt256(mask);\n-            testLong512ToFloat256(mask);\n-            testLong512ToShort128(mask);\n-            testLong512ToByte64(mask);\n-\n-            \/\/ Double\n-            testDouble128ToInt64(mask);\n-            testDouble128ToFloat64(mask);\n-            testDouble256ToInt128(mask);\n-            testDouble256ToFloat128(mask);\n-            testDouble256ToShort64(mask);\n-            testDouble512ToInt256(mask);\n-            testDouble512ToFloat256(mask);\n-            testDouble512ToShort128(mask);\n-            testDouble512ToByte64(mask);\n-        }\n+        Asserts.assertEquals(mDouble512.cast(ByteVector.SPECIES_64).toString(), mDouble512.toString());\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastTest.java","additions":272,"deletions":222,"binary":false,"changes":494,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+            makePair(FSPEC128, ISPEC128),\n+            makePair(FSPEC128, SSPEC64),\n@@ -67,0 +69,1 @@\n+            makePair(DSPEC128, ISPEC64),\n@@ -77,0 +80,5 @@\n+            makePair(DSPEC256, ISPEC128),\n+            makePair(DSPEC256, SSPEC64),\n+            makePair(FSPEC256, ISPEC256),\n+            makePair(FSPEC256, SSPEC128),\n+            makePair(FSPEC256, BSPEC64),\n@@ -92,1 +100,0 @@\n-            makePair(FSPEC256, ISPEC256),\n@@ -118,1 +125,0 @@\n-            makePair(FSPEC512, ISPEC512),\n@@ -121,0 +127,6 @@\n+            makePair(DSPEC512, ISPEC256),\n+            makePair(DSPEC512, SSPEC128),\n+            makePair(DSPEC512, BSPEC64),\n+            makePair(FSPEC512, ISPEC512),\n+            makePair(FSPEC512, SSPEC256),\n+            makePair(FSPEC512, BSPEC128),\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/TestCastMethods.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+        new LogMessageWithLevel(\"Merged Cards\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+        System.out.printf(caseDescription);\n+\n@@ -129,10 +131,0 @@\n-        } catch (Throwable e) {\n-            String result = Checker.abbreviateResult(e.getClass().getName());\n-\n-            System.out.printf(caseDescription);\n-\n-            for (String site : callSites) {\n-                System.out.printf(\" %7s\", result);\n-            }\n-\n-            System.out.println(\"\");\n@@ -140,9 +132,6 @@\n-            return true;\n-        }\n-\n-        if (executeTests) {\n-            \/\/ Check runtime behavior\n-            Caller caller = new Caller(loader, checker, paramClass, targetClass);\n-            boolean printedCaseDes = false;\n-            for (String site : callSites) {\n-                String callResult = caller.call(site);\n+            if (executeTests) {\n+                \/\/ Check runtime behavior\n+                Caller caller = new Caller(loader, checker, paramClass, targetClass);\n+                for (String site : callSites) {\n+                    String callResult = caller.call(site);\n+                    System.out.printf(\" %7s\", callResult);\n@@ -150,5 +139,4 @@\n-                if (!caller.isPassed()) {\n-                    isPassed = false;\n-                    if (!printedCaseDes) {\n-                        System.out.printf(caseDescription);\n-                        printedCaseDes = true;\n+                    if (!caller.isPassed()) {\n+                        String result = checker.check(loader.loadClass(site));\n+                        System.out.printf(\"\/%s\", Checker.abbreviateResult(result));\n+                        isPassed = false;\n@@ -156,1 +144,8 @@\n-                    System.out.printf(\" %7s\", callResult);\n+                }\n+                if (!caller.isPassed()) {\n+                    System.out.print(\" |   FAILED\");\n+                }\n+            } else {\n+                for (String site : callSites) {\n+                    String result = checker.check(loader.loadClass(site));\n+                    System.out.printf(\" %7s\", Checker.abbreviateResult(result));\n@@ -159,4 +154,3 @@\n-            if (!caller.isPassed()) {\n-                System.out.println(\" |   FAILED\");\n-            }\n-        } else {\n+        } catch (Throwable e) {\n+            String result = Checker.abbreviateResult(e.getClass().getName());\n+\n@@ -164,2 +158,1 @@\n-                String result = checker.check(loader.loadClass(site));\n-                System.out.printf(\" %7s\", Checker.abbreviateResult(result));\n+                System.out.printf(\" %7s\", result);\n@@ -168,0 +161,1 @@\n+        System.out.println();\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/shared\/AbstractGenerator.java","additions":25,"deletions":31,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        ClassWriter cw = new ClassWriter(COMPUTE_MAXS);\n+        ClassWriter cw = new ClassWriter(COMPUTE_FRAMES | COMPUTE_MAXS);\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/shared\/ExecutorGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8295278\n+ * @summary Call unlocked version loadClass directly, with another thread calling forName\n+ *          One class goes through the ClassLoader path and the other goes through JVM path\n+ * @library \/test\/lib\n+ * @compile test-classes\/A.java ..\/share\/ThreadPrint.java\n+ * @run main\/othervm CallLoadClassTest\n+ *\/\n+\n+import jdk.test.lib.classloader.ClassUnloadCommon;\n+import java.util.concurrent.Semaphore;\n+\n+public class CallLoadClassTest {\n+\n+    private static Semaphore mainSync = null;\n+\n+    private static class MyLoader extends ClassLoader {\n+\n+        ClassLoader parent;\n+        int count;\n+\n+        MyLoader(ClassLoader parent) {\n+            this.parent = parent;\n+            this.count = 0;\n+        }\n+\n+        public synchronized Class<?> loadClass(String name) throws ClassNotFoundException {\n+            Class<?> loadedClass = findLoadedClass(name);\n+            if (name.equals(\"A\") && loadedClass == null) {\n+                ThreadPrint.println(\"Loading A\");\n+                if (count == 0) {\n+                    count++;\n+                    ThreadPrint.println(\"Waiting for A\");\n+                    try {\n+                        mainSync.release(); \/\/ Let t2 start\n+                        wait();  \/\/ let the other thread load A instead.\n+                    } catch (InterruptedException ie) {\n+                    }\n+                } else {\n+                    notify(); \/\/ notify any waiting threads.\n+                }\n+                byte[] classfile = ClassUnloadCommon.getClassData(\"A\");\n+                return defineClass(name, classfile, 0, classfile.length);\n+            } else {\n+                return parent.loadClass(name);\n+            }\n+        }\n+    }\n+\n+    private static ClassLoadingThread[] threads = new ClassLoadingThread[2];\n+    private static boolean success = true;\n+\n+    private static boolean report_success() {\n+        for (int i = 0; i < 2; i++) {\n+          try {\n+            threads[i].join();\n+            if (!threads[i].report_success()) success = false;\n+          } catch (InterruptedException e) {}\n+        }\n+        return success;\n+    }\n+\n+    public static void main(java.lang.String[] unused) {\n+        mainSync = new Semaphore(0);\n+\n+        \/\/ t1 does loadClass directly, t2 does class.ForName()\n+        ClassLoader appLoader = CallLoadClassTest.class.getClassLoader();\n+        MyLoader ldr = new MyLoader(appLoader);\n+        for (int i = 0; i < 2; i++) {\n+            threads[i] = new ClassLoadingThread(ldr, i, mainSync);\n+            threads[i].setName(\"Loading Thread #\" + (i + 1));\n+            threads[i].start();\n+            System.out.println(\"Thread \" + (i + 1) + \" was started...\");\n+        }\n+        if (report_success()) {\n+           System.out.println(\"PASSED\");\n+        } else {\n+            throw new RuntimeException(\"FAILED\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/CallLoadClass\/CallLoadClassTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.concurrent.Semaphore;\n+\n+class ClassLoadingThread extends Thread {\n+\n+    private ClassLoader ldr = null;\n+    private int which;\n+    private Semaphore syncOrder;\n+\n+    public ClassLoadingThread(ClassLoader loader, int i, Semaphore sem) {\n+        ldr = loader;\n+        which = i;\n+        syncOrder = sem;\n+    }\n+\n+    private boolean success = true;\n+    public boolean report_success() { return success; }\n+\n+    public void callForName() {\n+        try {\n+            ThreadPrint.println(\"Starting forName thread ...\");\n+            \/\/ Initiate class loading using specified type\n+            Class<?> a = Class.forName(\"A\", true, ldr);\n+            Object obj = a.getConstructor().newInstance();\n+        } catch (Throwable e) {\n+            ThreadPrint.println(\"Exception is caught: \" + e);\n+            e.printStackTrace();\n+            success = false;\n+        }\n+    }\n+\n+    public void callLoadClass() {\n+        try {\n+            ThreadPrint.println(\"Starting loadClass thread ...\");\n+            Class<?> a = ldr.loadClass(\"A\");\n+            Object obj = a.getConstructor().newInstance();\n+            success = false; \/\/ Should have thrown LinkageError\n+        } catch (Throwable e) {\n+            \/\/ If you call loadClass directly, this will result in LinkageError\n+            ThreadPrint.println(\"Exception is caught: \" + e);\n+            e.printStackTrace();\n+            success = (e instanceof LinkageError);\n+        }\n+    }\n+\n+    public void run() {\n+       if (which == 0) {\n+           callLoadClass();\n+       } else {\n+           try {\n+               syncOrder.acquire();  \/\/ wait until loadClass is waiting.\n+           } catch (InterruptedException idc) {}\n+           callForName();\n+       }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/CallLoadClass\/ClassLoadingThread.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ This doesn't have to do anything\n+public class A {\n+  static { System.out.println(\"A called\"); }\n+  public A() { System.out.println(\"A.<init> called\"); }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/CallLoadClass\/test-classes\/A.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4699981 8295278\n+ * @summary This is a testcase for JDK-4699981. When 2 threads are loading the same class with\n+ *           the same classloader, and somehow one of the 2 threads releases the\n+ *           synchronization lock on the classloader, the JVM code\n+ *           throws ClassCircularityError, mistakenly.\n+ * @library \/test\/lib\n+ * @compile test-classes\/Base.java test-classes\/Derived.java test-classes\/Support.java\n+ * @run main\/othervm ParallelCircularityTest\n+ *\/\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+\n+public class ParallelCircularityTest {\n+\n+    private Object lock = new Object();\n+\n+    private void test() throws Exception {\n+       URL location = getClass().getProtectionDomain().getCodeSource().getLocation();\n+       URLLoader loader = new URLLoader(new URL[] {location}, getClass().getClassLoader().getParent());\n+\n+       Class cls = loader.loadClass(\"Support\");\n+\n+       Thread t1 = new Thread(new Run1(cls));\n+       t1.start();\n+\n+       Thread.sleep(1000);\n+\n+       \/\/ Load Derived, will trigger a loadClassInternal for Base\n+       loader.loadClass(\"Derived\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ParallelCircularityTest pct = new ParallelCircularityTest();\n+        pct.test();\n+    }\n+\n+    public class URLLoader extends URLClassLoader {\n+       private boolean m_firstTime = true;\n+\n+       public URLLoader(URL[] urls, ClassLoader parent) {\n+          super(urls, parent);\n+       }\n+\n+       public Class loadClass(String name) throws ClassNotFoundException {\n+          if (name.equals(\"Base\")) {\n+             if (m_firstTime) {\n+                m_firstTime = false;\n+\n+                \/\/ Notify the other thread\n+                synchronized (lock) {\n+                   lock.notifyAll();\n+                }\n+\n+                \/\/ Wait on the classloader to have the JVM throw ClassCircularityError\n+                try {\n+                   synchronized (this) {\n+                      wait(5000);\n+                   }\n+                }\n+                catch (InterruptedException ignored) { }\n+             }\n+          }\n+          return super.loadClass(name);\n+       }\n+    }\n+\n+    public class Run1 implements Runnable {\n+       private Class cls;\n+\n+       public Run1(Class cls) {\n+          this.cls = cls;\n+       }\n+\n+       public void run() {\n+          synchronized (lock) {\n+             try {\n+                lock.wait();\n+             }\n+             catch (InterruptedException ignored) {}\n+          }\n+\n+          \/\/ Trigger loadClassInternal for Base\n+          try {\n+             cls.newInstance();\n+          } catch (Throwable x) {\n+             x.printStackTrace();\n+          }\n+       }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelCircularity\/ParallelCircularityTest.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class Base {}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelCircularity\/test-classes\/Base.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class Derived extends Base {}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelCircularity\/test-classes\/Derived.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class Support {\n+  private Base base = new Base();\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelCircularity\/test-classes\/Support.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuper\/AsmClasses.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/AsmClasses.java","status":"renamed"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuper\/ClassLoadingThread.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ClassLoadingThread.java","status":"renamed"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuper\/MyLoader.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyLoader.java","status":"renamed"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuper\/MyNonParallelLoader.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyNonParallelLoader.java","status":"renamed"},{"patch":"@@ -32,1 +32,1 @@\n- * @compile test-classes\/ClassInLoader.java test-classes\/A.java test-classes\/B.java\n+ * @compile test-classes\/ClassInLoader.java test-classes\/A.java test-classes\/B.java ..\/share\/ThreadPrint.java\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuper\/ParallelSuperTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuperTest.java","status":"renamed"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuper\/test-classes\/A.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/test-classes\/A.java","status":"renamed"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuper\/test-classes\/B.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/test-classes\/B.java","status":"renamed"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuper\/test-classes\/ClassInLoader.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/test-classes\/ClassInLoader.java","status":"renamed"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/SaveResolutionError\/SaveResolutionErrorTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/SaveResolutionErrorTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class ClassLoadingThread extends Thread {\n+\n+    private ClassLoader ldr1;\n+    private ClassLoader ldr2;\n+    private int which;\n+\n+    public ClassLoadingThread(ClassLoader loader1, ClassLoader loader2, int i) {\n+        ldr1 = loader1;\n+        ldr2 = loader2;\n+        which = i;\n+    }\n+\n+    private boolean success = true;\n+    public boolean report_success() { return success; }\n+\n+    public void callForName(String cls, ClassLoader ldr) {\n+        try {\n+            ThreadPrint.println(\"Starting forName thread ...\");\n+            \/\/ Initiate class loading using specified type\n+            Class<?> a = Class.forName(cls, true, ldr);\n+            Object obj = a.getConstructor().newInstance();\n+        } catch (Throwable e) {\n+            ThreadPrint.println(\"Exception is caught: \" + e);\n+            e.printStackTrace();\n+            success = false;\n+        }\n+    }\n+\n+    public void run() {\n+       if (which == 0) {\n+           callForName(\"A\",ldr1);\n+       } else {\n+           callForName(\"C\", ldr2);\n+       }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/SuperWait\/ClassLoadingThread.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4670071 8295278\n+ * @summary Duplicate class loader deadlock referenced in https:\/\/openjdk.org\/groups\/core-libs\/ClassLoaderProposal.html\n+ *          One thread loads (A, CL1) extends (B, CL2), while the second loads (C, CL2) extends (D, CL1)\n+ * @library \/test\/lib\n+ * @compile test-classes\/A.java test-classes\/B.java test-classes\/C.java test-classes\/D.java ..\/share\/ThreadPrint.java\n+ * @run main\/othervm SuperWaitTest\n+ *\/\n+\n+import jdk.test.lib.classloader.ClassUnloadCommon;\n+import java.util.concurrent.Semaphore;\n+\n+public class SuperWaitTest {\n+\n+    private static Semaphore mainSync = null;\n+\n+    \/\/ Loads classes A and D, delegates for A's super class B\n+    private static class MyLoaderOne extends ClassLoader {\n+\n+        ClassLoader parent;\n+        ClassLoader baseLoader;\n+        int count;\n+\n+        MyLoaderOne(ClassLoader parent) {\n+            this.parent = parent;\n+            this.baseLoader = null;\n+            this.count = 0;\n+        }\n+\n+        public void setBaseLoader(ClassLoader ldr) {\n+            this.baseLoader = ldr;\n+        }\n+\n+        public synchronized Class<?> loadClass(String name) throws ClassNotFoundException {\n+            Class<?> loadedClass = findLoadedClass(name);\n+            if (loadedClass != null) return loadedClass;\n+            if (name.equals(\"A\") || name.equals(\"D\")) {\n+                ThreadPrint.println(\"Loading \" + name);\n+                if (name.equals(\"A\")) {\n+                    try {\n+                        ThreadPrint.println(\"Waiting for \" + name);\n+                        mainSync.acquire(); \/\/ wait until other thread gets here\n+                        wait(); \/\/ let the other thread have this lock.\n+                    } catch (InterruptedException ie) {}\n+                } else {\n+                    notify(); \/\/ reacquire lock when superclass loading is done\n+                }\n+                byte[] classfile = ClassUnloadCommon.getClassData(name);\n+                return defineClass(name, classfile, 0, classfile.length);\n+            } else if (name.equals(\"B\")) {\n+                return baseLoader.loadClass(name);\n+            } else {\n+                assert (!name.equals(\"C\"));\n+                return parent.loadClass(name);\n+            }\n+        }\n+    }\n+\n+    \/\/ Loads classes C and B, delegates for C's super class D\n+    private static class MyLoaderTwo extends ClassLoader {\n+\n+        ClassLoader parent;\n+        ClassLoader baseLoader;\n+        int count;\n+\n+        MyLoaderTwo(ClassLoader parent) {\n+            this.parent = parent;\n+            this.baseLoader = null;\n+            this.count = 0;\n+        }\n+\n+        public void setBaseLoader(ClassLoader ldr) {\n+            this.baseLoader = ldr;\n+        }\n+\n+        public synchronized Class<?> loadClass(String name) throws ClassNotFoundException {\n+            Class<?> loadedClass = findLoadedClass(name);\n+            if (loadedClass != null) return loadedClass;\n+            if (name.equals(\"C\") || name.equals(\"B\")) {\n+                ThreadPrint.println(\"Loading \" + name);\n+                if (name.equals(\"C\")) {\n+                    mainSync.release();\n+                }\n+                byte[] classfile = ClassUnloadCommon.getClassData(name);\n+                return defineClass(name, classfile, 0, classfile.length);\n+            } else if (name.equals(\"D\")) {\n+                return baseLoader.loadClass(name);\n+            } else {\n+                assert (!name.equals(\"A\"));\n+                return parent.loadClass(name);\n+            }\n+        }\n+    }\n+\n+    private static ClassLoadingThread[] threads = new ClassLoadingThread[2];\n+    private static boolean success = true;\n+\n+    private static boolean report_success() {\n+        for (int i = 0; i < 2; i++) {\n+          try {\n+            threads[i].join();\n+            if (!threads[i].report_success()) success = false;\n+          } catch (InterruptedException e) {}\n+        }\n+        return success;\n+    }\n+\n+    public static void main(java.lang.String[] unused) {\n+        \/\/ t1 loads (A,CL1) extends (B,CL2); t2 loads (C,CL2) extends (D,CL1)\n+        mainSync = new Semaphore(0);\n+\n+        ClassLoader appLoader = SuperWaitTest.class.getClassLoader();\n+        MyLoaderOne ldr1 = new MyLoaderOne(appLoader);\n+        MyLoaderTwo ldr2 = new MyLoaderTwo(appLoader);\n+        ldr1.setBaseLoader(ldr2);\n+        ldr2.setBaseLoader(ldr1);\n+\n+        for (int i = 0; i < 2; i++) {\n+            threads[i] = new ClassLoadingThread(ldr1, ldr2, i);\n+            threads[i].setName(\"Loading Thread #\" + (i + 1));\n+            threads[i].start();\n+            System.out.println(\"Thread \" + (i + 1) + \" was started...\");\n+        }\n+        if (report_success()) {\n+           System.out.println(\"PASSED\");\n+        } else {\n+            throw new RuntimeException(\"FAILED\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/SuperWait\/SuperWaitTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ A extends B in other Class loader.\n+public class A extends B {\n+  static { System.out.println(\"A called\"); }\n+  public A() { System.out.println(\"A.<init> called\"); }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/SuperWait\/test-classes\/A.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ This doesn't have to do anything\n+public class B {\n+  static { System.out.println(\"B called\"); }\n+  public B() { System.out.println(\"B.<init> called\"); }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/SuperWait\/test-classes\/B.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ C extends D in first class loader\n+public class C extends D {\n+  static { System.out.println(\"C called\"); }\n+  public C() { System.out.println(\"C.<init> called\"); }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/SuperWait\/test-classes\/C.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ This doesn't have to do anything\n+public class D {\n+  static { System.out.println(\"D called\"); }\n+  public D() { System.out.println(\"D.<init> called\"); }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/SuperWait\/test-classes\/D.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/share\/ThreadPrint.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ThreadPrint.java","status":"renamed"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-import jdk.test.lib.cds.CDSOptions;\n-\n-\/\/ This class represents options used for\n-\/\/ during creation of the archive and\/or running JVM with archive\n-\n-public class AppCDSOptions extends CDSOptions {\n-    public String appJar;\n-    public String appJarDir;\n-\n-    public AppCDSOptions setAppJar(String appJar) {\n-        this.appJar = appJar;\n-        return this;\n-    }\n-\n-    public AppCDSOptions setAppJarDir(String appJarDir) {\n-        this.appJarDir = appJarDir;\n-        return this;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/AppCDSOptions.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -66,1 +66,1 @@\n-        String logArg = \"-Xlog:cds=debug,cds+reloc=debug\";\n+        String logArg = \"-Xlog:cds=debug,cds+reloc=debug,cds+heap\";\n@@ -79,0 +79,6 @@\n+                        if (output.getOutput().contains(\"Trying to map heap\") || output.getOutput().contains(\"Loaded heap\")) {\n+                          \/\/ The native data in the RO\/RW regions have been relocated. If the CDS heap is\n+                          \/\/ mapped\/loaded, we must patch all the native pointers. (CDS heap is\n+                          \/\/ not supported on all platforms)\n+                          output.shouldContain(\"Patching native pointers in heap region\");\n+                        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ArchiveRelocationTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.io.IOException;\n@@ -172,1 +173,1 @@\n-        AppCDSOptions opts = (new AppCDSOptions()).setAppJar(appJar);\n+        CDSOptions opts = (new CDSOptions()).setAppJar(appJar);\n@@ -180,1 +181,1 @@\n-        AppCDSOptions opts = (new AppCDSOptions()).setAppJar(appJar);\n+        CDSOptions opts = (new CDSOptions()).setAppJar(appJar);\n@@ -210,1 +211,1 @@\n-    public static OutputAnalyzer createArchive(AppCDSOptions opts)\n+    public static OutputAnalyzer createArchive(CDSOptions opts)\n@@ -410,2 +411,2 @@\n-    \/\/ Execute JVM using AppCDS archive with specified AppCDSOptions\n-    public static OutputAnalyzer runWithArchive(AppCDSOptions opts)\n+    \/\/ Execute JVM using AppCDS archive with specified CDSOptions\n+    public static OutputAnalyzer runWithArchive(CDSOptions opts)\n@@ -454,1 +455,1 @@\n-        AppCDSOptions opts = (new AppCDSOptions());\n+        CDSOptions opts = (new CDSOptions());\n@@ -462,1 +463,1 @@\n-        AppCDSOptions opts = (new AppCDSOptions());\n+        CDSOptions opts = (new CDSOptions());\n@@ -468,1 +469,1 @@\n-        AppCDSOptions opts = (new AppCDSOptions());\n+        CDSOptions opts = (new CDSOptions());\n@@ -474,1 +475,1 @@\n-        AppCDSOptions opts = (new AppCDSOptions());\n+        CDSOptions opts = (new CDSOptions());\n@@ -481,1 +482,1 @@\n-        AppCDSOptions opts = (new AppCDSOptions()).setAppJar(appJar);\n+        CDSOptions opts = (new CDSOptions()).setAppJar(appJar);\n@@ -488,1 +489,1 @@\n-        AppCDSOptions opts = makeModuleOptions(prefix, upgrademodulepath, modulepath,\n+        CDSOptions opts = makeModuleOptions(prefix, upgrademodulepath, modulepath,\n@@ -494,1 +495,1 @@\n-        AppCDSOptions opts = (new AppCDSOptions());\n+        CDSOptions opts = (new CDSOptions());\n@@ -500,1 +501,1 @@\n-        AppCDSOptions opts = (new AppCDSOptions());\n+        CDSOptions opts = (new CDSOptions());\n@@ -506,1 +507,1 @@\n-    private static AppCDSOptions makeModuleOptions(String prefix[], String upgrademodulepath, String modulepath,\n+    private static CDSOptions makeModuleOptions(String prefix[], String upgrademodulepath, String modulepath,\n@@ -508,1 +509,1 @@\n-        AppCDSOptions opts = (new AppCDSOptions());\n+        CDSOptions opts = (new CDSOptions());\n@@ -524,1 +525,1 @@\n-        AppCDSOptions opts = makeModuleOptions(prefix, upgrademodulepath, modulepath,\n+        CDSOptions opts = makeModuleOptions(prefix, upgrademodulepath, modulepath,\n@@ -748,0 +749,33 @@\n+\n+    public static void filesMustMatch(Path a, Path b) throws IOException {\n+        linesMustMatch(Files.readString(a).split(\"\\n\"),\n+                       Files.readString(b).split(\"\\n\"));\n+    }\n+\n+    public static void linesMustMatch(String a[], String b[]) {\n+        int limit = Math.min(a.length, b.length);\n+\n+        \/\/ Check the lines that are in both a[] and b[]\n+        for (int i = 0; i < limit; i++) {\n+            if (!a[i].equals(b[i])) {\n+                System.out.println(\"a:\" + i + \" \" + a[i]);\n+                System.out.println(\"b:\" + i + \" \" + b[i]);\n+                throw new RuntimeException(\"Output mismatch on line \" + i\n+                                           + \": a=\" + a[i]\n+                                           + \", b=\" + b[i]);\n+            }\n+        }\n+\n+        \/\/ Report the first line that is in one array but not in the other\n+        if (a.length > b.length) {\n+            throw new RuntimeException(\"Output mismatch on line \" + limit\n+                                       + \": a=\" + a[limit]\n+                                       + \", b=<none>\");\n+\n+        }\n+        if (a.length < b.length) {\n+            throw new RuntimeException(\"Output mismatch on line \" + limit\n+                                       + \": a=<none>\"\n+                                       + \", b=\" + b[limit]);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":50,"deletions":16,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -94,0 +94,17 @@\n+        System.out.println(\"2. Exec with \" + execGC + \" and test ArchiveRelocationMode\");\n+        out = TestCommon.exec(helloJar,\n+                              execGC,\n+                              small1,\n+                              small2,\n+                              \"-Xlog:cds,cds+heap\",\n+                              \"-XX:ArchiveRelocationMode=1\", \/\/ always relocate shared metadata\n+                              \"Hello\");\n+        out.shouldContain(HELLO);\n+        if (out.getOutput().contains(\"Trying to map heap\") || out.getOutput().contains(\"Loaded heap\")) {\n+            \/\/ The native data in the RO\/RW regions have been relocated. If the CDS heap is\n+            \/\/ mapped\/loaded, we must patch all the native pointers. (CDS heap is\n+            \/\/ not supported on all platforms)\n+            out.shouldContain(\"Patching native pointers in heap region\");\n+        }\n+        out.shouldHaveExitValue(0);\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestSerialGCWithCDS.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        runTest(AppendClasspath::testDefaultBase);\n+        runTest(RelativePath::testDefaultBase);\n@@ -57,0 +57,10 @@\n+\n+        \/\/ Create CDS Archive\n+        dump(topArchiveName, \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=debug\",\n+            \"-cp\", appJar + File.pathSeparator + appJar2,\n+            \"HelloMore\")\n+            .assertNormalExit(output-> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+            });\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/RelativePath.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8295102\n+ * @summary Always load the lambda-form-invoker lines from default classlist\n+ * @requires vm.cds\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build DefaultClassListLFInvokers\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *             DefaultClassListLFInvokersApp DefaultClassListLFInvokersApp$CompMethods\n+ * @run driver DefaultClassListLFInvokers\n+ *\/\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class DefaultClassListLFInvokers {\n+    static final String appClass = DefaultClassListLFInvokersApp.class.getName();\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+\n+    static final String[] classlist = {\n+        appClass,\n+        \/\/ If we have at least one line of @lambda-form-invoker in the classlist, it triggers\n+        \/\/ the regeneration of the 4 XXX$Holder during -Xshare:dump.\n+        \"@lambda-form-invoker [LF_RESOLVE] java.lang.invoke.DirectMethodHandle$Holder invokeStatic L_V\"\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        File classListFile = CDSTestUtils.makeClassList(classlist);\n+        CDSTestUtils.createArchiveAndCheck(\"-XX:SharedClassListFile=\" + classListFile.getPath(),\n+                                           \"-cp\", appJar);\n+\n+        \/\/ Make sure we still have all the LF invoker methods as when CDS is disabled,\n+        \/\/ in which case the XXX$Holder classes are loaded from $JAVA_HOME\/lib\/modules\n+        Path no_cds_logfile = run(Mode.no_cds);\n+        Path custom_cds_logfile = run(Mode.custom_cds);\n+        System.out.println(\"\\n\\n============================== Checking output: custom_cds vs no_cds\");\n+        TestCommon.filesMustMatch(custom_cds_logfile, no_cds_logfile);\n+\n+        \/\/ We should also have all the LF invoker methods as when the default CDS archive is used\n+        \/\/ in which case the XXX$Holder classes are loaded from the default archive,\n+        \/\/ e.g., $JAVA_HOME\/lib\/server\/classes.jsa\n+        Path default_cds_logfile = run(Mode.default_cds);\n+        System.out.println(\"\\n\\n============================== Checking output: custom_cds vs default_cds\");\n+        TestCommon.filesMustMatch(custom_cds_logfile, default_cds_logfile);\n+    }\n+\n+    enum Mode {\n+        no_cds,\n+        default_cds,\n+        custom_cds\n+    };\n+\n+    static Path run(Mode mode) throws Exception {\n+        File f = new File(\"log_\" + mode.name() + \".txt\");\n+        CDSOptions opts = (new CDSOptions())\n+            .addSuffix(\"-showversion\", \"-cp\", appJar, appClass, f.toString())\n+            .setUseVersion(false);\n+\n+        switch (mode) {\n+        case no_cds:\n+            opts.setXShareMode(\"off\");\n+            break;\n+        case custom_cds:\n+            \/\/ We will use the archive created by the last CDSTestUtils.createArchiveAndCheck() call\n+            opts.setUseSystemArchive(false);\n+            opts.setXShareMode(\"auto\");\n+            break;\n+        case default_cds:\n+        default:\n+            \/\/ We will use the default archive.\n+            opts.setUseSystemArchive(true);\n+            opts.setXShareMode(\"auto\");\n+            break;\n+        }\n+        CDSTestUtils.run(opts).assertNormalExit(DefaultClassListLFInvokersApp.FLAG);\n+        return f.toPath();\n+    }\n+}\n+\n+class DefaultClassListLFInvokersApp {\n+    public static final String FLAG = \"Test Success!\";\n+    static class CompMethods implements Comparator<Method> {\n+        public int compare(Method a, Method b) {\n+            return a.toString().compareTo(b.toString());\n+        }\n+    }\n+    static final CompMethods compMethods = new CompMethods();\n+\n+    public static void main(String[] args) throws Exception {\n+        try (BufferedWriter w = new BufferedWriter(new FileWriter(args[0]))) {\n+            test(w, \"java.lang.invoke.Invokers$Holder\");\n+            test(w, \"java.lang.invoke.DirectMethodHandle$Holder\");\n+            test(w, \"java.lang.invoke.DelegatingMethodHandle$Holder\");\n+            test(w, \"java.lang.invoke.LambdaForm$Holder\");\n+            System.out.println(FLAG);\n+        }\n+    }\n+\n+    static void test(BufferedWriter w, String className) throws Exception {\n+        Class c = Class.forName(className);\n+        Method[] methods = c.getDeclaredMethods();\n+        w.write(\"Dumping all methods in \" + c + \"\\n\");\n+        Arrays.sort(methods, 0, methods.length, compMethods);\n+        for (Method m : methods) {\n+            w.write(m + \"\\n\");\n+        }\n+        w.write(\"Found \" + methods.length + \" methods\\n\\n\\n\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/lambdaForm\/DefaultClassListLFInvokers.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8294759\n+ * @summary Verify mutex rank logging works\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver MutexRankTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Platform;\n+\n+public class MutexRankTest {\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:vmmutex\",\n+                                                                  \"-version\");\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        oa.shouldContain(\"VM Mutex\/Monitor ranks:\");\n+        if (Platform.isDebugBuild()) {\n+            oa.shouldContain(\"Rank \\\"safepoint\\\"\");\n+            oa.shouldContain(\"Heap_lock\");\n+        } else {\n+            oa.shouldContain(\"Only known in debug builds\");\n+        }\n+        oa.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/MutexRankTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8249293\n- *\n- * @summary Test if stack walk to get local variable in the JVMTI implementation is safe if the\n- *          target thread is not suspended.\n- *\n- * @comment The main\/target thread uses recursion to build a large stack, then\n- *          calls a native method to notify the JVMTI agent thread to get a\n- *          local variable deep in the stack. This prolongs the stack walk. The\n- *          target thread's stack is walkable while in native. After sending the\n- *          notification it waits a while to give the agent time to reach the\n- *          stack walk, then it returns from native. This is when its stack\n- *          becomes not walkable again.\n- *\n- * @library \/test\/lib\n- * @compile GetLocalWithoutSuspendTest.java\n- * @run main\/othervm\/native\n- *                  -agentlib:GetLocalWithoutSuspendTest\n- *                  -Xbatch\n- *                  GetLocalWithoutSuspendTest\n- *\/\n-\n-public class GetLocalWithoutSuspendTest {\n-\n-    public static final int M = 1 << 20;\n-\n-    public static final int TEST_ITERATIONS = 200;\n-\n-    \/**\n-     * Native method to notify the agent thread to call GetLocalObject() on this thread.\n-     *\n-     * @param depth Depth of target frame for GetLocalObject() call. Should be\n-     *        large value to prolong the unsafe stack walk.\n-     * @param waitTime Time to wait after notify with\n-     *        walkable stack before returning an becoming unsafe again.\n-     * @return Dummy value.\n-     *\/\n-    public static native void notifyAgentToGetLocal(int depth, int waitTime);\n-\n-    \/**\n-     * Notify agent thread that we are shutting down and wait for it to terminate.\n-     *\/\n-    public static native void shutDown();\n-\n-    \/**\n-     * Provide agent thread with reference to target thread.\n-     * @param target The target thread\n-     *\/\n-    public static native void setTargetThread(Thread target);\n-\n-    public static void main(String[] args) throws Exception {\n-        new GetLocalWithoutSuspendTest().runTest();\n-    }\n-\n-    \/**\n-     * Wait cycles in native, i.e. with walkable stack, after notifying agent\n-     * thread to do GetLocalObject() call.\n-     *\/\n-    public int waitCycles = 1;\n-\n-    public void runTest() throws Exception {\n-        log(\"Set target thread for get local variable calls by agent.\");\n-        setTargetThread(Thread.currentThread());\n-\n-        log(\"Test how many frames fit on the stack by performing recursive calls until\");\n-        log(\"StackOverflowError is thrown\");\n-        int targetDepth = recursiveMethod(0, M);\n-        log(\"Testing with target depth: \" + targetDepth);\n-\n-        log(\"Begin Test.\");\n-        long start = System.currentTimeMillis();\n-        for (int iterations = 0; iterations < TEST_ITERATIONS; iterations++) {\n-            long now = System.currentTimeMillis();\n-            log((now - start) + \" ms  Iteration : \" + iterations +\n-                \"  waitTime : \" + waitCycles);\n-            int newTargetDepth = recursiveMethod(0, targetDepth);\n-            if (newTargetDepth < targetDepth) {\n-                \/\/ A StackOverflowError can occur due to (re-)compilation. We\n-                \/\/ don't reach the native method notifyAgentToGetLocal() then\n-                \/\/ which is a prerequisite to trigger the problematic race\n-                \/\/ condition. So we reduce the targetDepth to avoid stack\n-                \/\/ overflow.\n-                log(\"StackOverflowError during test.\");\n-                log(\"Old target depth: \" + targetDepth);\n-                log(\"Retry with new target depth: \" + newTargetDepth);\n-                targetDepth = newTargetDepth;\n-            }\n-            iterations++;\n-            \/\/ Double wait time, but limit to roughly 10^6 cycles.\n-            waitCycles = (waitCycles << 1) & (M - 1);\n-            waitCycles = waitCycles == 0 ? 1 : waitCycles;\n-        }\n-\n-        \/\/ Notify agent thread that we are shutting down and wait for it to terminate.\n-        shutDown();\n-\n-        log(\"Successfully finished test\");\n-    }\n-\n-    \/**\n-     * Perform recursive calls until the target stack depth is reached or the stack overflows.\n-     * Call {@link #notifyAgentToGetLocal(int, int)} if the target depth is reached.\n-     *\n-     * @param depth Current recursion depth\n-     * @param targetStackDepth Target recursion depth\n-     * @return Depth at which the recursion was ended\n-     *\/\n-    public int recursiveMethod(int depth, int targetStackDepth) {\n-        int maxDepth = depth;\n-        try {\n-            if (depth == targetStackDepth) {\n-                notifyAgentToGetLocal(depth - 100, waitCycles);\n-            } else {\n-                maxDepth = recursiveMethod(depth + 1, targetStackDepth);\n-            }\n-        } catch (StackOverflowError e) {\n-            \/\/ Don't print message here, because this would likely trigger a new StackOverflowError\n-        }\n-        return maxDepth;\n-    }\n-\n-    public static void log(String m) {\n-        System.out.println(\"### Java-Test: \" + m);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetLocalVariable\/GetLocalWithoutSuspendTest.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Verifies JVMTI GetLocalXXX\/SetLocalXXX return errors for unsuspended vthreads\n+ * @requires vm.continuations\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:GetSetLocalUnsuspended GetSetLocalUnsuspended\n+ *\/\n+\n+\n+public class GetSetLocalUnsuspended {\n+    private static final String agentLib = \"GetSetLocalUnsuspended\";\n+\n+    private static native void testUnsuspendedThread(Thread thread);\n+\n+    private static volatile boolean doStop;\n+\n+    private static void sleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"Interruption in Thread.sleep: \\n\\t\" + e);\n+        }\n+    }\n+\n+    static final Runnable SLEEPING_THREAD = () -> {\n+        while (!doStop) {\n+            sleep(1);\n+        }\n+    };\n+\n+    private static void testPlatformThread() throws Exception {\n+        doStop = false;\n+        Thread thread = Thread.ofPlatform().name(\"SleepingPlatformThread\").start(SLEEPING_THREAD);\n+        testUnsuspendedThread(thread);\n+        doStop = true;\n+        thread.join();\n+    }\n+\n+    private static void testVirtualThread() throws Exception {\n+        doStop = false;\n+        Thread thread = Thread.ofVirtual().name(\"SleepingVirtualThread\").start(SLEEPING_THREAD);\n+        testUnsuspendedThread(thread);\n+        doStop = true;\n+        thread.join();\n+    }\n+\n+    private void runTest() throws Exception {\n+        testPlatformThread();\n+        testVirtualThread();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            System.loadLibrary(agentLib);\n+        } catch (UnsatisfiedLinkError ex) {\n+            System.err.println(\"Failed to load \" + agentLib + \" lib\");\n+            System.err.println(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n+            throw ex;\n+        }\n+\n+        GetSetLocalUnsuspended obj = new GetSetLocalUnsuspended();\n+        obj.runTest();\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetLocalVariable\/GetSetLocalUnsuspended.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -1,449 +0,0 @@\n-\/*\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"jni.h\"\n-\n-\n-\/\/\n-\/\/ Please also read the @comment in GetLocalWithoutSuspendTest.java\n-\/\/\n-\n-extern \"C\" {\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BEGIN: Shared Variables\n-\/\/ The following variables are shared between agent and target thread\n-\n-\/\/ glws_monitor is used to synchronize access to shared variables.\n-static jrawMonitorID glws_monitor;\n-\n-\/\/ Target thread for agent operations.\n-static jthread target_thread = NULL;\n-\n-\/\/ Depth of the frame for GetLocalObject() call by the agent thread. It is set by the target thread.\n-\/\/ -1 is the signal to shut down.\n-static int depth_for_get_local = 0;\n-\n-enum TestState {\n-  Initial,\n-\n-  TargetInNative,            \/\/ The agent waits for the target thread to reach\n-                             \/\/ the native method notifyAgentToGetLocal. Then it\n-                             \/\/ reads depth_for_get_local and changes the state\n-                             \/\/ to AgentInGetLocal. After that it\n-                             \/\/ calls GetLocalObject().\n-\n-  AgentInGetLocal,           \/\/ The target thread waits for the agent to call\n-                             \/\/ GetLocalObject(). When this state is reached it\n-                             \/\/ resets the state to Initial and returns from\n-                             \/\/ native after a short spin wait racing the agent\n-                             \/\/ thread doing the unsafe stack walk.\n-\n-  ShutDown,\n-\n-  Terminated\n-};\n-\n-\/\/ Current test state. It is used to synchronize agent and target thread execution.\n-static TestState test_state;\n-\n-\/\/ END: Shared Variables\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\n-\/\/ Dummy counter used in spin wait. It is declared volatile to prevent the compiler\n-\/\/ from eliminating the whole spin loop.\n-static volatile int dummy_counter   = 0;\n-\n-\/\/ Makes a string of the argument (which is not macro-expanded)\n-#define STR(a)  #a\n-\n-\/\/ Makes a string of the macro expansion of a\n-#define XSTR(a) STR(a)\n-\n-#define AT_LINE \" ERROR at line \" XSTR(__LINE__)\n-\n-static jvmtiEnv* jvmti = NULL;\n-\n-static jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved);\n-\n-static char* GetErrorMessage(jvmtiEnv *jvmti, jvmtiError errCode) {\n-  char *errMsg;\n-  jvmtiError result = jvmti->GetErrorName(errCode, &errMsg);\n-  return result == JVMTI_ERROR_NONE ? errMsg : NULL;\n-}\n-\n-static void ShowErrorMessage(jvmtiEnv *jvmti, jvmtiError errCode, const char *message) {\n-  char* errMsg = GetErrorMessage(jvmti, errCode);\n-\n-  if (errMsg != NULL) {\n-    fprintf(stderr, \"AGENT: %s: %s (%d)\\n\", message, errMsg, errCode);\n-    jvmti->Deallocate((unsigned char *)errMsg);\n-  } else {\n-    fprintf(stderr, \"AGENT: %s (%d)\\n\", message, errCode);\n-  }\n-}\n-\n-static void monitor_enter(jvmtiEnv* jvmti, JNIEnv* env, const char* loc) {\n-  jvmtiError err = jvmti->RawMonitorEnter(glws_monitor);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, loc);\n-    env->FatalError(loc);\n-  }\n-}\n-\n-static void monitor_exit(jvmtiEnv* jvmti, JNIEnv* env, const char* loc) {\n-  jvmtiError err = jvmti->RawMonitorExit(glws_monitor);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, loc);\n-    env->FatalError(loc);\n-  }\n-}\n-\n-static void monitor_wait(jvmtiEnv* jvmti, JNIEnv* env, const char* loc) {\n-  jvmtiError err = jvmti->RawMonitorWait(glws_monitor, 0);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, loc);\n-    env->FatalError(loc);\n-  }\n-}\n-\n-static void monitor_notify(jvmtiEnv* jvmti, JNIEnv* env, const char* loc) {\n-  jvmtiError err = jvmti->RawMonitorNotify(glws_monitor);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, loc);\n-    env->FatalError(loc);\n-  }\n-}\n-\n-static void monitor_destroy(jvmtiEnv* jvmti, JNIEnv* env, const char* loc) {\n-  jvmtiError err = jvmti->DestroyRawMonitor(glws_monitor);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, loc);\n-    env->FatalError(loc);\n-  }\n-}\n-\n-\/\/ Perform GetLocalObject() at the requested depth while target thread is running.\n-\/\/ Note that the JVMTI spec does not require to suspend the target thread.\n-void test_GetLocalObject(jvmtiEnv* jvmti, JNIEnv* env, int depth) {\n-  jvmtiError err;\n-  jobject obj;\n-  char* errMsg;\n-\n-  printf(\"AGENT: calling GetLocalObject() with depth %d\\n\", depth);\n-  err = jvmti->GetLocalObject(target_thread, depth, 0, &obj);\n-  errMsg = GetErrorMessage(jvmti, err);\n-  printf(\"AGENT: GetLocalObject() result code %s (%d)\\n\", errMsg != NULL ? errMsg : \"N\/A\", err);\n-  if (errMsg != NULL) {\n-    jvmti->Deallocate((unsigned char *)errMsg);\n-  }\n-  fflush(stdout);\n-\n-  \/\/ If the target thread wins the race we can get errors because we\n-  \/\/ don't find a frame at the given depth or we find a non-java frame\n-  \/\/ there (e.g. native frame). This is expected.\n-  \/\/ JVMTI_ERROR_INVALID_SLOT can occur also because the target thread is\n-  \/\/ running and the GetLocalObject() call might coincidentally refer to the\n-  \/\/ frame of a static method without parameters.\n-  if (err != JVMTI_ERROR_NONE &&\n-      err != JVMTI_ERROR_NO_MORE_FRAMES &&\n-      err != JVMTI_ERROR_OPAQUE_FRAME &&\n-      err != JVMTI_ERROR_INVALID_SLOT) {\n-    ShowErrorMessage(jvmti, err, \"AgentThreadLoop: error in JVMTI GetLocalObject\");\n-    env->FatalError(\"AgentThreadLoop: error in JVMTI GetLocalObject\\n\");\n-  }\n-}\n-\n-\/\/ Function holding the main loop for the test agent thread.\n-\/\/\n-\/\/ The agent does the following in each loop iteration:\n-\/\/\n-\/\/ - Wait for the target thread either to start a new test iteration or to\n-\/\/   signal shutdown.\n-\/\/\n-\/\/     Shutdown is signalled by setting test_state to ShutDown. The agent reacts\n-\/\/     to it by changing test_state to Terminated and then exits.\n-\/\/\n-\/\/     In the case of a new test iteration the target thread builds a deep call\n-\/\/     stack and then calls the native method notifyAgentToGetLocal(). While in\n-\/\/     native code its stack is walkable. It sets the shared variable test_state\n-\/\/     to TargetInNative and then uses the glws_monitor to send the\n-\/\/     notification to the agent thread.\n-\/\/\n-\/\/ - Read the shared variable depth_for_get_local which was set by the target\n-\/\/   thread before sending the notification.\n-\/\/\n-\/\/ - Set test_state to AgentInGetLocal and notify the target thread.\n-\/\/\n-\/\/ - Perform the JVMTI GetLocal call at depth_for_get_local racing the target\n-\/\/   thread returning from the native call making its stack not walkable. The VM\n-\/\/   will crash if this happens while the stack is walked to find the frame for\n-\/\/   the GetLocal operation. The deeper the frame the more likely the crash\n-\/\/   because the stack walk takes longer.\n-\/\/\n-JNIEXPORT void JNICALL\n-AgentThreadLoop(jvmtiEnv * jvmti, JNIEnv* env, void * arg) {\n-  jvmtiError err;\n-  jvmtiThreadInfo thread_info;\n-\n-  \/\/ Wait until target_thread is set by target thread.\n-  monitor_enter(jvmti, env, AT_LINE);\n-  while (target_thread == NULL) {\n-    monitor_wait(jvmti, env, AT_LINE);\n-  }\n-  monitor_exit(jvmti, env, AT_LINE);\n-\n-  err = jvmti->GetThreadInfo(target_thread, &thread_info);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"AgentThreadLoop: error in JVMTI GetThreadInfo\");\n-    env->FatalError(\"AgentThreadLoop: error in JVMTI GetThreadInfo\\n\");\n-  }\n-\n-  printf(\"AGENT: AgentThreadLoop thread started. Polling thread '%s' for local variables\\n\",\n-         thread_info.name);\n-  jvmti->Deallocate((unsigned char *) thread_info.name);\n-\n-  do {\n-    int depth;\n-\n-    monitor_enter(jvmti, env, AT_LINE);\n-\n-    \/\/ Wait for java part to build large stack and then become stack walk\n-    \/\/ save by calling the native method notifyAgentToGetLocal or to signal\n-    \/\/ shutdown.\n-    while (test_state != TargetInNative) {\n-      if (test_state == ShutDown) {\n-        test_state = Terminated;\n-        monitor_notify(jvmti, env, AT_LINE);\n-        monitor_exit(jvmti, env, AT_LINE);\n-        return;\n-      }\n-      monitor_wait(jvmti, env, AT_LINE);\n-    }\n-    depth = depth_for_get_local;\n-\n-    \/\/ Notify target thread that this thread is about to query the local value.\n-    test_state = AgentInGetLocal;\n-    monitor_notify(jvmti, env, AT_LINE);\n-\n-    monitor_exit(jvmti, env, AT_LINE);\n-\n-    \/\/ Now get the local object from the target thread's stack.\n-    test_GetLocalObject(jvmti, env, depth);\n-  } while (true);\n-\n-  printf(\"AGENT: AgentThreadLoop thread: exiting\\n\");\n-}\n-\n-\/\/ Called by target thread after building a large stack.\n-\/\/ By calling this native method, the thread's stack becomes walkable.\n-\/\/ It notifies the agent to do the GetLocalObject() call and then races\n-\/\/ it to make its stack not walkable by returning from the native call.\n-JNIEXPORT void JNICALL\n-Java_GetLocalWithoutSuspendTest_notifyAgentToGetLocal(JNIEnv *env, jclass cls, jint depth, jint waitCycles) {\n-  monitor_enter(jvmti, env, AT_LINE);\n-\n-  \/\/ Set depth_for_get_local and notify agent that the target thread is ready for the GetLocalObject() call\n-  depth_for_get_local = depth;\n-  test_state = TargetInNative;\n-\n-  monitor_notify(jvmti, env, AT_LINE);\n-\n-  \/\/ Wait for agent thread to read depth_for_get_local and do the GetLocalObject() call\n-  while (test_state != AgentInGetLocal) {\n-    monitor_wait(jvmti, env, AT_LINE);\n-  }\n-\n-  \/\/ Reset state to Initial\n-  test_state = Initial;\n-\n-  monitor_exit(jvmti, env, AT_LINE);\n-\n-  \/\/ Wait a little until agent thread is in unsafe stack walk.\n-  \/\/ This needs to be a spin wait or sleep because we cannot get a notification\n-  \/\/ from there.\n-  while (--waitCycles > 0) {\n-    dummy_counter++;\n-  }\n-}\n-\n-\/\/ Called by target thread to signal shutdown. The target thread waits for the\n-\/\/ agent's acknowledge by changing test_state to Terminated.\n-JNIEXPORT void JNICALL\n-Java_GetLocalWithoutSuspendTest_shutDown(JNIEnv *env, jclass cls) {\n-  monitor_enter(jvmti, env, AT_LINE);\n-\n-  \/\/ Notify agent thread to shut down\n-  test_state = ShutDown;\n-  monitor_notify(jvmti, env, AT_LINE);\n-\n-  \/\/ Wait for agent to terminate\n-  while (test_state != Terminated) {\n-    monitor_wait(jvmti, env, AT_LINE);\n-  }\n-\n-  monitor_exit(jvmti, env, AT_LINE);\n-\n-  \/\/ Destroy glws_monitor\n-  monitor_destroy(jvmti, env, AT_LINE);\n-}\n-\n-\/\/ Called by target thread to provide agent with its thread object\n-JNIEXPORT void JNICALL\n-Java_GetLocalWithoutSuspendTest_setTargetThread(JNIEnv *env, jclass cls, jthread target) {\n-  monitor_enter(jvmti, env, AT_LINE);\n-\n-  target_thread = env->NewGlobalRef(target);\n-\n-  monitor_notify(jvmti, env, AT_LINE);\n-\n-  monitor_exit(jvmti, env, AT_LINE);\n-}\n-\n-void JNICALL VMInit(jvmtiEnv *jvmti, JNIEnv *env, jthread thr) {\n-  jvmtiError err;\n-  jobject agent_thread_name;\n-  jclass thread_clas;\n-  jmethodID thread_ctor;\n-  jthread agent_thread;\n-\n-  printf(\"AGENT: VM init event\\n\");\n-  printf(\"AGENT: Start new thread that performs GetLocalObject calls on a running target thread\\n\");\n-\n-  agent_thread_name = env->NewStringUTF(\"GetLocalWithoutSuspendTest Agent Thread\");\n-  if (agent_thread_name == NULL) {\n-    env->FatalError(\"VMInit: NewStringUTF failed\\n\");\n-  }\n-\n-  thread_clas = env->FindClass(\"java\/lang\/Thread\");\n-  if (thread_clas == NULL) {\n-    env->FatalError(\"VMInit: java.lang.Thread class not found\\n\");\n-  }\n-\n-  thread_ctor = env->GetMethodID(thread_clas, \"<init>\", \"(Ljava\/lang\/String;)V\");\n-  if (thread_ctor == NULL) {\n-    env->FatalError(\"VMInit: failed to get ID for the Thread ctor\\n\");\n-  }\n-\n-  agent_thread = (jthread) env->NewObject(thread_clas, thread_ctor, agent_thread_name);\n-  if (agent_thread == NULL) {\n-    env->FatalError(\"VMInit: Failed to allocate thread object\\n\");\n-  }\n-\n-  err = jvmti->RunAgentThread(agent_thread, &AgentThreadLoop, NULL,\n-                              JVMTI_THREAD_NORM_PRIORITY);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"VMInit: failed to start GetLocalWithoutSuspendTest thread\");\n-    return;\n-  }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  printf(\"AGENT: Agent_OnLoad started.\\n\");\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n-  printf(\"AGENT: Agent_OnAttach started.\");\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT jint JNICALL\n-JNI_OnLoad(JavaVM *jvm, void *reserved) {\n-  jint res;\n-  JNIEnv *env;\n-\n-  printf(\"AGENT: JNI_OnLoad started.\");\n-  res = jvm->GetEnv((void **) &env, JNI_VERSION_9);\n-  if (res != JNI_OK || env == NULL) {\n-    fprintf(stderr, \"Error: GetEnv call failed(%d)!\\n\", res);\n-    return JNI_ERR;\n-  }\n-\n-  return JNI_VERSION_9;\n-}\n-\n-static\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-  jint res;\n-  jvmtiError err;\n-  jvmtiCapabilities caps;\n-  jvmtiEventCallbacks callbacks;\n-\n-  printf(\"AGENT: Agent_Initialize started\\n\");\n-\n-  memset(&caps, 0, sizeof(caps));\n-  memset(&callbacks, 0, sizeof(callbacks));\n-\n-  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n-  if (res != JNI_OK || jvmti == NULL) {\n-    fprintf(stderr, \"Error: GetEnv(JVMTI_VERSION_9) call failed(%d)!\\n\", res);\n-    return JNI_ERR;\n-  }\n-\n-  caps.can_access_local_variables = 1;\n-\n-  err = jvmti->AddCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"Agent_OnLoad: error in JVMTI AddCapabilities\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"Agent_OnLoad: error in JVMTI GetCapabilities\");\n-    return JNI_ERR;\n-  }\n-\n-  if (!caps.can_access_local_variables) {\n-    fprintf(stderr, \"Warning: Access to local variables is not implemented\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  callbacks.VMInit = &VMInit;\n-  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"Agent_OnLoad: error in JVMTI SetEventCallbacks\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n-  if (err != JVMTI_ERROR_NONE) {\n-    ShowErrorMessage(jvmti, err, \"Agent_OnLoad: error in JVMTI SetEventNotificationMode\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->CreateRawMonitor(\"GetLocalWithoutSuspend Test Monitor\", &glws_monitor);\n-\n-  printf(\"AGENT: Agent_Initialize finished\\n\");\n-  return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetLocalVariable\/libGetLocalWithoutSuspendTest.cpp","additions":0,"deletions":449,"binary":false,"changes":449,"status":"deleted"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+#define MAX_FRAME_COUNT 30\n+\n+enum Slots {\n+  SlotInvalid0 = -1,\n+  SlotString = 0,\n+  SlotThread = 1,\n+  SlotInt = 2,\n+  SlotLong = 3,\n+  SlotUnaligned = 4,\n+  SlotFloat = 5,\n+  SlotDouble = 6,\n+};\n+\n+static jvmtiEnv *jvmti = NULL;\n+\n+static void\n+check_jvmti_error_not_suspended(JNIEnv* jni, const char* func_name, jvmtiError err) {\n+  if (err != JVMTI_ERROR_THREAD_NOT_SUSPENDED) {\n+    LOG(\"%s failed: expected JVMTI_ERROR_THREAD_NOT_SUSPENDED instead of: %d\\n\", func_name, err);\n+    fatal(jni, func_name);\n+  }\n+}\n+\n+static void\n+test_GetLocal(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  jvmtiError err;\n+  const int depth = 0;\n+\n+  jobject msg = NULL;\n+  jint ii = 0;\n+  jlong ll = 0L;\n+  jfloat ff = 0.0;\n+  jdouble dd = 0.0;\n+\n+  LOG(\"\\ntest_GetLocal started\\n\");\n+\n+  \/\/ #0: Test JVMTI GetLocalInstance function\n+  err = jvmti->GetLocalInstance(thread, depth, &msg);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalInstance\", err);\n+  LOG(\"check for JVMTI GetLocalInstance succeeded\\n\");\n+\n+  \/\/ #1: Test JVMTI GetLocalObject function\n+  err = jvmti->GetLocalObject(thread, depth, SlotString, &msg);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalObject\", err);\n+  LOG(\"check for JVMTI GetLocalObject succeeded\\n\");\n+\n+  \/\/ #2: Test JVMTI GetLocalInt function\n+  err = jvmti->GetLocalInt(thread, depth, SlotInt, &ii);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalInt\", err);\n+  LOG(\"check for JVMTI GetLocalInt succeeded\\n\");\n+\n+  \/\/ #3: Test JVMTI GetLocalLong function\n+  err = jvmti->GetLocalLong(thread, depth, SlotLong, &ll);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalLong\", err);\n+  LOG(\"check for JVMTI GetLocalLong succeeded\\n\");\n+\n+  \/\/ #4: Test JVMTI GetLocalFloat function\n+  err = jvmti->GetLocalFloat(thread, depth, SlotFloat, &ff);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalFloat\", err);\n+  LOG(\"check for JVMTI GetLocalFloat succeeded\\n\");\n+\n+  \/\/ #5: Test JVMTI GetLocalDouble function\n+  err = jvmti->GetLocalDouble(thread, depth, SlotDouble, &dd);\n+  check_jvmti_error_not_suspended(jni, \"GetLocalDouble\", err);\n+  LOG(\"check for JVMTI GetLocalDouble succeeded\\n\");\n+\n+  LOG(\"test_GetLocal finished\\n\");\n+}\n+\n+static void\n+test_SetLocal(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  jvmtiError err;\n+  const int depth = 0;\n+\n+  const jobject msg = NULL;\n+  const jint ii = 0;\n+  const jlong ll = 0L;\n+  const jfloat ff = 0.0;\n+  const jdouble dd = 0.0;\n+\n+  LOG(\"\\ntest_SetLocal started\\n\");\n+\n+  \/\/ #1: Test JVMTI SetLocalObject function\n+  err = jvmti->SetLocalObject(thread, depth, SlotString, msg);\n+  check_jvmti_error_not_suspended(jni, \"SetLocalObject\", err);\n+  LOG(\"check for JVMTI SetLocalObject succeeded\\n\");\n+\n+  \/\/ #2: Test JVMTI SetLocalInt function\n+  err = jvmti->SetLocalInt(thread, depth, SlotInt, ii);\n+  check_jvmti_error_not_suspended(jni, \"SetLocalInt\", err);\n+  LOG(\"check for JVMTI SetLocalInt succeeded\\n\");\n+\n+  \/\/ #3: Test JVMTI SetLocalLong function\n+  err = jvmti->SetLocalLong(thread, depth, SlotLong, ll);\n+  check_jvmti_error_not_suspended(jni, \"SetLocalLong\", err);\n+  LOG(\"check for JVMTI SetLocalLong succeeded\\n\");\n+\n+  \/\/ #4: Test JVMTI SetLocalFloat function\n+  err = jvmti->SetLocalFloat(thread, depth, SlotFloat, ff);\n+  check_jvmti_error_not_suspended(jni, \"SetLocalFloat\", err);\n+  LOG(\"check for JVMTI SetLocalFloat succeeded\\n\");\n+\n+  \/\/ #5: Test JVMTI SetLocalDouble function\n+  err = jvmti->SetLocalDouble(thread, depth, SlotDouble, dd);\n+  check_jvmti_error_not_suspended(jni, \"SetLocalDouble\", err);\n+  LOG(\"check for JVMTI SetLocalDouble succeeded\\n\");\n+\n+  LOG(\"test_SetLocal finished\\n\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+\n+  LOG(\"Agent_OnLoad started\\n\");\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_support_virtual_threads = 1;\n+  caps.can_access_local_variables = 1;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"error in JVMTI AddCapabilities: %d\\n\", err);\n+    return JNI_ERR;\n+  }\n+  LOG(\"Agent_OnLoad finished\\n\");\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_GetSetLocalUnsuspended_testUnsuspendedThread(JNIEnv *jni, jclass klass, jthread thread) {\n+  char* tname = get_thread_name(jvmti, jni, thread);\n+  jmethodID method = NULL;\n+  jlocation location = 0;\n+\n+  LOG(\"\\ntestUnsuspendedThread: started for thread: %s\\n\", tname);\n+\n+  test_GetLocal(jvmti, jni, thread);\n+  test_SetLocal(jvmti, jni, thread);\n+\n+  LOG(\"\\ntestUnsuspendedThread: finished for thread: %s\\n\", tname);\n+  deallocate(jvmti, jni, (void*)tname);\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetLocalVariable\/libGetSetLocalUnsuspended.cpp","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @bug 7124710\n+ *\n+ * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @library \/test\/lib\n+ *\n+ * @comment main\/othervm\/native -Xlog:redefine*=trace -agentlib:RedefineRetransform RedefineRetransform\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 1\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 2\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 3\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 4\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 5\n+ * @run main\/othervm\/native -agentlib:RedefineRetransform RedefineRetransform 6\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+\/*\n+ * The test verifies that after interleaved RedefineClasses\/RetransformClasses calls\n+ * JVMTI passes correct class bytes to ClassFileLoadHook (as per JVMTI spec).\n+ * To distinguish class version the test instruments test class overriding runtime-visible annotation.\n+ *\/\n+public class RedefineRetransform {\n+    static {\n+        System.loadLibrary(\"RedefineRetransform\");\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface ClassVersion {\n+        int value();\n+    }\n+\n+    \/\/ Use runtime-visible annotation to specify class version.\n+    @ClassVersion(0)\n+    static class TestClass {\n+        public TestClass() { }\n+    }\n+\n+    \/\/ Redefines testClass with classBytes, instruments with classLoadHookBytes (if != null).\n+    \/\/ Returns class bytes passed to ClassFileLoadHook or null on error.\n+    private static native byte[] nRedefine(Class testClass, byte[] classBytes, byte[] classLoadHookBytes);\n+    \/\/ Retransforms testClass, instruments with classBytes (if != null).\n+    \/\/ Returns class bytes passed to ClassFileLoadHook or null on error.\n+    private static native byte[] nRetransform(Class testClass, byte[] classBytes);\n+\n+    \/\/ Class bytes for initial TestClass (ClassVersion == 0).\n+    private static byte[] initialClassBytes;\n+\n+    private static class VersionScanner extends ClassVisitor {\n+        private Integer detectedVersion;\n+        private Integer versionToSet;\n+        \/\/ to get version\n+        public VersionScanner() {\n+            super(Opcodes.ASM7);\n+        }\n+        \/\/ to set version\n+        public VersionScanner(int verToSet, ClassVisitor classVisitor) {\n+            super(Opcodes.ASM7, classVisitor);\n+            versionToSet = verToSet;\n+        }\n+\n+        public int detectedVersion() {\n+            if (detectedVersion == null) {\n+                throw new RuntimeException(\"Version not detected\");\n+            }\n+            return detectedVersion;\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n+            \/\/log(\"visitAnnotation: descr = '\" + descriptor + \"', visible = \" + visible);\n+            if (Type.getDescriptor(ClassVersion.class).equals(descriptor)) {\n+                return new AnnotationVisitor(Opcodes.ASM7, super.visitAnnotation(descriptor, visible)) {\n+                    @Override\n+                    public void visit(String name, Object value) {\n+                        \/\/log(\"visit: name = '\" + name + \"', value = \" + value\n+                        \/\/        + \" (\" + (value == null ? \"N\/A\" : value.getClass()) + \")\");\n+                        if (\"value\".equals(name) && value instanceof Integer intValue) {\n+                            detectedVersion = intValue;\n+                            if (versionToSet != null) {\n+                                \/\/log(\"replace with \" + versionToSet);\n+                                value = versionToSet;\n+                            }\n+                        }\n+                        super.visit(name, value);\n+                    }\n+                };\n+            }\n+            return super.visitAnnotation(descriptor, visible);\n+        }\n+    }\n+\n+    \/\/ Generates TestClass class bytes with the specified ClassVersion value.\n+    private static byte[] getClassBytes(int ver) {\n+        if (ver < 0) {\n+            return null;\n+        }\n+        ClassWriter cw = new ClassWriter(0);\n+        ClassReader cr = new ClassReader(initialClassBytes);\n+        cr.accept(new VersionScanner(ver, cw), 0);\n+        return cw.toByteArray();\n+    }\n+\n+    \/\/ Extracts ClassVersion values from the provided class bytes.\n+    private static int getClassBytesVersion(byte[] classBytes) {\n+        ClassReader cr = new ClassReader(classBytes);\n+        VersionScanner scanner = new VersionScanner();\n+        cr.accept(scanner, 0);\n+        return scanner.detectedVersion();\n+    }\n+\n+    static void init() {\n+        try {\n+            initialClassBytes = TestClass.class.getClassLoader()\n+                    .getResourceAsStream(\"RedefineRetransform$TestClass.class\")\n+                    .readAllBytes();\n+            log(\"Read TestClass bytes: \" + initialClassBytes.length);\n+        } catch (IOException ex) {\n+            throw new RuntimeException(\"Failed to read class bytes\", ex);\n+        }\n+    }\n+\n+    \/\/ Redefines TestClass to the version specified.\n+    static void redefine(int ver) {\n+        redefine(ver, -1);\n+    }\n+\n+    \/\/ Redefines TestClass to the version specified\n+    \/\/ instrumenting (from ClassFileLoadHook) with 'classLoadHookVer' class bytes (if >= 0).\n+    \/\/ Also verifies that class bytes passed to ClassFileLoadHook have correct version (ver).\n+    static void redefine(int ver, int classLoadHookVer) {\n+        byte[] classBytes = getClassBytes(ver);\n+        byte[] classLoadHookBytes = getClassBytes(classLoadHookVer);\n+\n+        byte[] hookClassBytes = nRedefine(TestClass.class, classBytes, classLoadHookBytes);\n+        if (hookClassBytes == null) {\n+            throw new RuntimeException(\"Redefine error (ver = \" + ver + \")\");\n+        }\n+        \/\/ verify ClassFileLoadHook gets the expected class bytes\n+        int hookVer = getClassBytesVersion(hookClassBytes);\n+        if (hookVer != ver) {\n+            throw new RuntimeException(\"CLFH got unexpected version: \"  + hookVer\n+                    + \" (expected \" + ver + \")\");\n+        }\n+    }\n+\n+    \/\/ Retransforms TestClass instrumenting (from ClassFileLoadHook) with 'ver' class bytes (if >= 0).\n+    \/\/ Verifies that class bytes passed to ClassFileLoadHook have correct version (expectedVer).\n+    static void retransform(int ver, int expectedVer) {\n+        byte[] classBytes = getClassBytes(ver);\n+        byte[] hookClassBytes = nRetransform(TestClass.class, classBytes);\n+        int hookVer = getClassBytesVersion(hookClassBytes);\n+        if (hookVer != expectedVer) {\n+            throw new RuntimeException(\"CLFH got unexpected version: \"  + hookVer\n+                    + \" (expected \" + expectedVer + \")\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int testCase;\n+        try {\n+            testCase = Integer.valueOf(args[0]);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Single numeric argument expected\", ex);\n+        }\n+        init();\n+        switch (testCase) {\n+        case 1:\n+            test(\"Redefine-Retransform-Retransform\", () -> {\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                retransform(3, 1);  \/\/ uses existing cache\n+            });\n+            break;\n+\n+        case 2:\n+            test(\"Redefine-Retransform-Redefine-Redefine\", () -> {\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                redefine(3);        \/\/ resets cached class bytes to nullptr\n+                redefine(4);        \/\/ cached class bytes are not set\n+            });\n+            break;\n+\n+        case 3:\n+            test(\"Redefine-Retransform-Redefine-Retransform\", () -> {\n+                redefine(1);        \/\/ cached class bytes are not set\n+                retransform(2, 1);  \/\/ sets cached class bytes to ver 1\n+                redefine(3);        \/\/ resets cached class bytes to nullptr\n+                retransform(4, 3);  \/\/ sets cached class bytes to ver 3\n+            });\n+            break;\n+\n+        case 4:\n+            test(\"Retransform-Redefine-Retransform-Retransform\", () -> {\n+                retransform(1, 0);  \/\/ sets cached class bytes to ver 0 (initially loaded)\n+                redefine(2);        \/\/ resets cached class bytes to nullptr\n+                retransform(3, 2);  \/\/ sets cached class bytes to ver 2\n+                retransform(4, 2);  \/\/ uses existing cache\n+            });\n+            break;\n+\n+        case 5:\n+            test(\"Redefine-Retransform-Redefine-Retransform with CFLH\", () -> {\n+                redefine(1, 5);     \/\/ CFLH sets cached class bytes to ver 1\n+                retransform(2, 1);  \/\/ uses existing cache\n+                redefine(3, 6);     \/\/ resets cached class bytes to nullptr,\n+                                    \/\/ CFLH sets cached class bytes to ver 3\n+                retransform(4, 3);  \/\/ uses existing cache\n+            });\n+            break;\n+\n+        case 6:\n+            test(\"Retransform-Redefine-Retransform-Retransform with CFLH\", () -> {\n+                retransform(1, 0);  \/\/ sets cached class bytes to ver 0 (initially loaded)\n+                redefine(2, 5);     \/\/ resets cached class bytes to nullptr,\n+                                    \/\/ CFLH sets cached class bytes to ver 2\n+                retransform(3, 2);  \/\/ uses existing cache\n+                retransform(4, 2);  \/\/ uses existing cache\n+            });\n+            break;\n+        }\n+    }\n+\n+    private static void log(Object msg) {\n+        System.out.println(msg);\n+    }\n+\n+    private interface Test {\n+        void test();\n+    }\n+\n+    private static void test(String name, Test theTest) {\n+        log(\">>Test: \" + name);\n+        theTest.test();\n+        log(\"<<Test: \" + name + \" - OK\");\n+        log(\"\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/RedefineRetransform.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+\/\/ set by Agent_OnLoad\n+static jvmtiEnv* jvmti = nullptr;\n+\n+static const char testClassName[] = \"RedefineRetransform$TestClass\";\n+\n+static void _log(const char* format, ...) {\n+    va_list args;\n+    va_start(args, format);\n+    vprintf(format, args);\n+    va_end(args);\n+    fflush(0);\n+}\n+\n+static bool isTestClass(const char* name) {\n+    return name != nullptr && strcmp(name, testClassName) == 0;\n+}\n+\n+\/*\n+ * Helper class for data exchange between RedefineClasses\/RetransformClasses and\n+ * ClassFileLoadHook callback (saves class bytes to be passed to CFLH,\n+ * allows setting new class bytes to return from CFLH).\n+ * Callers create an instance on the stack, ClassFileLoadHook handler uses getInstance().\n+ *\/\n+class ClassFileLoadHookHelper {\n+    const char* mode;   \/\/ for logging only\n+    bool eventEnabled;\n+    JNIEnv* env;\n+    jbyteArray classBytes = nullptr;\n+\n+    unsigned char* savedClassBytes = nullptr;\n+    jint savedClassBytesLen = 0;\n+\n+    \/\/ single instance\n+    static ClassFileLoadHookHelper *instance;\n+public:\n+    ClassFileLoadHookHelper(const char* mode, JNIEnv* jni_env, jbyteArray hookClassBytes)\n+        : mode(mode), eventEnabled(false), env(jni_env), classBytes(nullptr),\n+        savedClassBytes(nullptr), savedClassBytesLen(0)\n+    {\n+        _log(\">>%s\\n\", mode);\n+        if (hookClassBytes != nullptr) {\n+            classBytes = (jbyteArray)env->NewGlobalRef(hookClassBytes);\n+        }\n+    }\n+\n+    ~ClassFileLoadHookHelper() {\n+        \/\/ cleanup on error\n+        stop();\n+        if (classBytes != nullptr) {\n+            env->DeleteGlobalRef(classBytes);\n+        }\n+        if (savedClassBytes != nullptr) {\n+            jvmti->Deallocate(savedClassBytes);\n+        }\n+        _log(\"<<%s\\n\", mode);\n+    }\n+\n+    bool start() {\n+        instance = this;\n+        jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"%s: SetEventNotificationMode(JVMTI_ENABLE) error %d\\n\", mode, err);\n+            eventEnabled = true;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    void stop() {\n+        instance = nullptr;\n+        if (eventEnabled) {\n+            jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+            if (err != JVMTI_ERROR_NONE) {\n+                _log(\"%s: SetEventNotificationMode(JVMTI_DISABLE) error %d\\n\", mode, err);\n+                return;\n+            }\n+            eventEnabled = false;\n+        }\n+    }\n+\n+    \/\/ valid only between start() and stop()\n+    static ClassFileLoadHookHelper* getInstance() {\n+        return instance;\n+    }\n+\n+    bool getHookClassBytes(unsigned char** newClassBytes, jint* newLen) {\n+        if (classBytes != nullptr) {\n+            jsize len = env->GetArrayLength(classBytes);\n+            unsigned char* buf = nullptr;\n+            jvmtiError err = jvmti->Allocate(len, &buf);\n+            if (err != JVMTI_ERROR_NONE) {\n+                _log(\"ClassFileLoadHook: failed to allocate %ld bytes for new class bytes: %d\", len, err);\n+                return false;\n+            }\n+\n+            jbyte* arrayPtr = env->GetByteArrayElements(classBytes, nullptr);\n+            if (arrayPtr == nullptr) {\n+                _log(\"ClassFileLoadHook: failed to get array elements\\n\");\n+                jvmti->Deallocate(buf);\n+                return false;\n+            }\n+\n+            memcpy(buf, arrayPtr, len);\n+\n+            env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n+\n+            *newClassBytes = buf;\n+            *newLen = len;\n+\n+            _log(\"  ClassFileLoadHook: set new class bytes\\n\");\n+        }\n+        return true;\n+    }\n+\n+    void setSavedHookClassBytes(const unsigned char* bytes, jint len) {\n+        jvmtiError err = jvmti->Allocate(len, &savedClassBytes);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"ClassFileLoadHook: failed to allocate %ld bytes for saved class bytes: %d\", len, err);\n+            return;\n+        }\n+        memcpy(savedClassBytes, bytes, len);\n+        savedClassBytesLen = len;\n+    }\n+\n+    jbyteArray getSavedHookClassBytes() {\n+        if (savedClassBytes == nullptr) {\n+            _log(\"%s: savedClassBytes is NULL\\n\", mode);\n+            return nullptr;\n+        }\n+\n+        jbyteArray result = env->NewByteArray(savedClassBytesLen);\n+        if (result == nullptr) {\n+            _log(\"%s: NewByteArray(%ld) failed\\n\", mode, savedClassBytesLen);\n+        } else {\n+            jbyte* arrayPtr = env->GetByteArrayElements(result, nullptr);\n+            if (arrayPtr == nullptr) {\n+                _log(\"%s: Failed to get array elements\\n\", mode);\n+                result = nullptr;\n+            } else {\n+                memcpy(arrayPtr, savedClassBytes, savedClassBytesLen);\n+                env->ReleaseByteArrayElements(result, arrayPtr, JNI_COMMIT);\n+            }\n+        }\n+        return result;\n+    }\n+};\n+\n+ClassFileLoadHookHelper* ClassFileLoadHookHelper::instance = nullptr;\n+\n+\n+extern \"C\" {\n+\n+JNIEXPORT void JNICALL\n+callbackClassFileLoadHook(jvmtiEnv *jvmti_env,\n+        JNIEnv* jni_env,\n+        jclass class_being_redefined,\n+        jobject loader,\n+        const char* name,\n+        jobject protection_domain,\n+        jint class_data_len,\n+        const unsigned char* class_data,\n+        jint* new_class_data_len,\n+        unsigned char** new_class_data) {\n+    if (isTestClass(name)) {\n+        _log(\">>ClassFileLoadHook: %s, %ld bytes, ptr = %p\\n\", name, class_data_len, class_data);\n+\n+        ClassFileLoadHookHelper* helper = ClassFileLoadHookHelper::getInstance();\n+        if (helper == nullptr) {\n+            _log(\"ClassFileLoadHook ERROR: helper instance is not initialized\\n\");\n+            return;\n+        }\n+        \/\/ save class bytes\n+        helper->setSavedHookClassBytes(class_data, class_data_len);\n+        \/\/ set new class bytes\n+        helper->getHookClassBytes(new_class_data, new_class_data_len);\n+\n+        _log(\"<<ClassFileLoadHook\\n\");\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+    jint res = jvm->GetEnv((void **)&jvmti, JVMTI_VERSION_1_1);\n+    if (res != JNI_OK) {\n+        _log(\"Failed to get JVMTI interface: %ld\\n\", res);\n+        return JNI_ERR;\n+    }\n+\n+    jvmtiCapabilities caps;\n+    memset(&caps, 0, sizeof(caps));\n+\n+    caps.can_redefine_classes = 1;\n+    caps.can_retransform_classes = 1;\n+    jvmtiError err = jvmti->AddCapabilities(&caps);\n+    if (err != JVMTI_ERROR_NONE) {\n+        _log(\"Failed to add capabilities: %d\\n\", err);\n+        return JNI_ERR;\n+    }\n+\n+    jvmtiEventCallbacks eventCallbacks;\n+    memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n+    eventCallbacks.ClassFileLoadHook = callbackClassFileLoadHook;\n+    err = jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+        _log(\"Error setting event callbacks: %d\\n\", err);\n+        return JNI_ERR;\n+    }\n+\n+    return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Agent_OnUnload(JavaVM* jvm) {\n+    return;\n+}\n+\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_RedefineRetransform_nRedefine(JNIEnv* env, jclass klass,\n+                                   jclass testClass, jbyteArray classBytes, jbyteArray classLoadHookBytes) {\n+\n+    ClassFileLoadHookHelper helper(\"nRedefine\", env, classLoadHookBytes);\n+\n+    jsize len = env->GetArrayLength(classBytes);\n+    jbyte* arrayPtr = env->GetByteArrayElements(classBytes, nullptr);\n+    if (arrayPtr == nullptr) {\n+        _log(\"nRedefine: Failed to get array elements\\n\");\n+        return nullptr;\n+    }\n+\n+    if (helper.start()) {\n+        jvmtiClassDefinition classDef;\n+        memset(&classDef, 0, sizeof(classDef));\n+        classDef.klass = testClass;\n+        classDef.class_byte_count = len;\n+        classDef.class_bytes = (unsigned char*)arrayPtr;\n+\n+        jvmtiError err = jvmti->RedefineClasses(1, &classDef);\n+\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"nRedefine: RedefineClasses error %d\", err);\n+            \/\/ don't exit here, need to cleanup\n+        }\n+        helper.stop();\n+    }\n+\n+    env->ReleaseByteArrayElements(classBytes, arrayPtr, JNI_ABORT);\n+\n+    return helper.getSavedHookClassBytes();\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_RedefineRetransform_nRetransform(JNIEnv* env, jclass klass, jclass testClass, jbyteArray classBytes) {\n+\n+    ClassFileLoadHookHelper helper(\"nRetransform\", env, classBytes);\n+    if (helper.start()) {\n+        jvmtiError err = jvmti->RetransformClasses(1, &testClass);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"nRetransform: RetransformClasses error %d\\n\", err);\n+            \/\/ don't exit here, disable CFLH event\n+        }\n+        helper.stop();\n+    }\n+    return helper.getSavedHookClassBytes();\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/libRedefineRetransform.cpp","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -1,177 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"jvmti_common.h\"\n-#include \"jvmti_thread.h\"\n-\n-extern \"C\" {\n-\n-\/* scaffold objects *\/\n-static jlong timeout = 0;\n-\n-\/* constant names *\/\n-#define THREAD_NAME     \"TestedThread\"\n-#define N_LATE_CALLS    10000\n-\n-\/** Agent algorithm. *\/\n-static void JNICALL\n-agentProc(jvmtiEnv *jvmti, JNIEnv *jni, void *arg) {\n-  jvmtiError err;\n-  \/* Original agentProc test block starts here: *\/\n-  LOG(\"Wait for thread to start\\n\");\n-  \/\/ SP2.1-n - notify agent is waiting and wait\n-  \/\/ SP3.1-w - wait to start test\n-  if (!agent_wait_for_sync(timeout))\n-    return;\n-\n-  \/* perform testing *\/\n-  {\n-    jthread testedThread = NULL;\n-    int late_count;\n-\n-    LOG(\"Find thread: %s\\n\", THREAD_NAME);\n-    testedThread = find_thread_by_name(jvmti, jni, THREAD_NAME);\n-    if (testedThread == NULL) {\n-      return;\n-    }\n-    LOG(\"  ... found thread: %p\\n\", (void *) testedThread);\n-\n-    LOG(\"Suspend thread: %p\\n\", (void *) testedThread);\n-    err = jvmti->SuspendThread(testedThread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      set_agent_fail_status();\n-      return;\n-    }\n-\n-    LOG(\"Let thread to run and finish\\n\");\n-    \/\/ SP5.1-n - notify suspend done\n-    if (!agent_resume_sync())\n-      return;\n-\n-    LOG(\"Get state vector for thread: %p\\n\", (void *) testedThread);\n-    {\n-      jint state = 0;\n-\n-      err = jvmti->GetThreadState(testedThread, &state);\n-      if (err != JVMTI_ERROR_NONE) {\n-        set_agent_fail_status();\n-        return;\n-      }\n-      LOG(\"  ... got state vector: %s (%d)\\n\", TranslateState(state), (int) state);\n-\n-      if ((state & JVMTI_THREAD_STATE_SUSPENDED) == 0) {\n-        LOG(\"SuspendThread() does not turn on flag SUSPENDED:\\n\"\n-            \"#   state: %s (%d)\\n\", TranslateState(state), (int) state);\n-        set_agent_fail_status();\n-      }\n-    }\n-\n-    LOG(\"Resume thread: %p\\n\", (void *) testedThread);\n-    err = jvmti->ResumeThread(testedThread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      set_agent_fail_status();\n-      return;\n-    }\n-    \/* Original agentProc test block ends here. *\/\n-\n-    \/*\n-     * Using LOG() instead of LOG() in this loop\n-     * in order to slow down the rate of SuspendThread() calls.\n-     *\/\n-    for (late_count = 0; late_count < N_LATE_CALLS; late_count++) {\n-      jvmtiError l_err;\n-      LOG(\"INFO: Late suspend thread: %p\\n\", (void *) testedThread);\n-      l_err = jvmti->SuspendThread(testedThread);\n-      if (l_err != JVMTI_ERROR_NONE) {\n-        LOG(\"INFO: Late suspend thread err: %d\\n\", l_err);\n-        \/\/ testedThread has exited so we're done with late calls\n-        break;\n-      }\n-\n-      \/\/ Only resume a thread if suspend worked. Using LOG()\n-      \/\/ here because we want ResumeThread() to be faster.\n-      LOG(\"INFO: Late resume thread: %p\\n\", (void *) testedThread);\n-      err = jvmti->ResumeThread(testedThread);\n-      if (err != JVMTI_ERROR_NONE) {\n-        set_agent_fail_status();\n-        return;\n-      }\n-    }\n-\n-    LOG(\"INFO: made %d late calls to JVM\/TI SuspendThread()\\n\", late_count);\n-    LOG(\"INFO: N_LATE_CALLS == %d value is %slarge enough to cause a \"\n-        \"SuspendThread() call after thread exit.\\n\", N_LATE_CALLS,\n-        (late_count == N_LATE_CALLS) ? \"NOT \" : \"\");\n-\n-    \/* Second part of original agentProc test block starts here: *\/\n-    LOG(\"Wait for thread to finish\\n\");\n-    \/\/ SP4.1-n - notify agent is waiting and wait\n-    \/\/ SP6.1-w - wait to end test\n-    if (!agent_wait_for_sync(timeout))\n-      return;\n-\n-    LOG(\"Delete thread reference\\n\");\n-    jni->DeleteGlobalRef(testedThread);\n-  }\n-\n-  LOG(\"Let debugee to finish\\n\");\n-  \/\/ SP7.1-n - notify agent end\n-  if (!agent_resume_sync())\n-    return;\n-  \/* Second part of original agentProc test block ends here. *\/\n-}\n-\n-JNIEXPORT jint JNICALL\n-Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  jvmtiEnv *jvmti = NULL;\n-\n-  timeout = 60 * 1000;\n-\n-  jint res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n-  if (res != JNI_OK || jvmti == NULL) {\n-    LOG(\"Wrong result of a valid call to GetEnv!\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  \/* add specific capabilities for suspending thread *\/\n-  jvmtiCapabilities suspendCaps;\n-  memset(&suspendCaps, 0, sizeof(suspendCaps));\n-  suspendCaps.can_suspend = 1;\n-  if (jvmti->AddCapabilities(&suspendCaps) != JVMTI_ERROR_NONE) {\n-    return JNI_ERR;\n-  }\n-\n-  if (init_agent_data(jvmti, &agent_data) != JVMTI_ERROR_NONE) {\n-    return JNI_ERR;\n-  }\n-  \/* register agent proc and arg *\/\n-  if (!set_agent_proc(agentProc, NULL)) {\n-    return JNI_ERR;\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/SuspendThread\/suspendthrd03\/libsuspendthrd03.cpp","additions":0,"deletions":177,"binary":false,"changes":177,"status":"deleted"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/SuspendThread\/suspendthrd003.\n- * VM Testbase keywords: [jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Same test as suspendthrd001 with additional calls to\n- *     SuspendThread() and ResumeThread() while threads are exiting.\n- *     Failing criteria for the test are:\n- *       - failures of used JVMTI functions.\n- * COMMENTS\n- *     Derived from nsk\/jvmti\/SuspendThread\/suspendthrd001.\n- * Transaction Diagram for this test:\n- * main thread                                      agent thread                                       TestedThread-N\n- * ===============================================  =================================================  =============================================\n- * data->thread_state = NEW\n- * for N = 0; i < N_THREADS; i++ {\n- *   thr = new TestedThread-N\n- *   thr.start()                                                                                       run()\n- *   # SP1-w - wait for TestedThread-N to be ready                                                     :\n- *   thr.checkReady()                                                                                  \/\/ SP1-n - tell main we are ready\n- *   :                                                                                                 threadReady = true\n- *   \/\/ SP2.1-w - wait for agent thread                                                                while (!shouldFinish) {\n- *   \/\/ SP3.1-n - notify to start test                                                                   \/\/ do work\n- *   \/\/ SP5.1-w - wait while testing                                                                     :\n- *   checkStatus(() {                                                                                    :\n- *     enter(data.monitor)                                                                               :\n- *     if data.thread_state == NEW {                                                                     :\n- *       run_agent_thread                                                                        :\n- *       :                                          \/\/ this set is in the agent wrapper:                 :\n- *       :                                          data.thread_state = RUNNABLE                         :\n- *       :                                          agentProc() {                                        :\n- *       :                                            \/\/ SP2.1-n - notify agent is waiting               :\n- *       :                                            \/\/ SP3.1-w - wait to start test                    :\n- *       while (data.thread_state == NEW) {           waitForSync() {                                    :\n- *         \/\/ SP2.2-w - wait for agent thread           enter(data.monitor)                              :\n- *         wait(data.monitor)                           : <blocked>                                      :\n- *         :                                            : <enter>                                        :\n- *         :                                            data.thread_state = WAITING                      :\n- *         :                                            \/\/ SP2.2-n - notify agent is waiting and wait    :\n- *         :                                            notify(data.monitor)                             :\n- *         : <notified>                                 while (data.thread_state == WAITING) {           :\n- *         :                                              \/\/ SP3.2-w - wait to start test                :\n- *         :                                              wait(data.monitor)                             :\n- *         : <reentered>                                  :                                              :\n- *       }                                                :                                              :\n- *       \/\/ saw data.thread_state == WAITING              :                                              :\n- *     }                                                  :                                              :\n- *     \/\/ we don't enter loop in first call               :                                              :\n- *     while (data.thread_state != WAITING                :                                              :\n- *            data.thread_state != TERMINATED) {          :                                              :\n- *       \/\/ SP4.2-w - second wait for agent thread        :                                              :\n- *       wait(data.monitor)                               :                                              :\n- *     }                                                  :                                              :\n- *     if (data.thread_state != TERMINATED) {             :                                              :\n- *       data.thread_state = SUSPENDED                    :                                              :\n- *       \/\/ SP3.2-n - notify to start test                :                                              :\n- *       notify(data.monitor)                             :                                              :\n- *     }                                                  : <notified>                                   :\n- *     while (data.thread_state == SUSPENDED) {           :                                              :\n- *       \/\/ SP5.2-w - wait while testing                  :                                              :\n- *       wait(data.monitor)                               :                                              :\n- *       :                                                : <reentered>                                  :\n- *       :                                              }                                                :\n- *       :                                              \/\/ saw data.thread_state == SUSPENDED            :\n- *       :                                              exit(data.monitor)                               :\n- *       :                                            } \/\/ end waitForSync()                             :\n- *       :                                            SuspendThread(TestedThread-N)                      :\n- *       :                                            \/\/ SP5.1-n - notify suspend done                   : <thread suspended>\n- *       :                                            resumeSync() {                                     :\n- *       :                                              enter(data.monitor)                              :\n- *       :                                              if (data.thread_state == SUSPENDED) {            :\n- *       :                                                data.thread_state = RUNNABLE                   :\n- *       :                                                \/\/ SP5.2-n - notify suspend done               :\n- *       :                                                notify(data.monitor)                           :\n- *       : <notified>                                   }                                                :\n- *       :                                              exit(data.monitor)                               :\n- *       : <re-entered>                               } \/\/ end resumeSync()                              :\n- *     }                                              GetThreadState(TestedThread-N)                     :\n- *     \/\/ saw data.thread_state -= RUNNABLE           ResumeThread(TestedThread-N)                       : <thread resumed>\n- *     :                                              for (1..N_LATE_CALLS) {                            :\n- *   } \/\/ end checkStatus()                             SuspendThread(TestedThread-N)                    :\n- *   :                                                  :                                                : <thread suspended>\n- *   thr.letFinish()                                    ResumeThread(TestedThread-N)                     :\n- *     shouldFinish = true;                             :                                                : <thread resumed>\n- *   thr.join()                                         :                                                : <sees shouldFinish == true>\n- *   :                                                  :                                              }\n- *   :                                                  :                                              : <thread exits>\n- *   : <join() sees thread exit>                        : <SuspendThread sees thread exit & breaks>\n- *   \/\/ SP4.1-w - second wait for agent thread        }\n- *   \/\/ SP6.1-n - notify to end test                  :\n- *   \/\/ SP7.1 - wait for agent end                    :\n- *   checkStatus()                                    \/\/ SP4.1-n - notify agent is waiting and wait\n- *     enter(data.monitor)                            \/\/ SP6.1-w - wait to end test\n- *     :                                              waitForSync()\n- *     \/\/ we don't enter if-stmt in second call         enter(data.monitor)\n- *     if data.thread_state == NEW {                    : <blocked>\n- *     }                                                :\n- *     while (data.thread_state != WAITING              :\n- *            data.thread_state != TERMINATED) {        :\n- *       \/\/ SP4.2-w - second wait for agent thread      :\n- *       wait(data.monitor)                             :\n- *       :                                              : <enter>\n- *       :                                              data.thread_state = WAITING\n- *       :                                              \/\/ SP4.2-n - notify agent is waiting and wait\n- *       :                                              notify(data.monitor)\n- *       : <notified>                                   while (data.thread_state == WAITING) {\n- *       :                                                \/\/ SP6.2-w - wait to end test\n- *       :                                                wait(data.monitor)\n- *       : <reentered>                                    :\n- *     }                                                  :\n- *     \/\/ saw thread_state == WAITING                     :\n- *     if (data.thread_state != TERMINATED) {             :\n- *       data.thread_state = SUSPENDED                    :\n- *       \/\/ SP6.2-n - notify to end test                  :\n- *       notify(data.monitor)                             :\n- *     }                                                  : <notified>\n- *     while (data.thread_state == SUSPENDED) {           :\n- *       \/\/ SP7.2 - wait for agent end                    :\n- *       wait(data.monitor)                               :\n- *       :                                                : <reentered>\n- *       :                                              }\n- *       :                                              \/\/ saw data.thread_state == SUSPENDED\n- *       :                                              exit(data.monitor)\n- *       :                                            } \/\/ end waitForSync()\n- *       :                                            \/\/ SP7.1-n - notify agent end\n- *       :                                            resumeSync() {\n- *       :                                              enter(data.monitor)\n- *       :                                              if (data.thread_state == SUSPENDED) {\n- *       :                                                data.thread_state = RUNNABLE\n- *       :                                                \/\/ SP7.2-n - notify agent end\n- *       :                                                notify(data.monitor)\n- *       : <notified>                                   }\n- *       :                                              exit(data.monitor)\n- *       : <re-entered>                               } \/\/ end resumeSync()\n- *     }                                            } \/\/ end agentProc\n- *     \/\/ saw data.thread_state -= RUNNABLE         \/\/ this set is in the wrapper:\n- *   } \/\/ end checkStatus()                         data.thread_state = TERMINATED\n- *   resetAgentData() {\n- *     enter(data.monitor)\n- *     while (data.thread_state != TERMINATED) {\n- *       wait(data.monitor, 10);\n- *     }\n- *     data.thread_state = NEW\n- *     exit(data.monitor)\n- *   } \/\/ end resetAgentData()\n- *\n- * @library \/test\/lib\n- * @run main\/othervm\/native -Xlog:thread+smr=debug -agentlib:suspendthrd03=-waittime=5 suspendthrd03\n- *\/\n-\n-import jdk.test.lib.jvmti.DebugeeClass;\n-\n-public class suspendthrd03 extends DebugeeClass {\n-\n-    final static int N_THREADS = 10;\n-\n-    \/\/ load native library if required\n-    static {\n-        System.loadLibrary(\"suspendthrd03\");\n-    }\n-\n-    public static void main(String argv[]) {\n-        int result =  new suspendthrd03().runIt();\n-        if (result != 0) {\n-            throw new RuntimeException(\"check failed with result \" + result);\n-        }\n-    }\n-\n-    \/* =================================================================== *\/\n-    long timeout = 0;\n-    int status = DebugeeClass.TEST_PASSED;\n-\n-    \/\/ tested thread\n-    suspendthrd03Thread thread = null;\n-\n-    \/\/ run debuggee\n-    public int runIt() {\n-        timeout = 60 * 1000; \/\/ milliseconds\n-\n-        for (int i = 0; i < N_THREADS; i++) {\n-            System.out.println(\"Starting TestedThread #\" + i + \".\");\n-\n-            \/\/ Original suspendthrd001 test block starts here:\n-            \/\/\n-            \/\/ create tested thread\n-            \/\/ Note: Cannot use TestedThread-N for thread name since\n-            \/\/ the agent has to know the thread's name.\n-            thread = new suspendthrd03Thread(\"TestedThread\");\n-\n-            \/\/ run tested thread\n-            System.out.println(\"Starting tested thread\");\n-            try {\n-                thread.start();\n-                \/\/ SP1-w - wait for TestedThread-N to be ready\n-                if (!thread.checkReady()) {\n-                    throw new RuntimeException(\"Unable to prepare tested thread: \" + thread);\n-                }\n-\n-                \/\/ testing sync\n-                System.out.println(\"Sync: thread started\");\n-                \/\/ SP2.1-w - wait for agent thread\n-                \/\/ SP3.1-n - notify to start test\n-                \/\/ SP5.1-w - wait while testing\n-                status = checkStatus(status);\n-            } finally {\n-                \/\/ let thread to finish\n-                thread.letFinish();\n-            }\n-\n-            \/\/ wait for thread to finish\n-            System.out.println(\"Finishing tested thread\");\n-            try {\n-                thread.join();\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-\n-            \/\/ testing sync\n-            System.out.println(\"Sync: thread finished\");\n-            \/\/ SP4.1-w - second wait for agent thread\n-            \/\/ SP6.1-n - notify to end test\n-            \/\/ SP7.1 - wait for agent end\n-            status = checkStatus(status);\n-\n-            \/\/ Original suspendthrd001 test block ends here.\n-\n-            if (status != DebugeeClass.TEST_PASSED) {\n-                break;\n-            }\n-\n-            resetAgentData();  \/\/ reset for another iteration\n-        }\n-\n-        return status;\n-    }\n-}\n-\n-\/* =================================================================== *\/\n-\n-\/\/ basic class for tested threads\n-class suspendthrd03Thread extends Thread {\n-    private volatile boolean threadReady = false;\n-    private volatile boolean shouldFinish = false;\n-\n-    \/\/ make thread with specific name\n-    public suspendthrd03Thread(String name) {\n-        super(name);\n-    }\n-\n-    \/\/ run thread continuously\n-    public void run() {\n-        \/\/ run in a loop\n-        \/\/ SP1-n - tell main we are ready\n-        threadReady = true;\n-        int i = 0;\n-        int n = 1000;\n-        while (!shouldFinish) {\n-            if (n <= 0) {\n-                n = 1000;\n-            }\n-            if (i > n) {\n-                i = 0;\n-                n = n - 1;\n-            }\n-            i = i + 1;\n-        }\n-    }\n-\n-    \/\/ check if thread is ready\n-    public boolean checkReady() {\n-        try {\n-            while (!threadReady) {\n-                sleep(1000);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\"Interruption while preparing tested thread: \\n\\t\" + e);\n-        }\n-        return threadReady;\n-    }\n-\n-    \/\/ let thread to finish\n-    public void letFinish() {\n-        shouldFinish = true;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/SuspendThread\/suspendthrd03\/suspendthrd03.java","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"},{"patch":"@@ -130,0 +130,2 @@\n+    suspend_thread(jvmti, jni, cthread);\n+\n@@ -133,0 +135,2 @@\n+\n+    resume_thread(jvmti, jni, cthread);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetSetLocalTest\/libGetSetLocalTest.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -381,2 +381,2 @@\n-  err = jvmti->GetLocalInstance(cthread, 3, &obj);\n-  check_jvmti_status(jni, err, \"event handler: error in JVMTI GetLocalInstance for carrier thread top frame Continuation.run\");\n+  {\n+    suspend_thread(jvmti, jni, cthread);\n@@ -384,1 +384,6 @@\n-  LOG(\"JVMTI GetLocalInstance succeed for carrier thread top frame Continuation.run()\\n\");\n+    err = jvmti->GetLocalInstance(cthread, 3, &obj);\n+    check_jvmti_status(jni, err, \"event handler: error in JVMTI GetLocalInstance for carrier thread top frame Continuation.run\");\n+    LOG(\"JVMTI GetLocalInstance succeed for carrier thread top frame Continuation.run()\\n\");\n+\n+    resume_thread(jvmti, jni, cthread);\n+  }\n@@ -592,0 +597,1 @@\n+  caps.can_suspend = 1;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadTest\/libVThreadTest.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -319,2 +319,0 @@\n-\n-\/* DEBUG -- while thread should be suspended\n@@ -322,1 +320,0 @@\n-*\/\n@@ -328,1 +325,0 @@\n-\/* DEBUG -- while thread should be suspended\n@@ -335,1 +331,0 @@\n-*\/\n@@ -391,1 +386,0 @@\n-\/* DEBUG -- while thread should be suspended\n@@ -396,1 +390,0 @@\n-*\/\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t011\/cm01t011.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package xpath;\n+\n+\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+\/*\n+ * @test\n+ * @bug 8289509\n+ * @library \/javax\/xml\/jaxp\/unittest\n+ * @run testng\/othervm xpath.XPathExpDescendantTest\n+ * @summary Tests for XPath descendant\/descendant-or-self axis specifier.\n+ *\/\n+public class XPathExpDescendantTest extends XPathTestBase {\n+\n+    \/*\n+     * DataProvider: provides XPath Axis descendant expressions and equivalent xpath expression.\n+     *\/\n+    @DataProvider(name = \"descendantXpath\")\n+    public Object[][] getDescendantXpathExpression() {\n+        return new Object[][] {\n+                {\"\/Customers\/descendant::*\", \"\/Customers\/\/*\"},\n+                {\"\/Customers\/descendant::Customer\", \"\/\/Customer\"},\n+                {\"\/Customers\/descendant::foo:Customer\", \"\/\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::Address\",\n+                        \"\/Customers\/Customer[@id='x1']\/Address\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::*\",\n+                        \"\/Customers\/Customer[@id='x1']\/\/*\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Address\/\/*\"},\n+                {\"\/Customers\/descendant::Name\", \"\/Customers\/\/Name\"},\n+                {\"\/Customers\/descendant::Street\", \"\/Customers\/\/Street\"},\n+                {\"\/Customers\/descendant::Street[2]\", \"Customers\/Customer[@id='x2']\/Address\/Street\"},\n+                {\"\/Customers\/descendant::Street[2]\", \"(Customers\/\/Street)[2]\"},\n+                {\"\/Customers\/descendant::Street[position() = 2]\",\n+                        \"Customers\/Customer[@id='x2']\/Address\/Street\"},\n+                {\"\/Customers\/descendant-or-self::*\", \"\/\/*\"},\n+                {\"\/Customers\/descendant-or-self::Customer\", \"\/Customers\/Customer\"},\n+                {\"\/Customers\/descendant-or-self::foo:Customer\", \"\/Customers\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::Address\",\n+                        \"\/Customers\/Customer[@id = 'x1']\/Address\"},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::*\",\n+                        \"\/Customers\/Customer[@id='x1'] | \/Customers\/Customer[@id = 'x1']\/\/*\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant-or-self::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Address | \/Customers\/foo:Customer\/foo:Address\/\/*\"},\n+                {\"\/Customers\/Customer\/*[descendant::Street]\", \"\/Customers\/Customer\/Address\"},\n+                {\"\/Customers\/Customer\/*[not(descendant::Street)]\", \"\/Customers\/Customer\/*[name() != \\\"Address\\\"]\"},\n+                {\"\/Customers\/Customer\/*[descendant-or-self::Street]\", \"\/Customers\/Customer\/Address\"},\n+                {\"\/Customers\/Customer\/*[not(descendant-or-self::Street)]\",\n+                        \"\/Customers\/Customer\/*[name() != \\\"Address\\\"]\"}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath descendant expressions and expected number of descendant nodes returned\n+     *\/\n+    @DataProvider(name = \"descendantXpathNodeCount\")\n+    public Object[][] getDescendantXpathExpressionNodeCount() {\n+        return new Object[][] {\n+                {\"\/Customers\/descendant::*\", 40},\n+                {\"\/Customers\/descendant::Customer\", 3},\n+                {\"\/Customers\/descendant::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::Address\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant::*\", 9},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant::*\", 3},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/descendant::Address\", 0},\n+                {\"\/Customers\/descendant-or-self::*\", 41},\n+                {\"\/Customers\/descendant-or-self::Customer\", 3},\n+                {\"\/Customers\/descendant-or-self::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::Address\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/descendant-or-self::Address\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/descendant-or-self::*\", 10},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/descendant-or-self::*\", 4},\n+                {\"\/Customers\/*[descendant::Name]\", 3},\n+                {\"\/Customers\/foo:Customer\/*[descendant-or-self::foo:Street]\", 1}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath descendant expressions which should return null.\n+     *\/\n+    @DataProvider(name = \"descendantXpathEmpty\")\n+    public Object[][] getDescendantXpathExpressionEmpty() {\n+        return new Object[][] {\n+                {\"\/Customers\/Customer\/Name\/descendant::*\"},\n+                {\"\/Customers\/foo:Customer\/descendant::Name\"},\n+                {\"\/Customers\/Customer\/descendant::foo:Name\"},\n+                {\"\/Customers\/descendant::id\"},\n+                {\"\/Customers\/Customer\/Name\/descendant-or-self::id\"},\n+                {\"\/Customers\/foo:Customer\/descendant-or-self::Name\"},\n+                {\"\/Customers\/Customer\/descendant-or-self::foo:Name\"},\n+                {\"\/Customers\/descendant-or-self::id\"}\n+        };\n+    }\n+\n+    \/**\n+     * Verifies descendant xpath expression returns same nodes as returns when used normal xpath expression\n+     * @param  descexp  descendant XPath expression.\n+     * @param  expath   normal xPath expression\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"descendantXpath\")\n+    public void descendantExpTests(String descexp, String expath) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList actualNodeList = (NodeList) xPath.evaluate(descexp, doc, XPathConstants.NODESET);\n+        NodeList expectedNodeList = (NodeList) xPath.evaluate(expath, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(actualNodeList.getLength(), expectedNodeList.getLength());\n+\n+        for(int i = 0; i < actualNodeList.getLength(); i++) {\n+            actualNodeList.item(i).equals(expectedNodeList.item(i));\n+        }\n+    }\n+\n+    \/**\n+     * Verifies descendant xpath expression return descendant nodes list with correct number of nodes.\n+     * @param  exp       XPath expression.\n+     * @param  nodeCount number of descendant nodes in nodelist.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"descendantXpathNodeCount\")\n+    public void descendantNodesCountTests(String exp, int nodeCount) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList nodeList = (NodeList) xPath.evaluate(exp, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(nodeList.getLength(), nodeCount);\n+    }\n+\n+    \/**\n+     * Verifies descendant xpath expression return no nodes if descendant expression context nodes don't have matching descendants\n+     * @param  exp     XPath expression.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"descendantXpathEmpty\")\n+    public void DescendantScopeTests(String exp) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        Node node = xPath.evaluateExpression(exp, doc, Node.class);\n+        Assert.assertNull(node);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathExpDescendantTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package xpath;\n+\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+\/*\n+ * @test\n+ * @bug 8289509\n+ * @library \/javax\/xml\/jaxp\/unittest\n+ * @run testng\/othervm xpath.XPathExpFollowingTest\n+ * @summary Tests for XPath following\/following-sibling axis specifier.\n+ *\/\n+public class XPathExpFollowingTest extends XPathTestBase {\n+    \/*\n+     * DataProvider: provides XPath Axis following expressions and equivalent xpath expression.\n+     *\/\n+    @DataProvider(name = \"followingXpath\")\n+    public Object[][] getFollowingXpathExpression() {\n+        return new Object[][] {\n+                {\"\/Customers\/following::*\", \"\/None\"},\n+                {\"\/Customers\/Customer\/following::Customer\", \"\/\/Customer[@id != 'x1']\"},\n+                {\"\/Customers\/Customer\/following::foo:Customer\", \"\/\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::Address\",\n+                        \"\/Customers\/Customer[@id != 'x1']\/Address\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::Street\",\n+                        \"\/Customers\/Customer[@id != 'x1']\/Address\/Street\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::Street[2]\",\n+                        \"\/Customers\/Customer[@id='x2']\/Address\/Street\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following::*\",\n+                        \"\/Customers\/Customer[@id != 'x1']\/descendant-or-self::*\" +\n+                                \" | \/Customers\/foo:Customer\/descendant-or-self::*\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Age | \/Customers\/foo:Customer\/foo:ClubMember\"},\n+                {\"\/Customers\/Customer[@id = 'x1']\/*[following::Street]\", \"\/Customers\/Customer[@id = 'x1']\/*\"},\n+                {\"\/Customers\/foo:Customer\/*[following::foo:Name]\", \"\/None\"},\n+                {\"\/Customers\/foo:Customer\/*[not(following::foo:Name)]\", \"\/Customers\/foo:Customer\/*\"},\n+                {\"\/Customers\/following-sibling::*\", \"\/None\"},\n+                {\"\/Customers\/Customer\/following-sibling::Customer\",\n+                        \"\/Customers\/Customer[@id != 'x1']\"},\n+                {\"\/Customers\/Customer\/following-sibling::foo:Customer\",\n+                        \"\/Customers\/foo:Customer\"},\n+                {\"\/Customers\/Customer[@id='x1']\/Name\/following-sibling::Address\",\n+                        \"\/Customers\/Customer[@id='x1']\/Address\"},\n+                {\"\/Customers\/Customer\/Name\/following-sibling::Address\",\n+                        \"\/Customers\/\/Address\"},\n+                {\"(\/Customers\/Customer\/Address\/Street\/following-sibling::State)[3]\",\n+                        \"\/Customers\/Customer[@id='x3']\/Address\/State\"},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/Street\/following-sibling::*[2]\",\n+                        \"\/Customers\/Customer[@id='x3']\/Address\/State\"},\n+                {\"\/Customers\/Customer[@id='x1']\/following-sibling::*\",\n+                        \"\/Customers\/Customer[@id != 'x1'] | \/Customers\/foo:Customer\"},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following-sibling::*\",\n+                        \"\/Customers\/foo:Customer\/foo:Age | \/Customers\/foo:Customer\/foo:ClubMember\"},\n+                {\"\/Customers\/Customer[@id = 'x1']\/*[following-sibling::Street]\", \"\/None\"},\n+                {\"\/Customers\/foo:Customer\/*[following-sibling::foo:Address]\", \"\/Customers\/foo:Customer\/foo:Name |\" +\n+                        \"\/Customers\/foo:Customer\/foo:Phone | \/Customers\/foo:Customer\/foo:Email\"},\n+                {\"\/Customers\/foo:Customer\/*[not(following-sibling::foo:Address)]\", \"\/Customers\/foo:Customer\/foo:Age | \" +\n+                        \"\/Customers\/foo:Customer\/foo:ClubMember | \/Customers\/foo:Customer\/foo:Address\"}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath following expressions and expected number of following nodes returned\n+     *\/\n+    @DataProvider(name = \"followingXpathNodeCount\")\n+    public Object[][] getFollowingXpathExpressionNodeCount() {\n+        return new Object[][] {\n+                {\"\/Customers\/following::*\", 0},\n+                {\"\/Customers\/Customer\/following::*\", 30},\n+                {\"\/Customers\/Customer\/following::Customer\", 2},\n+                {\"\/Customers\/Customer\/following::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/Name\/following::*\", 38},\n+                {\"\/Customers\/Customer\/Address\/following::*\", 32},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following::*\", 2},\n+                {\"\/Customers\/foo:Customer\/foo:Name\/following::*\", 8},\n+                {\"\/Customers\/foo:Customer\/*[following::foo:Name]\", 0},\n+                {\"\/Customers\/foo:Customer\/*[not(following::foo:Name)]\", 6},\n+                {\"\/Customers\/following-sibling::*\", 0},\n+                {\"\/Customers\/Customer\/following-sibling::*\", 3},\n+                {\"\/Customers\/Customer\/following-sibling::Customer\", 2},\n+                {\"\/Customers\/Customer\/following-sibling::foo:Customer\", 1},\n+                {\"\/Customers\/Customer[@id='x1']\/Name\/following-sibling::*\", 5},\n+                {\"\/Customers\/Customer\/Address\/following-sibling::*\", 6},\n+                {\"\/Customers\/Customer[@id='x1']\/Address\/following-sibling::*\", 2},\n+                {\"\/Customers\/foo:Customer\/foo:Address\/following-sibling::*\", 2},\n+                {\"\/Customers\/Customer[@id = 'x1']\/*[following-sibling::Street]\", 0},\n+                {\"\/Customers\/foo:Customer\/*[following-sibling::foo:Address]\", 3},\n+                {\"\/Customers\/foo:Customer\/*[not(following-sibling::foo:Address)]\", 3}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider: provides XPath following expressions which should not return any node.\n+     *\/\n+    @DataProvider(name = \"followingXpathEmpty\")\n+    public Object[][] getFollowingXpathExpressionEmpty() {\n+        return new Object[][] {\n+                {\"\/Customers\/following::*\"},\n+                {\"\/Customers\/foo:Customer\/following::*\"},\n+                {\"\/Customers\/Customer[@id = 'x3' ]\/following::Customer\"},\n+                {\"\/Customers\/following::id\"},\n+                {\"\/Customers\/Customer[@id = 'x3' ]\/following-sibling::Customer\"},\n+                {\"\/Customers\/foo:Customer\/following-sibling::*\"},\n+                {\"\/Customers\/Customer\/following-sibling::foo:Name\"},\n+                {\"\/Customers\/following-sibling::id\"}\n+        };\n+    }\n+\n+    \/**\n+     * Verifies Axis following xpath expression returns same nodes as returns when used normal xpath expression\n+     * @param  descexp  Axis following XPath expression.\n+     * @param  expath   normal xPath expression\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"followingXpath\")\n+    public void followingExpTests(String descexp, String expath) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList actualNodeList = (NodeList) xPath.evaluate(descexp, doc, XPathConstants.NODESET);\n+        NodeList expectedNodeList = (NodeList) xPath.evaluate(expath, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(actualNodeList.getLength(), expectedNodeList.getLength());\n+\n+        for(int i = 0; i < actualNodeList.getLength(); i++) {\n+            actualNodeList.item(i).equals(expectedNodeList.item(i));\n+        }\n+    }\n+\n+    \/**\n+     * Verifies following xpath expression return following nodes list with correct number of nodes.\n+     * @param  exp       XPath expression.\n+     * @param  nodeCount number of following nodes in nodelist.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"followingXpathNodeCount\")\n+    public void followingNodesCountTests(String exp, int nodeCount) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        NodeList nodeList = (NodeList) xPath.evaluate(exp, doc, XPathConstants.NODESET);\n+        Assert.assertEquals(nodeList.getLength(), nodeCount);\n+    }\n+\n+    \/**\n+     * Verifies following xpath expression return no nodes if following expression context nodes don't have matching following elements.\n+     * @param  exp     XPath expression.\n+     * @throws XPathExpressionException\n+     *\/\n+    @Test(dataProvider = \"followingXpathEmpty\")\n+    public void FollowingScopeTests(String exp) throws XPathExpressionException {\n+        Document doc = documentOf(DECLARATION + RAW_XML);\n+        XPath xPath = XPathFactory.newInstance().newXPath();\n+        Node node = xPath.evaluateExpression(exp, doc, Node.class);\n+        Assert.assertNull(node);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/xpath\/XPathExpFollowingTest.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+java\/lang\/Float\/Binary16Conversion.java 8295351 generic-x64\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-java\/awt\/TrayIcon\/ActionEventMask\/ActionEventMask.java 8150540 windows-all\n+java\/awt\/TrayIcon\/ActionEventMask\/ActionEventMask.java 8150540,8295300 windows-all,linux-all\n@@ -198,6 +198,6 @@\n-java\/awt\/TrayIcon\/ModalityTest\/ModalityTest.java 8150540 windows-all,macosx-all\n-java\/awt\/TrayIcon\/MouseEventMask\/MouseEventMaskTest.java 8150540 windows-all\n-java\/awt\/TrayIcon\/MouseMovedTest\/MouseMovedTest.java 8150540 windows-all\n-java\/awt\/TrayIcon\/SecurityCheck\/FunctionalityCheck\/FunctionalityCheck.java 8150540 windows-all\n-java\/awt\/TrayIcon\/TrayIconEventModifiers\/TrayIconEventModifiersTest.java 8150540 windows-all\n-java\/awt\/TrayIcon\/TrayIconEvents\/TrayIconEventsTest.java 8150540 windows-all\n+java\/awt\/TrayIcon\/ModalityTest\/ModalityTest.java 8150540,8295300 windows-all,macosx-all,linux-all\n+java\/awt\/TrayIcon\/MouseEventMask\/MouseEventMaskTest.java 8150540,8295300 windows-all,linux-all\n+java\/awt\/TrayIcon\/MouseMovedTest\/MouseMovedTest.java 8150540,8295300 windows-all,linux-all\n+java\/awt\/TrayIcon\/SecurityCheck\/FunctionalityCheck\/FunctionalityCheck.java 8150540,8295300 windows-all,linux-all\n+java\/awt\/TrayIcon\/TrayIconEventModifiers\/TrayIconEventModifiersTest.java 8150540,8295300 windows-all,linux-all\n+java\/awt\/TrayIcon\/TrayIconEvents\/TrayIconEventsTest.java 8150540,8295300 windows-all,linux-all\n@@ -510,1 +510,0 @@\n-java\/io\/BufferedInputStream\/TransferTo.java                     8294541 generic-all\n@@ -620,1 +619,0 @@\n-sun\/security\/ssl\/SSLSessionImpl\/NoInvalidateSocketException.java 8277970 linux-all,macosx-x64\n@@ -667,1 +665,1 @@\n-javax\/swing\/plaf\/aqua\/CustomComboBoxFocusTest.java 8294254 macosx-all\n+javax\/swing\/JRadioButton\/4314194\/bug4314194.java 8295006 linux-all\n@@ -752,1 +750,0 @@\n-jdk\/jfr\/event\/runtime\/TestActiveSettingEvent.java               8287832 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -622,2 +622,1 @@\n-    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java \\\n-    sun\/security\/tools\/keytool\/i18n.java\n+    sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java\n@@ -627,1 +626,2 @@\n-    java\/util\/TimeZone\/DefaultTimeZoneTest.java\n+    java\/util\/TimeZone\/DefaultTimeZoneTest.java \\\n+    sun\/security\/tools\/keytool\/i18n.java\n","filename":"test\/jdk\/TEST.groups","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+        String hashAlgorithm = null; \/\/ TLS1.2+ only\n@@ -97,0 +98,2 @@\n+            } else if (line.startsWith(\"km-hashalg:\")) {\n+                hashAlgorithm = data;\n@@ -122,1 +125,3 @@\n-                    KeyGenerator.getInstance(\"SunTlsKeyMaterial\", provider);\n+                        KeyGenerator.getInstance(minor == 3 ?\n+                                \"SunTls12KeyMaterial\" :\n+                                \"SunTlsKeyMaterial\", provider);\n@@ -125,0 +130,20 @@\n+                int prfHashLength, prfBlockSize;\n+\n+                if (hashAlgorithm != null) {\n+                    switch (hashAlgorithm) {\n+                        case \"SHA-256\":\n+                            prfHashLength = 32;\n+                            prfBlockSize = 64;\n+                            break;\n+                        case \"SHA-384\":\n+                            prfHashLength = 48;\n+                            prfBlockSize = 128;\n+                            break;\n+                        default:\n+                            throw new RuntimeException(\"Unexpected hashalg: \" +\n+                                    hashAlgorithm);\n+                    }\n+                } else {\n+                    prfHashLength = -1;\n+                    prfBlockSize = -1;\n+                }\n@@ -129,1 +154,1 @@\n-                        null, -1, -1);\n+                        hashAlgorithm, prfHashLength, prfBlockSize);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/TLS\/TestKeyMaterial.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -3649,0 +3649,34 @@\n+km-master:  f1:05:15:45:33:be:50:d6:88:0b:03:bb:88:9b:ef:d4:3b:98:aa:40:13:71:3c:1c:d9:df:34:c7:50:75:ad:5c:0a:d4:fe:ed:d5:58:6b:ff:2b:ce:c6:12:bc:6b:7e:dc\n+km-major:   3\n+km-minor:   3\n+km-crandom: 42:f3:36:8e:9d:c9:69:3e:c1:8a:38:d3:e0:ec:2b:58:c2:e0:0c:de:4f:f3:af:51:d2:5c:bc:b2:c3:3b:1e:56\n+km-srandom: 42:f3:36:8e:fa:fd:23:3e:fd:f9:bc:88:3c:98:93:f3:c3:1d:9c:2a:4a:3b:02:a7:40:d4:64:04:59:e9:65:97\n+km-cipalg:  AES\n+km-hashalg: SHA-256\n+km-keylen:  16\n+km-explen:  0\n+km-ivlen:   4\n+km-maclen:  0\n+km-ccipkey: 60:7a:45:a9:6e:76:58:ea:d9:44:c5:25:f8:92:f1:26\n+km-scipkey: 42:c0:ed:75:a2:51:21:7c:50:74:9d:78:9a:f7:35:2b\n+km-civ:     a1:3c:3e:4a\n+km-siv:     85:ab:ee:70\n+km-cmackey: (null)\n+km-smackey: (null)\n+km-master:  f1:05:15:45:33:be:50:d6:88:0b:03:bb:88:9b:ef:d4:3b:98:aa:40:13:71:3c:1c:d9:df:34:c7:50:75:ad:5c:0a:d4:fe:ed:d5:58:6b:ff:2b:ce:c6:12:bc:6b:7e:dc\n+km-major:   3\n+km-minor:   3\n+km-crandom: 42:f3:36:8e:9d:c9:69:3e:c1:8a:38:d3:e0:ec:2b:58:c2:e0:0c:de:4f:f3:af:51:d2:5c:bc:b2:c3:3b:1e:56\n+km-srandom: 42:f3:36:8e:fa:fd:23:3e:fd:f9:bc:88:3c:98:93:f3:c3:1d:9c:2a:4a:3b:02:a7:40:d4:64:04:59:e9:65:97\n+km-cipalg:  AES\n+km-hashalg: SHA-384\n+km-keylen:  32\n+km-explen:  0\n+km-ivlen:   4\n+km-maclen:  0\n+km-ccipkey: 3c:03:17:61:1e:88:4a:aa:01:4c:ac:6c:f8:bb:91:c3:0e:ec:57:c7:bf:07:ff:eb:49:22:f9:80:12:64:72:2a\n+km-scipkey: f8:00:8e:b2:dc:25:98:f1:97:00:55:28:60:a3:65:da:42:89:18:bb:40:94:53:d2:75:2a:29:e5:aa:94:1d:7a\n+km-civ:     24:02:76:6f\n+km-siv:     3b:6d:33:5a\n+km-cmackey: (null)\n+km-smackey: (null)\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/TLS\/keymatdata.txt","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6777156\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"linux\")\n+ * @summary Verifies if user is not able to select \"..\/\" beyond\n+ * root file system.\n+ * @run main\/manual TestFileChooserDirectorySelection\n+ *\/\n+\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+public class TestFileChooserDirectorySelection {\n+    private static JFrame frame;\n+    private static final String INSTRUCTIONS =\n+            \"Double click on the \\\"..\/\\\" entry from directory list.\\n\\n\" +\n+            \"Repeat the same process till the current directory is root \" +\n+            \"i.e \\\" \/ \\\" .\\n\\n\" +\n+            \"If \\\" ..\/ \\\" option is not available at root directory\" +\n+            \", press Pass else Fail.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\n+                \"JFileChooser Test Instructions\", INSTRUCTIONS, 5, 8, 35);\n+        try {\n+            SwingUtilities.invokeAndWait(\n+                    TestFileChooserDirectorySelection::createAndShowUI);\n+            passFailJFrame.awaitAndCheck();\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Test File Chooser Directory Selection\");\n+        JFileChooser fileChooser = new JFileChooser();\n+        fileChooser.setControlButtonsAreShown(false);\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(\n+                frame, PassFailJFrame.Position.HORIZONTAL);\n+        frame.add(fileChooser);\n+        frame.setSize(500, 500);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/java\/swing\/plaf\/gtk\/TestFileChooserDirectorySelection.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -108,0 +108,9 @@\n+\n+        \/\/ Do a short delay to make sure that the debug agent is done processing all\n+        \/\/ ClassPrepare events. Otherwise the debug agent might still be holding on to\n+        \/\/ a reference to a class, which will prevent it from unloading during the GC.\n+        try {\n+            Thread.sleep(5000);\n+        } catch (InterruptedException e) {\n+        }\n+\n@@ -111,2 +120,2 @@\n-        \/\/ Short delay to make sure all ClassUnloadEvents have been sent\n-        \/\/ before VMDeathEvent is genareated.\n+        \/\/ Do a short delay to make sure all ClassUnloadEvents have been sent\n+        \/\/ before VMDeathEvent is generated.\n","filename":"test\/jdk\/com\/sun\/jdi\/ClassUnloadEventTest.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import javax.naming.NamingException;\n+import javax.naming.Reference;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.InitialDirContext;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.SocketAddress;\n+import java.util.Hashtable;\n+\n+\/*\n+ * @test\n+ * @bug 8290368\n+ * @summary Checks if LDAP specific objects factory filter system and security\n+ *  properties can be used to restrict usage of object factories during\n+ *  LDAP lookup operations.\n+ * @modules java.naming\/com.sun.jndi.ldap\n+ * @library \/test\/lib ..\/..\/lib \/javax\/naming\/module\/src\/test\/test\/\n+ * @build LDAPServer LDAPTestUtils TestFactory\n+ *\n+ * @run main\/othervm LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=*\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.**;!*\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.test.**;!*\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.test.*;!*\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.test.Test*;!*\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=!com.test.**\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=!com.test.TestFactory;com.**\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=!com.test.TestFactory;com.test.*\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=!com.test.Test*\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.*;!*\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.test.TestFactor;!*\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.test.TestFactoryy;!*\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/disallowLdapFilter.props\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/disallowLdapFilter.props\n+ *                   -Djdk.jndi.ldap.object.factoriesFilter=com.test.TestFactory\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowLdapFilter.props\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowLdapFilter.props\n+ *                   -Djdk.jndi.rmi.object.factoriesFilter=!com.test.TestFactory\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowLdapFilter.props\n+ *                   -Djdk.jndi.ldap.object.factoriesFilter=!com.test.TestFactory\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=.*\n+ *                   LdapFactoriesFilterTest false false\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=*\n+ *                   -Djdk.jndi.object.factoriesFilter=.*\n+ *                   LdapFactoriesFilterTest false false\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=*\n+ *                   -Djdk.jndi.object.factoriesFilter=*\n+ *                   -Djdk.jndi.rmi.object.factoriesFilter=.*\n+ *                   LdapFactoriesFilterTest true true\n+ *\/\n+\n+public class LdapFactoriesFilterTest {\n+    public static void main(String[] args) throws Exception {\n+\n+        boolean testFactoryAllowed = Boolean.parseBoolean(args[0]);\n+        boolean ldapAndGlobalFiltersValid =\n+                Boolean.parseBoolean(args[1]);\n+\n+        \/\/ Create unbound server socket\n+        ServerSocket serverSocket = new ServerSocket();\n+        try (serverSocket) {\n+            \/\/ Bind it to the loopback address\n+            SocketAddress sockAddr = new InetSocketAddress(\n+                    InetAddress.getLoopbackAddress(), 0);\n+            serverSocket.bind(sockAddr);\n+\n+            \/\/ Construct the provider URL for LDAPTestUtils\n+            String providerURL = URIBuilder.newBuilder()\n+                    .scheme(\"ldap\")\n+                    .loopback()\n+                    .port(serverSocket.getLocalPort())\n+                    .buildUnchecked().toString();\n+\n+            \/\/ Create and initialize test environment variables\n+            Hashtable<Object, Object> env;\n+            env = LDAPTestUtils.initEnv(serverSocket, providerURL,\n+                    LdapFactoriesFilterTest.class.getName(), args, false);\n+            DirContext ctx = new InitialDirContext(env);\n+            Exception observedException = null;\n+            Object lookupRes = null;\n+\n+            \/\/ Lookup bound reference\n+            try {\n+                lookupRes = ctx.lookup(\"Example\");\n+                System.err.println(\"Lookup results: \" + lookupRes.getClass().getCanonicalName());\n+            } catch (Exception ex) {\n+                observedException = ex;\n+            }\n+\n+            \/\/ Check lookup operation results\n+            if (testFactoryAllowed) {\n+                \/\/ NamingException with RuntimeException cause is expected here\n+                if (observedException instanceof NamingException namingException) {\n+                    System.err.println(\"Observed NamingException: \" + observedException);\n+                    Throwable cause = namingException.getCause();\n+                    System.err.println(\"NamingException cause: \" + cause);\n+                    \/\/ We expect RuntimeException from factory for cases when LDAP factory\n+                    \/\/ filter allows the test factory\n+                    if (cause instanceof RuntimeException rte) {\n+                        String rteMessage = rte.getMessage();\n+                        System.err.println(\"RuntimeException message: \" + rteMessage);\n+                        if (!com.test.TestFactory.RUNTIME_EXCEPTION_MESSAGE.equals(rteMessage)) {\n+                            throw new AssertionError(\n+                                    \"Unexpected RuntimeException message observed\");\n+                        }\n+                    } else {\n+                        throw new AssertionError(\n+                                \"RuntimeException is expected to be thrown\" +\n+                                            \" by the test object factory\");\n+                    }\n+                } else {\n+                    throw new AssertionError(\n+                            \"NamingException was not thrown as expected\");\n+                }\n+            } else if (!ldapAndGlobalFiltersValid) {\n+                \/\/ If LDAP or GLOBAL factories filter are not properly formatted we're expecting to\n+                \/\/ get NamingException with IllegalArgumentException set as a cause that contains\n+                \/\/ formatting error message.\n+                \/\/ If RMI filter is not properly formatted we're not expecting IAE here since\n+                \/\/ this test only performing LDAP lookups\n+                if (observedException instanceof NamingException ne) {\n+                    if (ne.getCause() instanceof IllegalArgumentException iae) {\n+                        \/\/ All tests with malformed filters contain wildcards with\n+                        \/\/ package name missing, therefore the message is expected\n+                        \/\/ to start with \"package missing in:\"\n+                        System.err.println(\"Found expected exception: \" + iae);\n+                    } else {\n+                        throw new AssertionError(\"IllegalArgumentException\" +\n+                                \" is expected for malformed filter values\");\n+                    }\n+                }\n+            } else {\n+                \/\/ Object factory is not allowed by the factories filter\n+                \/\/ we expect reference here\n+                if (lookupRes instanceof Reference ref) {\n+                    System.err.println(\"Lookup result is a reference: \" +\n+                            ref.getFactoryClassLocation() + \" \" + ref.getFactoryClassName());\n+                } else {\n+                    new AssertionError(\"Reference was not returned as a lookup result\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/objects\/factory\/LdapFactoriesFilterTest.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+################################################################################\n+# Capture file for LdapFactoriesFilterTest.java\n+#\n+# NOTE: This hexadecimal dump of LDAP protocol messages was generated by\n+#       running the LdapFactoriesFilterTest application program against a real\n+#       LDAP server and setting the JNDI\/LDAP environment property:\n+#       com.sun.jndi.ldap.trace.ber to activate LDAP message tracing.\n+#\n+################################################################################\n+\n+# LDAP BindRequest\n+0000: 30 0C 02 01 01 60 07 02   01 03 04 00 80 00        0....`........\n+\n+# LDAP BindResponse\n+0000: 30 0C 02 01 01 61 07 0A   01 00 04 00 04 00        0....a........\n+\n+# LDAP SearchRequest\n+0000: 30 49 02 01 02 63 27 04   07 45 78 61 6D 70 6C 65  0I...c'..Example\n+0010: 0A 01 00 0A 01 03 02 01   00 02 01 00 01 01 00 87  ................\n+0020: 0B 6F 62 6A 65 63 74 43   6C 61 73 73 30 00 A0 1B  .objectClass0...\n+0030: 30 19 04 17 32 2E 31 36   2E 38 34 30 2E 31 2E 31  0...2.16.840.1.1\n+0040: 31 33 37 33 30 2E 33 2E   34 2E 32                 13730.3.4.2\n+\n+# LDAP SearchResultEntry\n+0000: 30 75 02 01 02 64 70 04   07 45 78 61 6D 70 6C 65  0u...dp..Example\n+0010: 30 65 30 16 04 0D 6A 61   76 61 43 6C 61 73 73 4E  0e0...javaClassN\n+0020: 61 6D 65 31 05 04 03 66   6F 6F 30 24 04 0B 6F 62  ame1...foo0$..ob\n+0030: 6A 65 63 74 43 6C 61 73   73 31 15 04 13 6A 61 76  jectClass1...jav\n+0040: 61 4E 61 6D 69 6E 67 52   65 66 65 72 65 6E 63 65  aNamingReference\n+0050: 30 25 04 0B 6A 61 76 61   46 61 63 74 6F 72 79 31  0%..javaFactory1\n+0060: 16 04 14 63 6F 6D 2E 74   65 73 74 2E 54 65 73 74  ...com.test.Test\n+0070: 46 61 63 74 6F 72 79                               Factory\n+\n+# LDAP SearchResultDone\n+0000: 30 0C 02 01 02 65 07 0A   01 00 04 00 04 00        0....e........\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/objects\/factory\/LdapFactoriesFilterTest.ldap","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.test;\n+\n+import javax.naming.Context;\n+import javax.naming.Name;\n+import javax.naming.spi.ObjectFactory;\n+import java.util.Hashtable;\n+\n+public class TestFactory implements ObjectFactory {\n+    public static final String RUNTIME_EXCEPTION_MESSAGE =\n+            \"Test object factory is called to instantiate factory\";\n+\n+    @Override\n+    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws Exception {\n+        System.err.println(\"obj:\" + obj);\n+        throw new RuntimeException(RUNTIME_EXCEPTION_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/objects\/factory\/TestFactory.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+jdk.jndi.ldap.object.factoriesFilter=com.test.TestFactory;!*\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/objects\/factory\/allowLdapFilter.props","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+jdk.jndi.ldap.object.factoriesFilter=!com.test.TestFactory\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/objects\/factory\/disallowLdapFilter.props","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+import javax.naming.NamingException;\n+import javax.naming.Reference;\n+import java.rmi.RemoteException;\n+import java.rmi.registry.Registry;\n+import java.util.Hashtable;\n+\n+\/*\n+ * @test\n+ * @bug 8290368\n+ * @summary Checks if RMI specific objects factory filter system and security\n+ *  properties can be used to restrict usage of object factories during\n+ *  RMI lookup operations.\n+ * @modules java.rmi\/sun.rmi.registry\n+ *          java.rmi\/sun.rmi.server\n+ *          java.rmi\/sun.rmi.transport\n+ *          java.rmi\/sun.rmi.transport.tcp\n+ * @library ..\/..\/..\/..\/..\/..\/java\/rmi\/testlibrary\n+ * @build TestLibrary\n+ * @compile TestFactory.java\n+ *\n+ * @run main\/othervm RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=*\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.**;!*\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.test.**;!*\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.test.*;!*\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.test.Test*;!*\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=!com.test.**\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=!com.test.TestFactory;com.**\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=!com.test.TestFactory;com.test.*\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=!com.test.Test*\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.*;!*\n+ *                    RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.test.TestFactor;!*\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.test.TestFactoryy;!*\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/disallowRmiFilter.props\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/disallowRmiFilter.props\n+ *                   -Djdk.jndi.rmi.object.factoriesFilter=com.test.TestFactory\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowRmiFilter.props\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowRmiFilter.props\n+ *                   -Djdk.jndi.ldap.object.factoriesFilter=!com.test.TestFactory\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowRmiFilter.props\n+ *                   -Djdk.jndi.rmi.object.factoriesFilter=!com.test.TestFactory\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=.*\n+ *                   RmiFactoriesFilterTest false false\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=*\n+ *                   -Djdk.jndi.object.factoriesFilter=.*\n+ *                   RmiFactoriesFilterTest false false\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=*\n+ *                   -Djdk.jndi.object.factoriesFilter=*\n+ *                   -Djdk.jndi.ldap.object.factoriesFilter=.*\n+ *                   RmiFactoriesFilterTest true true\n+ *\/\n+\n+public class RmiFactoriesFilterTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean classExpectedToLoad = Boolean.parseBoolean(args[0]);\n+        boolean rmiAndGlobalFiltersValid =\n+                Boolean.parseBoolean(args[1]);\n+        int registryPort;\n+        try {\n+            Registry registry = TestLibrary.createRegistryOnEphemeralPort();\n+            registryPort = TestLibrary.getRegistryPort(registry);\n+            System.out.println(\"Registry port: \" + registryPort);\n+        } catch (RemoteException re) {\n+            throw new RuntimeException(\"Failed to create registry\", re);\n+        }\n+\n+        Context context = getInitialContext(registryPort);\n+        \/\/ Bind the Reference object\n+        Reference ref = new Reference(\"TestObject\", \"com.test.TestFactory\",\n+                null);\n+        context.bind(\"objectTest\", ref);\n+\n+        loadUsingFactoryFromTCCL(registryPort, classExpectedToLoad, rmiAndGlobalFiltersValid);\n+        if (!rmiAndGlobalFiltersValid) {\n+            \/\/ Check that IAE is set as NamingException cause for malformed RMI or GLOBAL\n+            \/\/ filter values when lookup is called for the second time\n+            loadUsingFactoryFromTCCL(registryPort, classExpectedToLoad, false);\n+        }\n+    }\n+\n+    private static Context getInitialContext(int port) throws NamingException {\n+        Hashtable<String, String> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY,\n+                \"com.sun.jndi.rmi.registry.RegistryContextFactory\");\n+        env.put(Context.PROVIDER_URL, \"rmi:\/\/127.0.0.1:\" + port);\n+        return new InitialContext(env);\n+    }\n+\n+    private static void loadUsingFactoryFromTCCL(int registryPort,\n+                                                 boolean classExpectedToLoad,\n+                                                 boolean rmiAndGlobalFiltersValid) {\n+\n+\n+        try {\n+            Context context = getInitialContext(registryPort);\n+            Object object = context.lookup(\"objectTest\");\n+            System.out.println(\"Number of getObjectInstance calls:\" +\n+                    com.test.TestFactory.getNumberOfGetInstanceCalls());\n+            System.out.println(\"Loaded class type:\" + object.getClass().getCanonicalName());\n+            System.out.println(\"Loaded class: \" + object);\n+            if (classExpectedToLoad) {\n+                if (!\"TestObject\".equals(object)) {\n+                    throw new AssertionError(\"Class was expected to get loaded by the factory\");\n+                }\n+            } else {\n+                if (\"TestObject\".equals(object)) {\n+                    throw new AssertionError(\"Class was unexpectedly loaded by the factory\");\n+                }\n+            }\n+        } catch (NamingException ne) {\n+            \/\/ Only expecting NamingException for cases when RMI or GLOBAL filters are malformed\n+            if (rmiAndGlobalFiltersValid) {\n+                throw new AssertionError(\"Unexpected NamingException observed\", ne);\n+            }\n+            if (ne.getCause() instanceof IllegalArgumentException iae) {\n+                \/\/ All tests with malformed filters contain wildcards with\n+                \/\/ package name missing, therefore the message is expected\n+                \/\/ to start with \"package missing in:\"\n+                System.err.println(\"Found expected exception: \" + iae);\n+            } else {\n+                throw new AssertionError(\"IllegalArgument exception\" +\n+                        \" is expected for malformed filter values\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/rmi\/registry\/objects\/RmiFactoriesFilterTest.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.test;\n+\n+import javax.naming.Context;\n+import javax.naming.Name;\n+import javax.naming.Reference;\n+import javax.naming.spi.ObjectFactory;\n+import java.util.Hashtable;\n+\n+public class TestFactory implements ObjectFactory {\n+\n+    \/**\n+     * Get the number of {@code TestFactory.getObjectInstance} calls\n+     *\n+     * @return the number of calls\n+     *\/\n+    public static int getNumberOfGetInstanceCalls() {\n+        return timesGetInstanceCalled;\n+    }\n+\n+    \/**\n+     * @param obj         The possibly null object containing location or reference\n+     *                    information that can be used in creating an object.\n+     * @param name        The name of this object relative to {@code nameCtx},\n+     *                    or null if no name is specified.\n+     * @param nameCtx     The context relative to which the {@code name}\n+     *                    parameter is specified, or null if {@code name} is\n+     *                    relative to the default initial context.\n+     * @param environment The possibly null environment that is used in\n+     *                    creating the object.\n+     * @return If specified object is a {@code Reference} returns a {@code String} with a class\n+     * name specified in the reference, otherwise returns {@code \"TestObj\"}\n+     * @throws Exception\n+     *\/\n+    @Override\n+    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws Exception {\n+        timesGetInstanceCalled++;\n+        String loadedObject;\n+        if (obj instanceof Reference) {\n+            Reference r = (Reference) obj;\n+            System.err.println(\"TestFactory: loading javax.naming.Reference:\");\n+            System.err.println(\"\\tFactory location=\" + r.getFactoryClassLocation());\n+            System.err.println(\"\\tFactory class name=\" + r.getFactoryClassName());\n+            System.err.println(\"\\tClass name=\" + r.getClassName());\n+            loadedObject = r.getClassName();\n+        } else {\n+            System.err.println(\"TestFactory: loading \" + obj.getClass().getName());\n+            loadedObject = \"TestObj\";\n+        }\n+        return loadedObject;\n+    }\n+\n+    private static volatile int timesGetInstanceCalled;\n+}\n+\n","filename":"test\/jdk\/com\/sun\/jndi\/rmi\/registry\/objects\/TestFactory.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+jdk.jndi.rmi.object.factoriesFilter=com.test.TestFactory;!*\n","filename":"test\/jdk\/com\/sun\/jndi\/rmi\/registry\/objects\/allowRmiFilter.props","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+jdk.jndi.rmi.object.factoriesFilter=!com.test.TestFactory;*\n","filename":"test\/jdk\/com\/sun\/jndi\/rmi\/registry\/objects\/disallowRmiFilter.props","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @run main\/othervm -Dsun.net.httpserver.maxReqTime=2 Test\n- * @run main\/othervm -Djava.net.preferIPv6Addresses=true -Dsun.net.httpserver.maxReqTime=2 Test\n+ * @run main\/othervm -Dsun.net.httpserver.maxReqTime=2 -Dsun.net.httpserver.clockTick=2000 Test\n+ * @run main\/othervm -Djava.net.preferIPv6Addresses=true -Dsun.net.httpserver.maxReqTime=2 -Dsun.net.httpserver.clockTick=2000 Test\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/6725892\/Test.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8294426\n+ * @summary The test verifies that a press {@link java.awt.event.MouseEvent} contains correct modifiers although the according native mouse event is accompanied by no mouse modifiers.\n+ * @author Nikita.Provotorov@jetbrains.com\n+ *\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ *\n+ * @modules java.desktop\/java.awt:open java.desktop\/sun.lwawt:open java.desktop\/sun.lwawt.macosx:+open\n+ * @run main\/othervm MouseMacTouchPressEventModifiers\n+ *\/\n+\n+import sun.lwawt.macosx.CocoaConstants;\n+import sun.lwawt.macosx.LWCToolkit;\n+\n+import javax.swing.*;\n+import java.awt.*;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\n+\/**\n+ * Sometimes native mouse events aren't accompanied by the correct mouse modifiers, i.e.\n+ *  {@link sun.lwawt.macosx.NSEvent#nsToJavaModifiers} returns 0 inside\n+ *  {@link sun.lwawt.macosx.CPlatformResponder#handleMouseEvent(int, int, int, int, int, int, int, int)}.\n+ * E.g. the situation above happens when a user taps (NOT clicks) on a trackpad on a M2 MacBooks while\n+ *  System Preferences -> Trackpad -> Tap to click is turned on.\n+ * The test emulates the situation via a direct invocation of\n+ *  {@link sun.lwawt.macosx.CPlatformResponder#handleMouseEvent(int, int, int, int, int, int, int, int)};\n+ *  unfortunately it's impossible to use {@link java.awt.Robot} because its mouse press events ARE accompanied\n+ *  by the correct modifiers ({@link sun.lwawt.macosx.NSEvent#nsToJavaModifiers} returns correct values).\n+ *\/\n+public class MouseMacTouchPressEventModifiers\n+{\n+    \/**\n+     * How it works:\n+     * 1. Send a native mouse press to {@code frame} via\n+     *    {@link sun.lwawt.macosx.CPlatformResponder#handleMouseEvent(int, int, int, int, int, int, int, int)}\n+     *    (using reflection).\n+     * 2. Wait (via {@link Future#get()}) until it generates a usual java MouseEvent\n+     *    and dispatches it to the MouseListener of the {@code frame}.\n+     * 3. Verify the dispatched MouseEvent contains correct modifiers, modifiersEx and button number.\n+     * 4. Do all the steps above but for a corresponding mouse release.\n+     *\/\n+    public static void main(String[] args) throws Throwable {\n+        \/\/ TreeMap to preserve the testing order\n+        final var testCases = new TreeMap<>(Map.of(\n+            CocoaConstants.kCGMouseButtonLeft, new MouseEventFieldsToTest(MouseEvent.BUTTON1_MASK, MouseEvent.BUTTON1_DOWN_MASK, MouseEvent.BUTTON1),\n+            CocoaConstants.kCGMouseButtonRight, new MouseEventFieldsToTest(MouseEvent.BUTTON3_MASK, MouseEvent.BUTTON3_DOWN_MASK, MouseEvent.BUTTON3),\n+            CocoaConstants.kCGMouseButtonCenter, new MouseEventFieldsToTest(MouseEvent.BUTTON2_MASK, MouseEvent.BUTTON2_DOWN_MASK, MouseEvent.BUTTON2)\n+        ));\n+\n+        SwingUtilities.invokeAndWait(MouseMacTouchPressEventModifiers::createAndShowGUI);\n+\n+        try {\n+            for (var testCase : testCases.entrySet()) {\n+                final var fieldsToTest = testCase.getValue();\n+\n+                final int mouseX = (frame.getWidth() - 1) \/ 2;\n+                final int mouseY = (frame.getHeight() - 1) \/ 2;\n+\n+                \/\/ press\n+\n+                MouseEvent event = frame.sendNativeMousePress(\n+                    0,\n+                    testCase.getKey(),\n+                    1,\n+                    mouseX,\n+                    mouseY\n+                ).get(500, TimeUnit.MILLISECONDS);\n+                System.out.println(\"A mouse press turned into: \" + event);\n+\n+                frame.checkInternalErrors();\n+\n+                checkMouseEvent(event,\n+                    MouseEvent.MOUSE_PRESSED, fieldsToTest.modifiers, fieldsToTest.pressModifiersEx, fieldsToTest.button);\n+\n+                \/\/ release\n+\n+                event = frame.sendNativeMouseRelease(\n+                    0,\n+                    testCase.getKey(),\n+                    1,\n+                    mouseX,\n+                    mouseY\n+                ).get(500, TimeUnit.MILLISECONDS);\n+                System.out.println(\"A mouse release turned into: \" + event);\n+\n+                frame.checkInternalErrors();\n+\n+                checkMouseEvent(event,\n+                    MouseEvent.MOUSE_RELEASED, fieldsToTest.modifiers, 0, fieldsToTest.button);\n+\n+                System.out.println();\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(MouseMacTouchPressEventModifiers::disposeGUI);\n+            System.out.flush();\n+        }\n+    }\n+\n+\n+    private record MouseEventFieldsToTest(int modifiers, int pressModifiersEx, int button) {}\n+\n+    private static MyFrame frame;\n+\n+    private static void createAndShowGUI() {\n+        frame = new MyFrame();\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+\n+        frame.pack();\n+        frame.setSize(800, 500);\n+\n+        frame.setLocationRelativeTo(null);\n+        frame.setAlwaysOnTop(true);\n+\n+        frame.setVisible(true);\n+    }\n+\n+    private static void disposeGUI() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+\n+    private static void checkMouseEvent(MouseEvent me,\n+        int expectedId, int expectedModifiers, int expectedModifiersEx, int expectedButton\n+    ) {\n+        boolean wrong = false;\n+\n+        final var errMsg = new StringBuilder(1024);\n+        errMsg.append(\"Wrong MouseEvent \").append(me).append(':');\n+\n+        if (me.getID() != expectedId) {\n+            errMsg.append(\"\\n  eventId: expected <\").append(expectedId).append(\">, actual <\").append(me.getID()).append('>');\n+            wrong = true;\n+        }\n+        if (me.getModifiers() != expectedModifiers) {\n+            errMsg.append(\"\\n  modifiers: expected <\").append(expectedModifiers).append(\">, actual <\").append(me.getModifiers()).append('>');\n+            wrong = true;\n+        }\n+        if (me.getModifiersEx() != expectedModifiersEx) {\n+            errMsg.append(\"\\n  modifiersEx: expected <\").append(expectedModifiersEx).append(\">, actual <\").append(me.getModifiersEx()).append('>');\n+            wrong = true;\n+        }\n+        if (me.getButton() != expectedButton) {\n+            errMsg.append(\"\\n  button: expected <\").append(expectedButton).append(\">, actual <\").append(me.getButton()).append('>');\n+            wrong = true;\n+        }\n+\n+        if (wrong) {\n+            throw new IllegalArgumentException(errMsg.append('\\n').toString());\n+        }\n+    }\n+}\n+\n+\n+class MyFrame extends JFrame {\n+    public MyFrame() {\n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mousePressed(MouseEvent e) {\n+                System.out.println(\"MyFrame::mousePressed: \" + e);\n+                keepPromiseVia(e);\n+            }\n+\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                System.out.println(\"MyFrame::mouseReleased: \" + e);\n+                keepPromiseVia(e);\n+            }\n+        });\n+    }\n+\n+    public Future<MouseEvent> sendNativeMousePress(int modifierFlags, int buttonNumber, int clickCount, int x, int y) {\n+        final int eventType = (buttonNumber == CocoaConstants.kCGMouseButtonLeft) ? CocoaConstants.NSLeftMouseDown\n+                              : (buttonNumber == CocoaConstants.kCGMouseButtonRight) ? CocoaConstants.NSRightMouseDown\n+                              : CocoaConstants.NSOtherMouseDown;\n+\n+        return sendNativeMouseEvent(eventType, modifierFlags, buttonNumber, clickCount, x, y, getX() + x, getY() + y);\n+    }\n+\n+    public Future<MouseEvent> sendNativeMouseRelease(int modifierFlags, int buttonNumber, int clickCount, int x, int y) {\n+        final int eventType = (buttonNumber == CocoaConstants.kCGMouseButtonLeft) ? CocoaConstants.NSLeftMouseUp\n+                              : (buttonNumber == CocoaConstants.kCGMouseButtonRight) ? CocoaConstants.NSRightMouseUp\n+                              : CocoaConstants.NSOtherMouseUp;\n+\n+        return sendNativeMouseEvent(eventType, modifierFlags, buttonNumber, clickCount, x, y, getX() + x, getY() + y);\n+    }\n+\n+    public void checkInternalErrors() throws Throwable {\n+        final Throwable result = internalError.getAndSet(null);\n+        if (result != null) {\n+            throw result;\n+        }\n+    }\n+\n+\n+    private final AtomicReference<CompletableFuture<MouseEvent>> mouseEventPromise = new AtomicReference<>(null);\n+\n+    private final AtomicReference<Throwable> internalError = new AtomicReference<>(null);\n+\n+    private Future<MouseEvent> sendNativeMouseEvent(\n+        final int eventType,\n+        final int modifierFlags,\n+        final int buttonNumber,\n+        final int clickCount,\n+        final int x,\n+        final int y,\n+        final int absX,\n+        final int absY\n+    ) {\n+        assert !SwingUtilities.isEventDispatchThread();\n+        assert mouseEventPromise.get() == null : \"Trying to send a mouse event while there is already a processing one\";\n+\n+        final CompletableFuture<MouseEvent> result = new CompletableFuture<>();\n+\n+        SwingUtilities.invokeLater(() -> {\n+            try {\n+                LWCToolkit.invokeLater(() -> {\n+                    try {\n+                        final Object thisPlatformResponder = obtainFramePlatformResponder(this);\n+                        final Method thisPlatformResponderHandleMouseEventMethod = obtainHandleMouseEventMethod(thisPlatformResponder);\n+\n+                        if (mouseEventPromise.compareAndExchange(null, result) != null) {\n+                            throw new IllegalStateException(\"Trying to send a mouse event while there is already a processing one\");\n+                        }\n+\n+                        thisPlatformResponderHandleMouseEventMethod.invoke(thisPlatformResponder,\n+                            eventType, modifierFlags, buttonNumber, clickCount, x, y, absX, absY);\n+                    } catch (Throwable err) {\n+                        \/\/ Remove the promise if thisPlatformResponderHandleMouseEventMethod.invoke(...) failed\n+                        mouseEventPromise.compareAndExchange(result, null);\n+                        failPromiseDueTo(result, err);\n+                    }\n+                }, this);\n+            } catch (Throwable err) {\n+                failPromiseDueTo(result, err);\n+            }\n+        });\n+\n+        return result;\n+    }\n+\n+    \/** Wraps {@link CompletableFuture#complete(Object)} *\/\n+    private void keepPromiseVia(MouseEvent mouseEvent) {\n+        try {\n+            final CompletableFuture<MouseEvent> promise = mouseEventPromise.getAndSet(null);\n+            if (promise == null) {\n+                throw new IllegalStateException(\"The following unexpected MouseEvent has arrived: \" + mouseEvent);\n+            }\n+\n+            if (!promise.complete(mouseEvent)) {\n+                throw new IllegalStateException(\"The promise had already been completed when the following MouseEvent arrived: \" + mouseEvent);\n+            }\n+        } catch (Throwable err) {\n+            setInternalError(err);\n+        }\n+    }\n+\n+    \/** Wraps {@link CompletableFuture#completeExceptionally(Throwable)} *\/\n+    private void failPromiseDueTo(CompletableFuture<MouseEvent> promise, Throwable cause) {\n+        try {\n+            if (!promise.completeExceptionally(cause)) {\n+                throw new IllegalStateException(\"The promise had already been completed when the following error arrived: \" + cause);\n+            }\n+        } catch (Throwable err) {\n+            setInternalError(err);\n+        }\n+    }\n+\n+    private void setInternalError(Throwable err) {\n+        if (internalError.compareAndExchange(null, err) != null) {\n+            System.err.println(\"Failed to set the following internal error because there is another one: \" + err);\n+        }\n+    }\n+\n+    \/** Obtains {@code component.peer.platformWindow.responder} *\/\n+    private static Object obtainFramePlatformResponder(Component component) throws NoSuchFieldException, IllegalAccessException {\n+        final Object framePeer;\n+        {\n+            final var frameClass = Component.class;\n+            final var peerField = frameClass.getDeclaredField(\"peer\");\n+\n+            peerField.setAccessible(true);\n+\n+            framePeer = peerField.get(component);\n+        }\n+\n+        final Object peerPlatformWindow;\n+        {\n+            final var peerClass = framePeer.getClass();\n+            final var platformWindowField = peerClass.getDeclaredField(\"platformWindow\");\n+\n+            platformWindowField.setAccessible(true);\n+\n+            peerPlatformWindow = platformWindowField.get(framePeer);\n+        }\n+\n+        final Object platformWindowResponder;\n+        {\n+            final var peerPlatformWindowClass = peerPlatformWindow.getClass();\n+            final var platformWindowResponderField = peerPlatformWindowClass.getDeclaredField(\"responder\");\n+\n+            platformWindowResponderField.setAccessible(true);\n+\n+            platformWindowResponder = platformWindowResponderField.get(peerPlatformWindow);\n+        }\n+\n+        return platformWindowResponder;\n+    }\n+\n+    \/** Obtains {@link sun.lwawt.macosx.CPlatformResponder#handleMouseEvent(int, int, int, int, int, int, int, int)} *\/\n+    private static Method obtainHandleMouseEventMethod(final Object platformResponder) throws NoSuchMethodException {\n+        final var responderClass = platformResponder.getClass();\n+        final var handleMouseEventMethod = responderClass.getDeclaredMethod(\n+            \"handleMouseEvent\",\n+            int.class, int.class, int.class, int.class, int.class, int.class, int.class, int.class\n+        );\n+\n+        handleMouseEventMethod.setAccessible(true);\n+\n+        return handleMouseEventMethod;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Mouse\/MacTouchPressEventModifiers\/MouseMacTouchPressEventModifiers.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Tests that equals(Object) is consistent with hashCode(),\n+ *          in particular regarding negative versus positive zeros and\n+ *          NaN values.\n+ *\/\n+\n+import java.awt.geom.AffineTransform;\n+\n+public class EqualsAndHashCode {\n+    private static boolean failed;\n+\n+    public static void main(String arg[]) {\n+        checkReflexiveEquals();\n+        checkZeros();\n+        checkNotEqual();\n+        if (failed) {\n+            throw new RuntimeException(\"Some tests failed.\");\n+        }\n+    }\n+\n+    private static void checkReflexiveEquals() {\n+        AffineTransform t = new AffineTransform(1, 0, 0, 1, Double.NaN, 0);\n+        if (!t.equals(t)) {\n+            System.err.println(\"Transform should be equal to itself.\");\n+            failed = true;\n+        }\n+        if (!t.equals(t.clone())) {\n+            System.err.println(\"Transform should be equal to its clone.\");\n+            failed = true;\n+        }\n+    }\n+\n+    private static void checkZeros() {\n+        AffineTransform positive = new AffineTransform(2, 0, 0, 3, 0, +0.0);\n+        AffineTransform negative = new AffineTransform(2, 0, 0, 3, 0, -0.0);\n+        if (!positive.equals(negative)) {\n+            System.err.println(\"Transforms should be equal despite the sign difference in zero values.\");\n+            failed = true;\n+        } else if (positive.hashCode() != negative.hashCode()) {\n+            System.err.println(\"Equal transforms should have the same hash code value.\");\n+            failed = true;\n+        }\n+    }\n+\n+    private static void checkNotEqual() {\n+        AffineTransform t1 = new AffineTransform(2, 0, 0, 3, 2, 0);\n+        AffineTransform t2 = new AffineTransform(2, 0, 0, 3, 2, 4);\n+        if (t1.equals(t2)) {\n+            System.err.println(\"Expected non-equal transforms.\");\n+            failed = true;\n+        }\n+        if (t1.hashCode() == t2.hashCode()) {\n+            System.err.println(\"Expected different hash codes.\");\n+            failed = true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/geom\/AffineTransform\/EqualsAndHashCode.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -64,2 +64,2 @@\n- * @run testng\/othervm\/timeout=180 TransferTo\n- * @bug 8279283\n+ * @run testng\/othervm\/timeout=180 -Xmx1280m TransferTo\n+ * @bug 8279283 8294541\n","filename":"test\/jdk\/java\/io\/BufferedInputStream\/TransferTo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ * -XX:DisableIntrinsic=_float16ToFloat,_floatToFloat16 Binary16Conversion\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16Conversion.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.1 Binary16ConversionNaN\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ * -XX:DisableIntrinsic=_float16ToFloat,_floatToFloat16 Binary16ConversionNaN\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16ConversionNaN.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,10 +7,0 @@\n-\t\/\/ Allows any thread to stop itself using the java.lang.Thread.stop()\n-\t\/\/ method that takes no argument.\n-\t\/\/ Note that this permission is granted by default only to remain\n-\t\/\/ backwards compatible.\n-\t\/\/ It is strongly recommended that you either remove this permission\n-\t\/\/ from this policy file or further restrict it to code sources\n-\t\/\/ that you specify, because Thread.stop() is potentially unsafe.\n-\t\/\/ See \"http:\/\/java.sun.com\/notes\" for more information.\n-\tpermission java.lang.RuntimePermission \"stopThread\";\n-\n","filename":"test\/jdk\/java\/lang\/System\/System.policy","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -757,1 +757,1 @@\n-     * and unparking.\n+     * and unparking while pinned.\n@@ -778,1 +778,1 @@\n-     * and unparking.\n+     * and unparking while pinned.\n@@ -782,1 +782,8 @@\n-        VThreadRunner.run(this::testJoin33);\n+        \/\/ need at least two carrier threads due to pinning\n+        int previousParallelism = VThreadRunner.ensureParallelism(2);\n+        try {\n+            VThreadRunner.run(this::testJoin33);\n+        } finally {\n+            \/\/ restore\n+            VThreadRunner.setParallelism(previousParallelism);\n+        }\n@@ -1865,2 +1872,1 @@\n-     * Test Thread::getStackTrace on thread that has been started but\n-     * has not run.\n+     * Test Thread::getStackTrace on thread that has been started but has not run.\n@@ -1872,34 +1878,5 @@\n-        List<Thread> threads = new ArrayList<>();\n-        AtomicBoolean done = new AtomicBoolean();\n-        try {\n-            Thread target = null;\n-\n-            \/\/ start virtual threads that are CPU bound until we find a thread\n-            \/\/ that does not run. This is done while holding a monitor to\n-            \/\/ allow this test run in the context of a virtual thread.\n-            synchronized (this) {\n-                while (target == null) {\n-                    CountDownLatch latch = new CountDownLatch(1);\n-                    Thread vthread = Thread.ofVirtual().start(() -> {\n-                        latch.countDown();\n-                        while (!done.get()) { }\n-                    });\n-                    threads.add(vthread);\n-                    if (!latch.await(3, TimeUnit.SECONDS)) {\n-                        \/\/ thread did not run\n-                        target = vthread;\n-                    }\n-                }\n-            }\n-\n-            \/\/ stack trace should be empty\n-            StackTraceElement[] stack = target.getStackTrace();\n-            assertTrue(stack.length == 0);\n-        } finally {\n-            done.set(true);\n-\n-            \/\/ wait for threads to terminate\n-            for (Thread thread : threads) {\n-                thread.join();\n-            }\n-        }\n+        Executor scheduler = task -> { };\n+        Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n+        Thread thread = builder.start(() -> { });\n+        StackTraceElement[] stack = thread.getStackTrace();\n+        assertTrue(stack.length == 0);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":16,"deletions":39,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,7 @@\n+    private static Throwable agentError;\n+\n+    public static void checkErrors() {\n+        if (agentError != null) {\n+            throw new RuntimeException(\"Agent error\", agentError);\n+        }\n+    }\n@@ -90,0 +97,3 @@\n+                    if (agentError == null) {\n+                        agentError = ex;\n+                    }\n@@ -92,2 +102,1 @@\n-                    System.err.println(\"Returning bad class file, to cause test failure\");\n-                    return new byte[0];\n+                    return null;\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixAgent.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,2 @@\n+        NativeMethodPrefixAgent.checkErrors();\n+\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixApp.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-        instrumentingVisitor = new ClassVisitor(Opcodes.ASM7, instrumentingVisitor) {\n+        instrumentingVisitor = new ClassVisitor(Opcodes.ASM9, instrumentingVisitor) {\n","filename":"test\/jdk\/java\/lang\/instrument\/asmlib\/Instrumentor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default\n@@ -30,1 +30,2 @@\n- * @modules java.management\n+ * @modules java.base\/java.lang:+open java.management\n+ * @library \/test\/lib\n@@ -37,1 +38,1 @@\n- * @test\n+ * @test id=no-vmcontinuations\n@@ -40,1 +41,2 @@\n- * @modules java.management\n+ * @modules java.base\/java.lang:+open java.management\n+ * @library \/test\/lib\n@@ -51,0 +53,1 @@\n+import jdk.test.lib.thread.VThreadRunner;\n@@ -64,0 +67,2 @@\n+        \/\/ need at least two carrier threads due to pinning\n+        VThreadRunner.ensureParallelism(2);\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreadDeadlocks.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default\n@@ -34,1 +34,1 @@\n- * @test\n+ * @test id=no-vmcontinuations\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreads.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282252\n+ * @summary Test constructors of BigDecimal to replace BigInteger subclasses\n+ *\/\n+\n+import java.math.*;\n+\n+public class ConstructorUnscaledValue {\n+    public static void main(String... args) {\n+        TestBigInteger tbi = new TestBigInteger(BigInteger.ONE);\n+        \/\/ Create BigDecimal's using each of the three constructors\n+        \/\/ with guards on the class of unscaledValue\n+        BigDecimal[] values = {\n+            new BigDecimal(tbi),\n+            new BigDecimal(tbi, 2),\n+            new BigDecimal(tbi, 3, MathContext.DECIMAL32),\n+        };\n+\n+        for (var bd : values) {\n+            BigInteger unscaledValue = bd.unscaledValue();\n+            if (unscaledValue.getClass() != BigInteger.class) {\n+                throw new RuntimeException(\"Bad class for unscaledValue\");\n+            }\n+            if (!unscaledValue.equals(BigInteger.ONE)) {\n+                throw new RuntimeException(\"Bad value for unscaledValue\");\n+            }\n+        }\n+    }\n+\n+    private static class TestBigInteger extends BigInteger {\n+        public TestBigInteger(BigInteger bi) {\n+            super(bi.toByteArray());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return java.util.Arrays.toString(toByteArray());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigDecimal\/ConstructorUnscaledValue.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6177836\n+ * @bug 6177836 8282252\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n@@ -33,0 +32,1 @@\n+import java.util.List;\n@@ -36,1 +36,11 @@\n-    static void checkSerialForm(BigDecimal bd) throws Exception  {\n+    public static void main(String... args) throws Exception {\n+        checkBigDecimalSerialRoundTrip();\n+        checkBigDecimalSubSerialRoundTrip();\n+    }\n+\n+    private static void checkSerialForm(BigDecimal bd) throws Exception  {\n+        checkSerialForm0(bd);\n+        checkSerialForm0(bd.negate());\n+    }\n+\n+    private static void checkSerialForm0(BigDecimal bd) throws Exception  {\n@@ -38,4 +48,5 @@\n-        ObjectOutputStream oos = new ObjectOutputStream(bos);\n-        oos.writeObject(bd);\n-        oos.flush();\n-        oos.close();\n+        try(ObjectOutputStream oos = new ObjectOutputStream(bos)) {\n+            oos.writeObject(bd);\n+            oos.flush();\n+        }\n+\n@@ -47,1 +58,5 @@\n-            bd.hashCode() != tmp.hashCode()) {\n+            bd.hashCode() != tmp.hashCode() ||\n+            bd.getClass() != tmp.getClass() ||\n+            \/\/ Directly test equality of components\n+            bd.scale() != tmp.scale() ||\n+            !bd.unscaledValue().equals(tmp.unscaledValue())) {\n@@ -54,0 +69,9 @@\n+\n+        \/\/ If the class of the deserialized number is BigDecimal,\n+        \/\/ verify the implementation constraint on the unscaled value\n+        \/\/ having BigInteger class\n+        if (tmp.getClass() == BigDecimal.class) {\n+            if (tmp.unscaledValue().getClass() != BigInteger.class) {\n+                throw new RuntimeException(\"Not using genuine BigInteger as an unscaled value\");\n+            }\n+        }\n@@ -56,13 +80,27 @@\n-    public static void main(String[] args) throws Exception {\n-        BigDecimal values[] = {\n-            BigDecimal.ZERO,\n-            BigDecimal.ONE,\n-            BigDecimal.TEN,\n-            new BigDecimal(0),\n-            new BigDecimal(1),\n-            new BigDecimal(10),\n-            new BigDecimal(Integer.MAX_VALUE),\n-            new BigDecimal(Long.MAX_VALUE-1),\n-            new BigDecimal(BigInteger.valueOf(1), 1),\n-            new BigDecimal(BigInteger.valueOf(100), 50),\n-        };\n+    private static class BigIntegerSub extends BigInteger {\n+        public BigIntegerSub(BigInteger bi) {\n+            super(bi.toByteArray());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return java.util.Arrays.toString(toByteArray());\n+        }\n+    }\n+    private static void checkBigDecimalSerialRoundTrip() throws Exception {\n+        var values =\n+            List.of(BigDecimal.ZERO,\n+                    BigDecimal.ONE,\n+                    BigDecimal.TEN,\n+                    new BigDecimal(0),\n+                    new BigDecimal(1),\n+                    new BigDecimal(10),\n+                    new BigDecimal(Integer.MAX_VALUE),\n+                    new BigDecimal(Long.MAX_VALUE-1),\n+                    new BigDecimal(BigInteger.valueOf(1), 1),\n+                    new BigDecimal(BigInteger.valueOf(100), 50),\n+                    new BigDecimal(new BigInteger(\"9223372036854775808\"), \/\/ Long.MAX_VALUE + 1\n+                                   Integer.MAX_VALUE),\n+                    new BigDecimal(new BigInteger(\"9223372036854775808\"), \/\/ Long.MAX_VALUE + 1\n+                                   Integer.MIN_VALUE),\n+                    new BigDecimal(new BigIntegerSub(BigInteger.ONE), 2));\n@@ -72,1 +110,0 @@\n-            checkSerialForm(value.negate());\n@@ -74,0 +111,12 @@\n+    }\n+\n+    private static class BigDecimalSub extends BigDecimal {\n+        public BigDecimalSub(BigDecimal bd) {\n+            super(bd.unscaledValue(), bd.scale());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return unscaledValue() + \"x10^\" + (-scale());\n+        }\n+    }\n@@ -75,0 +124,25 @@\n+    \/\/ Subclass defining a serialVersionUID\n+    private static class BigDecimalSubSVUID extends BigDecimal {\n+        @java.io.Serial\n+        private static long serialVesionUID = 0x0123_4567_89ab_cdefL;\n+\n+        public BigDecimalSubSVUID(BigDecimal bd) {\n+            super(bd.unscaledValue(), bd.scale());\n+        }\n+    }\n+\n+    private static void checkBigDecimalSubSerialRoundTrip() throws Exception {\n+        var values =\n+            List.of(BigDecimal.ZERO,\n+                    BigDecimal.ONE,\n+                    BigDecimal.TEN,\n+                    new BigDecimal(BigInteger.TEN, 1234),\n+                    new BigDecimal(new BigInteger(\"9223372036854775808\"), \/\/ Long.MAX_VALUE + 1\n+                                   Integer.MAX_VALUE),\n+                    new BigDecimal(new BigInteger(\"9223372036854775808\"), \/\/ Long.MAX_VALUE + 1\n+                                   Integer.MIN_VALUE));\n+\n+        for(var value : values) {\n+            checkSerialForm(new BigDecimalSub(value));\n+            checkSerialForm(new BigDecimalSubSVUID(value));\n+        }\n","filename":"test\/jdk\/java\/math\/BigDecimal\/SerializationTests.java","additions":97,"deletions":23,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282252\n+ * @summary Verify BigInteger objects are serialized properly.\n+ *\/\n+\n+import java.math.*;\n+import java.io.*;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class SerializationTests {\n+\n+    public static void main(String... args) throws Exception {\n+        checkBigIntegerSerialRoundTrip();\n+        checkBigIntegerSubSerialRoundTrip();\n+    }\n+\n+    private static void checkSerialForm(BigInteger bi) throws Exception {\n+        checkSerialForm0(bi);\n+        checkSerialForm0(bi.negate());\n+    }\n+\n+    private static void checkSerialForm0(BigInteger bi) throws Exception  {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        try(ObjectOutputStream oos = new ObjectOutputStream(bos)) {\n+            oos.writeObject(bi);\n+            oos.flush();\n+        }\n+\n+        ObjectInputStream ois = new\n+            ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));\n+        BigInteger tmp = (BigInteger)ois.readObject();\n+\n+        if (!bi.equals(tmp) ||\n+            bi.hashCode() != tmp.hashCode() ||\n+            bi.getClass() != tmp.getClass() ||\n+            \/\/ For extra measure, directly test equality of components\n+            bi.signum() != tmp.signum() ||\n+            !Arrays.equals(bi.toByteArray(), (tmp.toByteArray())) ) {\n+            System.err.print(\"  original : \" + bi);\n+            System.err.println(\" (hash: 0x\" + Integer.toHexString(bi.hashCode()) + \")\");\n+            System.err.print(\"serialized : \" + tmp);\n+            System.err.println(\" (hash: 0x\" + Integer.toHexString(tmp.hashCode()) + \")\");\n+            throw new RuntimeException(\"Bad serial roundtrip\");\n+        }\n+    }\n+\n+    private static void checkBigIntegerSerialRoundTrip() throws Exception {\n+        var values =\n+            List.of(BigInteger.ZERO,\n+                    BigInteger.ONE,\n+                    BigInteger.TWO,\n+                    BigInteger.TEN,\n+                    BigInteger.valueOf(100),\n+                    BigInteger.valueOf(Integer.MAX_VALUE),\n+                    BigInteger.valueOf(Long.MAX_VALUE-1),\n+                    new BigInteger(\"9223372036854775808\")); \/\/ Long.MAX_VALUE + 1\n+\n+        for(BigInteger value : values) {\n+            checkSerialForm(value);\n+        }\n+    }\n+\n+    \/\/ Subclass with specialized toString output\n+    private static class BigIntegerSub extends BigInteger {\n+        public BigIntegerSub(BigInteger bi) {\n+            super(bi.toByteArray());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Arrays.toString(toByteArray());\n+        }\n+    }\n+\n+    \/\/ Subclass defining a serialVersionUID\n+    private static class BigIntegerSubSVUID extends BigInteger {\n+        @java.io.Serial\n+        private static long serialVesionUID = 0x0123_4567_89ab_cdefL;\n+\n+        public BigIntegerSubSVUID(BigInteger bi) {\n+            super(bi.toByteArray());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Arrays.toString(toByteArray());\n+        }\n+    }\n+\n+    \/\/ Subclass defining writeReplace\n+    private static class BigIntegerSubWR extends BigInteger {\n+        public BigIntegerSubWR(BigInteger bi) {\n+            super(bi.toByteArray());\n+        }\n+\n+        \/\/ Just return this; could use a serial proxy instead\n+        @java.io.Serial\n+        private Object writeReplace() throws ObjectStreamException {\n+            return this;\n+        }\n+    }\n+\n+\n+    private static void checkBigIntegerSubSerialRoundTrip() throws Exception {\n+        var values = List.of(BigInteger.ZERO,\n+                             BigInteger.ONE,\n+                             BigInteger.TEN,\n+                             new BigInteger(\"9223372036854775808\")); \/\/ Long.MAX_VALUE + 1\n+\n+        for(var value : values) {\n+            checkSerialForm(new BigIntegerSub(value));\n+            checkSerialForm(new BigIntegerSubSVUID(value));\n+            checkSerialForm(new BigIntegerSubWR(value));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/SerializationTests.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/* @test\n+ * @summary URL.openConnection can throw IOOBE\n+ * @bug 8282395\n+ *\/\n+\n+import java.net.MalformedURLException;\n+import java.net.Proxy;\n+import java.net.URL;\n+\n+public class B8282395 {\n+    public static void main(String[] args) throws Exception {\n+        boolean res = false;\n+        URL url = new URL(\"ftp:\/\/.:%@\");\n+        try {\n+            \/\/ Will throw IndexOutOfBoundsException if not fixed\n+            url.openConnection();\n+        } catch (MalformedURLException e) {\n+            res = true;\n+        }\n+        if (!res) {\n+            throw new RuntimeException(\"MalformedURLException should be thrown\");\n+        }\n+        res = false;\n+        try {\n+            \/\/ Will throw IndexOutOfBoundsException if not fixed\n+            url.openConnection(Proxy.NO_PROXY);\n+        } catch (MalformedURLException e) {\n+            res = true;\n+        }\n+        if (!res) {\n+            throw new RuntimeException(\"MalformedURLException should be thrown\");\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/URL\/B8282395.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,507 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293590\n+ * @summary URL built-in protocol handlers should parse the URL early\n+ *          to avoid constructing URLs for which openConnection\n+ *          would later throw an exception, when possible.\n+ *          A jdk.net.url.delayParsing property allows to switch that\n+ *          behavior off to mitigate risks of regression\n+ * @run junit  EarlyOrDelayedParsing\n+ * @run junit\/othervm -Djdk.net.url.delayParsing EarlyOrDelayedParsing\n+ * @run junit\/othervm -Djdk.net.url.delayParsing=true EarlyOrDelayedParsing\n+ * @run junit\/othervm -Djdk.net.url.delayParsing=false EarlyOrDelayedParsing\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.lang.System.err;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class EarlyOrDelayedParsing {\n+\n+    public final boolean EARLY_PARSING;\n+    {\n+        String value = System.getProperty(\"jdk.net.url.delayParsing\", \"false\");\n+        EARLY_PARSING = !value.isEmpty() && !Boolean.parseBoolean(value);\n+    }\n+\n+    \/\/ Some characters that when included at the wrong place\n+    \/\/ in the authority component, without being escaped, would\n+    \/\/ cause an exception.\n+    private static final String EXCLUDED_DELIMS = \"<>\\\" \";\n+    private static final String UNWISE = \"{}|\\\\^`\";\n+    private static final String DELIMS = \"[]\/?#@\";\n+\n+    \/\/ Test data used to test exceptions thrown by URL\n+    \/\/ at some point, when constructed with some illegal input.\n+    sealed interface URLArgTest\n+            permits OneArgTest, TwoArgsTest, ThreeArgsTest, FourArgsTest {\n+\n+        \/\/ Some character that is expected to cause an exception\n+        \/\/ at some point, and which this test case is built for\n+        int character();\n+\n+        \/\/ An URL string containing the illegal character\n+        String url();\n+\n+        \/\/ Some characters are already checked at construction\n+        \/\/ time. They will cause an exception to be thrown,\n+        \/\/ whether delayed parsing is activated or not.\n+        \/\/ This method returns true if an exception is\n+        \/\/ expected at construction time for this test case,\n+        \/\/ even when delayed parsing is activated.\n+        boolean early(int c);\n+\n+        \/\/ The URL scheme this test case is built for.\n+        \/\/ Typically, one of \"http\", \"https\", \"ftp\"...\n+        default String scheme() {\n+            return scheme(url());\n+        }\n+\n+        \/\/ Return the URL string of this test case, after\n+        \/\/ substituting its scheme with the given scheme.\n+        default String urlWithScheme(String scheme) {\n+            String url = url();\n+            int colon = url.indexOf(':');\n+            String urlWithScheme = scheme + url.substring(colon);\n+            return urlWithScheme;\n+        }\n+\n+        \/\/ Which exception to expect when parsing is delayed\n+        default boolean acceptDelayedException(Throwable exception) {\n+            return exception instanceof MalformedURLException\n+                    || exception instanceof UnknownHostException;\n+        }\n+\n+        default String describe() {\n+            return this.getClass().getSimpleName() + \"(url=\" + url() + \")\";\n+        }\n+\n+        static int port(String protocol) {\n+            return switch (protocol) {\n+                case \"http\" -> 80;\n+                case \"https\" -> 443;\n+                case \"ftp\" -> 21;\n+                default -> -1;\n+            };\n+        }\n+\n+        static String scheme(String url) {\n+            return url.substring(0, url.indexOf(':'));\n+        }\n+    }\n+\n+    \/\/ Test data for the one arg constructor\n+    \/\/ public URL(String spec) throws MalformedURLException\n+    sealed interface OneArgTest extends URLArgTest {\n+\n+        \/\/ Create a new test case identical to this one but\n+        \/\/ with a different URL scheme\n+        default OneArgTest withScheme(String scheme) {\n+            String urlWithScheme = urlWithScheme(scheme);\n+            if (this instanceof OfHost) {\n+                return new OfHost(character(), urlWithScheme);\n+            }\n+            if (this instanceof OfUserInfo) {\n+                return new OfUserInfo(character(), urlWithScheme);\n+            }\n+            throw new AssertionError(\"unexpected subclass: \" + this.getClass());\n+        }\n+\n+        @Override\n+        default boolean early(int c) {\n+            return this instanceof OfHost &&\n+                    (c < 31 || c == 127);\n+        }\n+\n+        @Override\n+        default boolean acceptDelayedException(Throwable exception) {\n+            return URLArgTest.super.acceptDelayedException(exception)\n+                    || \"file\".equalsIgnoreCase(scheme())\n+                    && character() == '\\\\'\n+                    && exception instanceof IOException;\n+        }\n+\n+        record OfHost(int character, String url) implements OneArgTest { }\n+        record OfUserInfo(int character, String url) implements OneArgTest { }\n+\n+        static OneArgTest ofHost(int c) {\n+            return new OfHost(c, \"http:\/\/local%shost\/\".formatted(Character.toString(c)));\n+        }\n+        static OneArgTest ofUserInfo(int c) {\n+            return new OfUserInfo(c, \"http:\/\/user%sinfo@localhost:9999\/\".formatted(Character.toString(c)));\n+        }\n+    }\n+\n+    \/\/ Test data for the two arg constructor\n+    \/\/ public URL(URL context, String spec) throws MalformedURLException\n+    sealed interface TwoArgsTest extends URLArgTest {\n+\n+        \/\/ Create a new test case identical to this one but\n+        \/\/ with a different URL scheme\n+        default TwoArgsTest withScheme(String scheme) {\n+            String urlWithScheme = urlWithScheme(scheme);\n+            if (this instanceof OfTwoArgsHost) {\n+                return new OfTwoArgsHost(character(), urlWithScheme);\n+            }\n+            if (this instanceof OfTwoArgsUserInfo) {\n+                return new OfTwoArgsUserInfo(character(), urlWithScheme);\n+            }\n+            throw new AssertionError(\"unexpected subclass: \" + this.getClass());\n+        }\n+\n+        @Override\n+        default boolean early(int c) {\n+            return this instanceof OfTwoArgsHost &&\n+                    (c < 31 || c == 127);\n+        }\n+\n+        @Override\n+        default boolean acceptDelayedException(Throwable exception) {\n+            return URLArgTest.super.acceptDelayedException(exception)\n+                    || \"file\".equalsIgnoreCase(scheme())\n+                    && character() == '\\\\'\n+                    && exception instanceof IOException;\n+        }\n+\n+        record OfTwoArgsHost(int character, String url) implements TwoArgsTest { }\n+        record OfTwoArgsUserInfo(int character, String url) implements TwoArgsTest { }\n+\n+        static TwoArgsTest ofHost(int c) {\n+            return new OfTwoArgsHost(c, \"http:\/\/local%shost\/\".formatted(Character.toString(c)));\n+        }\n+        static TwoArgsTest ofUserInfo(int c) {\n+            return new OfTwoArgsUserInfo(c, \"http:\/\/user%sinfo@localhost:9999\/\".formatted(Character.toString(c)));\n+        }\n+        static TwoArgsTest ofOneArgTest(OneArgTest test) {\n+            if (test instanceof OneArgTest.OfHost) {\n+                return ofHost(test.character());\n+            } else if (test instanceof OneArgTest.OfUserInfo) {\n+                return ofUserInfo(test.character());\n+            }\n+            throw new AssertionError(\"can't convert to TwoArgsTest: \"\n+                    + test.getClass());\n+        }\n+    }\n+\n+\n+    \/\/ Test data for the three args constructor\n+    \/\/ public URL(String scheme, String host, String file)\n+    \/\/     throws MalformedURLException\n+    sealed interface ThreeArgsTest extends URLArgTest {\n+\n+        \/\/ the host component\n+        String host();\n+\n+        \/\/ the path + query components\n+        String file();\n+\n+        \/\/ Create a new test case identical to this one but\n+        \/\/ with a different URL scheme and port\n+        default ThreeArgsTest withScheme(String scheme) {\n+            String urlWithScheme = urlWithScheme(scheme);\n+            if (this instanceof OfHostFile) {\n+                return new OfHostFile(character(), host(), file(), urlWithScheme);\n+            }\n+            throw new AssertionError(\"unexpected subclass: \" + this.getClass());\n+        }\n+\n+        @Override\n+        default boolean early(int c) {\n+            return (c < 31 || c == 127 || c == '\/');\n+        }\n+\n+        @Override\n+        default boolean acceptDelayedException(Throwable exception) {\n+            return URLArgTest.super.acceptDelayedException(exception)\n+                    || \"file\".equalsIgnoreCase(scheme())\n+                    && exception instanceof IOException;\n+        }\n+\n+        record OfHostFile(int character, String host, String file, String url)\n+                implements ThreeArgsTest {\n+        }\n+\n+        static ThreeArgsTest ofHostFile(int c) {\n+            String host = \"local%shost\".formatted(Character.toString(c));\n+            String url = \"http:\/\/\" + host + \"\/\";\n+            return new OfHostFile(c, host, \"\/\", url);\n+        }\n+    }\n+\n+    \/\/ Test data for the four args constructor\n+    \/\/ public URL(String scheme, String host, int port, String file)\n+    \/\/     throws MalformedURLException\n+    sealed interface FourArgsTest extends URLArgTest {\n+\n+        \/\/ the host component\n+        String host();\n+\n+        \/\/ the port component\n+        int port();\n+\n+        \/\/ the path + query components\n+        String file();\n+\n+        \/\/ Create a new test case identical to this one but\n+        \/\/ with a different URL scheme and port\n+        default FourArgsTest withScheme(String scheme) {\n+            String urlWithScheme = urlWithScheme(scheme);\n+            if (this instanceof OfHostFilePort) {\n+                int port = URLArgTest.port(scheme);\n+                return new OfHostFilePort(character(), host(), port, file(), urlWithScheme);\n+            }\n+            throw new AssertionError(\"unexpected subclass: \" + this.getClass());\n+        }\n+\n+        @Override\n+        default boolean early(int c) {\n+            return (c < 31 || c == 127 || c == '\/');\n+        }\n+\n+        @Override\n+        default boolean acceptDelayedException(Throwable exception) {\n+            return URLArgTest.super.acceptDelayedException(exception)\n+                    || \"file\".equalsIgnoreCase(scheme())\n+                    && exception instanceof IOException;\n+        }\n+\n+        record OfHostFilePort(int character, String host, int port, String file, String url)\n+                implements FourArgsTest {\n+        }\n+\n+        static FourArgsTest ofHostPortFile(int c) {\n+            String host = \"local%shost\".formatted(Character.toString(c));\n+            String url = \"http:\/\/\" + host + \"\/\";\n+            int port = URLArgTest.port(URLArgTest.scheme(url));\n+            return new OfHostFilePort(c, host, port, \"\/\", url);\n+        }\n+    }\n+\n+\n+    \/\/ Generate test data for the URL one arg constructor, with variations\n+    \/\/ of the host component.\n+    static Stream<OneArgTest> oneArgHostTests() {\n+        List<OneArgTest> tests = new ArrayList<>();\n+        List<OneArgTest> urls = new ArrayList<>();\n+        urls.addAll((UNWISE + EXCLUDED_DELIMS).chars()\n+                .mapToObj(OneArgTest::ofHost).toList());\n+        urls.addAll(IntStream.concat(IntStream.range(0, 31), IntStream.of(127))\n+                .mapToObj(OneArgTest::ofHost).toList());\n+        for (String scheme : List.of(\"http\", \"https\", \"ftp\")) {\n+            for (var test : urls) {\n+                tests.add(test.withScheme(scheme));\n+            }\n+        }\n+        return tests.stream();\n+    }\n+\n+    \/\/ Generate test data for the URL one arg constructor, with variations\n+    \/\/ of the user info component.\n+    static Stream<OneArgTest> oneArgUserInfoTests() {\n+        List<OneArgTest> tests = new ArrayList<>();\n+        List<OneArgTest> urls = new ArrayList<>();\n+        urls.addAll(IntStream.concat(IntStream.range(0, 31), IntStream.of(127))\n+                .mapToObj(OneArgTest::ofUserInfo).toList());\n+        urls.add(OneArgTest.ofUserInfo('\\\\'));\n+        for (String scheme : List.of(\"http\", \"https\", \"ftp\")) {\n+            for (var test : urls) {\n+                tests.add(test.withScheme(scheme));\n+            }\n+        }\n+        return tests.stream();\n+    }\n+\n+    \/\/ Test data with all variations for the URL one arg\n+    \/\/ constructor (spec)\n+    static Stream<OneArgTest> oneArgTests() {\n+        return Stream.concat(oneArgHostTests(), oneArgUserInfoTests());\n+    }\n+\n+    \/\/ Test data with all variations for the URL two arg\n+    \/\/ constructor (URL, spec)\n+    static Stream<TwoArgsTest> twoArgTests() {\n+        return oneArgTests().map(TwoArgsTest::ofOneArgTest);\n+    }\n+\n+    \/\/ Generate test data for the URL three arguments constructor\n+    \/\/ (scheme, host, file)\n+    static Stream<ThreeArgsTest> threeArgsTests() {\n+        List<ThreeArgsTest> urls = new ArrayList<>();\n+        urls.addAll((UNWISE + EXCLUDED_DELIMS + DELIMS).chars()\n+                .mapToObj(ThreeArgsTest::ofHostFile).toList());\n+        urls.addAll(IntStream.concat(IntStream.range(0, 31), IntStream.of(127))\n+                .mapToObj(ThreeArgsTest::ofHostFile).toList());\n+        List<ThreeArgsTest> tests = new ArrayList<>();\n+        for (String scheme : List.of(\"http\", \"https\", \"ftp\", \"file\")) {\n+            for (var test : urls) {\n+                tests.add(test.withScheme(scheme));\n+            }\n+        }\n+        return tests.stream();\n+    }\n+\n+    \/\/ Generate test data for the URL four arguments constructor\n+    \/\/ (scheme, host, port, file)\n+    static Stream<FourArgsTest> fourArgsTests() {\n+        List<FourArgsTest> urls = new ArrayList<>();\n+        urls.addAll((UNWISE + EXCLUDED_DELIMS + DELIMS).chars()\n+                .mapToObj(FourArgsTest::ofHostPortFile).toList());\n+        urls.addAll(IntStream.concat(IntStream.range(0, 31), IntStream.of(127))\n+                .mapToObj(FourArgsTest::ofHostPortFile).toList());\n+        List<FourArgsTest> tests = new ArrayList<>();\n+        for (String scheme : List.of(\"http\", \"https\", \"ftp\", \"file\")) {\n+            for (var test : urls) {\n+                tests.add(test.withScheme(scheme));\n+            }\n+        }\n+        return tests.stream();\n+    }\n+\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"oneArgTests\")\n+    public void testOneArgConstructor(OneArgTest test) throws Exception {\n+\n+        int c = test.character();\n+        String url = test.url();\n+        if (EARLY_PARSING || test.early(c)) {\n+            err.println(\"Early parsing: \" + test.describe());\n+            var exception = assertThrows(MalformedURLException.class, () -> {\n+                new URL(url);\n+            });\n+            err.println(\"Got expected exception: \" + exception);\n+        } else {\n+            err.println(\"Delayed parsing: \" + test.describe());\n+            URL u = new URL(url);\n+            var exception = assertThrows(IOException.class, () -> {\n+                u.openConnection().connect();\n+            });\n+            if (!test.acceptDelayedException(exception)) {\n+                    err.println(\"unexpected exception type: \" + exception);\n+                    throw exception;\n+            }\n+            err.println(\"Got expected exception: \" + exception);\n+            assertFalse(exception instanceof ConnectException);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"twoArgTests\")\n+    public void testTwoArgConstructor(TwoArgsTest test) throws Exception {\n+\n+        int c = test.character();\n+        String url = test.url();\n+        String scheme = URLArgTest.scheme(url);\n+        URL u = new URL(scheme, null,\"\");\n+        if (EARLY_PARSING || test.early(c)) {\n+            err.println(\"Early parsing: \" + test.describe());\n+            var exception = assertThrows(MalformedURLException.class, () -> {\n+                new URL(u, url);\n+            });\n+            err.println(\"Got expected exception: \" + exception);\n+        } else {\n+            err.println(\"Delayed parsing: \" + test.describe());\n+            URL u2 = new URL(u, url);\n+            var exception = assertThrows(IOException.class, () -> {\n+                u2.openConnection().connect();\n+            });\n+            if (!test.acceptDelayedException(exception)) {\n+                err.println(\"unexpected exception type: \" + exception);\n+                throw exception;\n+            }\n+            err.println(\"Got expected exception: \" + exception);\n+            assertFalse(exception instanceof ConnectException);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"threeArgsTests\")\n+    public void testThreeArgsConstructor(ThreeArgsTest test) throws Exception {\n+\n+        int c = test.character();\n+        String url = test.url();\n+        if (EARLY_PARSING || test.early(c)) {\n+            err.println(\"Early parsing: \" + url);\n+            var exception = assertThrows(MalformedURLException.class, () -> {\n+                new URL(test.scheme(), test.host(), test.file());\n+            });\n+            err.println(\"Got expected exception: \" + exception);\n+        } else {\n+            err.println(\"Delayed parsing: \" + url);\n+            URL u = new URL(test.scheme(), test.host(), test.file());\n+            var exception = assertThrows(IOException.class, () -> {\n+                u.openConnection().connect();\n+            });\n+            if (!test.acceptDelayedException(exception)) {\n+                err.println(\"unexpected exception type: \" + exception);\n+                throw exception;\n+            }\n+            err.println(\"Got expected exception: \" + exception);\n+            assertFalse(exception instanceof ConnectException);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"fourArgsTests\")\n+    public void testFourArgsConstructor(FourArgsTest test) throws Exception {\n+\n+        int c = test.character();\n+        String url = test.url();\n+        if (EARLY_PARSING || test.early(c)) {\n+            err.println(\"Early parsing: \" + url);\n+            var exception = assertThrows(MalformedURLException.class, () -> {\n+                new URL(test.scheme(), test.host(), test.port(), test.file());\n+            });\n+            err.println(\"Got expected exception: \" + exception);\n+        } else {\n+            err.println(\"Delayed parsing: \" + url);\n+            URL u = new URL(test.scheme(), test.host(), test.port(), test.file());\n+            var exception = assertThrows(IOException.class, () -> {\n+                u.openConnection().connect();\n+            });\n+            if (!test.acceptDelayedException(exception)) {\n+                err.println(\"unexpected exception type: \" + exception);\n+                throw exception;\n+            }\n+            err.println(\"Got expected exception: \" + exception);\n+            assertFalse(exception instanceof ConnectException);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/URL\/EarlyOrDelayedParsing.java","additions":507,"deletions":0,"binary":false,"changes":507,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-            Arrays.asList( NO_DURATION,   ofSeconds(1)  ),\n@@ -59,1 +58,0 @@\n-            Arrays.asList( NO_DURATION,   ofNanos(99)   ),\n@@ -62,1 +60,0 @@\n-            Arrays.asList( ofSeconds(1),  NO_DURATION   ),\n@@ -64,1 +61,0 @@\n-            Arrays.asList( ofNanos(99),   NO_DURATION   ),\n@@ -67,1 +63,0 @@\n-            Arrays.asList( ofSeconds(1),  ofMinutes(1)  ),\n@@ -69,1 +64,0 @@\n-            Arrays.asList( ofNanos(99),   ofMinutes(1)  ),\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractConnectTimeout.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,3 +71,1 @@\n-            Arrays.asList( NO_DURATION,   ofSeconds(1)  ),\n-            Arrays.asList( NO_DURATION,   ofSeconds(2)  ),\n-            Arrays.asList( NO_DURATION,   ofMillis(500) ),\n+            Arrays.asList( NO_DURATION,   ofMillis(100) ),\n@@ -75,3 +73,1 @@\n-            Arrays.asList( ofSeconds(1),  NO_DURATION   ),\n-            Arrays.asList( ofSeconds(2),  NO_DURATION   ),\n-            Arrays.asList( ofMillis(500), NO_DURATION   ),\n+            Arrays.asList( ofMillis(100), NO_DURATION   ),\n@@ -79,3 +75,1 @@\n-            Arrays.asList( ofSeconds(1),  ofMinutes(1)  ),\n-            Arrays.asList( ofSeconds(2),  ofMinutes(1)  ),\n-            Arrays.asList( ofMillis(500), ofMinutes(1)  )\n+            Arrays.asList( ofMillis(100), ofMinutes(1)  )\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractConnectTimeoutHandshake.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\n+\/**\n+ * @test\n+ * @bug 8292876\n+ * @library \/test\/lib server\n+ * @modules java.base\/sun.net.www.http\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ * @run junit UserInfoTest\n+ *\/\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class UserInfoTest {\n+\n+    Http2TestServer server;\n+    int port;\n+    SSLContext sslContext;\n+\n+    @BeforeAll\n+    void before() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        server = createServer(sslContext);\n+        port = server.getAddress().getPort();\n+        server.start();\n+    }\n+\n+    @AfterAll\n+    void after() throws Exception {\n+        server.close();\n+    }\n+\n+    static class Http2TestHandler implements Http2Handler {\n+        @Override\n+        public void handle(Http2TestExchange e) throws IOException {\n+            String authorityHeader = e.getRequestHeaders().firstValue(\":authority\").orElse(null);\n+            if (authorityHeader == null || authorityHeader.contains(\"user@\")) {\n+                e.sendResponseHeaders(500, -1);\n+            } else {\n+                e.sendResponseHeaders(200, -1);\n+            }\n+        }\n+    }\n+\n+    private static Http2TestServer createServer(SSLContext sslContext) throws Exception {\n+        Http2TestServer http2TestServer = new Http2TestServer(\"localhost\", true, sslContext);\n+        Http2TestHandler handler = new Http2TestHandler();\n+        http2TestServer.addHandler(handler, \"\/\");\n+        return http2TestServer;\n+    }\n+\n+    @Test\n+    public void testAuthorityHeader() throws Exception {\n+        HttpClient client = HttpClient\n+                .newBuilder()\n+                .proxy(HttpClient.Builder.NO_PROXY)\n+                .sslContext(sslContext)\n+                .build();\n+\n+        URI uri = URIBuilder.newBuilder()\n+                .scheme(\"https\")\n+                .userInfo(\"user\")\n+                .loopback()\n+                .port(port)\n+                .build();\n+\n+        HttpRequest request = HttpRequest\n+                .newBuilder(uri)\n+                .GET()\n+                .build();\n+\n+        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+\n+        assertEquals(200, response.statusCode(), \"Test Failed : \" + response.uri().getAuthority());\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/UserInfoTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -460,1 +460,1 @@\n-            this.key = ConnectionPool.cacheKey(address, proxy);\n+            this.key = ConnectionPool.cacheKey(secured, address, proxy);\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/ConnectionPoolTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,1 +147,1 @@\n-                if (!e.getMessage().contains(\"Current location of the bytebuffer \"\n+                if (!e.getMessage().contains(\"Current position of the bytebuffer \"\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/directio\/ReadDirect.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-                if (!e.getMessage().contains(\"Current location of the bytebuffer \"\n+                if (!e.getMessage().contains(\"Current position of the bytebuffer \"\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/directio\/WriteDirect.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -12,10 +12,0 @@\n-\t\/\/ Allows any thread to stop itself using the java.lang.Thread.stop()\n-\t\/\/ method that takes no argument.\n-\t\/\/ Note that this permission is granted by default only to remain\n-\t\/\/ backwards compatible.\n-\t\/\/ It is strongly recommended that you either remove this permission\n-\t\/\/ from this policy file or further restrict it to code sources\n-\t\/\/ that you specify, because Thread.stop() is potentially unsafe.\n-\t\/\/ See \"http:\/\/java.sun.com\/notes\" for more information.\n-\tpermission java.lang.RuntimePermission \"stopThread\";\n-\n","filename":"test\/jdk\/java\/nio\/charset\/spi\/default-pol","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,0 @@\n-        perms.add(new java.lang.RuntimePermission(\"stopThread\"));\n","filename":"test\/jdk\/java\/security\/Policy\/Dynamic\/DynamicPolicy.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @bug 8155246 8292297\n+ * @bug 8155246 8292297 8292177\n@@ -45,0 +45,8 @@\n+    private static final String EXPECTED_DEBUG_OUTPUT =\n+        \"Initial security property: crypto.policy=unlimited\";\n+\n+    private static final String UNEXPECTED_DEBUG_OUTPUT =\n+            \"Initial security property: postInitTest=shouldNotRecord\";\n+\n+    private static boolean overrideDetected = false;\n+\n@@ -55,0 +63,1 @@\n+            Security.setProperty(\"postInitTest\", \"shouldNotRecord\");\n@@ -102,0 +111,4 @@\n+\n+            if (!overrideDetected) {\n+                throw new RuntimeException(\"Override scenario not seen\");\n+            }\n@@ -108,1 +121,16 @@\n-        oa.shouldHaveExitValue(exitCode).shouldContain(output);\n+        oa.shouldHaveExitValue(exitCode)\n+                .shouldContain(output);\n+\n+        \/\/ extra checks on debug output\n+        if (exitCode != 1) {\n+            if (oa.getStderr().contains(\"overriding other security properties files!\")) {\n+                overrideDetected = true;\n+                \/\/ master file is not in use - only provider properties are set in custom file\n+                oa.shouldContain(\"security.provider.2=SunRsaSign\")\n+                        .shouldNotContain(EXPECTED_DEBUG_OUTPUT)\n+                        .shouldNotContain(UNEXPECTED_DEBUG_OUTPUT);\n+            } else {\n+                oa.shouldContain(EXPECTED_DEBUG_OUTPUT)\n+                        .shouldNotContain(UNEXPECTED_DEBUG_OUTPUT);\n+            }\n+        }\n","filename":"test\/jdk\/java\/security\/Security\/ConfigFileTest.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8177552 8217721 8222756\n+ * @bug 8177552 8217721 8222756 8295372\n@@ -84,0 +84,15 @@\n+    private static final NumberFormat FORMAT_ES_LONG_FD1 = NumberFormat\n+            .getCompactNumberInstance(Locale.of(\"es\"), NumberFormat.Style.LONG);\n+    private static final NumberFormat FORMAT_DE_LONG_FD2 = NumberFormat\n+            .getCompactNumberInstance(Locale.GERMAN, NumberFormat.Style.LONG);\n+    private static final NumberFormat FORMAT_IT_LONG_FD3 = NumberFormat\n+            .getCompactNumberInstance(Locale.ITALIAN, NumberFormat.Style.LONG);\n+    private static final NumberFormat FORMAT_PT_LONG_FD4 = NumberFormat\n+            .getCompactNumberInstance(Locale.of(\"pt\"), NumberFormat.Style.LONG);\n+    static {\n+        FORMAT_ES_LONG_FD1.setMaximumFractionDigits(1);\n+        FORMAT_DE_LONG_FD2.setMaximumFractionDigits(2);\n+        FORMAT_IT_LONG_FD3.setMaximumFractionDigits(3);\n+        FORMAT_PT_LONG_FD4.setMaximumFractionDigits(4);\n+    }\n+\n@@ -342,0 +357,5 @@\n+            \/\/ Fractional plurals\n+            {FORMAT_ES_LONG_FD1, 1_234_500, \"1,2 millones\"},\n+            {FORMAT_DE_LONG_FD2, 1_234_500, \"1,23 Millionen\"},\n+            {FORMAT_IT_LONG_FD3, 1_234_500, \"1,234 milioni\"},\n+            {FORMAT_PT_LONG_FD4, 1_234_500, \"1,2345 milh\\u00f5es\"},\n@@ -444,0 +464,5 @@\n+                \/\/ Fractional plurals\n+                {FORMAT_ES_LONG_FD1, \"1,2 millones\", 1_200_000L, Long.class},\n+                {FORMAT_DE_LONG_FD2, \"1,23 Millionen\", 1_230_000L, Long.class},\n+                {FORMAT_IT_LONG_FD3, \"1,234 milioni\", 1_234_000L, Long.class},\n+                {FORMAT_PT_LONG_FD4, \"1,2345 milh\\u00f5es\", 1_234_500L, Long.class},\n@@ -450,1 +475,1 @@\n-            \/\/ compact number instance, string to parse, null (no o\/p; must throws exception)\n+            \/\/ compact number instance, string to parse, null (no o\/p; must throw exception)\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCompactNumber.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/**\n+ * @test\n+ * @bug 8295232\n+ * @summary Ensures java.locale.useOldISOCodes is statically initialized\n+ * @library \/test\/lib\n+ * @run main UseOldISOCodesTest\n+ *\/\n+import java.util.Locale;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class UseOldISOCodesTest {\n+    public static void main(String[] args) throws Exception {\n+        ProcessTools.executeTestJvm(\"-Djava.locale.useOldISOCodes=true\", \"UseOldISOCodesTest$Runner\")\n+                .outputTo(System.out)\n+                .errorTo(System.err)\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    static class Runner {\n+        private static final String obsoleteCode = \"iw\";\n+        private static final String newCode = \"he\";\n+\n+        public static void main(String[] args) {\n+            System.setProperty(\"java.locale.useOldISOCodes\", \"false\");\n+            Locale locale = Locale.of(newCode);\n+            if(!obsoleteCode.equals(locale.getLanguage())){\n+                throw new RuntimeException(\"Expected that newcode mapped to old \");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/UseOldISOCodesTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-tzdata2022d\n+tzdata2022e\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-Asia\/Amman EET EEST\n@@ -102,1 +101,0 @@\n-Asia\/Damascus EET EEST\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/displaynames.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-   \n+\n","filename":"test\/jdk\/javax\/accessibility\/manual\/README.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8278086\n+ * @summary Tests that writing invalid bits per pixel image in BMP\n+            throws IOException\n+ *\/\n+\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+import java.io.File;\n+import java.io.IOException;\n+import javax.imageio.ImageIO;\n+\n+public class BMPBitsPerPixelTest {\n+\n+    public static void main(String[] args) {\n+        test(1, false);\n+        test(2, true);\n+        test(3, true);\n+        test(4, false);\n+        test(5, true);\n+        test(6, true);\n+        test(7, true);\n+        test(8, false);\n+    }\n+\n+    public static void test(int bpp, boolean shouldThrowException) {\n+        int palettes = (int)Math.pow(2, bpp);\n+        byte[] r = new byte[palettes];\n+        byte[] g = new byte[palettes];\n+        byte[] b = new byte[palettes];\n+        boolean exceptionThrown = false;\n+        try {\n+            IndexColorModel cm = new IndexColorModel(bpp, palettes, r, g, b);\n+            int imageType = BufferedImage.TYPE_BYTE_BINARY;\n+            if (bpp > 4) {\n+                imageType = BufferedImage.TYPE_BYTE_INDEXED;\n+            }\n+            BufferedImage img = new\n+                BufferedImage(10, 10, imageType, (IndexColorModel)cm);\n+            File file = File.createTempFile(\"test\", \".bmp\", new File(\".\"));\n+            file.deleteOnExit();\n+            ImageIO.write(img, \"BMP\", file);\n+        } catch (IOException e) {\n+            exceptionThrown = true;\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Unexpected exception: \" + e);\n+        }\n+\n+        if (shouldThrowException && !exceptionThrown) {\n+            throw new RuntimeException(\"IOException was not caught.\");\n+        } else if (!shouldThrowException && exceptionThrown) {\n+            throw new RuntimeException(\"IOException should not be thrown.\");\n+        } else {\n+            System.out.println(\"Test PASSED.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/imageio\/plugins\/bmp\/BMPBitsPerPixelTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -9,10 +9,0 @@\n-\t\/\/ Allows any thread to stop itself using the java.lang.Thread.stop()\n-\t\/\/ method that takes no argument.\n-\t\/\/ Note that this permission is granted by default only to remain\n-\t\/\/ backwards compatible.\n-\t\/\/ It is strongly recommended that you either remove this permission\n-\t\/\/ from this policy file or further restrict it to code sources\n-\t\/\/ that you specify, because Thread.stop() is potentially unsafe.\n-\t\/\/ See \"http:\/\/java.sun.com\/notes\" for more information.\n-\tpermission java.lang.RuntimePermission \"stopThread\";\n-\n","filename":"test\/jdk\/javax\/management\/security\/java.policy.authorization","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -101,1 +101,2 @@\n-                \"-Dcom.sun.jndi.ldap.object.trustSerialData=true\");\n+                \"-Dcom.sun.jndi.ldap.object.trustSerialData=true\",\n+                \"-Djdk.jndi.ldap.object.factoriesFilter=org.example.fruit.FruitFactory\");\n","filename":"test\/jdk\/javax\/naming\/module\/RunBasic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8288882\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"linux\")\n+ * @summary To test if the 1-Empty-File size shows 0.0 KB and other files show correct size.\n+ * @run main\/manual FileSizeCheck\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.WindowConstants;\n+\n+public class FileSizeCheck {\n+    private static Path[] tempFilePaths;\n+    private static final String INSTRUCTIONS =\n+            \"Click on the \\\"Details\\\" button in right-top corner.\\n\\n\" +\n+                    \"Scroll Down if required. \\n\\n\" +\n+                    \"Test 1: If the size of 1st-Empty-File shows 0.0 KB\\n\" +\n+                    \"Test 2: If the size of 2nd-File-1-Byte shows 0.1 KB\\n\" +\n+                    \"Test 3: If the size of 3rd-File-160-Byte shows 0.2 KB\\n\" +\n+                    \"Test 3: If the size of 4th-File-299-Byte shows 0.3 KB\\n\" +\n+                    \"Test 4: If the size of 5th-File-900-Byte shows 0.9 KB\\n\" +\n+                    \"Test 6: If the size of 6th-File-901-Byte shows 1.0 KB\\n\" +\n+                    \"Test 7: If the size of 7th-File-999-KB shows 999.0 KB\\n\" +\n+                    \"Test 8: If the size of 8th-File-1000-KB shows 1.0 MB\\n\" +\n+                    \"Test 9: If the size of 9th-File-2.8-MB shows 2.8 MB\\n\\n\" +\n+                           \"press PASS.\\n\\n\";\n+\n+    public static void test() {\n+        JFrame frame = new JFrame(\"JFileChooser File Size test\");\n+        JFileChooser fc = new JFileChooser();\n+        fc.setControlButtonsAreShown(false);\n+        Path dir = Paths.get(\".\");\n+        String[] tempFilesName = {\"1st-Empty-File\", \"2nd-File-1-Byte\", \"3rd-File-160-Byte\",\n+                \"4th-File-299-Byte\", \"5th-File-900-Byte\", \"6th-File-901-Byte\",\n+                \"7th-File-999-KB\", \"8th-File-1000-KB\", \"9th-File-2.8-MB\"};\n+\n+        int[] tempFilesSize = {0, 1, 160, 299, 900, 901, 999_000, 1_000_000, 2_800_000};\n+\n+        tempFilePaths = new Path[tempFilesName.length];\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+\n+        \/\/ Create temp files\n+        try {\n+            for (int i = 0; i < tempFilePaths.length; i++) {\n+                tempFilePaths[i] = dir.resolve(tempFilesName[i]);\n+                if (!Files.exists(tempFilePaths[i])){\n+                    RandomAccessFile f = new RandomAccessFile(tempFilePaths[i].toFile(), \"rw\");\n+                    f.setLength(tempFilesSize[i]);\n+                    f.close();\n+                }\n+            }\n+            fc.setCurrentDirectory(dir.toFile());\n+        } catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+        frame.add(fc);\n+        frame.pack();\n+        frame.setVisible(true);\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\"JFileChooser Test Instructions\",\n+                INSTRUCTIONS, 5, 19, 35);\n+        try {\n+            SwingUtilities.invokeAndWait(FileSizeCheck::test);\n+            passFailJFrame.awaitAndCheck();\n+        } finally {\n+            try {\n+                for (int i = 0; i < tempFilePaths.length; ++i) {\n+                    Files.deleteIfExists(tempFilePaths[i]);\n+                }\n+            } catch (IOException ex) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileSizeCheck.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+\n+import java.io.File;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JFileChooser;\n+import javax.swing.SwingUtilities;\n+import javax.swing.WindowConstants;\n+\n+import javax.swing.filechooser.FileView;\n+\n+\/*\n+ * @test\n+ * @bug 6616245\n+ * @key headful\n+ * @requires (os.family == \"windows\" | os.family == \"linux\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Test to check if NPE occurs when using custom FileView.\n+ * @run main\/manual FileViewNPETest\n+ *\/\n+public class FileViewNPETest {\n+    static PassFailJFrame passFailJFrame;\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            public void run() {\n+                try {\n+                    initialize();\n+                } catch (InterruptedException | InvocationTargetException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    static void initialize() throws InterruptedException, InvocationTargetException {\n+        JFrame frame;\n+        JFileChooser jfc;\n+\n+        \/\/Initialize the components\n+        final String INSTRUCTIONS = \"\"\"\n+                Instructions to Test:\n+                1. The traversable folder is set to the Documents folder,\n+                 if it exists, in the user's home folder, otherwise\n+                 it's the user's home. Other folders are non-traversable.\n+                2. When the file chooser appears on the screen, select any\n+                 non-traversable folder from \"Look-In\" combo box,\n+                 for example the user's folder or a folder above it.\n+                 (The folder will not be opened since it's non-traversable).\n+                3. Select the Documents folder again.\n+                4. If NullPointerException does not occur in the step 3,\n+                 click Pass, otherwise the test fails automatically.\n+                \"\"\";\n+        frame = new JFrame(\"JFileChooser File View NPE test\");\n+        passFailJFrame = new PassFailJFrame(\"Test Instructions\", INSTRUCTIONS,\n+                5L, 13, 40);\n+        jfc = new JFileChooser();\n+\n+        String userHome = System.getProperty(\"user.home\");\n+        String docs = userHome + File.separator + \"Documents\";\n+        String path = (new File(docs).exists()) ? docs : userHome;\n+\n+        jfc.setCurrentDirectory(new File(path));\n+        jfc.setFileView(new CustomFileView(path));\n+        jfc.setControlButtonsAreShown(false);\n+\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+\n+        frame.add(jfc, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+}\n+\n+class CustomFileView extends FileView {\n+    private final String basePath;\n+\n+    public CustomFileView(String path) {\n+        basePath = path;\n+    }\n+\n+    public Boolean isTraversable(File filePath) {\n+        return ((filePath != null) && (filePath.isDirectory()))\n+                && filePath.getAbsolutePath().startsWith(basePath);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/FileViewNPETest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4314194 8075916\n+ * @summary  Verifies disabled color for JCheckbox and JRadiobutton is honored in all L&F\n+ * @run main bug4314194\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import javax.swing.JFrame;\n+import javax.swing.JCheckBox;\n+import javax.swing.JRadioButton;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+public class bug4314194 {\n+    private static JFrame frame;\n+    private static JRadioButton radioButton;\n+    private static JCheckBox checkBox;\n+    private static Point point;\n+    private static Rectangle rect;\n+    private static Robot robot;\n+    private static final Color radioButtonColor = Color.RED;\n+    private static final Color checkboxColor = Color.GREEN;\n+    private static final int tolerance = 20;\n+\n+    private static boolean checkComponent(Component comp, Color c) throws Exception {\n+        int correctColoredPixels = 0;\n+        int totalPixels = 0;\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            point = comp.getLocationOnScreen();\n+            rect = comp.getBounds();\n+        });\n+\n+        int y = point.y + rect.height \/ 2;\n+        for (int x = point.x; x < point.x + rect.width; x++) {\n+            Color color = robot.getPixelColor(x, y);\n+            robot.waitForIdle();\n+\n+            if (color.equals(c)) {\n+                correctColoredPixels++;\n+            }\n+            totalPixels++;\n+        }\n+\n+        System.out.println(\"correctColoredPixels \" + correctColoredPixels + \" totalPixels \" + totalPixels);\n+        return ((double)correctColoredPixels\/totalPixels*100) >= tolerance;\n+    }\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported L&F: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void createUI() {\n+        UIManager.getDefaults().put(\"CheckBox.disabledText\", checkboxColor);\n+        UIManager.getDefaults().put(\"RadioButton.disabledText\", radioButtonColor);\n+\n+        checkBox = new JCheckBox(\"\\u2588\".repeat(5));\n+        radioButton = new JRadioButton(\"\\u2588\".repeat(5));\n+        checkBox.setFont(checkBox.getFont().deriveFont(50.0f));\n+        radioButton.setFont(radioButton.getFont().deriveFont(50.0f));\n+        checkBox.setEnabled(false);\n+        radioButton.setEnabled(false);\n+\n+        frame = new JFrame(\"bug4314194\");\n+        frame.getContentPane().add(radioButton, BorderLayout.SOUTH);\n+        frame.getContentPane().add(checkBox, BorderLayout.NORTH);\n+        frame.pack();\n+        frame.setAlwaysOnTop(true);\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+\n+        for (UIManager.LookAndFeelInfo laf :\n+                 UIManager.getInstalledLookAndFeels()) {\n+            if (laf.getClassName().contains(\"Motif\")) {\n+                System.out.println(\"Skipping Motif L&F as it is deprecated\");\n+                continue;\n+            }\n+            System.out.println(\"Testing L&F: \" + laf.getClassName());\n+            SwingUtilities.invokeAndWait(() -> setLookAndFeel(laf));\n+            try {\n+                SwingUtilities.invokeAndWait(() -> createUI());\n+                robot.waitForIdle();\n+                robot.delay(1000);\n+\n+                if (!checkComponent(checkBox, checkboxColor)) {\n+                    throw new RuntimeException(\"Correct color not set for Checkbox\");\n+                }\n+\n+                if (!checkComponent(radioButton, radioButtonColor)) {\n+                    throw new RuntimeException(\"Correct color not set for RadioButton\");\n+                }\n+            } finally {\n+                if (frame != null) {\n+                    SwingUtilities.invokeAndWait(() -> frame.dispose());\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JRadioButton\/4314194\/bug4314194.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @run     main CustomComboBoxFocusTest\n+ * @run     main\/othervm -Dsun.java2d.uiScale=1 CustomComboBoxFocusTest\n@@ -35,1 +35,0 @@\n-import java.awt.Component;\n@@ -37,0 +36,1 @@\n+import java.awt.Component;\n@@ -47,1 +47,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -49,0 +48,1 @@\n+\n","filename":"test\/jdk\/javax\/swing\/plaf\/aqua\/CustomComboBoxFocusTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 6852577\n+ * @summary  Verifies PasswordField.echoChar is not null for Nimbus L&F\n+ * @run main PasswordFieldTest\n+ *\/\n+\n+import javax.swing.UIManager;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+public class PasswordFieldTest {\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported L&F: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            for (UIManager.LookAndFeelInfo laf :\n+                                UIManager.getInstalledLookAndFeels()) {\n+                System.out.println(\"Testing L&F: \" + laf.getClassName());\n+                setLookAndFeel(laf);\n+\n+                System.out.println(\"Echo char: \" +\n+                                UIManager.get(\"PasswordField.echoChar\"));\n+                if (UIManager.get(\"PasswordField.echoChar\") == null) {\n+                    throw new RuntimeException(\n+                        \"PasswordField.echoChar returns null for \" +\n+                            laf.getClassName());\n+                }\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/nimbus\/PasswordFieldTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 4820080\n+   @summary RFE: Cannot Change the JSplitPane Divider Color while dragging\n+   @key headful\n+   @library \/java\/awt\/regtesthelpers\n+   @build PassFailJFrame\n+   @run main\/manual TestNimbusDividerDragColor\n+*\/\n+\n+import java.awt.Color;\n+import java.awt.Panel;\n+import javax.swing.Box;\n+import javax.swing.BoxLayout;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JSeparator;\n+import javax.swing.JSplitPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+public class TestNimbusDividerDragColor {\n+\n+    private static JFrame frame;\n+\n+    private static final String INSTRUCTIONS =\n+        \"Drag the dividers of the splitpanes (both top and bottom).\\n \" +\n+        \" If the divider color is green while dragging\\n \" +\n+        \" then test passes, otherwise test fails\";\n+\n+    public static void init() {\n+        UIManager.put(\"SplitPaneDivider.draggingColor\", Color.green);\n+\n+        frame = new JFrame();\n+        Box box = new Box(BoxLayout.Y_AXIS);\n+        frame.getContentPane().add(box);\n+\n+        JPanel jleft = new JPanel();\n+        jleft.setBackground(Color.darkGray);\n+        JPanel jright = new JPanel();\n+        jright.setBackground(Color.darkGray);\n+        JSplitPane jsp = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, jleft, jright);\n+        jsp.setContinuousLayout(false);\n+        box.add(jsp);\n+\n+        box.add(Box.createVerticalStrut(5));\n+        box.add(new JSeparator());\n+        box.add(Box.createVerticalStrut(5));\n+\n+        Panel left = new Panel();\n+        left.setBackground(Color.darkGray);\n+        Panel right = new Panel();\n+        right.setBackground(Color.darkGray);\n+        JSplitPane sp = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, left, right);\n+        sp.setContinuousLayout(false);\n+        box.add(sp);\n+        frame.add(box);\n+        frame.setSize(200, 200);\n+        frame.setVisible(true);\n+    }\n+\n+\n+    public static void main(String[] argv) throws Exception {\n+        UIManager.setLookAndFeel(\"javax.swing.plaf.nimbus.NimbusLookAndFeel\");\n+        PassFailJFrame passFailJFrame = new PassFailJFrame(\n+                \"JFileChooser Test Instructions\", INSTRUCTIONS, 5);\n+        SwingUtilities.invokeAndWait(() -> init());\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(\n+                frame, PassFailJFrame.Position.HORIZONTAL);\n+        passFailJFrame.awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/nimbus\/TestNimbusDividerDragColor.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 7172359\n+ * @summary  Verifies HTML parser StackOverflowError on invalid HTML: <li> tag\n+ *           inside an <option>\n+ * @run main ParserStackOverflow\n+ *\/\n+import javax.swing.text.html.HTMLDocument;\n+import javax.swing.text.html.HTMLEditorKit;\n+import java.io.StringReader;\n+import java.io.Reader;\n+\n+public class ParserStackOverflow {\n+    \/*\n+     * li element inside an option will crash javax.swing.text.html.parser.Parser\n+     *\/\n+    public static void main( String[] argv ) throws Exception {\n+        String badHtml =\n+         \"<html><body><form><select><option><li><\/option><\/select><\/form><\/body><\/html>\";\n+\n+        HTMLEditorKit kit = new HTMLEditorKit();\n+        HTMLDocument doc = (HTMLDocument) kit.createDefaultDocument();\n+        Reader reader = new StringReader(badHtml);\n+        kit.read(reader, doc, 0); \/\/ StackOverflowError here\n+\n+        System.out.println(\"Succeeded! (no StackOverflowError)\");\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/text\/html\/parser\/ParserStackOverflow.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.nio.file.Path;\n@@ -27,0 +28,1 @@\n+import java.util.Set;\n@@ -30,1 +32,6 @@\n-import jdk.test.lib.Asserts;\n+import jdk.jfr.SettingControl;\n+import jdk.jfr.SettingDefinition;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Asserts.assertFalse;\n@@ -34,1 +41,1 @@\n- * @summary Test enable\/disable event and verify recording has expected events.\n+ * @summary Test jdk.jfr.Event::shouldCommit()\n@@ -38,1 +45,1 @@\n- * @run main\/othervm -Xlog:jfr+event+setting=trace jdk.jfr.api.event.TestShouldCommit\n+ * @run main\/othervm jdk.jfr.api.event.TestShouldCommit\n@@ -40,1 +47,0 @@\n-\n@@ -43,33 +49,2 @@\n-    public static void main(String[] args) throws Exception {\n-        Recording rA = new Recording();\n-\n-        verifyShouldCommitFalse(); \/\/ No active recordings\n-\n-        rA.start();\n-        rA.enable(MyEvent.class).withoutThreshold(); \/\/ recA=all\n-        verifyShouldCommitTrue();\n-\n-        setThreshold(rA, 100); \/\/ recA=100\n-        verifyThreshold(100);\n-\n-        setThreshold(rA, 200); \/\/ recA=200\n-        verifyThreshold(200);\n-\n-        Recording rB = new Recording();\n-        verifyThreshold(200);  \/\/ recA=200, recB=not started\n-\n-        rB.start();\n-        verifyThreshold(200);  \/\/ recA=200, recB=not specified, settings from recA is used.\n-\n-        setThreshold(rB, 100); \/\/ recA=200, recB=100\n-        verifyThreshold(100);\n-\n-        setThreshold(rB, 300); \/\/ recA=200, recB=300\n-        verifyThreshold(200);\n-\n-        rA.disable(MyEvent.class); \/\/ recA=disabled, recB=300\n-\n-        verifyThreshold(300);\n-\n-        rB.disable(MyEvent.class); \/\/ recA=disabled, recB=disabled\n-        verifyShouldCommitFalse();\n+    private static class CatEvent extends Event {\n+    }\n@@ -77,2 +52,2 @@\n-        setThreshold(rA, 200); \/\/ recA=200, recB=disabled\n-        verifyThreshold(200);\n+    private static class DogEvent extends Event {\n+    }\n@@ -80,2 +55,2 @@\n-        rB.enable(MyEvent.class).withoutThreshold(); \/\/ recA=200, recB=all\n-        verifyShouldCommitTrue();\n+    private static class BirdEvent extends Event {\n+        public boolean isFlying;\n@@ -83,2 +58,5 @@\n-        setThreshold(rB, 100); \/\/ recA=200, recB=100\n-        verifyThreshold(100);\n+        @SettingDefinition\n+        public boolean fly(FlySetting control) {\n+            return control.shouldFly() == isFlying;\n+        }\n+    }\n@@ -86,2 +64,2 @@\n-        rB.stop(); \/\/ recA=200, recB=stopped\n-        verifyThreshold(200);\n+    private static class FlySetting extends SettingControl {\n+        private boolean shouldFly;\n@@ -89,2 +67,9 @@\n-        rA.stop(); \/\/ recA=stopped, recB=stopped\n-        verifyShouldCommitFalse();\n+        @Override\n+        public String combine(Set<String> settingValues) {\n+            for (String s : settingValues) {\n+                if (\"true\".equals(s)) {\n+                    return \"true\";\n+                }\n+            }\n+            return \"false\";\n+        }\n@@ -92,2 +77,3 @@\n-        rA.close();\n-        rB.close();\n+        public boolean shouldFly() {\n+            return shouldFly;\n+        }\n@@ -95,2 +81,4 @@\n-        verifyShouldCommitFalse();\n-    }\n+        @Override\n+        public void setValue(String settingValue) {\n+            shouldFly = \"true\".equals(settingValue);\n+        }\n@@ -98,2 +86,4 @@\n-    private static void setThreshold(Recording r, long millis) {\n-        r.enable(MyEvent.class).withThreshold(Duration.ofMillis(millis));\n+        @Override\n+        public String getValue() {\n+            return String.valueOf(shouldFly);\n+        }\n@@ -102,5 +92,6 @@\n-    private static void verifyThreshold(long threshold) throws Exception {\n-        \/\/ Create 2 events, with different sleep time between begin() and end()\n-        \/\/ First event ends just before threshold, the other just after.\n-        verifyThreshold(threshold-5, threshold);\n-        verifyThreshold(threshold+5, threshold);\n+    public static void main(String[] args) throws Exception {\n+        testEnablement();\n+        testThreshold();\n+        testCustomSetting();\n+        testWithoutEnd();\n+        testCommit();\n@@ -109,2 +100,3 @@\n-    private static void verifyThreshold(long sleepMs, long thresholdMs) throws Exception {\n-        MyEvent event = new MyEvent();\n+    private static void testEnablement() throws Exception {\n+        DogEvent b = new DogEvent();\n+        assertFalse(b.shouldCommit(), \"Expected false before recording is started\");\n@@ -112,3 +104,4 @@\n-        long beforeStartNanos = System.nanoTime();\n-        event.begin();\n-        long afterStartNanos = System.nanoTime();\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class);\n+            r.disable(DogEvent.class);\n+            r.start();\n@@ -116,1 +109,2 @@\n-        Thread.sleep(sleepMs);\n+            CatEvent c = new CatEvent();\n+            assertTrue(c.shouldCommit(), \"Expected true for enabled event\");\n@@ -118,3 +112,3 @@\n-        long beforeStopNanos = System.nanoTime();\n-        event.end();\n-        long afterStopNanos = System.nanoTime();\n+            DogEvent d = new DogEvent();\n+            assertFalse(d.shouldCommit(), \"Expected false for disabled event\");\n+        }\n@@ -122,1 +116,3 @@\n-        boolean actualShouldCommit = event.shouldCommit();\n+        CatEvent c = new CatEvent();\n+        assertFalse(c.shouldCommit(), \"Expected false after recording is stopped\");\n+    }\n@@ -124,1 +120,5 @@\n-        final long safetyMarginNanos = 2000000; \/\/ Allow an error of 2 ms. May have to be tuned.\n+    private static void testThreshold() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class).withThreshold(Duration.ofNanos(0));\n+            r.enable(DogEvent.class).withThreshold(Duration.ofDays(1));\n+            r.start();\n@@ -126,5 +126,5 @@\n-        \/\/Duration of event has been at least minDurationMicros\n-        long minDurationMicros = (beforeStopNanos - afterStartNanos - safetyMarginNanos) \/ 1000;\n-        \/\/Duration of event has been at most maxDurationMicros\n-        long maxDurationMicros = (afterStopNanos - beforeStartNanos + safetyMarginNanos) \/ 1000;\n-        Asserts.assertLessThanOrEqual(minDurationMicros, maxDurationMicros, \"Wrong min\/max duration. Test error.\");\n+            CatEvent c = new CatEvent();\n+            c.begin();\n+            Thread.sleep(1);\n+            c.end();\n+            assertTrue(c.shouldCommit(), \"Expected true if above threshold\");\n@@ -132,8 +132,5 @@\n-        long thresholdMicros = thresholdMs * 1000;\n-        Boolean shouldCommit = null;\n-        if (minDurationMicros > thresholdMicros) {\n-            shouldCommit = new Boolean(true);  \/\/ shouldCommit() must be true\n-        } else if (maxDurationMicros < thresholdMicros) {\n-            shouldCommit = new Boolean(false); \/\/ shouldCommit() must be false\n-        } else {\n-            \/\/ Too close to call. No checks are done since we are not sure of expected shouldCommit().\n+            DogEvent d = new DogEvent();\n+            d.begin();\n+            Thread.sleep(1);\n+            d.end();\n+            assertFalse(d.shouldCommit(), \"Expected false if below threshold\");\n@@ -141,0 +138,1 @@\n+    }\n@@ -142,13 +140,15 @@\n-        System.out.printf(\n-            \"threshold=%d, duration=[%d-%d], shouldCommit()=%b, expected=%s%n\",\n-            thresholdMicros, minDurationMicros, maxDurationMicros, actualShouldCommit,\n-            (shouldCommit!=null ? shouldCommit : \"too close to call\"));\n-\n-        try {\n-            if (shouldCommit != null) {\n-                Asserts.assertEquals(shouldCommit.booleanValue(), actualShouldCommit, \"Wrong shouldCommit()\");\n-            }\n-        } catch (Exception e) {\n-            System.out.println(\"Unexpected value of shouldCommit(). Searching for active threshold...\");\n-            searchThreshold(thresholdMs, 2000+thresholdMs);\n-            throw e;\n+    private static void testCustomSetting() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(BirdEvent.class).with(\"fly\", \"true\");\n+            r.start();\n+            BirdEvent b1 = new BirdEvent();\n+            b1.isFlying = false;\n+            b1.begin();\n+            b1.end();\n+            assertFalse(b1.shouldCommit(), \"Expected false if rejected by custom setting\");\n+\n+            BirdEvent b2 = new BirdEvent();\n+            b2.isFlying = true;\n+            b2.begin();\n+            b2.end();\n+            assertTrue(b2.shouldCommit(), \"Expected true if accepted by custom setting\");\n@@ -158,4 +158,5 @@\n-    \/\/ Sleeps until shouldCommit() is true, or give up. Used for logging.\n-    private static void searchThreshold(long expectedMs, long maxMs) throws Exception {\n-        long start = System.nanoTime();\n-        long stop = start + maxMs * 1000000;\n+    private static void testWithoutEnd() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class).withThreshold(Duration.ofDays(0));\n+            r.enable(DogEvent.class).withThreshold(Duration.ofDays(1));\n+            r.start();\n@@ -163,3 +164,4 @@\n-        MyEvent event = new MyEvent();\n-        event.begin();\n-        event.end();\n+            CatEvent c = new CatEvent();\n+            c.begin();\n+            Thread.sleep(1);\n+            assertTrue(c.shouldCommit(), \"Expected true when above threshold and end() not invoked\");\n@@ -167,1 +169,2 @@\n-        while (!event.shouldCommit() && System.nanoTime() < stop) {\n+            DogEvent d = new DogEvent();\n+            d.begin();\n@@ -169,1 +172,1 @@\n-            event.end();\n+            assertFalse(d.shouldCommit(), \"Expected false when below threshold and end() not invoked\");\n@@ -171,17 +174,0 @@\n-        long durationMicros = (System.nanoTime() - start) \/ 1000;\n-        long expectedMicros = expectedMs * 1000;\n-        System.out.printf(\"shouldCommit()=%b after %,d ms, expected %,d%n\", event.shouldCommit(), durationMicros, expectedMicros);\n-    }\n-\n-    private static void verifyShouldCommitFalse() {\n-        MyEvent event = new MyEvent();\n-        event.begin();\n-        event.end();\n-        Asserts.assertFalse(event.shouldCommit(), \"shouldCommit() expected false\");\n-    }\n-\n-    private static void verifyShouldCommitTrue() {\n-        MyEvent event = new MyEvent();\n-        event.begin();\n-        event.end();\n-        Asserts.assertTrue(event.shouldCommit(), \"shouldCommit() expected true\");\n@@ -190,1 +176,17 @@\n-    private static class MyEvent extends Event {\n+    private static void testCommit() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(CatEvent.class);\n+            r.start();\n+            CatEvent c = new CatEvent();\n+            c.begin();\n+            Thread.sleep(1);\n+            c.end();\n+            if (c.shouldCommit()) {\n+                c.commit();\n+            }\n+            r.stop();\n+            Path file = Path.of(\"dump.jfr\");\n+            r.dump(file);\n+            boolean hasEvent = RecordingFile.readAllEvents(file).size() > 0;\n+            assertTrue(hasEvent, \"Expected event when using commit() after shouldCommit()\");\n+        }\n@@ -192,1 +194,0 @@\n-\n","filename":"test\/jdk\/jdk\/jfr\/api\/event\/TestShouldCommit.java","additions":125,"deletions":124,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        r.enable(EventNames.JitRestart);\n+        r.enable(EventNames.JITRestart);\n@@ -94,1 +94,1 @@\n-            if (evt.getEventType().getName().equals(\"jdk.JitRestart\")) {\n+            if (evt.getEventType().getName().equals(\"jdk.JITRestart\")) {\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestJitRestart.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -255,0 +255,1 @@\n+        settingValues.put(EventNames.InitialSecurityProperty + \"#threshold\", \"0 ns\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestActiveSettingEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.security;\n+\n+import jdk.internal.access.SharedSecrets;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+import java.security.Security;\n+import java.util.List;\n+import java.util.Properties;\n+\n+\/*\n+ * @test\n+ * @bug 8292177\n+ * @summary InitialSecurityProperty JFR event\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.access\n+ * @run main\/othervm jdk.jfr.event.security.TestInitialSecurityPropertyEvent\n+ *\/\n+public class TestInitialSecurityPropertyEvent {\n+\n+    private static final String SEC_KEY = \"security.overridePropertiesFile\";\n+    public static void main(String[] args) throws Exception {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(EventNames.InitialSecurityProperty)\n+                    .with(\"period\", \"beginChunk\");\n+            recording.start();\n+            \/\/ this property edit should not be recorded\n+            Security.setProperty(SEC_KEY, \"false\");\n+            recording.stop();\n+\n+            Properties p = SharedSecrets.getJavaSecurityPropertiesAccess().getInitialProperties();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            if (events.size() == 0) {\n+                throw new Exception(\"No security properties - Security class may not have loaded ?\");\n+            }\n+            Asserts.assertEquals(events.size(), p.size(), \"Incorrect number of events\");\n+            assertEvent(events, SEC_KEY, \"true\");\n+        }\n+    }\n+\n+    private static void assertEvent(List<RecordedEvent> events, String key, String origValue) throws Exception {\n+        for (RecordedEvent e : events) {\n+            if (e.getString(\"key\").equals(key)) {\n+                Events.assertField(e, \"value\").equal(origValue);\n+                return;\n+            }\n+        }\n+        System.out.println(events);\n+        throw new Exception(\"Incorrect value for \" + key + \" property recorded\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestInitialSecurityPropertyEvent.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -11,10 +11,0 @@\n-\t\/\/ Allows any thread to stop itself using the java.lang.Thread.stop()\n-\t\/\/ method that takes no argument.\n-\t\/\/ Note that this permission is granted by default only to remain\n-\t\/\/ backwards compatible.\n-\t\/\/ It is strongly recommended that you either remove this permission\n-\t\/\/ from this policy file or further restrict it to code sources\n-\t\/\/ that you specify, because Thread.stop() is potentially unsafe.\n-\t\/\/ See \"http:\/\/java.sun.com\/notes\" for more information.\n-\tpermission java.lang.RuntimePermission \"stopThread\";\n-\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/IsKeepingAlive.policy","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,1272 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @bug 8291226 8291638\n+ * @modules java.base\/sun.net:+open\n+ *          java.base\/sun.net.www.http:+open\n+ *          java.base\/sun.net.www:+open\n+ *          java.base\/sun.net.www.protocol.http:+open\n+ * @run main\/othervm KeepAliveTest 0\n+ * @run main\/othervm KeepAliveTest 1\n+ * @run main\/othervm KeepAliveTest 2\n+ * @run main\/othervm KeepAliveTest 3\n+ * @run main\/othervm KeepAliveTest 4\n+ * @run main\/othervm KeepAliveTest 5\n+ * @run main\/othervm KeepAliveTest 6\n+ * @run main\/othervm KeepAliveTest 7\n+ * @run main\/othervm KeepAliveTest 8\n+ * @run main\/othervm KeepAliveTest 9\n+ * @run main\/othervm KeepAliveTest 10\n+ * @run main\/othervm KeepAliveTest 11\n+ * @run main\/othervm KeepAliveTest 12\n+ * @run main\/othervm KeepAliveTest 13\n+ * @run main\/othervm KeepAliveTest 14\n+ * @run main\/othervm KeepAliveTest 15\n+ * @run main\/othervm KeepAliveTest 16\n+ * @run main\/othervm KeepAliveTest 17\n+ * @run main\/othervm KeepAliveTest 18\n+ * @run main\/othervm KeepAliveTest 19\n+ * @run main\/othervm KeepAliveTest 20\n+ * @run main\/othervm KeepAliveTest 21\n+ * @run main\/othervm KeepAliveTest 22\n+ * @run main\/othervm KeepAliveTest 23\n+ * @run main\/othervm KeepAliveTest 24\n+ * @run main\/othervm KeepAliveTest 25\n+ * @run main\/othervm KeepAliveTest 26\n+ * @run main\/othervm KeepAliveTest 27\n+ * @run main\/othervm KeepAliveTest 28\n+ * @run main\/othervm KeepAliveTest 29\n+ * @run main\/othervm KeepAliveTest 30\n+ * @run main\/othervm KeepAliveTest 31\n+ * @run main\/othervm KeepAliveTest 32\n+ * @run main\/othervm KeepAliveTest 33\n+ * @run main\/othervm KeepAliveTest 34\n+ * @run main\/othervm KeepAliveTest 35\n+ * @run main\/othervm KeepAliveTest 36\n+ * @run main\/othervm KeepAliveTest 37\n+ * @run main\/othervm KeepAliveTest 38\n+ * @run main\/othervm KeepAliveTest 39\n+ * @run main\/othervm KeepAliveTest 40\n+ * @run main\/othervm KeepAliveTest 41\n+ * @run main\/othervm KeepAliveTest 42\n+ * @run main\/othervm KeepAliveTest 43\n+ * @run main\/othervm KeepAliveTest 44\n+ * @run main\/othervm KeepAliveTest 45\n+ * @run main\/othervm KeepAliveTest 46\n+ * @run main\/othervm KeepAliveTest 47\n+ * @run main\/othervm KeepAliveTest 48\n+ * @run main\/othervm KeepAliveTest 49\n+ * @run main\/othervm KeepAliveTest 50\n+ * @run main\/othervm KeepAliveTest 51\n+ * @run main\/othervm KeepAliveTest 52\n+ * @run main\/othervm KeepAliveTest 53\n+ * @run main\/othervm KeepAliveTest 54\n+ * @run main\/othervm KeepAliveTest 55\n+ * @run main\/othervm KeepAliveTest 56\n+ * @run main\/othervm KeepAliveTest 57\n+ * @run main\/othervm KeepAliveTest 58\n+ * @run main\/othervm KeepAliveTest 59\n+ * @run main\/othervm KeepAliveTest 60\n+ * @run main\/othervm KeepAliveTest 61\n+ * @run main\/othervm KeepAliveTest 62\n+ * @run main\/othervm KeepAliveTest 63\n+ * @run main\/othervm KeepAliveTest 64\n+ * @run main\/othervm KeepAliveTest 65\n+ * @run main\/othervm KeepAliveTest 66\n+ * @run main\/othervm KeepAliveTest 67\n+ * @run main\/othervm KeepAliveTest 68\n+ * @run main\/othervm KeepAliveTest 69\n+ * @run main\/othervm KeepAliveTest 70\n+ * @run main\/othervm KeepAliveTest 71\n+ * @run main\/othervm KeepAliveTest 72\n+ * @run main\/othervm KeepAliveTest 73\n+ * @run main\/othervm KeepAliveTest 74\n+ * @run main\/othervm KeepAliveTest 75\n+ * @run main\/othervm KeepAliveTest 76\n+ * @run main\/othervm KeepAliveTest 77\n+ * @run main\/othervm KeepAliveTest 78\n+ * @run main\/othervm KeepAliveTest 79\n+ * @run main\/othervm KeepAliveTest 80\n+ * @run main\/othervm KeepAliveTest 81\n+ * @run main\/othervm KeepAliveTest 82\n+ * @run main\/othervm KeepAliveTest 83\n+ * @run main\/othervm KeepAliveTest 84\n+ * @run main\/othervm KeepAliveTest 85\n+ * @run main\/othervm KeepAliveTest 86\n+ * @run main\/othervm KeepAliveTest 87\n+ * @run main\/othervm KeepAliveTest 88\n+ * @run main\/othervm KeepAliveTest 89\n+ * @run main\/othervm KeepAliveTest 90\n+ * @run main\/othervm KeepAliveTest 91\n+ * @run main\/othervm KeepAliveTest 92\n+ * @run main\/othervm KeepAliveTest 93\n+ * @run main\/othervm KeepAliveTest 94\n+ * @run main\/othervm KeepAliveTest 95\n+ * @run main\/othervm KeepAliveTest 96\n+ * @run main\/othervm KeepAliveTest 97\n+ * @run main\/othervm KeepAliveTest 98\n+ * @run main\/othervm KeepAliveTest 99\n+ * @run main\/othervm KeepAliveTest 100\n+ * @run main\/othervm KeepAliveTest 101\n+ * @run main\/othervm KeepAliveTest 102\n+ * @run main\/othervm KeepAliveTest 103\n+ * @run main\/othervm KeepAliveTest 104\n+ * @run main\/othervm KeepAliveTest 105\n+ * @run main\/othervm KeepAliveTest 106\n+ * @run main\/othervm KeepAliveTest 107\n+ * @run main\/othervm KeepAliveTest 108\n+ * @run main\/othervm KeepAliveTest 109\n+ * @run main\/othervm KeepAliveTest 110\n+ * @run main\/othervm KeepAliveTest 111\n+ * @run main\/othervm KeepAliveTest 112\n+ * @run main\/othervm KeepAliveTest 113\n+ * @run main\/othervm KeepAliveTest 114\n+ * @run main\/othervm KeepAliveTest 115\n+ * @run main\/othervm KeepAliveTest 116\n+ * @run main\/othervm KeepAliveTest 117\n+ * @run main\/othervm KeepAliveTest 118\n+ * @run main\/othervm KeepAliveTest 119\n+ * @run main\/othervm KeepAliveTest 120\n+ * @run main\/othervm KeepAliveTest 121\n+ * @run main\/othervm KeepAliveTest 122\n+ * @run main\/othervm KeepAliveTest 123\n+ * @run main\/othervm KeepAliveTest 124\n+ * @run main\/othervm KeepAliveTest 125\n+ * @run main\/othervm KeepAliveTest 126\n+ * @run main\/othervm KeepAliveTest 127\n+ * @run main\/othervm KeepAliveTest 128\n+ * @run main\/othervm KeepAliveTest 129\n+ * @run main\/othervm KeepAliveTest 130\n+ * @run main\/othervm KeepAliveTest 131\n+ * @run main\/othervm KeepAliveTest 132\n+ * @run main\/othervm KeepAliveTest 133\n+ * @run main\/othervm KeepAliveTest 134\n+ * @run main\/othervm KeepAliveTest 135\n+ * @run main\/othervm KeepAliveTest 136\n+ * @run main\/othervm KeepAliveTest 137\n+ * @run main\/othervm KeepAliveTest 138\n+ * @run main\/othervm KeepAliveTest 139\n+ * @run main\/othervm KeepAliveTest 140\n+ * @run main\/othervm KeepAliveTest 141\n+ * @run main\/othervm KeepAliveTest 142\n+ * @run main\/othervm KeepAliveTest 143\n+ * @run main\/othervm KeepAliveTest 144\n+ * @run main\/othervm KeepAliveTest 145\n+ * @run main\/othervm KeepAliveTest 146\n+ * @run main\/othervm KeepAliveTest 147\n+ * @run main\/othervm KeepAliveTest 148\n+ * @run main\/othervm KeepAliveTest 149\n+ * @run main\/othervm KeepAliveTest 150\n+ * @run main\/othervm KeepAliveTest 151\n+ * @run main\/othervm KeepAliveTest 152\n+ * @run main\/othervm KeepAliveTest 153\n+ * @run main\/othervm KeepAliveTest 154\n+ * @run main\/othervm KeepAliveTest 155\n+ * @run main\/othervm KeepAliveTest 156\n+ * @run main\/othervm KeepAliveTest 157\n+ * @run main\/othervm KeepAliveTest 158\n+ * @run main\/othervm KeepAliveTest 159\n+ *\/\n+\n+import java.nio.charset.StandardCharsets;\n+import java.io.InputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.Proxy.Type;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import sun.net.www.http.HttpClient;\n+import sun.net.www.http.KeepAliveCache;\n+import sun.net.www.protocol.http.HttpURLConnection;\n+import jdk.test.lib.net.URIBuilder;\n+\n+public class KeepAliveTest {\n+    private static final Logger logger = Logger.getLogger(\"sun.net.www.protocol.http.HttpURLConnection\");\n+    private static final String NOT_CACHED = \"NotCached\";\n+    private static final String CLIENT_SEPARATOR = \";\";\n+    private static final String NEW_LINE = \"\\r\\n\";\n+    private volatile int SERVER_PORT = 0;\n+    \/*\n+     * isProxySet is shared variable between server thread and client thread(main) and it should be set and reset to false for each and\n+     * every scenario.\n+     * isProxySet variable should be set by server thread before proceeding to client thread(main).\n+     *\/\n+    private volatile boolean isProxySet = false;\n+    private static final String CONNECTION_KEEP_ALIVE_ONLY = \"Connection: keep-alive\";\n+    private static final String PROXY_CONNECTION_KEEP_ALIVE_ONLY = \"Proxy-Connection: keep-alive\";\n+    private static final String KEEP_ALIVE_TIMEOUT_NEG = \"Keep-alive: timeout=-20\";\n+    private static final String KEEP_ALIVE_TIMEOUT_ZERO = \"Keep-alive: timeout=0\";\n+    private static final String KEEP_ALIVE_TIMEOUT = \"Keep-alive: timeout=20\";\n+    private static final String KEEP_ALIVE_PROXY_TIMEOUT = \"Keep-alive: timeout=120\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_NEGATIVE = \"http.keepAlive.time.server=-100\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_NEGATIVE = \"http.keepAlive.time.proxy=-200\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_ZERO = \"http.keepAlive.time.server=0\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_ZERO = \"http.keepAlive.time.proxy=0\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_POSITIVE = \"http.keepAlive.time.server=100\";\n+    private static final String CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_POSITIVE = \"http.keepAlive.time.proxy=200\";\n+    private static final String CONNECTION_KEEP_ALIVE_WITH_TIMEOUT = CONNECTION_KEEP_ALIVE_ONLY + NEW_LINE\n+        + KEEP_ALIVE_TIMEOUT;\n+   \/*\n+    * Following Constants represents Client Side Properties and is used as reference in below table as\n+    * CLIENT_INPUT_CONSTANT_NAMES\n+    *\/\n+    private static final String SERVER_100_NEGATIVE = CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_NEGATIVE;\n+    private static final String PROXY_200_NEGATIVE = CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_NEGATIVE;\n+    private static final String SERVER_ZERO = CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_ZERO;\n+    private static final String PROXY_ZERO = CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_ZERO;\n+    private static final String SERVER_100 = CLIENT_HTTP_KEEP_ALIVE_TIME_SERVER_POSITIVE;\n+    private static final String PROXY_200 = CLIENT_HTTP_KEEP_ALIVE_TIME_PROXY_POSITIVE;\n+\n+   \/*\n+    * CONSTANTS A,B,C,D,E,NI,F,G,H,I represents ServerScenarios and is used as reference in below table\n+    * as SERVER_RESPONSE_CONSTANT_NAME\n+    *\/\n+    private static final String A = CONNECTION_KEEP_ALIVE_ONLY;\n+    private static final String B = CONNECTION_KEEP_ALIVE_WITH_TIMEOUT;\n+    private static final String C = PROXY_CONNECTION_KEEP_ALIVE_ONLY;\n+    private static final String D = PROXY_CONNECTION_KEEP_ALIVE_ONLY + NEW_LINE + CONNECTION_KEEP_ALIVE_ONLY;\n+    private static final String E = C + NEW_LINE + KEEP_ALIVE_PROXY_TIMEOUT;\n+    private static final String NI = \"NO_INPUT\";\n+    private static final String F = A + NEW_LINE + KEEP_ALIVE_TIMEOUT_NEG;\n+    private static final String G = A + NEW_LINE + KEEP_ALIVE_TIMEOUT_ZERO;\n+    private static final String H = C + NEW_LINE + KEEP_ALIVE_TIMEOUT_NEG;\n+    private static final String I = C + NEW_LINE + KEEP_ALIVE_TIMEOUT_ZERO;\n+\n+   \/*\n+    * There are 160 scenarios run by this program.\n+    * For every scenario there is mapping between serverScenarios[int],clientScenarios[int] and expectedOutput[int]\n+    *\n+    * serverScenarios[0] clientScenarios[0] expectedOutput[0]\n+    * serverScenarios[1] clientScenarios[1] expectedOutput[1]\n+    * serverScenarios[2] clientScenarios[2] expectedOutput[2]\n+    *\n+    * ...\n+    *\n+    * serverScenarios[159] cientScenarios[159] expectedOutput[159]\n+    *\n+    * whereas serverScenarios[int] is retrieved using getServerScenario(int)\n+    * whereas clientScenarios[int] is retrieved using clientScenario[getClientScenarioNumber[int]]\n+    * and\n+    * expectedOutput[int] is retrieved using expectedOuput[int] directly.\n+    *\n+    *\/\n+\n+   \/* Here is the complete table of server_response, client system properties input and expected cached timeout at client side *\/\n+   \/* ScNo  |  SERVER RESPONSE (SERVER_RESPONSE_CONSTANT_NAME)| CLIENT SYSTEM PROPERTIES INPUT (CLIENT_INPUT_CONSTANT_NAMES) | EXPECTED CACHED TIMEOUT AT CLIENT SIDE\n+    *****************************************************************************************************************************************\n+    *    0  |  Connection: keep-alive (A)                     | No Input Provided (NI)                       | Default Timeout set to 5\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    1  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=100 (SERVER_100)| Client Timeout set to 100\n+    *--------------------------------------------------------------------------------------------------------------------------\n+    *    2  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.proxy=200 (PROXY_200)  | Default Timeout set to 5\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    3  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=100 &&          |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=200              | Timeout set to 100\n+    *       |                                                 | (SERVER_100 && PROXY_200)                    |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    4  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=-100            | Default Timeout set to 5\n+    *       |                                                 | (SERVER_100_NEGATIVE)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    5  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.proxy=-200             | Default Timeout set to 5\n+    *       |                                                 | (PROXY_200_NEGATIVE)                         |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    6  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=-100 &&         |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=-200             | Default Timeout set to 5\n+    *       |                                                 | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)  |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    7  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=0               | Connection Closed Immediately\n+    *       |                                                 | (SERVER_ZERO)                                |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    8  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.proxy=0                | Default Timeout set to 5\n+    *       |                                                 | (PROXY_ZERO)                                 |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *    9  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=0 &&            |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=0                | Connection Closed Immediately\n+    *       |                                                 | (SERVER_ZERO && PROXY_ZERO)                  |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   10  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=0 &&            |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=-200             | Connection Closed Immediately\n+    *       |                                                 | (SERVER_ZERO && PROXY_200_NEGATIVE)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   11  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=-100 &&         |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=0                | Default Timeout set to 5\n+    *       |                                                 | (SERVER_100_NEGATIVE && PROXY_ZERO)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   12  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=100 &&          |\n+    *       |                                                 |  -Dhttp.keepAlive.time.proxy=0               | Timeout set to 100\n+    *       |                                                 | (SERVER_100 && PROXY_ZERO)                   |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   13  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=0 &&            |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=200              | Connection Closed Immediately\n+    *       |                                                 | (SERVER_ZERO && PROXY_200)                   |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   14  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=100 &&          |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=-200             | Timeout set to 100\n+    *       |                                                 | (SERVER_100 && PROXY_200_NEGATIVE)           |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   15  |  Connection: keep-alive (A)                     | -Dhttp.keepAlive.time.server=-100 &&         |\n+    *       |                                                 | -Dhttp.keepAlive.time.proxy=200              | Default Timeout set to 5\n+    *       |                                                 | (SERVER_100_NEGATIVE && PROXY_200)           |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   16  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | No Input Provided (NI)                   | Timeout set to 20\n+    *------------------------------------------------------------------------------------------------------------------------\n+    *   17  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=100         | Timeout set to 20\n+    *       |                                                     | (SERVER_100)                             |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   18  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.proxy=200          | Timeout set to 20\n+    *       |                                                     | (PROXY_200)                              |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   19  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=100 &&      |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=200          | Timeout set to 20\n+    *       |                                                     | (SERVER_100 && PROXY_200)                |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   20  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=-100        | Timeout set to 20\n+    *       |                                                     | (SERVER_100_NEGATIVE)                    |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   21  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.proxy=-200         | Timeout set to 20\n+    *       |                                                     | (PROXY_200_NEGATIVE)                     |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   22  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=-100 &&       |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=-200           | Timeout set to 20\n+    *       |                                                     | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   23  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=0      | Timeout set to 20\n+    *       |                                                     | (SERVER_ZERO)                       |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   24  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 20\n+    *       |                                                     | (PROXY_ZERO)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   25  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 20\n+    *       |                                                     | (SERVER_ZERO && PROXY_ZERO)         |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   26  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=-200    | Timeout set to 20\n+    *       |                                                     | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   27  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 20\n+    *       |                                                     | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   28  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 20\n+    *       |                                                     | (SERVER_100 && PROXY_ZERO)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   29  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 20\n+    *       |                                                     | (SERVER_ZERO && PROXY_200)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   30  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=-200    | Timeout set to 20\n+    *       |                                                     | (SERVER_100 && PROXY_200_NEGATIVE)  |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   31  |Connection: keep-alive\\r\\nKeep-alive: timeout=20 (B) |-Dhttp.keepAlive.time.server=-100 && |\n+    *       |                                                     |-Dhttp.keepAlive.time.proxy=200      | Timeout set to 20\n+    *       |                                                     | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   32  |Proxy-Connection: keep-alive (C)                     | No Input Provided (NI)              | Default timeout set to 60\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   33  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=100    | Default timeout set to 60\n+    *       |                                                     | (SERVER_100)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   34  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                     | (PROXY_200)                         |\n+    *--------------------------------------------------------------------------------------------------------------------------\n+    *   35  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                     | (SERVER_100 && PROXY_200)           |\n+    *--------------------------------------------------------------------------------------------------------------------------\n+    *   36  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=-100   | Default timeout set to 60\n+    *       |                                                     | (SERVER_100_NEGATIVE)               |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   37  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.proxy=-200    | Default timeout set to 60\n+    *       |                                                     | (PROXY_200_NEGATIVE)                |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   38  |Proxy-Connection: keep-alive (C)                     |-Dhttp.keepAlive.time.server=-100 &&       |\n+    *       |                                                     |-Dhttp.keepAlive.time.proxy=-200           | Default timeout set to 60\n+    *       |                                                     |(SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   39  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=0      | Default timeout set to 60\n+    *       |                                                     | (SERVER_ZERO)                       |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   40  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                     | (PROXY_ZERO)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   41  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                     | (SERVER_ZERO && PROXY_ZERO)         |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   42  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=-200    | Default timeout set to 60\n+    *       |                                                     | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *   43  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                     | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *   44  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                     | (SERVER_100 && PROXY_ZERO)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   45  |Proxy-Connection: keep-alive (C)                     | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                     | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                     | (SERVER_ZERO && PROXY_200)          |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   46  |Proxy-Connection: keep-alive (C)                     |-Dhttp.keepAlive.time.server=100 &&  |\n+    *       |                                                     |-Dhttp.keepAlive.time.proxy=-200     | Default timeout set to 60\n+    *       |                                                     | (SERVER_100 && PROXY_200_NEGATIVE)  |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   47  |Proxy-Connection: keep-alive (C)                     |-Dhttp.keepAlive.time.server=-100 && |\n+    *       |                                                     |-Dhttp.keepAlive.time.proxy=200      | Timeout set to 200\n+    *       |                                                     | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   48  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | No Input Provided (NI)              | Default timeout set to 60\n+    *-----------------------------------------------------------------------------------------------------------------------------\n+    *   49  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=100    | Default timeout set to 60\n+    *       |                                                         | (SERVER_100)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------\n+    *   50  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                         | (PROXY_200)                         |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   51  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                         | (SERVER_100 && PROXY_200)           |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   52  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=-100   | Default timeout set to 60\n+    *       |                                                         | (SERVER_100_NEGATIVE)               |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   53  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.proxy=-200    | Default timeout set to 60\n+    *       |                                                         | (PROXY_200_NEGATIVE)                |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   54  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=-100&&        |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200           | Default timeout set to 60\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   55  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=0      | Default timeout set to 60\n+    *       |                                                         | (SERVER_ZERO)                       |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   56  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (PROXY_ZERO)                        |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   57  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)         |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   58  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | Default timeout set to 60\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   59  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   60  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)          |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   61  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)          |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   62  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | default timeout set to 60\n+    *       |                                                         | (SERVER_100 && PROXY_200_NEGATIVE)  |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   63  |Connection:keep-alive\\r\\nProxy-connection:keep-alive (D) | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 200\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   64  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| No Input Provided (NI)              | Timeout set to 120\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   65  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=100    | Timeout set to 120\n+    *       |                                                         | (SERVER_100)                        |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   66  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.proxy=200     | Timeout set to 120\n+    *       |                                                         | (PROXY_200)                         |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   67  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 120\n+    *       |                                                         | (SERVER_100 && PROXY_200)           |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   68  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=-100   | Timeout set to 120\n+    *       |                                                         | (SERVER_100_NEGATIVE)               |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   69  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.proxy=-200    | Timeout set to 120\n+    *       |                                                         | (PROXY_200_NEGATIVE)                |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   70  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=-100 &&       |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200           | Timeout set to 120\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   71  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=0      | Timeout set to 120\n+    *       |                                                         | (SERVER_ZERO)                       |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   72  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.proxy=0       | Timeout set to 120\n+    *       |                                                         | (PROXY_ZERO)                        |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   73  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 120\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)         |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   74  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | Timeout set to 120\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   75  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 120\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   76  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 120\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   77  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 120\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   78  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=100 &&         |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200            | Timeout set to 120\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE) |\n+    *-------------------------------------------------------------------------------------------------------------------------------\n+    *   79  |Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120 (E)| -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | Timeout set to 120\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *-----------------------------------------------------------------------------------------------------------------------------\n+    *   80  |No Input (NI)                                            | No Input Provided (NI)              | default timeout set to 5\n+    *-----------------------------------------------------------------------------------------------------------------------------\n+    *   81  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=100    | Timeout set to 100\n+    *       |                                                         | (SERVER_100)                        |\n+    *-----------------------------------------------------------------------------------------------------------------------------\n+    *   82  |No Input (NI)                                            | -Dhttp.keepAlive.time.proxy=200     | default timeout set to 5\n+    *       |                                                         | (PROXY_200)                         |\n+    *-----------------------------------------------------------------------------------------------------------------------------\n+    *   83  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | client timeot set to 100\n+    *       |                                                         | (SERVER_100 && PROXY_200)           |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   84  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=-100   | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE)               |\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   85  |No Input (NI)                                            | -Dhttp.keepAlive.time.proxy=-200    | default timeout set to 5\n+    *       |                                                         | (PROXY_200_NEGATIVE)                |\n+    *----------------------------------------------------------------------------------------------------------------------------\n+    *   86  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=-100 &&       |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200           | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *------------------------------------------------------------------------------------------------------------------------------\n+    *   87  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=0      | close connection immediately\n+    *       |                                                         | (SERVER_ZERO)                       |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *   88  |No Input (NI)                                            | -Dhttp.keepAlive.time.proxy=0       | default timeout set to 5\n+    *       |                                                         | (PROXY_ZERO)                        |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *   89  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)         |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *   90  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   91  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   92  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | Timeout set to 100\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)          |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   93  |No Input (NI)                                            | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)          |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   94  |No Input (NI)                                            |-Dhttp.keepAlive.time.server=100 &&  |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200     | Timeout set to 100\n+    *       |                                                         | (SERVER_100 && PROXY_200_NEGATIVE)  |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   95  |No Input (NI)                                            |-Dhttp.keepAlive.time.server=-100 && |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=200      | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   96  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    | No Input Provided (NI)              | default timeout set to 5\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   97  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=100     | Timeout set to 100\n+    *       |                                                         | (SERVER_100)                        |\n+    *--------------------------------------------------------------------------------------------------------------------------------\n+    *   98  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.proxy=200      | default timeout set to 5\n+    *       |                                                         | (PROXY_200)                         |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *   99  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=100 &&  |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=200      | Timeout set to 100\n+    *       |                                                         |(SERVER_100 && PROXY_200)            |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  100  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=-100    | default timeout set to 5\n+    *       |                                                         |(SERVER_100_NEGATIVE)                |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  101  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.proxy=-200     | default timeout set to 5\n+    *       |                                                         |(PROXY_200_NEGATIVE)                 |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  102  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=-100 &&        |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200            | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  103  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=0       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO)                       |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  104  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.proxy=0        | default timeout set to 5\n+    *       |                                                         | (PROXY_ZERO)                        |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  105  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=0 &&    |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)         |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  106  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=0 &&    |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200     | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO_NEGATIVE)|\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  107  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=-100 && |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=0        | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  108  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=100 &&  |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=0        | Timeout set to 100\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  109  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=0 &&    |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=200      | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  110  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=100 &&  |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200     | Timeout set to 100\n+    *       |                                                         |(SERVER_100 && PROXY_200_NEGATIVE)   |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  111  |Connection: keep-alive\\r\\nKeep-alive: timeout=-20 (F)    |-Dhttp.keepAlive.time.server=-100 && |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=200      | default timeout set to 5\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  112  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | No Input Provided (NI)              | close connection immediately\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  113  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=100    | close connection immediately\n+    *       |                                                         | (SERVER_100)                        |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  114  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.proxy=200     | close connection immediately\n+    *       |                                                         | (PROXY_200)                         |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  115  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_200)           |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  116  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=-100   | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE)               |\n+    *------------------------------------------------------------------------------------------------------------------------------------\n+    *  117  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.proxy=-200    | close connection immediately\n+    *       |                                                         | (PROXY_200_NEGATIVE)                |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  118  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      |-Dhttp.keepAlive.time.server=-100 &&         |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200             | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE) |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  119  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=0      | close connection immediately\n+    *       |                                                         | (SERVER_ZERO)                       |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  120  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (PROXY_ZERO)                        |\n+    *------------------------------------------------------------------------------------------------------------------------------------\n+    *  121  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)         |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  122  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE) |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  123  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO) |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  124  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0       | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  125  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=0 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)          |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  126  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=100 && |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200    | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_200_NEGATIVE)  |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  127  |Connection: keep-alive\\r\\nKeep-alive: timeout=0 (G)      | -Dhttp.keepAlive.time.server=-100 &&|\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200     | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)  |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  128  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| No Input Provided (NI)                | default timeout set to 60\n+    ---------------------------------------------------------------------------------------------------------------------------------------\n+    *  129  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=100      | default timeout set to 60\n+    *       |                                                         | (SERVER_100)                          |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  130  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.proxy=200       | Timeout set to 200\n+    *       |                                                         | (PROXY_200)                           |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  131  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=100 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200       | Timeout set to 200\n+    *       |                                                         | (SERVER_100 && PROXY_200)             |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  132  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=-100     | default timeout set to 60\n+    *       |                                                         | (SERVER_100_NEGATIVE)                 |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  133  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.proxy=-200      | default timeout set to 60\n+    *       |                                                         | (PROXY_200_NEGATIVE)                  |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  134  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)|-Dhttp.keepAlive.time.server=-100 &&        |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200            | default timeout set to 60\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE)|\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *  135  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=0        | default timeout set to 60\n+    *       |                                                         | (SERVER_ZERO)                         |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  136  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (PROXY_ZERO)                          |\n+    *----------------------------------------------------------------------------------------------------------------------------------\n+    *  137  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)           |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  138  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200      | default timeout set to 60\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE)   |\n+    *---------------------------------------------------------------------------------------------------------------------------------------\n+    *  139  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=-100 &&  |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO)   |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  140  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=100 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)            |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  141  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)| -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200       | Timeout set to 20\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)            |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  142  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)|-Dhttp.keepAlive.time.server=100 &&    |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=-200       | default timeout set to 60\n+    *       |                                                         | (SERVER_100 && PROXY_200_NEGATIVE)    |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  143  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=-20 (H)|-Dhttp.keepAlive.time.server=-100 &&   |\n+    *       |                                                         |-Dhttp.keepAlive.time.proxy=200        | Timeout set to 200\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)    |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  144  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | No Input Provided (NI)                | close connection immediately\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  145  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=100      | close connection immediately\n+    *       |                                                         | (SERVER_100)                          |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  146  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.proxy=200       | close connection immediately\n+    *       |                                                         | (PROXY_200)                           |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  147  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=100 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200       | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_200)             |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  148  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=-100     | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE)                 |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  149  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.proxy=-200      | close connection immediately\n+    *       |                                                         | (PROXY_200_NEGATIVE)                  |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  150  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=-100 &&        |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200            | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200_NEGATIVE) |\n+    *------------------------------------------------------------------------------------------------------------------------------------\n+    *  151  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=0        | close connection immediately\n+    *       |                                                         | (SERVER_ZERO)                         |\n+    *-----------------------------------------------------------------------------------------------------------------------------------\n+    *  152  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (PROXY_ZERO)                          |\n+    *---------------------------------------------------------------------------------------------------------------------------------\n+    *  153  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_ZERO)           |\n+    *------------------------------------------------------------------------------------------------------------------------------------\n+    *  154  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200      | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200_NEGATIVE)   |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  155  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=-100 &&  |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_ZERO)   |\n+    *-------------------------------------------------------------------------------------------------------------------------------------\n+    *  156  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=100 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=0         | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_ZERO)            |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  157  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=0 &&     |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200       | close connection immediately\n+    *       |                                                         | (SERVER_ZERO && PROXY_200)            |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  158  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=100 &&   |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=-200      | close connection immediately\n+    *       |                                                         | (SERVER_100 && PROXY_200_NEGATIVE)    |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *  159  |Proxy-Connection:keep-alive\\r\\nKeep-alive:timeout=0 (I)  | -Dhttp.keepAlive.time.server=-100 &&  |\n+    *       |                                                         | -Dhttp.keepAlive.time.proxy=200       | close connection immediately\n+    *       |                                                         | (SERVER_100_NEGATIVE && PROXY_200)    |\n+    *--------------------------------------------------------------------------------------------------------------------------------------\n+    *\/\n+\n+   \/* private static final String[] serverScenarios = {\n+        A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A,\n+        B, B, B, B, B, B, B, B, B, B,B, B, B, B, B, B,\n+        C, C, C, C, C, C, C, C, C, C, C, C, C, C, C, C,\n+        D, D, D, D, D, D, D, D, D, D, D, D, D, D, D, D,\n+        E, E, E, E, E, E, E, E, E, E, E, E, E, E, E, E,\n+        NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI, NI,\n+        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F,\n+        G, G, G, G, G, G, G, G, G, G, G, G, G, G, G, G,\n+        H, H, H, H, H, H, H, H, H, H, H, H, H, H, H, H,\n+        I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I\n+    }; *\/\n+    \/*\n+     * following are client scenarios which are repeated.\n+     *\/\n+    private static final String[] a = {\n+        NI, SERVER_100,     PROXY_200, SERVER_100 + CLIENT_SEPARATOR + PROXY_200,    SERVER_100_NEGATIVE,\n+        PROXY_200_NEGATIVE, SERVER_100_NEGATIVE + CLIENT_SEPARATOR + PROXY_200_NEGATIVE,\n+        SERVER_ZERO,         PROXY_ZERO, SERVER_ZERO + CLIENT_SEPARATOR + PROXY_ZERO,\n+        SERVER_ZERO + CLIENT_SEPARATOR + PROXY_200_NEGATIVE, SERVER_100_NEGATIVE + CLIENT_SEPARATOR + PROXY_ZERO,\n+        SERVER_100 + CLIENT_SEPARATOR + PROXY_ZERO, SERVER_ZERO + CLIENT_SEPARATOR + PROXY_200,\n+        SERVER_100 + CLIENT_SEPARATOR + PROXY_200_NEGATIVE, SERVER_100_NEGATIVE + CLIENT_SEPARATOR + PROXY_200\n+    };\n+\n+   \/* private String[] clientScenarios = {\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15],\n+    }; *\/\n+\n+    private static final String[] clientScenarios = {\n+        a[0] , a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]\n+    };\n+\n+    private static final int[] expectedValues = {\n+        5,  100,    5, 100,  5,  5,  5,  0,  5,   0,   0,   5,  100,    0,   100,    5,\n+        20,   20 ,  20,  20, 20, 20, 20, 20, 20,  20 , 20,  20,   20,   20,    20,   20,\n+        60,   60,  200, 200, 60, 60, 60, 60,  0,   0,  60,   0,    0,  200,    60,  200,\n+        60,   60,  200, 200, 60, 60, 60, 60,  0,   0,  60,   0,    0,  200,    60,  200,\n+        120, 120,  120, 120,120,120,120,120,120, 120, 120, 120,  120,  120,   120,  120,\n+        5,  100,    5, 100,  5,  5,  5,  0,  5,   0,   0,   5,  100,    0,   100,    5,\n+        5,  100,    5, 100,  5,  5,  5,  0,  5,   0,   0,   5,  100,    0,   100,    5,\n+        0,    0,    0,   0,  0,  0,  0,  0,  0,   0,   0,   0,    0,    0,     0,    0,\n+        60,  60,  200, 200, 60, 60, 60, 60,  0,   0,  60,   0,    0,  200,    60,  200,\n+        0,    0,    0,   0,  0,  0,  0,  0,  0,   0,   0,   0,    0,    0,     0,    0,\n+    };\n+\n+    private final CountDownLatch countDownLatch = new CountDownLatch(1);\n+\n+    private final CountDownLatch serverCountDownLatch = new CountDownLatch(1);\n+\n+    \/*\n+     * setting of client properties -Dhttp.keepAlive.time.server and -Dhttp.keepAlive.time.proxy is handled through this method.\n+     * There are 16 client scenarios in total starting with scenarioNumber 0(zero) and ending with 15.\n+     * Server Scenarios are grouped into batch of 16 scenarios.\n+     * There are 10 batches in total and each batch contains 16 scenarios so 10 * 16 = 160 scenarios in total.\n+     * 16 Client Scenarios are used repeatedly for every server scenario batch.\n+     * for serverscenario[0],serverscenario[16],serverscenario[32] ... serverscenario[144] is mapped to clientscenario[0]\n+     * for serverscenario[1],serverscenario[17],serverscenario[33] ... serverscenario[145] is mapped to clientscenario[1]\n+     * for serverscenario[2],serverscenario[18],serverscenario[34] ... serverscenario[146] is mapped to clientscenario[2]\n+     * ...\n+     * for serverscenario[15],serverscenario[31],serverscenario[47] ... serverscenario[159] is mapped to clientscenario[15]\n+     *\/\n+    private int getClientScenarioNumber(int scenarioNumber) {\n+        return scenarioNumber % 16 ;\n+    }\n+\n+    \/*\n+     * Returns SERVER_RESPONSE as String based on integer inputParameter scenarioNumber.\n+     * Server Scenarios are grouped into batch of 16 scenarios starting with scenarioNumber 0 (zero)\n+     * so there are 10 batches in total and each batch contains 16 scenarios so 10 * 16 = 160 scenarios in total.\n+     * For each batch of 16 scenarios, there will be common SERVER_RESPONSE for all 16 scenarios in batch.\n+     * for scenario numbers from 0 to 15 server  response is: Connection:keep-alive\n+     * for scenario numbers from 16 to 31 server response is: SERVER_RESPONSE=Connection: keep-alive\\r\\nKeep-alive: timeout=20\n+     * for scenario numbers from 32 to 47 server response is: SERVER_RESPONSE=Proxy-Connection: keep-alive\n+     * for scenario numbers from 48 to 63 server response is: SERVER_RESPONSE=Connection:keep-alive\\r\\nProxy-connection:keep-alive\n+     * for scenario numbers from 64 to 79 server response is: SERVER_RESPONSE=Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120\n+     * for scenario numbers from 80 to 95 server response is: SERVER_RESPONSE=No Input\n+     * for scenario numbers from 96 to 111 server response is: SERVER_RESPONSE=Connection: keep-alive\\r\\nKeep-alive: timeout=-20\n+     * for scenario numbers from 112 to 127 server resonse is: Connection: keep-alive\\r\\nKeep-alive: timeout=0\n+     * for scenario numbers from 128 to 143 server response is: Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=-20\n+     * for scenario numbers from 144 to 159 server response is: Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=0\n+     *\/\n+    private String getServerScenario(int scenarioNumber) {\n+        \/*\n+         *  ServerResponse for scenarios from 0 to 15\n+         *  SERVER_RESPONSE:Connection:keep-alive\n+         *\/\n+        if(scenarioNumber >= 0 && scenarioNumber <= 15) {\n+            return A;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 16 to 31\n+         * SERVER_RESPONSE=Connection: keep-alive\\r\\nKeep-alive: timeout=20\n+         *\/\n+        else if (scenarioNumber >= 16 && scenarioNumber <= 31){\n+            return B;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 32 to 47\n+         * SERVER_RESPONSE=Proxy-Connection: keep-alive\n+         *\/\n+        else if (scenarioNumber >= 32 && scenarioNumber <= 47){\n+            return C;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 48 to 63\n+         * SERVER_RESPONSE=Connection:keep-alive\\r\\nProxy-connection:keep-alive\n+         *\/\n+        else if (scenarioNumber >= 48 && scenarioNumber <= 63){\n+            return D;\n+        \/*\n+         * ServerResponse for scenarios from 64 to 79\n+         * SERVER_RESPONSE=Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=120\n+         *\/\n+        } else if (scenarioNumber >= 64 && scenarioNumber <= 79){\n+            return E;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 80 to 95\n+         * SERVER_RESPONSE=No Input\n+         *\/\n+        else if (scenarioNumber >= 80 && scenarioNumber <= 95){\n+            return NI;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 96 to 111\n+         * SERVER_RESPONSE=Connection: keep-alive\\r\\nKeep-alive: timeout=-20\n+         *\/\n+        else if (scenarioNumber >= 96 && scenarioNumber <= 111){\n+            return F;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 112 to 127\n+         * SERVER_RESPONSE=Connection: keep-alive\\r\\nKeep-alive: timeout=0\n+         *\/\n+        else if (scenarioNumber >= 112 && scenarioNumber <= 127){\n+            return G;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 128 to 143\n+         * SERVER_RESPONSE=Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=-20\n+         *\/\n+        else if (scenarioNumber >= 128 && scenarioNumber <= 143){\n+            return H;\n+        }\n+        \/*\n+         * ServerResponse for scenarios from 144 to 159\n+         * SERVER_RESPONSE=Proxy-connection:keep-alive\\r\\nKeep-alive:timeout=0\n+         *\/\n+        else if (scenarioNumber >= 144 && scenarioNumber <= 159){\n+            return I;\n+        }\n+        \/*Invalid Case*\/\n+        return null;\n+    }\n+\n+    private void startScenario(int scenarioNumber) throws Exception {\n+        System.out.println(\"serverScenarios[\" + scenarioNumber + \"]=\" + getServerScenario(scenarioNumber));\n+        System.out.println(\"clientScenarios[\" + scenarioNumber + \"]=\" + clientScenarios[getClientScenarioNumber(scenarioNumber)]);\n+        if(expectedValues[scenarioNumber] == 0) {\n+            System.out.println(\"ExpectedOutput=\" + NOT_CACHED);\n+        } else {\n+            System.out.println(\"ExpectedOutput=\" + expectedValues[scenarioNumber]);\n+        }\n+        System.out.println();\n+        startServer(scenarioNumber);\n+        runClient(scenarioNumber);\n+    }\n+\n+    private void startServer(int scenarioNumber) {\n+        Thread server = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                   executeServer(scenarioNumber);\n+                } catch (IOException e) {\n+                   e.printStackTrace();\n+                }\n+            }\n+        }, \"SERVER\");\n+        server.start();\n+    }\n+\n+    private void readAll(Socket s) throws IOException {\n+        byte[] buf = new byte[128];\n+        int c;\n+        String request = \"\";\n+        InputStream is = s.getInputStream();\n+        while ((c = is.read(buf)) > 0) {\n+            request += new String(buf, 0, c, StandardCharsets.US_ASCII);\n+            if (request.contains(\"\\r\\n\\r\\n\")) {\n+                return;\n+            }\n+        }\n+        if (c == -1) {\n+            throw new IOException(\"Socket closed\");\n+        }\n+    }\n+\n+    private void executeServer(int scenarioNumber) throws IOException {\n+        String serverScenarioContent = null;\n+        if (!getServerScenario(scenarioNumber).equalsIgnoreCase(NI)) {\n+            serverScenarioContent = getServerScenario(scenarioNumber) + NEW_LINE;\n+            \/*\n+             * isProxySet should be set before Server is moved to Listen State.\n+             *\/\n+            if (serverScenarioContent.contains(\"Proxy\")) {\n+                isProxySet = true;\n+            } else {\n+                isProxySet = false;\n+            }\n+        }\n+        ServerSocket serverSocket = null;\n+        Socket socket = null;\n+        OutputStreamWriter out = null;\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        try {\n+            serverSocket = new ServerSocket();\n+            serverSocket.bind(new InetSocketAddress(loopback, 0));\n+            SERVER_PORT = serverSocket.getLocalPort();\n+            \/\/serverReady = true;\n+            this.serverCountDownLatch.countDown();\n+            System.out\n+                .println(\"SERVER_PORT= \" + SERVER_PORT +\" isProxySet=\" + isProxySet);\n+            \/*\n+             * Server will be waiting for clients to connect.\n+             *\/\n+            socket = serverSocket.accept();\n+            readAll(socket);\n+            out = new OutputStreamWriter(socket.getOutputStream());\n+            String BODY = \"SERVER REPLY: Hello world\";\n+            String CLEN = \"Content-Length: \" + BODY.length() + NEW_LINE;\n+            \/* send the header *\/\n+            out.write(\"HTTP\/1.1 200 OK\\r\\n\");\n+            out.write(\"Content-Type: text\/plain; charset=iso-8859-1\\r\\n\");\n+            \/*\n+             * append each scenario content from array.\n+             *\/\n+            if(serverScenarioContent != null) {\n+                out.write(serverScenarioContent);\n+            }\n+            out.write(CLEN);\n+            out.write(NEW_LINE);\n+            out.write(BODY);\n+            out.flush();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        } finally {\n+            if (out != null) {\n+                out.flush();\n+                out.close();\n+            }\n+            if (socket != null) {\n+                socket.close();\n+            }\n+            if (serverSocket != null) {\n+                serverSocket.close();\n+            }\n+        }\n+    }\n+\n+    private void runClient(int scenarioNumber) throws Exception {\n+        try {\n+            connectToServerURL(scenarioNumber);\n+        } finally {\n+            System.out.println(\"client count down latch:\" + scenarioNumber);\n+            this.countDownLatch.countDown();\n+            System.out.println();\n+            System.out.println();\n+        }\n+    }\n+\n+    private void connectToServerURL(int scenarioNumber) throws Exception {\n+        \/\/    System.setProperty(\"java.net.useSystemProxies\", \"false\");\n+        \/\/    System.setProperty(\"http.nonProxyHosts\", \"\");\n+        \/\/    System.setProperty(\"http.proxyHost\", \"localhost\");\n+        \/\/    System.setProperty(\"http.proxyPort\", String.valueOf(SERVER_PORT));\n+        System.out.println(\"Following are Existing System Properties if set any\");\n+        System.out.println(\"http.keepAlive.time.server:\" + System.getProperty(\"http.keepAlive.time.server\"));\n+        System.out.println(\"http.keepAlive.time.proxy:\" + System.getProperty(\"http.keepAlive.time.proxy\"));\n+        System.setProperty(\"java.net.useSystemProxies\", \"false\");\n+        System.out.println(\"http.proxyPort:\"+System.getProperty(\"http.proxyPort\"));\n+        System.out.println(\"http.proxyHost:\"+System.getProperty(\"http.proxyHost\"));\n+        System.clearProperty(\"http.keepAlive.time.server\");\n+        System.clearProperty(\"http.keepAlive.time.proxy\");\n+        \/\/ fetch clientScenearios for each scenarioNumber from array and set it to\n+        \/\/ System property.\n+        if (!clientScenarios[getClientScenarioNumber(scenarioNumber)].equalsIgnoreCase(NI)) {\n+            System.out.println(\"Client Input Parsing\");\n+            for (String clientScenarioString : clientScenarios[getClientScenarioNumber(scenarioNumber)].split(CLIENT_SEPARATOR)) {\n+                System.out.println(clientScenarioString);\n+                String key = clientScenarioString.split(\"=\")[0];\n+                String value = clientScenarioString.split(\"=\")[1];\n+                System.setProperty(key, value);\n+            }\n+        }\n+        \/\/ wait until ServerSocket moves to listening state.\n+        this.serverCountDownLatch.await();\n+        System.out.println(\"client started\");\n+        URL url = URIBuilder.newBuilder().scheme(\"http\").loopback().port(SERVER_PORT).toURL();\n+        System.out.println(\"connecting from client to SERVER URL:\" + url);\n+        HttpURLConnection httpUrlConnection = null;\n+        \/*\n+         * isProxySet is set to true when Expected Server Response contains Proxy-Connection header.\n+         *\/\n+        if (isProxySet) {\n+            httpUrlConnection = (sun.net.www.protocol.http.HttpURLConnection) url\n+                .openConnection(new Proxy(Type.HTTP, new InetSocketAddress(\"localhost\", SERVER_PORT)));\n+        } else {\n+            httpUrlConnection = (sun.net.www.protocol.http.HttpURLConnection) url.openConnection();\n+        }\n+        InputStreamReader inputStreamReader = new InputStreamReader(httpUrlConnection.getInputStream());\n+        BufferedReader bufferedReader = null;\n+        try {\n+            bufferedReader = new BufferedReader(inputStreamReader);\n+            while (true) {\n+                String eachLine = bufferedReader.readLine();\n+                if (eachLine == null) {\n+                    break;\n+                }\n+                System.out.println(eachLine);\n+            }\n+        } finally {\n+            if (bufferedReader != null) {\n+                bufferedReader.close();\n+            }\n+        }\n+        \/\/    System.out.println(\"ResponseCode:\" + httpUrlConnection.getResponseCode());\n+        \/\/    System.out.println(\"ResponseMessage:\" + httpUrlConnection.getResponseMessage());\n+        \/\/    System.out.println(\"Content:\" + httpUrlConnection.getContent());\n+        \/\/    Thread.sleep(2000);\n+        for (Entry<String, List<String>> header : httpUrlConnection.getHeaderFields().entrySet()) {\n+            System.out.println(header.getKey() + \"=\" + header.getValue());\n+        }\n+        fetchInfo(scenarioNumber, httpUrlConnection);\n+    }\n+\n+    private void fetchInfo(int scenarioNumber, sun.net.www.protocol.http.HttpURLConnection httpUrlConnection)\n+        throws Exception {\n+       Field field = Class.forName(\"sun.net.www.protocol.http.HttpURLConnection\").getDeclaredField(\"http\");\n+       field.setAccessible(true);\n+       HttpClient httpClient = (HttpClient) field.get(httpUrlConnection);\n+       \/\/    System.out.println(\"httpclient=\" + httpClient);\n+       Field keepAliveField = Class.forName(\"sun.net.www.http.HttpClient\").getDeclaredField(\"kac\");\n+       keepAliveField.setAccessible(true);\n+       KeepAliveCache keepAliveCache = (KeepAliveCache) keepAliveField.get(httpClient);\n+       System.out.println(\"keepAliveCache\" + keepAliveCache);\n+       System.out.println(\"SERVER URL:\" + httpUrlConnection.getURL());\n+       \/*\n+        * create KeepAliveKey(URL,Object) object and compare created KeepAliveKey and\n+        * existing using equals() method: KeepAliveKey.equals()\n+        *\/\n+       Class keepAliveKeyClass = Class.forName(\"sun.net.www.http.KeepAliveKey\");\n+       \/\/    System.out.println(\"keepAliveKeyClass=\" + keepAliveKeyClass);\n+       Constructor keepAliveKeyClassconstructor = keepAliveKeyClass.getDeclaredConstructors()[0];\n+       keepAliveKeyClassconstructor.setAccessible(true);\n+       Object expectedKeepAliveKey = keepAliveKeyClassconstructor.newInstance(httpUrlConnection.getURL(), null);\n+       System.out.println(\"ExpectedKeepAliveKey=\" + expectedKeepAliveKey);\n+       Object clientVectorObjectInMap = keepAliveCache.get(expectedKeepAliveKey);\n+       System.out.println(\"ClientVector=\" + clientVectorObjectInMap);\n+       HttpClient httpClientCached = keepAliveCache.get(httpUrlConnection.getURL(), null);\n+       System.out.println(\"HttpClient in Cache:\" + httpClientCached);\n+       if(httpClientCached != null) {\n+            System.out.println(\"KeepingAlive:\" + httpClientCached.isKeepingAlive());\n+            System.out.println(\"UsingProxy:\" + httpClientCached.getUsingProxy());\n+            System.out.println(\"ProxiedHost:\" + httpClientCached.getProxyHostUsed());\n+            System.out.println(\"ProxiedPort:\" + httpClientCached.getProxyPortUsed());\n+            System.out.println(\"ProxyPortUsingSystemProperty:\" + System.getProperty(\"http.proxyPort\"));\n+            System.out.println(\"ProxyHostUsingSystemProperty:\" + System.getProperty(\"http.proxyHost\"));\n+            System.out.println(\"http.keepAlive.time.server=\" + System.getProperty(\"http.keepAlive.time.server\"));\n+            System.out.println(\"http.keepAlive.time.proxy=\" + System.getProperty(\"http.keepAlive.time.proxy\"));\n+            Class clientVectorClass = Class.forName(\"sun.net.www.http.ClientVector\");\n+            \/\/      System.out.println(\"clientVectorClass=\" + clientVectorClass);\n+            Field napField = clientVectorClass.getDeclaredField(\"nap\");\n+            napField.setAccessible(true);\n+            int napValue = (int) napField.get(clientVectorObjectInMap);\n+            int actualValue = napValue \/ 1000;\n+            \/\/      System.out.println(\"nap=\" + napValue \/ 1000);\n+            System.out.printf(\"ExpectedOutput:%d ActualOutput:%d \", expectedValues[scenarioNumber], actualValue);\n+            System.out.println();\n+            if (expectedValues[scenarioNumber] != actualValue) {\n+                throw new RuntimeException(\n+                            \"ExpectedOutput:\" + expectedValues[scenarioNumber] + \" ActualOutput: \" + actualValue);\n+            }\n+        } else {\n+            \/\/executed when value is not cached.\n+            String expected = expectedValues[scenarioNumber] == 0 ? NOT_CACHED\n+                    : String.valueOf(expectedValues[scenarioNumber]);\n+            System.out.println(\"ExpectedOutput:\" + expected + \" ActualOutput:\" + NOT_CACHED);\n+            if (!expected.equalsIgnoreCase(NOT_CACHED)) {\n+                    throw new RuntimeException(\"ExpectedOutput:\" + expected + \" ActualOutput:\" + NOT_CACHED);\n+            }\n+       }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException(\"Usage:java KeepAliveTest.java <scenarioNumber>\");\n+        }\n+        logger.setLevel(Level.FINEST);\n+        ConsoleHandler h = new ConsoleHandler();\n+        h.setLevel(Level.FINEST);\n+        logger.addHandler(h);\n+        KeepAliveTest keepAliveTest = new KeepAliveTest();\n+        if (args.length != 0) {\n+            keepAliveTest.startScenario(Integer.valueOf(args[0]));\n+        }\n+        \/\/ make main thread wait until server and client is completed.\n+        keepAliveTest.countDownLatch.await();\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/KeepAliveTest.java","additions":1272,"deletions":0,"binary":false,"changes":1272,"status":"added"},{"patch":"@@ -11,10 +11,0 @@\n-\t\/\/ Allows any thread to stop itself using the java.lang.Thread.stop()\n-\t\/\/ method that takes no argument.\n-\t\/\/ Note that this permission is granted by default only to remain\n-\t\/\/ backwards compatible.\n-\t\/\/ It is strongly recommended that you either remove this permission\n-\t\/\/ from this policy file or further restrict it to code sources\n-\t\/\/ that you specify, because Thread.stop() is potentially unsafe.\n-\t\/\/ See \"http:\/\/java.sun.com\/notes\" for more information.\n-\tpermission java.lang.RuntimePermission \"stopThread\";\n-\n","filename":"test\/jdk\/sun\/net\/www\/http\/HttpClient\/OpenServer.policy","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8151788\n+ * @bug 8151788 8286526\n@@ -45,1 +45,1 @@\n-        byte[] nonce = new byte[10];\n+        byte[] nonce = new byte[8];\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/http\/NULLTargetInfoTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6316539 8136355\n+ * @bug 6316539 8136355 8294906\n@@ -80,0 +80,1 @@\n+            String hashAlgorithm = null; \/\/ TLS1.2+ only\n@@ -113,0 +114,2 @@\n+                } else if (line.startsWith(\"km-hashalg:\")) {\n+                    hashAlgorithm = data;\n@@ -138,1 +141,3 @@\n-                        KeyGenerator.getInstance(\"SunTlsKeyMaterial\", provider);\n+                        KeyGenerator.getInstance(minor == 3 ?\n+                                \"SunTls12KeyMaterial\" :\n+                                \"SunTlsKeyMaterial\", provider);\n@@ -141,0 +146,1 @@\n+                    \/\/ prfHashLength and prfBlockSize are ignored by PKCS11 provider\n@@ -145,1 +151,1 @@\n-                        null, -1, -1);\n+                        hashAlgorithm, -1 \/*ignored*\/, -1 \/*ignored*\/);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/TestKeyMaterial.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3649,0 +3649,34 @@\n+km-master:  f1:05:15:45:33:be:50:d6:88:0b:03:bb:88:9b:ef:d4:3b:98:aa:40:13:71:3c:1c:d9:df:34:c7:50:75:ad:5c:0a:d4:fe:ed:d5:58:6b:ff:2b:ce:c6:12:bc:6b:7e:dc\n+km-major:   3\n+km-minor:   3\n+km-crandom: 42:f3:36:8e:9d:c9:69:3e:c1:8a:38:d3:e0:ec:2b:58:c2:e0:0c:de:4f:f3:af:51:d2:5c:bc:b2:c3:3b:1e:56\n+km-srandom: 42:f3:36:8e:fa:fd:23:3e:fd:f9:bc:88:3c:98:93:f3:c3:1d:9c:2a:4a:3b:02:a7:40:d4:64:04:59:e9:65:97\n+km-cipalg:  AES\n+km-hashalg: SHA-256\n+km-keylen:  16\n+km-explen:  0\n+km-ivlen:   4\n+km-maclen:  0\n+km-ccipkey: 60:7a:45:a9:6e:76:58:ea:d9:44:c5:25:f8:92:f1:26\n+km-scipkey: 42:c0:ed:75:a2:51:21:7c:50:74:9d:78:9a:f7:35:2b\n+km-civ:     a1:3c:3e:4a\n+km-siv:     85:ab:ee:70\n+km-cmackey: (null)\n+km-smackey: (null)\n+km-master:  f1:05:15:45:33:be:50:d6:88:0b:03:bb:88:9b:ef:d4:3b:98:aa:40:13:71:3c:1c:d9:df:34:c7:50:75:ad:5c:0a:d4:fe:ed:d5:58:6b:ff:2b:ce:c6:12:bc:6b:7e:dc\n+km-major:   3\n+km-minor:   3\n+km-crandom: 42:f3:36:8e:9d:c9:69:3e:c1:8a:38:d3:e0:ec:2b:58:c2:e0:0c:de:4f:f3:af:51:d2:5c:bc:b2:c3:3b:1e:56\n+km-srandom: 42:f3:36:8e:fa:fd:23:3e:fd:f9:bc:88:3c:98:93:f3:c3:1d:9c:2a:4a:3b:02:a7:40:d4:64:04:59:e9:65:97\n+km-cipalg:  AES\n+km-hashalg: SHA-384\n+km-keylen:  32\n+km-explen:  0\n+km-ivlen:   4\n+km-maclen:  0\n+km-ccipkey: 3c:03:17:61:1e:88:4a:aa:01:4c:ac:6c:f8:bb:91:c3:0e:ec:57:c7:bf:07:ff:eb:49:22:f9:80:12:64:72:2a\n+km-scipkey: f8:00:8e:b2:dc:25:98:f1:97:00:55:28:60:a3:65:da:42:89:18:bb:40:94:53:d2:75:2a:29:e5:aa:94:1d:7a\n+km-civ:     24:02:76:6f\n+km-siv:     3b:6d:33:5a\n+km-cmackey: (null)\n+km-smackey: (null)\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/keymatdata.txt","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @bug 8274736\n+ * @bug 8274736 8277970\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/NoInvalidateSocketException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 4348369 8076069\n- * @summary keytool not i18n compliant\n+ * @bug 4348369 8076069 8294994\n+ * @summary keytool i18n compliant\n@@ -29,1 +29,3 @@\n- * @run main\/manual i18n\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @library \/test\/lib\n+ * @run main\/manual\/othervm -Duser.language=en i18n\n@@ -32,1 +34,323 @@\n-import java.nio.file.Path;\n+\/*\n+ * @test\n+ * @bug 4348369 8076069 8294994\n+ * @summary keytool i18n compliant\n+ * @author charlie lai\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @library \/test\/lib\n+ * @run main\/manual\/othervm -Duser.language=de i18n\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4348369 8076069 8294994\n+ * @summary keytool i18n compliant\n+ * @author charlie lai\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @library \/test\/lib\n+ * @run main\/manual\/othervm -Duser.language=ja i18n\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4348369 8076069 8294994\n+ * @summary keytool i18n compliant\n+ * @author charlie lai\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @library \/test\/lib\n+ * @run main\/manual\/othervm -Duser.language=zh -Duser.country=CN i18n\n+ *\/\n+\n+import jdk.test.lib.UIBuilder;\n+\n+import javax.swing.*;\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.util.Locale;\n+\n+public class i18n {\n+    private static final String[][] TABLE = new String[][]{\n+            {\"-help\", \"All the output in this test should be in ${LANG}. \"\n+                    + \"Otherwise, the test failed.\"},\n+\n+            {\"-genkeypair -keyalg DSA -v -keysize 512 \"\n+                    + \"-dname cn=Name,ou=Java,o=Oracle,l=City,s=State,c=Country \"\n+                    + \"-storepass a \"\n+                    + \"-keypass a \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang.Exception: \"\n+                            + \"Keystore password must be at least 6 characters.\"},\n+\n+            {\"-genkeypair -keyalg DSA -v -keysize 512 \"\n+                    + \"-dname cn=Name,ou=Java,o=Oracle,l=City,s=State,c=Country \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: generated a 512 bit DSA key pair \"\n+                            + \"for CN=Name, OU=Java, O=Oracle, L=City, ST=State \"\n+                            + \"C=Country.\"},\n+\n+            {\"-list -v -storepass password -keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: contains 1 keystore entry with \"\n+                            + \"512-bit DSA key algorithm for CN=Name, OU=Java, \"\n+                            + \"O=Oracle, L=City, ST=State C=Country.\"},\n+\n+            {\"-list -v -storepass a -keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error:java.io.IOException: \"\n+                            + \"keystore password was incorrect.\"},\n+\n+            {\"-genkey -keyalg DSA -v -keysize 512 \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang.Exception: \"\n+                            + \"alias 'mykey' already exists.\"},\n+\n+            {\"-genkeypair -keyalg DSA -v -keysize 512 \"\n+                    + \"-dname cn=Name,ou=Java,o=Oracle,l=City,s=State,c=Country \"\n+                    + \"-alias mykey2 \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: generated a 512 bit DSA key pair \"\n+                            + \"for CN=Name, OU=Java, O=Oracle, L=City, ST=State \"\n+                            + \"C=Country.\"},\n+\n+            {\"-list -v -storepass password -keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: contains 2 keystore entries \"\n+                            + \"(alias name mykey & mykey2), both with 512-bit DSA\"\n+                            + \" key algorithm for CN=Name, OU=Java, O=Oracle, \"\n+                            + \"L=City, ST=State C=Country.\"},\n+\n+            {\"-keypasswd -v \"\n+                    + \"-alias mykey2 \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-new a \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang.Exception: \"\n+                            + \"New password must be at least 6 characters.\"},\n+\n+            {\"-keypasswd -v \"\n+                    + \"-alias mykey2 \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-new aaaaaa \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: -keypasswd \"\n+                            + \"commands not supported if -storetype is PKCS12.\"},\n+\n+            {\"-genkeypair -keyalg DSA -v -keysize 512 \"\n+                    + \"-dname cn=Name,ou=Java,o=Oracle,l=City,s=State,c=Country \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-keystore .\/i18n.jks \"\n+                    + \"-storetype JKS\",\n+                    \"Output in ${LANG}. Check: generated a 512 bit DSA key pair \"\n+                            + \"with a JKS warning.\"},\n+\n+            {\"-keypasswd -v \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-new aaaaaa \"\n+                    + \"-keystore .\/i18n.jks\",\n+                    \"Output in ${LANG}. Check: storing i18n.jks with a JKS warning.\"},\n+\n+            {\"-selfcert -v -alias mykey \"\n+                    + \"-storepass password \"\n+                    + \"-keypass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: generated a new certificate \"\n+                            + \"(self-signed).\"},\n+\n+            {\"-list -v -storepass password -keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: contains 2 keystore entries \"\n+                            + \"(alias name mykey & mykey2), both with 512-bit DSA\"\n+                            + \" key algorithm for CN=Name, OU=Java, O=Oracle, \"\n+                            + \"L=City, ST=State C=Country.\"},\n+\n+            {\"-export -v -alias mykey \"\n+                    + \"-file backup.keystore \"\n+                    + \"-storepass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check: certificate stored in file <backup\"\n+                            + \".keystore>.\"},\n+\n+            {\"-import -v \"\n+                    + \"-file backup.keystore \"\n+                    + \"-storepass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: reply and certificate \"\n+                            + \"in keystore are identical.\"},\n+\n+            {\"-printcert -file backup.keystore\",\n+                    \"Output in ${LANG}. Check: 512 bit DSA key pair for CN=Name,\"\n+                            + \" OU=Java, O=Oracle, L=City, ST=State C=Country.\"},\n+\n+            {\"-list -storepass password -keystore .\/i18n.keystore \"\n+                    + \"-addprovider SUN\",\n+                    \"Output in ${LANG}. Check: contains 2 keystore entries \"\n+                            + \"(alias name mykey & mykey2).\"},\n+\n+            {\"-storepasswd \"\n+                    + \"-storepass password \"\n+                    + \"-new a \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang.Exception: \"\n+                            + \"New password must be at least 6 characters.\"},\n+\n+            {\"-storepasswd \"\n+                    + \"-storetype PKCS11 \"\n+                    + \"-keystore NONE\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang\"\n+                            + \".UnsupportedOperationException: -storepasswd and \"\n+                            + \"-keypasswd commands not supported if -storetype is\"\n+                            + \" PKCS11.\"},\n+\n+            {\"-keypasswd \"\n+                    + \"-storetype PKCS11 \"\n+                    + \"-keystore NONE\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang\"\n+                            + \".UnsupportedOperationException: -storepasswd and \"\n+                            + \"-keypasswd commands not supported if -storetype is\"\n+                            + \" PKCS11.\"},\n+\n+            {\"-list -protected \"\n+                    + \"-storepass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang\"\n+                            + \".IllegalArgumentException: if -protected is \"\n+                            + \"specified, then -storepass, -keypass, and -new \"\n+                            + \"must not be specified.\"},\n+\n+            {\"-keypasswd -protected \"\n+                    + \"-storepass password \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang\"\n+                            + \".IllegalArgumentException: if -protected is \"\n+                            + \"specified, then -storepass, -keypass, and -new \"\n+                            + \"must not be specified.\"},\n+\n+            {\"-keypasswd -protected \"\n+                    + \"-storepass password \"\n+                    + \"-new aaaaaa \"\n+                    + \"-keystore .\/i18n.keystore\",\n+                    \"Output in ${LANG}. Check keytool error: java.lang\"\n+                            + \".IllegalArgumentException: if -protected is \"\n+                            + \"specified, then -storepass, -keypass, and -new \"\n+                            + \"must not be specified.\"},\n+    };\n+    private static String TEST_SRC = System.getProperty(\"test.src\");\n+    private static int TIMEOUT_MS = 120000;\n+    private volatile boolean failed = false;\n+    private volatile boolean aborted = false;\n+    private Thread currentThread = null;\n+\n+    public static void executeKeytool(String command) throws Exception {\n+        sun.security.tools.keytool.Main.main(command.split(\"\\\\s+\"));\n+    }\n+\n+    public static void main(String[] args) {\n+        final String lang = System.getProperty(\"user.language\");\n+        final String country = System.getProperty(\"user.country\");\n+\n+        if (lang != null) {\n+            if (country != null) {\n+                Locale.setDefault(Locale.of(lang, country));\n+            } else {\n+                Locale.setDefault(Locale.of(lang));\n+            }\n+        }\n+\n+        final String displayName = Locale.getDefault().getDisplayName();\n+\n+        boolean testFailed = false;\n+        i18n i18nTest = new i18n();\n+\n+        for (String[] entry : TABLE) {\n+            String command = entry[0].replaceAll(\"\\\\$\\\\{TEST_SRC\\\\}\", TEST_SRC);\n+            String instruction = entry[1].replaceAll(\"\\\\$\\\\{LANG\\\\}\", displayName);\n+\n+            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+\n+            doKeytool(command, new PrintStream(buffer, true));\n+\n+            testFailed |= i18nTest.validate(command, instruction, buffer.toString());\n+        }\n+\n+        if (testFailed) {\n+            throw new RuntimeException(\"One or more tests failed.\");\n+        }\n+    }\n+\n+    public static void doKeytool(String command, PrintStream dest) {\n+        \/\/ Backups stdout and stderr.\n+        PrintStream origStdOut = System.out;\n+        PrintStream origErrOut = System.err;\n+\n+        \/\/ Redirects the system output to a custom one.\n+        System.setOut(dest);\n+        System.setErr(dest);\n+\n+        try {\n+            executeKeytool(\"-debug \" + command);\n+        } catch (Exception e) {\n+            \/\/ Do nothing.\n+        } finally {\n+            System.setOut(origStdOut);\n+            System.setErr(origErrOut);\n+        }\n+    }\n+\n+    public boolean validate(String command, String instruction, String message) {\n+        failed = false;\n+        currentThread = Thread.currentThread();\n+        JDialog dialog = new UIBuilder.DialogBuilder()\n+                .setTitle(\"keytool \" + command)\n+                .setInstruction(instruction)\n+                .setMessage(message)\n+                .setPassAction(e -> pass())\n+                .setFailAction(e -> fail())\n+                .setCloseAction(() -> abort())\n+                .build();\n+\n+        SwingUtilities.invokeLater(() -> {\n+            try {\n+                dialog.setVisible(true);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        try {\n+            Thread.sleep(TIMEOUT_MS);\n+            \/\/Timed out, so fail the test\n+            throw new RuntimeException(\n+                    \"Timed out after \" + TIMEOUT_MS \/ 1000 + \" seconds\");\n+        } catch (InterruptedException e) {\n+            if (aborted) {\n+                throw new RuntimeException(\"TEST ABORTED\");\n+            }\n+\n+            if (failed) {\n+                System.out.println(command + \": TEST FAILED\");\n+                System.out.println(message);\n+            } else {\n+                System.out.println(command + \": TEST PASSED\");\n+            }\n+        } finally {\n+            dialog.dispose();\n+        }\n+\n+        return failed;\n+    }\n+\n+    public void pass() {\n+        failed = false;\n+        currentThread.interrupt();\n+    }\n+\n+    public void fail() {\n+        failed = true;\n+        currentThread.interrupt();\n+    }\n@@ -34,4 +358,3 @@\n-public class i18n{\n-    public static void main(String[] args) throws Exception {\n-        System.out.println(\"see i18n.html\");\n-        System.out.println(Path.of(System.getProperty(\"test.jdk\"), \"bin\", \"keytool\"));\n+    public void abort() {\n+        aborted = true;\n+        currentThread.interrupt();\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/i18n.java","additions":332,"deletions":9,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.jvmci\n","filename":"test\/jdk\/tools\/jlink\/plugins\/SaveJlinkArgfilesPluginTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug     8295024\n+ * @summary Cyclic constructor error is non-deterministic and inconsistent\n+ *\/\n+import java.io.*;\n+import java.net.*;\n+import java.util.*;\n+import java.util.stream.*;\n+import javax.tools.*;\n+public class T8295024 {\n+\n+    private static final int NUM_RUNS = 10;\n+    private static final String EXPECTED_ERROR = \"\"\"\n+        Cyclic.java:12:9: compiler.err.recursive.ctor.invocation\n+        1 error\n+        \"\"\";\n+    private static final String SOURCE = \"\"\"\n+        public class Cyclic {\n+            public Cyclic(int x) {\n+                this((float)x);\n+            }\n+            public Cyclic(float x) {\n+                this((long)x);\n+            }\n+            public Cyclic(long x) {\n+                this((double)x);\n+            }\n+            public Cyclic(double x) {\n+                this((int)x);\n+            \/\/  ^ error should be reported here every time\n+            }\n+        }\n+        \"\"\";\n+\n+    private static final SimpleJavaFileObject FILE = new SimpleJavaFileObject(\n+      URI.create(\"string:\/\/\/Cyclic.java\"), JavaFileObject.Kind.SOURCE) {\n+        @Override\n+        public String getCharContent(boolean ignoreEncodingErrors) {\n+            return  SOURCE;\n+        }\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Compile program NUM_RUNS times\n+        final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        final StringWriter output = new StringWriter();\n+        final Iterable<String> options = Collections.singleton(\"-XDrawDiagnostics\");\n+        final Iterable<SimpleJavaFileObject> files = Collections.singleton(FILE);\n+        for (int i = 0; i < NUM_RUNS; i++)\n+            compiler.getTask(output, null, null, options, null, files).call();\n+\n+        \/\/ Verify consistent error report each time\n+        final String expected = IntStream.range(0, NUM_RUNS)\n+          .mapToObj(i -> EXPECTED_ERROR)\n+          .collect(Collectors.joining(\"\"));\n+        final String actual = output.toString().replaceAll(\"\\\\r\", \"\");\n+        assert expected.equals(actual) : \"EXPECTED:\\n\" + expected + \"ACTUAL:\\n\" + actual;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/Diagnostics\/8295024\/T8295024.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8295020\n+ * @summary javac emits incorrect code for for-each on an intersection type.\n+ * @run main CovariantIntersectIterator\n+ *\/\n+\n+import java.io.Serializable;\n+import java.util.Iterator;\n+\n+public class CovariantIntersectIterator {\n+\n+    public static void main(String... args) {\n+        int npeCount = 0;\n+        try {\n+            \/\/ JCEnhancedForLoop.expr's erased type is ALREADY an Iterable\n+            \/\/ iterator() comes from expr's erased type (MyIterable) and\n+            \/\/ is called using invokevirtual & returns a covariant type (MyIterable.MyIterator)\n+            for (Object s : (MyIterable & Serializable) null) {}\n+        } catch (NullPointerException e) {\n+            npeCount++;\n+        }\n+        try {\n+            \/\/ JCEnhancedForLoop.expr's erased type is NOT an Iterable\n+            \/\/ iterator() comes from Iterable (expr's erased type casted),\n+            \/\/ will be called by invokeinterface and return Iterator\n+            for (Object s : (MyIterableBase & Iterable<Object>) null) {}\n+        } catch (NullPointerException e) {\n+            npeCount++;\n+        }\n+        if (npeCount != 2) {\n+            throw new AssertionError(\"Expected NPE missing\");\n+        }\n+    }\n+\n+    abstract static class MyIterableBase {\n+        public abstract MyIterable.MyIterator iterator();\n+    }\n+\n+    static class MyIterable extends MyIterableBase implements Iterable<Object> {\n+\n+        class MyIterator implements Iterator<Object> {\n+\n+            public boolean hasNext() {\n+                return false;\n+            }\n+\n+            public Object next() {\n+                return null;\n+            }\n+\n+            public void remove() {}\n+        }\n+\n+        public MyIterator iterator() {\n+            return new MyIterator();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/foreach\/CovariantIntersectIterator.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8292975\n+ * @summary Javac produces code that crashes with LambdaConversionException\n+ * @run main IntersectionParameterTypeTest\n+ *\/\n+\n+import java.util.function.BiFunction;\n+\n+public class IntersectionParameterTypeTest {\n+\n+    sealed interface Term {\n+        record Lit() implements Term {}\n+        record Lam(String x, Term a) implements Term {}\n+    }\n+\n+    public static <U, T> void call(BiFunction<U, T, T> op, U x, T t) {\n+      op.apply(x, t);\n+    }\n+\n+    public static void main(String[] args) {\n+      \/\/ this code works\n+      call(Term.Lam::new, \"x\", (Term) new Term.Lit());\n+\n+      \/\/ this does not\n+      call(Term.Lam::new, \"x\", new Term.Lit());\n+  }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/IntersectionParameterTypeTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8269983\n+ * @summary BootstrapMethodError with method reference and intersection type\n+ * @run main IntersectionParameterTypeTest2\n+ *\/\n+\n+public class IntersectionParameterTypeTest2 {\n+\n+    public static void main(String[] args) {\n+        f();\n+    }\n+\n+    static <T extends Comparable<T> & G> C<T> f() {\n+        return new C<>(Q::g);\n+    }\n+\n+    public interface G {}\n+\n+    private interface E<T> {\n+        void g(Q g, T value);\n+    }\n+\n+    static class C<T extends Comparable<?>> {\n+        C(E<T> g) {}\n+    }\n+\n+    static class Q {\n+        void g(G g) {}\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/IntersectionParameterTypeTest2.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -4,1 +4,1 @@\n- * @summary Verify that javac rejects Java 8 program with --release 7\n+ * @summary Verify that javac rejects Java 17 program with --release 11\n@@ -6,0 +6,1 @@\n+ * @compile\/fail\/ref=ReleaseOption.out -XDrawDiagnostics --release 11 ReleaseOption.java\n@@ -8,1 +9,1 @@\n-interface ReleaseOption extends java.util.stream.Stream {\n+interface ReleaseOption extends java.util.random.RandomGenerator {\n","filename":"test\/langtools\/tools\/javac\/options\/release\/ReleaseOption.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+ReleaseOption.java:9:49: compiler.err.doesnt.exist: java.util.random\n+1 error\n","filename":"test\/langtools\/tools\/javac\/options\/release\/ReleaseOption.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n-            List<String> options = Arrays.asList(\"--release\", \"8\", \"-XDrawDiagnostics\", \"-Xlint:-options\");\n+            List<String> options = Arrays.asList(\"--release\", \"11\", \"-XDrawDiagnostics\", \"-d\", \".\");\n@@ -56,1 +56,3 @@\n-            String expected =\"\";\n+            String expected =\n+                    \"ReleaseOption.java:9:49: compiler.err.doesnt.exist: java.util.random\" + lineSep +\n+                    \"1 error\" + lineSep;\n","filename":"test\/langtools\/tools\/javac\/options\/release\/ReleaseOptionThroughAPI.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-                    \"hv\",           \"fsrm\",             \"avx512_bitalg\",     \"gfni\"\n+                    \"hv\",           \"fsrm\",             \"avx512_bitalg\",     \"gfni\",\n+                    \"f16c\"\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8028756\n+ * @bug 8038756\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/vm_flags\/BooleanTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8028756\n+ * @bug 8038756\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/vm_flags\/DoubleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8028756\n+ * @bug 8038756\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/vm_flags\/StringTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8028756\n+ * @bug 8038756\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/vm_flags\/Uint64Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8028756\n+ * @bug 8038756\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/vm_flags\/UintxTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib;\n+\n+import javax.swing.*;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+\n+\/**\n+ * This is a common library for building UI for testing purposes.\n+ *\/\n+public class UIBuilder {\n+\n+    \/**\n+     * Creates a {@link javax.swing.JDialog} object with a fixed layout that contains\n+     * an instructions {@link javax.swing.JTextArea} and a message\n+     * {@link javax.swing.JTextArea} for displaying text contents. Text contents can\n+     * be set by using {@code setInstruction} method and {@code setMessage} method.\n+     *\n+     * The {@link javax.swing.JDialog} object also a pass {@link javax.swing.JButton}\n+     * and a fail {@link javax.swing.JButton} to indicate test result. Buttons' action\n+     * can be bound by using {@code setPassAction} and {@code setFailAction}.\n+     *\/\n+    public static class DialogBuilder {\n+        private JDialog dialog;\n+        private JTextArea instructionsText;\n+        private JTextArea messageText;\n+        private JButton pass;\n+        private JButton fail;\n+\n+        \/**\n+         * Construct a new DialogBuilder object.\n+         *\/\n+        public DialogBuilder() {\n+            dialog = new JDialog(new JFrame());\n+            dialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);\n+            instructionsText = new JTextArea(\"\", 5, 100);\n+\n+            dialog.add(\"North\", new JScrollPane(instructionsText,\n+                    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,\n+                    JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS));\n+\n+            messageText = new JTextArea(\"\", 20, 100);\n+            dialog.add(\"Center\", new JScrollPane(messageText,\n+                    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,\n+                    JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS));\n+\n+            JPanel buttons = new JPanel();\n+            pass = new JButton(\"pass\");\n+            pass.setActionCommand(\"pass\");\n+            buttons.add(\"East\", pass);\n+\n+            fail = new JButton(\"fail\");\n+            fail.setActionCommand(\"fail\");\n+            buttons.add(\"West\", fail);\n+\n+            dialog.add(\"South\", buttons);\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting the dialog's title to a new value.\n+         * @param title a string value\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setTitle(String title) {\n+            dialog.setTitle(title);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting the instruction text to a new\n+         * value.\n+         * @param instruction a string value\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setInstruction(String instruction) {\n+            instructionsText.setText(\"Test instructions:\\n\" + instruction);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting the message text to a new value.\n+         * @param message a string value\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setMessage(String message) {\n+            messageText.setText(message);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting pass button action to\n+         * {@link java.awt.event.ActionListener}.\n+         * @param action an action to perform on button click\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setPassAction(ActionListener action) {\n+            pass.addActionListener(action);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting fail button action to\n+         * {@link java.awt.event.ActionListener}.\n+         * @param action an action to perform on button click\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setFailAction(ActionListener action) {\n+            fail.addActionListener(action);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns this {@code DialogBuilder} setting window-closing action to\n+         * {@link java.lang.Runnable}.\n+         * @param action a runnerable action to perform on window close\n+         * @returns this DialogBuilder\n+         *\/\n+        public DialogBuilder setCloseAction(Runnable action) {\n+            dialog.addWindowListener(new WindowAdapter() {\n+                @Override\n+                public void windowClosing(WindowEvent e) {\n+                    super.windowClosing(e);\n+                    action.run();\n+                }\n+            });\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns a {@link javax.swing.JDialog} window.\n+         * @returns a JDialog\n+         *\/\n+        public JDialog build() {\n+            dialog.pack();\n+            return dialog;\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/UIBuilder.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -35,0 +35,2 @@\n+    public String appJar;\n+    public String appJarDir;\n@@ -108,0 +110,11 @@\n+    \/\/ AppCDS methods\n+    public CDSOptions setAppJar(String appJar) {\n+        this.appJar = appJar;\n+        return this;\n+    }\n+\n+    public CDSOptions setAppJarDir(String appJarDir) {\n+        this.appJarDir = appJarDir;\n+        return this;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSOptions.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    public final static String PREFIX = \"jdk.\";\n+    public static final String PREFIX = \"jdk.\";\n@@ -39,16 +39,16 @@\n-    public final static String JVMInformation = PREFIX + \"JVMInformation\";\n-    public final static String InitialSystemProperty = PREFIX + \"InitialSystemProperty\";\n-    public final static String IntFlag = PREFIX + \"IntFlag\";\n-    public final static String UnsignedIntFlag = PREFIX + \"UnsignedIntFlag\";\n-    public final static String LongFlag = PREFIX + \"LongFlag\";\n-    public final static String UnsignedLongFlag = PREFIX + \"UnsignedLongFlag\";\n-    public final static String DoubleFlag = PREFIX + \"DoubleFlag\";\n-    public final static String BooleanFlag = PREFIX + \"BooleanFlag\";\n-    public final static String StringFlag = PREFIX + \"StringFlag\";\n-    public final static String IntFlagChanged = PREFIX + \"IntFlagChanged\";\n-    public final static String UnsignedIntFlagChanged = PREFIX + \"UnsignedIntFlagChanged\";\n-    public final static String LongFlagChanged = PREFIX + \"LongFlagChanged\";\n-    public final static String UnsignedLongFlagChanged = PREFIX + \"UnsignedLongFlagChanged\";\n-    public final static String DoubleFlagChanged = PREFIX + \"DoubleFlagChanged\";\n-    public final static String BooleanFlagChanged = PREFIX + \"BooleanFlagChanged\";\n-    public final static String StringFlagChanged = PREFIX + \"StringFlagChanged\";\n+    public static final String JVMInformation = PREFIX + \"JVMInformation\";\n+    public static final String InitialSystemProperty = PREFIX + \"InitialSystemProperty\";\n+    public static final String IntFlag = PREFIX + \"IntFlag\";\n+    public static final String UnsignedIntFlag = PREFIX + \"UnsignedIntFlag\";\n+    public static final String LongFlag = PREFIX + \"LongFlag\";\n+    public static final String UnsignedLongFlag = PREFIX + \"UnsignedLongFlag\";\n+    public static final String DoubleFlag = PREFIX + \"DoubleFlag\";\n+    public static final String BooleanFlag = PREFIX + \"BooleanFlag\";\n+    public static final String StringFlag = PREFIX + \"StringFlag\";\n+    public static final String IntFlagChanged = PREFIX + \"IntFlagChanged\";\n+    public static final String UnsignedIntFlagChanged = PREFIX + \"UnsignedIntFlagChanged\";\n+    public static final String LongFlagChanged = PREFIX + \"LongFlagChanged\";\n+    public static final String UnsignedLongFlagChanged = PREFIX + \"UnsignedLongFlagChanged\";\n+    public static final String DoubleFlagChanged = PREFIX + \"DoubleFlagChanged\";\n+    public static final String BooleanFlagChanged = PREFIX + \"BooleanFlagChanged\";\n+    public static final String StringFlagChanged = PREFIX + \"StringFlagChanged\";\n@@ -57,28 +57,28 @@\n-    public final static String ThreadStart = PREFIX + \"ThreadStart\";\n-    public final static String ThreadEnd = PREFIX + \"ThreadEnd\";\n-    public final static String ThreadSleep = PREFIX + \"ThreadSleep\";\n-    public final static String ThreadPark = PREFIX + \"ThreadPark\";\n-    public final static String JavaMonitorEnter = PREFIX + \"JavaMonitorEnter\";\n-    public final static String JavaMonitorWait = PREFIX + \"JavaMonitorWait\";\n-    public final static String JavaMonitorInflate = PREFIX + \"JavaMonitorInflate\";\n-    public final static String SyncOnValueBasedClass = PREFIX + \"SyncOnValueBasedClass\";\n-    public final static String ClassLoad = PREFIX + \"ClassLoad\";\n-    public final static String ClassDefine = PREFIX + \"ClassDefine\";\n-    public final static String ClassUnload = PREFIX + \"ClassUnload\";\n-    public final static String SafepointBegin = PREFIX + \"SafepointBegin\";\n-    public final static String SafepointStateSynchronization = PREFIX + \"SafepointStateSynchronization\";\n-    public final static String SafepointCleanup = PREFIX + \"SafepointCleanup\";\n-    public final static String SafepointCleanupTask = PREFIX + \"SafepointCleanupTask\";\n-    public final static String SafepointEnd = PREFIX + \"SafepointEnd\";\n-    public final static String ExecuteVMOperation = PREFIX + \"ExecuteVMOperation\";\n-    public final static String Shutdown = PREFIX + \"Shutdown\";\n-    public final static String JavaThreadStatistics = PREFIX + \"JavaThreadStatistics\";\n-    public final static String ClassLoadingStatistics = PREFIX + \"ClassLoadingStatistics\";\n-    public final static String ClassLoaderStatistics = PREFIX + \"ClassLoaderStatistics\";\n-    public final static String ThreadAllocationStatistics = PREFIX + \"ThreadAllocationStatistics\";\n-    public final static String ExecutionSample = PREFIX + \"ExecutionSample\";\n-    public final static String NativeMethodSample = PREFIX + \"NativeMethodSample\";\n-    public final static String ThreadDump = PREFIX + \"ThreadDump\";\n-    public final static String OldObjectSample = PREFIX + \"OldObjectSample\";\n-    public final static String SymbolTableStatistics = PREFIX + \"SymbolTableStatistics\";\n-    public final static String StringTableStatistics = PREFIX + \"StringTableStatistics\";\n+    public static final String ThreadStart = PREFIX + \"ThreadStart\";\n+    public static final String ThreadEnd = PREFIX + \"ThreadEnd\";\n+    public static final String ThreadSleep = PREFIX + \"ThreadSleep\";\n+    public static final String ThreadPark = PREFIX + \"ThreadPark\";\n+    public static final String JavaMonitorEnter = PREFIX + \"JavaMonitorEnter\";\n+    public static final String JavaMonitorWait = PREFIX + \"JavaMonitorWait\";\n+    public static final String JavaMonitorInflate = PREFIX + \"JavaMonitorInflate\";\n+    public static final String SyncOnValueBasedClass = PREFIX + \"SyncOnValueBasedClass\";\n+    public static final String ClassLoad = PREFIX + \"ClassLoad\";\n+    public static final String ClassDefine = PREFIX + \"ClassDefine\";\n+    public static final String ClassUnload = PREFIX + \"ClassUnload\";\n+    public static final String SafepointBegin = PREFIX + \"SafepointBegin\";\n+    public static final String SafepointStateSynchronization = PREFIX + \"SafepointStateSynchronization\";\n+    public static final String SafepointCleanup = PREFIX + \"SafepointCleanup\";\n+    public static final String SafepointCleanupTask = PREFIX + \"SafepointCleanupTask\";\n+    public static final String SafepointEnd = PREFIX + \"SafepointEnd\";\n+    public static final String ExecuteVMOperation = PREFIX + \"ExecuteVMOperation\";\n+    public static final String Shutdown = PREFIX + \"Shutdown\";\n+    public static final String JavaThreadStatistics = PREFIX + \"JavaThreadStatistics\";\n+    public static final String ClassLoadingStatistics = PREFIX + \"ClassLoadingStatistics\";\n+    public static final String ClassLoaderStatistics = PREFIX + \"ClassLoaderStatistics\";\n+    public static final String ThreadAllocationStatistics = PREFIX + \"ThreadAllocationStatistics\";\n+    public static final String ExecutionSample = PREFIX + \"ExecutionSample\";\n+    public static final String NativeMethodSample = PREFIX + \"NativeMethodSample\";\n+    public static final String ThreadDump = PREFIX + \"ThreadDump\";\n+    public static final String OldObjectSample = PREFIX + \"OldObjectSample\";\n+    public static final String SymbolTableStatistics = PREFIX + \"SymbolTableStatistics\";\n+    public static final String StringTableStatistics = PREFIX + \"StringTableStatistics\";\n@@ -91,1 +91,1 @@\n-    public final static String ReservedStackActivation = PREFIX + \"ReservedStackActivation\";\n+    public static final String ReservedStackActivation = PREFIX + \"ReservedStackActivation\";\n@@ -94,54 +94,54 @@\n-    public final static String GCHeapSummary = PREFIX + \"GCHeapSummary\";\n-    public final static String MetaspaceSummary = PREFIX + \"MetaspaceSummary\";\n-    public final static String MetaspaceGCThreshold = PREFIX + \"MetaspaceGCThreshold\";\n-    public final static String MetaspaceAllocationFailure = PREFIX + \"MetaspaceAllocationFailure\";\n-    public final static String MetaspaceOOM = PREFIX + \"MetaspaceOOM\";\n-    public final static String MetaspaceChunkFreeListSummary = PREFIX + \"MetaspaceChunkFreeListSummary\";\n-    public final static String PSHeapSummary = PREFIX + \"PSHeapSummary\";\n-    public final static String G1HeapSummary = PREFIX + \"G1HeapSummary\";\n-    public final static String G1HeapRegionInformation = PREFIX + \"G1HeapRegionInformation\";\n-    public final static String G1HeapRegionTypeChange = PREFIX + \"G1HeapRegionTypeChange\";\n-    public final static String ShenandoahHeapRegionInformation = PREFIX + \"ShenandoahHeapRegionInformation\";\n-    public final static String ShenandoahHeapRegionStateChange = PREFIX + \"ShenandoahHeapRegionStateChange\";\n-    public final static String TenuringDistribution = PREFIX + \"TenuringDistribution\";\n-    public final static String GarbageCollection = PREFIX + \"GarbageCollection\";\n-    public final static String ParallelOldGarbageCollection = PREFIX + \"ParallelOldGarbageCollection\";\n-    public final static String ParallelOldCollection = ParallelOldGarbageCollection;\n-    public final static String YoungGarbageCollection = PREFIX + \"YoungGarbageCollection\";\n-    public final static String OldGarbageCollection = PREFIX + \"OldGarbageCollection\";\n-    public final static String G1GarbageCollection = PREFIX + \"G1GarbageCollection\";\n-    public final static String G1MMU = PREFIX + \"G1MMU\";\n-    public final static String EvacuationInformation = PREFIX + \"EvacuationInformation\";\n-    public final static String GCReferenceStatistics = PREFIX + \"GCReferenceStatistics\";\n-    public final static String ObjectCountAfterGC = PREFIX + \"ObjectCountAfterGC\";\n-    public final static String PromoteObjectInNewPLAB = PREFIX + \"PromoteObjectInNewPLAB\";\n-    public final static String PromoteObjectOutsidePLAB = PREFIX + \"PromoteObjectOutsidePLAB\";\n-    public final static String PromotionFailed = PREFIX + \"PromotionFailed\";\n-    public final static String EvacuationFailed = PREFIX + \"EvacuationFailed\";\n-    public final static String ConcurrentModeFailure = PREFIX + \"ConcurrentModeFailure\";\n-    public final static String GCPhasePause = PREFIX + \"GCPhasePause\";\n-    public final static String GCPhasePauseLevel1 = PREFIX + \"GCPhasePauseLevel1\";\n-    public final static String GCPhasePauseLevel2 = PREFIX + \"GCPhasePauseLevel2\";\n-    public final static String GCPhasePauseLevel3 = PREFIX + \"GCPhasePauseLevel3\";\n-    public final static String GCPhasePauseLevel4 = PREFIX + \"GCPhasePauseLevel4\";\n-    public final static String ObjectCount = PREFIX + \"ObjectCount\";\n-    public final static String GCConfiguration = PREFIX + \"GCConfiguration\";\n-    public final static String GCSurvivorConfiguration = PREFIX + \"GCSurvivorConfiguration\";\n-    public final static String GCTLABConfiguration = PREFIX + \"GCTLABConfiguration\";\n-    public final static String GCHeapConfiguration = PREFIX + \"GCHeapConfiguration\";\n-    public final static String YoungGenerationConfiguration = PREFIX + \"YoungGenerationConfiguration\";\n-    public final static String G1AdaptiveIHOP = PREFIX + \"G1AdaptiveIHOP\";\n-    public final static String G1EvacuationYoungStatistics = PREFIX + \"G1EvacuationYoungStatistics\";\n-    public final static String G1EvacuationOldStatistics = PREFIX + \"G1EvacuationOldStatistics\";\n-    public final static String G1BasicIHOP = PREFIX + \"G1BasicIHOP\";\n-    public final static String AllocationRequiringGC = PREFIX + \"AllocationRequiringGC\";\n-    public final static String GCPhaseParallel = PREFIX + \"GCPhaseParallel\";\n-    public final static String GCPhaseConcurrent = PREFIX + \"GCPhaseConcurrent\";\n-    public final static String GCPhaseConcurrentLevel1 = PREFIX + \"GCPhaseConcurrentLevel1\";\n-    public final static String ZAllocationStall = PREFIX + \"ZAllocationStall\";\n-    public final static String ZPageAllocation = PREFIX + \"ZPageAllocation\";\n-    public final static String ZRelocationSet = PREFIX + \"ZRelocationSet\";\n-    public final static String ZRelocationSetGroup = PREFIX + \"ZRelocationSetGroup\";\n-    public final static String ZUncommit = PREFIX + \"ZUncommit\";\n-    public final static String ZUnmap = PREFIX + \"ZUnmap\";\n-    public final static String GCLocker = PREFIX + \"GCLocker\";\n+    public static final String GCHeapSummary = PREFIX + \"GCHeapSummary\";\n+    public static final String MetaspaceSummary = PREFIX + \"MetaspaceSummary\";\n+    public static final String MetaspaceGCThreshold = PREFIX + \"MetaspaceGCThreshold\";\n+    public static final String MetaspaceAllocationFailure = PREFIX + \"MetaspaceAllocationFailure\";\n+    public static final String MetaspaceOOM = PREFIX + \"MetaspaceOOM\";\n+    public static final String MetaspaceChunkFreeListSummary = PREFIX + \"MetaspaceChunkFreeListSummary\";\n+    public static final String PSHeapSummary = PREFIX + \"PSHeapSummary\";\n+    public static final String G1HeapSummary = PREFIX + \"G1HeapSummary\";\n+    public static final String G1HeapRegionInformation = PREFIX + \"G1HeapRegionInformation\";\n+    public static final String G1HeapRegionTypeChange = PREFIX + \"G1HeapRegionTypeChange\";\n+    public static final String ShenandoahHeapRegionInformation = PREFIX + \"ShenandoahHeapRegionInformation\";\n+    public static final String ShenandoahHeapRegionStateChange = PREFIX + \"ShenandoahHeapRegionStateChange\";\n+    public static final String TenuringDistribution = PREFIX + \"TenuringDistribution\";\n+    public static final String GarbageCollection = PREFIX + \"GarbageCollection\";\n+    public static final String ParallelOldGarbageCollection = PREFIX + \"ParallelOldGarbageCollection\";\n+    public static final String ParallelOldCollection = ParallelOldGarbageCollection;\n+    public static final String YoungGarbageCollection = PREFIX + \"YoungGarbageCollection\";\n+    public static final String OldGarbageCollection = PREFIX + \"OldGarbageCollection\";\n+    public static final String G1GarbageCollection = PREFIX + \"G1GarbageCollection\";\n+    public static final String G1MMU = PREFIX + \"G1MMU\";\n+    public static final String EvacuationInformation = PREFIX + \"EvacuationInformation\";\n+    public static final String GCReferenceStatistics = PREFIX + \"GCReferenceStatistics\";\n+    public static final String ObjectCountAfterGC = PREFIX + \"ObjectCountAfterGC\";\n+    public static final String PromoteObjectInNewPLAB = PREFIX + \"PromoteObjectInNewPLAB\";\n+    public static final String PromoteObjectOutsidePLAB = PREFIX + \"PromoteObjectOutsidePLAB\";\n+    public static final String PromotionFailed = PREFIX + \"PromotionFailed\";\n+    public static final String EvacuationFailed = PREFIX + \"EvacuationFailed\";\n+    public static final String ConcurrentModeFailure = PREFIX + \"ConcurrentModeFailure\";\n+    public static final String GCPhasePause = PREFIX + \"GCPhasePause\";\n+    public static final String GCPhasePauseLevel1 = PREFIX + \"GCPhasePauseLevel1\";\n+    public static final String GCPhasePauseLevel2 = PREFIX + \"GCPhasePauseLevel2\";\n+    public static final String GCPhasePauseLevel3 = PREFIX + \"GCPhasePauseLevel3\";\n+    public static final String GCPhasePauseLevel4 = PREFIX + \"GCPhasePauseLevel4\";\n+    public static final String ObjectCount = PREFIX + \"ObjectCount\";\n+    public static final String GCConfiguration = PREFIX + \"GCConfiguration\";\n+    public static final String GCSurvivorConfiguration = PREFIX + \"GCSurvivorConfiguration\";\n+    public static final String GCTLABConfiguration = PREFIX + \"GCTLABConfiguration\";\n+    public static final String GCHeapConfiguration = PREFIX + \"GCHeapConfiguration\";\n+    public static final String YoungGenerationConfiguration = PREFIX + \"YoungGenerationConfiguration\";\n+    public static final String G1AdaptiveIHOP = PREFIX + \"G1AdaptiveIHOP\";\n+    public static final String G1EvacuationYoungStatistics = PREFIX + \"G1EvacuationYoungStatistics\";\n+    public static final String G1EvacuationOldStatistics = PREFIX + \"G1EvacuationOldStatistics\";\n+    public static final String G1BasicIHOP = PREFIX + \"G1BasicIHOP\";\n+    public static final String AllocationRequiringGC = PREFIX + \"AllocationRequiringGC\";\n+    public static final String GCPhaseParallel = PREFIX + \"GCPhaseParallel\";\n+    public static final String GCPhaseConcurrent = PREFIX + \"GCPhaseConcurrent\";\n+    public static final String GCPhaseConcurrentLevel1 = PREFIX + \"GCPhaseConcurrentLevel1\";\n+    public static final String ZAllocationStall = PREFIX + \"ZAllocationStall\";\n+    public static final String ZPageAllocation = PREFIX + \"ZPageAllocation\";\n+    public static final String ZRelocationSet = PREFIX + \"ZRelocationSet\";\n+    public static final String ZRelocationSetGroup = PREFIX + \"ZRelocationSetGroup\";\n+    public static final String ZUncommit = PREFIX + \"ZUncommit\";\n+    public static final String ZUnmap = PREFIX + \"ZUnmap\";\n+    public static final String GCLocker = PREFIX + \"GCLocker\";\n@@ -152,14 +152,14 @@\n-    public final static String Compilation = PREFIX + \"Compilation\";\n-    public final static String CompilerPhase = PREFIX + \"CompilerPhase\";\n-    public final static String CompilationFailure = PREFIX + \"CompilationFailure\";\n-    public final static String CompilerInlining = PREFIX + \"CompilerInlining\";\n-    public final static String CompilerStatistics = PREFIX + \"CompilerStatistics\";\n-    public final static String CompilerConfiguration = PREFIX + \"CompilerConfiguration\";\n-    public final static String CodeCacheStatistics = PREFIX + \"CodeCacheStatistics\";\n-    public final static String CodeCacheConfiguration = PREFIX + \"CodeCacheConfiguration\";\n-    public final static String CodeCacheFull = PREFIX + \"CodeCacheFull\";\n-    public final static String ObjectAllocationInNewTLAB = PREFIX + \"ObjectAllocationInNewTLAB\";\n-    public final static String ObjectAllocationOutsideTLAB = PREFIX + \"ObjectAllocationOutsideTLAB\";\n-    public final static String ObjectAllocationSample = PREFIX + \"ObjectAllocationSample\";\n-    public final static String Deoptimization = PREFIX + \"Deoptimization\";\n-    public final static String JitRestart = PREFIX + \"JitRestart\";\n+    public static final String Compilation = PREFIX + \"Compilation\";\n+    public static final String CompilerPhase = PREFIX + \"CompilerPhase\";\n+    public static final String CompilationFailure = PREFIX + \"CompilationFailure\";\n+    public static final String CompilerInlining = PREFIX + \"CompilerInlining\";\n+    public static final String CompilerStatistics = PREFIX + \"CompilerStatistics\";\n+    public static final String CompilerConfiguration = PREFIX + \"CompilerConfiguration\";\n+    public static final String CodeCacheStatistics = PREFIX + \"CodeCacheStatistics\";\n+    public static final String CodeCacheConfiguration = PREFIX + \"CodeCacheConfiguration\";\n+    public static final String CodeCacheFull = PREFIX + \"CodeCacheFull\";\n+    public static final String ObjectAllocationInNewTLAB = PREFIX + \"ObjectAllocationInNewTLAB\";\n+    public static final String ObjectAllocationOutsideTLAB = PREFIX + \"ObjectAllocationOutsideTLAB\";\n+    public static final String ObjectAllocationSample = PREFIX + \"ObjectAllocationSample\";\n+    public static final String Deoptimization = PREFIX + \"Deoptimization\";\n+    public static final String JITRestart = PREFIX + \"JITRestart\";\n@@ -168,11 +168,11 @@\n-    public final static String OSInformation = PREFIX + \"OSInformation\";\n-    public final static String VirtualizationInformation = PREFIX + \"VirtualizationInformation\";\n-    public final static String CPUInformation = PREFIX + \"CPUInformation\";\n-    public final static String CPULoad = PREFIX + \"CPULoad\";\n-    public final static String ThreadCPULoad = PREFIX + \"ThreadCPULoad\";\n-    public final static String SystemProcess = PREFIX + \"SystemProcess\";\n-    public final static String ThreadContextSwitchRate = PREFIX + \"ThreadContextSwitchRate\";\n-    public final static String InitialEnvironmentVariable = PREFIX + \"InitialEnvironmentVariable\";\n-    public final static String NativeLibrary = PREFIX + \"NativeLibrary\";\n-    public final static String PhysicalMemory = PREFIX + \"PhysicalMemory\";\n-    public final static String NetworkUtilization = PREFIX + \"NetworkUtilization\";\n+    public static final String OSInformation = PREFIX + \"OSInformation\";\n+    public static final String VirtualizationInformation = PREFIX + \"VirtualizationInformation\";\n+    public static final String CPUInformation = PREFIX + \"CPUInformation\";\n+    public static final String CPULoad = PREFIX + \"CPULoad\";\n+    public static final String ThreadCPULoad = PREFIX + \"ThreadCPULoad\";\n+    public static final String SystemProcess = PREFIX + \"SystemProcess\";\n+    public static final String ThreadContextSwitchRate = PREFIX + \"ThreadContextSwitchRate\";\n+    public static final String InitialEnvironmentVariable = PREFIX + \"InitialEnvironmentVariable\";\n+    public static final String NativeLibrary = PREFIX + \"NativeLibrary\";\n+    public static final String PhysicalMemory = PREFIX + \"PhysicalMemory\";\n+    public static final String NetworkUtilization = PREFIX + \"NetworkUtilization\";\n@@ -187,12 +187,13 @@\n-    public final static String ExceptionStatistics = PREFIX + \"ExceptionStatistics\";\n-    public final static String JavaExceptionThrow = PREFIX + \"JavaExceptionThrow\";\n-    public final static String JavaErrorThrow = PREFIX + \"JavaErrorThrow\";\n-    public final static String ModuleRequire = PREFIX + \"ModuleRequire\";\n-    public final static String ModuleExport = PREFIX + \"ModuleExport\";\n-    public final static String TLSHandshake = PREFIX + \"TLSHandshake\";\n-    public final static String X509Certificate = PREFIX + \"X509Certificate\";\n-    public final static String X509Validation = PREFIX + \"X509Validation\";\n-    public final static String SecurityProperty = PREFIX + \"SecurityPropertyModification\";\n-    public final static String SecurityProviderService = PREFIX + \"SecurityProviderService\";\n-    public final static String DirectBufferStatistics = PREFIX + \"DirectBufferStatistics\";\n-    public final static String Deserialization = PREFIX + \"Deserialization\";\n+    public static final String ExceptionStatistics = PREFIX + \"ExceptionStatistics\";\n+    public static final String JavaExceptionThrow = PREFIX + \"JavaExceptionThrow\";\n+    public static final String JavaErrorThrow = PREFIX + \"JavaErrorThrow\";\n+    public static final String ModuleRequire = PREFIX + \"ModuleRequire\";\n+    public static final String ModuleExport = PREFIX + \"ModuleExport\";\n+    public static final String TLSHandshake = PREFIX + \"TLSHandshake\";\n+    public static final String X509Certificate = PREFIX + \"X509Certificate\";\n+    public static final String X509Validation = PREFIX + \"X509Validation\";\n+    public static final String InitialSecurityProperty = PREFIX + \"InitialSecurityProperty\";\n+    public static final String SecurityProperty = PREFIX + \"SecurityPropertyModification\";\n+    public static final String SecurityProviderService = PREFIX + \"SecurityProviderService\";\n+    public static final String DirectBufferStatistics = PREFIX + \"DirectBufferStatistics\";\n+    public static final String Deserialization = PREFIX + \"Deserialization\";\n@@ -212,5 +213,5 @@\n-    public final static String DumpReason = PREFIX + \"DumpReason\";\n-    public final static String DataLoss = PREFIX + \"DataLoss\";\n-    public final static String CPUTimeStampCounter = PREFIX + \"CPUTimeStampCounter\";\n-    public final static String ActiveRecording = PREFIX + \"ActiveRecording\";\n-    public final static String ActiveSetting = PREFIX + \"ActiveSetting\";\n+    public static final String DumpReason = PREFIX + \"DumpReason\";\n+    public static final String DataLoss = PREFIX + \"DataLoss\";\n+    public static final String CPUTimeStampCounter = PREFIX + \"CPUTimeStampCounter\";\n+    public static final String ActiveRecording = PREFIX + \"ActiveRecording\";\n+    public static final String ActiveSetting = PREFIX + \"ActiveSetting\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":143,"deletions":142,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.reflect.Field;\n@@ -27,0 +28,1 @@\n+import java.util.concurrent.ForkJoinPool;\n@@ -30,1 +32,1 @@\n- * Helper class for running tasks in a virtual thread.\n+ * Helper class to support tests running tasks a in virtual thread.\n@@ -143,0 +145,37 @@\n+\n+    \/**\n+     * Returns the virtual thread scheduler.\n+     *\/\n+    private static ForkJoinPool defaultScheduler() {\n+        try {\n+            var clazz = Class.forName(\"java.lang.VirtualThread\");\n+            var field = clazz.getDeclaredField(\"DEFAULT_SCHEDULER\");\n+            field.setAccessible(true);\n+            return (ForkJoinPool) field.get(null);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Sets the virtual thread scheduler's target parallelism.\n+     * @return the previous parallelism level\n+     *\/\n+    public static int setParallelism(int size) {\n+        return defaultScheduler().setParallelism(size);\n+    }\n+\n+    \/**\n+     * Ensures that the virtual thread scheduler's target parallelism is at least\n+     * the given size. If the target parallelism is less than the given size then\n+     * it is changed to the given size.\n+     * @return the previous parallelism level\n+     *\/\n+    public static int ensureParallelism(int size) {\n+        ForkJoinPool pool = defaultScheduler();\n+        int parallelism = pool.getParallelism();\n+        if (size > parallelism) {\n+            pool.setParallelism(size);\n+        }\n+        return parallelism;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/VThreadRunner.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package micro.org.openjdk.bench.java.io;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 4, warmups = 0)\n+@Measurement(iterations = 5, time = 1)\n+@Warmup(iterations = 2, time = 2)\n+@State(Scope.Benchmark)\n+public class DataInputStreamTest {\n+    private final int size = 1024;\n+\n+    private ByteArrayInputStream bais;\n+\n+    @Setup(Level.Iteration)\n+    public void setup() {\n+        byte[] bytes = new byte[size];\n+        ThreadLocalRandom.current().nextBytes(bytes);\n+        bais = new ByteArrayInputStream(bytes);\n+    }\n+\n+    @Benchmark\n+    public void readChar(Blackhole bh) throws Exception {\n+        bais.reset();\n+        DataInputStream dis = new DataInputStream(bais);\n+        for (int i = 0; i < size \/ 2; i++) {\n+            bh.consume(dis.readChar());\n+        }\n+    }\n+\n+    @Benchmark\n+    public void readInt(Blackhole bh) throws Exception {\n+        bais.reset();\n+        DataInputStream dis = new DataInputStream(bais);\n+        for (int i = 0; i < size \/ 4; i++) {\n+            bh.consume(dis.readInt());\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/DataInputStreamTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.math;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class Fp16ConversionBenchmark {\n+\n+  @Param({\"2048\"})\n+  public int size;\n+\n+  public short[] f16in;\n+  public short[] f16out;\n+  public float[] fin;\n+  public float[] fout;\n+  public static short f16, s;\n+  public static float f;\n+\n+  @Setup(Level.Trial)\n+  public void BmSetup() {\n+      int i = 0;\n+      Random r = new Random(1024);\n+\n+      f16in  = new short[size];\n+      f16out = new short[size];\n+      f16    = (short) r.nextInt();\n+\n+      for (; i < size; i++) {\n+          f16in[i] = Float.floatToFloat16(r.nextFloat());;\n+      }\n+\n+      fin  = new float[size];\n+      fout = new float[size];\n+      f    = r.nextFloat();\n+\n+      i = 0;\n+\n+      for (; i < size; i++) {\n+          fin[i] = Float.float16ToFloat((short)r.nextInt());\n+      }\n+  }\n+\n+  @Benchmark\n+  public short[] floatToFloat16() {\n+      for (int i = 0; i < fin.length; i++) {\n+          f16out[i] = Float.floatToFloat16(fin[i]);\n+      }\n+      return f16out;\n+  }\n+\n+  @Benchmark\n+  public float[] float16ToFloat() {\n+      for (int i = 0; i < f16in.length; i++) {\n+          fout[i] = Float.float16ToFloat(f16in[i]);\n+      }\n+      return fout;\n+  }\n+\n+  @Benchmark\n+  public float float16ToFloatMemory() {\n+      f = Float.float16ToFloat(f16);\n+      return f;\n+  }\n+\n+  @Benchmark\n+  public short floatToFloat16Memory() {\n+      s = Float.floatToFloat16(f);\n+      return s;\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/Fp16ConversionBenchmark.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/\/\n+\/\/ Copyright (c) 2022, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class IndexVectorBenchmark {\n+    @Param({\"1024\"})\n+    private int size;\n+\n+    private byte[] ba;\n+    private short[] sa;\n+    private int[] ia;\n+    private long[] la;\n+    private float[] fa;\n+    private double[] da;\n+\n+    private static final VectorSpecies<Byte> bspecies = VectorSpecies.ofLargestShape(byte.class);\n+    private static final VectorSpecies<Short> sspecies = VectorSpecies.ofLargestShape(short.class);\n+    private static final VectorSpecies<Integer> ispecies = VectorSpecies.ofLargestShape(int.class);\n+    private static final VectorSpecies<Long> lspecies = VectorSpecies.ofLargestShape(long.class);\n+    private static final VectorSpecies<Float> fspecies = VectorSpecies.ofLargestShape(float.class);\n+    private static final VectorSpecies<Double> dspecies = VectorSpecies.ofLargestShape(double.class);\n+\n+    @Setup(Level.Trial)\n+    public void Setup() {\n+        ba = new byte[size];\n+        sa = new short[size];\n+        ia = new int[size];\n+        la = new long[size];\n+        fa = new float[size];\n+        da = new double[size];\n+    }\n+\n+    @Benchmark\n+    public void byteIndexVector() {\n+        for (int i = 0; i < size; i += bspecies.length()) {\n+            ((ByteVector) bspecies.broadcast(0).addIndex(i % 2)).intoArray(ba, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void shortIndexVector() {\n+        for (int i = 0; i < size; i += sspecies.length()) {\n+            ((ShortVector) sspecies.broadcast(0).addIndex(i % 5)).intoArray(sa, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void intIndexVector() {\n+        for (int i = 0; i < size; i += ispecies.length()) {\n+            ((IntVector) ispecies.broadcast(0).addIndex(i % 5)).intoArray(ia, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longIndexVector() {\n+        for (int i = 0; i < size; i += lspecies.length()) {\n+            ((LongVector) lspecies.broadcast(0).addIndex(i % 5)).intoArray(la, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void floatIndexVector() {\n+        for (int i = 0; i < size; i += fspecies.length()) {\n+            ((FloatVector) fspecies.broadcast(0).addIndex(i % 5)).intoArray(fa, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void doubleIndexVector() {\n+        for (int i = 0; i < size; i += dspecies.length()) {\n+            ((DoubleVector) dspecies.broadcast(0).addIndex(i % 5)).intoArray(da, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/IndexVectorBenchmark.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Random;\n@@ -35,0 +36,2 @@\n+    @Param({\"512\", \"1024\"})\n+    static int SIZE;\n@@ -36,7 +39,6 @@\n-    FloatVector fvec256;\n-    FloatVector fvec512;\n-    DoubleVector dvec512;\n-\n-    static final float [] float_arr = {\n-      1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f,\n-      9.0f, 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 16.0f\n+    static final float [] float_sp_vals = {\n+       Float.NaN,\n+       Float.POSITIVE_INFINITY,\n+       Float.NEGATIVE_INFINITY,\n+       0.0f,\n+       -0.0f\n@@ -45,3 +47,6 @@\n-    static final double [] double_arr = {\n-      1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0,\n-      9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0\n+    static final double [] double_sp_vals = {\n+       Double.NaN,\n+       Double.POSITIVE_INFINITY,\n+       Double.NEGATIVE_INFINITY,\n+       0.0,\n+       -0.0\n@@ -50,0 +55,12 @@\n+    static float [] float_arr;\n+\n+    static double [] double_arr;\n+\n+    static long [] long_res;\n+\n+    static int [] int_res;\n+\n+    static short [] short_res;\n+\n+    static byte [] byte_res;\n+\n@@ -52,3 +69,496 @@\n-        fvec256 = FloatVector.fromArray(FloatVector.SPECIES_256, float_arr, 0);\n-        fvec512 = FloatVector.fromArray(FloatVector.SPECIES_512, float_arr, 0);\n-        dvec512 = DoubleVector.fromArray(DoubleVector.SPECIES_512, double_arr, 0);\n+        Random r = new Random(1024);\n+        float_arr = new float[SIZE];\n+        double_arr = new double[SIZE];\n+        long_res = new long[SIZE];\n+        int_res = new int[SIZE * 2];\n+        short_res = new short[SIZE * 4];\n+        byte_res = new byte[SIZE * 8];\n+        for(int i = 0; i < SIZE; i++) {\n+            float_arr[i] = SIZE * r.nextFloat();\n+            double_arr[i] = SIZE * r.nextDouble();\n+        }\n+        for(int i = 0 ; i < SIZE; i += 100) {\n+            System.arraycopy(float_sp_vals, 0, float_arr, i, float_sp_vals.length);\n+            System.arraycopy(double_sp_vals, 0, double_arr, i, double_sp_vals.length);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void microFloat128ToByte128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToByte256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToByte512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 16); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToShort128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToShort256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToShort512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToInteger128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToInteger256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToInteger512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToLong128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToLong256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat128ToLong512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToByte128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToByte256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToByte512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToShort128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToShort256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToShort512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToInteger128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToInteger256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToInteger512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToLong128() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToLong256() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microFloat256ToLong512() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToByte128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToByte256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 16); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToByte512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 32); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToShort128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToShort256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToShort512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 16); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToInteger128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToInteger256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToInteger512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToLong128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToLong256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble128ToLong512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_128;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble256ToByte128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble256ToByte256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble256ToByte512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Byte> OSPECIES = ByteVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 16); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2B, OSPECIES, 0)\n+                .reinterpretAsBytes()\n+                .intoArray(byte_res, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void microDouble256ToShort128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n@@ -58,2 +568,9 @@\n-    public Vector microFloat2Int() {\n-        return fvec512.convertShape(VectorOperators.F2I, IntVector.SPECIES_512, 0);\n+    public void microDouble256ToShort256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n@@ -63,2 +580,9 @@\n-    public Vector microFloat2Long() {\n-        return fvec256.convertShape(VectorOperators.F2L, LongVector.SPECIES_512, 0);\n+    public void microDouble256ToShort512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 8); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n@@ -68,2 +592,9 @@\n-    public Vector microFloat2Short() {\n-        return fvec512.convertShape(VectorOperators.F2S, ShortVector.SPECIES_256, 0);\n+    public void microDouble256ToInteger128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n@@ -73,2 +604,9 @@\n-    public Vector microFloat2Byte() {\n-        return fvec512.convertShape(VectorOperators.F2B, ByteVector.SPECIES_128, 0);\n+    public void microDouble256ToInteger256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n@@ -78,2 +616,9 @@\n-    public Vector microDouble2Int() {\n-        return dvec512.convertShape(VectorOperators.D2I, IntVector.SPECIES_256, 0);\n+    public void microDouble256ToInteger512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Integer> OSPECIES = IntVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 4); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2I, OSPECIES, 0)\n+                .reinterpretAsInts()\n+                .intoArray(int_res, j);\n+        }\n@@ -83,2 +628,9 @@\n-    public Vector microDouble2Long() {\n-        return dvec512.convertShape(VectorOperators.D2L, LongVector.SPECIES_512, 0);\n+    public void microDouble256ToLong128() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_128;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n@@ -88,2 +640,9 @@\n-    public Vector microDouble2Short() {\n-        return dvec512.convertShape(VectorOperators.D2S, ShortVector.SPECIES_128, 0);\n+    public void microDouble256ToLong256() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_256;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n@@ -93,2 +652,9 @@\n-    public Vector microDouble2Byte() {\n-        return dvec512.convertShape(VectorOperators.D2B, ByteVector.SPECIES_64, 0);\n+    public void microDouble256ToLong512() {\n+        VectorSpecies<Double> ISPECIES = DoubleVector.SPECIES_256;\n+        VectorSpecies<Long> OSPECIES = LongVector.SPECIES_512;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            DoubleVector.fromArray(ISPECIES, double_arr, i)\n+                .convertShape(VectorOperators.D2L, OSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .intoArray(long_res, j);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorFPtoIntCastOperations.java","additions":595,"deletions":29,"binary":false,"changes":624,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests transformation that converts `~x` into `-1-x` when `~x` is\n+ * used in an arithmetic expression.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 20, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 20, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class NotOpTransformation {\n+\n+    private static final int I_C = 1234567;\n+\n+    private static final long L_C = 123_456_789_123_456L;\n+\n+    private int iFld = 4711;\n+\n+    private long lFld = 4711 * 4711 * 4711;\n+\n+    @Benchmark\n+    public void baselineInt(Blackhole bh) {\n+        bh.consume(iFld);\n+    }\n+\n+    @Benchmark\n+    public void baselineLong(Blackhole bh) {\n+        bh.consume(lFld);\n+    }\n+\n+    \/\/ Convert c-(~x)-x into c-(-1-x)-x, which is finally converted\n+    \/\/ into c+1.\n+    @Benchmark\n+    public void testInt1(Blackhole bh) {\n+        bh.consume(I_C - (~iFld) - iFld);\n+    }\n+\n+    \/\/ Convert ~(c-x)-x into -1-(c-x)-x, which is finally converted\n+    \/\/ into -1-c.\n+    @Benchmark\n+    public void testInt2(Blackhole bh) {\n+        bh.consume(~(I_C - iFld) - iFld);\n+    }\n+\n+    \/\/ Convert c-(~x)-x into c-(-1-x)-x, which is finally converted\n+    \/\/ into c+1.\n+    @Benchmark\n+    public void testLong1(Blackhole bh) {\n+        bh.consume(L_C - (~lFld) - lFld);\n+    }\n+\n+    \/\/ Convert ~(c-x)-x into -1-(c-x)-x, which is finally converted\n+    \/\/ into -1-c.\n+    @Benchmark\n+    public void testLong2(Blackhole bh) {\n+        bh.consume(~(L_C - lFld) - lFld);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/NotOpTransformation.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler.x86;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1)\n+@State(Scope.Thread)\n+public class LeaPeephole {\n+    static final int ITERATION = 1000;\n+\n+    int x, y;\n+\n+    @Benchmark\n+    public void B_I_int(Blackhole bh) {\n+        int x = this.x;\n+        int y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            int x1 = x + y;\n+            x = x1 + y;\n+            y = x1 + x;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+\n+    @Benchmark\n+    public void B_D_int(Blackhole bh) {\n+        int x = this.x;\n+        int y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x + 10);\n+            bh.consume(x + 20);\n+            bh.consume(x + 30);\n+            bh.consume(y + 10);\n+            bh.consume(y + 20);\n+            bh.consume(y + 30);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void I_S_int(Blackhole bh) {\n+        int x = this.x;\n+        int y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x << 1);\n+            bh.consume(x << 2);\n+            bh.consume(x << 3);\n+            bh.consume(y << 1);\n+            bh.consume(y << 2);\n+            bh.consume(y << 3);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void B_I_long(Blackhole bh) {\n+        long x = this.x;\n+        long y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            long x1 = x + y;\n+            x = x1 + y;\n+            y = x1 + x;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+\n+    @Benchmark\n+    public void B_D_long(Blackhole bh) {\n+        long x = this.x;\n+        long y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x + 10);\n+            bh.consume(x + 20);\n+            bh.consume(x + 30);\n+            bh.consume(y + 10);\n+            bh.consume(y + 20);\n+            bh.consume(y + 30);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void I_S_long(Blackhole bh) {\n+        long x = this.x;\n+        long y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x << 1);\n+            bh.consume(x << 2);\n+            bh.consume(x << 3);\n+            bh.consume(y << 1);\n+            bh.consume(y << 2);\n+            bh.consume(y << 3);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/LeaPeephole.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}