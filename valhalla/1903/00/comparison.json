{"files":[{"patch":"@@ -324,1 +324,0 @@\n-\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -96,0 +96,12 @@\n+\/\/\n+\/\/ LIMITATION:\n+\/\/\n+\/\/ CDSHeapVerifier can only check for problems with object identity. In the example above,\n+\/\/ if the Bar type has identity, the program's correctness requires that the identity\n+\/\/ of Foo.bar and Bar.bar to be equal. This requirement can be checked by CDSHeapVerifier.\n+\/\/\n+\/\/ However, if Bar does not have identity (e.g., it's a value class, or is a primitive type),\n+\/\/ the program's correctness no longer requires that the identity of Foo.bar and Bar.bar\n+\/\/ to be equal (since they don't have an identity anymore). While the program's\n+\/\/ correctness may still have certain assumptions about Foo.bar and Bar.bar (such as the\n+\/\/ internal fields of these two values), such assumptions cannot be checked by CDSHeapVerifier.\n@@ -296,0 +308,8 @@\n+      if (!field_type->is_identity_class()) {\n+        \/\/ See comment of LIMITATION above\n+        \/\/ Any concrete value class will have a field \".null_reset\" which holds an\n+        \/\/ all-zero instance of the value class so it will not change between\n+        \/\/ dump time and runtime.\n+        return;\n+      }\n+\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -819,0 +819,19 @@\n+  Klass* k = java_lang_Class::as_Klass(orig_mirror);\n+  if (k != nullptr && k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+\n+    if (ik->is_inline_klass() && ik->is_initialized()) {\n+      \/\/ Only concrete value classes need the null_reset field\n+      InlineKlass* ilk = InlineKlass::cast(k);\n+      if (ilk->has_nullable_atomic_layout()) {\n+        scratch_m->obj_field_put(ilk->null_reset_value_offset(), ilk->null_reset_value());\n+      }\n+    }\n+\n+    if (ik->has_acmp_maps_offset()) {\n+      int maps_offset = ik->acmp_maps_offset();\n+      oop maps = orig_mirror->obj_field(maps_offset);\n+      scratch_m->obj_field_put(maps_offset, maps);\n+    }\n+  }\n+\n@@ -1984,1 +2003,2 @@\n-      if (subgraph_k->is_instance_klass() &&\n+\n+      if (subgraph_k->is_identity_class() &&\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -5547,1 +5547,4 @@\n-    typeArrayOop map = oopFactory::new_intArray(nonoop_acmp_map_size + oop_acmp_map_size + 1, CHECK);\n+    int acmp_map_size = nonoop_acmp_map_size + oop_acmp_map_size + 1;\n+\n+    _acmp_maps_array = MetadataFactory::new_array<int>(loader_data(), acmp_map_size, CHECK);\n+    typeArrayOop map = oopFactory::new_intArray(acmp_map_size, CHECK);\n@@ -5550,0 +5553,1 @@\n+    _acmp_maps_array->at_put(0, _layout_info->_nonoop_acmp_map->length());\n@@ -5553,0 +5557,3 @@\n+\n+      _acmp_maps_array->at_put(i * 2 + 1, _layout_info->_nonoop_acmp_map->at(i).first);\n+      _acmp_maps_array->at_put(i * 2 + 2, _layout_info->_nonoop_acmp_map->at(i).second);\n@@ -5557,0 +5564,1 @@\n+      _acmp_maps_array->at_put(oop_map_start + i, _layout_info->_oop_acmp_map->at(i));\n@@ -5558,0 +5566,1 @@\n+    assert(_acmp_maps_array->length() == map->length(), \"sanity\");\n@@ -5559,0 +5568,4 @@\n+    ik->set_acmp_maps_array(_acmp_maps_array);\n+\n+    \/\/ Clear out this field so it doesn't get deallocated by the destructor\n+    _acmp_maps_array = nullptr;\n@@ -5642,0 +5655,1 @@\n+  _acmp_maps_array(nullptr),\n@@ -5781,0 +5795,4 @@\n+  if (_acmp_maps_array != nullptr) {\n+    MetadataFactory::free_array<int>(_loader_data, _acmp_maps_array);\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -159,0 +159,1 @@\n+  Array<int>* _acmp_maps_array;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -598,0 +598,1 @@\n+  _acmp_maps_array(nullptr),\n@@ -809,0 +810,5 @@\n+  if (acmp_maps_array() != nullptr) {\n+    MetadataFactory::free_array<int>(loader_data, acmp_maps_array());\n+  }\n+  set_acmp_maps_array(nullptr);\n+\n@@ -2205,1 +2211,1 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n@@ -2215,1 +2221,1 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n@@ -2962,0 +2968,1 @@\n+  it->push(&_acmp_maps_array, MetaspaceClosure::_writable);\n@@ -3135,0 +3142,12 @@\n+  \/\/ restore acmp_maps java array from the version stored in metadata\n+  \/\/ if it cannot be found in the archive\n+  if (Arguments::is_valhalla_enabled() && has_acmp_maps_offset() && java_mirror()->obj_field(_acmp_maps_offset) == nullptr) {\n+    int acmp_maps_size = _acmp_maps_array->length();\n+    typeArrayOop map = oopFactory::new_intArray(acmp_maps_size, CHECK);\n+    typeArrayHandle map_h(THREAD, map);\n+    for (int i = 0; i < acmp_maps_size; i++) {\n+      map_h->int_at_put(i, _acmp_maps_array->at(i));\n+    }\n+    java_mirror()->obj_field_put(_acmp_maps_offset, map_h());\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-  int             _acmp_maps_offset;        \/\/ offset to injected static field storing acmp_maps for values classes\n+  int             _acmp_maps_offset;        \/\/ offset to injected static field storing .acmp_maps for values classes\n@@ -327,0 +327,4 @@\n+  Array<int>* _acmp_maps_array; \/\/ Metadata copy of the acmp_maps oop used in value classes.\n+                                \/\/ When loading an inline klass from the CDS\/AOT archive\n+                                \/\/ this copy can be used to regenerate the \".acmp_maps\" oop\n+                                \/\/ if it is not stored in the archive.\n@@ -497,0 +501,3 @@\n+  Array<int>* acmp_maps_array() const { return _acmp_maps_array; }\n+  void set_acmp_maps_array(Array<int>* array) { _acmp_maps_array = array; }\n+\n@@ -649,0 +656,4 @@\n+  bool has_acmp_maps_offset() const {\n+    return _acmp_maps_offset != 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1974,4 +1974,0 @@\n-  if (UseAltSubstitutabilityMethod) {\n-    no_shared_spaces(\"Alternate substitutability method doesn't work with CDS yet\");\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2055,1 +2055,1 @@\n-  product(bool, UseAltSubstitutabilityMethod, false,                        \\\n+  product(bool, UseAltSubstitutabilityMethod, true,                         \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -358,0 +358,4 @@\n+        Asserts.assertTrue(lo.getCurrentLine().startsWith(\"Non-oop acmp map\"), lo.getCurrentLine());\n+        lo.moveToNextLine();\n+        Asserts.assertTrue(lo.getCurrentLine().startsWith(\"oop acmp map\"), lo.getCurrentLine());\n+        lo.moveToNextLine();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/FieldLayoutAnalyzer.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-\n-valhalla\/valuetypes\/SubstitutabilityTest.java                  8374025 generic-all\n","filename":"test\/jdk\/ProblemList-AotJdk.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,14 +275,0 @@\n-\n-    \/*\n-     * Throw SOE for large graph\n-     *\/\n-    @Test\n-    public void largeGraph() {\n-        N node = build();\n-        long start = System.nanoTime();\n-        \/\/ With the alternate isSubstitutable() method, type recursion is handled differently\n-        \/\/ and the line below won't throw a SOE\n-        assertThrows(StackOverflowError.class, () -> { boolean v = node.l == node.r; });\n-        assertThrows(StackOverflowError.class, () -> { int hc = node.hashCode(); });\n-        System.out.format(\"testing large graph: %d ms%n\", (System.nanoTime() - start) \/ 1000);\n-    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/RecursiveValueClass.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run junit\/othervm -Xshare:off -XX:+UseAltSubstitutabilityMethod SubstitutabilityTest\n+ * @run junit\/othervm -Xshare:off SubstitutabilityTest\n","filename":"test\/jdk\/valhalla\/valuetypes\/SubstitutabilityTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}