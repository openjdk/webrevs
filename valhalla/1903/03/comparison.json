{"files":[{"patch":"@@ -96,0 +96,12 @@\n+\/\/\n+\/\/ LIMITATION:\n+\/\/\n+\/\/ CDSHeapVerifier can only check for problems with object identity. In the example above,\n+\/\/ if the Bar type has identity, the program's correctness requires that the identity\n+\/\/ of Foo.bar and Bar.bar to be equal. This requirement can be checked by CDSHeapVerifier.\n+\/\/\n+\/\/ However, if Bar does not have identity (e.g., it's a value class, or is a primitive type),\n+\/\/ the program's correctness no longer requires that the identity of Foo.bar and Bar.bar\n+\/\/ to be equal (since they don't have an identity anymore). While the program's\n+\/\/ correctness may still have certain assumptions about Foo.bar and Bar.bar (such as the\n+\/\/ internal fields of these two values), such assumptions cannot be checked by CDSHeapVerifier.\n@@ -296,0 +308,8 @@\n+      if (!field_type->is_identity_class()) {\n+        \/\/ See comment of LIMITATION above\n+        \/\/ Any concrete value class will have a field \".null_reset\" which holds an\n+        \/\/ all-zero instance of the value class so it will not change between\n+        \/\/ dump time and runtime.\n+        return;\n+      }\n+\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -819,0 +819,19 @@\n+  Klass* k = java_lang_Class::as_Klass(orig_mirror);\n+  if (k != nullptr && k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+\n+    if (ik->is_inline_klass() && ik->is_initialized()) {\n+      \/\/ Only concrete value classes need the null_reset field\n+      InlineKlass* ilk = InlineKlass::cast(k);\n+      if (ilk->has_nullable_atomic_layout()) {\n+        scratch_m->obj_field_put(ilk->null_reset_value_offset(), ilk->null_reset_value());\n+      }\n+    }\n+\n+    if (ik->has_acmp_maps_offset()) {\n+      int maps_offset = ik->acmp_maps_offset();\n+      oop maps = orig_mirror->obj_field(maps_offset);\n+      scratch_m->obj_field_put(maps_offset, maps);\n+    }\n+  }\n+\n@@ -1984,1 +2003,2 @@\n-      if (subgraph_k->is_instance_klass() &&\n+\n+      if (subgraph_k->is_identity_class() &&\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -5547,1 +5547,4 @@\n-    typeArrayOop map = oopFactory::new_intArray(nonoop_acmp_map_size + oop_acmp_map_size + 1, CHECK);\n+    int acmp_map_size = nonoop_acmp_map_size + oop_acmp_map_size + 1;\n+\n+    typeArrayOop map = oopFactory::new_intArray(acmp_map_size, CHECK);\n+    Array<int>* acmp_maps_array = MetadataFactory::new_array<int>(loader_data(), acmp_map_size, CHECK);\n@@ -5550,0 +5553,1 @@\n+    acmp_maps_array->at_put(0, _layout_info->_nonoop_acmp_map->length());\n@@ -5553,0 +5557,4 @@\n+\n+      \/\/ Also store acmp maps as metadata for regeneration when using dynamic archive or AOT training data.\n+      acmp_maps_array->at_put(i * 2 + 1, _layout_info->_nonoop_acmp_map->at(i).first);\n+      acmp_maps_array->at_put(i * 2 + 2, _layout_info->_nonoop_acmp_map->at(i).second);\n@@ -5557,0 +5565,1 @@\n+      acmp_maps_array->at_put(oop_map_start + i, _layout_info->_oop_acmp_map->at(i));\n@@ -5558,0 +5567,1 @@\n+    assert(acmp_maps_array->length() == map->length(), \"sanity\");\n@@ -5559,0 +5569,1 @@\n+    ik->set_acmp_maps_array(acmp_maps_array);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -598,0 +598,1 @@\n+  _acmp_maps_array(nullptr),\n@@ -809,0 +810,5 @@\n+  if (acmp_maps_array() != nullptr) {\n+    MetadataFactory::free_array<int>(loader_data, acmp_maps_array());\n+  }\n+  set_acmp_maps_array(nullptr);\n+\n@@ -2205,1 +2211,1 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n@@ -2215,1 +2221,1 @@\n-  for (JavaFieldStream fs(this); !fs.done(); fs.next()) {\n+  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n@@ -2962,0 +2968,1 @@\n+  it->push(&_acmp_maps_array, MetaspaceClosure::_writable);\n@@ -3135,0 +3142,12 @@\n+  \/\/ Restore acmp_maps java array from the version stored in metadata.\n+  \/\/ if it cannot be found in the archive\n+  if (Arguments::is_valhalla_enabled() && has_acmp_maps_offset() && java_mirror()->obj_field(_acmp_maps_offset) == nullptr) {\n+    int acmp_maps_size = _acmp_maps_array->length();\n+    typeArrayOop map = oopFactory::new_intArray(acmp_maps_size, CHECK);\n+    typeArrayHandle map_h(THREAD, map);\n+    for (int i = 0; i < acmp_maps_size; i++) {\n+      map_h->int_at_put(i, _acmp_maps_array->at(i));\n+    }\n+    java_mirror()->obj_field_put(_acmp_maps_offset, map_h());\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-  int             _acmp_maps_offset;        \/\/ offset to injected static field storing acmp_maps for values classes\n+  int             _acmp_maps_offset;        \/\/ offset to injected static field storing .acmp_maps for values classes\n@@ -327,0 +327,4 @@\n+  Array<int>* _acmp_maps_array; \/\/ Metadata copy of the acmp_maps oop used in value classes.\n+                                \/\/ When loading an inline klass from the CDS\/AOT archive\n+                                \/\/ this copy can be used to regenerate the \".acmp_maps\" oop\n+                                \/\/ if it is not stored in the archive.\n@@ -497,0 +501,3 @@\n+  Array<int>* acmp_maps_array() const { return _acmp_maps_array; }\n+  void set_acmp_maps_array(Array<int>* array) { _acmp_maps_array = array; }\n+\n@@ -649,0 +656,4 @@\n+  bool has_acmp_maps_offset() const {\n+    return _acmp_maps_offset != 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1974,4 +1974,0 @@\n-  if (UseAltSubstitutabilityMethod) {\n-    no_shared_spaces(\"Alternate substitutability method doesn't work with CDS yet\");\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2056,1 +2056,1 @@\n-  product(bool, UseAltSubstitutabilityMethod, false,                        \\\n+  product(bool, UseAltSubstitutabilityMethod, true,                         \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Nullable flat fields test for dynamic archive\n+ * @requires vm.cds\n+ * @requires vm.debug == true\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @compile ..\/test-classes\/NullableFlatFieldApp.java\n+ * @compile ..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Asserts.java\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar nullable_flat.jar NullableFlatFieldApp\n+ *  NullableFlatFieldApp$Value0 NullableFlatFieldApp$Container0\n+ *  NullableFlatFieldApp$Value1a NullableFlatFieldApp$Value1b\n+ *  NullableFlatFieldApp$Value2a NullableFlatFieldApp$Value2b\n+ *  NullableFlatFieldApp$Container1 NullableFlatFieldApp$Container2\n+ *  NullableFlatFieldApp$Value3 NullableFlatFieldApp$Container3\n+ *  jdk\/test\/lib\/Asserts\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. NullableFlatFieldDynamicTest\n+ *\/\n+\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class NullableFlatFieldDynamicTest extends DynamicArchiveTestBase {\n+    public static void main(String[] args) throws Exception {\n+        runTest(NullableFlatFieldDynamicTest::test);\n+    }\n+\n+    static void test() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top\");\n+        String baseArchiveName = getNewArchiveName(\"base\");\n+        TestCommon.dumpBaseArchive(baseArchiveName, \"--enable-preview\", \"-Xlog:cds\");\n+        doTest(baseArchiveName, topArchiveName);\n+    }\n+\n+    private static void doTest(String baseArchiveName, String topArchiveName) throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"nullable_flat.jar\");\n+        String mainClass = \"NullableFlatFieldApp\";\n+        dump2(baseArchiveName, topArchiveName,\n+             \"--enable-preview\",\n+             \"-XX:+UseNullableValueFlattening\",\n+             \"-XX:+UnlockDiagnosticVMOptions\",\n+             \"-XX:+PrintInlineLayout\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+        run2(baseArchiveName, topArchiveName,\n+            \"--enable-preview\",\n+            \"-XX:+UseNullableValueFlattening\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+PrintInlineLayout\",\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=debug,cds=debug\",\n+            \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"NullableFlatFieldApp source: shared objects file\")\n+                          .shouldHaveExitValue(0);\n+              });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/NullableFlatFieldDynamicTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,11 +24,0 @@\n- \/*\n- * @test NullableFlatFieldTest\n- * @requires vm.debug == true\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.vm.annotation\n- * @enablePreview\n- * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlineLayout runtime.valhalla.inlinetypes.NullableFlatFieldTest\n- *\/\n-\n-package runtime.valhalla.inlinetypes;\n-\n@@ -40,1 +29,1 @@\n-public class NullableFlatFieldTest {\n+public class NullableFlatFieldApp {\n@@ -298,1 +287,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/NullableFlatFieldApp.java","additions":2,"deletions":14,"binary":false,"changes":16,"previous_filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/NullableFlatFieldTest.java","status":"copied"},{"patch":"@@ -358,0 +358,4 @@\n+        Asserts.assertTrue(lo.getCurrentLine().startsWith(\"Non-oop acmp map\"), lo.getCurrentLine());\n+        lo.moveToNextLine();\n+        Asserts.assertTrue(lo.getCurrentLine().startsWith(\"oop acmp map\"), lo.getCurrentLine());\n+        lo.moveToNextLine();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/FieldLayoutAnalyzer.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\n-valhalla\/valuetypes\/SubstitutabilityTest.java                  8374025 generic-all\n","filename":"test\/jdk\/ProblemList-AotJdk.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,14 +275,0 @@\n-\n-    \/*\n-     * Throw SOE for large graph\n-     *\/\n-    @Test\n-    public void largeGraph() {\n-        N node = build();\n-        long start = System.nanoTime();\n-        \/\/ With the alternate isSubstitutable() method, type recursion is handled differently\n-        \/\/ and the line below won't throw a SOE\n-        assertThrows(StackOverflowError.class, () -> { boolean v = node.l == node.r; });\n-        assertThrows(StackOverflowError.class, () -> { int hc = node.hashCode(); });\n-        System.out.format(\"testing large graph: %d ms%n\", (System.nanoTime() - start) \/ 1000);\n-    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/RecursiveValueClass.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run junit\/othervm -Xshare:off -XX:+UseAltSubstitutabilityMethod SubstitutabilityTest\n+ * @run junit\/othervm -Xshare:off SubstitutabilityTest\n","filename":"test\/jdk\/valhalla\/valuetypes\/SubstitutabilityTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}