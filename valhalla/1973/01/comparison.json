{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,0 +160,1 @@\n+  macro(early_larval, arg1, arg2) \\\n@@ -224,1 +225,2 @@\n-      return frame_type + 1; }\n+    return frame_type + 1;\n+  }\n@@ -226,1 +228,2 @@\n-      return checked_cast<u1>(offset_delta - 1); }\n+    return checked_cast<u1>(offset_delta - 1);\n+  }\n@@ -330,1 +333,2 @@\n-      return frame_type - 63; }\n+    return frame_type - 63;\n+  }\n@@ -332,1 +336,2 @@\n-      return (u1)(offset_delta + 63); }\n+    return (u1)(offset_delta + 63);\n+  }\n@@ -402,0 +407,69 @@\n+class early_larval : public stack_map_frame {\n+ private:\n+  static int frame_type_to_offset_delta(u1 frame_type) {\n+    return 0;\n+  }\n+  static u1 offset_delta_to_frame_type(int offset_delta) {\n+    return checked_cast<u1>(246);\n+  }\n+\n+  address num_unset_fields_addr() const { return frame_type_addr() + sizeof(u1); }\n+  int number_of_unset_fields() const { return Bytes::get_Java_u2(num_unset_fields_addr()); }\n+\n+  \/\/ EARLY_LARVAL frames wrap regular stack map frames\n+  stack_map_frame* nested_frame() const { return (stack_map_frame*)(frame_type_addr() + calculate_size(number_of_unset_fields())); }\n+\n+ public:\n+  static bool is_frame_type(u1 tag) {\n+    return tag == 246;\n+  }\n+\n+  static early_larval* at(address addr) {\n+    assert(is_frame_type(*addr), \"Wrong frame id\");\n+    return (early_larval*)addr;\n+  }\n+\n+  static early_larval* create_at(address addr, int offset_delta) {\n+    early_larval* sm = (early_larval*)addr;\n+    return sm;\n+  }\n+\n+  static size_t calculate_size(u2 num_unset_fields) { return sizeof(u1) + sizeof(u2) + (sizeof(u2) * num_unset_fields); }\n+\n+  size_t size() const { return calculate_size(number_of_unset_fields()) + nested_frame()->size(); }\n+  int offset_delta() const { return nested_frame()->offset_delta(); }\n+\n+  void set_offset_delta(int offset_delta) {\n+    assert(offset_delta == 0, \"early_larval should not have an offset\");\n+    set_frame_type(offset_delta_to_frame_type(offset_delta));\n+  }\n+\n+  int number_of_types() const { return 0; }\n+  verification_type_info* types() const { return nullptr; }\n+\n+  bool is_valid_offset(int offset_delta) const {\n+    return is_frame_type(offset_delta_to_frame_type(offset_delta));\n+  }\n+\n+  bool verify_subtype(address start, address end) const {\n+    return nested_frame()->verify(start, end);\n+  }\n+\n+  void print_on(outputStream* st, int current_offset = -1) const {\n+    st->print(\"early_larval(%d unset fields: \", number_of_unset_fields());\n+    st->print(\"[ \");\n+    address addr = num_unset_fields_addr() + sizeof(u2);\n+    for (int i = 0; i < number_of_unset_fields(); i++) {\n+      st->print(\"%u \", Bytes::get_Java_u2(addr + (i * sizeof(u2))));\n+    }\n+    st->print_cr(\"])\");\n+    st->print(\"\\t\");\n+    nested_frame()->print_on(st, current_offset);\n+  }\n+\n+  void print_truncated(outputStream* st, int current_offset = -1) const {\n+    \/\/ If we fail to verify, we may have a nested early_larval\n+    st->print(\"early_larval(%d unset fields), output truncated, Stackmap exceeds table size.\", number_of_unset_fields());\n+  }\n+};\n+\n@@ -660,1 +734,2 @@\n-      return end_of_locals; }\n+    return end_of_locals;\n+  }\n@@ -662,1 +737,2 @@\n-      return stack_slots_addr(end_of_locals) + sizeof(u2); }\n+    return stack_slots_addr(end_of_locals) + sizeof(u2);\n+  }\n@@ -933,1 +1009,2 @@\n-      return (address)this; }\n+    return (address)this;\n+  }\n@@ -935,1 +1012,2 @@\n-      return name_index_addr() + sizeof(u2); }\n+    return name_index_addr() + sizeof(u2);\n+  }\n@@ -937,1 +1015,2 @@\n-      return attribute_length_addr() + sizeof(u4); }\n+    return attribute_length_addr() + sizeof(u4);\n+  }\n@@ -951,1 +1030,2 @@\n-    return Bytes::get_Java_u2(name_index_addr()); }\n+    return Bytes::get_Java_u2(name_index_addr());\n+  }\n@@ -953,1 +1033,2 @@\n-    return Bytes::get_Java_u4(attribute_length_addr()); }\n+    return Bytes::get_Java_u4(attribute_length_addr());\n+  }\n","filename":"src\/hotspot\/share\/classfile\/stackMapTableFormat.hpp","additions":93,"deletions":12,"binary":false,"changes":105,"status":"modified"}]}