{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,0 +160,1 @@\n+  macro(early_larval, arg1, arg2) \\\n@@ -402,0 +403,67 @@\n+class early_larval : public stack_map_frame {\n+ private:\n+  static int frame_type_to_offset_delta(u1 frame_type) {\n+      return 0; }\n+  static u1 offset_delta_to_frame_type(int offset_delta) {\n+      return checked_cast<u1>(246); }\n+\n+  address num_unset_fields_addr() const { return frame_type_addr() + sizeof(u1); }\n+  int number_of_unset_fields() const { return Bytes::get_Java_u2(num_unset_fields_addr()); }\n+\n+  \/\/ EARLY_LARVAL frames wrap regular stack map frames\n+  stack_map_frame* nested_frame() const { return (stack_map_frame*)(frame_type_addr() + calculate_size(number_of_unset_fields())); }\n+\n+ public:\n+  static bool is_frame_type(u1 tag) {\n+    return tag == 246;\n+  }\n+\n+  static early_larval* at(address addr) {\n+    assert(is_frame_type(*addr), \"Wrong frame id\");\n+    return (early_larval*)addr;\n+  }\n+\n+  static early_larval* create_at(address addr, int offset_delta) {\n+    early_larval* sm = (early_larval*)addr;\n+    return sm;\n+  }\n+\n+  static size_t calculate_size(u2 num_unset_fields) { return sizeof(u1) + sizeof(u2) + (sizeof(u2) * num_unset_fields); }\n+\n+  size_t size() const { return calculate_size(number_of_unset_fields()) + nested_frame()->size(); }\n+  int offset_delta() const { return nested_frame()->offset_delta(); }\n+\n+  void set_offset_delta(int offset_delta) {\n+    assert(offset_delta == 0, \"early_larval should not have an offset\");\n+    set_frame_type(offset_delta_to_frame_type(offset_delta));\n+  }\n+\n+  int number_of_types() const { return 0; }\n+  verification_type_info* types() const { return nullptr; }\n+\n+  bool is_valid_offset(int offset_delta) const {\n+    return is_frame_type(offset_delta_to_frame_type(offset_delta));\n+  }\n+\n+  bool verify_subtype(address start, address end) const {\n+    return nested_frame()->verify(start, end);\n+  }\n+\n+  void print_on(outputStream* st, int current_offset = -1) const {\n+    st->print(\"early_larval(%d unset fields: \", number_of_unset_fields());\n+    st->print(\"[ \");\n+    address addr = num_unset_fields_addr() + sizeof(u2);\n+    for (int i = 0; i < number_of_unset_fields(); i++) {\n+      st->print(\"%u \", Bytes::get_Java_u2(addr + (i * sizeof(u2))));\n+    }\n+    st->print_cr(\"])\");\n+    st->print(\"\\t\");\n+    nested_frame()->print_on(st, current_offset);\n+  }\n+\n+  void print_truncated(outputStream* st, int current_offset = -1) const {\n+    \/\/ If we fail to verify, we may have a nested early_larval\n+    st->print(\"early_larval(%d unset fields), output truncated, Stackmap exceeds table size.\", number_of_unset_fields());\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/classfile\/stackMapTableFormat.hpp","additions":69,"deletions":1,"binary":false,"changes":70,"status":"modified"}]}