{"files":[{"patch":"@@ -97,0 +97,1 @@\n+    public Map<JCMethodDecl, Set<Symbol>> initializersAlreadyInConst = new HashMap<>();\n@@ -120,0 +121,6 @@\n+    private void addIncludedInitializer(JCMethodDecl constructor, Symbol varSymbol) {\n+        Set<Symbol> fieldSet = initializersAlreadyInConst.getOrDefault(constructor, new HashSet<>());\n+        fieldSet.add(varSymbol);\n+        initializersAlreadyInConst.put(constructor, fieldSet);\n+    }\n+\n@@ -181,0 +188,2 @@\n+            } else {\n+                addIncludedInitializer(constructor, fieldDecl.sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LocalProxyVarsGen.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+    private final LocalProxyVarsGen localProxyVarsGen;\n@@ -115,0 +116,1 @@\n+        localProxyVarsGen = LocalProxyVarsGen.instance(context);\n@@ -565,0 +567,15 @@\n+        Set<Symbol> fieldsWithInits;\n+        List<JCStatement> inits;\n+        if ((fieldsWithInits = localProxyVarsGen.initializersAlreadyInConst.get(md)) != null) {\n+            ListBuffer<JCStatement> newInitCode = new ListBuffer<>();\n+            for (JCStatement init : initCode) {\n+                Symbol sym = ((JCIdent)((JCAssign)((JCExpressionStatement)init).expr).lhs).sym;\n+                if (!fieldsWithInits.contains(sym)) {\n+                    newInitCode.add(init);\n+                }\n+            }\n+            inits = newInitCode.toList();\n+            localProxyVarsGen.initializersAlreadyInConst.remove(md);\n+        } else {\n+            inits = initCode;\n+        }\n@@ -569,2 +586,2 @@\n-                rewriteInitializersIfNeeded(md, initCode);\n-                md.body.stats = initCode.appendList(md.body.stats);\n+                rewriteInitializersIfNeeded(md, inits);\n+                md.body.stats = inits.appendList(md.body.stats);\n@@ -573,1 +590,1 @@\n-                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.prepend(supercall)));\n+                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, inits.prepend(supercall)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -830,22 +830,4 @@\n-            String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,invokespecial,return\";\n-            String expectedCodeSequenceRecord = \"aload_0,iload_1,putfield,aload_0,invokespecial,return\";\n-            File dir = assertOK(true, data.src);\n-            for (final File fileEntry : dir.listFiles()) {\n-                var classFile = ClassFile.of().parse(fileEntry.toPath());\n-                classFile.methods().stream()\n-                        .filter(mm -> mm.methodName().equalsString(ConstantDescs.INIT_NAME))\n-                        .map(mm -> mm.findAttribute(Attributes.code()).orElseThrow())\n-                        .forEach(code -> {\n-                            List<String> mnemonics = new ArrayList<>();\n-                            for (var coe : code) {\n-                                if (coe instanceof Instruction inst) {\n-                                    mnemonics.add(inst.opcode().name().toLowerCase(Locale.ROOT));\n-                                }\n-                            }\n-                            var foundCodeSequence = String.join(\",\", mnemonics);\n-                            if (!data.isRecord) {\n-                                Assert.check(expectedCodeSequence.equals(foundCodeSequence));\n-                            } else {\n-                                Assert.check(expectedCodeSequenceRecord.equals(foundCodeSequence));\n-                            }\n-                        });\n+            if (!data.isRecord()) {\n+                checkMnemonicsFor(data.src, \"aload_0,bipush,putfield,aload_0,invokespecial,return\");\n+            } else {\n+                checkMnemonicsFor(data.src, \"aload_0,iload_1,putfield,aload_0,invokespecial,return\");\n@@ -865,20 +847,12 @@\n-        {\n-            String expectedCodeSequence = \"aload_0,bipush,putfield,aload_0,iconst_0,putfield,aload_0,invokespecial,getstatic,iconst_0,invokevirtual,return\";\n-            File dir = assertOK(true, source);\n-            for (final File fileEntry : dir.listFiles()) {\n-                var classFile = ClassFile.of().parse(fileEntry.toPath());\n-                classFile.methods().stream()\n-                        .filter(mm -> mm.methodName().equalsString(ConstantDescs.INIT_NAME))\n-                        .map(mm -> mm.findAttribute(Attributes.code()).orElseThrow())\n-                        .forEach(code -> {\n-                            List<String> mnemonics = new ArrayList<>();\n-                            for (var coe : code) {\n-                                if (coe instanceof Instruction inst) {\n-                                    mnemonics.add(inst.opcode().name().toLowerCase(Locale.ROOT));\n-                                }\n-                            }\n-                            var foundCodeSequence = String.join(\",\", mnemonics);\n-                            Assert.check(expectedCodeSequence.equals(foundCodeSequence), \"found \" + foundCodeSequence);\n-                        });\n-            }\n-        }\n+        checkMnemonicsFor(\n+                \"\"\"\n+                value class Test {\n+                    int i = 100;\n+                    int j = 0;\n+                    {\n+                        System.out.println(j);\n+                    }\n+                }\n+                \"\"\",\n+                \"aload_0,bipush,putfield,aload_0,iconst_0,putfield,aload_0,invokespecial,getstatic,iconst_0,invokevirtual,return\"\n+        );\n@@ -1057,1 +1031,1 @@\n-            var expectedCodeSequence = \"aload_0,new,dup,invokespecial,putfield,aload_0,invokespecial,return\";\n+            String expectedCodeSequence = \"aload_0,new,dup,invokespecial,putfield,aload_0,invokespecial,return\";\n@@ -1059,19 +1033,1 @@\n-                File dir = assertOK(true, src);\n-                for (final File fileEntry : dir.listFiles()) {\n-                    var classFile = ClassFile.of().parse(fileEntry.toPath());\n-                    if (classFile.thisClass().name().equalsString(\"Test\")) {\n-                        for (var method : classFile.methods()) {\n-                            if (method.methodName().equalsString(\"<init>\")) {\n-                                var code = method.findAttribute(Attributes.code()).orElseThrow();\n-                                List<String> mnemonics = new ArrayList<>();\n-                                for (var coe : code) {\n-                                    if (coe instanceof Instruction inst) {\n-                                        mnemonics.add(inst.opcode().name().toLowerCase(Locale.ROOT));\n-                                    }\n-                                }\n-                                var foundCodeSequence = String.join(\",\", mnemonics);\n-                                Assert.check(expectedCodeSequence.equals(foundCodeSequence), \"found \" + foundCodeSequence);\n-                            }\n-                        }\n-                    }\n-                }\n+                checkMnemonicsFor(src, \"aload_0,new,dup,invokespecial,putfield,aload_0,invokespecial,return\");\n@@ -1179,0 +1135,40 @@\n+\n+        \/\/ check that javac doesn't generate duplicate initializer code\n+        checkMnemonicsFor(\n+                \"\"\"\n+                value class Test {\n+                    static class Foo {\n+                        int x;\n+                        int getX() { return x; }\n+                    }\n+                    Foo data = new Foo();\n+                    Test() { \/\/ we will check that: `data = new Foo();` is generated only once\n+                        data.getX();\n+                        super();\n+                    }\n+                }\n+                \"\"\",\n+                \"new,dup,invokespecial,astore_1,aload_1,invokevirtual,pop,aload_0,aload_1,putfield,aload_0,invokespecial,return\"\n+        );\n+    }\n+\n+    void checkMnemonicsFor(String source, String expectedMnemonics) throws Exception {\n+        File dir = assertOK(true, source);\n+        for (final File fileEntry : dir.listFiles()) {\n+            var classFile = ClassFile.of().parse(fileEntry.toPath());\n+            if (classFile.thisClass().name().equalsString(\"Test\")) {\n+                for (var method : classFile.methods()) {\n+                    if (method.methodName().equalsString(\"<init>\")) {\n+                        var code = method.findAttribute(Attributes.code()).orElseThrow();\n+                        List<String> mnemonics = new ArrayList<>();\n+                        for (var coe : code) {\n+                            if (coe instanceof Instruction inst) {\n+                                mnemonics.add(inst.opcode().name().toLowerCase(Locale.ROOT));\n+                            }\n+                        }\n+                        var foundCodeSequence = String.join(\",\", mnemonics);\n+                        Assert.check(expectedMnemonics.equals(foundCodeSequence), \"found \" + foundCodeSequence);\n+                    }\n+                }\n+            }\n+        }\n@@ -1617,18 +1613,2 @@\n-                File dir = assertOK(true, source);\n-                File fileEntry = dir.listFiles()[0];\n-                String expectedCodeSequence = \"iconst_1,istore_1,aload_0,iload_1,putfield,aload_0,iload_1,putfield,\" +\n-                        \"aload_0,invokespecial,getstatic,aload_0,getfield,invokevirtual,return\";\n-                var classFile = ClassFile.of().parse(fileEntry.toPath());\n-                for (var method : classFile.methods()) {\n-                    if (method.methodName().equalsString(\"<init>\")) {\n-                        var code = method.findAttribute(Attributes.code()).orElseThrow();\n-                        List<String> mnemonics = new ArrayList<>();\n-                        for (var coe : code) {\n-                            if (coe instanceof Instruction inst) {\n-                                mnemonics.add(inst.opcode().name().toLowerCase(Locale.ROOT));\n-                            }\n-                        }\n-                        var foundCodeSequence = String.join(\",\", mnemonics);\n-                        Assert.check(expectedCodeSequence.equals(foundCodeSequence), \"found \" + foundCodeSequence);\n-                    }\n-                }\n+                checkMnemonicsFor(source, \"iconst_1,istore_1,aload_0,iload_1,putfield,aload_0,iload_1,putfield,\" +\n+                        \"aload_0,invokespecial,getstatic,aload_0,getfield,invokevirtual,return\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":60,"deletions":80,"binary":false,"changes":140,"status":"modified"}]}