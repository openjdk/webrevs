{"files":[{"patch":"@@ -20,0 +20,8 @@\n+\n+[checks \"problemlists\"]\n+dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n+\n+[checks \"copyright\"]\n+files=^(?!LICENSE|license\\.txt|.*\\.bin|.*\\.gif|.*\\.jpg|.*\\.png|.*\\.icon|.*\\.tiff|.*\\.dat|.*\\.patch|.*\\.wav|.*\\.class|.*-header|.*\\.jar).*\n+oracle_locator=.*Copyright \\(c\\)(.*)Oracle and\/or its affiliates\\. All rights reserved\\.\n+oracle_validator=.*Copyright \\(c\\) (\\d{4})(?:, (\\d{4}))?, Oracle and\/or its affiliates\\. All rights reserved\\.\n","filename":".jcheck\/conf","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,3 @@\n-# This must be the first rule\n-default: all\n+include MakeFileStart.gmk\n+\n+################################################################################\n@@ -29,3 +30,1 @@\n-include $(SPEC)\n-include MakeBase.gmk\n-include Modules.gmk\n+include Modules.gmk\n@@ -91,1 +90,9 @@\n--include Java.gmk\n+THIS_SNIPPET := modules\/$(MODULE)\/Java.gmk\n+\n+ifneq ($(wildcard $(THIS_SNIPPET)), )\n+  include MakeSnippetStart.gmk\n+\n+  include $(THIS_SNIPPET)\n+\n+  include MakeSnippetEnd.gmk\n+endif\n@@ -197,3 +204,1 @@\n-all: $(TARGETS)\n-\n-.PHONY: all\n+include MakeFileEnd.gmk\n","filename":"make\/CompileJavaModules.gmk","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,20 +25,1 @@\n-default: all\n-\n-include $(SPEC)\n-include MakeBase.gmk\n-\n-include CopyFiles.gmk\n-include Execute.gmk\n-include Modules.gmk\n-include ModuleTools.gmk\n-include ProcessMarkdown.gmk\n-include ToolsJdk.gmk\n-include ZipArchive.gmk\n-include TextFileProcessing.gmk\n-\n-# This is needed to properly setup DOCS_MODULES.\n-$(eval $(call ReadImportMetaData))\n-\n-################################################################################\n-# Hook to include the corresponding custom file, if present.\n-$(eval $(call IncludeCustomExtension, Docs.gmk))\n+include MakeFileStart.gmk\n@@ -57,1 +38,13 @@\n-#\n+################################################################################\n+\n+include CopyFiles.gmk\n+include Execute.gmk\n+include Modules.gmk\n+include ProcessMarkdown.gmk\n+include TextFileProcessing.gmk\n+include ZipArchive.gmk\n+include $(TOPDIR)\/make\/ModuleTools.gmk\n+include $(TOPDIR)\/make\/ToolsJdk.gmk\n+\n+# This is needed to properly setup DOCS_MODULES.\n+$(eval $(call ReadImportMetaData))\n@@ -766,4 +759,0 @@\n-################################################################################\n-# Hook to include the corresponding custom file, if present.\n-$(eval $(call IncludeCustomExtension, Docs-post.gmk))\n-\n@@ -811,1 +800,1 @@\n-.PHONY: default all docs-jdk-api-javadoc docs-jdk-api-graphs \\\n+.PHONY: docs-jdk-api-javadoc docs-jdk-api-graphs \\\n@@ -815,0 +804,4 @@\n+\n+################################################################################\n+\n+include MakeFileEnd.gmk\n","filename":"make\/Docs.gmk","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-default: all\n+include MakeFileStart.gmk\n@@ -28,2 +28,1 @@\n-include $(SPEC)\n-include MakeBase.gmk\n+################################################################################\n@@ -40,3 +39,0 @@\n-# Hook to include the corresponding custom file, if present.\n-$(eval $(call IncludeCustomExtension, Images-pre.gmk))\n-\n@@ -315,6 +311,0 @@\n-# Include custom post hook here to make it possible to augment the target lists\n-# before actual target prerequisites are declared.\n-$(eval $(call IncludeCustomExtension, Images-post.gmk))\n-\n-################################################################################\n-\n@@ -330,1 +320,5 @@\n-.PHONY: default all jdk jre symbols\n+.PHONY: jdk jre symbols\n+\n+################################################################################\n+\n+include MakeFileEnd.gmk\n","filename":"make\/Images.gmk","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-ifndef _MODULES_GMK\n-_MODULES_GMK := 1\n+include MakeIncludeStart.gmk\n+ifeq ($(INCLUDE), true)\n@@ -48,5 +48,0 @@\n-################################################################################\n-# Hook to include the corresponding custom file, if present.\n-# Allowing MODULE list extensions setup above.\n-$(eval $(call IncludeCustomExtension, common\/Modules.gmk))\n-\n@@ -335,1 +330,2 @@\n-endif # _MODULES_GMK\n+endif # include guard\n+include MakeIncludeEnd.gmk\n","filename":"make\/common\/Modules.gmk","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,4 @@\n-$(eval $(call IncludeCustomExtension, hotspot\/lib\/JvmFeatures.gmk))\n+################################################################################\n+\n+include MakeIncludeStart.gmk\n+ifeq ($(INCLUDE), true)\n@@ -31,0 +34,1 @@\n+################################################################################\n@@ -282,0 +286,5 @@\n+\n+################################################################################\n+\n+endif # include guard\n+include MakeIncludeEnd.gmk\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+################################################################################\n+\n@@ -28,0 +30,1 @@\n+include gensrc\/GensrcBuffer.gmk\n@@ -29,3 +32,1 @@\n-include gensrc\/GensrcMisc.gmk\n-include gensrc\/GensrcCharsetMapping.gmk\n-include gensrc\/GensrcBuffer.gmk\n+include gensrc\/GensrcCharsetMapping.gmk\n@@ -34,1 +35,1 @@\n-include gensrc\/GensrcVarHandles.gmk\n+include gensrc\/GensrcMisc.gmk\n@@ -36,1 +37,1 @@\n-include gensrc\/GensrcScopedMemoryAccess.gmk\n+include gensrc\/GensrcScopedMemoryAccess.gmk\n@@ -38,0 +39,1 @@\n+include gensrc\/GensrcVarHandles.gmk\n@@ -117,0 +119,2 @@\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,5 @@\n+include MakeIncludeStart.gmk\n+ifeq ($(INCLUDE), true)\n+\n+################################################################################\n+\n@@ -290,0 +295,5 @@\n+\n+################################################################################\n+\n+endif # include guard\n+include MakeIncludeEnd.gmk\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n-# This must be the first rule\n-default: all\n+include MakeFileStart.gmk\n@@ -29,2 +28,1 @@\n-include $(SPEC)\n-include MakeBase.gmk\n+################################################################################\n@@ -158,1 +156,3 @@\n-.PHONY: all\n+################################################################################\n+\n+include MakeFileEnd.gmk\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+include MakeFileStart.gmk\n+\n@@ -32,5 +34,0 @@\n-default: all\n-\n-include $(SPEC)\n-include MakeBase.gmk\n-\n@@ -44,2 +41,0 @@\n-TARGETS :=\n-\n@@ -94,1 +89,0 @@\n-#\n@@ -100,1 +94,5 @@\n-.PHONY: default all build-test-lib test-image-lib\n+.PHONY: build-test-lib test-image-lib\n+\n+################################################################################\n+\n+include MakeFileEnd.gmk\n","filename":"make\/test\/BuildTestLib.gmk","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+include MakeFileStart.gmk\n+\n@@ -32,5 +34,0 @@\n-default: all\n-\n-include $(SPEC)\n-include MakeBase.gmk\n-\n@@ -40,2 +37,0 @@\n-$(eval $(call IncludeCustomExtension, test\/JtregNativeHotspot.gmk))\n-\n@@ -871,0 +866,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit += -ldl\n@@ -884,1 +880,0 @@\n-BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libatExit := java.base:libjvm\n@@ -1593,1 +1588,5 @@\n-.PHONY: default all build-test-hotspot-jtreg-native test-image-hotspot-jtreg-native test-image\n+.PHONY: build-test-hotspot-jtreg-native test-image-hotspot-jtreg-native test-image\n+\n+################################################################################\n+\n+include MakeFileEnd.gmk\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1340,0 +1340,5 @@\n+\/\/ Intrinsic for Class::isInstance\n+address LIRGenerator::isInstance_entry() {\n+  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1023,0 +1023,49 @@\n+    case C1StubId::is_instance_of_id:\n+      {\n+        \/\/ Mirror: c_rarg0\n+        \/\/ Object: c_rarg1\n+        \/\/ Temps: r3, r4, r5, r6\n+        \/\/ Result: r0\n+\n+        \/\/ Get the Klass* into c_rarg6\n+        Register klass = c_rarg6, obj = c_rarg1, result = r0;\n+        __ ldr(klass, Address(c_rarg0, java_lang_Class::klass_offset()));\n+\n+        Label fail, is_secondary, success;\n+\n+        __ cbz(klass, fail); \/\/ Klass is null\n+        __ cbz(obj, fail); \/\/ obj is null\n+\n+        __ ldrw(r3, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n+        __ cmpw(r3, in_bytes(Klass::secondary_super_cache_offset()));\n+        __ br(Assembler::EQ, is_secondary); \/\/ Klass is a secondary superclass\n+\n+        \/\/ Klass is a concrete class\n+        __ load_klass(r5, obj);\n+        __ ldr(rscratch1, Address(r5, r3));\n+        __ cmp(klass, rscratch1);\n+        __ cset(result, Assembler::EQ);\n+        __ ret(lr);\n+\n+        __ bind(is_secondary);\n+\n+        __ load_klass(obj, obj);\n+\n+        \/\/ This is necessary because I am never in my own secondary_super list.\n+        __ cmp(obj, klass);\n+        __ br(Assembler::EQ, success);\n+\n+        __ lookup_secondary_supers_table_var(obj, klass,\n+                                             \/*temps*\/r3, r4, r5, v0,\n+                                             result,\n+                                             &success);\n+        __ bind(fail);\n+        __ mov(result, 0);\n+        __ ret(lr);\n+\n+        __ bind(success);\n+        __ mov(result, 1);\n+        __ ret(lr);\n+      }\n+      break;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1522,0 +1522,5 @@\n+\/\/ Intrinsic for Class::isInstance\n+address LIRGenerator::isInstance_entry() {\n+  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1432,0 +1432,54 @@\n+    case C1StubId::is_instance_of_id:\n+      {\n+        \/\/ Mirror: c_rarg0  (Windows: rcx, SysV: rdi)\n+        \/\/ Object: c_rarg1  (Windows: rdx, SysV: rsi)\n+        \/\/ ObjClass: r9\n+        \/\/ Temps:  rcx, r8, r10, r11\n+        \/\/ Result: rax\n+\n+        Register klass = r9, obj = c_rarg1, result = rax;\n+        Register temp0 = rcx, temp1 = r8, temp2 = r10, temp3 = r11;\n+\n+        \/\/ Get the Klass* into r9. c_rarg0 is now dead.\n+        __ movptr(klass, Address(c_rarg0, java_lang_Class::klass_offset()));\n+\n+        Label done, is_secondary, same;\n+\n+        __ xorq(result, result);\n+        __ testq(klass, klass);\n+        __ jcc(Assembler::equal, done); \/\/ Klass is null\n+\n+        __ testq(obj, obj);\n+        __ jcc(Assembler::equal, done); \/\/ obj is null\n+\n+        __ movl(temp0, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n+        __ cmpl(temp0, in_bytes(Klass::secondary_super_cache_offset()));\n+        __ jcc(Assembler::equal, is_secondary); \/\/ Klass is a secondary superclass\n+\n+        \/\/ Klass is a concrete class\n+        __ load_klass(temp2, obj, \/*tmp*\/temp1);\n+        __ cmpptr(klass, Address(temp2, temp0));\n+        __ setcc(Assembler::equal, result);\n+        __ ret(0);\n+\n+        __ bind(is_secondary);\n+\n+        __ load_klass(obj, obj, \/*tmp*\/temp1);\n+\n+        \/\/ This is necessary because I am never in my own secondary_super list.\n+        __ cmpptr(obj, klass);\n+        __ jcc(Assembler::equal, same);\n+\n+        __ lookup_secondary_supers_table_var(obj, klass,\n+                                             \/*temps*\/temp0, temp1, temp2, temp3,\n+                                             result);\n+        __ testq(result, result);\n+\n+        __ bind(same);\n+        __ setcc(Assembler::equal, result);\n+\n+        __ bind(done);\n+        __ ret(0);\n+      }\n+      break;\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -6707,0 +6707,12 @@\n+void C2_MacroAssembler::efp16sh(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2) {\n+  switch(opcode) {\n+    case Op_AddHF: vaddsh(dst, src1, src2); break;\n+    case Op_SubHF: vsubsh(dst, src1, src2); break;\n+    case Op_MulHF: vmulsh(dst, src1, src2); break;\n+    case Op_DivHF: vdivsh(dst, src1, src2); break;\n+    case Op_MaxHF: vmaxsh(dst, src1, src2); break;\n+    case Op_MinHF: vminsh(dst, src1, src2); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -509,0 +509,1 @@\n+  void efp16sh(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -788,0 +788,4 @@\n+#ifdef _WIN64\n+  \/\/ Windows always allocates space for its register args\n+  subq(rsp,  frame::arg_reg_save_area_bytes);\n+#endif\n@@ -791,0 +795,4 @@\n+#ifdef _WIN64\n+  \/\/ restore stack pointer\n+  addq(rsp, frame::arg_reg_save_area_bytes);\n+#endif\n@@ -2393,0 +2401,16 @@\n+void MacroAssembler::cmp32_mxcsr_std(Address mxcsr_save, Register tmp, Register rscratch) {\n+  ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n+  assert(rscratch != noreg || always_reachable(mxcsr_std), \"missing\");\n+\n+  stmxcsr(mxcsr_save);\n+  movl(tmp, mxcsr_save);\n+  if (EnableX86ECoreOpts) {\n+    \/\/ The mxcsr_std has status bits set for performance on ECore\n+    orl(tmp, 0x003f);\n+  } else {\n+    \/\/ Mask out status bits (only check control and mask bits)\n+    andl(tmp, 0xFFC0);\n+  }\n+  cmp32(tmp, mxcsr_std, rscratch);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1200,0 +1200,1 @@\n+  void cmp32_mxcsr_std(Address mxcsr_save, Register tmp, Register rscratch = noreg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -254,5 +254,1 @@\n-    __ stmxcsr(mxcsr_save);\n-    __ movl(rax, mxcsr_save);\n-    __ andl(rax, 0xFFC0); \/\/ Mask out any pending exceptions (only check control and mask bits)\n-    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n-    __ cmp32(rax, mxcsr_std, rscratch1);\n+    __ cmp32_mxcsr_std(mxcsr_save, rax, rscratch1);\n@@ -260,0 +256,1 @@\n+    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n@@ -598,4 +595,1 @@\n-    __ stmxcsr(mxcsr_save);\n-    __ movl(rax, mxcsr_save);\n-    __ andl(rax, 0xFFC0); \/\/ Mask out any pending exceptions (only check control and mask bits)\n-    __ cmp32(rax, mxcsr_std, rscratch1);\n+    __ cmp32_mxcsr_std(mxcsr_save, rax, rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1030,0 +1030,1 @@\n+    _features &= ~CPU_AVX512_FP16;\n@@ -1080,0 +1081,1 @@\n+      _features &= ~CPU_AVX512_FP16;\n@@ -3112,0 +3114,3 @@\n+\n+    if (_cpuid_info.sef_cpuid7_edx.bits.avx512_fp16 != 0)\n+      result |= CPU_AVX512_FP16;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1464,0 +1464,14 @@\n+    case Op_AddHF:\n+    case Op_DivHF:\n+    case Op_FmaHF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+    case Op_MulHF:\n+    case Op_ReinterpretS2HF:\n+    case Op_ReinterpretHF2S:\n+    case Op_SubHF:\n+    case Op_SqrtHF:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -4557,0 +4571,29 @@\n+#ifdef _LP64\n+instruct ReplHF_imm(vec dst, immH con, rRegI rtmp) %{\n+  match(Set dst (Replicate con));\n+  effect(TEMP rtmp);\n+  format %{ \"replicateHF $dst, $con \\t! using $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(VM_Version::supports_avx512_fp16() && bt == T_SHORT, \"\");\n+    __ movl($rtmp$$Register, $con$$constant);\n+    __ evpbroadcastw($dst$$XMMRegister, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct ReplHF_reg(vec dst, regF src, rRegI rtmp) %{\n+  predicate(VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n+  effect(TEMP rtmp);\n+  format %{ \"replicateHF $dst, $src \\t! using $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vmovw($rtmp$$Register, $src$$XMMRegister);\n+    __ evpbroadcastw($dst$$XMMRegister, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+#endif\n+\n@@ -10873,0 +10916,77 @@\n+\n+instruct reinterpretS2HF(regF dst, rRegI src)\n+%{\n+  match(Set dst (ReinterpretS2HF src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2HFAndS2HF(regF dst, regF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ vcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convHF2SAndHF2F(regF dst, regF src)\n+%{\n+  match(Set dst (ConvHF2F (ReinterpretHF2S src)));\n+  format %{ \"convHF2SAndHF2F $dst, $src\" %}\n+  ins_encode %{\n+    __ vcvtph2ps($dst$$XMMRegister, $src$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretHF2S(rRegI dst, regF src)\n+%{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scalar_sqrt_HF_reg(regF dst, regF src)\n+%{\n+  match(Set dst (SqrtHF src));\n+  format %{ \"scalar_sqrt_fp16 $dst, $src\" %}\n+  ins_encode %{\n+    __ vsqrtsh($dst$$XMMRegister, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scalar_binOps_HF_reg(regF dst, regF src1, regF src2)\n+%{\n+  match(Set dst (AddHF src1 src2));\n+  match(Set dst (DivHF src1 src2));\n+  match(Set dst (MaxHF src1 src2));\n+  match(Set dst (MinHF src1 src2));\n+  match(Set dst (MulHF src1 src2));\n+  match(Set dst (SubHF src1 src2));\n+  format %{ \"scalar_binop_fp16 $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    __ efp16sh(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scalar_fma_HF_reg(regF dst, regF src1, regF src2)\n+%{\n+  match(Set dst (FmaHF  src2 (Binary dst src1)));\n+  effect(DEF dst);\n+  format %{ \"scalar_fma_fp16 $dst, $src1, $src2\\t# $dst = $dst * $src1 + $src2 fma packedH\" %}\n+  ins_encode %{\n+    __ vfmadd132sh($dst$$XMMRegister, $src2$$XMMRegister, $src1$$XMMRegister);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":121,"deletions":1,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2394,0 +2394,10 @@\n+\/\/ Half Float Immediate\n+operand immH()\n+%{\n+  match(ConH);\n+\n+  op_cost(15);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4868,0 +4878,10 @@\n+instruct loadConH(regF dst, immH con) %{\n+  match(Set dst con);\n+  ins_cost(125);\n+  format %{ \"movss   $dst, [$constantaddress]\\t# load from constant table: halffloat=$con\" %}\n+  ins_encode %{\n+    __ movflt($dst$$XMMRegister, $constantaddress($con));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -7076,0 +7096,11 @@\n+instruct castHH(regF dst)\n+%{\n+  match(Set dst (CastHH dst));\n+\n+  size(0);\n+  format %{ \"# castHH of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,0 +223,1 @@\n+  if (strcmp(name,\"ConH\")==0) return Form::idealH;\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1093,1 +1093,1 @@\n-      if ( (type == Form::idealF) || (type == Form::idealD) ) {\n+      if ( (type == Form::idealH) || (type == Form::idealF) || (type == Form::idealD) ) {\n@@ -1104,1 +1104,1 @@\n-  if( data_type==idealD || data_type==idealF ) {\n+  if( data_type==idealH || data_type==idealD || data_type==idealF ) {\n@@ -2667,0 +2667,1 @@\n+  case Form::idealH: fprintf(fp,\"  st->print(\\\"#%%d\\\", _c%d);\\n\", const_index); break;\n@@ -2748,0 +2749,1 @@\n+  case idealH: fprintf(fp,\"_c%d\",           const_index); break;\n@@ -3958,1 +3960,1 @@\n-    \"AddI\",\"AddL\",\"AddF\",\"AddD\",\n+    \"AddI\",\"AddL\",\"AddHF\",\"AddF\",\"AddD\",\n@@ -3960,3 +3962,4 @@\n-    \"MaxI\",\"MinI\",\"MaxF\",\"MinF\",\"MaxD\",\"MinD\",\n-    \"MulI\",\"MulL\",\"MulF\",\"MulD\",\n-    \"OrI\",\"OrL\", \"XorI\",\"XorL\",\n+    \"MaxI\",\"MinI\",\"MaxHF\",\"MinHF\",\"MaxF\",\"MinF\",\"MaxD\",\"MinD\",\n+    \"MulI\",\"MulL\",\"MulHF\",\"MulF\",\"MulD\",\n+    \"OrI\",\"OrL\",\n+    \"XorI\",\"XorL\"\n@@ -4198,0 +4201,1 @@\n+        strcmp(opType,\"DivHF\")==0 ||\n@@ -4205,0 +4209,1 @@\n+        strcmp(opType,\"SqrtHF\")==0 ||\n@@ -4224,0 +4229,1 @@\n+        strcmp(opType,\"FmaHF\") == 0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -526,1 +526,1 @@\n-        \/\/ an InstantOf instruction\n+        \/\/ an InstanceOf instruction\n@@ -550,16 +550,0 @@\n-  case vmIntrinsics::_getModifiers: {\n-    assert(x->number_of_arguments() == 1, \"wrong type\");\n-\n-    \/\/ Optimize for Foo.class.getModifier()\n-    InstanceConstant* c = x->argument_at(0)->type()->as_InstanceConstant();\n-    if (c != nullptr && !c->value()->is_null_object()) {\n-      ciType* t = c->value()->java_mirror_type();\n-      if (t->is_klass()) {\n-        set_constant(t->as_klass()->modifier_flags());\n-      } else {\n-        assert(t->is_primitive_type(), \"should be a primitive type\");\n-        set_constant(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n-      }\n-    }\n-    break;\n-  }\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1254,7 +1254,0 @@\n-  \/\/ TODO could try to substitute this node with an equivalent InstanceOf\n-  \/\/ if clazz is known to be a constant Class. This will pick up newly found\n-  \/\/ constants after HIR construction. I'll leave this to a future change.\n-\n-  \/\/ as a first cut, make a simple leaf call to runtime to stay platform independent.\n-  \/\/ could follow the aastore example in a future change.\n-\n@@ -1273,0 +1266,1 @@\n+  address pd_instanceof_fn = isInstance_entry();\n@@ -1274,1 +1268,1 @@\n-                                     CAST_FROM_FN_PTR(address, Runtime1::is_instance_of),\n+                                     pd_instanceof_fn,\n@@ -1326,50 +1320,0 @@\n-\/\/ Example: Foo.class.getModifiers()\n-void LIRGenerator::do_getModifiers(Intrinsic* x) {\n-  assert(x->number_of_arguments() == 1, \"wrong type\");\n-\n-  LIRItem receiver(x->argument_at(0), this);\n-  receiver.load_item();\n-  LIR_Opr result = rlock_result(x);\n-\n-  CodeEmitInfo* info = nullptr;\n-  if (x->needs_null_check()) {\n-    info = state_for(x);\n-  }\n-\n-  \/\/ While reading off the universal constant mirror is less efficient than doing\n-  \/\/ another branch and returning the constant answer, this branchless code runs into\n-  \/\/ much less risk of confusion for C1 register allocator. The choice of the universe\n-  \/\/ object here is correct as long as it returns the same modifiers we would expect\n-  \/\/ from the primitive class itself. See spec for Class.getModifiers that provides\n-  \/\/ the typed array klasses with similar modifiers as their component types.\n-\n-  \/\/ Valhalla update: the code is now a bit convuloted because arrays and primitive\n-  \/\/ classes don't have the same modifiers set anymore, but we cannot introduce\n-  \/\/ branches in LIR generation (JDK-8211231). So, the first part of the code remains\n-  \/\/ identical, using the byteArrayKlass object to avoid a NPE when accessing the\n-  \/\/ modifiers. But then the code also prepares the correct modifiers set for\n-  \/\/ primitive classes, and there's a second conditional move to put the right\n-  \/\/ value into result.\n-\n-\n-  Klass* univ_klass = Universe::byteArrayKlass();\n-  assert(univ_klass->modifier_flags() == (JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC\n-                                          | (Arguments::enable_preview() ? JVM_ACC_IDENTITY : 0)), \"Sanity\");\n-  LIR_Opr prim_klass = LIR_OprFact::metadataConst(univ_klass);\n-\n-  LIR_Opr recv_klass = new_register(T_METADATA);\n-  __ move(new LIR_Address(receiver.result(), java_lang_Class::klass_offset(), T_ADDRESS), recv_klass, info);\n-\n-  \/\/ Check if this is a Java mirror of primitive type, and select the appropriate klass.\n-  LIR_Opr klass = new_register(T_METADATA);\n-  __ cmp(lir_cond_equal, recv_klass, LIR_OprFact::metadataConst(nullptr));\n-  __ cmove(lir_cond_equal, prim_klass, recv_klass, klass, T_ADDRESS);\n-  LIR_Opr klass_modifiers = new_register(T_INT);\n-  __ move(new LIR_Address(klass, in_bytes(Klass::modifier_flags_offset()), T_CHAR), klass_modifiers);\n-\n-  LIR_Opr prim_modifiers = load_immediate(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC, T_INT);\n-\n-  __ cmp(lir_cond_equal, recv_klass, LIR_OprFact::metadataConst(0));\n-  __ cmove(lir_cond_equal, prim_modifiers, klass_modifiers, result, T_CHAR);\n-}\n-\n@@ -3535,1 +3479,0 @@\n-  case vmIntrinsics::_getModifiers:   do_getModifiers(x);  break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":59,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,1 +261,0 @@\n-  void do_getModifiers(Intrinsic* x);\n@@ -561,0 +560,3 @@\n+  \/\/ Intrinsic for Class::isInstance\n+  address isInstance_entry();\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+  case C1StubId::is_instance_of_id:\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,3 +54,0 @@\n-  oop     protection_domain()        { return _base_element_klass->protection_domain(); }\n-  jobject protection_domain_handle() { return _base_element_klass->protection_domain_handle(); }\n-\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-  ciInlineKlass(ciSymbol* name, jobject loader, jobject protection_domain) :\n-    ciInstanceKlass(name, loader, protection_domain, T_OBJECT) {}\n+  ciInlineKlass(ciSymbol* name, jobject loader) :\n+    ciInstanceKlass(name, loader, T_OBJECT) {}\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,2 +95,0 @@\n-    _protection_domain = JNIHandles::make_local(thread,\n-                                                ik->protection_domain());\n@@ -100,2 +98,0 @@\n-    Handle h_protection_domain(thread, ik->protection_domain());\n-    _protection_domain = JNIHandles::make_global(h_protection_domain);\n@@ -124,1 +120,1 @@\n-                                 jobject loader, jobject protection_domain,\n+                                 jobject loader,\n@@ -136,1 +132,0 @@\n-  _protection_domain = protection_domain;\n@@ -178,13 +173,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciInstanceKlass::protection_domain\n-oop ciInstanceKlass::protection_domain() {\n-  ASSERT_IN_VM;\n-  return JNIHandles::resolve(_protection_domain);\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciInstanceKlass::protection_domain_handle\n-jobject ciInstanceKlass::protection_domain_handle() {\n-  return _protection_domain;\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-  jobject                _protection_domain;\n@@ -89,1 +88,1 @@\n-  ciInstanceKlass(ciSymbol* name, jobject loader, jobject protection_domain, BasicType bt = T_OBJECT); \/\/ for unloaded klasses\n+  ciInstanceKlass(ciSymbol* name, jobject loader, BasicType bt = T_OBJECT); \/\/ for unloaded klasses\n@@ -98,3 +97,0 @@\n-  oop protection_domain();\n-  jobject protection_domain_handle();\n-\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,3 +70,0 @@\n-  virtual oop protection_domain()             { return nullptr; }\n-  virtual jobject protection_domain_handle()  { return nullptr; }\n-\n@@ -135,1 +132,1 @@\n-  \/\/ Fetch Klass::modifier_flags.\n+  \/\/ Fetch modifier flags.\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,4 +61,0 @@\n-  oop     protection_domain()        { return _base_element_klass->protection_domain(); }\n-  jobject protection_domain_handle() { return _base_element_klass->protection_domain_handle(); }\n-\n-\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-  ciEnv::_unloaded_ciinstance_klass = new (_arena) ciInstanceKlass(ciEnv::_unloaded_cisymbol, nullptr, nullptr);\n+  ciEnv::_unloaded_ciinstance_klass = new (_arena) ciInstanceKlass(ciEnv::_unloaded_cisymbol, nullptr);\n@@ -480,1 +480,0 @@\n-    domain = accessing_klass->protection_domain();\n@@ -485,2 +484,1 @@\n-        entry->loader() == loader &&\n-        entry->protection_domain() == domain) {\n+        entry->loader() == loader) {\n@@ -525,1 +523,0 @@\n-    jobject domain_handle = nullptr;\n@@ -528,2 +525,1 @@\n-      domain_handle = accessing_klass->protection_domain_handle();\n-    new_klass = new (arena()) ciInstanceKlass(name, loader_handle, domain_handle);\n+    new_klass = new (arena()) ciInstanceKlass(name, loader_handle);\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3917,5 +3917,0 @@\n-  \/\/ Initialize cached modifier_flags to support Class.getModifiers().\n-  \/\/ This must follow setting inner_class attributes.\n-  u2 computed_modifiers = this_klass->compute_modifier_flags();\n-  this_klass->set_modifier_flags(computed_modifiers);\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -872,0 +872,1 @@\n+int java_lang_Class::_modifiers_offset;\n@@ -1065,0 +1066,4 @@\n+  \/\/ Set the modifiers flag.\n+  int computed_modifiers = k->compute_modifier_flags();\n+  set_modifiers(mirror(), computed_modifiers);\n+\n@@ -1370,0 +1375,1 @@\n+  set_modifiers(java_class, JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n@@ -1514,1 +1520,3 @@\n-  macro(_signers_offset,             k, \"signers\",             object_array_signature, false);\n+  macro(_signers_offset,             k, \"signers\",             object_array_signature, false); \\\n+  macro(_modifiers_offset,           k, vmSymbols::modifiers_name(), int_signature,    false); \\\n+  macro(_protection_domain_offset,   k, \"protectionDomain\",    java_security_ProtectionDomain_signature,  false);\n@@ -1548,0 +1556,10 @@\n+int java_lang_Class::modifiers(oop the_class_mirror) {\n+  assert(_modifiers_offset != 0, \"offsets should have been initialized\");\n+  return the_class_mirror->int_field(_modifiers_offset);\n+}\n+\n+void java_lang_Class::set_modifiers(oop the_class_mirror, int value) {\n+  assert(_modifiers_offset != 0, \"offsets should have been initialized\");\n+  the_class_mirror->int_field_put(_modifiers_offset, value);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-  macro(java_lang_Class, protection_domain,      object_signature,  false) \\\n@@ -261,0 +260,1 @@\n+  static int _modifiers_offset;\n@@ -343,0 +343,3 @@\n+  static int modifiers(oop java_class);\n+  static void set_modifiers(oop java_class, int value);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -259,1 +259,0 @@\n-  case vmIntrinsics::_getModifiers:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -307,2 +307,0 @@\n-  do_intrinsic(_getModifiers,             java_lang_Class,        getModifiers_name, void_int_signature,         F_RN)  \\\n-   do_name(     getModifiers_name,                               \"getModifiers\")                                        \\\n@@ -944,1 +942,1 @@\n-   do_alias(    getAndSetInt_signature,                                 \/*\"(Ljava\/lang\/Object;JI)I\"*\/ getAndAddInt_signature)   \\\n+   do_alias(    getAndSetInt_signature,                                 \/*\"(Ljava\/lang\/Object;JI)I\"*\/ getAndAddInt_signature) \\\n@@ -947,1 +945,1 @@\n-   do_alias(    getAndSetLong_signature,                                \/*\"(Ljava\/lang\/Object;JJ)J\"*\/ getAndAddLong_signature)  \\\n+   do_alias(    getAndSetLong_signature,                                \/*\"(Ljava\/lang\/Object;JJ)J\"*\/ getAndAddLong_signature)\\\n@@ -950,1 +948,1 @@\n-   do_alias(    getAndSetByte_signature,                                \/*\"(Ljava\/lang\/Object;JB)B\"*\/ getAndAddByte_signature)  \\\n+   do_alias(    getAndSetByte_signature,                                \/*\"(Ljava\/lang\/Object;JB)B\"*\/ getAndAddByte_signature)\\\n@@ -952,4 +950,4 @@\n-   do_name(     getAndSetShort_name,                                    \"getAndSetShort\")                                     \\\n-   do_alias(    getAndSetShort_signature,                               \/*\"(Ljava\/lang\/Object;JS)S\"*\/ getAndAddShort_signature) \\\n-  do_intrinsic(_getAndSetReference,       jdk_internal_misc_Unsafe,     getAndSetReference_name, getAndSetReference_signature, F_R) \\\n-   do_name(     getAndSetReference_name,                                \"getAndSetReference\")                                  \\\n+   do_name(     getAndSetShort_name,                                    \"getAndSetShort\")                                             \\\n+   do_alias(    getAndSetShort_signature,                               \/*\"(Ljava\/lang\/Object;JS)S\"*\/ getAndAddShort_signature)       \\\n+  do_intrinsic(_getAndSetReference,       jdk_internal_misc_Unsafe,     getAndSetReference_name, getAndSetReference_signature, F_R)   \\\n+   do_name(     getAndSetReference_name,                                \"getAndSetReference\")                                         \\\n@@ -957,0 +955,15 @@\n+                                                                                                                             \\\n+  \/* Float16Math API intrinsification support *\/                                                                             \\\n+  \/* Float16 signatures *\/                                                                                                   \\\n+  do_signature(float16_unary_math_op_sig, \"(Ljava\/lang\/Class;\"                                                               \\\n+                                           \"Ljava\/lang\/Object;\"                                                              \\\n+                                           \"Ljava\/util\/function\/UnaryOperator;)\"                                             \\\n+                                           \"Ljava\/lang\/Object;\")                                                             \\\n+  do_signature(float16_ternary_math_op_sig, \"(Ljava\/lang\/Class;\"                                                             \\\n+                                             \"Ljava\/lang\/Object;\"                                                            \\\n+                                             \"Ljava\/lang\/Object;\"                                                            \\\n+                                             \"Ljava\/lang\/Object;\"                                                            \\\n+                                             \"Ljdk\/internal\/vm\/vector\/Float16Math$TernaryOperator;)\"                         \\\n+                                             \"Ljava\/lang\/Object;\")                                                           \\\n+  do_intrinsic(_sqrt_float16, jdk_internal_vm_vector_Float16Math, sqrt_name, float16_unary_math_op_sig, F_S)                 \\\n+  do_intrinsic(_fma_float16, jdk_internal_vm_vector_Float16Math, fma_name, float16_ternary_math_op_sig, F_S)                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-  template(jdk_internal_vm_vector_VectorSupport,      \"jdk\/internal\/vm\/vector\/VectorSupport\")               \\\n+  template(jdk_internal_vm_vector_VectorSupport,      \"jdk\/internal\/vm\/vector\/VectorSupport\")     \\\n+  template(jdk_internal_vm_vector_Float16Math,        \"jdk\/internal\/vm\/vector\/Float16Math\")       \\\n@@ -313,0 +314,1 @@\n+  template(java_security_ProtectionDomain_signature,      \"Ljava\/security\/ProtectionDomain;\")     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    _max_num_optional_regions(collection_set->optional_region_length()),\n+    _max_num_optional_regions(collection_set->num_optional_regions()),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,1 +275,0 @@\n-  nonstatic_field(Klass,                       _modifier_flags,                               u2)                                    \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -331,0 +331,6 @@\n+int Klass::modifier_flags() const {\n+  int mods = java_lang_Class::modifiers(java_mirror());\n+  assert(mods == compute_modifier_flags(), \"should be same\");\n+  return mods;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -128,3 +128,0 @@\n-  \/\/ Processed access flags, for use by Class.getModifiers.\n-  u2          _modifier_flags;\n-\n@@ -297,4 +294,0 @@\n-  \/\/ modifier flags\n-  u2 modifier_flags() const          { return _modifier_flags; }\n-  void set_modifier_flags(u2 flags)  { _modifier_flags = flags; }\n-\n@@ -453,1 +446,0 @@\n-  static ByteSize modifier_flags_offset()        { return byte_offset_of(Klass, _modifier_flags); }\n@@ -787,0 +779,1 @@\n+  int modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -146,3 +146,0 @@\n-\n-  \/\/ Compute modifier flags after bottom_klass and element_klass are initialized.\n-  set_modifier_flags(compute_modifier_flags());\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,3 +93,0 @@\n-\n-  \/\/ Compute modifier flags.\n-  set_modifier_flags(compute_modifier_flags());\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -558,0 +559,16 @@\n+\/\/=============================================================================\n+\/\/------------------------------add_of_identity--------------------------------\n+\/\/ Check for addition of the identity\n+const Type* AddHFNode::add_of_identity(const Type* t1, const Type* t2) const {\n+  return nullptr;\n+}\n+\n+\/\/ Supplied function returns the sum of the inputs.\n+\/\/ This also type-checks the inputs for sanity.  Guaranteed never to\n+\/\/ be passed a TOP or BOTTOM type, these are filtered out by pre-check.\n+const Type* AddHFNode::add_ring(const Type* t0, const Type* t1) const {\n+  if (!t0->isa_half_float_constant() || !t1->isa_half_float_constant()) {\n+    return bottom_type();\n+  }\n+  return TypeH::make(t0->getf() + t1->getf());\n+}\n@@ -1519,0 +1536,27 @@\n+\/\/------------------------------add_ring---------------------------------------\n+const Type* MinHFNode::add_ring(const Type* t0, const Type* t1) const {\n+  const TypeH* r0 = t0->isa_half_float_constant();\n+  const TypeH* r1 = t1->isa_half_float_constant();\n+  if (r0 == nullptr || r1 == nullptr) {\n+    return bottom_type();\n+  }\n+\n+  if (r0->is_nan()) {\n+    return r0;\n+  }\n+  if (r1->is_nan()) {\n+    return r1;\n+  }\n+\n+  float f0 = r0->getf();\n+  float f1 = r1->getf();\n+  if (f0 != 0.0f || f1 != 0.0f) {\n+    return f0 < f1 ? r0 : r1;\n+  }\n+\n+  \/\/ As per IEEE 754 specification, floating point comparison consider +ve and -ve\n+  \/\/ zeros as equals. Thus, performing signed integral comparison for min value\n+  \/\/ detection.\n+  return (jint_cast(f0) < jint_cast(f1)) ? r0 : r1;\n+}\n+\n@@ -1569,0 +1613,28 @@\n+\/\/------------------------------add_ring---------------------------------------\n+const Type* MaxHFNode::add_ring(const Type* t0, const Type* t1) const {\n+  const TypeH* r0 = t0->isa_half_float_constant();\n+  const TypeH* r1 = t1->isa_half_float_constant();\n+  if (r0 == nullptr || r1 == nullptr) {\n+    return bottom_type();\n+  }\n+\n+  if (r0->is_nan()) {\n+    return r0;\n+  }\n+  if (r1->is_nan()) {\n+    return r1;\n+  }\n+\n+  float f0 = r0->getf();\n+  float f1 = r1->getf();\n+  if (f0 != 0.0f || f1 != 0.0f) {\n+    return f0 > f1 ? r0 : r1;\n+  }\n+\n+  \/\/ As per IEEE 754 specification, floating point comparison consider +ve and -ve\n+  \/\/ zeros as equals. Thus, performing signed integral comparison for max value\n+  \/\/ detection.\n+  return (jint_cast(f0) > jint_cast(f1)) ? r0 : r1;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -356,0 +356,6 @@\n+  case vmIntrinsics::_sqrt_float16:\n+    if (!Matcher::match_rule_supported(Op_SqrtHF)) return false;\n+    break;\n+  case vmIntrinsics::_fma_float16:\n+    if (!Matcher::match_rule_supported(Op_FmaHF)) return false;\n+    break;\n@@ -759,1 +765,0 @@\n-  case vmIntrinsics::_getModifiers:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -534,0 +534,2 @@\n+  } else if (type->isa_half_float()) {\n+    return new CastHHNode(c, in, type, dependency, types);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,0 +146,11 @@\n+class CastHHNode: public ConstraintCastNode {\n+public:\n+  CastHHNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(ctrl, n, t, dependency, types) {\n+    assert(ctrl != nullptr, \"control must be set\");\n+    init_class_id(Class_CastHH);\n+  }\n+  virtual int Opcode() const;\n+  virtual uint ideal_reg() const { return in(1)->ideal_reg(); }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+macro(AddHF)\n@@ -67,0 +68,1 @@\n+macro(CastHH)\n@@ -136,0 +138,1 @@\n+macro(ConH)\n@@ -170,0 +173,1 @@\n+macro(DivHF)\n@@ -189,0 +193,1 @@\n+macro(FmaHF)\n@@ -227,0 +232,1 @@\n+macro(MaxHF)\n@@ -242,0 +248,1 @@\n+macro(MinHF)\n@@ -258,0 +265,1 @@\n+macro(MulHF)\n@@ -343,0 +351,1 @@\n+macro(SqrtHF)\n@@ -363,0 +372,1 @@\n+macro(SubHF)\n@@ -492,0 +502,2 @@\n+macro(ReinterpretS2HF)\n+macro(ReinterpretHF2S)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1759,2 +1759,0 @@\n-      if (flat->offset() == in_bytes(Klass::modifier_flags_offset()))\n-        alias_type(idx)->set_rewritable(false);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/divnode.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"opto\/mulnode.hpp\"\n@@ -259,0 +261,31 @@\n+\/\/------------------------------Ideal------------------------------------------\n+Node* ConvF2HFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Float16 instance encapsulates a short field holding IEEE 754\n+  \/\/ binary16 value. On unboxing, this short field is loaded into a\n+  \/\/ GPR register while FP operation operates over floating point\n+  \/\/ registers. ConvHF2F converts incoming short value to a FP32 value\n+  \/\/ to perform operation at FP32 granularity. However, if target\n+  \/\/ support FP16 ISA we can save this redundant up casting and\n+  \/\/ optimize the graph pallet using following transformation.\n+  \/\/\n+  \/\/ ConvF2HF(FP32BinOp(ConvHF2F(x), ConvHF2F(y))) =>\n+  \/\/        ReinterpretHF2S(FP16BinOp(ReinterpretS2HF(x), ReinterpretS2HF(y)))\n+  \/\/\n+  \/\/ Please note we need to inject appropriate reinterpretation\n+  \/\/ IR to move the values b\/w GPR and floating point register\n+  \/\/ before and after FP16 operation.\n+\n+  if (Float16NodeFactory::is_float32_binary_oper(in(1)->Opcode()) &&\n+      in(1)->in(1)->Opcode() == Op_ConvHF2F &&\n+      in(1)->in(2)->Opcode() == Op_ConvHF2F) {\n+    if (Matcher::match_rule_supported(Float16NodeFactory::get_float16_binary_oper(in(1)->Opcode())) &&\n+        Matcher::match_rule_supported(Op_ReinterpretS2HF) &&\n+        Matcher::match_rule_supported(Op_ReinterpretHF2S)) {\n+      Node* in1 = phase->transform(new ReinterpretS2HFNode(in(1)->in(1)->in(1)));\n+      Node* in2 = phase->transform(new ReinterpretS2HFNode(in(1)->in(2)->in(1)));\n+      Node* binop = phase->transform(Float16NodeFactory::make(in(1)->Opcode(), in(1)->in(0), in1, in2));\n+      return new ReinterpretHF2SNode(binop);\n+    }\n+  }\n+  return nullptr;\n+}\n@@ -907,0 +940,72 @@\n+\n+const Type* ReinterpretS2HFNode::Value(PhaseGVN* phase) const {\n+  const Type* type = phase->type(in(1));\n+  \/\/ Convert short constant value to a Half Float constant value\n+  if ((type->isa_int() && type->is_int()->is_con())) {\n+     jshort hfval = type->is_int()->get_con();\n+     return TypeH::make(hfval);\n+  }\n+  return Type::HALF_FLOAT;\n+}\n+\n+Node* ReinterpretS2HFNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReinterpretHF2S) {\n+     assert(in(1)->in(1)->bottom_type()->isa_half_float(), \"\");\n+     return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+const Type* ReinterpretHF2SNode::Value(PhaseGVN* phase) const {\n+  const Type* type = phase->type(in(1));\n+  \/\/ Convert Half float constant value to short constant value.\n+  if (type->isa_half_float_constant()) {\n+     jshort hfval = type->is_half_float_constant()->_f;\n+     return TypeInt::make(hfval);\n+  }\n+  return TypeInt::SHORT;\n+}\n+\n+bool Float16NodeFactory::is_float32_binary_oper(int opc) {\n+  switch(opc) {\n+    case Op_AddF:\n+    case Op_SubF:\n+    case Op_MulF:\n+    case Op_DivF:\n+    case Op_MaxF:\n+    case Op_MinF:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+int Float16NodeFactory::get_float16_binary_oper(int opc) {\n+  switch(opc) {\n+    case Op_AddF:\n+      return Op_AddHF;\n+    case Op_SubF:\n+      return Op_SubHF;\n+    case Op_MulF:\n+      return Op_MulHF;\n+    case Op_DivF:\n+      return Op_DivHF;\n+    case Op_MaxF:\n+      return Op_MaxHF;\n+    case Op_MinF:\n+      return Op_MinHF;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+Node* Float16NodeFactory::make(int opc, Node* c, Node* in1, Node* in2) {\n+  switch(opc) {\n+    case Op_AddF: return new AddHFNode(in1, in2);\n+    case Op_SubF: return new SubHFNode(in1, in2);\n+    case Op_MulF: return new MulHFNode(in1, in2);\n+    case Op_DivF: return new DivHFNode(c, in1, in2);\n+    case Op_MaxF: return new MaxHFNode(in1, in2);\n+    case Op_MinF: return new MinHFNode(in1, in2);\n+    default: ShouldNotReachHere();\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -808,0 +808,109 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+\/\/ An DivHFNode divides its inputs.  The third input is a Control input, used to\n+\/\/ prevent hoisting the divide above an unsafe test.\n+const Type* DivHFNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if(t1 == Type::TOP) { return Type::TOP; }\n+  if(t2 == Type::TOP) { return Type::TOP; }\n+\n+  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n+  const Type* bot = bottom_type();\n+  if((t1 == bot) || (t2 == bot) ||\n+     (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM)) {\n+    return bot;\n+  }\n+\n+  \/\/ x\/x == 1, we ignore 0\/0.\n+  \/\/ Note: if t1 and t2 are zero then result is NaN (JVMS page 213)\n+  \/\/ Does not work for variables because of NaN's\n+  if (in(1) == in(2) && t1->base() == Type::HalfFloatCon &&\n+      !g_isnan(t1->getf()) && g_isfinite(t1->getf()) && t1->getf() != 0.0) { \/\/ could be negative ZERO or NaN\n+    return TypeH::ONE;\n+  }\n+\n+  if (t2 == TypeH::ONE) {\n+    return t1;\n+  }\n+\n+  \/\/ If divisor is a constant and not zero, divide the numbers\n+  if (t1->base() == Type::HalfFloatCon &&\n+      t2->base() == Type::HalfFloatCon &&\n+      t2->getf() != 0.0)  {\n+    \/\/ could be negative zero\n+    return TypeH::make(t1->getf() \/ t2->getf());\n+  }\n+\n+  \/\/ If the dividend is a constant zero\n+  \/\/ Note: if t1 and t2 are zero then result is NaN (JVMS page 213)\n+  \/\/ Test TypeHF::ZERO is not sufficient as it could be negative zero\n+\n+  if (t1 == TypeH::ZERO && !g_isnan(t2->getf()) && t2->getf() != 0.0) {\n+    return TypeH::ZERO;\n+  }\n+\n+  \/\/ If divisor or dividend is nan then result is nan.\n+  if (g_isnan(t1->getf()) || g_isnan(t2->getf())) {\n+    return TypeH::make(NAN);\n+  }\n+\n+  \/\/ Otherwise we give up all hope\n+  return Type::HALF_FLOAT;\n+}\n+\n+\/\/-----------------------------------------------------------------------------\n+\/\/ Dividing by self is 1.\n+\/\/ IF the divisor is 1, we are an identity on the dividend.\n+Node* DivHFNode::Identity(PhaseGVN* phase) {\n+  return (phase->type( in(2) ) == TypeH::ONE) ? in(1) : this;\n+}\n+\n+\n+\/\/------------------------------Idealize---------------------------------------\n+Node* DivHFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape))  return this;\n+  \/\/ Don't bother trying to transform a dead node\n+  if (in(0) != nullptr && in(0)->is_top())  { return nullptr; }\n+\n+  const Type* t2 = phase->type(in(2));\n+  if (t2 == TypeH::ONE) {      \/\/ Identity?\n+    return nullptr;            \/\/ Skip it\n+  }\n+  const TypeH* tf = t2->isa_half_float_constant();\n+  if(tf == nullptr) { return nullptr; }\n+  if(tf->base() != Type::HalfFloatCon) { return nullptr; }\n+\n+  \/\/ Check for out of range values\n+  if(tf->is_nan() || !tf->is_finite()) { return nullptr; }\n+\n+  \/\/ Get the value\n+  float f = tf->getf();\n+  int exp;\n+\n+  \/\/ Consider the following geometric progression series of POT(power of two) numbers.\n+  \/\/ 0.5 x 2^0 = 0.5, 0.5 x 2^1 = 1.0, 0.5 x 2^2 = 2.0, 0.5 x 2^3 = 4.0 ... 0.5 x 2^n,\n+  \/\/ In all the above cases, normalized mantissa returned by frexp routine will\n+  \/\/ be exactly equal to 0.5 while exponent will be 0,1,2,3...n\n+  \/\/ Perform division to multiplication transform only if divisor is a POT value.\n+  if(frexp((double)f, &exp) != 0.5) { return nullptr; }\n+\n+  \/\/ Limit the range of acceptable exponents\n+  if(exp < -14 || exp > 15) { return nullptr; }\n+\n+  \/\/ Since divisor is a POT number, hence its reciprocal will never\n+  \/\/ overflow 11 bits precision range of Float16\n+  \/\/ value if exponent returned by frexp routine strictly lie\n+  \/\/ within the exponent range of normal min(0x1.0P-14) and\n+  \/\/ normal max(0x1.ffcP+15) values.\n+  \/\/ Thus we can safely compute the reciprocal of divisor without\n+  \/\/ any concerns about the precision loss and transform the division\n+  \/\/ into a multiplication operation.\n+  float reciprocal = ((float)1.0) \/ f;\n+\n+  assert(frexp((double)reciprocal, &exp) == 0.5, \"reciprocal should be power of 2\");\n+\n+  \/\/ return multiplication by the reciprocal\n+  return (new MulHFNode(in(1), phase->makecon(TypeH::make(reciprocal))));\n+}\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":109,"deletions":0,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -81,0 +81,14 @@\n+\n+\/\/------------------------------DivHFNode--------------------------------------\n+\/\/ Half float division\n+class DivHFNode : public Node {\n+public:\n+  DivHFNode(Node* c, Node* dividend, Node* divisor) : Node(c, dividend, divisor) {}\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1004,1 +1004,1 @@\n-    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+    ex_klass_node = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -1022,1 +1022,1 @@\n-        Node* k = _gvn.transform( LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+        Node* k = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4716,0 +4716,1 @@\n+              op == Op_ReinterpretS2HF ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1234,1 +1234,1 @@\n-  return _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+  return _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -2969,1 +2969,1 @@\n-  Node *nkls = gvn.transform(LoadKlassNode::make(gvn, nullptr, kmem, p2, gvn.type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n+  Node* nkls = gvn.transform(LoadKlassNode::make(gvn, kmem, p2, gvn.type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -3762,1 +3762,1 @@\n-    Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, control(), C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+    Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciSymbols.hpp\"\n@@ -525,1 +526,0 @@\n-  case vmIntrinsics::_getModifiers:\n@@ -541,1 +541,2 @@\n-\n+  case vmIntrinsics::_sqrt_float16:             return inline_fp16_operations(intrinsic_id(), 1);\n+  case vmIntrinsics::_fma_float16:              return inline_fp16_operations(intrinsic_id(), 3);\n@@ -3212,1 +3213,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(),\n@@ -3242,1 +3243,1 @@\n-    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(),\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(),\n@@ -4027,1 +4028,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeRawPtr::BOTTOM, kls_type));\n@@ -4089,4 +4090,0 @@\n-  case vmIntrinsics::_getModifiers:\n-    prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n-    return_type = TypeInt::CHAR;\n-    break;\n@@ -4172,5 +4169,0 @@\n-  case vmIntrinsics::_getModifiers:\n-    p = basic_plus_adr(kls, in_bytes(Klass::modifier_flags_offset()));\n-    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n-    break;\n-\n@@ -4224,1 +4216,1 @@\n-    kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n+    kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -4393,1 +4385,1 @@\n-    Node* kls = LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p, adr_type, kls_type);\n+    Node* kls = LoadKlassNode::make(_gvn, immutable_memory(), p, adr_type, kls_type);\n@@ -5471,1 +5463,1 @@\n-  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p,\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p,\n@@ -9007,0 +8999,109 @@\n+\n+Node* LibraryCallKit::unbox_fp16_value(const TypeInstPtr* float16_box_type, ciField* field, Node* box) {\n+  const TypeInstPtr* box_type = _gvn.type(box)->isa_instptr();\n+  if (box_type == nullptr || box_type->instance_klass() != float16_box_type->instance_klass()) {\n+    return nullptr; \/\/ box klass is not Float16\n+  }\n+\n+  \/\/ Null check; get notnull casted pointer\n+  Node* null_ctl = top();\n+  Node* not_null_box = null_check_oop(box, &null_ctl, true);\n+  \/\/ If not_null_box is dead, only null-path is taken\n+  if (stopped()) {\n+    set_control(null_ctl);\n+    return nullptr;\n+  }\n+  assert(not_null_box->bottom_type()->is_instptr()->maybe_null() == false, \"\");\n+  const TypePtr* adr_type = C->alias_type(field)->adr_type();\n+  Node* adr = basic_plus_adr(not_null_box, field->offset_in_bytes());\n+  return access_load_at(not_null_box, adr, adr_type, TypeInt::SHORT, T_SHORT, IN_HEAP);\n+}\n+\n+Node* LibraryCallKit::box_fp16_value(const TypeInstPtr* float16_box_type, ciField* field, Node* value) {\n+  PreserveReexecuteState preexecs(this);\n+  jvms()->set_should_reexecute(true);\n+\n+  const TypeKlassPtr* klass_type = float16_box_type->as_klass_type();\n+  Node* klass_node = makecon(klass_type);\n+  Node* box = new_instance(klass_node);\n+\n+  Node* value_field = basic_plus_adr(box, field->offset_in_bytes());\n+  const TypePtr* value_adr_type = value_field->bottom_type()->is_ptr();\n+\n+  Node* field_store = _gvn.transform(access_store_at(box,\n+                                                     value_field,\n+                                                     value_adr_type,\n+                                                     value,\n+                                                     TypeInt::SHORT,\n+                                                     T_SHORT,\n+                                                     IN_HEAP));\n+  set_memory(field_store, value_adr_type);\n+  return box;\n+}\n+\n+bool LibraryCallKit::inline_fp16_operations(vmIntrinsics::ID id, int num_args) {\n+  if (!Matcher::match_rule_supported(Op_ReinterpretS2HF) ||\n+      !Matcher::match_rule_supported(Op_ReinterpretHF2S)) {\n+    return false;\n+  }\n+\n+  const TypeInstPtr* box_type = _gvn.type(argument(0))->isa_instptr();\n+  if (box_type == nullptr || box_type->const_oop() == nullptr) {\n+    return false;\n+  }\n+\n+  ciInstanceKlass* float16_klass = box_type->const_oop()->as_instance()->java_lang_Class_klass()->as_instance_klass();\n+  const TypeInstPtr* float16_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, float16_klass);\n+  ciField* field = float16_klass->get_field_by_name(ciSymbols::value_name(),\n+                                                    ciSymbols::short_signature(),\n+                                                    false);\n+  assert(field != nullptr, \"\");\n+\n+  \/\/ Transformed nodes\n+  Node* fld1 = nullptr;\n+  Node* fld2 = nullptr;\n+  Node* fld3 = nullptr;\n+  switch(num_args) {\n+    case 3:\n+      fld3 = unbox_fp16_value(float16_box_type, field, argument(3));\n+      if (fld3 == nullptr) {\n+        return false;\n+      }\n+      fld3 = _gvn.transform(new ReinterpretS2HFNode(fld3));\n+    \/\/ fall-through\n+    case 2:\n+      fld2 = unbox_fp16_value(float16_box_type, field, argument(2));\n+      if (fld2 == nullptr) {\n+        return false;\n+      }\n+      fld2 = _gvn.transform(new ReinterpretS2HFNode(fld2));\n+    \/\/ fall-through\n+    case 1:\n+      fld1 = unbox_fp16_value(float16_box_type, field, argument(1));\n+      if (fld1 == nullptr) {\n+        return false;\n+      }\n+      fld1 = _gvn.transform(new ReinterpretS2HFNode(fld1));\n+      break;\n+    default: fatal(\"Unsupported number of arguments %d\", num_args);\n+  }\n+\n+  Node* result = nullptr;\n+  switch (id) {\n+    \/\/ Unary operations\n+    case vmIntrinsics::_sqrt_float16:\n+      result = _gvn.transform(new SqrtHFNode(C, control(), fld1));\n+      break;\n+    \/\/ Ternary operations\n+    case vmIntrinsics::_fma_float16:\n+      result = _gvn.transform(new FmaHFNode(fld1, fld2, fld3));\n+      break;\n+    default:\n+      fatal_unexpected_iid(id);\n+      break;\n+  }\n+  result = _gvn.transform(new ReinterpretHF2SNode(result));\n+  set_result(box_fp16_value(float16_box_type, field, result));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":118,"deletions":17,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -323,0 +323,3 @@\n+  bool inline_fp16_operations(vmIntrinsics::ID id, int num_args);\n+  Node* unbox_fp16_value(const TypeInstPtr* box_class, ciField* field, Node* box);\n+  Node* box_fp16_value(const TypeInstPtr* box_class, ciField* field, Node* value);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+jshort  MachOper::constantH() const { ShouldNotReachHere(); }\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,0 +160,1 @@\n+  virtual jshort  constantH() const;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2734,1 +2734,1 @@\n-      subklass = _igvn.transform(LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+      subklass = _igvn.transform(LoadKlassNode::make(_igvn, C->immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -2800,1 +2800,1 @@\n-        Node* klass = _igvn.transform(LoadKlassNode::make(_igvn, ctrl, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+        Node* klass = _igvn.transform(LoadKlassNode::make(_igvn, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -2829,1 +2829,1 @@\n-        klass = transform_later(LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+        klass = transform_later(LoadKlassNode::make(_igvn, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-  Node* klass = transform_later(LoadKlassNode::make(_igvn, *ctrl, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+  Node* klass = transform_later(LoadKlassNode::make(_igvn, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -704,1 +704,1 @@\n-        Node* n1 = LoadKlassNode::make(_igvn, nullptr, C->immutable_memory(), p1, TypeRawPtr::BOTTOM);\n+        Node* n1 = LoadKlassNode::make(_igvn, C->immutable_memory(), p1, TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2348,0 +2348,1 @@\n+    case Op_FmaHF:\n@@ -2520,0 +2521,1 @@\n+    case Op_FmaHF:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2003,6 +2003,0 @@\n-  if (tkls->offset() == in_bytes(Klass::modifier_flags_offset())) {\n-    \/\/ The field is Klass::_modifier_flags.  Return its (constant) value.\n-    \/\/ (Folds up the 2nd indirection in aClassConstant.getModifiers().)\n-    assert(Opcode() == Op_LoadUS, \"must load an unsigned short from _modifier_flags\");\n-    return TypeInt::make(klass->modifier_flags());\n-  }\n@@ -2442,2 +2436,1 @@\n-Node* LoadKlassNode::make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,\n-                          const TypeKlassPtr* tk) {\n+Node* LoadKlassNode::make(PhaseGVN& gvn, Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk) {\n@@ -2445,1 +2438,1 @@\n-  const TypePtr *adr_type = adr->bottom_type()->isa_ptr();\n+  const TypePtr* adr_type = adr->bottom_type()->isa_ptr();\n@@ -2450,1 +2443,1 @@\n-    Node* load_klass = gvn.transform(new LoadNKlassNode(ctl, mem, adr, at, tk->make_narrowklass(), MemNode::unordered));\n+    Node* load_klass = gvn.transform(new LoadNKlassNode(mem, adr, at, tk->make_narrowklass(), MemNode::unordered));\n@@ -2455,1 +2448,1 @@\n-  return new LoadKlassNode(ctl, mem, adr, at, tk, MemNode::unordered);\n+  return new LoadKlassNode(mem, adr, at, tk, MemNode::unordered);\n@@ -2463,6 +2456,0 @@\n-\/\/ In most cases, LoadKlassNode does not have the control input set. If the control\n-\/\/ input is set, it must not be removed (by LoadNode::Ideal()).\n-bool LoadKlassNode::can_remove_control() const {\n-  return false;\n-}\n-\n@@ -2511,1 +2498,1 @@\n-        \/\/ (Folds up the 1st indirection in aClassConstant.getModifiers().)\n+        \/\/ Fold up the load of the hidden field\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":18,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -529,4 +529,4 @@\n-protected:\n-  \/\/ In most cases, LoadKlassNode does not have the control input set. If the control\n-  \/\/ input is set, it must not be removed (by LoadNode::Ideal()).\n-  virtual bool can_remove_control() const;\n+private:\n+  LoadKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeKlassPtr* tk, MemOrd mo)\n+    : LoadPNode(nullptr, mem, adr, at, tk, mo) {}\n+\n@@ -534,2 +534,0 @@\n-  LoadKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeKlassPtr *tk, MemOrd mo)\n-    : LoadPNode(c, mem, adr, at, tk, mo) {}\n@@ -542,1 +540,1 @@\n-  static Node* make(PhaseGVN& gvn, Node* ctl, Node* mem, Node* adr, const TypePtr* at,\n+  static Node* make(PhaseGVN& gvn, Node* mem, Node* adr, const TypePtr* at,\n@@ -555,0 +553,5 @@\n+private:\n+  friend Node* LoadKlassNode::make(PhaseGVN&, Node*, Node*, const TypePtr*, const TypeKlassPtr*);\n+  LoadNKlassNode(Node* mem, Node* adr, const TypePtr* at, const TypeNarrowKlass* tk, MemOrd mo)\n+    : LoadNNode(nullptr, mem, adr, at, tk, mo) {}\n+\n@@ -556,2 +559,0 @@\n-  LoadNKlassNode(Node *c, Node *mem, Node *adr, const TypePtr *at, const TypeNarrowKlass *tk, MemOrd mo)\n-    : LoadNNode(c, mem, adr, at, tk, mo) {}\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n-                  (op == Op_MulF) || (op == Op_MulD);\n+                  (op == Op_MulF) || (op == Op_MulD) ||\n+                  (op == Op_MulHF);\n@@ -124,1 +125,2 @@\n-      op != Op_MulD ) {\n+      op != Op_MulD &&\n+      op != Op_MulHF) {\n@@ -550,0 +552,8 @@\n+  return MulNode::Ideal(phase, can_reshape);\n+}\n+\n+\/\/=============================================================================\n+\/\/------------------------------Ideal------------------------------------------\n+\/\/ Check to see if we are multiplying by a constant 2 and convert to add, then try the regular MulNode::Ideal\n+Node* MulHFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeH* t2 = phase->type(in(2))->isa_half_float_constant();\n@@ -551,0 +561,5 @@\n+  \/\/ x * 2 -> x + x\n+  if (t2 != nullptr && t2->getf() == 2) {\n+    Node* base = in(1);\n+    return new AddHFNode(base, base);\n+  }\n@@ -554,0 +569,8 @@\n+\/\/ Compute the product type of two half float ranges into this node.\n+const Type* MulHFNode::mul_ring(const Type* t0, const Type* t1) const {\n+  if (t0 == Type::HALF_FLOAT || t1 == Type::HALF_FLOAT) {\n+    return Type::HALF_FLOAT;\n+  }\n+  return TypeH::make(t0->getf() * t1->getf());\n+}\n+\n@@ -1956,0 +1979,22 @@\n+\/\/=============================================================================\n+\/\/------------------------------Value------------------------------------------\n+const Type* FmaHFNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  if (t1 == Type::TOP) { return Type::TOP; }\n+  if (t1->base() != Type::HalfFloatCon) { return Type::HALF_FLOAT; }\n+  const Type* t2 = phase->type(in(2));\n+  if (t2 == Type::TOP) { return Type::TOP; }\n+  if (t2->base() != Type::HalfFloatCon) { return Type::HALF_FLOAT; }\n+  const Type* t3 = phase->type(in(3));\n+  if (t3 == Type::TOP) { return Type::TOP; }\n+  if (t3->base() != Type::HalfFloatCon) { return Type::HALF_FLOAT; }\n+#ifndef __STDC_IEC_559__\n+  return Type::HALF_FLOAT;\n+#else\n+  float f1 = t1->getf();\n+  float f2 = t2->getf();\n+  float f3 = t3->getf();\n+  return TypeH::make(fma(f1, f2, f3));\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":47,"deletions":2,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1601,0 +1601,7 @@\n+\/\/ Get a half float constant from a ConstNode.\n+\/\/ Returns the constant if it is a float ConstNode\n+jshort Node::geth() const {\n+  assert( Opcode() == Op_ConH, \"\" );\n+  return ((ConHNode*)this)->type()->is_half_float_constant()->geth();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+class CastHHNode;\n@@ -734,0 +735,1 @@\n+        DEFINE_CLASS_ID(CastHH, ConstraintCast, 7)\n@@ -921,0 +923,1 @@\n+  DEFINE_CLASS_QUERY(CastFF)\n@@ -1273,0 +1276,1 @@\n+  jshort geth() const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2278,1 +2278,1 @@\n-  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n+  Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), klass_addr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,1 +169,0 @@\n-  bool always_see_exact_class = false;\n@@ -172,1 +171,1 @@\n-    const TypeKlassPtr* extak = nullptr;\n+    const TypeAryKlassPtr* extak = nullptr;\n@@ -179,1 +178,1 @@\n-      extak = TypeKlassPtr::make(ary_spec);\n+      extak = TypeKlassPtr::make(ary_spec)->is_aryklassptr();\n@@ -192,1 +191,1 @@\n-          extak = TypeKlassPtr::make(array_type);\n+          extak = TypeKlassPtr::make(array_type)->is_aryklassptr();\n@@ -195,1 +194,1 @@\n-    } else if (!too_many_traps(Deoptimization::Reason_array_check) && tak != TypeInstKlassPtr::OBJECT) {\n+    } else if (!too_many_traps(Deoptimization::Reason_array_check) && tak->isa_aryklassptr()) {\n@@ -214,1 +213,1 @@\n-      extak = tak->cast_to_exactness(true);\n+      extak = tak->cast_to_exactness(true)->is_aryklassptr();\n@@ -223,1 +222,0 @@\n-        always_see_exact_class = true;\n@@ -254,7 +252,4 @@\n-\n-  Node *p2 = basic_plus_adr(array_klass, array_klass, element_klass_offset);\n-  \/\/ We are allowed to use the constant type only if cast succeeded. If always_see_exact_class is true,\n-  \/\/ we must set a control edge from the IfTrue node created by the uncommon_trap above to the\n-  \/\/ LoadKlassNode.\n-  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, always_see_exact_class ? control() : nullptr,\n-                                                       immutable_memory(), p2, tak));\n+  Node* p2 = basic_plus_adr(array_klass, array_klass, element_klass_offset);\n+  Node* a_e_klass = _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), p2, tak));\n+  \/\/ Disable, fix: 8350632\n+  \/\/assert(array_klass->is_Con() == a_e_klass->is_Con() || StressReflectiveCode, \"a constant array type must come with a constant element type\");\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -556,0 +556,18 @@\n+\/\/------------------------------sub--------------------------------------------\n+\/\/ A subtract node differences its two inputs.\n+const Type* SubHFNode::sub(const Type* t1, const Type* t2) const {\n+  \/\/ no folding if one of operands is infinity or NaN, do not do constant folding\n+  if(g_isfinite(t1->getf()) && g_isfinite(t2->getf())) {\n+    return TypeH::make(t1->getf() - t2->getf());\n+  }\n+  else if(g_isnan(t1->getf())) {\n+    return t1;\n+  }\n+  else if(g_isnan(t2->getf())) {\n+    return t2;\n+  }\n+  else {\n+    return Type::HALF_FLOAT;\n+  }\n+}\n+\n@@ -2091,0 +2109,9 @@\n+const Type* SqrtHFNode::Value(PhaseGVN* phase) const {\n+  const Type* t1 = phase->type(in(1));\n+  if (t1 == Type::TOP) { return Type::TOP; }\n+  if (t1->base() != Type::HalfFloatCon) { return Type::HALF_FLOAT; }\n+  float f = t1->getf();\n+  if (f < 0.0f) return Type::HALF_FLOAT;\n+  return TypeH::make((float)sqrt((double)f));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -133,0 +133,12 @@\n+\/\/------------------------------SubHFNode--------------------------------------\n+\/\/ Subtract 2 half floats\n+class SubHFNode : public SubFPNode {\n+public:\n+  SubHFNode(Node* in1, Node* in2) : SubFPNode(in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type* sub(const Type*, const Type*) const;\n+  const Type* add_id() const { return TypeH::ZERO; }\n+  const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n@@ -553,0 +565,14 @@\n+\/\/------------------------------SqrtHFNode-------------------------------------\n+\/\/ square root of a half-precision float\n+class SqrtHFNode : public Node {\n+public:\n+  SqrtHFNode(Compile* C, Node* c, Node* in1) : Node(c, in1) {\n+    init_flags(Flag_is_expensive);\n+    C->add_expensive_node(this);\n+  }\n+  virtual int Opcode() const;\n+  const Type* bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual uint ideal_reg() const { return Op_RegF; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-          Node* nkls = phase->transform(LoadKlassNode::make(*phase, nullptr, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n+          Node* nkls = phase->transform(LoadKlassNode::make(*phase, C->immutable_memory(), p2, phase->type(p2)->is_ptr(), TypeInstKlassPtr::OBJECT_OR_NULL));\n@@ -240,1 +240,1 @@\n-    subklass  = phase->transform(LoadKlassNode::make(*phase, nullptr, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n+    subklass  = phase->transform(LoadKlassNode::make(*phase, phase->C->immutable_memory(), adr, TypeInstPtr::KLASS));\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -50,0 +51,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -155,0 +157,3 @@\n+  { HalfFloatBot,    T_SHORT,      \"halffloat_top\", false, Op_RegF,              relocInfo::none          },  \/\/ HalfFloatTop\n+  { HalfFloatCon,    T_SHORT,      \"hfcon:\",        false, Op_RegF,              relocInfo::none          },  \/\/ HalfFloatCon\n+  { HalfFloatTop,    T_SHORT,      \"short\",         false, Op_RegF,              relocInfo::none          },  \/\/ HalfFloatBot\n@@ -184,0 +189,1 @@\n+const Type *Type::HALF_FLOAT;   \/\/ All half floats\n@@ -507,0 +513,1 @@\n+  HALF_FLOAT = make(HalfFloatBot); \/\/ All half floats\n@@ -518,0 +525,7 @@\n+  TypeH::MAX = TypeH::make(max_jfloat16); \/\/ HalfFloat MAX\n+  TypeH::MIN = TypeH::make(min_jfloat16); \/\/ HalfFloat MIN\n+  TypeH::ZERO = TypeH::make((jshort)0); \/\/ HalfFloat 0 (positive zero)\n+  TypeH::ONE  = TypeH::make(one_jfloat16); \/\/ HalfFloat 1\n+  TypeH::POS_INF = TypeH::make(pos_inf_jfloat16);\n+  TypeH::NEG_INF = TypeH::make(neg_inf_jfloat16);\n+\n@@ -1111,0 +1125,1 @@\n+  case HalfFloatCon:\n@@ -1146,0 +1161,9 @@\n+  case HalfFloatTop:\n+    if (_base == HalfFloatTop) { return this; }\n+  case HalfFloatBot:            \/\/ Half Float\n+    if (_base == HalfFloatBot || _base == HalfFloatTop) { return HALF_FLOAT; }\n+    if (_base == FloatBot || _base == FloatTop) { return Type::BOTTOM; }\n+    if (_base == DoubleTop || _base == DoubleBot) { return Type::BOTTOM; }\n+    typerr(t);\n+    return Type::BOTTOM;\n+\n@@ -1147,1 +1171,1 @@\n-    if( _base == FloatTop ) return this;\n+    if (_base == FloatTop ) { return this; }\n@@ -1149,2 +1173,3 @@\n-    if( _base == FloatBot || _base == FloatTop ) return FLOAT;\n-    if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;\n+    if (_base == FloatBot || _base == FloatTop) { return FLOAT; }\n+    if (_base == HalfFloatTop || _base == HalfFloatBot) { return Type::BOTTOM; }\n+    if (_base == DoubleTop || _base == DoubleBot) { return Type::BOTTOM; }\n@@ -1155,1 +1180,1 @@\n-    if( _base == DoubleTop ) return this;\n+    if (_base == DoubleTop) { return this; }\n@@ -1157,2 +1182,3 @@\n-    if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;\n-    if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;\n+    if (_base == DoubleBot || _base == DoubleTop) { return DOUBLE; }\n+    if (_base == HalfFloatTop || _base == HalfFloatBot) { return Type::BOTTOM; }\n+    if (_base == FloatTop || _base == FloatBot) { return Type::BOTTOM; }\n@@ -1166,1 +1192,1 @@\n-    if( _base == t->_base )  return this;\n+    if (_base == t->_base)  { return this; }\n@@ -1246,0 +1272,1 @@\n+  case HalfFloatTop:\n@@ -1254,0 +1281,1 @@\n+  case HalfFloatBot:\n@@ -1301,0 +1329,3 @@\n+    case Type::HalfFloatTop:\n+    case Type::HalfFloatCon:\n+    case Type::HalfFloatBot:\n@@ -1406,0 +1437,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -1484,0 +1518,132 @@\n+\/\/=============================================================================\n+\/\/ Convenience common pre-built types.\n+const TypeH* TypeH::MAX;        \/\/ Half float max\n+const TypeH* TypeH::MIN;        \/\/ Half float min\n+const TypeH* TypeH::ZERO;       \/\/ Half float zero\n+const TypeH* TypeH::ONE;        \/\/ Half float one\n+const TypeH* TypeH::POS_INF;    \/\/ Half float positive infinity\n+const TypeH* TypeH::NEG_INF;    \/\/ Half float negative infinity\n+\n+\/\/------------------------------make-------------------------------------------\n+\/\/ Create a halffloat constant\n+const TypeH* TypeH::make(short f) {\n+  return (TypeH*)(new TypeH(f))->hashcons();\n+}\n+\n+const TypeH* TypeH::make(float f) {\n+  assert(StubRoutines::f2hf_adr() != nullptr, \"\");\n+  short hf = StubRoutines::f2hf(f);\n+  return (TypeH*)(new TypeH(hf))->hashcons();\n+}\n+\n+\/\/------------------------------xmeet-------------------------------------------\n+\/\/ Compute the MEET of two types.  It returns a new Type object.\n+const Type* TypeH::xmeet(const Type* t) const {\n+  \/\/ Perform a fast test for common case; meeting the same types together.\n+  if (this == t) return this;  \/\/ Meeting same type-rep?\n+\n+  \/\/ Current \"this->_base\" is FloatCon\n+  switch (t->base()) {          \/\/ Switch on original type\n+  case AnyPtr:                  \/\/ Mixing with oops happens when javac\n+  case RawPtr:                  \/\/ reuses local variables\n+  case OopPtr:\n+  case InstPtr:\n+  case AryPtr:\n+  case MetadataPtr:\n+  case KlassPtr:\n+  case InstKlassPtr:\n+  case AryKlassPtr:\n+  case NarrowOop:\n+  case NarrowKlass:\n+  case Int:\n+  case Long:\n+  case FloatTop:\n+  case FloatCon:\n+  case FloatBot:\n+  case DoubleTop:\n+  case DoubleCon:\n+  case DoubleBot:\n+  case Bottom:                  \/\/ Ye Olde Default\n+    return Type::BOTTOM;\n+\n+  case HalfFloatBot:\n+    return t;\n+\n+  default:                      \/\/ All else is a mistake\n+    typerr(t);\n+\n+  case HalfFloatCon:            \/\/ Half float-constant vs Half float-constant?\n+    if (_f != t->geth()) {      \/\/ unequal constants?\n+                                \/\/ must compare bitwise as positive zero, negative zero and NaN have\n+                                \/\/ all the same representation in C++\n+      return HALF_FLOAT;        \/\/ Return generic float\n+    }                           \/\/ Equal constants\n+  case Top:\n+  case HalfFloatTop:\n+    break;                      \/\/ Return the Half float constant\n+  }\n+  return this;                  \/\/ Return the Half float constant\n+}\n+\n+\/\/------------------------------xdual------------------------------------------\n+\/\/ Dual: symmetric\n+const Type* TypeH::xdual() const {\n+  return this;\n+}\n+\n+\/\/------------------------------eq---------------------------------------------\n+\/\/ Structural equality check for Type representations\n+bool TypeH::eq(const Type* t) const {\n+  \/\/ Bitwise comparison to distinguish between +\/-0. These values must be treated\n+  \/\/ as different to be consistent with C1 and the interpreter.\n+  return (_f == t->geth());\n+}\n+\n+\/\/------------------------------hash-------------------------------------------\n+\/\/ Type-specific hashing function.\n+uint TypeH::hash(void) const {\n+  return *(jshort*)(&_f);\n+}\n+\n+\/\/------------------------------is_finite--------------------------------------\n+\/\/ Has a finite value\n+bool TypeH::is_finite() const {\n+  assert(StubRoutines::hf2f_adr() != nullptr, \"\");\n+  float f = StubRoutines::hf2f(geth());\n+  return g_isfinite(f) != 0;\n+}\n+\n+float TypeH::getf() const {\n+  assert(StubRoutines::hf2f_adr() != nullptr, \"\");\n+  return StubRoutines::hf2f(geth());\n+}\n+\n+\/\/------------------------------is_nan-----------------------------------------\n+\/\/ Is not a number (NaN)\n+bool TypeH::is_nan() const {\n+  assert(StubRoutines::hf2f_adr() != nullptr, \"\");\n+  float f = StubRoutines::hf2f(geth());\n+  return g_isnan(f) != 0;\n+}\n+\n+\/\/------------------------------dump2------------------------------------------\n+\/\/ Dump float constant Type\n+#ifndef PRODUCT\n+void TypeH::dump2(Dict &d, uint depth, outputStream* st) const {\n+  Type::dump2(d,depth, st);\n+  st->print(\"%f\", getf());\n+}\n+#endif\n+\n+\/\/------------------------------singleton--------------------------------------\n+\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n+\/\/ constants (Ldi nodes).  Singletons are integer, half float, float or double constants\n+\/\/ or a single symbol.\n+bool TypeH::singleton(void) const {\n+  return true;                  \/\/ Always a singleton\n+}\n+\n+bool TypeH::empty(void) const {\n+  return false;                 \/\/ always exactly a singleton\n+}\n+\n@@ -1519,0 +1685,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -1715,0 +1884,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -1978,0 +2150,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -2850,0 +3025,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -3776,0 +3954,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -4378,0 +4559,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -5234,0 +5418,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -5786,0 +5973,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -5940,0 +6130,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -6319,0 +6512,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n@@ -6814,0 +7010,3 @@\n+  case HalfFloatTop:\n+  case HalfFloatCon:\n+  case HalfFloatBot:\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":206,"deletions":7,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+class   TypeH;\n@@ -125,0 +126,3 @@\n+    HalfFloatTop,               \/\/ No float value\n+    HalfFloatCon,               \/\/ Floating point constant\n+    HalfFloatBot,               \/\/ Any float value\n@@ -306,1 +310,2 @@\n-  float getf() const;\n+  short geth() const;\n+  virtual float getf() const;\n@@ -318,0 +323,3 @@\n+  const TypeH      *isa_half_float() const;          \/\/ Returns null if not a Float{Top,Con,Bot}\n+  const TypeH      *is_half_float_constant() const;  \/\/ Asserts it is a FloatCon\n+  const TypeH      *isa_half_float_constant() const; \/\/ Returns null if not a FloatCon\n@@ -463,0 +471,1 @@\n+  static const Type *HALF_FLOAT;\n@@ -553,0 +562,32 @@\n+\/\/ Class of Half Float-Constant Types.\n+class TypeH : public Type {\n+  TypeH(short f) : Type(HalfFloatCon), _f(f) {};\n+public:\n+  virtual bool eq(const Type* t) const;\n+  virtual uint hash() const;             \/\/ Type specific hashing\n+  virtual bool singleton(void) const;    \/\/ TRUE if type is a singleton\n+  virtual bool empty(void) const;        \/\/ TRUE if type is vacuous\n+public:\n+  const short _f;                        \/\/ Half Float constant\n+\n+  static const TypeH* make(float f);\n+  static const TypeH* make(short f);\n+\n+  virtual bool is_finite() const;  \/\/ Has a finite value\n+  virtual bool is_nan() const;     \/\/ Is not a number (NaN)\n+\n+  virtual float getf() const;\n+  virtual const Type* xmeet(const Type* t) const;\n+  virtual const Type* xdual() const;    \/\/ Compute dual right now.\n+  \/\/ Convenience common pre-built types.\n+  static const TypeH* MAX;\n+  static const TypeH* MIN;\n+  static const TypeH* ZERO; \/\/ positive zero only\n+  static const TypeH* ONE;\n+  static const TypeH* POS_INF;\n+  static const TypeH* NEG_INF;\n+#ifndef PRODUCT\n+  virtual void dump2(Dict &d, uint depth, outputStream* st) const;\n+#endif\n+};\n+\n@@ -2110,0 +2151,5 @@\n+inline short Type::geth() const {\n+  assert(_base == HalfFloatCon, \"Not a HalfFloatCon\");\n+  return ((TypeH*)this)->_f;\n+}\n+\n@@ -2142,0 +2188,15 @@\n+inline const TypeH* Type::isa_half_float() const {\n+  return ((_base == HalfFloatTop ||\n+           _base == HalfFloatCon ||\n+           _base == HalfFloatBot) ? (TypeH*)this : nullptr);\n+}\n+\n+inline const TypeH* Type::is_half_float_constant() const {\n+  assert( _base == HalfFloatCon, \"Not a HalfFloat\" );\n+  return (TypeH*)this;\n+}\n+\n+inline const TypeH* Type::isa_half_float_constant() const {\n+  return (_base == HalfFloatCon ? (TypeH*)this : nullptr);\n+}\n+\n@@ -2331,1 +2392,2 @@\n-  if( (_base == FloatCon)  || (_base == FloatBot) ||\n+  if( (_base == HalfFloatCon)  || (_base == HalfFloatBot) ||\n+      (_base == FloatCon)  || (_base == FloatBot) ||\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1337,16 +1337,0 @@\n-JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (mirror == nullptr) {\n-    THROW_(vmSymbols::java_lang_NullPointerException(), nullptr);\n-  }\n-\n-  if (java_lang_Class::is_primitive(mirror)) {\n-    \/\/ Primitive types does not have a protection domain.\n-    return nullptr;\n-  }\n-\n-  oop pd = java_lang_Class::protection_domain(mirror);\n-  return (jobject) JNIHandles::make_local(THREAD, pd);\n-JVM_END\n-\n-\n@@ -1413,16 +1397,0 @@\n-JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (java_lang_Class::is_primitive(mirror)) {\n-    \/\/ Primitive type\n-    return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n-  }\n-\n-  Klass* k = java_lang_Class::as_Klass(mirror);\n-  debug_only(u2 computed_modifiers = k->compute_modifier_flags());\n-  assert(k->modifier_flags() == computed_modifiers, \"modifiers cache is OK\");\n-  return k->modifier_flags();\n-JVM_END\n-\n-\n-\/\/ Inner class reflection \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2720,14 +2720,1 @@\n-  JavaThread* current_thread  = JavaThread::current();\n-  jint result = 0;\n-  if (!java_lang_Class::is_primitive(k_mirror)) {\n-    Klass* k = java_lang_Class::as_Klass(k_mirror);\n-    NULL_CHECK(k, JVMTI_ERROR_INVALID_CLASS);\n-    result = k->modifier_flags();\n-\n-    \/\/ Reset the deleted  ACC_SUPER bit (deleted in compute_modifier_flags()).\n-    \/\/ if (k->is_super()) {\n-    \/\/   result |= JVM_ACC_SUPER;\n-    \/\/ }\n-  } else {\n-    result = (JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n-  }\n+  jint result = java_lang_Class::modifiers(k_mirror);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+  do_blob(is_instance_of)                                              \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -267,1 +267,0 @@\n-  nonstatic_field(Klass,                       _modifier_flags,                               u2)                                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -549,0 +549,5 @@\n+const jshort max_jfloat16 = 31743;\n+const jshort min_jfloat16 = 1;\n+const jshort one_jfloat16 = 15360;\n+const jshort pos_inf_jfloat16 = 31744;\n+const jshort neg_inf_jfloat16 = -1024;\n@@ -921,0 +926,1 @@\n+ void set_jshort(jshort i) { _value.i = i;}\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-    private Class(ClassLoader loader, Class<?> arrayComponentType) {\n+    private Class(ClassLoader loader, Class<?> arrayComponentType, int mods, ProtectionDomain pd) {\n@@ -247,0 +247,2 @@\n+        modifiers = mods;\n+        protectionDomain = pd;\n@@ -1044,0 +1046,1 @@\n+    private final transient int modifiers;  \/\/ Set by the VM\n@@ -1389,2 +1392,1 @@\n-    @IntrinsicCandidate\n-    public native int getModifiers();\n+    public int getModifiers() { return modifiers; }\n@@ -2751,11 +2753,1 @@\n-    \/**\n-     * Returns the {@code ProtectionDomain} of this class.\n-     *\n-     * @return the ProtectionDomain of this class\n-     *\n-     * @see java.security.ProtectionDomain\n-     * @since 1.2\n-     *\/\n-    public ProtectionDomain getProtectionDomain() {\n-        return protectionDomain();\n-    }\n+    private transient final ProtectionDomain protectionDomain;\n@@ -2773,4 +2765,10 @@\n-    \/\/ package-private\n-    ProtectionDomain protectionDomain() {\n-        ProtectionDomain pd = getProtectionDomain0();\n-        if (pd == null) {\n+    \/**\n+     * Returns the {@code ProtectionDomain} of this class.\n+     *\n+     * @return the ProtectionDomain of this class\n+     *\n+     * @see java.security.ProtectionDomain\n+     * @since 1.2\n+     *\/\n+    public ProtectionDomain getProtectionDomain() {\n+        if (protectionDomain == null) {\n@@ -2779,1 +2777,1 @@\n-            return pd;\n+            return protectionDomain;\n@@ -2783,5 +2781,0 @@\n-    \/**\n-     * Returns the ProtectionDomain of this class.\n-     *\/\n-    private native ProtectionDomain getProtectionDomain0();\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":17,"deletions":24,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2152,1 +2152,1 @@\n-                return c.protectionDomain();\n+                return c.getProtectionDomain();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-#define PD  \"Ljava\/security\/ProtectionDomain;\"\n@@ -65,1 +64,0 @@\n-    {\"getModifiers\",     \"()I\",             (void *)&JVM_GetClassModifiers},\n@@ -69,1 +67,0 @@\n-    {\"getProtectionDomain0\", \"()\" PD,       (void *)&JVM_GetProtectionDomain},\n","filename":"src\/java.base\/share\/native\/libjava\/Class.c","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        previewHandler = new MandatoryWarningHandler(log, source, verbose, true, \"preview\", LintCategory.PREVIEW);\n+        previewHandler = new MandatoryWarningHandler(log, source, verbose, true, LintCategory.PREVIEW);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1371,0 +1371,1 @@\n+                permitted.add(index, element);\n@@ -1372,1 +1373,0 @@\n-            permitted.add(index, element);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,1 +233,1 @@\n-     * @param deferPos    report errors here\n+     * @param deferDecl   enclosing declaration for DeferredLintHandler, or null for no deferral\n@@ -236,1 +236,1 @@\n-            Symbol s, DiagnosticPosition deferPos)\n+            Symbol s, JCTree deferDecl)\n@@ -254,5 +254,2 @@\n-            DiagnosticPosition prevLintPos =\n-                    deferPos != null\n-                            ? deferredLintHandler.setPos(deferPos)\n-                            : deferredLintHandler.immediate(lint);\n-            Lint prevLint = deferPos != null ? null : chk.setLint(lint);\n+            Assert.check(deferDecl != null);\n+            deferredLintHandler.push(deferDecl);\n@@ -269,3 +266,1 @@\n-                if (prevLint != null)\n-                    chk.setLint(prevLint);\n-                deferredLintHandler.setPos(prevLintPos);\n+                deferredLintHandler.pop();\n@@ -289,1 +284,1 @@\n-            MethodSymbol m, DiagnosticPosition deferPos)\n+            MethodSymbol m, JCTree deferDecl)\n@@ -293,1 +288,1 @@\n-            DiagnosticPosition prevLintPos = deferredLintHandler.setPos(deferPos);\n+            deferredLintHandler.push(deferDecl);\n@@ -297,1 +292,1 @@\n-                deferredLintHandler.setPos(prevLintPos);\n+                deferredLintHandler.pop();\n@@ -694,1 +689,1 @@\n-            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, tree.pos());\n+            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, null);\n@@ -1047,1 +1042,1 @@\n-            Symbol s, DiagnosticPosition deferPos, boolean isTypeParam)\n+            Symbol s, JCTree deferDecl, boolean isTypeParam)\n@@ -1051,3 +1046,2 @@\n-        DiagnosticPosition prevLintPos = null;\n-        if (deferPos != null) {\n-            prevLintPos = deferredLintHandler.setPos(deferPos);\n+        if (deferDecl != null) {\n+            deferredLintHandler.push(deferDecl);\n@@ -1059,2 +1053,2 @@\n-            if (prevLintPos != null)\n-                deferredLintHandler.setPos(prevLintPos);\n+            if (deferDecl != null)\n+                deferredLintHandler.pop();\n@@ -1068,2 +1062,1 @@\n-    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym,\n-            DiagnosticPosition deferPos)\n+    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym, JCTree deferDecl)\n@@ -1072,1 +1065,1 @@\n-        normal(() -> tree.accept(new TypeAnnotate(env, sym, deferPos)));\n+        normal(() -> tree.accept(new TypeAnnotate(env, sym, deferDecl)));\n@@ -1107,1 +1100,1 @@\n-        private DiagnosticPosition deferPos;\n+        private JCTree deferDecl;\n@@ -1109,1 +1102,1 @@\n-        public TypeAnnotate(Env<AttrContext> env, Symbol sym, DiagnosticPosition deferPos) {\n+        public TypeAnnotate(Env<AttrContext> env, Symbol sym, JCTree deferDecl) {\n@@ -1113,1 +1106,1 @@\n-            this.deferPos = deferPos;\n+            this.deferDecl = deferDecl;\n@@ -1118,1 +1111,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferPos, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n@@ -1124,1 +1117,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferPos, true);\n+            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, true);\n@@ -1130,1 +1123,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferPos, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n@@ -1132,1 +1125,1 @@\n-                enterTypeAnnotations(dimAnnos, env, sym, deferPos, false);\n+                enterTypeAnnotations(dimAnnos, env, sym, deferDecl, false);\n@@ -1151,2 +1144,2 @@\n-            DiagnosticPosition prevPos = deferPos;\n-            deferPos = tree.pos();\n+            JCTree prevDecl = deferDecl;\n+            deferDecl = tree;\n@@ -1162,1 +1155,1 @@\n-                deferPos = prevPos;\n+                deferDecl = prevDecl;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":27,"deletions":34,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -867,4 +867,1 @@\n-\n-        DiagnosticPosition prevLintPos\n-                = deferredLintHandler.setPos(variable.pos());\n-\n+        deferredLintHandler.push(variable);\n@@ -886,1 +883,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -1015,1 +1012,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n@@ -1316,1 +1313,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n@@ -1369,1 +1366,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());\n+            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree);\n@@ -4246,1 +4243,1 @@\n-        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.pos());\n+        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.var);\n@@ -4248,1 +4245,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var.pos());\n+            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var);\n@@ -5362,1 +5359,1 @@\n-            deferredLintHandler.flush(env.tree.pos(), lint);\n+            deferredLintHandler.flush(env.tree, lint);\n@@ -5596,1 +5593,1 @@\n-            deferredLintHandler.flush(tree.pos(), lint);\n+            deferredLintHandler.flush(tree, lint);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-                enforceMandatoryWarnings, \"deprecated\", LintCategory.DEPRECATION);\n+                enforceMandatoryWarnings, LintCategory.DEPRECATION, \"deprecated\");\n@@ -173,1 +173,1 @@\n-                enforceMandatoryWarnings, \"removal\", LintCategory.REMOVAL);\n+                enforceMandatoryWarnings, LintCategory.REMOVAL);\n@@ -175,3 +175,1 @@\n-                enforceMandatoryWarnings, \"unchecked\", LintCategory.UNCHECKED);\n-        sunApiHandler = new MandatoryWarningHandler(log, null, false,\n-                enforceMandatoryWarnings, \"sunapi\", null);\n+                enforceMandatoryWarnings, LintCategory.UNCHECKED);\n@@ -209,4 +207,0 @@\n-    \/** A handler for messages about using proprietary API.\n-     *\/\n-    private MandatoryWarningHandler sunApiHandler;\n-\n@@ -313,1 +307,0 @@\n-        sunApiHandler.reportDeferredDiagnostic();\n@@ -489,1 +482,0 @@\n-        sunApiHandler.clear();\n@@ -1224,1 +1216,0 @@\n-     *  @param pos           Position to be used for error reporting.\n@@ -1227,0 +1218,1 @@\n+     *  @param tree          The declaration\n@@ -1228,1 +1220,2 @@\n-    long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {\n+    long checkFlags(long flags, Symbol sym, JCTree tree) {\n+        final DiagnosticPosition pos = tree.pos();\n@@ -1280,1 +1273,1 @@\n-                warnOnExplicitStrictfp(pos);\n+                warnOnExplicitStrictfp(tree);\n@@ -1332,1 +1325,1 @@\n-                warnOnExplicitStrictfp(pos);\n+                warnOnExplicitStrictfp(tree);\n@@ -1407,2 +1400,2 @@\n-    private void warnOnExplicitStrictfp(DiagnosticPosition pos) {\n-        DiagnosticPosition prevLintPos = deferredLintHandler.setPos(pos);\n+    private void warnOnExplicitStrictfp(JCTree tree) {\n+        deferredLintHandler.push(tree);\n@@ -1410,1 +1403,1 @@\n-            deferredLintHandler.report(_ -> lint.logIfEnabled(pos, LintWarnings.Strictfp));\n+            deferredLintHandler.report(_ -> lint.logIfEnabled(tree.pos(), LintWarnings.Strictfp));\n@@ -1412,1 +1405,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-        m.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, m, tree);\n+        m.flags_field = chk.checkFlags(tree.mods.flags, m, tree);\n@@ -197,1 +197,1 @@\n-        DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());\n+        deferredLintHandler.push(tree);\n@@ -205,1 +205,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -230,1 +230,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, m, tree.pos());\n+        annotate.annotateLater(tree.mods.annotations, localEnv, m, tree);\n@@ -233,1 +233,1 @@\n-        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m, tree.pos());\n+        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m, tree);\n@@ -237,1 +237,1 @@\n-            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree.pos());\n+            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree);\n@@ -266,1 +266,1 @@\n-        DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());\n+        deferredLintHandler.push(tree);\n@@ -277,1 +277,1 @@\n-            deferredLintHandler.setPos(prevLintPos);\n+            deferredLintHandler.pop();\n@@ -296,1 +296,1 @@\n-        v.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, v, tree);\n+        v.flags_field = chk.checkFlags(tree.mods.flags, v, tree);\n@@ -320,1 +320,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, v, tree.pos());\n+        annotate.annotateLater(tree.mods.annotations, localEnv, v, tree);\n@@ -322,1 +322,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree.pos());\n+            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,1 +278,1 @@\n-                DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());\n+                deferredLintHandler.push(tree);\n@@ -286,1 +286,1 @@\n-                    deferredLintHandler.setPos(prevLintPos);\n+                    deferredLintHandler.pop();\n@@ -369,1 +369,1 @@\n-            DiagnosticPosition prevLintPos = deferredLintHandler.immediate(lint);\n+            deferredLintHandler.pushImmediate(lint);\n@@ -394,1 +394,1 @@\n-                    DiagnosticPosition prevCheckDeprecatedLintPos = deferredLintHandler.setPos(decl.pos());\n+                    deferredLintHandler.push(decl);\n@@ -399,1 +399,1 @@\n-                        deferredLintHandler.setPos(prevCheckDeprecatedLintPos);\n+                        deferredLintHandler.pop();\n@@ -402,1 +402,1 @@\n-                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl.pos());\n+                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl);\n@@ -407,1 +407,1 @@\n-                deferredLintHandler.setPos(prevLintPos);\n+                deferredLintHandler.pop();\n@@ -440,1 +440,1 @@\n-            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree.pos());\n+            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree);\n@@ -933,1 +933,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());\n+                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree);\n@@ -935,1 +935,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());\n+                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree);\n@@ -950,2 +950,1 @@\n-            annotate.annotateLater(tree.mods.annotations, baseEnv,\n-                        sym, tree.pos());\n+            annotate.annotateLater(tree.mods.annotations, baseEnv, sym, tree);\n@@ -955,1 +954,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());\n+                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -663,1 +663,1 @@\n-            var prevPos = deferredLintHandler.setPos(tree);\n+            deferredLintHandler.push(tree);\n@@ -667,1 +667,1 @@\n-                deferredLintHandler.setPos(prevPos);\n+                deferredLintHandler.pop();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-compiler\/vectorapi\/reshape\/TestVectorReinterpret.java 8320897 aix-ppc64,linux-ppc64le\n+compiler\/vectorapi\/reshape\/TestVectorReinterpret.java 8320897,8348519 aix-ppc64,linux-ppc64le,linux-s390x\n@@ -83,2 +83,0 @@\n-compiler\/arguments\/TestCodeEntryAlignment.java 8349102 generic-all\n-\n@@ -187,7 +185,7 @@\n-serviceability\/sa\/ClhsdbCDSCore.java              8267433,8318754 macosx-x64,macosx-aarch64\n-serviceability\/sa\/ClhsdbFindPC.java#xcomp-core    8267433,8318754 macosx-x64,macosx-aarch64\n-serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8267433,8318754 macosx-x64,macosx-aarch64\n-serviceability\/sa\/ClhsdbPmap.java#core            8267433,8318754 macosx-x64,macosx-aarch64\n-serviceability\/sa\/ClhsdbPstack.java#core          8267433,8318754 macosx-x64,macosx-aarch64\n-serviceability\/sa\/TestJmapCore.java               8267433,8318754 macosx-x64,macosx-aarch64\n-serviceability\/sa\/TestJmapCoreMetaspace.java      8267433,8318754 macosx-x64,macosx-aarch64\n+serviceability\/sa\/ClhsdbCDSCore.java              8318754 macosx-aarch64\n+serviceability\/sa\/ClhsdbFindPC.java#xcomp-core    8318754 macosx-aarch64\n+serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8318754 macosx-aarch64\n+serviceability\/sa\/ClhsdbPmap.java#core            8318754 macosx-aarch64\n+serviceability\/sa\/ClhsdbPstack.java#core          8318754 macosx-aarch64\n+serviceability\/sa\/TestJmapCore.java               8318754 macosx-aarch64\n+serviceability\/sa\/TestJmapCoreMetaspace.java      8318754 macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -935,1 +935,4 @@\n-            return f.getName().equals(\"classLoader\") || f.getName().equals(\"classData\");\n+            return f.getName().equals(\"classLoader\") ||\n+                   f.getName().equals(\"classData\") ||\n+                   f.getName().equals(\"modifiers\") ||\n+                   f.getName().equals(\"protectionDomain\");\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -219,0 +219,5 @@\n+    public static final String ADD_F = PREFIX + \"ADD_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_F, \"AddF\");\n+    }\n+\n@@ -229,0 +234,5 @@\n+    public static final String ADD_HF = PREFIX + \"ADD_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_HF, \"AddHF\");\n+    }\n+\n@@ -538,0 +548,5 @@\n+    public static final String CONV_F2HF = PREFIX + \"CONV_F2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_F2HF, \"ConvF2HF\");\n+    }\n+\n@@ -548,0 +563,5 @@\n+    public static final String CONV_HF2F = PREFIX + \"CONV_HF2F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV_HF2F, \"ConvHF2F\");\n+    }\n+\n@@ -662,0 +682,5 @@\n+    public static final String FMA_HF = PREFIX + \"FMA_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(FMA_HF, \"FmaHF\");\n+    }\n+\n@@ -1169,0 +1194,10 @@\n+    public static final String MIN_HF = PREFIX + \"MIN_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_HF, \"MinHF\");\n+    }\n+\n+    public static final String MAX_HF = PREFIX + \"MAX_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_HF, \"MaxHF\");\n+    }\n+\n@@ -1250,0 +1285,5 @@\n+    public static final String MUL_HF = PREFIX + \"MUL_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_HF, \"MulHF\");\n+    }\n+\n@@ -1450,0 +1490,10 @@\n+    public static final String REINTERPRET_S2HF = PREFIX + \"REINTERPRET_S2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_S2HF, \"ReinterpretS2HF\");\n+    }\n+\n+    public static final String REINTERPRET_HF2S = PREFIX + \"REINTERPRET_HF2S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_HF2S, \"ReinterpretHF2S\");\n+    }\n+\n@@ -1616,0 +1666,10 @@\n+    public static final String SQRT_HF = PREFIX + \"SQRT_HF\" + POSTFIX;\n+    static {\n+       beforeMatchingNameRegex(SQRT_HF, \"SqrtHF\");\n+    }\n+\n+    public static final String SQRT_F = PREFIX + \"SQRT_F\" + POSTFIX;\n+    static {\n+       beforeMatchingNameRegex(SQRT_F, \"SqrtF\");\n+    }\n+\n@@ -1757,0 +1817,5 @@\n+    public static final String SUB_HF = PREFIX + \"SUB_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUB_HF, \"SubHF\");\n+    }\n+\n@@ -1807,0 +1872,5 @@\n+    public static final String DIV_HF = PREFIX + \"DIV_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_HF, \"DivHF\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -553,3 +553,3 @@\n-sun\/management\/jdp\/JdpDefaultsTest.java                         8308807,8241865 aix-ppc64,macosx-aarch64\n-sun\/management\/jdp\/JdpJmxRemoteDynamicPortTest.java             8308807,8241865 aix-ppc64,macosx-aarch64\n-sun\/management\/jdp\/JdpSpecificAddressTest.java                  8308807,8241865 aix-ppc64,macosx-aarch64\n+sun\/management\/jdp\/JdpDefaultsTest.java                         8308807,8241865 aix-ppc64,macosx-all\n+sun\/management\/jdp\/JdpJmxRemoteDynamicPortTest.java             8308807,8241865 aix-ppc64,macosx-all\n+sun\/management\/jdp\/JdpSpecificAddressTest.java                  8308807,8241865 aix-ppc64,macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}