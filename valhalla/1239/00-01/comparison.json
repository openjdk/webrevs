{"files":[{"patch":"@@ -17304,1 +17304,1 @@\n-instruct isInfiniteHF(iRegINoSp dst, vRegF src, vRegF tmp)\n+instruct isInfiniteHF(iRegINoSp dst, iRegINoSp src)\n@@ -17306,2 +17306,1 @@\n-  match(Set dst (IsInfiniteHF src));\n-  effect(TEMP tmp);\n+  match(Set dst (IsInfiniteHF (ReinterpretS2HF src)));\n@@ -17310,6 +17309,6 @@\n-    __ fabsh($src$$FloatRegister, $src$$FloatRegister);\n-    __ movz(rscratch1, 0x7bff); \/\/ Load Float16.MAX_VALUE\n-    __ fmovs($tmp$$FloatRegister, rscratch1);\n-    __ fcmph($src$$FloatRegister, $tmp$$FloatRegister);\n-    __ csetw($dst$$Register, Assembler::GT); \/\/ Set result to true if\n-                                             \/\/ input > max value\n+    __ movz(rscratch1, 0x7c00); \/\/ Load FP16 positive infinity\n+    __ movz(rscratch2, 0x7fff); \/\/ Load 16-bit sign mask\n+    __ eor(rscratch1, $src$$Register, rscratch1); \/\/ eor FP16 positive infinity with src\n+    __ ands(rscratch1, rscratch1, rscratch2); \/\/ Mask off the sign bit (ensures both positive\n+                                              \/\/ and negative infinite values are identified)\n+    __ csetw($dst$$Register, Assembler::EQ); \/\/ Set the destination if result of \"and\" is zero\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -492,4 +492,0 @@\n-    \/\/ Skipping for now\n-    \/\/ public boolean isNaN()\n-    \/\/ public boolean isInfinite() {\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}