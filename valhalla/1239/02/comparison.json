{"files":[{"patch":"@@ -447,1 +447,1 @@\n-        return Float.isNaN(f16.floatValue());\n+        return ((float16ToRawShortBits(f16) & 0x7e00) == 0x7e00);\n@@ -466,1 +466,1 @@\n-        return Float.isInfinite(f16.floatValue());\n+        return ((float16ToRawShortBits(f16) ^ float16ToRawShortBits(POSITIVE_INFINITY)) & 0x7fff) == 0;\n@@ -486,1 +486,1 @@\n-        return Float.isFinite(f16.floatValue());\n+        return (float16ToRawShortBits(f16) & (short)0x0000_7FFF) <= float16ToRawShortBits(MAX_VALUE);\n@@ -489,4 +489,0 @@\n-    \/\/ Skipping for now\n-    \/\/ public boolean isNaN()\n-    \/\/ public boolean isInfinite() {\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,11 +43,14 @@\n-            case \"abs\"  : return float16ToRawShortBits(Float16.abs(shortBitsToFloat16(val[0])));\n-            case \"neg\"  : return float16ToRawShortBits(Float16.negate(shortBitsToFloat16(val[0])));\n-            case \"sqrt\" : return float16ToRawShortBits(Float16.sqrt(shortBitsToFloat16(val[0])));\n-            case \"+\"    : return float16ToRawShortBits(Float16.add(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"-\"    : return float16ToRawShortBits(Float16.subtract(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"*\"    : return float16ToRawShortBits(Float16.multiply(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"\/\"    : return float16ToRawShortBits(Float16.divide(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"min\"  : return float16ToRawShortBits(Float16.min(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"max\"  : return float16ToRawShortBits(Float16.max(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"fma\"  : return float16ToRawShortBits(Float16.fma(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1]), shortBitsToFloat16(val[2])));\n-            default     : throw new AssertionError(\"Unsupported Operation!\");\n+            case \"abs\"        : return float16ToRawShortBits(Float16.abs(shortBitsToFloat16(val[0])));\n+            case \"neg\"        : return float16ToRawShortBits(Float16.negate(shortBitsToFloat16(val[0])));\n+            case \"sqrt\"       : return float16ToRawShortBits(Float16.sqrt(shortBitsToFloat16(val[0])));\n+            case \"isInfinite\" : return (short)(Float16.isInfinite(shortBitsToFloat16(val[0])) ? 1 : 0);\n+            case \"isFinite\"   : return (short)(Float16.isFinite(shortBitsToFloat16(val[0])) ? 1 : 0);\n+            case \"isNaN\"      : return (short)(Float16.isNaN(shortBitsToFloat16(val[0])) ? 1 : 0);\n+            case \"+\"          : return float16ToRawShortBits(Float16.add(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n+            case \"-\"          : return float16ToRawShortBits(Float16.subtract(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n+            case \"*\"          : return float16ToRawShortBits(Float16.multiply(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n+            case \"\/\"          : return float16ToRawShortBits(Float16.divide(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n+            case \"min\"        : return float16ToRawShortBits(Float16.min(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n+            case \"max\"        : return float16ToRawShortBits(Float16.max(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n+            case \"fma\"        : return float16ToRawShortBits(Float16.fma(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1]), shortBitsToFloat16(val[2])));\n+            default           : throw new AssertionError(\"Unsupported Operation!\");\n@@ -62,0 +65,3 @@\n+            validate(\"isInfinite\", arr1[i]);\n+            validate(\"isFinite\", arr1[i]);\n+            validate(\"isNaN\", arr1[i]);\n@@ -74,11 +80,14 @@\n-            case \"abs\" : return Float.floatToFloat16(Math.abs(Float.float16ToFloat(input[0])));\n-            case \"neg\" : return (short)(input[0] ^ (short)0x0000_8000);\n-            case \"sqrt\": return Float.floatToFloat16((float)Math.sqrt((double)Float.float16ToFloat(input[0])));\n-            case \"+\"   : return Float.floatToFloat16(Float.float16ToFloat(input[0]) + Float.float16ToFloat(input[1]));\n-            case \"-\"   : return Float.floatToFloat16(Float.float16ToFloat(input[0]) - Float.float16ToFloat(input[1]));\n-            case \"*\"   : return Float.floatToFloat16(Float.float16ToFloat(input[0]) * Float.float16ToFloat(input[1]));\n-            case \"\/\"   : return Float.floatToFloat16(Float.float16ToFloat(input[0]) \/ Float.float16ToFloat(input[1]));\n-            case \"min\" : return Float.floatToFloat16(Float.min(Float.float16ToFloat(input[0]), Float.float16ToFloat(input[1])));\n-            case \"max\" : return Float.floatToFloat16(Float.max(Float.float16ToFloat(input[0]), Float.float16ToFloat(input[1])));\n-            case \"fma\" : return Float.floatToFloat16(Float.float16ToFloat(input[0]) * Float.float16ToFloat(input[1]) + Float.float16ToFloat(input[2]));\n-            default    : throw new AssertionError(\"Unsupported Operation!\");\n+            case \"abs\"        : return Float.floatToFloat16(Math.abs(Float.float16ToFloat(input[0])));\n+            case \"neg\"        : return (short)(input[0] ^ (short)0x0000_8000);\n+            case \"sqrt\"       : return Float.floatToFloat16((float)Math.sqrt((double)Float.float16ToFloat(input[0])));\n+            case \"isInfinite\" : return (short)(Float.isInfinite(Float.float16ToFloat(input[0])) ? 1 : 0);\n+            case \"isFinite\"   : return (short)(Float.isFinite(Float.float16ToFloat(input[0])) ? 1 : 0);\n+            case \"isNaN\"      : return (short)(Float.isNaN(Float.float16ToFloat(input[0])) ? 1 : 0);\n+            case \"+\"          : return Float.floatToFloat16(Float.float16ToFloat(input[0]) + Float.float16ToFloat(input[1]));\n+            case \"-\"          : return Float.floatToFloat16(Float.float16ToFloat(input[0]) - Float.float16ToFloat(input[1]));\n+            case \"*\"          : return Float.floatToFloat16(Float.float16ToFloat(input[0]) * Float.float16ToFloat(input[1]));\n+            case \"\/\"          : return Float.floatToFloat16(Float.float16ToFloat(input[0]) \/ Float.float16ToFloat(input[1]));\n+            case \"min\"        : return Float.floatToFloat16(Float.min(Float.float16ToFloat(input[0]), Float.float16ToFloat(input[1])));\n+            case \"max\"        : return Float.floatToFloat16(Float.max(Float.float16ToFloat(input[0]), Float.float16ToFloat(input[1])));\n+            case \"fma\"        : return Float.floatToFloat16(Float.float16ToFloat(input[0]) * Float.float16ToFloat(input[1]) + Float.float16ToFloat(input[2]));\n+            default           : throw new AssertionError(\"Unsupported Operation!\");\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ScalarOperations.java","additions":31,"deletions":22,"binary":false,"changes":53,"status":"modified"}]}