{"files":[{"patch":"@@ -447,1 +447,3 @@\n-        return Float.isNaN(f16.floatValue());\n+        final short bits = float16ToRawShortBits(f16);\n+        \/\/ A NaN value has all ones in its exponent and a non-zero significand\n+        return ((bits & 0x7c00) == 0x7c00 && (bits & 0x03ff) != 0);\n@@ -466,1 +468,1 @@\n-        return Float.isInfinite(f16.floatValue());\n+        return ((float16ToRawShortBits(f16) ^ float16ToRawShortBits(POSITIVE_INFINITY)) & 0x7fff) == 0;\n@@ -486,1 +488,1 @@\n-        return Float.isFinite(f16.floatValue());\n+        return (float16ToRawShortBits(f16) & (short)0x0000_7FFF) <= float16ToRawShortBits(MAX_VALUE);\n@@ -489,4 +491,0 @@\n-    \/\/ Skipping for now\n-    \/\/ public boolean isNaN()\n-    \/\/ public boolean isInfinite() {\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n- * @bug 8308363 8336406\n- * @summary Verify binary FP16 scalar operations\n+ * @bug 8308363 8336406 8339473\n+ * @summary Verify FP16 unary, binary and ternary operations\n@@ -34,1 +34,1 @@\n-\n+import java.util.stream.IntStream;\n@@ -39,1 +39,6 @@\n-    public static Random r = new Random(1024);\n+    public static final int SIZE = 65504;\n+    public static Random r = new Random(SIZE);\n+    public static final Float16 ONE = Float16.valueOf(1.0);\n+    public static final Float16 ZERO = Float16.valueOf(0.0);\n+    public static final int EXP = 0x7c00; \/\/ Mask for Float16 Exponent in a NaN (which is all ones)\n+    public static final int SIGN_BIT = 0x8000; \/\/ Mask for sign bit for Float16\n@@ -41,1 +46,1 @@\n-    public static short actual_value(String oper, short... val) {\n+    public static Float16 actual_value(String oper, Float16... val) {\n@@ -43,11 +48,14 @@\n-            case \"abs\"  : return float16ToRawShortBits(Float16.abs(shortBitsToFloat16(val[0])));\n-            case \"neg\"  : return float16ToRawShortBits(Float16.negate(shortBitsToFloat16(val[0])));\n-            case \"sqrt\" : return float16ToRawShortBits(Float16.sqrt(shortBitsToFloat16(val[0])));\n-            case \"+\"    : return float16ToRawShortBits(Float16.add(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"-\"    : return float16ToRawShortBits(Float16.subtract(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"*\"    : return float16ToRawShortBits(Float16.multiply(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"\/\"    : return float16ToRawShortBits(Float16.divide(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"min\"  : return float16ToRawShortBits(Float16.min(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"max\"  : return float16ToRawShortBits(Float16.max(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1])));\n-            case \"fma\"  : return float16ToRawShortBits(Float16.fma(shortBitsToFloat16(val[0]), shortBitsToFloat16(val[1]), shortBitsToFloat16(val[2])));\n-            default     : throw new AssertionError(\"Unsupported Operation!\");\n+            case \"abs\"        : return Float16.abs(val[0]);\n+            case \"neg\"        : return Float16.negate(val[0]);\n+            case \"sqrt\"       : return Float16.sqrt(val[0]);\n+            case \"isInfinite\" : return Float16.isInfinite(val[0]) ? ONE : ZERO;\n+            case \"isFinite\"   : return Float16.isFinite(val[0]) ? ONE : ZERO;\n+            case \"isNaN\"      : return Float16.isNaN(val[0]) ? ONE : ZERO;\n+            case \"+\"          : return Float16.add(val[0], val[1]);\n+            case \"-\"          : return Float16.subtract(val[0], val[1]);\n+            case \"*\"          : return Float16.multiply(val[0], val[1]);\n+            case \"\/\"          : return Float16.divide(val[0], val[1]);\n+            case \"min\"        : return Float16.min(val[0], val[1]);\n+            case \"max\"        : return Float16.max(val[0], val[1]);\n+            case \"fma\"        : return Float16.fma(val[0], val[1], val[2]);\n+            default           : throw new AssertionError(\"Unsupported Operation!\");\n@@ -57,12 +65,16 @@\n-    public static void test_operations(short [] arr1, short arr2[], short arr3[]) {\n-        for (int i = 0; i < arr1.length; i++) {\n-            validate(\"abs\", arr1[i]);\n-            validate(\"neg\", arr1[i]);\n-            validate(\"sqrt\", arr1[i]);\n-            validate(\"+\", arr1[i], arr2[i]);\n-            validate(\"-\", arr1[i], arr2[i]);\n-            validate(\"*\", arr1[i], arr2[i]);\n-            validate(\"\/\", arr1[i], arr2[i]);\n-            validate(\"min\", arr1[i], arr2[i]);\n-            validate(\"max\", arr1[i], arr2[i]);\n-            validate(\"fma\", arr1[i], arr2[i], arr3[i]);\n+    public static Float16 expected_value(String oper, Float16... val) {\n+        switch (oper) {\n+            case \"abs\"        : return Float16.valueOf(Math.abs(val[0].floatValue()));\n+            case \"neg\"        : return Float16.shortBitsToFloat16((short)(Float16.float16ToRawShortBits(val[0]) ^ (short)0x0000_8000));\n+            case \"sqrt\"       : return Float16.valueOf(Math.sqrt(val[0].floatValue()));\n+            case \"isInfinite\" : return Float.isInfinite(val[0].floatValue()) ? ONE : ZERO;\n+            case \"isFinite\"   : return Float.isFinite(val[0].floatValue()) ? ONE : ZERO;\n+            case \"isNaN\"      : return Float.isNaN(val[0].floatValue()) ? ONE : ZERO;\n+            case \"+\"          : return Float16.valueOf(val[0].floatValue() + val[1].floatValue());\n+            case \"-\"          : return Float16.valueOf(val[0].floatValue() - val[1].floatValue());\n+            case \"*\"          : return Float16.valueOf(val[0].floatValue() * val[1].floatValue());\n+            case \"\/\"          : return Float16.valueOf(val[0].floatValue() \/ val[1].floatValue());\n+            case \"min\"        : return Float16.valueOf(Float.min(val[0].floatValue(), val[1].floatValue()));\n+            case \"max\"        : return Float16.valueOf(Float.max(val[0].floatValue(), val[1].floatValue()));\n+            case \"fma\"        : return Float16.valueOf(val[0].floatValue() * val[1].floatValue() + val[2].floatValue());\n+            default           : throw new AssertionError(\"Unsupported Operation!\");\n@@ -72,13 +84,17 @@\n-    public static short expected_value(String oper, short... input) {\n-        switch(oper) {\n-            case \"abs\" : return Float.floatToFloat16(Math.abs(Float.float16ToFloat(input[0])));\n-            case \"neg\" : return (short)(input[0] ^ (short)0x0000_8000);\n-            case \"sqrt\": return Float.floatToFloat16((float)Math.sqrt((double)Float.float16ToFloat(input[0])));\n-            case \"+\"   : return Float.floatToFloat16(Float.float16ToFloat(input[0]) + Float.float16ToFloat(input[1]));\n-            case \"-\"   : return Float.floatToFloat16(Float.float16ToFloat(input[0]) - Float.float16ToFloat(input[1]));\n-            case \"*\"   : return Float.floatToFloat16(Float.float16ToFloat(input[0]) * Float.float16ToFloat(input[1]));\n-            case \"\/\"   : return Float.floatToFloat16(Float.float16ToFloat(input[0]) \/ Float.float16ToFloat(input[1]));\n-            case \"min\" : return Float.floatToFloat16(Float.min(Float.float16ToFloat(input[0]), Float.float16ToFloat(input[1])));\n-            case \"max\" : return Float.floatToFloat16(Float.max(Float.float16ToFloat(input[0]), Float.float16ToFloat(input[1])));\n-            case \"fma\" : return Float.floatToFloat16(Float.float16ToFloat(input[0]) * Float.float16ToFloat(input[1]) + Float.float16ToFloat(input[2]));\n-            default    : throw new AssertionError(\"Unsupported Operation!\");\n+    public static void validate(String oper, Float16... input) {\n+        int arity = input.length;\n+\n+        short actual = Float16.float16ToRawShortBits(actual_value(oper, input));\n+        short expected = Float16.float16ToRawShortBits(expected_value(oper, input));\n+\n+        if (actual != expected) {\n+            switch (arity) {\n+                case 1:\n+                    throw new AssertionError(\"Test Failed: \" + oper + \"(\" + Float16.float16ToRawShortBits(input[0]) + \") : \" +  actual + \" != \" + expected);\n+                case 2:\n+                    throw new AssertionError(\"Test Failed: \" + oper + \"(\" + Float16.float16ToRawShortBits(input[0]) + \", \" + Float16.float16ToRawShortBits(input[1]) + \") : \" + actual + \" != \" + expected);\n+                case 3:\n+                    throw new AssertionError(\"Test failed: \" + oper + \"(\" + Float16.float16ToRawShortBits(input[0]) + \", \" + Float16.float16ToRawShortBits(input[1]) + \", \" + Float16.float16ToRawShortBits(input[2]) + \") : \" + actual + \" != \" + expected);\n+                default:\n+                    throw new AssertionError(\"Incorrect operation (\" + oper + \")  arity = \" + arity);\n+            }\n@@ -88,2 +104,9 @@\n-    public static boolean compare(short actual, short expected) {\n-        return !((0xFFFF & actual) == (0xFFFF & expected));\n+    public static void test_unary_operations(Float16 [] inp) {\n+        for (int i = 0; i < inp.length; i++) {\n+            validate(\"abs\", inp[i]);\n+            validate(\"neg\", inp[i]);\n+            validate(\"sqrt\", inp[i]);\n+            validate(\"isInfinite\", inp[i]);\n+            validate(\"isFinite\", inp[i]);\n+            validate(\"isNaN\", inp[i]);\n+        }\n@@ -92,13 +115,6 @@\n-    public static void validate(String oper, short... input) {\n-        short actual = actual_value(oper, input);\n-        short expected = expected_value(oper, input);\n-        if (compare(actual, expected)) {\n-            if (input.length == 1) {\n-                throw new AssertionError(\"Test Failed: \" + oper + \"(\" + input[0] + \") : \" +  actual + \" != \" + expected);\n-            }\n-            if (input.length == 2) {\n-                throw new AssertionError(\"Test Failed: \" + oper + \"(\" + input[0] + \", \" + input[1] + \") : \" + actual + \" != \" + expected);\n-            }\n-            if (input.length == 3) {\n-                throw new AssertionError(\"Test failed: \" + oper + \"(\" + input[0] + \", \" + input[1] + \", \" + input[2] + \") : \" + actual + \" != \" + expected);\n-            }\n+    public static void test_binary_operations(Float16 [] inp1, Float16 inp2[]) {\n+        for (int i = 0; i < inp1.length; i++) {\n+            validate(\"+\", inp1[i], inp2[i]);\n+            validate(\"-\", inp1[i], inp2[i]);\n+            validate(\"*\", inp1[i], inp2[i]);\n+            validate(\"\/\", inp1[i], inp2[i]);\n@@ -108,4 +124,22 @@\n-    public static short [] get_fp16_array(int size) {\n-        short [] arr = new short[size];\n-        for (int i = 0; i < arr.length; i++) {\n-            arr[i] = Float.floatToFloat16(r.nextFloat());\n+    public static void test_ternary_operations(Float16 [] inp1, Float16 inp2[], Float16 inp3[]) {\n+        for (int i = 0; i < inp1.length; i++) {\n+            validate(\"fma\", inp1[i], inp2[i], inp3[i]);\n+        }\n+    }\n+\n+    public static void test_fin_inf_nan() {\n+        Float16 pos_nan, neg_nan;\n+        \/\/ Starting from 1 as the significand in a NaN value is always non-zero\n+        for (int i = 1; i < 0x03ff; i++) {\n+            pos_nan = Float16.shortBitsToFloat16((short)(EXP | i));\n+            neg_nan = Float16.shortBitsToFloat16((short)(Float16.float16ToRawShortBits(pos_nan) | SIGN_BIT));\n+\n+            \/\/ Test isFinite, isInfinite, isNaN for all positive NaN values\n+            validate(\"isInfinite\", pos_nan);\n+            validate(\"isFinite\", pos_nan);\n+            validate(\"isNaN\", pos_nan);\n+\n+           \/\/ Test isFinite, isinfinite, isNaN for all negative NaN values\n+            validate(\"isInfinite\", neg_nan);\n+            validate(\"isFinite\", neg_nan);\n+            validate(\"isNaN\", neg_nan);\n@@ -113,1 +147,0 @@\n-        return arr;\n@@ -117,11 +150,15 @@\n-        int res = 0;\n-        short [] input1 = get_fp16_array(1024);\n-        short [] input2 = get_fp16_array(1024);\n-        short [] input3 = get_fp16_array(1024);\n-\n-        short [] special_values = {\n-              32256,          \/\/ NAN\n-              31744,          \/\/ +Inf\n-              (short)-1024,   \/\/ -Inf\n-              0,              \/\/ +0.0\n-              (short)-32768,  \/\/ -0.0\n+        Float16 [] input1 = new Float16[SIZE];\n+        Float16 [] input2 = new Float16[SIZE];\n+        Float16 [] input3 = new Float16[SIZE];\n+\n+        \/\/ input1, input2, input3 contain the entire value range for FP16\n+        IntStream.range(0, input1.length).forEach(i -> {input1[i] = Float16.valueOf((float)i);});\n+        IntStream.range(0, input2.length).forEach(i -> {input2[i] = Float16.valueOf((float)i);});\n+        IntStream.range(0, input2.length).forEach(i -> {input3[i] = Float16.valueOf((float)i);});\n+\n+        Float16 [] special_values = {\n+              Float16.NaN,                 \/\/ NAN\n+              Float16.POSITIVE_INFINITY,   \/\/ +Inf\n+              Float16.NEGATIVE_INFINITY,   \/\/ -Inf\n+              Float16.valueOf(0.0),        \/\/ +0.0\n+              Float16.valueOf(-0.0),       \/\/ -0.0\n@@ -129,0 +166,1 @@\n+\n@@ -130,2 +168,11 @@\n-            test_operations(input1, input2, input3);\n-            test_operations(special_values, special_values, special_values);\n+            test_unary_operations(input1);\n+            test_binary_operations(input1, input2);\n+            test_ternary_operations(input1, input2, input3);\n+\n+            test_unary_operations(special_values);\n+            test_binary_operations(special_values, input1);\n+            test_ternary_operations(special_values, input1, input2);\n+\n+            \/\/ The above functions test isFinite, isInfinite and isNaN for all possible finite FP16 values\n+            \/\/ and infinite values. The below method tests these functions for all possible NaN values as well.\n+            test_fin_inf_nan();\n","filename":"test\/jdk\/java\/lang\/Float16\/FP16ScalarOperations.java","additions":121,"deletions":74,"binary":false,"changes":195,"status":"modified"}]}