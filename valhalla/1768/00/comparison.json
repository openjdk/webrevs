{"files":[{"patch":"@@ -665,0 +665,1 @@\n+      _strength_reduction(false),\n@@ -2744,0 +2745,1 @@\n+  set_strength_reduction(true);\n@@ -2761,0 +2763,1 @@\n+  set_strength_reduction(false);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -340,0 +340,1 @@\n+  bool                  _strength_reduction;    \/\/ Are we doing strength reduction to direct call\n@@ -608,0 +609,2 @@\n+  void          set_strength_reduction(bool z)  { _strength_reduction = z; }\n+  bool              strength_reduction() const  { return _strength_reduction; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciMethod.hpp\"\n@@ -2050,11 +2051,16 @@\n-        Node* store_to_buf_call = make_runtime_call(RC_NO_LEAF | RC_NO_IO,\n-                                                    OptoRuntime::store_inline_type_fields_Type(),\n-                                                    StubRoutines::store_inline_type_fields_to_buf(),\n-                                                    nullptr, TypePtr::BOTTOM, ret);\n-\n-        \/\/ We don't know how many values are returned. This assumes the\n-        \/\/ worst case, that all available registers are used.\n-        for (uint i = TypeFunc::Parms+1; i < domain->cnt(); i++) {\n-          if (domain->field_at(i) == Type::HALF) {\n-            store_to_buf_call->init_req(i, top());\n-            continue;\n+        \/\/ Don't add store to buffer call if we are strength reducing\n+        if (!C->strength_reduction()) {\n+          Node* store_to_buf_call = make_runtime_call(RC_NO_LEAF | RC_NO_IO,\n+                                                      OptoRuntime::store_inline_type_fields_Type(),\n+                                                      StubRoutines::store_inline_type_fields_to_buf(),\n+                                                      nullptr, TypePtr::BOTTOM, ret);\n+\n+          \/\/ We don't know how many values are returned. This assumes the\n+          \/\/ worst case, that all available registers are used.\n+          for (uint i = TypeFunc::Parms+1; i < domain->cnt(); i++) {\n+            if (domain->field_at(i) == Type::HALF) {\n+              store_to_buf_call->init_req(i, top());\n+              continue;\n+            }\n+            Node* proj =_gvn.transform(new ProjNode(call, i));\n+            store_to_buf_call->init_req(i, proj);\n@@ -2062,4 +2068,1 @@\n-          Node* proj =_gvn.transform(new ProjNode(call, i));\n-          store_to_buf_call->init_req(i, proj);\n-        }\n-        make_slow_call_ex(store_to_buf_call, env()->Throwable_klass(), false);\n+          make_slow_call_ex(store_to_buf_call, env()->Throwable_klass(), false);\n@@ -2067,3 +2070,3 @@\n-        Node* buf = _gvn.transform(new ProjNode(store_to_buf_call, TypeFunc::Parms));\n-        const Type* buf_type = TypeOopPtr::make_from_klass(t->as_klass())->join_speculative(TypePtr::NOTNULL);\n-        buf = _gvn.transform(new CheckCastPPNode(control(), buf, buf_type));\n+          Node* buf = _gvn.transform(new ProjNode(store_to_buf_call, TypeFunc::Parms));\n+          const Type* buf_type = TypeOopPtr::make_from_klass(t->as_klass())->join_speculative(TypePtr::NOTNULL);\n+          buf = _gvn.transform(new CheckCastPPNode(control(), buf, buf_type));\n@@ -2071,1 +2074,7 @@\n-        ideal.set(res, buf);\n+          ideal.set(res, buf);\n+        } else {\n+          for (uint i = TypeFunc::Parms+1; i < domain->cnt(); i++) {\n+            Node* proj =_gvn.transform(new ProjNode(call, i));\n+          }\n+          ideal.set(res, ret);\n+        }\n@@ -2214,1 +2223,2 @@\n-    assert(callprojs->nb_resproj == 1 || (call->tf()->returns_inline_type_as_fields() && stopped()),\n+    assert(callprojs->nb_resproj == 1 || (call->tf()->returns_inline_type_as_fields() && stopped()) ||\n+           (C->strength_reduction() && InlineTypeReturnedAsFields && !call->as_CallJava()->method()->return_type()->is_loaded()),\n@@ -2216,1 +2226,10 @@\n-    C->gvn_replace_by(callprojs->resproj[0], result);\n+    \/\/ If we are doing strength reduction and the return types is not loaded we\n+    \/\/ need to rewire all projections since store_inline_type_fields_to_buf is already present\n+    if (C->strength_reduction() && InlineTypeReturnedAsFields && !call->as_CallJava()->method()->return_type()->is_loaded()) {\n+      const TypeTuple* domain = OptoRuntime::store_inline_type_fields_Type()->domain_cc();\n+      for (uint i = TypeFunc::Parms; i < domain->cnt(); i++) {\n+        C->gvn_replace_by(callprojs->resproj[0], final_state->in(i));\n+      }\n+    } else {\n+      C->gvn_replace_by(callprojs->resproj[0], result);\n+    }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":40,"deletions":21,"binary":false,"changes":61,"status":"modified"}]}