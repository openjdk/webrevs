{"files":[{"patch":"@@ -670,0 +670,1 @@\n+      _strength_reduction(false),\n@@ -2778,0 +2779,1 @@\n+  set_strength_reduction(true);\n@@ -2795,0 +2797,1 @@\n+  set_strength_reduction(false);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -340,0 +340,1 @@\n+  bool                  _strength_reduction;    \/\/ Are we doing strength reduction to direct call\n@@ -610,0 +611,2 @@\n+  void          set_strength_reduction(bool z)  { _strength_reduction = z; }\n+  bool              strength_reduction() const  { return _strength_reduction; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciMethod.hpp\"\n@@ -2042,26 +2043,30 @@\n-      ideal.if_then(ret, BoolTest::eq, ideal.makecon(TypePtr::NULL_PTR)); {\n-        \/\/ Return value is null\n-        ideal.set(res, makecon(TypePtr::NULL_PTR));\n-      } ideal.else_(); {\n-        \/\/ Return value is non-null\n-        sync_kit(ideal);\n-\n-        \/\/ Change return type of call to scalarized return\n-        const TypeFunc* tf = call->_tf;\n-        const TypeTuple* domain = OptoRuntime::store_inline_type_fields_Type()->domain_cc();\n-        const TypeFunc* new_tf = TypeFunc::make(tf->domain_sig(), tf->domain_cc(), tf->range_sig(), domain);\n-        call->_tf = new_tf;\n-        _gvn.set_type(call, call->Value(&_gvn));\n-        _gvn.set_type(ret, ret->Value(&_gvn));\n-\n-        Node* store_to_buf_call = make_runtime_call(RC_NO_LEAF | RC_NO_IO,\n-                                                    OptoRuntime::store_inline_type_fields_Type(),\n-                                                    StubRoutines::store_inline_type_fields_to_buf(),\n-                                                    nullptr, TypePtr::BOTTOM, ret);\n-\n-        \/\/ We don't know how many values are returned. This assumes the\n-        \/\/ worst case, that all available registers are used.\n-        for (uint i = TypeFunc::Parms+1; i < domain->cnt(); i++) {\n-          if (domain->field_at(i) == Type::HALF) {\n-            store_to_buf_call->init_req(i, top());\n-            continue;\n+      \/\/ Change return type of call to scalarized return\n+      const TypeFunc* tf = call->_tf;\n+      const TypeTuple* domain = OptoRuntime::store_inline_type_fields_Type()->domain_cc();\n+      const TypeFunc* new_tf = TypeFunc::make(tf->domain_sig(), tf->domain_cc(), tf->range_sig(), domain);\n+      call->_tf = new_tf;\n+      _gvn.set_type(call, call->Value(&_gvn));\n+      _gvn.set_type(ret, ret->Value(&_gvn));\n+      \/\/ Don't add store to buffer call if we are strength reducing\n+      if (!C->strength_reduction()) {\n+        ideal.if_then(ret, BoolTest::eq, ideal.makecon(TypePtr::NULL_PTR)); {\n+          \/\/ Return value is null\n+          ideal.set(res, makecon(TypePtr::NULL_PTR));\n+        } ideal.else_(); {\n+          \/\/ Return value is non-null\n+          sync_kit(ideal);\n+\n+          Node* store_to_buf_call = make_runtime_call(RC_NO_LEAF | RC_NO_IO,\n+                                                      OptoRuntime::store_inline_type_fields_Type(),\n+                                                      StubRoutines::store_inline_type_fields_to_buf(),\n+                                                      nullptr, TypePtr::BOTTOM, ret);\n+\n+          \/\/ We don't know how many values are returned. This assumes the\n+          \/\/ worst case, that all available registers are used.\n+          for (uint i = TypeFunc::Parms+1; i < domain->cnt(); i++) {\n+            if (domain->field_at(i) == Type::HALF) {\n+              store_to_buf_call->init_req(i, top());\n+              continue;\n+            }\n+            Node* proj =_gvn.transform(new ProjNode(call, i));\n+            store_to_buf_call->init_req(i, proj);\n@@ -2069,4 +2074,1 @@\n-          Node* proj =_gvn.transform(new ProjNode(call, i));\n-          store_to_buf_call->init_req(i, proj);\n-        }\n-        make_slow_call_ex(store_to_buf_call, env()->Throwable_klass(), false);\n+          make_slow_call_ex(store_to_buf_call, env()->Throwable_klass(), false);\n@@ -2074,3 +2076,3 @@\n-        Node* buf = _gvn.transform(new ProjNode(store_to_buf_call, TypeFunc::Parms));\n-        const Type* buf_type = TypeOopPtr::make_from_klass(t->as_klass())->join_speculative(TypePtr::NOTNULL);\n-        buf = _gvn.transform(new CheckCastPPNode(control(), buf, buf_type));\n+          Node* buf = _gvn.transform(new ProjNode(store_to_buf_call, TypeFunc::Parms));\n+          const Type* buf_type = TypeOopPtr::make_from_klass(t->as_klass())->join_speculative(TypePtr::NOTNULL);\n+          buf = _gvn.transform(new CheckCastPPNode(control(), buf, buf_type));\n@@ -2078,3 +2080,9 @@\n-        ideal.set(res, buf);\n-        ideal.sync_kit(this);\n-      } ideal.end_if();\n+          ideal.set(res, buf);\n+          ideal.sync_kit(this);\n+        } ideal.end_if();\n+      } else {\n+        for (uint i = TypeFunc::Parms+1; i < domain->cnt(); i++) {\n+          Node* proj =_gvn.transform(new ProjNode(call, i));\n+        }\n+        ideal.set(res, ret);\n+      }\n@@ -2221,1 +2229,2 @@\n-    assert(callprojs->nb_resproj == 1 || (call->tf()->returns_inline_type_as_fields() && stopped()),\n+    assert(callprojs->nb_resproj == 1 || (call->tf()->returns_inline_type_as_fields() && stopped()) ||\n+           (C->strength_reduction() && InlineTypeReturnedAsFields && !call->as_CallJava()->method()->return_type()->is_loaded()),\n@@ -2223,1 +2232,10 @@\n-    C->gvn_replace_by(callprojs->resproj[0], result);\n+    \/\/ If we are doing strength reduction and the return type is not loaded we\n+    \/\/ need to rewire all projections since store_inline_type_fields_to_buf is already present\n+    if (C->strength_reduction() && InlineTypeReturnedAsFields && !call->as_CallJava()->method()->return_type()->is_loaded()) {\n+      const TypeTuple* domain = OptoRuntime::store_inline_type_fields_Type()->domain_cc();\n+      for (uint i = TypeFunc::Parms; i < domain->cnt(); i++) {\n+        C->gvn_replace_by(callprojs->resproj[0], final_state->in(i));\n+      }\n+    } else {\n+      C->gvn_replace_by(callprojs->resproj[0], result);\n+    }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":56,"deletions":38,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-runtime\/exceptionMsgs\/ArrayIndexOutOfBoundsException\/ArrayIndexOutOfBoundsExceptionTest.java#id1 8369045 macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList-enable-preview.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,4 +32,0 @@\n-valhalla\/valuetypes\/ObjectMethodsViaCondy.java                  8369045 macosx-all\n-valhalla\/valuetypes\/ObjectNewInstance.java                      8369045 macosx-all\n-valhalla\/valuetypes\/ProxyTest.java                              8369045 macosx-all\n-valhalla\/valuetypes\/WeakReferenceTest.java                      8369045 macosx-all\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-java\/lang\/StackWalker\/LocalsAndOperands.java#id0                   8369045 macosx-all\n-java\/lang\/StackWalker\/LocalsAndOperands.java#id1                   8369045 macosx-all\n-java\/lang\/StringBuilder\/CompactStringBuilder.java                  8369045 macosx-all\n","filename":"test\/jdk\/ProblemList-enable-preview.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}