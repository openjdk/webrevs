{"files":[{"patch":"@@ -393,2 +393,2 @@\n-    common.boot_jdk_version = \"20\";\n-    common.boot_jdk_build_number = \"36\";\n+    common.boot_jdk_version = \"21\";\n+    common.boot_jdk_build_number = \"35\";\n@@ -429,3 +429,8 @@\n-            dependencies: [\"devkit\", \"gtest\"],\n-            configure_args: concat(common.configure_args_32bit,\n-                \"--with-jvm-variants=minimal,server\", \"--with-zlib=system\"),\n+            dependencies: [\"devkit\", \"gtest\", \"libffi\"],\n+            configure_args: concat(common.configure_args_32bit, [\n+                \"--with-jvm-variants=minimal,server\",\n+                \"--with-zlib=system\",\n+                \"--with-libffi=\" + input.get(\"libffi\", \"home_path\"),\n+                \"--enable-libffi-bundling\",\n+                \"--enable-fallback-linker\"\n+            ])\n@@ -439,1 +444,1 @@\n-                \"--with-macosx-version-max=10.12.00\",\n+                \"--with-macosx-version-max=11.00.00\",\n@@ -948,4 +953,1 @@\n-            labels: \"test\",\n-            environment: {\n-                \"JT_JAVA\": common.boot_jdk_home\n-            }\n+            labels: \"test\"\n@@ -1087,1 +1089,1 @@\n-        macosx: \"Xcode12.4+1.1\",\n+        macosx: \"Xcode14.3.1+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"20 21 22\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"21 22\"\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,3 @@\n-# sun.security.util is required to compile Cache benchmark\n+# sun.security.util is required to compile Cache benchmark.\n+# jmh uses annotation processors to generate the benchmark jar and thus\n+# requires the use of -processor option during benchmark compilation.\n@@ -94,1 +96,1 @@\n-    DISABLED_WARNINGS := this-escape processing rawtypes unchecked cast serial preview deprecation, \\\n+    DISABLED_WARNINGS := restricted this-escape processing rawtypes unchecked cast serial preview deprecation, \\\n@@ -110,0 +112,1 @@\n+        --add-exports java.base\/jdk.internal.foreign=ALL-UNNAMED \\\n@@ -111,1 +114,2 @@\n-        --enable-preview, \\\n+        --enable-preview \\\n+        -processor org.openjdk.jmh.generators.BenchmarkProcessor, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -16489,1 +16489,1 @@\n-instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)\n+instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -16492,1 +16492,1 @@\n-  effect(TEMP tmp, TEMP tmp2);\n+  effect(TEMP tmp, TEMP tmp2, TEMP tmp3);\n@@ -16500,1 +16500,1 @@\n-    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -439,1 +439,1 @@\n-      __ unlock_object(r5, r4, r0, *stub->entry());\n+      __ unlock_object(r5, r4, r0, r6, *stub->entry());\n@@ -2754,0 +2754,1 @@\n+  Register temp = op->scratch_opr()->as_register();\n@@ -2763,1 +2764,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, temp, *op->stub()->entry());\n@@ -2770,1 +2771,1 @@\n-    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n+    __ unlock_object(hdr, obj, lock, temp, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -324,5 +324,1 @@\n-  \/\/ Need a scratch register for inline type\n-  LIR_Opr scratch = LIR_OprFact::illegalOpr;\n-  if (EnableValhalla && x->maybe_inlinetype()) {\n-    scratch = new_register(T_INT);\n-  }\n+  LIR_Opr scratch = new_register(T_INT);\n@@ -344,1 +340,1 @@\n-                        x->monitor_no(), info_for_exception, info, throw_imse_stub);\n+                x->monitor_no(), info_for_exception, info, throw_imse_stub);\n@@ -356,0 +352,1 @@\n+  LIR_Opr scratch = new_register(T_INT);\n@@ -357,1 +354,1 @@\n-  monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x->monitor_no());\n+  monitor_exit(obj_temp, lock, syncTempOpr(), scratch, x->monitor_no());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n@@ -68,1 +68,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr);\n+  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n@@ -88,1 +88,1 @@\n-    lightweight_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_lock(obj, hdr, temp, rscratch2, slow_case);\n@@ -136,1 +136,1 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n@@ -139,1 +139,1 @@\n-  assert(hdr != obj && hdr != disp_hdr && obj != disp_hdr, \"registers must be different\");\n+  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n@@ -160,1 +160,1 @@\n-    lightweight_unlock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_unlock(obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                                  Register tmp2Reg) {\n+                                  Register tmp2Reg, Register tmp3Reg) {\n@@ -135,1 +135,1 @@\n-    lightweight_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n+    lightweight_lock(oop, disp_hdr, tmp, tmp3Reg, no_count);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  void fast_lock(Register object, Register box, Register tmp, Register tmp2);\n+  void fast_lock(Register object, Register box, Register tmp, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb);\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null = false);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb) {\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null) {\n@@ -108,1 +108,1 @@\n-  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  assert(_cb != nullptr || allow_cb_null, \"pc: \" INTPTR_FORMAT, p2i(pc));\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -837,1 +837,1 @@\n-\/\/      c_rarg0, c_rarg1, c_rarg2, c_rarg3, .. (param regs)\n+\/\/      c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, .. (param regs)\n@@ -852,0 +852,2 @@\n+    const Register tmp2 = c_rarg4;\n+    const Register tmp3 = c_rarg5;\n@@ -872,1 +874,1 @@\n-      lightweight_lock(obj_reg, tmp, rscratch1, rscratch2, slow_case);\n+      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -974,0 +976,1 @@\n+    const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n@@ -1007,1 +1010,1 @@\n-      lightweight_unlock(obj_reg, header_reg, swap_reg, rscratch1, slow_case);\n+      lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3003,0 +3003,4 @@\n+#ifdef ASSERT\n+    \/\/ Poison rscratch1 which is written on !UseLSE branch\n+    mov(rscratch1, 0x1f1f1f1f1f1f1f1f);\n+#endif\n@@ -7133,1 +7137,1 @@\n-  assert_different_registers(obj, hdr, t1, t2);\n+  assert_different_registers(obj, hdr, t1, t2, rscratch1);\n@@ -7145,0 +7149,1 @@\n+  \/\/ Clobbers rscratch1 when UseLSE is false\n@@ -7165,1 +7170,1 @@\n-  assert_different_registers(obj, hdr, t1, t2);\n+  assert_different_registers(obj, hdr, t1, t2, rscratch1);\n@@ -7205,0 +7210,1 @@\n+  \/\/ Clobbers rscratch1 when UseLSE is false\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2052,0 +2052,1 @@\n+  const Register lock_tmp = r14;  \/\/ Temporary used by lightweight_lock\/unlock\n@@ -2109,1 +2110,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, tmp, rscratch1, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -2251,1 +2252,1 @@\n-      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, rscratch1, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2218,1 +2218,3 @@\n-  std(R15_esp, _ijava_state_neg(esp), scratch);\n+  subf(R0, scratch, R15_esp);\n+  sradi(R0, R0, Interpreter::logStackElementSize);\n+  std(R0, _ijava_state_neg(esp), scratch);\n@@ -2248,0 +2250,1 @@\n+    \/\/ Derelativize esp\n@@ -2249,0 +2252,2 @@\n+    sldi(R15_esp, R15_esp, Interpreter::logStackElementSize);\n+    add(R15_esp, R15_esp, scratch);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -352,1 +353,1 @@\n-  \/\/ Get index out of bytecode pointer, get_cache_entry_pointer_at_bcp\n+  \/\/ Get index out of bytecode pointer.\n@@ -354,1 +355,2 @@\n-  \/\/ Get address of invokedynamic array\n+\n+  \/\/ Get the address of the ResolvedIndyEntry array\n@@ -357,2 +359,10 @@\n-  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n-  z_sllg(index, index, exact_log2(sizeof(ResolvedIndyEntry)));\n+\n+  \/\/ Scale the index to form a byte offset into the ResolvedIndyEntry array\n+  size_t entry_size = sizeof(ResolvedIndyEntry);\n+  if (is_power_of_2(entry_size)) {\n+    z_sllg(index, index, exact_log2(entry_size));\n+  } else {\n+    z_mghi(index, entry_size);\n+  }\n+\n+  \/\/ Calculate the final field address.\n@@ -362,0 +372,20 @@\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get field index out of bytecode pointer.\n+  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n+\n+  \/\/ Get the address of the ResolvedFieldEntry array.\n+  get_constant_pool_cache(cache);\n+  z_lg(cache, Address(cache, in_bytes(ConstantPoolCache::field_entries_offset())));\n+\n+  \/\/ Scale the index to form a byte offset into the ResolvedFieldEntry array\n+  size_t entry_size = sizeof(ResolvedFieldEntry);\n+  if (is_power_of_2(entry_size)) {\n+    z_sllg(index, index, exact_log2(entry_size));\n+  } else {\n+    z_mghi(index, entry_size);\n+  }\n+\n+  \/\/ Calculate the final field address.\n+  z_la(cache, Array<ResolvedFieldEntry>::base_offset_in_bytes(), index, cache);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    entry_frame_after_call_words                     =  60,\n+    entry_frame_after_call_words                     =  28,\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,4 +112,2 @@\n-\/\/ -60 [ argument word 1      ]\n-\/\/ -59 [ saved xmm31          ] <--- rsp after_call\n-\/\/     [ saved xmm16-xmm30    ] (EVEX enabled, else the space is blank)\n-\/\/ -27 [ saved xmm15          ]\n+\/\/ -28 [ argument word 1      ]\n+\/\/ -27 [ saved xmm15          ] <--- rsp after_call\n@@ -143,1 +141,1 @@\n-  xmm_save_last      = 31, \/\/ to xmm31\n+  xmm_save_last      = 15, \/\/ to xmm15\n@@ -243,11 +241,2 @@\n-  if (UseAVX > 2) {\n-    last_reg = 31;\n-  }\n-  if (VM_Version::supports_evex()) {\n-    for (int i = xmm_save_first; i <= last_reg; i++) {\n-      __ vextractf32x4(xmm_save(i), as_XMMRegister(i), 0);\n-    }\n-  } else {\n-    for (int i = xmm_save_first; i <= last_reg; i++) {\n-      __ movdqu(xmm_save(i), as_XMMRegister(i));\n-    }\n+  for (int i = xmm_save_first; i <= last_reg; i++) {\n+    __ movdqu(xmm_save(i), as_XMMRegister(i));\n@@ -378,8 +367,2 @@\n-  if (VM_Version::supports_evex()) {\n-    for (int i = xmm_save_first; i <= last_reg; i++) {\n-      __ vinsertf32x4(as_XMMRegister(i), as_XMMRegister(i), xmm_save(i), 0);\n-    }\n-  } else {\n-    for (int i = xmm_save_first; i <= last_reg; i++) {\n-      __ movdqu(as_XMMRegister(i), xmm_save(i));\n-    }\n+  for (int i = xmm_save_first; i <= last_reg; i++) {\n+    __ movdqu(as_XMMRegister(i), xmm_save(i));\n@@ -4364,0 +4347,20 @@\n+  \/\/ Load x86_64_sort library on supported hardware to enable avx512 sort and partition intrinsics\n+  if (VM_Version::is_intel() && VM_Version::supports_avx512dq()) {\n+    void *libsimdsort = nullptr;\n+    char ebuf_[1024];\n+    char dll_name_simd_sort[JVM_MAXPATHLEN];\n+    if (os::dll_locate_lib(dll_name_simd_sort, sizeof(dll_name_simd_sort), Arguments::get_dll_dir(), \"simdsort\")) {\n+      libsimdsort = os::dll_load(dll_name_simd_sort, ebuf_, sizeof ebuf_);\n+    }\n+    \/\/ Get addresses for avx512 sort and partition routines\n+    if (libsimdsort != nullptr) {\n+      log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"simdsort\" JNI_LIB_SUFFIX, p2i(libsimdsort));\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_sort\");\n+      StubRoutines::_array_sort = (address)os::dll_lookup(libsimdsort, ebuf_);\n+\n+      snprintf(ebuf_, sizeof(ebuf_), \"avx512_partition\");\n+      StubRoutines::_array_partition = (address)os::dll_lookup(libsimdsort, ebuf_);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-\/\/ Windows ABI: XMM6-XMM31 preserved across function calls\n+\/\/ Windows ABI: XMM6-XMM15 preserved across function calls\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compilerDirectives.hpp\"\n@@ -37,0 +39,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -445,0 +448,3 @@\n+\n+  CompilationMemoryStatisticMark cmsm(env()->task()->directive());\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -320,0 +321,6 @@\n+template <typename T>\n+void update_buffered_object_field(address buffered_obj, int field_offset, T value) {\n+  T* field_addr = cast_to_oop(buffered_obj)->field_addr<T>(field_offset);\n+  *field_addr = value;\n+}\n+\n@@ -345,0 +352,14 @@\n+  \/\/ These native pointers will be restored explicitly at run time.\n+  if (java_lang_Module::is_instance(src_obj)) {\n+    update_buffered_object_field<ModuleEntry*>(to, java_lang_Module::module_entry_offset(), nullptr);\n+  } else if (java_lang_ClassLoader::is_instance(src_obj)) {\n+#ifdef ASSERT\n+    \/\/ We only archive these loaders\n+    if (src_obj != SystemDictionary::java_platform_loader() &&\n+        src_obj != SystemDictionary::java_system_loader()) {\n+      assert(src_obj->klass()->name()->equals(\"jdk\/internal\/loader\/ClassLoaders$BootClassLoader\"), \"must be\");\n+    }\n+#endif\n+    update_buffered_object_field<ClassLoaderData*>(to, java_lang_ClassLoader::loader_data_offset(), nullptr);\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -668,7 +668,0 @@\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  \/\/ Restore the java loaders that were cleared at dump time\n-  if (use_full_module_graph()) {\n-    HeapShared::restore_loader_data();\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+  assert(java_lang_Class::as_Klass(get_oop()) != nullptr, \"klass is null\");\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -847,3 +847,1 @@\n-    ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n-    MethodData* method_data = MethodData::allocate(loader_data, methodHandle(THREAD, method), CHECK);\n-    method->set_method_data(method_data);\n+    method->build_profiling_method_data(methodHandle(THREAD, method), CHECK);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4636,0 +4636,1 @@\n+        return;\n@@ -4643,0 +4644,1 @@\n+        return;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = nullptr;\n@@ -1380,1 +1379,0 @@\n-    NEWPERFTICKCOUNTER(_perf_sys_class_lookup_time, SUN_CLS, \"lookupSysClassTime\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -868,0 +868,3 @@\n+    \/\/ CDS\n+    static int module_entry_offset() { return _module_entry_offset; }\n+\n@@ -1483,0 +1486,1 @@\n+  \/\/ Support for CDS\n@@ -1484,0 +1488,1 @@\n+  static int loader_data_offset() { return  _loader_data_offset; }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -350,0 +350,8 @@\n+  do_intrinsic(_arraySort,                java_util_DualPivotQuicksort, arraySort_name, arraySort_signature,     F_S)   \\\n+   do_name(     arraySort_name,                                  \"sort\")                                                \\\n+   do_signature(arraySort_signature, \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIILjava\/util\/DualPivotQuicksort$SortOperation;)V\") \\\n+                                                                                                                        \\\n+  do_intrinsic(_arrayPartition,           java_util_DualPivotQuicksort, arrayPartition_name, arrayPartition_signature, F_S) \\\n+   do_name(     arrayPartition_name,                             \"partition\")                                           \\\n+   do_signature(arrayPartition_signature, \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIIIILjava\/util\/DualPivotQuicksort$PartitionOperation;)[I\") \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+  template(java_util_DualPivotQuicksort,              \"java\/util\/DualPivotQuicksort\")             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -446,1 +446,2 @@\n-                                           bool caller_must_gc_arguments)\n+                                           bool caller_must_gc_arguments,\n+                                           bool alloc_fail_is_fatal)\n@@ -454,0 +455,6 @@\n+    if (stub == nullptr) {\n+      if (!alloc_fail_is_fatal) {\n+        return nullptr;\n+      }\n+      fatal(\"Initial size of CodeCache is too small\");\n+    }\n@@ -463,3 +470,1 @@\n-  void* p = CodeCache::allocate(size, CodeBlobType::NonNMethod);\n-  if (!p) fatal(\"Initial size of CodeCache is too small\");\n-  return p;\n+  return CodeCache::allocate(size, CodeBlobType::NonNMethod);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -534,1 +534,2 @@\n-    bool        caller_must_gc_arguments\n+    bool        caller_must_gc_arguments,\n+    bool        alloc_fail_is_fatal=true\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -565,2 +565,2 @@\n-  if (cb != nullptr && cb->is_adapter_blob()) {\n-    return true;\n+  if (cb == nullptr) {\n+    return false;\n@@ -568,4 +568,4 @@\n-  \/\/ itable stubs also use CompiledICHolder\n-  if (cb != nullptr && cb->is_vtable_blob()) {\n-    VtableStub* s = VtableStubs::entry_point(entry);\n-    return (s != nullptr) && s->is_itable_stub();\n+  if (cb->is_adapter_blob()) {\n+    return true;\n+  } else if (cb->is_vtable_blob()) {\n+    return VtableStubs::is_icholder_entry(entry);\n@@ -573,1 +573,0 @@\n-\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1711,1 +1711,1 @@\n-  uint8_t state = RawAccess<MO_RELAXED>::load(&_is_unloading_state);\n+  uint8_t state = Atomic::load(&_is_unloading_state);\n@@ -1747,1 +1747,1 @@\n-  RawAccess<MO_RELAXED>::store(&_is_unloading_state, state);\n+  Atomic::store(&_is_unloading_state, state);\n@@ -2160,45 +2160,0 @@\n-\n-void nmethod::check_all_dependencies(DepChange& changes) {\n-  \/\/ Checked dependencies are allocated into this ResourceMark\n-  ResourceMark rm;\n-\n-  \/\/ Turn off dependency tracing while actually testing dependencies.\n-  NOT_PRODUCT( FlagSetting fs(Dependencies::_verify_in_progress, true));\n-\n-  typedef ResourceHashtable<DependencySignature, int, 11027,\n-                            AnyObj::RESOURCE_AREA, mtInternal,\n-                            &DependencySignature::hash,\n-                            &DependencySignature::equals> DepTable;\n-\n-  DepTable* table = new DepTable();\n-\n-  \/\/ Iterate over live nmethods and check dependencies of all nmethods that are not\n-  \/\/ marked for deoptimization. A particular dependency is only checked once.\n-  NMethodIterator iter(NMethodIterator::only_not_unloading);\n-  while(iter.next()) {\n-    nmethod* nm = iter.method();\n-    \/\/ Only notify for live nmethods\n-    if (!nm->is_marked_for_deoptimization()) {\n-      for (Dependencies::DepStream deps(nm); deps.next(); ) {\n-        \/\/ Construct abstraction of a dependency.\n-        DependencySignature* current_sig = new DependencySignature(deps);\n-\n-        \/\/ Determine if dependency is already checked. table->put(...) returns\n-        \/\/ 'true' if the dependency is added (i.e., was not in the hashtable).\n-        if (table->put(*current_sig, 1)) {\n-          if (deps.check_dependency() != nullptr) {\n-            \/\/ Dependency checking failed. Print out information about the failed\n-            \/\/ dependency and finally fail with an assert. We can fail here, since\n-            \/\/ dependency checking is never done in a product build.\n-            tty->print_cr(\"Failed dependency:\");\n-            changes.print();\n-            nm->print();\n-            nm->print_dependencies_on(tty);\n-            assert(false, \"Should have been marked for deoptimization\");\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":47,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -687,4 +687,0 @@\n-  \/\/ tells if any of this method's dependencies have been invalidated\n-  \/\/ (this is expensive!)\n-  static void check_all_dependencies(DepChange& changes);\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,2 +98,1 @@\n-VtableStub* VtableStubs::_table[VtableStubs::N];\n-int VtableStubs::_number_of_vtable_stubs = 0;\n+VtableStub* volatile VtableStubs::_table[VtableStubs::N];\n@@ -129,0 +128,2 @@\n+  assert(VtableStub::_receiver_location == VMRegImpl::Bad(), \"initialized multiple times?\");\n+\n@@ -132,3 +133,1 @@\n-    assert(_number_of_vtable_stubs == 0, \"potential performance bug: VtableStubs initialized more than once\");\n-    assert(is_power_of_2(int(N)), \"N must be a power of 2\");\n-      _table[i] = nullptr;\n+      Atomic::store(&_table[i], (VtableStub*)nullptr);\n@@ -266,1 +265,1 @@\n-  VtableStub* s = _table[hash];\n+  VtableStub* s = Atomic::load(&_table[hash]);\n@@ -276,4 +275,4 @@\n-  \/\/ enter s at the beginning of the corresponding list\n-  s->set_next(_table[h]);\n-  _table[h] = s;\n-  _number_of_vtable_stubs++;\n+  \/\/ Insert s at the beginning of the corresponding list.\n+  s->set_next(Atomic::load(&_table[h]));\n+  \/\/ Make sure that concurrent readers not taking the mutex observe the writing of \"next\".\n+  Atomic::release_store(&_table[h], s);\n@@ -287,1 +286,1 @@\n-  for (s = _table[hash]; s != nullptr && s != stub; s = s->next()) {}\n+  for (s = Atomic::load(&_table[hash]); s != nullptr && s != stub; s = s->next()) {}\n@@ -291,0 +290,7 @@\n+bool VtableStubs::is_icholder_entry(address pc) {\n+  assert(contains(pc), \"must contain all vtable blobs\");\n+  VtableStub* stub = (VtableStub*)(pc - VtableStub::entry_offset());\n+  \/\/ itable stubs use CompiledICHolder.\n+  return stub->is_itable_stub();\n+}\n+\n@@ -299,4 +305,1 @@\n-  \/\/ Note: No locking needed since any change to the data structure\n-  \/\/       happens with an atomic store into it (we don't care about\n-  \/\/       consistency with the _number_of_vtable_stubs counter).\n-    for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n+    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n@@ -315,4 +318,3 @@\n-    for (int i = 0; i < N; i++) {\n-        for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n-            f(s);\n-        }\n+  for (int i = 0; i < N; i++) {\n+    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n+      f(s);\n@@ -320,0 +322,1 @@\n+  }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+  static_assert(is_power_of_2((int)N), \"N must be a power of 2\");\n+\n@@ -85,2 +87,1 @@\n-  static VtableStub* _table[N];                  \/\/ table of existing stubs\n-  static int         _number_of_vtable_stubs;    \/\/ number of stubs created so far (for statistics)\n+  static VtableStub* volatile _table[N];                  \/\/ table of existing stubs\n@@ -109,0 +110,1 @@\n+  static bool        is_icholder_entry(address pc);                  \/\/ is the blob containing pc (which must be a vtable blob) an icholder?\n@@ -111,1 +113,0 @@\n-  static int         number_of_vtable_stubs() { return _number_of_vtable_stubs; }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -653,0 +654,4 @@\n+  if (CompilerOracle::should_collect_memstat()) {\n+    CompilationMemoryStatistic::initialize();\n+  }\n+\n@@ -1698,1 +1703,1 @@\n-  if (comp->is_jvmci() && !task->should_wait_for_compilation()) {\n+  if (!UseJVMCINativeLibrary && comp->is_jvmci() && !task->should_wait_for_compilation()) {\n@@ -1700,0 +1705,3 @@\n+    \/\/ Note that libjvmci should not pre-emptively unblock\n+    \/\/ a thread waiting for a compilation as it does not call\n+    \/\/ Java code and so is not deadlock prone like jarjvmci.\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-    return BarrierSetC2::load_at_resolved(access, val_type);;\n+    return BarrierSetC2::load_at_resolved(access, val_type);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+      if (C->failing()) return false;\n@@ -390,0 +391,6 @@\n+        \"array_partition_stub\",\n+        { { TypeFunc::Parms, ShenandoahStore }, { TypeFunc::Parms+4, ShenandoahStore },   { -1, ShenandoahNone },\n+          { -1, ShenandoahNone },                { -1, ShenandoahNone },                  { -1, ShenandoahNone } },\n+        \"arraysort_stub\",\n+        { { TypeFunc::Parms, ShenandoahStore },  { -1, ShenandoahNone },                  { -1, ShenandoahNone },\n+          { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+  static void deallocate(OopMapCacheEntry* const entry);\n+\n@@ -404,0 +406,4 @@\n+void OopMapCacheEntry::deallocate(OopMapCacheEntry* const entry) {\n+  entry->flush();\n+  FREE_C_HEAP_OBJ(entry);\n+}\n@@ -479,2 +485,1 @@\n-      entry->flush();\n-      FREE_C_HEAP_OBJ(entry);\n+      OopMapCacheEntry::deallocate(entry);\n@@ -499,2 +504,1 @@\n-      entry->flush();\n-      FREE_C_HEAP_OBJ(entry);\n+      OopMapCacheEntry::deallocate(entry);\n@@ -547,2 +551,1 @@\n-    tmp->flush();\n-    FREE_C_HEAP_OBJ(tmp);\n+    OopMapCacheEntry::deallocate(tmp);\n@@ -571,1 +574,1 @@\n-    enqueue_for_cleanup(tmp);\n+    OopMapCacheEntry::deallocate(tmp);\n@@ -606,2 +609,1 @@\n-    entry->flush();\n-    FREE_C_HEAP_OBJ(entry);\n+    OopMapCacheEntry::deallocate(entry);\n@@ -620,2 +622,1 @@\n-  tmp->flush();\n-  FREE_C_HEAP_OBJ(tmp);\n+  OopMapCacheEntry::deallocate(tmp);\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -653,0 +654,47 @@\n+JVMCI::CodeInstallResult CodeInstaller::install_runtime_stub(CodeBlob*& cb,\n+                                                             const char* name,\n+                                                             CodeBuffer* buffer,\n+                                                             int stack_slots,\n+                                                             JVMCI_TRAPS) {\n+  if (name == nullptr) {\n+    JVMCI_ERROR_OK(\"stub should have a name\");\n+  }\n+\n+  name = os::strdup(name);\n+  GrowableArray<RuntimeStub*> *stubs_to_free = nullptr;\n+#ifdef ASSERT\n+  const char* val = Arguments::PropertyList_get_value(Arguments::system_properties(), \"test.jvmci.forceRuntimeStubAllocFail\");\n+  if (val != nullptr && strstr(name , val) != 0) {\n+    stubs_to_free = new GrowableArray<RuntimeStub*>();\n+    JVMCI_event_1(\"forcing allocation of %s in code cache to fail\", name);\n+  }\n+#endif\n+\n+  do {\n+    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name,\n+                                       buffer,\n+                                       _offsets.value(CodeOffsets::Frame_Complete),\n+                                       stack_slots,\n+                                       _debug_recorder->_oopmaps,\n+                                       \/* caller_must_gc_arguments *\/ false,\n+                                       \/* alloc_fail_is_fatal *\/ false);\n+    cb = stub;\n+    if (stub == nullptr) {\n+      \/\/ Allocation failed\n+#ifdef ASSERT\n+      if (stubs_to_free != nullptr) {\n+        JVMCI_event_1(\"allocation of %s in code cache failed, freeing %d stubs\", name, stubs_to_free->length());\n+        for (GrowableArrayIterator<RuntimeStub*> iter = stubs_to_free->begin(); iter != stubs_to_free->end(); ++iter) {\n+          RuntimeStub::free(*iter);\n+        }\n+      }\n+#endif\n+      return JVMCI::cache_full;\n+    }\n+    if (stubs_to_free == nullptr) {\n+      return JVMCI::ok;\n+    }\n+    stubs_to_free->append(stub);\n+  } while (true);\n+}\n+\n@@ -710,11 +758,1 @@\n-    if (name == nullptr) {\n-      JVMCI_ERROR_OK(\"stub should have a name\");\n-    }\n-    name = os::strdup(name); \/\/ Note: this leaks. See JDK-8289632\n-    cb = RuntimeStub::new_runtime_stub(name,\n-                                       &buffer,\n-                                       _offsets.value(CodeOffsets::Frame_Complete),\n-                                       stack_slots,\n-                                       _debug_recorder->_oopmaps,\n-                                       false);\n-    result = JVMCI::ok;\n+    return install_runtime_stub(cb, name, &buffer, stack_slots, JVMCI_CHECK_OK);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":49,"deletions":11,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1285,0 +1285,12 @@\n+static MethodData* get_profiling_method_data(const methodHandle& method, TRAPS) {\n+  MethodData* method_data = method->method_data();\n+  if (method_data == nullptr) {\n+    method->build_profiling_method_data(method, CHECK_NULL);\n+    method_data = method->method_data();\n+    if (method_data == nullptr) {\n+      THROW_MSG_NULL(vmSymbols::java_lang_OutOfMemoryError(), \"cannot allocate MethodData\")\n+    }\n+  }\n+  return method_data;\n+}\n+\n@@ -1300,3 +1312,1 @@\n-    ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n-    method_data = MethodData::allocate(loader_data, method, CHECK);\n-    method->set_method_data(method_data);\n+    method_data = get_profiling_method_data(method, CHECK);\n@@ -2429,0 +2439,10 @@\n+C2V_VMENTRY(void, clearOopHandle, (JNIEnv* env, jobject, jlong oop_handle))\n+  if (oop_handle == 0L) {\n+    JVMCI_THROW(NullPointerException);\n+  }\n+  \/\/ Assert before nulling out, for better debugging.\n+  assert(JVMCIRuntime::is_oop_handle(oop_handle), \"precondition\");\n+  oop* oop_ptr = (oop*) oop_handle;\n+  NativeAccess<>::oop_store(oop_ptr, (oop) nullptr);\n+C2V_END\n+\n@@ -2979,6 +2999,1 @@\n-  MethodData* method_data = method->method_data();\n-  if (method_data == nullptr) {\n-    ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n-    method_data = MethodData::allocate(loader_data, method, CHECK_0);\n-    method->set_method_data(method_data);\n-  }\n+  MethodData* method_data = get_profiling_method_data(method, CHECK_0);\n@@ -3258,0 +3273,1 @@\n+  {CC \"clearOopHandle\",                               CC \"(J)V\",                                                                            FN_PTR(clearOopHandle)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+  nonstatic_field(JavaThread,                  _lock_stack,                                   LockStack)                             \\\n@@ -223,0 +224,2 @@\n+  nonstatic_field(LockStack,                   _top,                                          uint32_t)                              \\\n+                                                                                                                                     \\\n@@ -331,0 +334,2 @@\n+  static_field(StubRoutines,                _array_sort,                                      address)                               \\\n+  static_field(StubRoutines,                _array_partition,                                 address)                               \\\n@@ -497,0 +502,1 @@\n+  declare_constant_with_value(\"LockStack::_end_offset\", LockStack::end_offset()) \\\n@@ -686,0 +692,4 @@\n+  declare_constant(LockingMode::LM_MONITOR)                               \\\n+  declare_constant(LockingMode::LM_LEGACY)                                \\\n+  declare_constant(LockingMode::LM_LIGHTWEIGHT)                           \\\n+                                                                          \\\n@@ -733,0 +743,2 @@\n+  declare_constant(ObjectMonitor::ANONYMOUS_OWNER)                        \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  set_method_data(nullptr);\n+  clear_method_data();\n@@ -130,1 +130,1 @@\n-  set_method_data(nullptr);\n+  clear_method_data();\n@@ -1227,1 +1227,1 @@\n-  set_method_data(nullptr);\n+  clear_method_data();\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -315,2 +315,0 @@\n-  void set_method_data(MethodData* data);\n-\n@@ -370,0 +368,4 @@\n+  void clear_method_data() {\n+    _method_data = nullptr;\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,7 +50,0 @@\n-inline void Method::set_method_data(MethodData* data) {\n-  \/\/ The store into method must be released. On platforms without\n-  \/\/ total store order (TSO) the reference may become visible before\n-  \/\/ the initialization of data otherwise.\n-  Atomic::release_store(&_method_data, data);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -137,3 +137,0 @@\n-  template <typename T, class OopClosureType>\n-  inline void oop_oop_iterate_elements_bounded(objArrayOop a, OopClosureType* closure, MemRegion mr);\n-\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -283,2 +283,20 @@\n-      sub->init_req(1, phase->transform(AddNode::make(in1->in(1), in2->in(1), bt)));\n-      sub->init_req(2, phase->transform(AddNode::make(in1->in(2), in2->in(2), bt)));\n+      Node* sub_in1;\n+      PhaseIterGVN* igvn = phase->is_IterGVN();\n+      \/\/ During IGVN, if both inputs of the new AddNode are a tree of SubNodes, this same transformation will be applied\n+      \/\/ to every node of the tree. Calling transform() causes the transformation to be applied recursively, once per\n+      \/\/ tree node whether some subtrees are identical or not. Pushing to the IGVN worklist instead, causes the transform\n+      \/\/ to be applied once per unique subtrees (because all uses of a subtree are updated with the result of the\n+      \/\/ transformation). In case of a large tree, this can make a difference in compilation time.\n+      if (igvn != nullptr) {\n+        sub_in1 = igvn->register_new_node_with_optimizer(AddNode::make(in1->in(1), in2->in(1), bt));\n+      } else {\n+        sub_in1 = phase->transform(AddNode::make(in1->in(1), in2->in(1), bt));\n+      }\n+      Node* sub_in2;\n+      if (igvn != nullptr) {\n+        sub_in2 = igvn->register_new_node_with_optimizer(AddNode::make(in1->in(2), in2->in(2), bt));\n+      } else {\n+        sub_in2 = phase->transform(AddNode::make(in1->in(2), in2->in(2), bt));\n+      }\n+      sub->init_req(1, sub_in1);\n+      sub->init_req(2, sub_in2);\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -344,3 +344,0 @@\n-  product(bool, DoReserveCopyInSuperWord, true,                             \\\n-          \"Create reserve copy of graph in SuperWord.\")                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -58,0 +59,3 @@\n+const char* C2Compiler::retry_no_superword() {\n+  return \"retry without SuperWord\";\n+}\n@@ -109,0 +113,2 @@\n+  CompilationMemoryStatisticMark cmsm(directive);\n+\n@@ -115,0 +121,1 @@\n+  bool do_superword = UseSuperWord;\n@@ -117,0 +124,1 @@\n+    ResourceMark rm;\n@@ -118,1 +126,8 @@\n-    Options options(subsume_loads, do_escape_analysis, do_iterative_escape_analysis, do_reduce_allocation_merges, eliminate_boxing, do_locks_coarsening, install_code);\n+    Options options(subsume_loads,\n+                    do_escape_analysis,\n+                    do_iterative_escape_analysis,\n+                    do_reduce_allocation_merges,\n+                    eliminate_boxing,\n+                    do_locks_coarsening,\n+                    do_superword,\n+                    install_code);\n@@ -153,0 +168,6 @@\n+      if (C.failure_reason_is(retry_no_superword())) {\n+        assert(do_superword, \"must make progress\");\n+        do_superword = false;\n+        env->report_failure(C.failure_reason());\n+        continue;  \/\/ retry\n+      }\n@@ -600,0 +621,2 @@\n+  case vmIntrinsics::_arraySort:\n+  case vmIntrinsics::_arrayPartition:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+  if (C->failing()) return nullptr;\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1898,0 +1898,11 @@\n+\/\/ Returns the BasicType of a given convert node and a type, with special handling to ensure that conversions to\n+\/\/ and from half float will return the SHORT basic type, as that wouldn't be returned typically from TypeInt.\n+static BasicType get_convert_type(Node* convert, const Type* type) {\n+  int convert_op = convert->Opcode();\n+  if (type->isa_int() && (convert_op == Op_ConvHF2F || convert_op == Op_ConvF2HF)) {\n+    return T_SHORT;\n+  }\n+\n+  return type->basic_type();\n+}\n+\n@@ -2691,0 +2702,35 @@\n+  \/\/ Try to convert a Phi with two duplicated convert nodes into a phi of the pre-conversion type and the convert node\n+  \/\/ proceeding the phi, to de-duplicate the convert node and compact the IR.\n+  if (can_reshape && progress == nullptr) {\n+    ConvertNode* convert = in(1)->isa_Convert();\n+    if (convert != nullptr) {\n+      int conv_op = convert->Opcode();\n+      bool ok = true;\n+\n+      \/\/ Check the rest of the inputs\n+      for (uint i = 2; i < req(); i++) {\n+        \/\/ Make sure that all inputs are of the same type of convert node\n+        if (in(i)->Opcode() != conv_op) {\n+          ok = false;\n+          break;\n+        }\n+      }\n+\n+      if (ok) {\n+        \/\/ Find the local bottom type to set as the type of the phi\n+        const Type* source_type = Type::get_const_basic_type(convert->in_type()->basic_type());\n+        const Type* dest_type = convert->bottom_type();\n+\n+        PhiNode* newphi = new PhiNode(in(0), source_type, nullptr);\n+        \/\/ Set inputs to the new phi be the inputs of the convert\n+        for (uint i = 1; i < req(); i++) {\n+          newphi->init_req(i, in(i)->in(1));\n+        }\n+\n+        phase->is_IterGVN()->register_new_node_with_optimizer(newphi, this);\n+\n+        return ConvertNode::create_convert(get_convert_type(convert, source_type), get_convert_type(convert, dest_type), newphi);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -664,2 +664,2 @@\n-                  _node_arena_one(mtCompiler),\n-                  _node_arena_two(mtCompiler),\n+                  _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n+                  _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n@@ -2734,0 +2734,2 @@\n+  if (failing())  return;\n+\n@@ -2744,0 +2746,2 @@\n+    if (failing())  return;\n+\n@@ -2759,0 +2763,2 @@\n+  if (failing())  return;\n+\n@@ -2763,0 +2769,2 @@\n+  if (failing())  return;\n+\n@@ -2768,1 +2776,1 @@\n-\n+    if (failing())  return;\n@@ -2793,0 +2801,2 @@\n+  if (failing())  return;\n+\n@@ -2905,0 +2915,2 @@\n+  if (failing())  return;\n+\n@@ -4531,2 +4543,0 @@\n-        DEBUG_ONLY( n->dump_bfs(1, 0, \"-\"); );\n-        assert(false, \"malformed control flow\");\n@@ -5458,0 +5468,1 @@\n+      if (failing())  return;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+  const bool _do_superword;          \/\/ Do SuperWord\n@@ -187,1 +188,2 @@\n-  Options(bool subsume_loads, bool do_escape_analysis,\n+  Options(bool subsume_loads,\n+          bool do_escape_analysis,\n@@ -190,1 +192,3 @@\n-          bool eliminate_boxing, bool do_locks_coarsening,\n+          bool eliminate_boxing,\n+          bool do_locks_coarsening,\n+          bool do_superword,\n@@ -198,0 +202,1 @@\n+          _do_superword(do_superword),\n@@ -209,0 +214,1 @@\n+       \/* do_superword = *\/ true,\n@@ -588,0 +594,1 @@\n+  bool              do_superword() const        { return _options._do_superword; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -99,0 +99,49 @@\n+uint ConvertNode::ideal_reg() const {\n+  return _type->ideal_reg();\n+}\n+\n+Node* ConvertNode::create_convert(BasicType source, BasicType target, Node* input) {\n+  if (source == T_INT) {\n+    if (target == T_LONG) {\n+      return new ConvI2LNode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvI2FNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvI2DNode(input);\n+    }\n+  } else if (source == T_LONG) {\n+    if (target == T_INT) {\n+      return new ConvL2INode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvL2FNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvL2DNode(input);\n+    }\n+  } else if (source == T_FLOAT) {\n+    if (target == T_INT) {\n+      return new ConvF2INode(input);\n+    } else if (target == T_LONG) {\n+      return new ConvF2LNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvF2DNode(input);\n+    } else if (target == T_SHORT) {\n+      return new ConvF2HFNode(input);\n+    }\n+  } else if (source == T_DOUBLE) {\n+    if (target == T_INT) {\n+      return new ConvD2INode(input);\n+    } else if (target == T_LONG) {\n+      return new ConvD2LNode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvD2FNode(input);\n+    }\n+  } else if (source == T_SHORT) {\n+    if (target == T_FLOAT) {\n+      return new ConvHF2FNode(input);\n+    }\n+  }\n+\n+  assert(false, \"Couldn't create conversion for type %s to %s\", type2name(source), type2name(target));\n+  return nullptr;\n+}\n+\n@@ -203,2 +252,3 @@\n-  if (t == Type::FLOAT) return TypeInt::SHORT;\n-  if (StubRoutines::f2hf_adr() == nullptr) return bottom_type();\n+  if (t == Type::FLOAT || StubRoutines::f2hf_adr() == nullptr) {\n+    return TypeInt::SHORT;\n+  }\n@@ -273,2 +323,3 @@\n-  if (t == TypeInt::SHORT) return Type::FLOAT;\n-  if (StubRoutines::hf2f_adr() == nullptr) return bottom_type();\n+  if (t == TypeInt::SHORT || StubRoutines::hf2f_adr() == nullptr) {\n+    return Type::FLOAT;\n+  }\n@@ -280,1 +331,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n@@ -290,1 +341,1 @@\n-  return bottom_type();\n+  return Type::DOUBLE;\n@@ -300,1 +351,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n@@ -720,1 +771,1 @@\n-  return bottom_type();\n+  return Type::DOUBLE;\n@@ -730,1 +781,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":60,"deletions":9,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1613,0 +1613,2 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"arraysort_stub\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"array_partition_stub\") == 0 ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,2 @@\n-    assert(!has_exceptions(), \"user must call transfer_exceptions_into_jvms\");\n+    assert(failing() || !has_exceptions(),\n+           \"unless compilation failed, user must call transfer_exceptions_into_jvms\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -297,0 +297,3 @@\n+  case vmIntrinsics::_arraySort:                return inline_array_sort();\n+  case vmIntrinsics::_arrayPartition:           return inline_array_partition();\n+\n@@ -5736,0 +5739,95 @@\n+\/\/------------------------------inline_array_partition-----------------------\n+bool LibraryCallKit::inline_array_partition() {\n+\n+  const char *stubName = \"array_partition_stub\";\n+\n+  Node* elementType     = null_check(argument(0));\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2);\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+  Node* indexPivot1     = argument(6);\n+  Node* indexPivot2     = argument(7);\n+\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType bt = elem_type->basic_type();\n+  address stubAddr = nullptr;\n+  stubAddr = StubRoutines::select_array_partition_function();\n+  \/\/ stub not loaded\n+  if (stubAddr == nullptr) {\n+    return false;\n+  }\n+  \/\/ get the address of the array\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+    return false; \/\/ failed input validation\n+  }\n+  Node* obj_adr = make_unsafe_address(obj, offset);\n+\n+  \/\/ create the pivotIndices array of type int and size = 2\n+  Node* size = intcon(2);\n+  Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n+  Node* pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n+  AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n+  guarantee(alloc != nullptr, \"created above\");\n+  Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n+\n+  \/\/ pass the basic type enum to the stub\n+  Node* elemType = intcon(bt);\n+\n+  \/\/ Call the stub\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    obj_adr, elemType, fromIndex, toIndex, pivotIndices_adr,\n+                    indexPivot1, indexPivot2);\n+\n+  if (!stopped()) {\n+    set_result(pivotIndices);\n+  }\n+\n+  return true;\n+}\n+\n+\n+\/\/------------------------------inline_array_sort-----------------------\n+bool LibraryCallKit::inline_array_sort() {\n+\n+  const char *stubName;\n+  stubName = \"arraysort_stub\";\n+\n+  Node* elementType     = null_check(argument(0));\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2);\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType bt = elem_type->basic_type();\n+  address stubAddr = nullptr;\n+  stubAddr = StubRoutines::select_arraysort_function();\n+  \/\/stub not loaded\n+  if (stubAddr == nullptr) {\n+    return false;\n+  }\n+\n+  \/\/ get address of the array\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+    return false; \/\/ failed input validation\n+  }\n+  Node* obj_adr = make_unsafe_address(obj, offset);\n+\n+  \/\/ pass the basic type enum to the stub\n+  Node* elemType = intcon(bt);\n+\n+  \/\/ Call the stub.\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_sort_Type(),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    obj_adr, elemType, fromIndex, toIndex);\n+\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -304,1 +304,2 @@\n-\n+  bool inline_array_sort();\n+  bool inline_array_partition();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -359,146 +359,0 @@\n-LoopNode* PhaseIdealLoop::create_reserve_version_of_loop(IdealLoopTree *loop, CountedLoopReserveKit* lk) {\n-  Node_List old_new;\n-  LoopNode* head  = loop->_head->as_Loop();\n-  bool counted_loop = head->is_CountedLoop();\n-  Node*     entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n-  _igvn.rehash_node_delayed(entry);\n-  IdealLoopTree* outer_loop = head->is_strip_mined() ? loop->_parent->_parent : loop->_parent;\n-\n-  ConINode* const_1 = _igvn.intcon(1);\n-  set_ctrl(const_1, C->root());\n-  IfNode* iff = new IfNode(entry, const_1, PROB_MAX, COUNT_UNKNOWN);\n-  register_node(iff, outer_loop, entry, dom_depth(entry));\n-  ProjNode* iffast = new IfTrueNode(iff);\n-  register_node(iffast, outer_loop, iff, dom_depth(iff));\n-  ProjNode* ifslow = new IfFalseNode(iff);\n-  register_node(ifslow, outer_loop, iff, dom_depth(iff));\n-\n-  \/\/ Clone the loop body.  The clone becomes the slow loop.  The\n-  \/\/ original pre-header will (illegally) have 3 control users\n-  \/\/ (old & new loops & new if).\n-  clone_loop(loop, old_new, dom_depth(head), CloneIncludesStripMined, iff);\n-  assert(old_new[head->_idx]->is_Loop(), \"\" );\n-\n-  LoopNode* slow_head = old_new[head->_idx]->as_Loop();\n-\n-#ifndef PRODUCT\n-  if (TraceLoopOpts) {\n-    tty->print_cr(\"PhaseIdealLoop::create_reserve_version_of_loop:\");\n-    tty->print(\"\\t iff = %d, \", iff->_idx); iff->dump();\n-    tty->print(\"\\t iffast = %d, \", iffast->_idx); iffast->dump();\n-    tty->print(\"\\t ifslow = %d, \", ifslow->_idx); ifslow->dump();\n-    tty->print(\"\\t before replace_input_of: head = %d, \", head->_idx); head->dump();\n-    tty->print(\"\\t before replace_input_of: slow_head = %d, \", slow_head->_idx); slow_head->dump();\n-  }\n-#endif\n-\n-  \/\/ Fast (true) control\n-  _igvn.replace_input_of(head->skip_strip_mined(), LoopNode::EntryControl, iffast);\n-  \/\/ Slow (false) control\n-  _igvn.replace_input_of(slow_head->skip_strip_mined(), LoopNode::EntryControl, ifslow);\n-\n-  recompute_dom_depth();\n-\n-  lk->set_iff(iff);\n-\n-#ifndef PRODUCT\n-  if (TraceLoopOpts ) {\n-    tty->print(\"\\t after  replace_input_of: head = %d, \", head->_idx); head->dump();\n-    tty->print(\"\\t after  replace_input_of: slow_head = %d, \", slow_head->_idx); slow_head->dump();\n-  }\n-#endif\n-\n-  return slow_head->as_Loop();\n-}\n-\n-CountedLoopReserveKit::CountedLoopReserveKit(PhaseIdealLoop* phase, IdealLoopTree *loop, bool active = true) :\n-  _phase(phase),\n-  _lpt(loop),\n-  _lp(nullptr),\n-  _iff(nullptr),\n-  _lp_reserved(nullptr),\n-  _has_reserved(false),\n-  _use_new(false),\n-  _active(active)\n-  {\n-    create_reserve();\n-  };\n-\n-CountedLoopReserveKit::~CountedLoopReserveKit() {\n-  if (!_active) {\n-    return;\n-  }\n-\n-  if (_has_reserved && !_use_new) {\n-    \/\/ intcon(0)->iff-node reverts CF to the reserved copy\n-    ConINode* const_0 = _phase->_igvn.intcon(0);\n-    _phase->set_ctrl(const_0, _phase->C->root());\n-    _iff->set_req(1, const_0);\n-\n-    #ifndef PRODUCT\n-      if (TraceLoopOpts) {\n-        tty->print_cr(\"CountedLoopReserveKit::~CountedLoopReserveKit()\");\n-        tty->print(\"\\t discard loop %d and revert to the reserved loop clone %d: \", _lp->_idx, _lp_reserved->_idx);\n-        _lp_reserved->dump();\n-      }\n-    #endif\n-  }\n-}\n-\n-bool CountedLoopReserveKit::create_reserve() {\n-  if (!_active) {\n-    return false;\n-  }\n-\n-  if(!_lpt->_head->is_CountedLoop()) {\n-    if (TraceLoopOpts) {\n-      tty->print_cr(\"CountedLoopReserveKit::create_reserve: %d not counted loop\", _lpt->_head->_idx);\n-    }\n-    return false;\n-  }\n-  CountedLoopNode *cl = _lpt->_head->as_CountedLoop();\n-  if (!cl->is_valid_counted_loop(T_INT)) {\n-    if (TraceLoopOpts) {\n-      tty->print_cr(\"CountedLoopReserveKit::create_reserve: %d not valid counted loop\", cl->_idx);\n-    }\n-    return false; \/\/ skip malformed counted loop\n-  }\n-  if (!cl->is_main_loop()) {\n-    bool loop_not_canonical = true;\n-    if (cl->is_post_loop() && (cl->slp_max_unroll() > 0)) {\n-      loop_not_canonical = false;\n-    }\n-    \/\/ only reject some loop forms\n-    if (loop_not_canonical) {\n-      if (TraceLoopOpts) {\n-        tty->print_cr(\"CountedLoopReserveKit::create_reserve: %d not canonical loop\", cl->_idx);\n-      }\n-      return false; \/\/ skip normal, pre, and post (conditionally) loops\n-    }\n-  }\n-\n-  _lp = _lpt->_head->as_Loop();\n-  _lp_reserved = _phase->create_reserve_version_of_loop(_lpt, this);\n-\n-  if (!_lp_reserved->is_CountedLoop()) {\n-    return false;\n-  }\n-\n-  Node* ifslow_pred = _lp_reserved->skip_strip_mined()->in(LoopNode::EntryControl);\n-\n-  if (!ifslow_pred->is_IfFalse()) {\n-    return false;\n-  }\n-\n-  Node* iff = ifslow_pred->in(0);\n-  if (!iff->is_If() || iff != _iff) {\n-    return false;\n-  }\n-\n-  if (iff->in(1)->Opcode() != Op_ConI) {\n-    return false;\n-  }\n-\n-  _has_reserved = true;\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":0,"deletions":146,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-class CountedLoopReserveKit;\n@@ -824,1 +823,0 @@\n-  friend class CountedLoopReserveKit;\n@@ -1202,1 +1200,1 @@\n-\n+      if (C->failing()) { return; }\n@@ -1421,10 +1419,0 @@\n-  \/\/ Clone a loop and return the clone head (clone_loop_head).\n-  \/\/ Added nodes include int(1), int(0) - disconnected, If, IfTrue, IfFalse,\n-  \/\/ This routine was created for usage in CountedLoopReserveKit.\n-  \/\/\n-  \/\/    int(1) -> If -> IfTrue -> original_loop_head\n-  \/\/              |\n-  \/\/              V\n-  \/\/           IfFalse -> clone_loop_head (returned by function pointer)\n-  \/\/\n-  LoopNode* create_reserve_version_of_loop(IdealLoopTree *loop, CountedLoopReserveKit* lk);\n@@ -1802,63 +1790,0 @@\n-\n-\/\/ This kit may be used for making of a reserved copy of a loop before this loop\n-\/\/  goes under non-reversible changes.\n-\/\/\n-\/\/ Function create_reserve() creates a reserved copy (clone) of the loop.\n-\/\/ The reserved copy is created by calling\n-\/\/ PhaseIdealLoop::create_reserve_version_of_loop - see there how\n-\/\/ the original and reserved loops are connected in the outer graph.\n-\/\/ If create_reserve succeeded, it returns 'true' and _has_reserved is set to 'true'.\n-\/\/\n-\/\/ By default the reserved copy (clone) of the loop is created as dead code - it is\n-\/\/ dominated in the outer loop by this node chain:\n-\/\/   intcon(1)->If->IfFalse->reserved_copy.\n-\/\/ The original loop is dominated by the same node chain but IfTrue projection:\n-\/\/   intcon(0)->If->IfTrue->original_loop.\n-\/\/\n-\/\/ In this implementation of CountedLoopReserveKit the ctor includes create_reserve()\n-\/\/ and the dtor, checks _use_new value.\n-\/\/ If _use_new == false, it \"switches\" control to reserved copy of the loop\n-\/\/ by simple replacing of node intcon(1) with node intcon(0).\n-\/\/\n-\/\/ Here is a proposed example of usage (see also SuperWord::output in superword.cpp).\n-\/\/\n-\/\/ void CountedLoopReserveKit_example()\n-\/\/ {\n-\/\/    CountedLoopReserveKit lrk((phase, lpt, DoReserveCopy = true); \/\/ create local object\n-\/\/    if (DoReserveCopy && !lrk.has_reserved()) {\n-\/\/      return; \/\/failed to create reserved loop copy\n-\/\/    }\n-\/\/    ...\n-\/\/    \/\/something is wrong, switch to original loop\n-\/\/\/   if(something_is_wrong) return; \/\/ ~CountedLoopReserveKit makes the switch\n-\/\/    ...\n-\/\/    \/\/everything worked ok, return with the newly modified loop\n-\/\/    lrk.use_new();\n-\/\/    return; \/\/ ~CountedLoopReserveKit does nothing once use_new() was called\n-\/\/  }\n-\/\/\n-\/\/ Keep in mind, that by default if create_reserve() is not followed by use_new()\n-\/\/ the dtor will \"switch to the original\" loop.\n-\/\/ NOTE. You you modify outside of the original loop this class is no help.\n-\/\/\n-class CountedLoopReserveKit {\n-  private:\n-    PhaseIdealLoop* _phase;\n-    IdealLoopTree*  _lpt;\n-    LoopNode*       _lp;\n-    IfNode*         _iff;\n-    LoopNode*       _lp_reserved;\n-    bool            _has_reserved;\n-    bool            _use_new;\n-    const bool      _active; \/\/may be set to false in ctor, then the object is dummy\n-\n-  public:\n-    CountedLoopReserveKit(PhaseIdealLoop* phase, IdealLoopTree *loop, bool active);\n-    ~CountedLoopReserveKit();\n-    void use_new()                {_use_new = true;}\n-    void set_iff(IfNode* x)       {_iff = x;}\n-    bool has_reserved()     const { return _active && _has_reserved;}\n-  private:\n-    bool create_reserve();\n-};\/\/ class CountedLoopReserveKit\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":76,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -391,1 +391,3 @@\n-  C->set_cached_top_node(xform( C->top(), live_nodes ));\n+  Node* const n = xform(C->top(), live_nodes);\n+  if (C->failing()) return;\n+  C->set_cached_top_node(n);\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -601,2 +601,7 @@\n-          const TypeX *ld_offs_t = phase->type(ld_offs)->isa_intptr_t();\n-          if (ac->modifies(ld_offs_t->_lo, ld_offs_t->_hi, phase, can_see_stored_value)) {\n+          const TypeX* ld_offs_t = phase->type(ld_offs)->isa_intptr_t();\n+          assert(!ld_offs_t->empty(), \"dead reference should be checked already\");\n+          \/\/ Take into account vector or unsafe access size\n+          jlong ld_size_in_bytes = (jlong)memory_size();\n+          jlong offset_hi = ld_offs_t->_hi + ld_size_in_bytes - 1;\n+          offset_hi = MIN2(offset_hi, (jlong)(TypeX::MAX->_hi)); \/\/ Take care for overflow in 32-bit VM\n+          if (ac->modifies(ld_offs_t->_lo, (intptr_t)offset_hi, phase, can_see_stored_value)) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+class ConvertNode;\n@@ -742,0 +743,1 @@\n+      DEFINE_CLASS_ID(Convert, Type, 11)\n@@ -902,0 +904,1 @@\n+  DEFINE_CLASS_QUERY(Convert)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1649,0 +1649,1 @@\n+    if (failing()) return;\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -127,3 +127,0 @@\n-  const Type *operator[] ( uint i ) const \/\/ Lookup, or null for not mapped\n-  { return (i<_max) ? _types[i] : (Type*)nullptr; }\n-  friend class PhaseValues;\n@@ -132,0 +129,2 @@\n+  const Type *operator[] ( uint i ) const \/\/ Lookup, or null for not mapped\n+  { return (i<_max) ? _types[i] : (Type*)nullptr; }\n@@ -552,1 +551,1 @@\n-  void replace_input_of(Node* n, int i, Node* in) {\n+  void replace_input_of(Node* n, uint i, Node* in) {\n@@ -564,1 +563,1 @@\n-  void delete_input_of(Node* n, int i) {\n+  void delete_input_of(Node* n, uint i) {\n@@ -570,1 +569,1 @@\n-  void delete_precedence_of(Node* n, int i) {\n+  void delete_precedence_of(Node* n, uint i) {\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -866,0 +866,43 @@\n+const TypeFunc* OptoRuntime::array_partition_Type() {\n+  \/\/ create input type (domain)\n+  int num_args = 7;\n+  int argcnt = num_args;\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;  \/\/ array\n+  fields[argp++] = TypeInt::INT;      \/\/ element type\n+  fields[argp++] = TypeInt::INT;      \/\/ low\n+  fields[argp++] = TypeInt::INT;      \/\/ end\n+  fields[argp++] = TypePtr::NOTNULL;  \/\/ pivot_indices (int array)\n+  fields[argp++] = TypeInt::INT;      \/\/ indexPivot1\n+  fields[argp++] = TypeInt::INT;      \/\/ indexPivot2\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n+const TypeFunc* OptoRuntime::array_sort_Type() {\n+  \/\/ create input type (domain)\n+  int num_args      = 4;\n+  int argcnt = num_args;\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ array\n+  fields[argp++] = TypeInt::INT;    \/\/ element type\n+  fields[argp++] = TypeInt::INT;    \/\/ fromIndex\n+  fields[argp++] = TypeInt::INT;    \/\/ toIndex\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -273,0 +273,2 @@\n+  static const TypeFunc* array_sort_Type();\n+  static const TypeFunc* array_partition_Type();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4941,1 +4941,1 @@\n-  jint max_hi = max_array_length(elem()->basic_type());\n+  jint max_hi = max_array_length(elem()->array_element_basic_type());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1552,0 +1552,4 @@\n+      JvmtiEnv *env = ets->get_env();\n+      if (env->phase() == JVMTI_PHASE_PRIMORDIAL) {\n+        continue;\n+      }\n@@ -1553,4 +1557,0 @@\n-        JvmtiEnv *env = ets->get_env();\n-        if (env->phase() == JVMTI_PHASE_PRIMORDIAL) {\n-          continue;\n-        }\n@@ -1578,8 +1578,2 @@\n-  JavaThread *cur_thread = JavaThread::current();\n-  JvmtiThreadState *state = get_jvmti_thread_state(cur_thread);\n-  if (state == nullptr) {\n-    return;\n-  }\n-\n-  if (state->is_enabled(JVMTI_EVENT_VIRTUAL_THREAD_START)) {\n-    JvmtiEnvThreadStateIterator it(state);\n+  JavaThread *thread = JavaThread::current();\n+  assert(!thread->is_hidden_from_external_view(), \"carrier threads can't be hidden\");\n@@ -1587,2 +1581,3 @@\n-    for (JvmtiEnvThreadState* ets = it.first(); ets != nullptr; ets = it.next(ets)) {\n-      JvmtiEnv *env = ets->get_env();\n+  if (JvmtiEventController::is_enabled(JVMTI_EVENT_VIRTUAL_THREAD_START)) {\n+    JvmtiEnvIterator it;\n+    for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n@@ -1592,1 +1587,1 @@\n-      if (ets->is_enabled(JVMTI_EVENT_VIRTUAL_THREAD_START)) {\n+      if (env->is_enabled(JVMTI_EVENT_VIRTUAL_THREAD_START)) {\n@@ -1595,2 +1590,2 @@\n-        JvmtiVirtualThreadEventMark jem(cur_thread);\n-        JvmtiJavaThreadEventTransition jet(cur_thread);\n+        JvmtiVirtualThreadEventMark jem(thread);\n+        JvmtiJavaThreadEventTransition jet(thread);\n@@ -1612,2 +1607,4 @@\n-  JavaThread *cur_thread = JavaThread::current();\n-  JvmtiThreadState *state = get_jvmti_thread_state(cur_thread);\n+  JavaThread *thread = JavaThread::current();\n+  assert(!thread->is_hidden_from_external_view(), \"carrier threads can't be hidden\");\n+\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n@@ -1629,2 +1626,2 @@\n-        JvmtiVirtualThreadEventMark jem(cur_thread);\n-        JvmtiJavaThreadEventTransition jet(cur_thread);\n+        JvmtiVirtualThreadEventMark jem(thread);\n+        JvmtiJavaThreadEventTransition jet(thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -471,1 +471,1 @@\n-UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong size)) {\n+UNSAFE_LEAF(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong size)) {\n@@ -481,1 +481,1 @@\n-UNSAFE_ENTRY(jlong, Unsafe_ReallocateMemory0(JNIEnv *env, jobject unsafe, jlong addr, jlong size)) {\n+UNSAFE_LEAF(jlong, Unsafe_ReallocateMemory0(JNIEnv *env, jobject unsafe, jlong addr, jlong size)) {\n@@ -492,1 +492,1 @@\n-UNSAFE_ENTRY(void, Unsafe_FreeMemory0(JNIEnv *env, jobject unsafe, jlong addr)) {\n+UNSAFE_LEAF(void, Unsafe_FreeMemory0(JNIEnv *env, jobject unsafe, jlong addr)) {\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -117,0 +116,3 @@\n+#if INCLUDE_SERIALGC\n+#include \"gc\/serial\/serialHeap.hpp\"\n+#endif \/\/ INCLUDE_SERIALGC\n@@ -428,2 +430,7 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n-  return !gch->is_in_young(p);\n+#if INCLUDE_SERIALGC\n+  if (UseSerialGC) {\n+    return !SerialHeap::heap()->is_in_young(p);\n+  }\n+#endif\n+  ShouldNotReachHere();\n+  return false;\n@@ -727,1 +734,1 @@\n-  Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));\n+  Arena* arena =  new (mtTest) Arena(mtTest, Arena::Tag::tag_other, size_t(init_size));\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -528,0 +528,6 @@\n+  { \"DoReserveCopyInSuperWord\",     JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+\n+#ifdef LINUX\n+  { \"UseHugeTLBFS\",                 JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+  { \"UseSHM\",                       JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-  HandleArea(HandleArea* prev) : Arena(mtThread, Chunk::tiny_size) {\n+  HandleArea(HandleArea* prev) : Arena(mtThread, Tag::tag_ha, Chunk::tiny_size) {\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3629,6 +3629,11 @@\n-      \/\/ Inflate so the object's header no longer refers to the BasicLock.\n-      if (lock->displaced_header().is_unlocked()) {\n-        \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-        \/\/ locked so it can't be async deflated until ownership is dropped.\n-        \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n-        ObjectSynchronizer::inflate_helper(kptr2->obj());\n+      if (LockingMode == LM_LEGACY) {\n+        \/\/ Inflate so the object's header no longer refers to the BasicLock.\n+        if (lock->displaced_header().is_unlocked()) {\n+          \/\/ The object is locked and the resulting ObjectMonitor* will also be\n+          \/\/ locked so it can't be async deflated until ownership is dropped.\n+          \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n+          ObjectSynchronizer::inflate_helper(kptr2->obj());\n+        }\n+        \/\/ Now the displaced header is free to move because the\n+        \/\/ object's header no longer refers to it.\n+        buf[i] = (intptr_t)lock->displaced_header().value();\n@@ -3636,3 +3641,6 @@\n-      \/\/ Now the displaced header is free to move because the\n-      \/\/ object's header no longer refers to it.\n-      buf[i++] = (intptr_t)lock->displaced_header().value();\n+#ifdef ASSERT\n+      else {\n+        buf[i] = badDispHeaderOSR;\n+      }\n+#endif\n+      i++;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -610,1 +610,0 @@\n-  static void print_statistics();\n@@ -614,0 +613,2 @@\n+\n+  static void print_statistics() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -182,0 +182,3 @@\n+address StubRoutines::_array_sort = nullptr;\n+address StubRoutines::_array_partition  = nullptr;\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -156,0 +156,2 @@\n+  static address _array_sort;\n+  static address _array_partition;\n@@ -381,0 +383,2 @@\n+  static address select_arraysort_function() { return _array_sort; }\n+  static address select_array_partition_function() { return _array_partition; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1500,0 +1500,1 @@\n+  declare_c2_type(ConvertNode, TypeNode)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -142,0 +144,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilationMemoryStatisticDCmd>(full_export, true, false));\n@@ -1161,0 +1164,14 @@\n+\n+CompilationMemoryStatisticDCmd::CompilationMemoryStatisticDCmd(outputStream* output, bool heap) :\n+    DCmdWithParser(output, heap),\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  _minsize(\"-s\", \"Minimum memory size\", \"MEMORY SIZE\", false, \"0\") {\n+  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _dcmdparser.add_dcmd_option(&_minsize);\n+}\n+\n+void CompilationMemoryStatisticDCmd::execute(DCmdSource source, TRAPS) {\n+  const bool human_readable = _human_readable.value();\n+  const size_t minsize = _minsize.has_value() ? _minsize.value()._size : 0;\n+  CompilationMemoryStatistic::print_all_by_size(output(), human_readable, minsize);\n+}\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -982,0 +982,24 @@\n+class CompilationMemoryStatisticDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<MemorySizeArgument> _minsize;\n+public:\n+  static int num_arguments() { return 2; }\n+  CompilationMemoryStatisticDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"Compiler.memory\";\n+  }\n+  static const char* description() {\n+    return \"Print compilation footprint\";\n+  }\n+  static const char* impact() {\n+    return \"Medium: Pause time depends on number of compiled methods\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/continuationWrapper.inline.hpp\"\n@@ -1873,1 +1874,0 @@\n-\n@@ -1939,0 +1939,304 @@\n+\/\/ Support class used to generate HPROF_GC_ROOT_JAVA_FRAME records.\n+\n+class JavaStackRefDumper : public StackObj {\n+private:\n+  AbstractDumpWriter* _writer;\n+  u4 _thread_serial_num;\n+  int _frame_num;\n+  AbstractDumpWriter* writer() const { return _writer; }\n+public:\n+  JavaStackRefDumper(AbstractDumpWriter* writer, u4 thread_serial_num)\n+      : _writer(writer), _thread_serial_num(thread_serial_num), _frame_num(-1) \/\/ default - empty stack\n+  {\n+  }\n+\n+  void set_frame_number(int n) { _frame_num = n; }\n+\n+  void dump_java_stack_refs(StackValueCollection* values);\n+};\n+\n+void JavaStackRefDumper::dump_java_stack_refs(StackValueCollection* values) {\n+  for (int index = 0; index < values->size(); index++) {\n+    if (values->at(index)->type() == T_OBJECT) {\n+      oop o = values->obj_at(index)();\n+      if (o != nullptr) {\n+        u4 size = 1 + sizeof(address) + 4 + 4;\n+        writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n+        writer()->write_objectID(o);\n+        writer()->write_u4(_thread_serial_num);\n+        writer()->write_u4((u4)_frame_num);\n+        writer()->end_sub_record();\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Class to collect, store and dump thread-related data:\n+\/\/ - HPROF_TRACE and HPROF_FRAME records;\n+\/\/ - HPROF_GC_ROOT_THREAD_OBJ\/HPROF_GC_ROOT_JAVA_FRAME\/HPROF_GC_ROOT_JNI_LOCAL subrecords.\n+class ThreadDumper : public CHeapObj<mtInternal> {\n+public:\n+  enum class ThreadType { Platform, MountedVirtual, UnmountedVirtual };\n+\n+private:\n+  ThreadType _thread_type;\n+  JavaThread* _java_thread;\n+  oop _thread_oop;\n+\n+  GrowableArray<StackFrameInfo*>* _frames;\n+  \/\/ non-null if the thread is OOM thread\n+  Method* _oome_constructor;\n+  int _thread_serial_num;\n+  int _start_frame_serial_num;\n+\n+  vframe* get_top_frame() const;\n+\n+public:\n+  static bool should_dump_pthread(JavaThread* thread) {\n+    return thread->threadObj() != nullptr && !thread->is_exiting() && !thread->is_hidden_from_external_view();\n+  }\n+\n+  static bool should_dump_vthread(oop vt) {\n+    return java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::NEW\n+        && java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::TERMINATED;\n+  }\n+\n+  ThreadDumper(ThreadType thread_type, JavaThread* java_thread, oop thread_oop);\n+\n+  \/\/ affects frame_count\n+  void add_oom_frame(Method* oome_constructor) {\n+    assert(_start_frame_serial_num == 0, \"add_oom_frame cannot be called after init_serial_nums\");\n+    _oome_constructor = oome_constructor;\n+  }\n+\n+  void init_serial_nums(volatile int* thread_counter, volatile int* frame_counter) {\n+    assert(_start_frame_serial_num == 0, \"already initialized\");\n+    _thread_serial_num = Atomic::fetch_then_add(thread_counter, 1);\n+    _start_frame_serial_num = Atomic::fetch_then_add(frame_counter, frame_count());\n+  }\n+\n+  bool oom_thread() const {\n+    return _oome_constructor != nullptr;\n+  }\n+\n+  int frame_count() const {\n+    return _frames->length() + (oom_thread() ? 1 : 0);\n+  }\n+\n+  u4 thread_serial_num() const {\n+    return (u4)_thread_serial_num;\n+  }\n+\n+  u4 stack_trace_serial_num() const {\n+    return (u4)(_thread_serial_num + STACK_TRACE_ID);\n+  }\n+\n+  \/\/ writes HPROF_TRACE and HPROF_FRAME records\n+  \/\/ returns number of dumped frames\n+  void dump_stack_traces(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map);\n+\n+  \/\/ writes HPROF_GC_ROOT_THREAD_OBJ subrecord\n+  void dump_thread_obj(AbstractDumpWriter* writer);\n+\n+  \/\/ Walk the stack of the thread.\n+  \/\/ Dumps a HPROF_GC_ROOT_JAVA_FRAME subrecord for each local\n+  \/\/ Dumps a HPROF_GC_ROOT_JNI_LOCAL subrecord for each JNI local\n+  void dump_stack_refs(AbstractDumpWriter* writer);\n+\n+};\n+\n+ThreadDumper::ThreadDumper(ThreadType thread_type, JavaThread* java_thread, oop thread_oop)\n+    : _thread_type(thread_type), _java_thread(java_thread), _thread_oop(thread_oop),\n+      _oome_constructor(nullptr),\n+      _thread_serial_num(0), _start_frame_serial_num(0)\n+{\n+  \/\/ sanity checks\n+  if (_thread_type == ThreadType::UnmountedVirtual) {\n+    assert(_java_thread == nullptr, \"sanity\");\n+    assert(_thread_oop != nullptr, \"sanity\");\n+  } else {\n+    assert(_java_thread != nullptr, \"sanity\");\n+    assert(_thread_oop != nullptr, \"sanity\");\n+  }\n+\n+  _frames = new (mtServiceability) GrowableArray<StackFrameInfo*>(10, mtServiceability);\n+  bool stop_at_vthread_entry = _thread_type == ThreadType::MountedVirtual;\n+\n+  \/\/ vframes are resource allocated\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  for (vframe* vf = get_top_frame(); vf != nullptr; vf = vf->sender()) {\n+    if (stop_at_vthread_entry && vf->is_vthread_entry()) {\n+      break;\n+    }\n+    if (vf->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(vf);\n+      _frames->append(new StackFrameInfo(jvf, false));\n+    } else {\n+      \/\/ ignore non-Java frames\n+    }\n+  }\n+}\n+\n+void ThreadDumper::dump_stack_traces(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_nums are not initialized\");\n+\n+  \/\/ write HPROF_FRAME records for this thread's stack trace\n+  int depth = _frames->length();\n+  int frame_serial_num = _start_frame_serial_num;\n+\n+  if (oom_thread()) {\n+    \/\/ OOM thread\n+    \/\/ write fake frame that makes it look like the thread, which caused OOME,\n+    \/\/ is in the OutOfMemoryError zero-parameter constructor\n+    int oome_serial_num = klass_map->find(_oome_constructor->method_holder());\n+    \/\/ the class serial number starts from 1\n+    assert(oome_serial_num > 0, \"OutOfMemoryError class not found\");\n+    DumperSupport::dump_stack_frame(writer, ++frame_serial_num, oome_serial_num, _oome_constructor, 0);\n+    depth++;\n+  }\n+\n+  for (int j = 0; j < _frames->length(); j++) {\n+    StackFrameInfo* frame = _frames->at(j);\n+    Method* m = frame->method();\n+    int class_serial_num = klass_map->find(m->method_holder());\n+    \/\/ the class serial number starts from 1\n+    assert(class_serial_num > 0, \"class not found\");\n+    DumperSupport::dump_stack_frame(writer, ++frame_serial_num, class_serial_num, m, frame->bci());\n+  }\n+\n+  \/\/ write HPROF_TRACE record for the thread\n+  DumperSupport::write_header(writer, HPROF_TRACE, checked_cast<u4>(3 * sizeof(u4) + depth * oopSize));\n+  writer->write_u4(stack_trace_serial_num());   \/\/ stack trace serial number\n+  writer->write_u4(thread_serial_num());        \/\/ thread serial number\n+  writer->write_u4((u4)depth);                  \/\/ frame count (including oom frame)\n+  for (int j = 1; j <= depth; j++) {\n+    writer->write_id(_start_frame_serial_num + j);\n+  }\n+}\n+\n+void ThreadDumper::dump_thread_obj(AbstractDumpWriter * writer) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_num is not initialized\");\n+\n+  u4 size = 1 + sizeof(address) + 4 + 4;\n+  writer->start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);\n+  writer->write_objectID(_thread_oop);\n+  writer->write_u4(thread_serial_num());      \/\/ thread serial number\n+  writer->write_u4(stack_trace_serial_num()); \/\/ stack trace serial number\n+  writer->end_sub_record();\n+}\n+\n+void ThreadDumper::dump_stack_refs(AbstractDumpWriter * writer) {\n+  assert(_thread_serial_num != 0 && _start_frame_serial_num != 0, \"serial_num is not initialized\");\n+\n+  JNILocalsDumper blk(writer, thread_serial_num());\n+  if (_thread_type == ThreadType::Platform) {\n+    if (!_java_thread->has_last_Java_frame()) {\n+      \/\/ no last java frame but there may be JNI locals\n+      _java_thread->active_handles()->oops_do(&blk);\n+      return;\n+    }\n+  }\n+\n+  JavaStackRefDumper java_ref_dumper(writer, thread_serial_num());\n+\n+  \/\/ vframes are resource allocated\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  bool stopAtVthreadEntry = _thread_type == ThreadType::MountedVirtual;\n+  frame* last_entry_frame = nullptr;\n+  bool is_top_frame = true;\n+  int depth = 0;\n+  if (oom_thread()) {\n+    depth++;\n+  }\n+\n+  for (vframe* vf = get_top_frame(); vf != nullptr; vf = vf->sender()) {\n+    if (stopAtVthreadEntry && vf->is_vthread_entry()) {\n+      break;\n+    }\n+\n+    if (vf->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(vf);\n+      if (!(jvf->method()->is_native())) {\n+        java_ref_dumper.set_frame_number(depth);\n+        java_ref_dumper.dump_java_stack_refs(jvf->locals());\n+        java_ref_dumper.dump_java_stack_refs(jvf->expressions());\n+      } else {\n+        \/\/ native frame\n+        blk.set_frame_number(depth);\n+        if (is_top_frame) {\n+          \/\/ JNI locals for the top frame.\n+          assert(_java_thread != nullptr, \"impossible for unmounted vthread\");\n+          _java_thread->active_handles()->oops_do(&blk);\n+        } else {\n+          if (last_entry_frame != nullptr) {\n+            \/\/ JNI locals for the entry frame\n+            assert(last_entry_frame->is_entry_frame(), \"checking\");\n+            last_entry_frame->entry_frame_call_wrapper()->handles()->oops_do(&blk);\n+          }\n+        }\n+      }\n+      last_entry_frame = nullptr;\n+      \/\/ increment only for Java frames\n+      depth++;\n+    } else {\n+      \/\/ externalVFrame - for an entry frame then we report the JNI locals\n+      \/\/ when we find the corresponding javaVFrame\n+      frame* fr = vf->frame_pointer();\n+      assert(fr != nullptr, \"sanity check\");\n+      if (fr->is_entry_frame()) {\n+        last_entry_frame = fr;\n+      }\n+    }\n+  is_top_frame = false;\n+  }\n+  assert(depth == frame_count(), \"total number of Java frames not matched\");\n+}\n+\n+vframe* ThreadDumper::get_top_frame() const {\n+  if (_thread_type == ThreadType::UnmountedVirtual) {\n+    ContinuationWrapper cont(java_lang_VirtualThread::continuation(_thread_oop));\n+    if (cont.is_empty()) {\n+      return nullptr;\n+    }\n+    assert(!cont.is_mounted(), \"sanity check\");\n+    stackChunkOop chunk = cont.last_nonempty_chunk();\n+    if (chunk == nullptr || chunk->is_empty()) {\n+      return nullptr;\n+    }\n+\n+    RegisterMap reg_map(cont.continuation(), RegisterMap::UpdateMap::include);\n+    frame fr = chunk->top_frame(&reg_map);\n+    vframe* vf = vframe::new_vframe(&fr, &reg_map, nullptr); \/\/ don't need JavaThread\n+    return vf;\n+  }\n+\n+  RegisterMap reg_map(_java_thread,\n+      RegisterMap::UpdateMap::include,\n+      RegisterMap::ProcessFrames::include,\n+      RegisterMap::WalkContinuation::skip);\n+  switch (_thread_type) {\n+  case ThreadType::Platform:\n+    if (!_java_thread->has_last_Java_frame()) {\n+      return nullptr;\n+    }\n+    return _java_thread->is_vthread_mounted()\n+        ? _java_thread->carrier_last_java_vframe(&reg_map)\n+        : _java_thread->platform_thread_last_java_vframe(&reg_map);\n+\n+  case ThreadType::MountedVirtual:\n+    return _java_thread->last_java_vframe(&reg_map);\n+\n+  default: \/\/ make compilers happy\n+      break;\n+  }\n+  ShouldNotReachHere();\n+  return nullptr;\n+}\n+\n+\n@@ -2177,2 +2481,6 @@\n-  ThreadStackTrace**      _stack_traces;\n-  int                     _num_threads;\n+\n+  ThreadDumper**          _thread_dumpers; \/\/ platform, carrier and mounted virtual threads\n+  int                     _thread_dumpers_count;\n+  volatile int            _thread_serial_num;\n+  volatile int            _frame_serial_num;\n+\n@@ -2219,3 +2527,2 @@\n-  \/\/ HPROF_GC_ROOT_THREAD_OBJ records\n-  int do_thread(JavaThread* thread, u4 thread_serial_num);\n-  void do_threads();\n+  \/\/ HPROF_GC_ROOT_THREAD_OBJ records for platform and mounted virtual threads\n+  void dump_threads();\n@@ -2227,1 +2534,5 @@\n-  \/\/ HPROF_TRACE and HPROF_FRAME records\n+  bool is_oom_thread(JavaThread* thread) const {\n+    return thread == _oome_thread && _oome_constructor != nullptr;\n+  }\n+\n+  \/\/ HPROF_TRACE and HPROF_FRAME records for platform and mounted virtual threads\n@@ -2240,2 +2551,6 @@\n-    _stack_traces = nullptr;\n-    _num_threads = 0;\n+\n+    _thread_dumpers = nullptr;\n+    _thread_dumpers_count = 0;\n+    _thread_serial_num = 1;\n+    _frame_serial_num = 1;\n+\n@@ -2261,3 +2576,3 @@\n-    if (_stack_traces != nullptr) {\n-      for (int i=0; i < _num_threads; i++) {\n-        delete _stack_traces[i];\n+    if (_thread_dumpers != nullptr) {\n+      for (int i = 0; i < _thread_dumpers_count; i++) {\n+        delete _thread_dumpers[i];\n@@ -2265,1 +2580,1 @@\n-      FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);\n+      FREE_C_HEAP_ARRAY(ThreadDumper*, _thread_dumpers);\n@@ -2267,0 +2582,1 @@\n+\n@@ -2335,94 +2651,6 @@\n-\/\/ Walk the stack of the given thread.\n-\/\/ Dumps a HPROF_GC_ROOT_JAVA_FRAME record for each local\n-\/\/ Dumps a HPROF_GC_ROOT_JNI_LOCAL record for each JNI local\n-\/\/\n-\/\/ It returns the number of Java frames in this thread stack\n-int VM_HeapDumper::do_thread(JavaThread* java_thread, u4 thread_serial_num) {\n-  JNILocalsDumper blk(writer(), thread_serial_num);\n-\n-  oop threadObj = java_thread->threadObj();\n-  assert(threadObj != nullptr, \"sanity check\");\n-\n-  int stack_depth = 0;\n-  if (java_thread->has_last_Java_frame()) {\n-\n-    \/\/ vframes are resource allocated\n-    Thread* current_thread = Thread::current();\n-    ResourceMark rm(current_thread);\n-    HandleMark hm(current_thread);\n-\n-    RegisterMap reg_map(java_thread,\n-                        RegisterMap::UpdateMap::include,\n-                        RegisterMap::ProcessFrames::include,\n-                        RegisterMap::WalkContinuation::skip);\n-    frame f = java_thread->last_frame();\n-    vframe* vf = vframe::new_vframe(&f, &reg_map, java_thread);\n-    frame* last_entry_frame = nullptr;\n-    int extra_frames = 0;\n-\n-    if (java_thread == _oome_thread && _oome_constructor != nullptr) {\n-      extra_frames++;\n-    }\n-    while (vf != nullptr) {\n-      blk.set_frame_number(stack_depth);\n-      if (vf->is_java_frame()) {\n-\n-        \/\/ java frame (interpreted, compiled, ...)\n-        javaVFrame *jvf = javaVFrame::cast(vf);\n-        if (!(jvf->method()->is_native())) {\n-          StackValueCollection* locals = jvf->locals();\n-          for (int slot=0; slot<locals->size(); slot++) {\n-            if (locals->at(slot)->type() == T_OBJECT) {\n-              oop o = locals->obj_at(slot)();\n-\n-              if (o != nullptr) {\n-                u4 size = 1 + sizeof(address) + 4 + 4;\n-                writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n-                writer()->write_objectID(o);\n-                writer()->write_u4(thread_serial_num);\n-                writer()->write_u4((u4) (stack_depth + extra_frames));\n-                writer()->end_sub_record();\n-              }\n-            }\n-          }\n-          StackValueCollection *exprs = jvf->expressions();\n-          for(int index = 0; index < exprs->size(); index++) {\n-            if (exprs->at(index)->type() == T_OBJECT) {\n-               oop o = exprs->obj_at(index)();\n-               if (o != nullptr) {\n-                 u4 size = 1 + sizeof(address) + 4 + 4;\n-                 writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n-                 writer()->write_objectID(o);\n-                 writer()->write_u4(thread_serial_num);\n-                 writer()->write_u4((u4) (stack_depth + extra_frames));\n-                 writer()->end_sub_record();\n-               }\n-             }\n-          }\n-        } else {\n-          \/\/ native frame\n-          if (stack_depth == 0) {\n-            \/\/ JNI locals for the top frame.\n-            java_thread->active_handles()->oops_do(&blk);\n-          } else {\n-            if (last_entry_frame != nullptr) {\n-              \/\/ JNI locals for the entry frame\n-              assert(last_entry_frame->is_entry_frame(), \"checking\");\n-              last_entry_frame->entry_frame_call_wrapper()->handles()->oops_do(&blk);\n-            }\n-          }\n-        }\n-        \/\/ increment only for Java frames\n-        stack_depth++;\n-        last_entry_frame = nullptr;\n-\n-      } else {\n-        \/\/ externalVFrame - if it's an entry frame then report any JNI locals\n-        \/\/ as roots when we find the corresponding native javaVFrame\n-        frame* fr = vf->frame_pointer();\n-        assert(fr != nullptr, \"sanity check\");\n-        if (fr->is_entry_frame()) {\n-          last_entry_frame = fr;\n-        }\n-      }\n-      vf = vf->sender();\n+\/\/ Write a HPROF_GC_ROOT_THREAD_OBJ record for platform\/carrier and mounted virtual threads.\n+\/\/ Then walk the stack so that locals and JNI locals are dumped.\n+void VM_HeapDumper::dump_threads() {\n+    for (int i = 0; i < _thread_dumpers_count; i++) {\n+        _thread_dumpers[i]->dump_thread_obj(writer());\n+        _thread_dumpers[i]->dump_stack_refs(writer());\n@@ -2430,26 +2658,0 @@\n-  } else {\n-    \/\/ no last java frame but there may be JNI locals\n-    java_thread->active_handles()->oops_do(&blk);\n-  }\n-  return stack_depth;\n-}\n-\n-\n-\/\/ write a HPROF_GC_ROOT_THREAD_OBJ record for each java thread. Then walk\n-\/\/ the stack so that locals and JNI locals are dumped.\n-void VM_HeapDumper::do_threads() {\n-  for (int i=0; i < _num_threads; i++) {\n-    JavaThread* thread = _stack_traces[i]->thread();\n-    oop threadObj = thread->threadObj();\n-    u4 thread_serial_num = i+1;\n-    u4 stack_serial_num = thread_serial_num + STACK_TRACE_ID;\n-    u4 size = 1 + sizeof(address) + 4 + 4;\n-    writer()->start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);\n-    writer()->write_objectID(threadObj);\n-    writer()->write_u4(thread_serial_num);  \/\/ thread number\n-    writer()->write_u4(stack_serial_num);   \/\/ stack trace serial number\n-    writer()->end_sub_record();\n-    int num_frames = do_thread(thread, thread_serial_num);\n-    assert(num_frames == _stack_traces[i]->get_stack_depth(),\n-           \"total number of Java frames not matched\");\n-  }\n@@ -2607,0 +2809,2 @@\n+    \/\/ HPROF_HEAP_DUMP\/HPROF_HEAP_DUMP_SEGMENT starts here\n+\n@@ -2614,1 +2818,1 @@\n-    do_threads();\n+    dump_threads();\n@@ -2672,2 +2876,2 @@\n-  DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));\n-  writer()->write_u4((u4) STACK_TRACE_ID);\n+  DumperSupport::write_header(writer(), HPROF_TRACE, 3 * sizeof(u4));\n+  writer()->write_u4((u4)STACK_TRACE_ID);\n@@ -2677,27 +2881,10 @@\n-  _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);\n-  int frame_serial_num = 0;\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n-    oop threadObj = thread->threadObj();\n-    if (threadObj != nullptr && !thread->is_exiting() && !thread->is_hidden_from_external_view()) {\n-      \/\/ dump thread stack trace\n-      Thread* current_thread = Thread::current();\n-      ResourceMark rm(current_thread);\n-      HandleMark hm(current_thread);\n-\n-      ThreadStackTrace* stack_trace = new ThreadStackTrace(thread, false);\n-      stack_trace->dump_stack_at_safepoint(-1, \/* ObjectMonitorsHashtable is not needed here *\/ nullptr, true);\n-      _stack_traces[_num_threads++] = stack_trace;\n-\n-      \/\/ write HPROF_FRAME records for this thread's stack trace\n-      int depth = stack_trace->get_stack_depth();\n-      int thread_frame_start = frame_serial_num;\n-      int extra_frames = 0;\n-      \/\/ write fake frame that makes it look like the thread, which caused OOME,\n-      \/\/ is in the OutOfMemoryError zero-parameter constructor\n-      if (thread == _oome_thread && _oome_constructor != nullptr) {\n-        int oome_serial_num = _klass_map->find(_oome_constructor->method_holder());\n-        \/\/ the class serial number starts from 1\n-        assert(oome_serial_num > 0, \"OutOfMemoryError class not found\");\n-        DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, oome_serial_num,\n-                                        _oome_constructor, 0);\n-        extra_frames++;\n+  \/\/ max number if every platform thread is carrier with mounted virtual thread\n+  _thread_dumpers = NEW_C_HEAP_ARRAY(ThreadDumper*, Threads::number_of_threads() * 2, mtInternal);\n+\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread * thread = jtiwh.next(); ) {\n+    if (ThreadDumper::should_dump_pthread(thread)) {\n+      bool add_oom_frame = is_oom_thread(thread);\n+\n+      oop mounted_vt = thread->is_vthread_mounted() ? thread->vthread() : nullptr;\n+      if (mounted_vt != nullptr && !ThreadDumper::should_dump_vthread(mounted_vt)) {\n+        mounted_vt = nullptr;\n@@ -2705,7 +2892,12 @@\n-      for (int j=0; j < depth; j++) {\n-        StackFrameInfo* frame = stack_trace->stack_frame_at(j);\n-        Method* m = frame->method();\n-        int class_serial_num = _klass_map->find(m->method_holder());\n-        \/\/ the class serial number starts from 1\n-        assert(class_serial_num > 0, \"class not found\");\n-        DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame->bci());\n+\n+      \/\/ mounted vthread (if any)\n+      if (mounted_vt != nullptr) {\n+        ThreadDumper* thread_dumper = new ThreadDumper(ThreadDumper::ThreadType::MountedVirtual, thread, mounted_vt);\n+        _thread_dumpers[_thread_dumpers_count++] = thread_dumper;\n+        if (add_oom_frame) {\n+          thread_dumper->add_oom_frame(_oome_constructor);\n+          \/\/ we add oom frame to the VT stack, don't add it to the carrier thread stack\n+          add_oom_frame = false;\n+        }\n+        thread_dumper->init_serial_nums(&_thread_serial_num, &_frame_serial_num);\n+        thread_dumper->dump_stack_traces(writer(), _klass_map);\n@@ -2713,10 +2905,6 @@\n-      depth += extra_frames;\n-\n-      \/\/ write HPROF_TRACE record for one thread\n-      DumperSupport::write_header(writer(), HPROF_TRACE, checked_cast<u4>(3*sizeof(u4) + depth*oopSize));\n-      int stack_serial_num = _num_threads + STACK_TRACE_ID;\n-      writer()->write_u4(stack_serial_num);      \/\/ stack trace serial number\n-      writer()->write_u4((u4) _num_threads);     \/\/ thread serial number\n-      writer()->write_u4(depth);                 \/\/ frame count\n-      for (int j=1; j <= depth; j++) {\n-        writer()->write_id(thread_frame_start + j);\n+\n+      \/\/ platform or carrier thread\n+      ThreadDumper* thread_dumper = new ThreadDumper(ThreadDumper::ThreadType::Platform, thread, thread->threadObj());\n+      _thread_dumpers[_thread_dumpers_count++] = thread_dumper;\n+      if (add_oom_frame) {\n+        thread_dumper->add_oom_frame(_oome_constructor);\n@@ -2724,0 +2912,2 @@\n+      thread_dumper->init_serial_nums(&_thread_serial_num, &_frame_serial_num);\n+      thread_dumper->dump_stack_traces(writer(), _klass_map);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":370,"deletions":180,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -1054,1 +1054,2 @@\n-\n+const intptr_t badDispHeaderDeopt = 0xDE0BD000;             \/\/ value to fill unused displaced header during deoptimization\n+const intptr_t badDispHeaderOSR   = 0xDEAD05A0;             \/\/ value to fill unused displaced header during OSR\n@@ -1156,2 +1157,2 @@\n-inline intx byte_size(void* from, void* to) {\n-  return (address)to - (address)from;\n+inline size_t byte_size(void* from, void* to) {\n+  return pointer_delta(to, from, sizeof(char));\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -1222,0 +1223,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -92,1 +93,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -2458,2 +2458,2 @@\n-            public void ensureNativeAccess(Module m, Class<?> owner, String methodName) {\n-                m.ensureNativeAccess(owner, methodName);\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass) {\n+                m.ensureNativeAccess(owner, methodName, currentClass);\n@@ -2695,0 +2695,10 @@\n+\n+            @Override\n+            public void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n+                string.copyToSegmentRaw(segment, offset);\n+            }\n+\n+            @Override\n+            public boolean bytesCompatible(String string, Charset charset) {\n+                return string.bytesCompatible(charset);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.javac.PreviewFeature;\n@@ -50,4 +48,0 @@\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n@@ -8019,79 +8013,0 @@\n-    \/**\n-     * Creates a var handle object, which can be used to dereference a {@linkplain java.lang.foreign.MemorySegment memory segment}\n-     * at a given byte offset, using the provided value layout.\n-     *\n-     * <p>The provided layout specifies the {@linkplain ValueLayout#carrier() carrier type},\n-     * the {@linkplain ValueLayout#byteSize() byte size},\n-     * the {@linkplain ValueLayout#byteAlignment() byte alignment} and the {@linkplain ValueLayout#order() byte order}\n-     * associated with the returned var handle.\n-     *\n-     * <p>The list of coordinate types associated with the returned var handle is {@code (MemorySegment, long)},\n-     * where the {@code long} coordinate type corresponds to byte offset into the given memory segment coordinate.\n-     * Thus, the returned var handle accesses bytes at an offset in a given memory segment, composing bytes to or from\n-     * a value of the var handle type. Moreover, the access operation will honor the endianness and the\n-     * alignment constraints expressed in the provided layout.\n-     *\n-     * <p>As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n-     * {@snippet lang=\"java\" :\n-     *     GroupLayout seq = java.lang.foreign.MemoryLayout.structLayout(\n-     *             MemoryLayout.paddingLayout(4),\n-     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n-     *     );\n-     * }\n-     * To access the member layout named {@code value}, we can construct a memory segment view var handle as follows:\n-     * {@snippet lang=\"java\" :\n-     *     VarHandle handle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n-     *     handle = MethodHandles.insertCoordinates(handle, 1, 4); \/\/(MemorySegment) -> int\n-     * }\n-     *\n-     * @apiNote The resulting var handle features certain <i>access mode restrictions<\/i>,\n-     * which are common to all memory segment view var handles. A memory segment view var handle is associated\n-     * with an access size {@code S} and an alignment constraint {@code B}\n-     * (both expressed in bytes). We say that a memory access operation is <em>fully aligned<\/em> if it occurs\n-     * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.\n-     * If access is fully aligned then following access modes are supported and are\n-     * guaranteed to support atomic access:\n-     * <ul>\n-     * <li>read write access modes for all {@code T}, with the exception of\n-     *     access modes {@code get} and {@code set} for {@code long} and\n-     *     {@code double} on 32-bit platforms.\n-     * <li>atomic update access modes for {@code int}, {@code long},\n-     *     {@code float}, {@code double} or {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     types for certain currently unsupported access modes.)\n-     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <\/ul>\n-     *\n-     * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic\n-     * update access modes compare values using their bitwise representation\n-     * (see {@link Float#floatToRawIntBits},\n-     * {@link Double#doubleToRawLongBits} and {@link MemorySegment#address()}, respectively).\n-     * <p>\n-     * Alternatively, a memory access operation is <em>partially aligned<\/em> if it occurs at a memory address {@code A}\n-     * which is only compatible with the alignment constraint {@code B}; in such cases, access for anything other than the\n-     * {@code get} and {@code set} access modes will result in an {@code IllegalStateException}. If access is partially aligned,\n-     * atomic access is only guaranteed with respect to the largest power of two that divides the GCD of {@code A} and {@code S}.\n-     * <p>\n-     * In all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n-     * {@code IllegalStateException} is thrown, irrespective of the access mode being used.\n-     * <p>\n-     * Finally, if {@code T} is {@code MemorySegment} all write access modes throw {@link IllegalArgumentException}\n-     * unless the value to be written is a {@linkplain MemorySegment#isNative() native} memory segment.\n-     *\n-     * @param layout the value layout for which a memory access handle is to be obtained.\n-     * @return the new memory segment view var handle.\n-     * @throws NullPointerException if {@code layout} is {@code null}.\n-     * @see MemoryLayout#varHandle(MemoryLayout.PathElement...)\n-     * @since 19\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static VarHandle memorySegmentViewVarHandle(ValueLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return Utils.makeSegmentViewVarHandle(layout);\n-    }\n-\n@@ -8128,1 +8043,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8130,1 +8045,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8164,1 +8078,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8166,1 +8080,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8196,1 +8109,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8198,1 +8111,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8239,1 +8151,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8241,1 +8153,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8283,1 +8194,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8285,1 +8196,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8309,1 +8219,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8311,1 +8221,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":97,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -277,1 +278,1 @@\n-    void ensureNativeAccess(Module m, Class<?> owner, String methodName);\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass);\n@@ -617,0 +618,10 @@\n+\n+    \/**\n+     * Copy the string bytes to an existing segment, avoiding intermediate copies.\n+     *\/\n+    void copyToSegmentRaw(String string, MemorySegment segment, long offset);\n+\n+    \/**\n+     * Are the string bytes compatible with the given charset?\n+     *\/\n+    boolean bytesCompatible(String string, Charset charset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \/\/ not used\n+        \/\/ not used, but required for interim javac to not warn.\n@@ -69,1 +69,0 @@\n-        @JEP(number=442, title=\"Foreign Function & Memory API\", status=\"Third Preview\")\n@@ -72,0 +71,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-        jdk.incubator.vector, \/\/ participates in preview features\n+        jdk.incubator.vector,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -425,0 +425,5 @@\n+    \/**\n+     * Flag to indicate restricted method declaration.\n+     *\/\n+    public static final long RESTRICTED = 1L<<62; \/\/ MethodSymbols\n+\n@@ -431,1 +436,1 @@\n-     * Describe modifier flags as they migh appear in source code, i.e.,\n+     * Describe modifier flags as they might appear in source code, i.e.,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -343,1 +343,6 @@\n-        PREVIEW(\"preview\");\n+        PREVIEW(\"preview\"),\n+\n+        \/**\n+         * Warn about use of restricted methods.\n+         *\/\n+        RESTRICTED(\"restricted\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+    public final Type restrictedType;\n@@ -626,0 +627,1 @@\n+        restrictedType = enterClass(\"jdk.internal.javac.Restricted\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4812,0 +4812,1 @@\n+                chk.checkRestricted(tree.pos(), sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -291,0 +291,9 @@\n+    \/** Log a preview warning.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param msg        A Warning describing the problem.\n+     *\/\n+    public void warnRestrictedAPI(DiagnosticPosition pos, Symbol sym) {\n+        if (lint.isEnabled(LintCategory.RESTRICTED))\n+            log.warning(LintCategory.RESTRICTED, pos, Warnings.RestrictedMethod(sym.enclClass(), sym));\n+    }\n+\n@@ -4107,0 +4116,6 @@\n+    void checkRestricted(DiagnosticPosition pos, Symbol s) {\n+        if (s.kind == MTH && (s.flags() & RESTRICTED) != 0) {\n+            deferredLintHandler.report(() -> warnRestrictedAPI(pos, s));\n+        }\n+    }\n+\n@@ -4892,1 +4907,1 @@\n-                    hasBindings(patternLabel.pat)) {\n+                    (hasBindings(patternLabel.pat) || hasBindings(c.guard))) {\n@@ -4896,1 +4911,1 @@\n-                           hasBindings(patternLabel.pat) &&\n+                           (hasBindings(patternLabel.pat) || hasBindings(c.guard)) &&\n@@ -4905,1 +4920,1 @@\n-    boolean hasBindings(JCPattern p) {\n+    boolean hasBindings(JCTree p) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1560,0 +1560,3 @@\n+            } else if (proxy.type.tsym.flatName() == syms.restrictedType.tsym.flatName()) {\n+                Assert.check(sym.kind == MTH);\n+                sym.flags_field |= RESTRICTED;\n@@ -1573,0 +1576,3 @@\n+                }  else if (proxy.type.tsym == syms.restrictedType.tsym) {\n+                    Assert.check(sym.kind == MTH);\n+                    sym.flags_field |= RESTRICTED;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1147,2 +1147,0 @@\n-        \/\/ Process annotations if processing is not disabled and there\n-        \/\/ is at least one Processor available.\n@@ -1154,6 +1152,4 @@\n-            processAnnotations = procEnvImpl.atLeastOneProcessor();\n-            if (processAnnotations) {\n-                if (!explicitAnnotationProcessingRequested() &&\n-                    !optionsCheckingInitiallyDisabled) {\n-                    log.note(Notes.ImplicitAnnotationProcessing);\n-                }\n+            \/\/ Process annotations if processing is requested and there\n+            \/\/ is at least one Processor available.\n+            processAnnotations = procEnvImpl.atLeastOneProcessor() &&\n+                explicitAnnotationProcessingRequested();\n@@ -1162,0 +1158,1 @@\n+            if (processAnnotations) {\n@@ -1170,2 +1167,2 @@\n-            } else { \/\/ free resources\n-                procEnvImpl.close();\n+        } else { \/\/ free resources\n+            procEnvImpl.close();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;\n@@ -944,0 +943,1 @@\n+                checkNoMods(pos, mods.flags & Flags.FINAL);\n@@ -2884,1 +2884,1 @@\n-            dc = token.comment(CommentStyle.JAVADOC);\n+            dc = token.docComment();\n@@ -2894,1 +2894,1 @@\n-            dc = token.comment(CommentStyle.JAVADOC);\n+            dc = token.docComment();\n@@ -2900,1 +2900,1 @@\n-            dc = token.comment(CommentStyle.JAVADOC);\n+            dc = token.docComment();\n@@ -2906,1 +2906,1 @@\n-            dc = token.comment(CommentStyle.JAVADOC);\n+            dc = token.docComment();\n@@ -2963,1 +2963,1 @@\n-                    return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));\n+                    return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.docComment()));\n@@ -2968,1 +2968,1 @@\n-                    return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.comment(CommentStyle.JAVADOC)));\n+                    return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), token.docComment()));\n@@ -2973,1 +2973,1 @@\n-            dc = token.comment(CommentStyle.JAVADOC);\n+            dc = token.docComment();\n@@ -2977,1 +2977,1 @@\n-            dc = token.comment(CommentStyle.JAVADOC);\n+            dc = token.docComment();\n@@ -4014,1 +4014,1 @@\n-            attach(pd, firstToken.comment(CommentStyle.JAVADOC));\n+            attach(pd, firstToken.docComment());\n@@ -4049,1 +4049,1 @@\n-                Comment docComment = token.comment(CommentStyle.JAVADOC);\n+                Comment docComment = token.docComment();\n@@ -4051,1 +4051,1 @@\n-                    docComment = firstToken.comment(CommentStyle.JAVADOC);\n+                    docComment = firstToken.docComment();\n@@ -4118,1 +4118,1 @@\n-            attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));\n+            attach(toplevel, firstToken.docComment());\n@@ -4604,1 +4604,1 @@\n-        Comment dc = token.comment(CommentStyle.JAVADOC);\n+        Comment dc = token.docComment();\n@@ -4709,1 +4709,1 @@\n-            Comment dc = token.comment(CommentStyle.JAVADOC);\n+            Comment dc = token.docComment();\n@@ -4842,1 +4842,1 @@\n-        Comment dc = token.comment(CommentStyle.JAVADOC);\n+        Comment dc = token.docComment();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1654,1 +1654,1 @@\n-                    node.body.stats.nonEmpty() && TreeInfo.isSuperCall(node.body.stats.head) &&\n+                    node.body != null && node.body.stats.nonEmpty() && TreeInfo.isSuperCall(node.body.stats.head) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1926,0 +1926,5 @@\n+# 0: symbol, 1: symbol\n+compiler.warn.restricted.method=\\\n+    {0}.{1} is a restricted method.\\n\\\n+    (Restricted methods are unsafe and, if used incorrectly, might crash the Java runtime or corrupt memory)\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -288,0 +288,3 @@\n+javac.opt.Xlint.desc.restricted=\\\n+    Warn about use of restricted methods.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -456,3 +456,0 @@\n-        boolean useStringTable = options.isSet(\"useStringTable\");\n-        if (useStringTable)\n-            return newStringNameTable();\n@@ -462,1 +459,5 @@\n-        return newSharedNameTable();\n+        boolean useSharedTable = options.isSet(\"useSharedTable\");\n+        if (useSharedTable)\n+            return newSharedNameTable();\n+        boolean internStringTable = options.isSet(\"internStringTable\");\n+        return newStringNameTable(internStringTable);\n@@ -465,2 +466,2 @@\n-    public StringNameTable newStringNameTable() {\n-        return StringNameTable.create(this);\n+    public StringNameTable newStringNameTable(boolean intern) {\n+        return StringNameTable.create(this, intern);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -98,2 +98,1 @@\n-\n-runtime\/jni\/terminatedThread\/TestTerminatedThread.java 8219652 aix-ppc64\n+runtime\/jni\/terminatedThread\/TestTerminatedThread.java 8317789 aix-ppc64\n@@ -108,1 +107,0 @@\n-runtime\/CompressedOops\/CompressedClassPointers.java 8305765 generic-all\n@@ -119,0 +117,2 @@\n+runtime\/CompressedOops\/CompressedClassPointers.java 8317610 linux-x64,windows-x64\n+\n@@ -145,1 +145,2 @@\n-serviceability\/jvmti\/RedefineClasses\/RedefineLeakThrowable.java 8316658 generic-all\n+\n+serviceability\/jvmti\/stress\/StackTrace\/NotSuspended\/GetStackTraceNotSuspendedStressTest.java 8315980 linux-all,windows-x64\n@@ -182,0 +183,1 @@\n+gtest\/GTestWrapper.java 8306561 aix-ppc64\n@@ -197,3 +199,0 @@\n-vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI05\/ji05t001\/TestDescription.java 8219652 aix-ppc64\n-vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI06\/ji06t001\/TestDescription.java 8219652 aix-ppc64\n-vmTestbase\/nsk\/jvmti\/SetJNIFunctionTable\/setjniftab001\/TestDescription.java 8219652 aix-ppc64\n@@ -219,0 +218,2 @@\n+\n+vmTestbase\/nsk\/monitoring\/ThreadMXBean\/findMonitorDeadlockedThreads\/find006\/TestDescription.java 8310144 macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -445,0 +445,5 @@\n+    public static final String CONV = PREFIX + \"CONV\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV, \"Conv\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        sprintf(signature, \"(Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        snprintf(signature, sizeof(signature), \"(Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n@@ -67,1 +67,1 @@\n-        sprintf(signature, \"(%c)Ljava\/lang\/String;\", signature_type);\n+        snprintf(signature, sizeof(signature), \"(%c)Ljava\/lang\/String;\", signature_type);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Valhalla\/FieldAccessModify\/libFieldAccessModify.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-java\/awt\/Mouse\/MouseModifiersUnitTest\/MouseModifiersUnitTest_Standard.java 7124407 macosx-all\n+java\/awt\/Mouse\/MouseModifiersUnitTest\/MouseModifiersUnitTest_Standard.java 7124407,8302787  macosx-all,windows-all\n@@ -457,0 +457,1 @@\n+java\/awt\/Graphics2D\/DrawString\/RotTransText.java 8316878 linux-all\n@@ -458,0 +459,2 @@\n+java\/awt\/KeyboardFocusmanager\/ConsumeNextMnemonicKeyTypedTest\/ConsumeForModalDialogTest\/ConsumeForModalDialogTest.java 8302787 windows-all\n+java\/awt\/KeyboardFocusmanager\/TypeAhead\/MenuItemActivatedTest\/MenuItemActivatedTest.java 8302787 windows-all\n@@ -462,1 +465,0 @@\n-java\/awt\/GraphicsDevice\/CheckDisplayModes.java 8266242 macosx-aarch64\n@@ -556,0 +558,2 @@\n+java\/net\/Socket\/asyncClose\/Race.java                            8317801 aix-ppc64\n+\n@@ -562,0 +566,2 @@\n+java\/nio\/channels\/Channels\/SocketChannelStreams.java            8317838 aix-ppc64\n+\n@@ -619,6 +625,7 @@\n-sun\/security\/tools\/keytool\/NssTest.java                         8295343 linux-all\n-sun\/security\/pkcs11\/Signature\/TestRSAKeyLength.java             8295343 linux-all\n-sun\/security\/pkcs11\/rsa\/TestSignatures.java                     8295343 linux-all\n-sun\/security\/pkcs11\/rsa\/TestKeyPairGenerator.java               8295343 linux-all\n-sun\/security\/pkcs11\/rsa\/TestKeyFactory.java                     8295343 linux-all\n-sun\/security\/pkcs11\/KeyStore\/Basic.java                         8295343 linux-all\n+sun\/security\/tools\/keytool\/NssTest.java                         8295343 generic-all\n+sun\/security\/pkcs11\/Signature\/TestRSAKeyLength.java             8295343 generic-all\n+sun\/security\/pkcs11\/rsa\/TestSignatures.java                     8295343 generic-all\n+sun\/security\/pkcs11\/rsa\/TestKeyPairGenerator.java               8295343 generic-all\n+sun\/security\/pkcs11\/rsa\/TestKeyFactory.java                     8295343 generic-all\n+sun\/security\/pkcs11\/KeyStore\/Basic.java                         8295343 generic-all\n+sun\/security\/pkcs11\/sslecc\/ClientJSSEServerJSSE.java            8316183 linux-ppc64le\n@@ -739,4 +746,4 @@\n-sun\/tools\/jstat\/jstatLineCounts1.sh                             8268211 linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts2.sh                             8268211 linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts3.sh                             8268211 linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts4.sh                             8268211 linux-aarch64\n+sun\/tools\/jstat\/jstatLineCounts1.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n+sun\/tools\/jstat\/jstatLineCounts2.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n+sun\/tools\/jstat\/jstatLineCounts3.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n+sun\/tools\/jstat\/jstatLineCounts4.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n@@ -760,1 +767,1 @@\n-jdk\/jfr\/api\/consumer\/recordingstream\/TestOnEvent.java           8255404 linux-x64\n+jdk\/jfr\/api\/consumer\/recordingstream\/TestOnEvent.java           8255404 linux-x64,linux-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -52,1 +54,0 @@\n-\n@@ -86,0 +87,4 @@\n+\n+        public void putAll(Map<String, String> map) {\n+            map.entrySet().forEach(e -> put(e.getKey(), () -> e.getValue()));\n+        }\n@@ -138,0 +143,1 @@\n+        map.putAll(xOptFlags()); \/\/ -Xmx4g -> @requires vm.opt.x.Xmx == \"4g\" )\n@@ -606,3 +612,4 @@\n-        ProcessBuilder pb = new ProcessBuilder(Container.ENGINE_COMMAND, \"ps\");\n-        Map<String, String> logFileNames = redirectOutputToLogFile(\"checkDockerSupport(): <container> ps\",\n-                                                      pb, \"container-ps\");\n+        ProcessBuilder pb = new ProcessBuilder(\"which\", Container.ENGINE_COMMAND);\n+        Map<String, String> logFileNames =\n+            redirectOutputToLogFile(\"checkDockerSupport(): which <container-engine>\",\n+                                                      pb, \"which-container\");\n@@ -665,3 +672,1 @@\n-        List<String> allFlags = new ArrayList<String>();\n-        Collections.addAll(allFlags, System.getProperty(\"test.vm.opts\", \"\").trim().split(\"\\\\s+\"));\n-        Collections.addAll(allFlags, System.getProperty(\"test.java.opts\", \"\").trim().split(\"\\\\s+\"));\n+        List<String> allFlags = allFlags().toList();\n@@ -693,1 +698,3 @@\n-                \"mixed\"\n+                \"mixed\",\n+                \/\/ -XmxmNNNm added by run-test framework for non-hotspot tests\n+                \"mx\"\n@@ -698,4 +705,6 @@\n-                              \/\/ remove -X\n-                              .map(s -> s.substring(2))\n-                              \/\/ remove :.* from flags with values\n-                              .map(s -> s.contains(\":\") ? s.substring(0, s.indexOf(':')) : s)\n+                          \/\/ remove -X\n+                          .map(s -> s.substring(2))\n+                          \/\/ remove :.* from flags with values\n+                          .map(s -> s.contains(\":\") ? s.substring(0, s.indexOf(':')) : s)\n+                          \/\/ remove size like 4G, 768m which might be set for non-hotspot tests\n+                          .map(s -> s.replaceAll(\"(\\\\d+)[mMgGkK]\", \"\"))\n@@ -710,0 +719,25 @@\n+    private Stream<String> allFlags() {\n+        return Stream.of((System.getProperty(\"test.vm.opts\", \"\") + \" \" + System.getProperty(\"test.java.opts\", \"\")).trim().split(\"\\\\s+\"));\n+    }\n+\n+    \/**\n+     * Parses extra options, options that start with -X excluding the\n+     * bare -X option (as it is not considered an extra option).\n+     * Ignores extra options not starting with -X\n+     *\n+     * This could be improved to handle extra options not starting\n+     * with -X as well as \"standard\" options.\n+     *\/\n+    private Map<String, String> xOptFlags() {\n+        return allFlags()\n+            .filter(s -> s.startsWith(\"-X\") && !s.startsWith(\"-XX:\") && !s.equals(\"-X\"))\n+            .map(s -> s.replaceFirst(\"-\", \"\"))\n+            .map(flag -> flag.splitWithDelimiters(\"[:0123456789]\", 2))\n+            .collect(Collectors.toMap(a -> \"vm.opt.x.\" + a[0],\n+                                      a -> (a.length == 1)\n+                                      ? \"true\" \/\/ -Xnoclassgc\n+                                      : (a[1].equals(\":\")\n+                                         ? a[2]            \/\/ [\"-XshowSettings\", \":\", \"system\"]\n+                                         : a[1] + a[2]))); \/\/ [\"-Xmx\", \"4\", \"g\"]\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":46,"deletions":12,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -221,0 +221,7 @@\n+# this one is transitional (waiting for FFM API to exit preview)\n+compiler.warn.restricted.method\n+\n+# Pending removal\n+compiler.note.implicit.annotation.processing\n+compiler.warn.proc.use.proc.or.implicit\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n- * @run testng\/othervm -DuseAP=false RecordCompilationTests\n- * @run testng\/othervm -DuseAP=true RecordCompilationTests\n+ * @run junit\/othervm -DuseAP=false RecordCompilationTests\n+ * @run junit\/othervm -DuseAP=true RecordCompilationTests\n@@ -84,1 +84,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -88,1 +88,0 @@\n-import static org.testng.Assert.assertEquals;\n@@ -102,2 +101,1 @@\n-@Test\n-public class RecordCompilationTests extends CompilationTestCase {\n+class RecordCompilationTests extends CompilationTestCase {\n@@ -131,1 +129,2 @@\n-    public void testMalformedDeclarations() {\n+    @Test\n+    void testMalformedDeclarations() {\n@@ -153,1 +152,2 @@\n-    public void testGoodDeclarations() {\n+    @Test\n+    void testGoodDeclarations() {\n@@ -183,1 +183,2 @@\n-    public void testGoodMemberDeclarations() {\n+    @Test\n+    void testGoodMemberDeclarations() {\n@@ -194,1 +195,2 @@\n-    public void testBadComponentNames() {\n+    @Test\n+    void testBadComponentNames() {\n@@ -199,1 +201,2 @@\n-    public void testRestrictedIdentifiers() {\n+    @Test\n+    void testRestrictedIdentifiers() {\n@@ -218,1 +221,2 @@\n-    public void testValidMembers() {\n+    @Test\n+    void testValidMembers() {\n@@ -229,1 +233,2 @@\n-    public void testCyclic() {\n+    @Test\n+    void testCyclic() {\n@@ -234,1 +239,2 @@\n-    public void testBadExtends() {\n+    @Test\n+    void testBadExtends() {\n@@ -242,1 +248,2 @@\n-    public void testNoExtendRecord() {\n+    @Test\n+    void testNoExtendRecord() {\n@@ -254,1 +261,2 @@\n-    public void testFieldDeclarations() {\n+    @Test\n+    void testFieldDeclarations() {\n@@ -282,1 +290,2 @@\n-    public void testAccessorRedeclaration() {\n+    @Test\n+    void testAccessorRedeclaration() {\n@@ -338,1 +347,2 @@\n-    public void testConstructorRedeclaration() {\n+    @Test\n+    void testConstructorRedeclaration() {\n@@ -429,1 +439,2 @@\n-    public void testAnnotationCriteria() {\n+    @Test\n+    void testAnnotationCriteria() {\n@@ -438,1 +449,1 @@\n-        assertEquals(goodSet.size() + badSet.size(), values().length);\n+        Assert.check(goodSet.size() + badSet.size() == values().length);\n@@ -462,1 +473,2 @@\n-    public void testNestedRecords() {\n+    @Test\n+    void testNestedRecords() {\n@@ -480,1 +492,2 @@\n-    public void testDuplicatedMember() {\n+    @Test\n+    void testDuplicatedMember() {\n@@ -489,1 +502,2 @@\n-    public void testStaticLocals() {\n+    @Test\n+    void testStaticLocals() {\n@@ -579,1 +593,2 @@\n-    public void testStaticDefinitionsInInnerClasses() {\n+    @Test\n+    void testStaticDefinitionsInInnerClasses() {\n@@ -1045,1 +1060,2 @@\n-    public void testReturnInCanonical_Compact() {\n+    @Test\n+    void testReturnInCanonical_Compact() {\n@@ -1054,1 +1070,2 @@\n-    public void testArgumentsAreNotFinalInCompact() {\n+    @Test\n+    void testArgumentsAreNotFinalInCompact() {\n@@ -1065,1 +1082,2 @@\n-    public void testNoNativeMethods() {\n+    @Test\n+    void testNoNativeMethods() {\n@@ -1072,1 +1090,2 @@\n-    public void testRecordsInsideInner() {\n+    @Test\n+    void testRecordsInsideInner() {\n@@ -1113,1 +1132,2 @@\n-    public void testAnnoInsideLocalOrAnonymous() {\n+    @Test\n+    void testAnnoInsideLocalOrAnonymous() {\n@@ -1217,1 +1237,2 @@\n-    public void testReceiverParameter() {\n+    @Test\n+    void testReceiverParameter() {\n@@ -1245,1 +1266,2 @@\n-    public void testOnlyOneFieldRef() throws Exception {\n+    @Test\n+    void testOnlyOneFieldRef() throws Exception {\n@@ -1295,1 +1317,2 @@\n-    public void testCheckInitializationOrderInCompactConstructor() throws Exception {\n+    @Test\n+    void testCheckInitializationOrderInCompactConstructor() throws Exception {\n@@ -1334,1 +1357,2 @@\n-    public void testAcceptRecordId() {\n+    @Test\n+    void testAcceptRecordId() {\n@@ -1351,1 +1375,2 @@\n-    public void testMultipleAnnosInRecord() throws Exception {\n+    @Test\n+    void testMultipleAnnosInRecord() throws Exception {\n@@ -1392,1 +1417,2 @@\n-    public void testAnnos() throws Exception {\n+    @Test\n+    void testAnnos() throws Exception {\n@@ -1535,1 +1561,2 @@\n-    public void testOnlyTypeAnnotationsOnComponentField() throws Exception {\n+    @Test\n+    void testOnlyTypeAnnotationsOnComponentField() throws Exception {\n@@ -1758,1 +1785,2 @@\n-    public void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {\n+    @Test\n+    void testMethodsInheritedFromRecordArePublicAndFinal() throws Exception {\n@@ -1777,1 +1805,2 @@\n-    public void testCanonicalAccessibility() throws Exception {\n+    @Test\n+    void testCanonicalAccessibility() throws Exception {\n@@ -1826,1 +1855,2 @@\n-    public void testSameArity() {\n+    @Test\n+    void testSameArity() {\n@@ -1900,1 +1930,2 @@\n-    public void testSafeVararsAnno() {\n+    @Test\n+    void testSafeVararsAnno() {\n@@ -1962,1 +1993,2 @@\n-    public void testOverrideAtAccessor() {\n+    @Test\n+    void testOverrideAtAccessor() {\n@@ -2000,1 +2032,2 @@\n-    public void testNoAssigmentInsideCompactRecord() {\n+    @Test\n+    void testNoAssigmentInsideCompactRecord() {\n@@ -2021,1 +2054,2 @@\n-    public void testNoNPEStaticAnnotatedFields() {\n+    @Test\n+    void testNoNPEStaticAnnotatedFields() {\n@@ -2054,1 +2088,2 @@\n-    public void testDoNotAllowCStyleArraySyntaxForRecComponents() {\n+    @Test\n+    void testDoNotAllowCStyleArraySyntaxForRecComponents() {\n@@ -2072,1 +2107,2 @@\n-    public void testNoWarningForSerializableRecords() {\n+    @Test\n+    void testNoWarningForSerializableRecords() {\n@@ -2087,1 +2123,2 @@\n-    public void testAnnotationsOnVarargsRecComp() {\n+    @Test\n+    void testAnnotationsOnVarargsRecComp() {\n@@ -2122,1 +2159,2 @@\n-    public void testSaveVarargsAnno() {\n+    @Test\n+    void testSaveVarargsAnno() {\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":86,"deletions":48,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-                return ((JavaValueArray)value).valueString();\n+                return ((JavaValueArray)value).valueAsString();\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaObject.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -374,0 +374,14 @@\n+\n+    \/\/ Tries to represent the value as string (used by JavaObject.toString).\n+    public String valueAsString() {\n+        if (getElementType() == 'B')  {\n+            JavaThing[] things = getValue();\n+            byte[] bytes = new byte[things.length];\n+            for (int i = 0; i < things.length; i++) {\n+                bytes[i] = ((JavaByte)things[i]).value;\n+            }\n+            return new String(bytes);\n+        }\n+        \/\/ fallback\n+        return valueString();\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaValueArray.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,3 @@\n+    \/\/ threads\n+    private ArrayList<ThreadObject> threads = new ArrayList<>();\n+\n@@ -182,0 +185,4 @@\n+    public void addThreadObject(ThreadObject thread) {\n+        threads.add(thread);\n+    }\n+\n@@ -335,1 +342,1 @@\n-            t.setupReferers();\n+            t.setupReferrers();\n@@ -475,0 +482,4 @@\n+    public List<ThreadObject> getThreads() {\n+        return Collections.unmodifiableList(threads);\n+    }\n+\n@@ -492,1 +503,1 @@\n-                \/\/ referers, because they might be more interesting.\n+                \/\/ referrers, because they might be more interesting.\n@@ -494,3 +505,3 @@\n-            Enumeration<JavaThing> referers = curr.getReferers();\n-            while (referers.hasMoreElements()) {\n-                JavaHeapObject t = (JavaHeapObject) referers.nextElement();\n+            Enumeration<JavaThing> referrers = curr.getReferrers();\n+            while (referrers.hasMoreElements()) {\n+                JavaHeapObject t = (JavaHeapObject)referrers.nextElement();\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/Snapshot.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -453,2 +453,4 @@\n-                    threadObjects.put(threadSeq,\n-                                      new ThreadObject(id, stackSeq));\n+                    StackTrace st = getStackTraceFromSerial(stackSeq);\n+                    ThreadObject threadObj = new ThreadObject(id, st);\n+                    threadObjects.put(threadSeq, threadObj);\n+                    snapshot.addThreadObject(threadObj);\n@@ -470,1 +472,1 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n+                    StackTrace st = to.getStackTrace();\n@@ -474,1 +476,1 @@\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -484,1 +486,1 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n+                    StackTrace st = to.getStackTrace();;\n@@ -488,1 +490,1 @@\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -497,2 +499,2 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    StackTrace st = to.getStackTrace();;\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -513,2 +515,2 @@\n-                    StackTrace st = getStackTraceFromSerial(to.stackSeq);\n-                    snapshot.addRoot(new Root(id, to.threadId,\n+                    StackTrace st = to.getStackTrace();\n+                    snapshot.addRoot(new Root(id, to.getId(),\n@@ -982,14 +984,0 @@\n-    \/\/\n-    \/\/ A trivial data-holder class for HPROF_GC_ROOT_THREAD_OBJ.\n-    \/\/\n-    private class ThreadObject {\n-\n-        long threadId;\n-        int stackSeq;\n-\n-        ThreadObject(long threadId, int stackSeq) {\n-            this.threadId = threadId;\n-            this.stackSeq = stackSeq;\n-        }\n-    }\n-\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/parser\/HprofReader.java","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"}]}