{"files":[{"patch":"@@ -160,1 +160,1 @@\n-serviceability\/jvmti\/Valhalla\/HeapDump\/HeapDump.java 8317416 generic-all\n+serviceability\/jvmti\/valhalla\/HeapDump\/HeapDump.java 8317416 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,225 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @ignore Fix JDK-8328461\n- * @test\n- * @summary Tests that all FieldAccess and FieldModification notifications\n-            are generated for value classes.\n- * @requires vm.jvmti\n- * @enablePreview\n- * @compile FieldAccessModify.java\n- * @run main\/othervm\/native -agentlib:FieldAccessModify FieldAccessModify\n- *\/\n-\n-import java.lang.reflect.Field;\n-import java.util.Arrays;\n-\n-\n-public class FieldAccessModify {\n-\n-    private static final String agentLib = \"FieldAccessModify\";\n-\n-    private static value class MyPrimitive {\n-        public int MyPrimitive_fld1;\n-        public int MyPrimitive_fld2;\n-\n-        public MyPrimitive(int v1, int v2) { MyPrimitive_fld1 = v1; MyPrimitive_fld2 = v2; }\n-\n-        public static MyPrimitive create(int v1, int v2) {\n-            return new MyPrimitive(v1, v2);\n-        }\n-\n-        public String toString() {\n-            return \"MyPrimitive { fld1=\" + MyPrimitive_fld1 + \", fld2=\" + MyPrimitive_fld2 + \"}\";\n-        }\n-\n-    }\n-\n-    private static class InstanceHolder {\n-        public final MyPrimitive InstanceHolder_fld1;\n-\n-        public InstanceHolder(int v) {\n-            InstanceHolder_fld1 = MyPrimitive.create(v, v + 100);\n-        }\n-\n-        public String toString() {\n-            return \"InstanceHolder { fld1 is \" + InstanceHolder_fld1 + \"}\";\n-        }\n-    }\n-\n-    private static value class PrimitiveHolder {\n-        public MyPrimitive PrimitiveHolder_fld1;\n-\n-        public PrimitiveHolder(int v) {\n-            PrimitiveHolder_fld1 = MyPrimitive.create(v, v + 200);\n-        }\n-\n-        public String toString() {\n-            return \"PrimitiveHolder { fld1 is \" + PrimitiveHolder_fld1 + \"}\";\n-        }\n-    }\n-\n-    private static class TestHolder {\n-        public MyPrimitive primitiveObj = MyPrimitive.create(1, 1);\n-        public InstanceHolder instanceHolderObj = new InstanceHolder(1);\n-        public PrimitiveHolder primitiveHolderObj = new PrimitiveHolder(1);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        try {\n-            System.loadLibrary(agentLib);\n-        } catch (UnsatisfiedLinkError ex) {\n-            System.err.println(\"Failed to load \" + agentLib + \" lib\");\n-            System.err.println(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n-            throw ex;\n-        }\n-\n-        \/\/ create objects for access testing before setting watchers\n-        TestHolder testHolder = new TestHolder();\n-\n-        if (!initWatchers(MyPrimitive.class, MyPrimitive.class.getDeclaredField(\"MyPrimitive_fld1\"))) {\n-            throw new RuntimeException(\"Watchers initializations error (MyPrimitive_fld1)\");\n-        }\n-        if (!initWatchers(MyPrimitive.class, MyPrimitive.class.getDeclaredField(\"MyPrimitive_fld2\"))) {\n-            throw new RuntimeException(\"Watchers initializations error (MyPrimitive_fld2)\");\n-        }\n-        if (!initWatchers(InstanceHolder.class, InstanceHolder.class.getDeclaredField(\"InstanceHolder_fld1\"))) {\n-            throw new RuntimeException(\"Watchers initializations error (InstanceHolder_fld1)\");\n-        }\n-        if (!initWatchers(PrimitiveHolder.class, PrimitiveHolder.class.getDeclaredField(\"PrimitiveHolder_fld1\"))) {\n-            throw new RuntimeException(\"Watchers initializations error (PrimitiveHolder_fld1)\");\n-        }\n-\n-        test(\"MyPrimitive (access)\", () -> {\n-                testHolder.primitiveObj.toString();     \/\/ should access both MyPrimitive_fld1 and MyPrimitive_fld2\n-            }, new TestResult() {\n-                public boolean MyPrimitive_fld1_access;\n-                public boolean MyPrimitive_fld2_access;\n-            });\n-\n-        test(\"InstanceHolder (access)\", () ->  {\n-                testHolder.instanceHolderObj.toString();\n-            }, new TestResult() {\n-                public boolean InstanceHolder_fld1_access;\n-                \/\/ MyPrimitive fields should be accessed too\n-                public boolean MyPrimitive_fld1_access;\n-                public boolean MyPrimitive_fld2_access;\n-            });\n-\n-        test(\"PrimitiveHolder (access)\", () ->  {\n-                testHolder.primitiveHolderObj.toString();\n-            }, new TestResult() {\n-                public boolean PrimitiveHolder_fld1_access;\n-                \/\/ MyPrimitive fields should be accessed too\n-                public boolean MyPrimitive_fld1_access;\n-                public boolean MyPrimitive_fld2_access;\n-            });\n-\n-        test(\"MyPrimitive (modify)\", () ->  {\n-                MyPrimitive obj = MyPrimitive.create(1, 1);\n-            }, new TestResult() {\n-                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld1_modify;\n-                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld2_modify;\n-            });\n-\n-        test(\"InstanceHolder (modify)\", () ->  {\n-                InstanceHolder obj = new InstanceHolder(10);\n-            }, new TestResult() {\n-                public boolean InstanceHolder_fld1_modify;\n-                \/\/ MyPrimitive fields should be modified too\n-                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld1_modify;\n-                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld2_modify;\n-            });\n-\n-        test(\"PrimitiveHolder (modify)\", () ->  {\n-                PrimitiveHolder obj = new PrimitiveHolder(11);\n-            }, new TestResult() {\n-                \/\/ KNOWN_ISSUE public boolean PrimitiveHolder_fld1_modify;\n-                \/\/ MyPrimitive fields should be modified too\n-                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld1_modify;\n-                \/\/ KNOWN_ISSUE public boolean MyPrimitive_fld2_modify;\n-            });\n-\n-    }\n-\n-    private static void log(String msg) {\n-        System.out.println(msg);\n-        System.out.flush();\n-    }\n-\n-    private static void assertTrue(boolean value) {\n-        if (!value) {\n-            throw new RuntimeException(\"assert\");\n-        }\n-    }\n-\n-    \/\/ For every access\/modify notification native part tries to locate\n-    \/\/ boolean \"<field_name>_access\"\/\"<field_name>_modify\" field and sets it to true\n-    private static class TestResult {\n-\n-        \/\/ verify that all fields are set to true\n-        public void verify() {\n-            Arrays.stream(this.getClass().getDeclaredFields()).forEach(f -> verify(f));\n-        }\n-\n-        private void verify(Field f) {\n-            try {\n-                if (!f.getBoolean(this)) {\n-                    throw new RuntimeException(f.getName() + \" notification is missed\");\n-                }\n-                log(\"  - \" + f.getName() + \": OK\");\n-            } catch (IllegalAccessException ex) {\n-                throw new RuntimeException(ex);\n-            }\n-        }\n-    }\n-\n-    @FunctionalInterface\n-    private interface TestAction {\n-        void apply();\n-    }\n-\n-    private static void test(String descr, TestAction action, TestResult result) throws Exception {\n-        log(descr + \": starting\");\n-        if (!startTest(result)) {\n-            throw new RuntimeException(\"startTest failed\");\n-        }\n-        action.apply();\n-        \/\/ wait some time to ensure all posted events are handled\n-        Thread.sleep(500);\n-\n-        stopTest();\n-\n-        \/\/ check the results\n-        result.verify();\n-\n-        log(descr + \": OK\");\n-        log(\"\");\n-    }\n-\n-    private static native boolean initWatchers(Class cls, Field field);\n-    private static native boolean startTest(TestResult results);\n-    private static native void stopTest();\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Valhalla\/FieldAccessModify\/FieldAccessModify.java","additions":0,"deletions":225,"binary":false,"changes":225,"status":"deleted"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @ignore Fix JDK-8328461\n+ * @test\n+ * @summary Tests that all FieldAccess and FieldModification notifications\n+            are generated for value classes.\n+ * @requires vm.jvmti\n+ * @enablePreview\n+ * @run main\/othervm\/native -agentlib:FieldAccessModify -XX:+EnableValhalla FieldAccessModify\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+\n+public class FieldAccessModify {\n+\n+    private static final String agentLib = \"FieldAccessModify\";\n+\n+    private static value class ValueClass {\n+        public int valueClass_fld1;\n+        public int valueClass_fld2;\n+\n+        public ValueClass(int v1, int v2) { valueClass_fld1 = v1; valueClass_fld2 = v2; }\n+\n+        public String toString() {\n+            return \"ValueClass { fld1=\" + valueClass_fld1 + \", fld2=\" + valueClass_fld2 + \"}\";\n+        }\n+\n+    }\n+\n+    private static class InstanceHolder {\n+        public final ValueClass instanceHolder_fld1;\n+\n+        public InstanceHolder(int v) {\n+            instanceHolder_fld1 = new ValueClass(v, v + 100);\n+        }\n+\n+        public String toString() {\n+            return \"InstanceHolder { fld1 is \" + instanceHolder_fld1 + \"}\";\n+        }\n+    }\n+\n+    private static value class ValueHolder {\n+        public ValueClass valueHolder_fld1;\n+\n+        public ValueHolder(int v) {\n+            valueHolder_fld1 = new ValueClass(v, v + 200);\n+        }\n+\n+        public String toString() {\n+            return \"ValueHolder { fld1 is \" + valueHolder_fld1 + \"}\";\n+        }\n+    }\n+\n+    private static class TestHolder {\n+        public ValueClass valueObj = new ValueClass(1, 1);\n+        public InstanceHolder instanceHolderObj = new InstanceHolder(1);\n+        public ValueHolder valueHolderObj = new ValueHolder(1);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            System.loadLibrary(agentLib);\n+        } catch (UnsatisfiedLinkError ex) {\n+            System.err.println(\"Failed to load \" + agentLib + \" lib\");\n+            System.err.println(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n+            throw ex;\n+        }\n+\n+        \/\/ create objects for access testing before setting watchers\n+        TestHolder testHolder = new TestHolder();\n+\n+        if (!initWatchers(ValueClass.class, ValueClass.class.getDeclaredField(\"valueClass_fld1\"))) {\n+            throw new RuntimeException(\"Watchers initializations error (valueClass_fld1)\");\n+        }\n+        if (!initWatchers(ValueClass.class, ValueClass.class.getDeclaredField(\"valueClass_fld2\"))) {\n+            throw new RuntimeException(\"Watchers initializations error (valueClass_fld2)\");\n+        }\n+        if (!initWatchers(InstanceHolder.class, InstanceHolder.class.getDeclaredField(\"instanceHolder_fld1\"))) {\n+            throw new RuntimeException(\"Watchers initializations error (instanceHolder_fld1)\");\n+        }\n+        if (!initWatchers(ValueHolder.class, ValueHolder.class.getDeclaredField(\"valueHolder_fld1\"))) {\n+            throw new RuntimeException(\"Watchers initializations error (valueHolder_fld1)\");\n+        }\n+\n+        test(\"ValueClass (access)\", () -> {\n+                testHolder.valueObj.toString();     \/\/ should access both valueClass_fld1 and valueClass_fld2\n+            }, new TestResult() {\n+                public boolean valueClass_fld1_access;\n+                public boolean valueClass_fld2_access;\n+            });\n+\n+        test(\"InstanceHolder (access)\", () ->  {\n+                testHolder.instanceHolderObj.toString();\n+            }, new TestResult() {\n+                public boolean instanceHolder_fld1_access;\n+                \/\/ ValueClass fields should be accessed too\n+                public boolean valueClass_fld1_access;\n+                public boolean valueClass_fld2_access;\n+            });\n+\n+        test(\"ValueHolder (access)\", () ->  {\n+                testHolder.valueHolderObj.toString();\n+            }, new TestResult() {\n+                public boolean valueHolder_fld1_access;\n+                \/\/ ValueClass fields should be accessed too\n+                public boolean valueClass_fld1_access;\n+                public boolean valueClass_fld2_access;\n+            });\n+\n+        test(\"ValueClass (modify)\", () ->  {\n+                ValueClass obj = new ValueClass(1, 1);\n+            }, new TestResult() {\n+                public boolean valueClass_fld1_modify;\n+                public boolean valueClass_fld2_modify;\n+            });\n+\n+        test(\"InstanceHolder (modify)\", () ->  {\n+                InstanceHolder obj = new InstanceHolder(10);\n+            }, new TestResult() {\n+                public boolean instanceHolder_fld1_modify;\n+                \/\/ ValueClass fields should be modified too\n+                boolean valueClass_fld1_modify;\n+                public boolean valueClass_fld2_modify;\n+            });\n+\n+        test(\"ValueHolder (modify)\", () ->  {\n+                ValueHolder obj = new ValueHolder(11);\n+            }, new TestResult() {\n+                public boolean valueHolder_fld1_modify;\n+                \/\/ ValueClass fields should be modified too\n+                public boolean valueClass_fld1_modify;\n+                public boolean valueClass_fld2_modify;\n+            });\n+\n+    }\n+\n+    private static void log(String msg) {\n+        System.out.println(msg);\n+        System.out.flush();\n+    }\n+\n+    private static void assertTrue(boolean value) {\n+        if (!value) {\n+            throw new RuntimeException(\"assert\");\n+        }\n+    }\n+\n+    \/\/ For every access\/modify notification native part tries to locate\n+    \/\/ boolean \"<field_name>_access\"\/\"<field_name>_modify\" field and sets it to true\n+    private static class TestResult {\n+\n+        \/\/ verify that all fields are set to true\n+        public void verify() {\n+            Arrays.stream(this.getClass().getDeclaredFields()).forEach(f -> verify(f));\n+        }\n+\n+        private void verify(Field f) {\n+            try {\n+                if (!f.getBoolean(this)) {\n+                    throw new RuntimeException(f.getName() + \" notification is missed\");\n+                }\n+                log(\"  - \" + f.getName() + \": OK\");\n+            } catch (IllegalAccessException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface TestAction {\n+        void apply();\n+    }\n+\n+    private static void test(String descr, TestAction action, TestResult result) throws Exception {\n+        log(descr + \": starting\");\n+        if (!startTest(result)) {\n+            throw new RuntimeException(\"startTest failed\");\n+        }\n+        action.apply();\n+        \/\/ wait some time to ensure all posted events are handled\n+        Thread.sleep(500);\n+\n+        stopTest();\n+\n+        \/\/ check the results\n+        result.verify();\n+\n+        log(descr + \": OK\");\n+        log(\"\");\n+    }\n+\n+    private static native boolean initWatchers(Class cls, Field field);\n+    private static native boolean startTest(TestResult results);\n+    private static native void stopTest();\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/FieldAccessModify\/FieldAccessModify.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/FieldAccessModify\/libFieldAccessModify.cpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Valhalla\/FieldAccessModify\/libFieldAccessModify.cpp","status":"renamed"},{"patch":"","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/HeapDump\/HeapDump.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Valhalla\/HeapDump\/HeapDump.java","status":"renamed"}]}