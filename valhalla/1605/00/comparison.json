{"files":[{"patch":"@@ -349,1 +349,1 @@\n-      dependant_lea->set_req(AddPNode::Base, decode_address);\n+      dependant_lea->set_req(AddPNode::Base, lea_derived_oop->in(AddPNode::Address));\n","filename":"src\/hotspot\/cpu\/x86\/peephole_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,3 +88,0 @@\n-compiler\/codegen\/TestRedundantLea.java#StringInflate  8367518 generic-all\n-compiler\/codegen\/TestRedundantLea.java#StoreNParallel 8367518 generic-all\n-compiler\/codegen\/TestRedundantLea.java#StoreNSerial   8367518 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,0 +84,10 @@\n+\/*\n+ * @test id=Spill\n+ * @bug 8020282\n+ * @summary Test that we do not generate redundant leas and remove related spills on x86.\n+ * @requires os.simpleArch == \"x64\"\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/test\/lib \/\n+ * @run driver compiler.codegen.TestRedundantLea Spill\n+ *\/\n+\n@@ -132,0 +142,3 @@\n+            case \"Spill\" -> {\n+                framework = new TestFramework(SpillTest.class);\n+            }\n@@ -227,0 +240,1 @@\n+    \/\/ TODO: Make tests more precise\n@@ -231,1 +245,1 @@\n-    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=5\"},\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \">=5\"},\n@@ -233,4 +247,1 @@\n-        applyIfAnd = {\"OptoPeephole\", \"false\", \"UseAVX\", \">=2\"})\n-    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=13\"},\n-        phase = {CompilePhase.FINAL_CODE},\n-        applyIfAnd = {\"OptoPeephole\", \"false\", \"UseAVX\", \"<2\"})\n+        applyIf = {\"OptoPeephole\", \"false\"})\n@@ -238,4 +249,1 @@\n-    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=3\"},\n-        phase = {CompilePhase.FINAL_CODE},\n-        applyIfAnd = {\"OptoPeephole\", \"true\", \"UseAVX\", \">=2\"})\n-    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=11\"},\n+    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \">=3\"},\n@@ -243,1 +251,1 @@\n-        applyIfAnd = {\"OptoPeephole\", \"true\", \"UseAVX\", \"<2\"})\n+        applyIf = {\"OptoPeephole\", \"true\"})\n@@ -261,0 +269,1 @@\n+    \/\/ TODO: Make tests more precise\n@@ -281,3 +290,1 @@\n-\/\/ Here, we can also manipulate the offset such that we get a leaP32Narrow rule\n-\/\/ and we can demonstrate that the peephole also removes simple cases of unneeded\n-\/\/ spills.\n+\/\/ Here, we can also manipulate the offset such that we get a leaP32Narrow rule.\n@@ -294,2 +301,0 @@\n-    private Object[] objArr8bit = new Object[SOME_SIZE];\n-    private Object[] objArr32bit = new Object[SOME_SIZE];\n@@ -309,7 +314,0 @@\n-    \/\/ Test that the peephole removes a spill.\n-    @IR(counts = {IRNode.MEM_TO_REG_SPILL_COPY, \"=4\"},\n-        phase = {CompilePhase.FINAL_CODE},\n-        applyIfAnd ={\"OptoPeephole\", \"false\", \"UseCompactObjectHeaders\", \"false\"})\n-    @IR(counts = {IRNode.MEM_TO_REG_SPILL_COPY, \"=3\"},\n-        phase = {CompilePhase.FINAL_CODE},\n-        applyIfAnd ={\"OptoPeephole\", \"true\", \"UseCompactObjectHeaders\", \"false\"})\n@@ -338,0 +336,31 @@\n+}\n+\n+class StoreNTestHelper {\n+    Object o1;\n+    Object o2;\n+\n+    public StoreNTestHelper(Object o1, Object o2) {\n+        this.o1 = o1;\n+        this.o2 = o2;\n+    }\n+}\n+\n+\/\/ This test validates that the peephole removes simple spills.\n+\/\/ The code for the test originates from compiler\/escapeAnalysis\/Test6775880.java.\n+class SpillTest {\n+    int cnt;\n+    int b[];\n+    String s;\n+\n+    @Run(test = \"test\")\n+    public static void run() {\n+        SpillTest t = new SpillTest();\n+        t.cnt = 3;\n+        t.b = new int[3];\n+        t.b[0] = 0;\n+        t.b[1] = 1;\n+        t.b[2] = 2;\n+        int j = 0;\n+        t.s = \"\";\n+        t.test();\n+    }\n@@ -340,0 +369,1 @@\n+    \/\/ TODO: Make tests more precise\n@@ -347,1 +377,0 @@\n-    \/\/ Test that the peephole worked for leaPCompressedOopOffset\n@@ -351,11 +380,2 @@\n-    public void testNoAlloc() {\n-        this.objArr8bit[OFFSET8BIT_IDX] = CURRENT;\n-        this.objArr32bit[OFFSET32BIT_IDX] = OTHER;\n-    }\n-\n-    @Test\n-    @IR(counts = {IRNode.LEA_P, \"=2\"},\n-        phase = {CompilePhase.FINAL_CODE},\n-        applyIfPlatform = {\"mac\", \"false\"})\n-    \/\/ Negative test\n-    @IR(counts = {IRNode.DECODE_HEAP_OOP_NOT_NULL, \"=1\"},\n+    \/\/ Test that the peephole removes a spill.\n+    @IR(counts = {IRNode.MEM_TO_REG_SPILL_COPY, \">=20\"},\n@@ -363,3 +383,2 @@\n-        applyIf = {\"OptoPeephole\", \"false\"})\n-    \/\/ Test that the peephole worked for leaPCompressedOopOffset\n-    @IR(failOn = {IRNode.DECODE_HEAP_OOP_NOT_NULL},\n+        applyIf ={\"OptoPeephole\", \"false\"})\n+    @IR(counts = {IRNode.MEM_TO_REG_SPILL_COPY, \">=18\"},\n@@ -367,14 +386,10 @@\n-        applyIf = {\"OptoPeephole\", \"true\"})\n-    public void testNoAllocSameArray() {\n-        this.objArr8bit[OFFSET8BIT_IDX] = CURRENT;\n-        this.objArr8bit[OFFSET32BIT_IDX] = OTHER;\n-    }\n-}\n-\n-class StoreNTestHelper {\n-    Object o1;\n-    Object o2;\n-\n-    public StoreNTestHelper(Object o1, Object o2) {\n-        this.o1 = o1;\n-        this.o2 = o2;\n+        applyIf ={\"OptoPeephole\", \"true\"})\n+    String test() {\n+        String res = \"\";\n+        for (int i = 0; i < cnt; i++) {\n+            if (i != 0) {\n+                res = res + \".\";\n+            }\n+            res = res + b[i];\n+        }\n+        return res;\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestRedundantLea.java","additions":66,"deletions":51,"binary":false,"changes":117,"status":"modified"}]}