{"files":[{"patch":"@@ -102,0 +102,3 @@\n+\n+COMPILATION_OUTPUTDIR := $(if $($(MODULE)_BIN), $($(MODULE)_BIN), $(JDK_OUTPUTDIR)\/modules)\n+\n@@ -108,1 +111,1 @@\n-    BIN := $(if $($(MODULE)_BIN), $($(MODULE)_BIN), $(JDK_OUTPUTDIR)\/modules), \\\n+    BIN := $(COMPILATION_OUTPUTDIR), \\\n@@ -141,0 +144,9 @@\n+  # Temporarily compile valueclasses into a separate directory with the form:\n+  #   <tempdir>\/<module>\/<classpath>\n+  # and then copy the class files into:\n+  #   <outdir>\/<module>\/META-INF\/preview\/<classpath>\n+  # We cannot compile directly into the desired directory because it's the\n+  # compiler which creates the original '<module>\/<classpath>\/...' hierarchy.\n+  VALUECLASS_OUTPUTDIR := $(SUPPORT_OUTPUTDIR)\/$(VALUECLASSES_STR)\n+  PREVIEW_OUTPUTDIR := $(COMPILATION_OUTPUTDIR)\/$(MODULE)\/META-INF\/preview\n+\n@@ -148,1 +160,1 @@\n-        BIN := $(SUPPORT_OUTPUTDIR)\/$(VALUECLASSES_STR)\/, \\\n+        BIN := $(VALUECLASS_OUTPUTDIR)\/, \\\n@@ -166,0 +178,8 @@\n+    # Restructure the class file hierarchy from <module>\/<classpath>\/... to <module>\/META-INF\/preview\/<classpath>\/...\n+    $(PREVIEW_OUTPUTDIR)\/_copy_valueclasses.marker: $($(MODULE)-$(VALUECLASSES_STR))\n+\t\t$(call MakeTargetDir)\n+\t\t$(CP) -R $(VALUECLASS_OUTPUTDIR)\/$(MODULE)\/. $(@D)\/\n+\t\t$(TOUCH) $@\n+\n+    TARGETS += $(PREVIEW_OUTPUTDIR)\/_copy_valueclasses.marker\n+\n","filename":"make\/CompileJavaModules.gmk","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.NoSuchElementException;\n@@ -41,0 +42,1 @@\n+import java.util.function.Predicate;\n@@ -42,0 +44,2 @@\n+import java.util.stream.Stream;\n+\n@@ -329,0 +333,81 @@\n+    \/**\n+     * Returns the \"raw\" API for accessing underlying jimage resource entries.\n+     *\n+     * <p>This is only meaningful for use by code dealing directly with jimage\n+     * files, and cannot be used to reliably lookup resources used at runtime.\n+     *\n+     * <p>This API remains valid until the image reader from which it was\n+     * obtained is closed.\n+     *\/\n+    \/\/ Package visible for use by ImageReader.\n+    ResourceEntries getResourceEntries() {\n+        return new ResourceEntries() {\n+            @Override\n+            public Stream<String> entryNamesIn(String module) {\n+                if (module.isEmpty() || module.equals(\"modules\") || module.equals(\"packages\")) {\n+                    throw new IllegalArgumentException(\"Invalid module name: \" + module);\n+                }\n+                return IntStream.range(0, offsets.capacity())\n+                        .map(offsets::get)\n+                        .filter(offset -> offset != 0)\n+                        \/\/ Reusing a location instance or getting the module\n+                        \/\/ offset directly would save a lot of allocations here.\n+                        .mapToObj(offset -> ImageLocation.readFrom(BasicImageReader.this, offset))\n+                        \/\/ Reverse lookup of module offset would be faster here.\n+                        .filter(loc -> module.equals(loc.getModule()))\n+                        .map(ImageLocation::getFullName);\n+            }\n+\n+            private ImageLocation getResourceLocation(String name) {\n+                \/\/ Other types of invalid name just result in no entry being found.\n+                if (name.startsWith(\"\/modules\/\") || name.startsWith(\"\/packages\/\")) {\n+                    throw new IllegalArgumentException(\"Invalid entry name: \" + name);\n+                }\n+                ImageLocation location = BasicImageReader.this.findLocation(name);\n+                if (location == null) {\n+                    throw new NoSuchElementException(\"No such resource entry: \" + name);\n+                }\n+                return location;\n+            }\n+\n+            @Override\n+            public long sizeOf(String name) {\n+                return getResourceLocation(name).getUncompressedSize();\n+            }\n+\n+            @Override\n+            public InputStream open(String name) {\n+                return BasicImageReader.this.getResourceStream(getResourceLocation(name));\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Returns a sorted array of all matching entry names in the jimage file.\n+     *\n+     * <p>Entry names are of one of the following forms:\n+     * <ul>\n+     *     <li>{@code \"\/modules\/<mod-name>\/path\/to\/class-or-resource\"}\n+     *     <li>{@code \"\/<mod-name>\/path\/to\/directory\"}\n+     *     <li>{@code \"\/packages\/<package-name>\"}\n+     * <\/ul>\n+     *\n+     * <p>Note that the module names {@code \"modules\"} or {@code \"packages\"} are\n+     * not representable in a jimage file, so can never exist.\n+     *\n+     * <p>The resulting array is sorted lexicographically, and the resulting\n+     * order need not match that of a breadth or depth first search.\n+     *\n+     * @param matcher a predicate for entry names to be returned.\n+     *\/\n+    public String[] getEntryNames(Predicate<String> matcher) {\n+        int[] attributeOffsets = new int[offsets.capacity()];\n+        offsets.get(attributeOffsets);\n+        return IntStream.of(attributeOffsets)\n+                .filter(o -> o != 0)\n+                .mapToObj(o -> ImageLocation.readFrom(this, o).getFullName())\n+                .filter(matcher)\n+                .sorted()\n+                .toArray(String[]::new);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -233,0 +233,13 @@\n+    \/**\n+     * Returns the \"raw\" API for accessing underlying jimage resource entries.\n+     *\n+     * <p>This is only meaningful for use by code dealing directly with jimage\n+     * files, and cannot be used to reliably lookup resources used at runtime.\n+     *\n+     * <p>This API remains valid until the image reader from which it was\n+     * obtained is closed.\n+     *\/\n+    public ResourceEntries getResourceEntries() {\n+        return reader.getResourceEntries();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+package jdk.internal.jimage;\n+\n+import java.io.InputStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Accesses the underlying resource entries in a jimage file.\n+ *\n+ * <p>This API is designed only for use by the jlink classes, which manipulate\n+ * jimage files directly. For inspection of runtime resources, it is vital that\n+ * {@code previewMode} is correctly observed, making this API unsuitable.\n+ *\n+ * <p>This API ignores the {@code previewMode} of the {@link ImageReader} from\n+ * which it is obtained, and returns an unmapped view of entries (e.g. allowing\n+ * for direct access of resources in the {@code META-INF\/preview\/...} namespace).\n+ *\n+ * <p>It disallows access to resource directories (i.e. {@code \"\/modules\/...\"}\n+ * or packages (i.e. {@code \"\/packages\/...\"}.\n+ *\/\n+public interface ResourceEntries {\n+    \/**\n+     * Returns the full entry names for all resources in the given module, in\n+     * random order. Entry names will always be prefixed by the given module\n+     * name (e.g. \"\/<module-name\/...\").\n+     *\/\n+    Stream<String> entryNamesIn(String module);\n+\n+    \/**\n+     * Returns the (uncompressed) size of a resource given its full entry name.\n+     *\n+     * @throws java.util.NoSuchElementException if the resource does not exist.\n+     *\/\n+    long sizeOf(String name);\n+\n+    \/**\n+     * Returns an {@link InputStream} for a resource given its full entry name.\n+     *\n+     * @throws java.util.NoSuchElementException if the resource does not exist.\n+     *\/\n+    InputStream open(String name);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ResourceEntries.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.Closeable;\n@@ -37,1 +38,1 @@\n-public interface Archive {\n+public interface Archive extends Closeable {\n@@ -62,5 +63,6 @@\n-         * Constructs an entry of the given archive\n-         * @param archive archive\n-         * @param path\n-         * @param name an entry name that does not contain the module name\n-         * @param type\n+         * Constructs an entry of the given archive.\n+         *\n+         * @param archive the archive in which this entry exists.\n+         * @param path the complete path of the entry, including the module.\n+         * @param name an entry name relative to its containing module.\n+         * @param type the entry type.\n@@ -75,4 +77,0 @@\n-        public final Archive archive() {\n-            return archive;\n-        }\n-\n@@ -90,0 +88,5 @@\n+        \/**\n+         * Returns the path of this entry.\n+         *\/\n+        public final String path() {return path;}\n+\n@@ -137,0 +140,1 @@\n+    @Override\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/Archive.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -575,58 +575,0 @@\n-\n-    \/**\n-     * Helper method that splits a Resource path onto 3 items: module, parent\n-     * and resource name.\n-     *\n-     * @param path\n-     * @return An array containing module, parent and name.\n-     *\/\n-    public static String[] splitPath(String path) {\n-        Objects.requireNonNull(path);\n-        String noRoot = path.substring(1);\n-        int pkgStart = noRoot.indexOf(\"\/\");\n-        String module = noRoot.substring(0, pkgStart);\n-        List<String> result = new ArrayList<>();\n-        result.add(module);\n-        String pkg = noRoot.substring(pkgStart + 1);\n-        String resName;\n-        int pkgEnd = pkg.lastIndexOf(\"\/\");\n-        if (pkgEnd == -1) { \/\/ No package.\n-            resName = pkg;\n-        } else {\n-            resName = pkg.substring(pkgEnd + 1);\n-        }\n-\n-        pkg = toPackage(pkg, false);\n-        result.add(pkg);\n-        result.add(resName);\n-\n-        String[] array = new String[result.size()];\n-        return result.toArray(array);\n-    }\n-\n-    \/**\n-     * Returns the path of the resource.\n-     *\/\n-    public static String resourceName(String path) {\n-        Objects.requireNonNull(path);\n-        String s = path.substring(1);\n-        int index = s.indexOf(\"\/\");\n-        return s.substring(index + 1);\n-    }\n-\n-    public static String toPackage(String name) {\n-        return toPackage(name, false);\n-    }\n-\n-    private static String toPackage(String name, boolean log) {\n-        int index = name.lastIndexOf('\/');\n-        if (index > 0) {\n-            return name.substring(0, index).replace('\/', '.');\n-        } else {\n-            \/\/ ## unnamed package\n-            if (log) {\n-                System.err.format(\"Warning: %s in unnamed package%n\", name);\n-            }\n-            return \"\";\n-        }\n-    }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImageFileCreator.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+import jdk.internal.jimage.ResourceEntries;\n+import jdk.internal.jimage.SystemImageReader;\n@@ -66,1 +68,0 @@\n-\n@@ -69,1 +70,1 @@\n-    private final ModuleReference ref;\n+    private final ResourceEntries imageResources;\n@@ -102,6 +103,5 @@\n-        this.ref = ModuleFinder.ofSystem()\n-                               .find(module)\n-                               .orElseThrow(() ->\n-                                    new IllegalArgumentException(\n-                                            \"Module \" + module +\n-                                            \" not part of the JDK install\"));\n+        ModuleFinder.ofSystem()\n+                .find(module)\n+                .orElseThrow(() -> new IllegalArgumentException(\n+                        \"Module \" + module + \" not part of the JDK install\"));\n+        this.imageResources = SystemImageReader.get().getResourceEntries();\n@@ -162,0 +162,11 @@\n+    private boolean isNormalOrModifiedDiff(String name) {\n+        ResourceDiff rd = resDiff.get(name);\n+        \/\/ Filter all resources with a resource diff of kind MODIFIED.\n+        \/\/ Note that REMOVED won't happen since in that case the module listing\n+        \/\/ won't have the resource anyway.\n+        \/\/ Note as well that filter removes files of kind ADDED. Those files are\n+        \/\/ not in the packaged modules, so ought not to get returned from the\n+        \/\/ pipeline.\n+        return (rd == null || rd.getKind() == ResourceDiff.Kind.MODIFIED);\n+    }\n+\n@@ -165,0 +176,1 @@\n+\n@@ -167,25 +179,6 @@\n-            files.addAll(ref.open().list()\n-                                   .filter(i -> {\n-                                           String lookupKey = String.format(\"\/%s\/%s\", module, i);\n-                                           ResourceDiff rd = resDiff.get(lookupKey);\n-                                           \/\/ Filter all resources with a resource diff\n-                                           \/\/ that are of kind MODIFIED.\n-                                           \/\/ Note that REMOVED won't happen since in\n-                                           \/\/ that case the module listing won't have\n-                                           \/\/ the resource anyway.\n-                                           \/\/ Note as well that filter removes files\n-                                           \/\/ of kind ADDED. Those files are not in\n-                                           \/\/ the packaged modules, so ought not to\n-                                           \/\/ get returned from the pipeline.\n-                                           return (rd == null ||\n-                                                   rd.getKind() == ResourceDiff.Kind.MODIFIED);\n-                                   })\n-                                   .map(s -> {\n-                                           String lookupKey = String.format(\"\/%s\/%s\", module, s);\n-                                           return new JRTArchiveFile(JRTArchive.this, s,\n-                                                           EntryType.CLASS_OR_RESOURCE,\n-                                                           null \/* hashOrTarget *\/,\n-                                                           false \/* symlink *\/,\n-                                                           resDiff.get(lookupKey));\n-                                   })\n-                                   .toList());\n+            imageResources.entryNamesIn(module)\n+                    .filter(this::isNormalOrModifiedDiff)\n+                    .sorted()\n+                    .map(name -> new JrtModuleFile(this, name, resDiff.get(name)))\n+                    .forEach(files::add);\n+\n@@ -195,13 +188,3 @@\n-                                         .filter(rd -> rd.getKind() == ResourceDiff.Kind.REMOVED)\n-                                         .map(s -> {\n-                                                 int secondSlash = s.getName().indexOf(\"\/\", 1);\n-                                                 assert secondSlash != -1;\n-                                                 String pathWithoutModule = s.getName().substring(secondSlash + 1);\n-                                                 return new JRTArchiveFile(JRTArchive.this,\n-                                                         pathWithoutModule,\n-                                                         EntryType.CLASS_OR_RESOURCE,\n-                                                         null  \/* hashOrTarget *\/,\n-                                                         false \/* symlink *\/,\n-                                                         s);\n-                                         })\n-                                         .toList());\n+                    .filter(rd -> rd.getKind() == ResourceDiff.Kind.REMOVED)\n+                    .map(rd -> new JrtModuleFile(this, rd.getName(), rd))\n+                    .toList());\n@@ -237,9 +220,4 @@\n-                        return new JRTArchiveFile(JRTArchive.this,\n-                                                  m.resPath,\n-                                                  toEntryType(m.resType),\n-                                                  m.hashOrTarget,\n-                                                  m.symlink,\n-                                                  \/* diff only for resources *\/\n-                                                  null);\n-                 })\n-                 .toList());\n+                        return new JrtOtherFile(\n+                                this, m.resPath, toEntryType(m.resType), m.hashOrTarget, m.symlink);\n+                    })\n+                    .toList());\n@@ -327,1 +305,1 @@\n-         *  line: <int>|<int>|<hashOrTarget>|<path>\n+         *  line: {@code <int>|<int>|<hashOrTarget>|<path>}\n@@ -329,1 +307,1 @@\n-         *  Take the integer before '|' convert it to a Type. The second\n+         *  <p>Take the integer before {@code '|'} convert it to a Type. The second\n@@ -440,6 +418,55 @@\n-    record JRTArchiveFile(Archive archive,\n-                          String resPath,\n-                          EntryType resType,\n-                          String sha,\n-                          boolean symlink,\n-                          ResourceDiff diff) implements JRTFile {\n+    record JrtModuleFile(\n+            JRTArchive archive,\n+            String resPath,\n+            ResourceDiff diff) implements JRTFile {\n+        @Override\n+        public Entry toEntry() {\n+            assert resPath.startsWith(\"\/\" + archive.moduleName() + \"\/\");\n+            String resName = resPath.substring(archive.moduleName().length() + 2);\n+\n+            \/\/ If the resource has a diff to the packaged modules, use the diff.\n+            \/\/ Diffs of kind ADDED have been filtered out in collectFiles();\n+            if (diff != null) {\n+                assert diff.getKind() != ResourceDiff.Kind.ADDED;\n+                assert diff.getName().equals(resPath);\n+\n+                return new Entry(archive, resPath, resName, EntryType.CLASS_OR_RESOURCE) {\n+                    @Override\n+                    public long size() {\n+                        return diff.getResourceBytes().length;\n+                    }\n+                    @Override\n+                    public InputStream stream() {\n+                        return new ByteArrayInputStream(diff.getResourceBytes());\n+                    }\n+                };\n+            } else {\n+                return new Entry(archive, resPath, resName, EntryType.CLASS_OR_RESOURCE) {\n+                    @Override\n+                    public long size() {\n+                        return archive.imageResources.sizeOf(path());\n+                    }\n+\n+                    @Override\n+                    public InputStream stream() {\n+                        return archive.imageResources.open(path());\n+                    }\n+                };\n+            }\n+        }\n+    }\n+\n+    record JrtOtherFile(\n+            JRTArchive archive,\n+            String resPath,\n+            EntryType resType,\n+            String sha,\n+            boolean symlink) implements JRTFile {\n+\n+        \/\/ Read from the base JDK image, special casing\n+        \/\/ symlinks, which have the link target in the\n+        \/\/ hashOrTarget field.\n+        Path targetPath() {\n+            return BASE.resolve(symlink ? sha : resPath);\n+        }\n+\n@@ -447,6 +474,8 @@\n-            return new Entry(archive,\n-                             String.format(\"\/%s\/%s\",\n-                                           archive.moduleName(),\n-                                           resPath),\n-                             resPath,\n-                             resType) {\n+            assert resType != EntryType.CLASS_OR_RESOURCE;\n+\n+            return new Entry(\n+                    archive,\n+                    String.format(\"\/%s\/%s\", archive.moduleName(), resPath),\n+                    resPath,\n+                    resType) {\n+\n@@ -456,25 +485,1 @@\n-                        if (resType != EntryType.CLASS_OR_RESOURCE) {\n-                            \/\/ Read from the base JDK image, special casing\n-                            \/\/ symlinks, which have the link target in the\n-                            \/\/ hashOrTarget field\n-                            if (symlink) {\n-                                return Files.size(BASE.resolve(sha));\n-                            }\n-                            return Files.size(BASE.resolve(resPath));\n-                        } else {\n-                            if (diff != null) {\n-                                \/\/ If the resource has a diff to the\n-                                \/\/ packaged modules, use the diff. Diffs of kind\n-                                \/\/ ADDED have been filtered out in collectFiles();\n-                                assert diff.getKind() != ResourceDiff.Kind.ADDED;\n-                                assert diff.getName().equals(String.format(\"\/%s\/%s\",\n-                                                                           archive.moduleName(),\n-                                                                           resPath));\n-                                return diff.getResourceBytes().length;\n-                            }\n-                            \/\/ Read from the module image. This works, because\n-                            \/\/ the underlying base path is a JrtPath with the\n-                            \/\/ JrtFileSystem underneath which is able to handle\n-                            \/\/ this size query.\n-                            return Files.size(archive.getPath().resolve(resPath));\n-                        }\n+                        return Files.size(targetPath());\n@@ -488,20 +493,1 @@\n-                    if (resType != EntryType.CLASS_OR_RESOURCE) {\n-                        \/\/ Read from the base JDK image.\n-                        Path path = symlink ? BASE.resolve(sha) : BASE.resolve(resPath);\n-                        return Files.newInputStream(path);\n-                    } else {\n-                        \/\/ Read from the module image. Use the diff to the\n-                        \/\/ packaged modules if we have one. Diffs of kind\n-                        \/\/ ADDED have been filtered out in collectFiles();\n-                        if (diff != null) {\n-                            assert diff.getKind() != ResourceDiff.Kind.ADDED;\n-                            assert diff.getName().equals(String.format(\"\/%s\/%s\",\n-                                                                       archive.moduleName(),\n-                                                                       resPath));\n-                            return new ByteArrayInputStream(diff.getResourceBytes());\n-                        }\n-                        String module = archive.moduleName();\n-                        ModuleReference mRef = ModuleFinder.ofSystem()\n-                                                    .find(module).orElseThrow();\n-                        return mRef.open().open(resPath).orElseThrow();\n-                    }\n+                    return Files.newInputStream(targetPath());\n@@ -509,1 +495,0 @@\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JRTArchive.java","additions":100,"deletions":115,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -352,15 +352,16 @@\n-        ImageProvider imageProvider =\n-                createImageProvider(config,\n-                                    null,\n-                                    IGNORE_SIGNING_DEFAULT,\n-                                    false,\n-                                    null,\n-                                    false,\n-                                    new OptionsValues(),\n-                                    null);\n-\n-        \/\/ Then create the Plugin Stack\n-        ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(plugins);\n-\n-        \/\/Ask the stack to proceed;\n-        stack.operate(imageProvider);\n+        try (ImageHelper imageProvider =\n+                     createImageProvider(config,\n+                             null,\n+                             IGNORE_SIGNING_DEFAULT,\n+                             false,\n+                             null,\n+                             false,\n+                             new OptionsValues(),\n+                             null)) {\n+\n+            \/\/ Then create the Plugin Stack\n+            ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(plugins);\n+\n+            \/\/Ask the stack to proceed;\n+            stack.operate(imageProvider);\n+        }\n@@ -489,16 +490,19 @@\n-        ImageHelper imageProvider = createImageProvider(config,\n-                                                        options.packagedModulesPath,\n-                                                        options.ignoreSigning,\n-                                                        options.bindServices,\n-                                                        options.endian,\n-                                                        options.verbose,\n-                                                        options,\n-                                                        log);\n-\n-        \/\/ Then create the Plugin Stack\n-        ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(\n-            taskHelper.getPluginsConfig(options.output, options.launchers,\n-                    imageProvider.targetPlatform));\n-\n-        \/\/Ask the stack to proceed\n-        stack.operate(imageProvider);\n+        try (ImageHelper imageProvider = createImageProvider(config,\n+                options.packagedModulesPath,\n+                options.ignoreSigning,\n+                options.bindServices,\n+                options.endian,\n+                options.verbose,\n+                options,\n+                log)) {\n+            \/\/ Then create the Plugin Stack\n+            ImagePluginStack stack = ImagePluginConfiguration.parseConfiguration(\n+                    taskHelper.getPluginsConfig(\n+                            options.output,\n+                            options.launchers,\n+                            imageProvider.targetPlatform));\n+\n+            \/\/Ask the stack to proceed\n+            stack.operate(imageProvider);\n+        }\n+\n@@ -1030,4 +1034,5 @@\n-    private static record ImageHelper(Set<Archive> archives,\n-                                      Platform targetPlatform,\n-                                      Path packagedModulesPath,\n-                                      boolean generateRuntimeImage) implements ImageProvider {\n+    private record ImageHelper(Set<Archive> archives,\n+                               Platform targetPlatform,\n+                               Path packagedModulesPath,\n+                               boolean generateRuntimeImage)\n+            implements ImageProvider, AutoCloseable {\n@@ -1049,0 +1054,7 @@\n+\n+        @Override\n+        public void close() throws IOException {\n+            for (Archive archive : archives) {\n+                archive.close();\n+            }\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":47,"deletions":35,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -69,13 +69,0 @@\n-    \/**\n-     * Returns true if a resource is located in a named package.\n-     *\/\n-    public static boolean isNamedPackageResource(String name) {\n-        int index = name.lastIndexOf(\"\/\");\n-        if (index == -1) {\n-            return false;\n-        } else {\n-            String pn = name.substring(0, index).replace('\/', '.');\n-            return Checks.isPackageName(pn);\n-        }\n-    }\n-\n@@ -83,0 +70,1 @@\n+        private static final String PREVIEW_PREFIX = \"META-INF\/preview\/\";\n@@ -135,10 +123,2 @@\n-                .filter(m -> m.type() == ResourcePoolEntry.Type.CLASS_OR_RESOURCE)\n-                .forEach(res -> {\n-                    String name = ImageFileCreator.resourceName(res.path());\n-                    if (isNamedPackageResource(name)) {\n-                        String pkg = ImageFileCreator.toPackage(name);\n-                        if (!pkg.isEmpty()) {\n-                            pkgs.add(pkg);\n-                        }\n-                    }\n-                });\n+                    .filter(m -> m.type() == ResourcePoolEntry.Type.CLASS_OR_RESOURCE)\n+                    .forEach(res -> inferPackageName(res).ifPresent(pkgs::add));\n@@ -162,0 +142,33 @@\n+\n+        \/**\n+         * Returns a valid non-empty package name, inferred from a resource pool\n+         * entry's path.\n+         *\n+         * <p>If the resource pool entry is for a preview resource (i.e. with\n+         * path {@code \"\/mod-name\/META-INF\/preview\/pkg-path\/resource-name\"})\n+         * the package name is the non-preview name based on {@code \"pkg-path\"}.\n+         *\n+         * @return the inferred package name, or {@link Optional#empty() empty}\n+         *     if no name could be inferred.\n+         *\/\n+        private static Optional<String> inferPackageName(ResourcePoolEntry res) {\n+            \/\/ Expect entry paths to be \"\/mod-name\/pkg-path\/resource-name\", but\n+            \/\/ may also get \"\/mod-name\/META-INF\/preview\/pkg-path\/resource-name\"\n+            String name = res.path();\n+            if (name.charAt(0) == '\/') {\n+                int pkgStart = name.indexOf('\/', 1) + 1;\n+                int pkgEnd = name.lastIndexOf('\/');\n+                if (pkgStart > 0 && pkgEnd > pkgStart) {\n+                    String pkgPath = name.substring(pkgStart, pkgEnd);\n+                    \/\/ Handle preview paths by removing the prefix.\n+                    if (pkgPath.startsWith(PREVIEW_PREFIX)) {\n+                        pkgPath = pkgPath.substring(PREVIEW_PREFIX.length());\n+                    }\n+                    String pkgName = pkgPath.replace('\/', '.');\n+                    if (Checks.isPackageName(pkgName)) {\n+                        return Optional.of(pkgName);\n+                    }\n+                }\n+            }\n+            return Optional.empty();\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ResourcePoolManager.java","additions":36,"deletions":23,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -24,10 +24,0 @@\n-\/*\n- * @test\n- * @summary Test a pool containing jimage resources and classes.\n- * @author Jean-Francois Denise\n- * @modules jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- * @run build ResourcePoolTest\n- * @run main ResourcePoolTest\n- *\/\n-\n@@ -37,1 +27,0 @@\n-import java.util.HashSet;\n@@ -39,0 +28,1 @@\n+import java.util.Map;\n@@ -46,0 +36,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -47,11 +38,5 @@\n-public class ResourcePoolTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        new ResourcePoolTest().test();\n-    }\n-\n-    public void test() throws Exception {\n-        checkResourceAdding();\n-        checkResourceVisitor();\n-        checkResourcesAfterCompression();\n-    }\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -59,0 +44,9 @@\n+\/*\n+ * @test\n+ * @summary Test a pool containing jimage resources and classes.\n+ * @author Jean-Francois Denise\n+ * @modules jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jlink.plugin\n+ * @run junit ResourcePoolTest\n+ *\/\n+public class ResourcePoolTest {\n@@ -61,1 +55,2 @@\n-    private void checkResourceVisitor() throws Exception {\n+    @Test\n+    public void resourceVisitor() throws Exception {\n@@ -72,11 +67,3 @@\n-        if (visitor.getAmountBefore() == 0) {\n-            throw new AssertionError(\"Resources not found\");\n-        }\n-        if (visitor.getAmountBefore() != input.entryCount()) {\n-            throw new AssertionError(\"Number of visited resources. Expected: \" +\n-                    visitor.getAmountBefore() + \", got: \" + input.entryCount());\n-        }\n-        if (visitor.getAmountAfter() != output.entryCount()) {\n-            throw new AssertionError(\"Number of added resources. Expected: \" +\n-                    visitor.getAmountAfter() + \", got: \" + output.entryCount());\n-        }\n+        assertNotEquals(0, visitor.getAmountBefore(), \"Resources not found\");\n+        assertEquals(visitor.getAmountBefore(), input.entryCount(), \"Number of visited resources\");\n+        assertEquals(visitor.getAmountAfter(), output.entryCount(), \"Number of added resources\");\n@@ -85,3 +72,1 @@\n-            if (!input.findEntry(path).isPresent()) {\n-                throw new AssertionError(\"Unknown resource: \" + path);\n-            }\n+            assertTrue(input.findEntry(path).isPresent(), \"Unknown resource: \" + path);\n@@ -120,8 +105,5 @@\n-    private void checkResourceAdding() {\n-        List<String> samples = new ArrayList<>();\n-        samples.add(\"java.base\");\n-        samples.add(\"java\/lang\/Object\");\n-        samples.add(\"java.base\");\n-        samples.add(\"java\/lang\/String\");\n-        samples.add(\"java.management\");\n-        samples.add(\"javax\/management\/ObjectName\");\n+    @Test\n+    public void resourceAdding() {\n+        Map<String, List<String>> samples = Map.of(\n+                \"java.base\", List.of(\"java\/lang\/Object\", \"java\/lang\/String\"),\n+                \"java.management\", List.of(\"javax\/management\/ObjectName\"));\n@@ -147,22 +129,9 @@\n-    private void test(List<String> samples, ResourceAdder adder) {\n-        if (samples.isEmpty()) {\n-            throw new AssertionError(\"No sample to test\");\n-        }\n-        ResourcePoolManager resources = new ResourcePoolManager();\n-        Set<String> modules = new HashSet<>();\n-        for (int i = 0; i < samples.size(); i++) {\n-            String module = samples.get(i);\n-            modules.add(module);\n-            i++;\n-            String clazz = samples.get(i);\n-            String path = \"\/\" + module + \"\/\" + clazz + \".class\";\n-            adder.add(resources, module, path);\n-        }\n-        for (int i = 0; i < samples.size(); i++) {\n-            String module = samples.get(i);\n-            i++;\n-            String clazz = samples.get(i);\n-            String path = \"\/\" + module + \"\/\" + clazz + \".class\";\n-            Optional<ResourcePoolEntry> res = resources.findEntry(path);\n-            if (!res.isPresent()) {\n-                throw new AssertionError(\"Resource not found \" + path);\n+    @Test\n+    public void packageInference() {\n+        Map<String, List<String>> samples = Map.of(\n+                \"java.base\", List.of(\"NoPackage\", \"java\/lang\/String\", \"java\/util\/List\"));\n+        ResourcePoolManager manager = test(samples, (resources, module, path) -> {\n+            try {\n+                resources.add(ResourcePoolEntry.create(path, new byte[0]));\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n@@ -170,3 +139,22 @@\n-            checkModule(resources.resourcePool(), res.get());\n-            if (resources.findEntry(clazz).isPresent()) {\n-                throw new AssertionError(\"Resource found \" + clazz);\n+        });\n+\n+        Optional<ResourcePoolModule> modBase = manager.moduleView().findModule(\"java.base\");\n+        assertTrue(modBase.isPresent());\n+        \/\/ Empty packages are not included (and should normally not exist).\n+        assertEquals(Set.of(\"java.lang\", \"java.util\"), modBase.get().packages());\n+    }\n+\n+    @Test\n+    public void packageInference_previewOnly() {\n+        Map<String, List<String>> samples = Map.of(\n+                \"java.base\", List.of(\n+                        \"java\/lang\/Object\",\n+                        \"java\/lang\/String\",\n+                        \"java\/util\/List\",\n+                        \"META-INF\/preview\/java\/lang\/String\",\n+                        \"META-INF\/preview\/java\/extra\/PreviewOnly\"));\n+        ResourcePoolManager manager = test(samples, (resources, module, path) -> {\n+            try {\n+                resources.add(ResourcePoolEntry.create(path, new byte[0]));\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n@@ -174,4 +162,32 @@\n-        }\n-        if (resources.entryCount() != samples.size() \/ 2) {\n-            throw new AssertionError(\"Invalid number of resources\");\n-        }\n+        });\n+\n+        Optional<ResourcePoolModule> modBase = manager.moduleView().findModule(\"java.base\");\n+        assertTrue(modBase.isPresent());\n+        \/\/ Preview only package is included, and no packages start with 'META-INF'.\n+        assertEquals(Set.of(\"java.lang\", \"java.util\", \"java.extra\"), modBase.get().packages());\n+        \/\/ But the preview resources exist in the META-INF\/preview namespace.\n+        assertTrue(modBase.get().findEntry(\"\/java.base\/META-INF\/preview\/java\/extra\/PreviewOnly.class\").isPresent());\n+    }\n+\n+    private ResourcePoolManager test(Map<String, List<String>> samples, ResourceAdder adder) {\n+        assertFalse(samples.isEmpty(), \"No sample to test\");\n+        ResourcePoolManager resources = new ResourcePoolManager();\n+        samples.forEach((module, clazzes) -> {\n+            clazzes.forEach(clazz -> {\n+                String path = \"\/\" + module + \"\/\" + clazz + \".class\";\n+                adder.add(resources, module, path);\n+            });\n+        });\n+        samples.forEach((module, clazzes) -> {\n+            clazzes.forEach(clazz -> {\n+                String path = \"\/\" + module + \"\/\" + clazz + \".class\";\n+                Optional<ResourcePoolEntry> res = resources.findEntry(path);\n+                assertTrue(res.isPresent(), \"Resource not found \" + path);\n+                checkModule(resources.resourcePool(), res.get());\n+                assertTrue(resources.findEntry(clazz).isEmpty(), \"Resource found \" + clazz);\n+            });\n+        });\n+        long resourcesCount = samples.values().stream().mapToInt(List::size).sum();\n+        assertEquals(resourcesCount, resources.entryCount(), \"Invalid number of resources\");\n+        assertEquals(samples.size(), resources.moduleCount(), \"Invalid number of modules\");\n+        return resources;\n@@ -182,3 +198,1 @@\n-        if (!optMod.isPresent()) {\n-            throw new AssertionError(\"No module \" + res.moduleName());\n-        }\n+        assertTrue(optMod.isPresent(), \"No module \" + res.moduleName());\n@@ -186,7 +200,3 @@\n-        if (!m.name().equals(res.moduleName())) {\n-            throw new AssertionError(\"Not right module name \" + res.moduleName());\n-        }\n-        if (!m.findEntry(res.path()).isPresent()) {\n-            throw new AssertionError(\"resource \" + res.path()\n-                    + \" not in module \" + m.name());\n-        }\n+        assertEquals(res.moduleName(), m.name(), \"Not right module name \" + res.moduleName());\n+        assertTrue(m.findEntry(res.path()).isPresent(),\n+                \"resource \" + res.path() + \" not in module \" + m.name());\n@@ -195,1 +205,2 @@\n-    private void checkResourcesAfterCompression() throws Exception {\n+    @Test\n+    public void resourcesAfterCompression() throws Exception {\n@@ -218,22 +229,6 @@\n-            if (!resources.contains(res)) {\n-                throw new AssertionError(\"Resource not found: \" + res);\n-            }\n-\n-            if (!resources.findEntry(res.path()).isPresent()) {\n-                throw new AssertionError(\"Resource not found: \" + res);\n-            }\n-\n-            if (!modules.contains(res.moduleName())) {\n-                throw new AssertionError(\"Module not found: \" + res.moduleName());\n-            }\n-\n-            if (!resources.contains(res)) {\n-                throw new AssertionError(\"Resources not found: \" + res);\n-            }\n-\n-            try {\n-                resources.add(res);\n-                throw new AssertionError(res + \" already present, but an exception is not thrown\");\n-            } catch (Exception ex) {\n-                \/\/ Expected\n-            }\n+            assertTrue(resources.contains(res), \"Resource not found: \" + res);\n+            assertTrue(resources.findEntry(res.path()).isPresent(), \"Resource not found: \" + res);\n+            assertTrue(modules.contains(res.moduleName()), \"Module not found: \" + res.moduleName());\n+            assertTrue(modules.contains(res.moduleName()), \"Module not found: \" + res.moduleName());\n+            assertThrows(RuntimeException.class, () -> resources.add(res),\n+                    res + \" already present, but an exception is not thrown\");\n@@ -242,6 +237,3 @@\n-        try {\n-            resources.add(ResourcePoolEntry.create(\"\/module2\/toto1\", new byte[0]));\n-            throw new AssertionError(\"ResourcePool is read-only, but an exception is not thrown\");\n-        } catch (Exception ex) {\n-            \/\/ Expected\n-        }\n+        ResourcePoolEntry toAdd = ResourcePoolEntry.create(\"\/module2\/toto1\", new byte[0]);\n+        assertThrows(RuntimeException.class, () -> resources.add(toAdd),\n+                \"ResourcePool is read-only, but an exception is not thrown\");\n","filename":"test\/jdk\/tools\/jlink\/ResourcePoolTest.java","additions":105,"deletions":113,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.stream.Collectors;\n@@ -50,0 +51,1 @@\n+ *          jdk.jlink\n@@ -52,1 +54,1 @@\n- * @run main\/othervm\/timeout=1200 -Xmx1g PackagedModulesVsRuntimeImageLinkTest\n+ * @run main\/othervm\/timeout=1200 -ea -esa -DDISABLE_PREVIEW_PATCHING=false -Xmx1g PackagedModulesVsRuntimeImageLinkTest\n@@ -73,1 +75,0 @@\n-\n@@ -123,3 +124,2 @@\n-        if (jimageContentJmodLess.size() != jimageContentJmodFull.size()) {\n-            throw new AssertionError(String.format(\"Size of jimage content differs for jmod-less (%d) v. jmod-full (%d)\", jimageContentJmodLess.size(), jimageContentJmodFull.size()));\n-        }\n+        assertSameContent(\"jmod-less\", jimageContentJmodLess, \"jmod-full\", jimageContentJmodFull);\n+        \/\/ Both lists are same size, with same names, so enumerate either.\n@@ -148,0 +148,41 @@\n+    \/\/ Helper to assert the content of two jimage files are the same and provide\n+    \/\/ useful debug information otherwise.\n+    private static void assertSameContent(\n+            String lhsLabel, List<String> lhsNames, String rhsLabel, List<String> rhsNames) {\n+        int lhsSize = lhsNames.size();\n+        int rhsSize = rhsNames.size();\n+        \/\/ Both input lists are sorted, enumerate the differences for debugging.\n+        List<String> lhsOnly = new ArrayList<>();\n+        List<String> rhsOnly = new ArrayList<>();\n+        int i = 0;\n+        int j = 0;\n+        while (i < lhsSize && j < rhsSize) {\n+            String lhsName = lhsNames.get(i);\n+            String rhsName = rhsNames.get(j);\n+            int signum = lhsName.compareTo(rhsName);\n+            if (signum == 0) {\n+                i += 1;\n+                j += 1;\n+            } else if (signum < 0) {\n+                lhsOnly.add(lhsName);\n+                i += 1;\n+            } else {\n+                rhsOnly.add(rhsName);\n+                j += 1;\n+            }\n+        }\n+        lhsOnly.addAll(lhsNames.subList(i, lhsSize));\n+        rhsOnly.addAll(rhsNames.subList(j, rhsSize));\n+        if (!lhsOnly.isEmpty() || !rhsOnly.isEmpty()) {\n+            String message = String.format(\n+                    \"jimage content differs for %s (%d) v. %s (%d)\", lhsLabel, lhsSize, rhsLabel, rhsSize);\n+            if (!lhsOnly.isEmpty()) {\n+                message += \"\\nOnly in \" + lhsLabel + \":\\n\\t\" + String.join(\"\\n\\t\", lhsOnly);\n+            }\n+            if (!rhsOnly.isEmpty()) {\n+                message += \"\\nOnly in \" + rhsLabel + \":\\n\\t\" + String.join(\"\\n\\t\", rhsOnly);\n+            }\n+            throw new AssertionError(message);\n+        }\n+    }\n+\n@@ -149,1 +190,7 @@\n-        return path.startsWith(\"\/packages\") || path.startsWith(\"\/modules\");\n+        return pathStartsWith(path, \"\/packages\") || pathStartsWith(path, \"\/modules\");\n+    }\n+\n+    \/\/ Handle both \"<prefix>\" and \"<prefix>\/...\".\n+    private static boolean pathStartsWith(String path, String prefix) {\n+        int plen = prefix.length();\n+        return path.startsWith(prefix) && (path.length() == plen || path.charAt(plen) == '\/');\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PackagedModulesVsRuntimeImageLinkTest.java","additions":53,"deletions":6,"binary":false,"changes":59,"status":"modified"}]}