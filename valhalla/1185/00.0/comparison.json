{"files":[{"patch":"@@ -16498,0 +16498,1 @@\n+  predicate(LockingMode != LM_LIGHTWEIGHT);\n@@ -16501,3 +16502,1 @@\n-  \/\/ TODO\n-  \/\/ identify correct cost\n-  format %{ \"fastlock $object,$box\\t! kills $tmp,$tmp2\" %}\n+  format %{ \"fastlock $object,$box\\t! kills $tmp,$tmp2,$tmp3\" %}\n@@ -16515,0 +16514,1 @@\n+  predicate(LockingMode != LM_LIGHTWEIGHT);\n@@ -16528,0 +16528,31 @@\n+instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)\n+%{\n+  predicate(LockingMode == LM_LIGHTWEIGHT);\n+  match(Set cr (FastLock object box));\n+  effect(TEMP tmp, TEMP tmp2);\n+\n+  ins_cost(5 * INSN_COST);\n+  format %{ \"fastlock $object,$box\\t! kills $tmp,$tmp2\" %}\n+\n+  ins_encode %{\n+    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n+\n+  ins_pipe(pipe_serial);\n+%}\n+\n+instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)\n+%{\n+  predicate(LockingMode == LM_LIGHTWEIGHT);\n+  match(Set cr (FastUnlock object box));\n+  effect(TEMP tmp, TEMP tmp2);\n+\n+  ins_cost(5 * INSN_COST);\n+  format %{ \"fastunlock $object,$box\\t! kills $tmp, $tmp2\" %}\n+\n+  ins_encode %{\n+    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n+\n+  ins_pipe(pipe_serial);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,2 +85,0 @@\n-  \/\/ Load object header\n-  ldr(hdr, Address(obj, hdr_offset));\n@@ -91,0 +89,2 @@\n+    \/\/ Load object header\n+    ldr(hdr, Address(obj, hdr_offset));\n@@ -155,5 +155,0 @@\n-    ldr(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n-    \/\/ We cannot use tbnz here, the target might be too far away and cannot\n-    \/\/ be encoded.\n-    tst(hdr, markWord::monitor_value);\n-    br(Assembler::NE, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -81,0 +82,1 @@\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_lock_lightweight\");\n@@ -99,1 +101,2 @@\n-  } else if (LockingMode == LM_LEGACY) {\n+  } else {\n+    assert(LockingMode == LM_LEGACY, \"must be\");\n@@ -133,4 +136,0 @@\n-  } else {\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-    lightweight_lock(oop, disp_hdr, tmp, tmp3Reg, no_count);\n-    b(count);\n@@ -150,8 +149,7 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-    \/\/ lock. The fast-path monitor unlock code checks for\n-    \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-    \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n-    mov(tmp, (address)markWord::unused_mark().value());\n-    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-  }\n+  \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n+  \/\/ lock. The fast-path monitor unlock code checks for\n+  \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n+  \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n+  mov(tmp, (address)markWord::unused_mark().value());\n+  str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n@@ -188,0 +186,1 @@\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_unlock_lightweight\");\n@@ -206,1 +205,2 @@\n-  } else if (LockingMode == LM_LEGACY) {\n+  } else {\n+    assert(LockingMode == LM_LEGACY, \"must be\");\n@@ -214,4 +214,0 @@\n-  } else {\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-    lightweight_unlock(oop, tmp, box, disp_hdr, no_count);\n-    b(count);\n@@ -227,13 +223,0 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n-    Register tmp2 = disp_hdr;\n-    ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n-    \/\/ We cannot use tbnz here, the target might be too far away and cannot\n-    \/\/ be encoded.\n-    tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n-    C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n-    Compile::current()->output()->add_stub(stub);\n-    br(Assembler::NE, stub->entry());\n-    bind(stub->continuation());\n-  }\n-\n@@ -272,0 +255,256 @@\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register t1,\n+                                              Register t2, Register t3) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert_different_registers(obj, t1, t2, t3);\n+\n+  \/\/ Handle inflated monitor.\n+  Label inflated;\n+  \/\/ Finish fast lock successfully. MUST branch to with flag == EQ\n+  Label locked;\n+  \/\/ Finish fast lock unsuccessfully. MUST branch to with flag == NE\n+  Label slow_path;\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(t1, obj);\n+    ldrw(t1, Address(t1, Klass::access_flags_offset()));\n+    tstw(t1, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    br(Assembler::NE, slow_path);\n+  }\n+\n+  const Register t1_mark = t1;\n+\n+  { \/\/ Lightweight locking\n+\n+    \/\/ Push lock to the lock stack and finish successfully. MUST branch to with flag == EQ\n+    Label push;\n+\n+    const Register t2_top = t2;\n+    const Register t3_t = t3;\n+\n+    \/\/ Check if lock-stack is full.\n+    ldrw(t2_top, Address(rthread, JavaThread::lock_stack_top_offset()));\n+    cmpw(t2_top, (unsigned)LockStack::end_offset() - 1);\n+    br(Assembler::GT, slow_path);\n+\n+    \/\/ Check if recursive.\n+    subw(t3_t, t2_top, oopSize);\n+    ldr(t3_t, Address(rthread, t3_t));\n+    cmp(obj, t3_t);\n+    br(Assembler::EQ, push);\n+\n+    \/\/ Relaxed normal load to check for monitor. Optimization for monitor case.\n+    ldr(t1_mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    tbnz(t1_mark, exact_log2(markWord::monitor_value), inflated);\n+\n+    \/\/ Not inflated\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"required to avoid a lea\");\n+\n+    \/\/ Try to lock. Transition lock-bits 0b01 => 0b00\n+    orr(t1_mark, t1_mark, markWord::unlocked_value);\n+    eor(t3_t, t1_mark, markWord::unlocked_value);\n+    cmpxchg(\/*addr*\/ obj, \/*expected*\/ t1_mark, \/*new*\/ t3_t, Assembler::xword,\n+            \/*acquire*\/ true, \/*release*\/ false, \/*weak*\/ false, noreg);\n+    br(Assembler::NE, slow_path);\n+\n+    bind(push);\n+    \/\/ After successful lock, push object on lock-stack.\n+    str(obj, Address(rthread, t2_top));\n+    addw(t2_top, t2_top, oopSize);\n+    strw(t2_top, Address(rthread, JavaThread::lock_stack_top_offset()));\n+    b(locked);\n+  }\n+\n+  { \/\/ Handle inflated monitor.\n+    bind(inflated);\n+\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register t1_tagged_monitor = t1_mark;\n+    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register t2_owner_addr = t2;\n+    const Register t3_owner = t3;\n+\n+    \/\/ Compute owner address.\n+    lea(t2_owner_addr, Address(t1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+\n+    \/\/ CAS owner (null => current thread).\n+    cmpxchg(t2_owner_addr, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+            \/*release*\/ false, \/*weak*\/ false, t3_owner);\n+    br(Assembler::EQ, locked);\n+\n+    \/\/ Check if recursive.\n+    cmp(t3_owner, rthread);\n+    br(Assembler::NE, slow_path);\n+\n+    \/\/ Recursive.\n+    increment(Address(t1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1);\n+  }\n+\n+  bind(locked);\n+  increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+#ifdef ASSERT\n+  \/\/ Check that locked label is reached with Flags == EQ.\n+  Label flag_correct;\n+  br(Assembler::EQ, flag_correct);\n+  stop(\"Fast Lock Flag != EQ\");\n+#endif\n+\n+  bind(slow_path);\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with Flags == NE.\n+  br(Assembler::NE, flag_correct);\n+  stop(\"Fast Lock Flag != NE\");\n+  bind(flag_correct);\n+#endif\n+  \/\/ C2 uses the value of Flags (NE vs EQ) to determine the continuation.\n+}\n+\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register t1, Register t2,\n+                                                Register t3) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert_different_registers(obj, t1, t2, t3);\n+\n+  \/\/ Handle inflated monitor.\n+  Label inflated, inflated_load_monitor;\n+  \/\/ Finish fast unlock successfully. MUST branch to with flag == EQ\n+  Label unlocked;\n+  \/\/ Finish fast unlock unsuccessfully. MUST branch to with flag == NE\n+  Label slow_path;\n+\n+  const Register t1_mark = t1;\n+  const Register t2_top = t2;\n+  const Register t3_t = t3;\n+\n+  { \/\/ Lightweight unlock\n+\n+    \/\/ Check if obj is top of lock-stack.\n+    ldrw(t2_top, Address(rthread, JavaThread::lock_stack_top_offset()));\n+    subw(t2_top, t2_top, oopSize);\n+    ldr(t3_t, Address(rthread, t2_top));\n+    cmp(obj, t3_t);\n+    \/\/ Top of lock stack was not obj. Must be monitor.\n+    br(Assembler::NE, inflated_load_monitor);\n+\n+    \/\/ Pop lock-stack.\n+    DEBUG_ONLY(str(zr, Address(rthread, t2_top));)\n+    strw(t2_top, Address(rthread, JavaThread::lock_stack_top_offset()));\n+\n+    \/\/ Check if recursive.\n+    subw(t3_t, t2_top, oopSize);\n+    ldr(t3_t, Address(rthread, t3_t));\n+    cmp(obj, t3_t);\n+    br(Assembler::EQ, unlocked);\n+\n+    \/\/ Not recursive.\n+    \/\/ Load Mark.\n+    ldr(t1_mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+\n+    \/\/ Check header for monitor (0b10).\n+    tbnz(t1_mark, exact_log2(markWord::monitor_value), inflated);\n+\n+    \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"required to avoid lea\");\n+    orr(t3_t, t1_mark, markWord::unlocked_value);\n+    cmpxchg(\/*addr*\/ obj, \/*expected*\/ t1_mark, \/*new*\/ t3_t, Assembler::xword,\n+            \/*acquire*\/ false, \/*release*\/ true, \/*weak*\/ false, noreg);\n+    br(Assembler::EQ, unlocked);\n+\n+    \/\/ Compare and exchange failed.\n+    \/\/ Restore lock-stack and handle the unlock in runtime.\n+    DEBUG_ONLY(str(obj, Address(rthread, t2_top));)\n+    addw(t2_top, t2_top, oopSize);\n+    str(t2_top, Address(rthread, JavaThread::lock_stack_top_offset()));\n+    b(slow_path);\n+  }\n+\n+\n+  { \/\/ Handle inflated monitor.\n+    bind(inflated_load_monitor);\n+    ldr(t1_mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+#ifdef ASSERT\n+    tbnz(t1_mark, exact_log2(markWord::monitor_value), inflated);\n+    stop(\"Fast Unlock not monitor\");\n+#endif\n+\n+    bind(inflated);\n+\n+#ifdef ASSERT\n+    Label check_done;\n+    subw(t2_top, t2_top, oopSize);\n+    cmpw(t2_top, in_bytes(JavaThread::lock_stack_base_offset()));\n+    br(Assembler::LT, check_done);\n+    ldr(t3_t, Address(rthread, t2_top));\n+    cmp(obj, t3_t);\n+    br(Assembler::NE, inflated);\n+    stop(\"Fast Unlock lock on stack\");\n+    bind(check_done);\n+#endif\n+\n+    \/\/ mark contains the tagged ObjectMonitor*.\n+    const Register t1_monitor = t1_mark;\n+    const uintptr_t monitor_tag = markWord::monitor_value;\n+\n+    \/\/ Untag the monitor.\n+    sub(t1_monitor, t1_mark, monitor_tag);\n+\n+    const Register t2_recursions = t2;\n+    Label not_recursive;\n+\n+    \/\/ Check if recursive.\n+    ldr(t2_recursions, Address(t1_monitor, ObjectMonitor::recursions_offset()));\n+    cbz(t2_recursions, not_recursive);\n+\n+    \/\/ Recursive unlock.\n+    sub(t2_recursions, t2_recursions, 1u);\n+    str(t2_recursions, Address(t1_monitor, ObjectMonitor::recursions_offset()));\n+    \/\/ Set flag == EQ\n+    cmp(t2_recursions, t2_recursions);\n+    b(unlocked);\n+\n+    bind(not_recursive);\n+\n+    Label release;\n+    const Register t2_owner_addr = t2;\n+\n+    \/\/ Compute owner address.\n+    lea(t2_owner_addr, Address(t1_monitor, ObjectMonitor::owner_offset()));\n+\n+    \/\/ Check if the entry lists are empty.\n+    ldr(rscratch1, Address(t1_monitor, ObjectMonitor::EntryList_offset()));\n+    ldr(t3_t, Address(t1_monitor, ObjectMonitor::cxq_offset()));\n+    orr(rscratch1, rscratch1, t3_t);\n+    cmp(rscratch1, zr);\n+    br(Assembler::EQ, release);\n+\n+    \/\/ The owner may be anonymous and we removed the last obj entry in\n+    \/\/ the lock-stack. This loses the information about the owner.\n+    \/\/ Write the thread to the owner field so the runtime knows the owner.\n+    str(rthread, Address(t2_owner_addr));\n+    b(slow_path);\n+\n+    bind(release);\n+    \/\/ Set owner to null.\n+    \/\/ Release to satisfy the JMM\n+    stlr(zr, t2_owner_addr);\n+  }\n+\n+  bind(unlocked);\n+  decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+#ifdef ASSERT\n+  \/\/ Check that unlocked label is reached with Flags == EQ.\n+  Label flag_correct;\n+  br(Assembler::EQ, flag_correct);\n+  stop(\"Fast Unlock Flag != EQ\");\n+#endif\n+\n+  bind(slow_path);\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with Flags == NE.\n+  br(Assembler::NE, flag_correct);\n+  stop(\"Fast Unlock Flag != NE\");\n+  bind(flag_correct);\n+#endif\n+  \/\/ C2 uses the value of Flags (NE vs EQ) to determine the continuation.\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":270,"deletions":31,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-  \/\/ See full description in macroAssembler_aarch64.cpp.\n@@ -44,0 +43,3 @@\n+  \/\/ Code used by cmpFastLockLightweight and cmpFastUnlockLightweight mach instructions in .ad file.\n+  void fast_lock_lightweight(Register object, Register t1, Register t2, Register t3);\n+  void fast_unlock_lightweight(Register object, Register t1, Register t2, Register t3);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -804,1 +804,0 @@\n-      ldr(tmp, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n@@ -925,16 +924,0 @@\n-\n-      \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n-      \/\/ must handle it.\n-      Register tmp = rscratch1;\n-      \/\/ First check for lock-stack underflow.\n-      ldrw(tmp, Address(rthread, JavaThread::lock_stack_top_offset()));\n-      cmpw(tmp, (unsigned)LockStack::start_offset());\n-      br(Assembler::LE, slow_case);\n-      \/\/ Then check if the top of the lock-stack matches the unlocked object.\n-      subw(tmp, tmp, oopSize);\n-      ldr(tmp, Address(rthread, tmp));\n-      cmpoop(tmp, obj_reg);\n-      br(Assembler::NE, slow_case);\n-\n-      ldr(header_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      tbnz(header_reg, exact_log2(markWord::monitor_value), slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-#include <sys\/types.h>\n-\n@@ -62,0 +60,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -74,0 +73,2 @@\n+#include <sys\/types.h>\n+\n@@ -7195,2 +7196,0 @@\n-\/\/ Branches to slow upon failure to lock the object, with ZF cleared.\n-\/\/ Falls through upon success with ZF set.\n@@ -7199,3 +7198,3 @@\n-\/\/  - hdr: the header, already loaded from obj, will be destroyed\n-\/\/  - t1, t2: temporary registers, will be destroyed\n-void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+\/\/  - t1, t2, t3: temporary registers, will be destroyed\n+\/\/  - slow: branched to if locking fails, absolute offset may larger than 32KB (imm14 encoding).\n+void MacroAssembler::lightweight_lock(Register obj, Register t1, Register t2, Register t3, Label& slow) {\n@@ -7203,6 +7202,25 @@\n-  assert_different_registers(obj, hdr, t1, t2, rscratch1);\n-\n-  \/\/ Check if we would have space on lock-stack for the object.\n-  ldrw(t1, Address(rthread, JavaThread::lock_stack_top_offset()));\n-  cmpw(t1, (unsigned)LockStack::end_offset() - 1);\n-  br(Assembler::GT, slow);\n+  assert_different_registers(obj, t1, t2, t3, rscratch1);\n+\n+  Label push;\n+  const Register top = t1;\n+  const Register mark = t2;\n+  const Register t = t3;\n+\n+  \/\/ Preload the markWord. It is important that this is the first\n+  \/\/ instruction emitted as it is part of C1's null check semantics.\n+  ldr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+\n+  \/\/ Check if the lock-stack is full.\n+  ldrw(top, Address(rthread, JavaThread::lock_stack_top_offset()));\n+  cmpw(top, (unsigned)LockStack::end_offset());\n+  br(Assembler::GE, slow);\n+\n+  \/\/ Check for recursion.\n+  subw(t, top, oopSize);\n+  ldr(t, Address(rthread, t));\n+  cmp(obj, t);\n+  br(Assembler::EQ, push);\n+\n+  \/\/ Check header for monitor (0b10).\n+  tst(mark, markWord::monitor_value);\n+  br(Assembler::NE, slow);\n@@ -7210,2 +7228,3 @@\n-  \/\/ Load (object->mark() | 1) into hdr\n-  orr(hdr, hdr, markWord::unlocked_value);\n+  \/\/ Try to lock. Transition lock bits 0b01 => 0b00\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"required to avoid lea\");\n+  orr(mark, mark, markWord::unlocked_value);\n@@ -7214,1 +7233,1 @@\n-    andr(hdr, hdr, ~((int) markWord::inline_type_bit_in_place));\n+    andr(mark, mark, ~((int) markWord::inline_type_bit_in_place));\n@@ -7216,7 +7235,3 @@\n-\n-  \/\/ Clear lock-bits, into t2\n-  eor(t2, hdr, markWord::unlocked_value);\n-  \/\/ Try to swing header from unlocked to locked\n-  \/\/ Clobbers rscratch1 when UseLSE is false\n-  cmpxchg(\/*addr*\/ obj, \/*expected*\/ hdr, \/*new*\/ t2, Assembler::xword,\n-          \/*acquire*\/ true, \/*release*\/ true, \/*weak*\/ false, t1);\n+  eor(t, mark, markWord::unlocked_value);\n+  cmpxchg(\/*addr*\/ obj, \/*expected*\/ mark, \/*new*\/ t, Assembler::xword,\n+          \/*acquire*\/ true, \/*release*\/ false, \/*weak*\/ false, noreg);\n@@ -7225,5 +7240,5 @@\n-  \/\/ After successful lock, push object on lock-stack\n-  ldrw(t1, Address(rthread, JavaThread::lock_stack_top_offset()));\n-  str(obj, Address(rthread, t1));\n-  addw(t1, t1, oopSize);\n-  strw(t1, Address(rthread, JavaThread::lock_stack_top_offset()));\n+  bind(push);\n+  \/\/ After successful lock, push object on lock-stack.\n+  str(obj, Address(rthread, top));\n+  addw(top, top, oopSize);\n+  strw(top, Address(rthread, JavaThread::lock_stack_top_offset()));\n@@ -7233,2 +7248,0 @@\n-\/\/ Branches to slow upon failure, with ZF cleared.\n-\/\/ Falls through upon success, with ZF set.\n@@ -7237,3 +7250,3 @@\n-\/\/ - hdr: the (pre-loaded) header of the object\n-\/\/ - t1, t2: temporary registers\n-void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+\/\/ - t1, t2, t3: temporary registers\n+\/\/ - slow: branched to if unlocking fails, absolute offset may larger than 32KB (imm14 encoding).\n+void MacroAssembler::lightweight_unlock(Register obj, Register t1, Register t2, Register t3, Label& slow) {\n@@ -7241,1 +7254,2 @@\n-  assert_different_registers(obj, hdr, t1, t2, rscratch1);\n+  \/\/ cmpxchg clobbers rscratch1.\n+  assert_different_registers(obj, t1, t2, t3, rscratch1);\n@@ -7245,4 +7259,0 @@\n-    \/\/ The following checks rely on the fact that LockStack is only ever modified by\n-    \/\/ its owning thread, even if the lock got inflated concurrently; removal of LockStack\n-    \/\/ entries after inflation will happen delayed in that case.\n-\n@@ -7253,1 +7263,1 @@\n-    br(Assembler::GT, stack_ok);\n+    br(Assembler::GE, stack_ok);\n@@ -7257,18 +7267,0 @@\n-  {\n-    \/\/ Check if the top of the lock-stack matches the unlocked object.\n-    Label tos_ok;\n-    subw(t1, t1, oopSize);\n-    ldr(t1, Address(rthread, t1));\n-    cmpoop(t1, obj);\n-    br(Assembler::EQ, tos_ok);\n-    STOP(\"Top of lock-stack does not match the unlocked object\");\n-    bind(tos_ok);\n-  }\n-  {\n-    \/\/ Check that hdr is fast-locked.\n-    Label hdr_ok;\n-    tst(hdr, markWord::lock_mask_in_place);\n-    br(Assembler::EQ, hdr_ok);\n-    STOP(\"Header is not fast-locked\");\n-    bind(hdr_ok);\n-  }\n@@ -7277,2 +7269,4 @@\n-  \/\/ Load the new header (unlocked) into t1\n-  orr(t1, hdr, markWord::unlocked_value);\n+  Label unlocked, push_and_slow;\n+  const Register top = t1;\n+  const Register mark = t2;\n+  const Register t = t3;\n@@ -7280,4 +7274,5 @@\n-  \/\/ Try to swing header from locked to unlocked\n-  \/\/ Clobbers rscratch1 when UseLSE is false\n-  cmpxchg(obj, hdr, t1, Assembler::xword,\n-          \/*acquire*\/ true, \/*release*\/ true, \/*weak*\/ false, t2);\n+  \/\/ Check if obj is top of lock-stack.\n+  ldrw(top, Address(rthread, JavaThread::lock_stack_top_offset()));\n+  subw(top, top, oopSize);\n+  ldr(t, Address(rthread, top));\n+  cmp(obj, t);\n@@ -7286,3 +7281,14 @@\n-  \/\/ After successful unlock, pop object from lock-stack\n-  ldrw(t1, Address(rthread, JavaThread::lock_stack_top_offset()));\n-  subw(t1, t1, oopSize);\n+  \/\/ Pop lock-stack.\n+  DEBUG_ONLY(str(zr, Address(rthread, top));)\n+  strw(top, Address(rthread, JavaThread::lock_stack_top_offset()));\n+\n+  \/\/ Check if recursive.\n+  subw(t, top, oopSize);\n+  ldr(t, Address(rthread, t));\n+  cmp(obj, t);\n+  br(Assembler::EQ, unlocked);\n+\n+  \/\/ Not recursive. Check header for monitor (0b10).\n+  ldr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  tbnz(mark, log2i_exact(markWord::monitor_value), push_and_slow);\n+\n@@ -7290,1 +7296,5 @@\n-  str(zr, Address(rthread, t1));\n+  \/\/ Check header not unlocked (0b01).\n+  Label not_unlocked;\n+  tbz(mark, log2i_exact(markWord::unlocked_value), not_unlocked);\n+  stop(\"lightweight_unlock already unlocked\");\n+  bind(not_unlocked);\n@@ -7292,1 +7302,16 @@\n-  strw(t1, Address(rthread, JavaThread::lock_stack_top_offset()));\n+\n+  \/\/ Try to unlock. Transition lock bits 0b00 => 0b01\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"required to avoid lea\");\n+  orr(t, mark, markWord::unlocked_value);\n+  cmpxchg(obj, mark, t, Assembler::xword,\n+          \/*acquire*\/ false, \/*release*\/ true, \/*weak*\/ false, noreg);\n+  br(Assembler::EQ, unlocked);\n+\n+  bind(push_and_slow);\n+  \/\/ Restore lock-stack and handle the unlock in runtime.\n+  DEBUG_ONLY(str(obj, Address(rthread, top));)\n+  addw(top, top, oopSize);\n+  strw(top, Address(rthread, JavaThread::lock_stack_top_offset()));\n+  b(slow);\n+\n+  bind(unlocked);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":94,"deletions":69,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1685,2 +1685,2 @@\n-  void lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n-  void lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n+  void lightweight_lock(Register obj, Register t1, Register t2, Register t3, Label& slow);\n+  void lightweight_unlock(Register obj, Register t1, Register t2, Register t3, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2078,1 +2078,0 @@\n-      __ ldr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n@@ -2221,2 +2220,0 @@\n-      __ ldr(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      __ tbnz(old_hdr, exact_log2(markWord::monitor_value), slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -812,1 +812,1 @@\n-    _features = feature_flags(); \/\/ These can be changed by VM settings\n+    _features = _cpuid_info.feature_flags(); \/\/ These can be changed by VM settings\n@@ -2894,1 +2894,1 @@\n-uint64_t VM_Version::feature_flags() {\n+uint64_t VM_Version::CpuidInfo::feature_flags() const {\n@@ -2896,1 +2896,1 @@\n-  if (_cpuid_info.std_cpuid1_edx.bits.cmpxchg8 != 0)\n+  if (std_cpuid1_edx.bits.cmpxchg8 != 0)\n@@ -2898,1 +2898,1 @@\n-  if (_cpuid_info.std_cpuid1_edx.bits.cmov != 0)\n+  if (std_cpuid1_edx.bits.cmov != 0)\n@@ -2900,1 +2900,1 @@\n-  if (_cpuid_info.std_cpuid1_edx.bits.clflush != 0)\n+  if (std_cpuid1_edx.bits.clflush != 0)\n@@ -2908,2 +2908,2 @@\n-  if (_cpuid_info.std_cpuid1_edx.bits.fxsr != 0 || (is_amd_family() &&\n-      _cpuid_info.ext_cpuid1_edx.bits.fxsr != 0))\n+  if (std_cpuid1_edx.bits.fxsr != 0 || (is_amd_family() &&\n+      ext_cpuid1_edx.bits.fxsr != 0))\n@@ -2914,2 +2914,2 @@\n-  if (_cpuid_info.std_cpuid1_edx.bits.mmx != 0 || (is_amd_family() &&\n-      _cpuid_info.ext_cpuid1_edx.bits.mmx != 0))\n+  if (std_cpuid1_edx.bits.mmx != 0 || (is_amd_family() &&\n+      ext_cpuid1_edx.bits.mmx != 0))\n@@ -2917,1 +2917,1 @@\n-  if (_cpuid_info.std_cpuid1_edx.bits.sse != 0)\n+  if (std_cpuid1_edx.bits.sse != 0)\n@@ -2919,1 +2919,1 @@\n-  if (_cpuid_info.std_cpuid1_edx.bits.sse2 != 0)\n+  if (std_cpuid1_edx.bits.sse2 != 0)\n@@ -2921,1 +2921,1 @@\n-  if (_cpuid_info.std_cpuid1_ecx.bits.sse3 != 0)\n+  if (std_cpuid1_ecx.bits.sse3 != 0)\n@@ -2923,1 +2923,1 @@\n-  if (_cpuid_info.std_cpuid1_ecx.bits.ssse3 != 0)\n+  if (std_cpuid1_ecx.bits.ssse3 != 0)\n@@ -2925,1 +2925,1 @@\n-  if (_cpuid_info.std_cpuid1_ecx.bits.sse4_1 != 0)\n+  if (std_cpuid1_ecx.bits.sse4_1 != 0)\n@@ -2927,1 +2927,1 @@\n-  if (_cpuid_info.std_cpuid1_ecx.bits.sse4_2 != 0)\n+  if (std_cpuid1_ecx.bits.sse4_2 != 0)\n@@ -2929,1 +2929,1 @@\n-  if (_cpuid_info.std_cpuid1_ecx.bits.popcnt != 0)\n+  if (std_cpuid1_ecx.bits.popcnt != 0)\n@@ -2931,4 +2931,4 @@\n-  if (_cpuid_info.std_cpuid1_ecx.bits.avx != 0 &&\n-      _cpuid_info.std_cpuid1_ecx.bits.osxsave != 0 &&\n-      _cpuid_info.xem_xcr0_eax.bits.sse != 0 &&\n-      _cpuid_info.xem_xcr0_eax.bits.ymm != 0) {\n+  if (std_cpuid1_ecx.bits.avx != 0 &&\n+      std_cpuid1_ecx.bits.osxsave != 0 &&\n+      xem_xcr0_eax.bits.sse != 0 &&\n+      xem_xcr0_eax.bits.ymm != 0) {\n@@ -2937,1 +2937,1 @@\n-    if (_cpuid_info.std_cpuid1_ecx.bits.f16c != 0)\n+    if (std_cpuid1_ecx.bits.f16c != 0)\n@@ -2939,1 +2939,1 @@\n-    if (_cpuid_info.sef_cpuid7_ebx.bits.avx2 != 0)\n+    if (sef_cpuid7_ebx.bits.avx2 != 0)\n@@ -2941,4 +2941,4 @@\n-    if (_cpuid_info.sef_cpuid7_ebx.bits.avx512f != 0 &&\n-        _cpuid_info.xem_xcr0_eax.bits.opmask != 0 &&\n-        _cpuid_info.xem_xcr0_eax.bits.zmm512 != 0 &&\n-        _cpuid_info.xem_xcr0_eax.bits.zmm32 != 0) {\n+    if (sef_cpuid7_ebx.bits.avx512f != 0 &&\n+        xem_xcr0_eax.bits.opmask != 0 &&\n+        xem_xcr0_eax.bits.zmm512 != 0 &&\n+        xem_xcr0_eax.bits.zmm32 != 0) {\n@@ -2946,1 +2946,1 @@\n-      if (_cpuid_info.sef_cpuid7_ebx.bits.avx512cd != 0)\n+      if (sef_cpuid7_ebx.bits.avx512cd != 0)\n@@ -2948,1 +2948,1 @@\n-      if (_cpuid_info.sef_cpuid7_ebx.bits.avx512dq != 0)\n+      if (sef_cpuid7_ebx.bits.avx512dq != 0)\n@@ -2950,1 +2950,1 @@\n-      if (_cpuid_info.sef_cpuid7_ebx.bits.avx512ifma != 0)\n+      if (sef_cpuid7_ebx.bits.avx512ifma != 0)\n@@ -2952,1 +2952,1 @@\n-      if (_cpuid_info.sef_cpuid7_ebx.bits.avx512pf != 0)\n+      if (sef_cpuid7_ebx.bits.avx512pf != 0)\n@@ -2954,1 +2954,1 @@\n-      if (_cpuid_info.sef_cpuid7_ebx.bits.avx512er != 0)\n+      if (sef_cpuid7_ebx.bits.avx512er != 0)\n@@ -2956,1 +2956,1 @@\n-      if (_cpuid_info.sef_cpuid7_ebx.bits.avx512bw != 0)\n+      if (sef_cpuid7_ebx.bits.avx512bw != 0)\n@@ -2958,1 +2958,1 @@\n-      if (_cpuid_info.sef_cpuid7_ebx.bits.avx512vl != 0)\n+      if (sef_cpuid7_ebx.bits.avx512vl != 0)\n@@ -2960,1 +2960,1 @@\n-      if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpopcntdq != 0)\n+      if (sef_cpuid7_ecx.bits.avx512_vpopcntdq != 0)\n@@ -2962,1 +2962,1 @@\n-      if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpclmulqdq != 0)\n+      if (sef_cpuid7_ecx.bits.avx512_vpclmulqdq != 0)\n@@ -2964,1 +2964,1 @@\n-      if (_cpuid_info.sef_cpuid7_ecx.bits.vaes != 0)\n+      if (sef_cpuid7_ecx.bits.vaes != 0)\n@@ -2966,1 +2966,1 @@\n-      if (_cpuid_info.sef_cpuid7_ecx.bits.gfni != 0)\n+      if (sef_cpuid7_ecx.bits.gfni != 0)\n@@ -2968,1 +2968,1 @@\n-      if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vnni != 0)\n+      if (sef_cpuid7_ecx.bits.avx512_vnni != 0)\n@@ -2970,1 +2970,1 @@\n-      if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_bitalg != 0)\n+      if (sef_cpuid7_ecx.bits.avx512_bitalg != 0)\n@@ -2972,1 +2972,1 @@\n-      if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vbmi != 0)\n+      if (sef_cpuid7_ecx.bits.avx512_vbmi != 0)\n@@ -2974,1 +2974,1 @@\n-      if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vbmi2 != 0)\n+      if (sef_cpuid7_ecx.bits.avx512_vbmi2 != 0)\n@@ -2978,1 +2978,1 @@\n-  if (_cpuid_info.std_cpuid1_ecx.bits.hv != 0)\n+  if (std_cpuid1_ecx.bits.hv != 0)\n@@ -2980,1 +2980,1 @@\n-  if (_cpuid_info.sef_cpuid7_ebx.bits.bmi1 != 0)\n+  if (sef_cpuid7_ebx.bits.bmi1 != 0)\n@@ -2982,1 +2982,1 @@\n-  if (_cpuid_info.std_cpuid1_edx.bits.tsc != 0)\n+  if (std_cpuid1_edx.bits.tsc != 0)\n@@ -2984,1 +2984,1 @@\n-  if (_cpuid_info.ext_cpuid7_edx.bits.tsc_invariance != 0)\n+  if (ext_cpuid7_edx.bits.tsc_invariance != 0)\n@@ -2986,1 +2986,1 @@\n-  if (_cpuid_info.std_cpuid1_ecx.bits.aes != 0)\n+  if (std_cpuid1_ecx.bits.aes != 0)\n@@ -2988,1 +2988,1 @@\n-  if (_cpuid_info.sef_cpuid7_ebx.bits.erms != 0)\n+  if (sef_cpuid7_ebx.bits.erms != 0)\n@@ -2990,1 +2990,1 @@\n-  if (_cpuid_info.sef_cpuid7_edx.bits.fast_short_rep_mov != 0)\n+  if (sef_cpuid7_edx.bits.fast_short_rep_mov != 0)\n@@ -2992,1 +2992,1 @@\n-  if (_cpuid_info.std_cpuid1_ecx.bits.clmul != 0)\n+  if (std_cpuid1_ecx.bits.clmul != 0)\n@@ -2994,1 +2994,1 @@\n-  if (_cpuid_info.sef_cpuid7_ebx.bits.rtm != 0)\n+  if (sef_cpuid7_ebx.bits.rtm != 0)\n@@ -2996,1 +2996,1 @@\n-  if (_cpuid_info.sef_cpuid7_ebx.bits.adx != 0)\n+  if (sef_cpuid7_ebx.bits.adx != 0)\n@@ -2998,1 +2998,1 @@\n-  if (_cpuid_info.sef_cpuid7_ebx.bits.bmi2 != 0)\n+  if (sef_cpuid7_ebx.bits.bmi2 != 0)\n@@ -3000,1 +3000,1 @@\n-  if (_cpuid_info.sef_cpuid7_ebx.bits.sha != 0)\n+  if (sef_cpuid7_ebx.bits.sha != 0)\n@@ -3002,1 +3002,1 @@\n-  if (_cpuid_info.std_cpuid1_ecx.bits.fma != 0)\n+  if (std_cpuid1_ecx.bits.fma != 0)\n@@ -3004,1 +3004,1 @@\n-  if (_cpuid_info.sef_cpuid7_ebx.bits.clflushopt != 0)\n+  if (sef_cpuid7_ebx.bits.clflushopt != 0)\n@@ -3006,1 +3006,1 @@\n-  if (_cpuid_info.ext_cpuid1_edx.bits.rdtscp != 0)\n+  if (ext_cpuid1_edx.bits.rdtscp != 0)\n@@ -3008,1 +3008,1 @@\n-  if (_cpuid_info.sef_cpuid7_ecx.bits.rdpid != 0)\n+  if (sef_cpuid7_ecx.bits.rdpid != 0)\n@@ -3013,2 +3013,2 @@\n-    if ((_cpuid_info.ext_cpuid1_edx.bits.tdnow != 0) ||\n-        (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0))\n+    if ((ext_cpuid1_edx.bits.tdnow != 0) ||\n+        (ext_cpuid1_ecx.bits.prefetchw != 0))\n@@ -3016,1 +3016,1 @@\n-    if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0)\n+    if (ext_cpuid1_ecx.bits.lzcnt != 0)\n@@ -3018,1 +3018,1 @@\n-    if (_cpuid_info.ext_cpuid1_ecx.bits.sse4a != 0)\n+    if (ext_cpuid1_ecx.bits.sse4a != 0)\n@@ -3024,1 +3024,1 @@\n-    if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0) {\n+    if (ext_cpuid1_ecx.bits.lzcnt != 0) {\n@@ -3027,1 +3027,1 @@\n-    if (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0) {\n+    if (ext_cpuid1_ecx.bits.prefetchw != 0) {\n@@ -3030,1 +3030,1 @@\n-    if (_cpuid_info.sef_cpuid7_ebx.bits.clwb != 0) {\n+    if (sef_cpuid7_ebx.bits.clwb != 0) {\n@@ -3033,1 +3033,1 @@\n-    if (_cpuid_info.sef_cpuid7_edx.bits.serialize != 0)\n+    if (sef_cpuid7_edx.bits.serialize != 0)\n@@ -3039,1 +3039,1 @@\n-    if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0) {\n+    if (ext_cpuid1_ecx.bits.lzcnt != 0) {\n@@ -3042,1 +3042,1 @@\n-    if (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0) {\n+    if (ext_cpuid1_ecx.bits.prefetchw != 0) {\n@@ -3048,1 +3048,1 @@\n-  if (_cpuid_info.sef_cpuid7_ecx.bits.pku != 0) {\n+  if (sef_cpuid7_ecx.bits.pku != 0) {\n@@ -3051,1 +3051,1 @@\n-  if (_cpuid_info.sef_cpuid7_ecx.bits.ospke != 0) {\n+  if (sef_cpuid7_ecx.bits.ospke != 0) {\n@@ -3056,1 +3056,1 @@\n-  if (_cpuid_info.sef_cpuid7_ecx.bits.cet_ss != 0) {\n+  if (sef_cpuid7_ecx.bits.cet_ss != 0) {\n@@ -3059,1 +3059,1 @@\n-  if (_cpuid_info.sef_cpuid7_edx.bits.cet_ibt != 0) {\n+  if (sef_cpuid7_edx.bits.cet_ibt != 0) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":71,"deletions":71,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -848,3 +848,12 @@\n-    for (int i = 0; i < x->length(); i++) {\n-      if (v == x->key_at(i)) {\n-        sux = x->sux_at(i);\n+    int low = 0;\n+    int high = x->length() - 1;\n+    while (low <= high) {\n+      int mid = low + ((high - low) >> 1);\n+      int key = x->key_at(mid);\n+      if (key == v) {\n+        sux = x->sux_at(mid);\n+        break;\n+      } else if (key > v) {\n+        high = mid - 1;\n+      } else {\n+        low = mid + 1;\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1765,3 +1765,6 @@\n-  char *base = os::remap_memory(_fd, _full_path, r->file_offset(),\n-                                addr, size, false \/* !read_only *\/,\n-                                r->allow_exec());\n+  \/\/ This path should not be reached for Windows; see JDK-8222379.\n+  assert(WINDOWS_ONLY(false) NOT_WINDOWS(true), \"Don't call on Windows\");\n+  \/\/ Replace old mapping with new one that is writable.\n+  char *base = os::map_memory(_fd, _full_path, r->file_offset(),\n+                              addr, size, false \/* !read_only *\/,\n+                              r->allow_exec());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1033,1 +1033,1 @@\n-\/\/ Search either the patch-module or exploded build entries for class.\n+\/\/ Search the module list for the class file stream based on the file name and java package\n@@ -1036,1 +1036,1 @@\n-                                                    const char* const class_name,\n+                                                    PackageEntry* pkg_entry, \/\/ Java package entry derived from the class name\n@@ -1040,4 +1040,1 @@\n-  \/\/ Find the class' defining module in the boot loader's module entry table\n-  TempNewSymbol class_name_symbol = SymbolTable::new_symbol(class_name);\n-  TempNewSymbol pkg_name = package_from_class_name(class_name_symbol);\n-  PackageEntry* pkg_entry = get_package_entry(pkg_name, ClassLoaderData::the_null_class_loader_data());\n+  \/\/ Find the defining module in the boot loader's module entry table\n@@ -1088,1 +1085,1 @@\n-InstanceKlass* ClassLoader::load_class(Symbol* name, bool search_append_only, TRAPS) {\n+InstanceKlass* ClassLoader::load_class(Symbol* name, PackageEntry* pkg_entry, bool search_append_only, TRAPS) {\n@@ -1137,1 +1134,1 @@\n-      stream = search_module_entries(THREAD, _patch_mod_entries, class_name, file_name);\n+      stream = search_module_entries(THREAD, _patch_mod_entries, pkg_entry, file_name);\n@@ -1152,1 +1149,1 @@\n-      stream = search_module_entries(THREAD, _exploded_entries, class_name, file_name);\n+      stream = search_module_entries(THREAD, _exploded_entries, pkg_entry, file_name);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1314,1 +1314,1 @@\n-      k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);\n+      k = ClassLoader::load_class(class_name, pkg_entry, search_only_bootloader_append, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -416,0 +417,1 @@\n+    mem_zap_end_padding(mem);\n@@ -421,0 +423,18 @@\n+#ifndef PRODUCT\n+void ObjArrayAllocator::mem_zap_end_padding(HeapWord* mem) const {\n+  const size_t length_in_bytes = static_cast<size_t>(_length) << ArrayKlass::cast(_klass)->log2_element_size();\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(element_type);\n+  const size_t size_in_bytes = _word_size * BytesPerWord;\n+\n+  const address obj_end = reinterpret_cast<address>(mem) + size_in_bytes;\n+  const address base = reinterpret_cast<address>(mem) + base_offset_in_bytes;\n+  const address elements_end = base + length_in_bytes;\n+  assert(elements_end <= obj_end, \"payload must fit in object\");\n+  if (elements_end < obj_end) {\n+    const size_t padding_in_bytes = obj_end - elements_end;\n+    Copy::fill_to_bytes(elements_end, padding_in_bytes, heapPaddingByteVal);\n+  }\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,0 +109,2 @@\n+  void mem_zap_end_padding(HeapWord* mem) const PRODUCT_RETURN;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  static void clone_obj_array(objArrayOop src, objArrayOop dst, size_t size);\n+  static void clone_obj_array(objArrayOop src, objArrayOop dst);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-    clone_obj_array(objArrayOop(src), objArrayOop(dst), size);\n+    clone_obj_array(objArrayOop(src), objArrayOop(dst));\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,2 @@\n+  mem_zap_end_padding(mem);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2028,1 +2028,1 @@\n-  product(uint, TrimNativeHeapInterval, 0, EXPERIMENTAL,                    \\\n+  product(uint, TrimNativeHeapInterval, 0,                                  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -467,6 +467,0 @@\n-    \/\/ Ignore modules for -Xshare:dump because we do not have any package\n-    \/\/ or module information for modules other than java.base.\n-    if (CDSConfig::is_dumping_static_archive()) {\n-      return ACCESS_OK;\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -584,0 +584,2 @@\n+#include CPU_HEADER(globalDefinitions)\n+\n@@ -585,0 +587,1 @@\n+#ifndef CODE_CACHE_SIZE_LIMIT\n@@ -586,0 +589,2 @@\n+#endif\n+\n@@ -589,2 +594,0 @@\n-#include CPU_HEADER(globalDefinitions)\n-\n@@ -1043,13 +1046,14 @@\n-const jint     badInt           = -3;                       \/\/ generic \"bad int\" value\n-const intptr_t badAddressVal    = -2;                       \/\/ generic \"bad address\" value\n-const intptr_t badOopVal        = -1;                       \/\/ generic \"bad oop\" value\n-const intptr_t badHeapOopVal    = (intptr_t) CONST64(0x2BAD4B0BBAADBABE); \/\/ value used to zap heap after GC\n-const int      badStackSegVal   = 0xCA;                     \/\/ value used to zap stack segments\n-const int      badHandleValue   = 0xBC;                     \/\/ value used to zap vm handle area\n-const int      badResourceValue = 0xAB;                     \/\/ value used to zap resource area\n-const int      freeBlockPad     = 0xBA;                     \/\/ value used to pad freed blocks.\n-const int      uninitBlockPad   = 0xF1;                     \/\/ value used to zap newly malloc'd blocks.\n-const juint    uninitMetaWordVal= 0xf7f7f7f7;               \/\/ value used to zap newly allocated metachunk\n-const juint    badHeapWordVal   = 0xBAADBABE;               \/\/ value used to zap heap after GC\n-const juint    badMetaWordVal   = 0xBAADFADE;               \/\/ value used to zap metadata heap after GC\n-const int      badCodeHeapNewVal= 0xCC;                     \/\/ value used to zap Code heap at allocation\n+const jint     badInt             = -3;                     \/\/ generic \"bad int\" value\n+const intptr_t badAddressVal      = -2;                     \/\/ generic \"bad address\" value\n+const intptr_t badOopVal          = -1;                     \/\/ generic \"bad oop\" value\n+const intptr_t badHeapOopVal      = (intptr_t) CONST64(0x2BAD4B0BBAADBABE); \/\/ value used to zap heap after GC\n+const int      badStackSegVal     = 0xCA;                   \/\/ value used to zap stack segments\n+const int      badHandleValue     = 0xBC;                   \/\/ value used to zap vm handle area\n+const int      badResourceValue   = 0xAB;                   \/\/ value used to zap resource area\n+const int      freeBlockPad       = 0xBA;                   \/\/ value used to pad freed blocks.\n+const int      uninitBlockPad     = 0xF1;                   \/\/ value used to zap newly malloc'd blocks.\n+const juint    uninitMetaWordVal  = 0xf7f7f7f7;             \/\/ value used to zap newly allocated metachunk\n+const jubyte   heapPaddingByteVal = 0xBD;                   \/\/ value used to zap object padding in the heap\n+const juint    badHeapWordVal     = 0xBAADBABE;             \/\/ value used to zap heap after GC\n+const juint    badMetaWordVal     = 0xBAADFADE;             \/\/ value used to zap metadata heap after GC\n+const int      badCodeHeapNewVal  = 0xCC;                   \/\/ value used to zap Code heap at allocation\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -117,0 +117,5 @@\n+applications\/jcstress\/accessAtomic.java 8325984 generic-all\n+applications\/jcstress\/acqrel.java 8325984 generic-all\n+applications\/jcstress\/atomicity.java 8325984 generic-all\n+applications\/jcstress\/coherence.java 8325984 generic-all\n+\n@@ -213,0 +218,1 @@\n+vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/deoptimize\/Test.java#id1 8325905 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-sun\/java2d\/X11SurfaceData\/SharedMemoryPixmapsTest\/SharedMemoryPixmapsTest.sh 8221451 linux-all\n+sun\/java2d\/X11SurfaceData\/SharedMemoryPixmapsTest\/SharedMemoryPixmapsTest.sh 7184899,8221451 linux-all,macosx-aarch64\n@@ -581,2 +581,0 @@\n-jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java                     8301183 linux-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @enablePreview\n@@ -29,2 +29,16 @@\n-import jdk.internal.org.objectweb.asm.*;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.attribute.EnclosingMethodAttribute;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.Optional;\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -124,2 +138,2 @@\n-        final String innerName;\n-        final String outerName;\n+        final ClassDesc innerName;\n+        final ClassDesc outerName;\n@@ -129,2 +143,2 @@\n-            this.innerName = intl(innerName);\n-            this.outerName = intl(outerName);\n+            this.innerName = ClassDesc.of(innerName);\n+            this.outerName = ClassDesc.of(outerName);\n@@ -134,10 +148,6 @@\n-        static String intl(String name) { return name.replace('.', '\/'); }\n-\n-        static void makeDefaultCtor(ClassWriter cw) {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n+        static void makeDefaultCtor(ClassBuilder clb) {\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cb -> {\n+                cb.aload(0);\n+                cb.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cb.return_();\n+            });\n@@ -146,1 +156,1 @@\n-        void makeCtxk(ClassWriter cw, boolean isInner) {\n+        void makeCtxk(ClassBuilder clb, boolean isInner) {\n@@ -148,1 +158,2 @@\n-                cw.visitOuterClass(outerName, \"f\", \"()V\");\n+                clb.with(EnclosingMethodAttribute.of(outerName,\n+                        Optional.of(\"f\"), Optional.of(MTD_void)));\n@@ -150,5 +161,2 @@\n-                MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"f\", \"()V\", null, null);\n-                mv.visitCode();\n-                mv.visitInsn(RETURN);\n-                mv.visitMaxs(0, 0);\n-                mv.visitEnd();\n+                clb.withMethodBody(\"f\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                        CodeBuilder::return_);\n@@ -159,9 +167,10 @@\n-            String name = (isInner ? innerName : outerName);\n-            ClassWriter cw = new ClassWriter(0);\n-            cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n-\n-            cw.visitInnerClass(innerName, outerName, simpleName, ACC_PUBLIC | ACC_STATIC);\n-\n-            makeDefaultCtor(cw);\n-            cw.visitEnd();\n-            return cw.toByteArray();\n+            var name = (isInner ? innerName : outerName);\n+            return ClassFile.of().build(name, clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+                clb.with(InnerClassesAttribute.of(\n+                        InnerClassInfo.of(innerName,\n+                                Optional.of(outerName),\n+                                Optional.of(simpleName))));\n+                makeDefaultCtor(clb);\n+            });\n@@ -171,9 +180,11 @@\n-            String name = (isInner ? innerName : outerName);\n-            ClassWriter cw = new ClassWriter(0);\n-            cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n-\n-            cw.visitInnerClass(innerName, outerName, simpleName, ACC_PUBLIC);\n-\n-            makeDefaultCtor(cw);\n-            cw.visitEnd();\n-            return cw.toByteArray();\n+            var name = (isInner ? innerName : outerName);\n+            return ClassFile.of().build(name, clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+                clb.with(InnerClassesAttribute.of(\n+                        InnerClassInfo.of(innerName,\n+                                Optional.of(outerName),\n+                                Optional.of(simpleName),\n+                                AccessFlag.PUBLIC)));\n+                makeDefaultCtor(clb);\n+            });\n@@ -183,10 +194,12 @@\n-            String name = (isInner ? innerName : outerName);\n-            ClassWriter cw = new ClassWriter(0);\n-            cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n-\n-            cw.visitInnerClass(innerName, null, simpleName, ACC_PUBLIC | ACC_STATIC);\n-            makeCtxk(cw, isInner);\n-\n-            makeDefaultCtor(cw);\n-            cw.visitEnd();\n-            return cw.toByteArray();\n+            var name = (isInner ? innerName : outerName);\n+            return ClassFile.of().build(name, clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+                clb.with(InnerClassesAttribute.of(\n+                        InnerClassInfo.of(innerName,\n+                                Optional.empty(),\n+                                Optional.of(simpleName),\n+                                AccessFlag.PUBLIC, AccessFlag.STATIC)));\n+                makeDefaultCtor(clb);\n+                makeCtxk(clb, isInner);\n+            });\n@@ -196,10 +209,12 @@\n-            String name = (isInner ? innerName : outerName);\n-            ClassWriter cw = new ClassWriter(0);\n-            cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n-\n-            cw.visitInnerClass(innerName, null, null, ACC_PUBLIC | ACC_STATIC);\n-            makeCtxk(cw, isInner);\n-\n-            makeDefaultCtor(cw);\n-            cw.visitEnd();\n-            return cw.toByteArray();\n+            var name = (isInner ? innerName : outerName);\n+            return ClassFile.of().build(name, clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+                clb.with(InnerClassesAttribute.of(\n+                        InnerClassInfo.of(innerName,\n+                                Optional.empty(),\n+                                Optional.empty(),\n+                                AccessFlag.PUBLIC, AccessFlag.STATIC)));\n+                makeDefaultCtor(clb);\n+                makeCtxk(clb, isInner);\n+            });\n","filename":"test\/jdk\/java\/lang\/Class\/getSimpleName\/GetSimpleNameTest.java","additions":78,"deletions":63,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- *          java.base\/jdk.internal.org.objectweb.asm\n+ * @enablePreview\n@@ -33,0 +33,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n@@ -34,2 +36,1 @@\n-import static java.lang.invoke.MethodHandles.*;\n-import static java.lang.invoke.MethodHandles.Lookup.*;\n+import java.lang.reflect.AccessFlag;\n@@ -41,5 +42,9 @@\n-\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CLASS_INIT_NAME;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+import static java.lang.invoke.MethodHandles.*;\n+import static java.lang.invoke.MethodHandles.Lookup.*;\n@@ -51,0 +56,2 @@\n+    private static final ClassDesc CD_Runnable = Runnable.class.describeConstable().orElseThrow();\n+    private static final ClassDesc CD_MissingSuperClass = ClassDesc.of(\"MissingSuperClass\");\n@@ -254,19 +261,9 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V9,\n-                ACC_PUBLIC + ACC_SUPER,\n-                className.replace(\".\", \"\/\"),\n-                null,\n-                \"java\/lang\/Object\",\n-                null);\n-\n-        \/\/ <init>\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return ClassFile.of().build(ClassDesc.of(className), clb -> {\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+            clb.withSuperclass(CD_Object);\n+            clb.withMethodBody(INIT_NAME, MTD_void, PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+        });\n@@ -283,27 +280,13 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V9,\n-                ACC_PUBLIC + ACC_SUPER,\n-                className.replace(\".\", \"\/\"),\n-                null,\n-                \"java\/lang\/Object\",\n-                new String[] { \"java\/lang\/Runnable\" });\n-\n-        \/\/ <init>\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ run()\n-        String tc = targetClass.replace(\".\", \"\/\");\n-        mv = cw.visitMethod(ACC_PUBLIC, \"run\", \"()V\", null, null);\n-        mv.visitMethodInsn(INVOKESTATIC, tc, targetMethod, \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return ClassFile.of().build(ClassDesc.of(className), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(CD_Runnable);\n+            clb.withMethodBody(INIT_NAME, MTD_void, PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"run\", MTD_void, PUBLIC, cob -> {\n+                cob.invokestatic(ClassDesc.of(targetClass), targetMethod, MTD_void);\n+                cob.return_();\n+            });\n+        });\n@@ -320,27 +303,13 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V9,\n-                ACC_PUBLIC + ACC_SUPER,\n-                className.replace(\".\", \"\/\"),\n-                null,\n-                \"java\/lang\/Object\",\n-                null);\n-\n-        \/\/ <init>\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ <clinit>\n-        String tc = targetClass.replace(\".\", \"\/\");\n-        mv = cw.visitMethod(ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n-        mv.visitMethodInsn(INVOKESTATIC, tc, targetMethod, \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return ClassFile.of().build(ClassDesc.of(className), clb -> {\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+            clb.withSuperclass(CD_Object);\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+                cob.invokestatic(ClassDesc.of(targetClass), targetMethod, MTD_void);\n+                cob.return_();\n+            });\n+        });\n@@ -353,19 +322,9 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V14,\n-                ACC_PUBLIC + ACC_SUPER,\n-                className.replace(\".\", \"\/\"),\n-                null,\n-                \"MissingSuperClass\",\n-                null);\n-\n-        \/\/ <init>\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"MissingSuperClass\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return ClassFile.of().build(ClassDesc.of(className), clb -> {\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+            clb.withSuperclass(CD_MissingSuperClass);\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_MissingSuperClass, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+        });\n@@ -378,11 +337,1 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V14,\n-                ACC_MODULE,\n-                \"module-info\",\n-                null,\n-                null,\n-                null);\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return ClassFile.of().build(ClassDesc.of(\"module-info\"), cb -> cb.withFlags(AccessFlag.MODULE));\n","filename":"test\/jdk\/java\/lang\/invoke\/DefineClassTest.java","additions":61,"deletions":112,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @enablePreview\n@@ -35,0 +35,8 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.TypeKind;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -39,0 +47,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -46,0 +55,1 @@\n+import java.util.function.Consumer;\n@@ -48,1 +58,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -52,0 +61,2 @@\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -53,1 +64,0 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n@@ -58,0 +68,1 @@\n+    private static final ClassDesc CD_ClassDataTest = ClassDataTest.class.describeConstable().orElseThrow();\n@@ -297,3 +308,1 @@\n-        Handle bsm = new Handle(H_INVOKESTATIC, \"ClassDataTest\", \"getClassDataEntry\",\n-                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Object;\",\n-                false);\n+        DirectMethodHandleDesc bsm = ConstantDescs.ofConstantBootstrap(CD_ClassDataTest, \"getClassDataEntry\", CD_Object);\n@@ -303,1 +312,1 @@\n-                                         Class.class, new ConstantDynamic(\"class\", Type.getDescriptor(Class.class), bsm))\n+                                         Class.class, DynamicConstantDesc.ofNamed(bsm, \"class\", CD_Class))\n@@ -305,1 +314,1 @@\n-                                         MethodHandle.class, new ConstantDynamic(\"method\", Type.getDescriptor(MethodHandle.class), bsm))\n+                                         MethodHandle.class, DynamicConstantDesc.ofNamed(bsm, \"method\", CD_MethodHandle))\n@@ -345,2 +354,2 @@\n-        private final ClassWriter cw;\n-        private final String classname;\n+        private Consumer<ClassBuilder> cw;\n+        private final ClassDesc classname;\n@@ -353,10 +362,10 @@\n-            this.classname = classname;\n-            this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-            cw.visit(V14, ACC_FINAL | ACC_IDENTITY, classname, null, OBJECT_CLS, null);\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, OBJECT_CLS, \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            this.classname = ClassDesc.ofInternalName(classname);\n+            this.cw = clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withFlags(AccessFlag.FINAL);\n+                clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                    cob.aload(0);\n+                    cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                    cob.return_();\n+                });\n+            };\n@@ -366,2 +375,1 @@\n-            cw.visitEnd();\n-            byte[] bytes = cw.toByteArray();\n+            byte[] bytes = ClassFile.of().build(classname, cw);\n@@ -381,14 +389,8 @@\n-            MethodType mtype = MethodType.methodType(returnType);\n-            MethodVisitor mv = cw.visitMethod(accessFlags,\n-                                             \"classData\",\n-                                              mtype.descriptorString(), null, null);\n-            mv.visitCode();\n-            Handle bsm = new Handle(H_INVOKESTATIC, MHS_CLS, \"classData\",\n-                                    CLASS_DATA_BSM_DESCR,\n-                                    false);\n-            ConstantDynamic dynamic = new ConstantDynamic(\"_\", Type.getDescriptor(returnType), bsm);\n-            mv.visitLdcInsn(dynamic);\n-            mv.visitInsn(returnType == int.class ? IRETURN :\n-                            (returnType == float.class ? FRETURN : ARETURN));\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            ClassDesc returnDesc = returnType.describeConstable().orElseThrow();\n+            MethodTypeDesc mt = MethodTypeDesc.of(returnDesc);\n+            cw = cw.andThen(clb -> {\n+                clb.withMethodBody(\"classData\", mt, accessFlags, cob -> {\n+                    cob.constantInstruction(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA, DEFAULT_NAME, returnDesc));\n+                    cob.returnInstruction(TypeKind.from(returnType));\n+                });\n+            });\n@@ -402,13 +404,8 @@\n-            MethodType mtype = MethodType.methodType(returnType);\n-            MethodVisitor mv = cw.visitMethod(accessFlags,\n-                                              \"classData\",\n-                                               mtype.descriptorString(), null, null);\n-            mv.visitCode();\n-            Handle bsm = new Handle(H_INVOKESTATIC, \"java\/lang\/invoke\/MethodHandles\", \"classDataAt\",\n-                        \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;I)Ljava\/lang\/Object;\",\n-                        false);\n-            ConstantDynamic dynamic = new ConstantDynamic(\"_\", Type.getDescriptor(returnType), bsm, index);\n-            mv.visitLdcInsn(dynamic);\n-            mv.visitInsn(returnType == int.class? IRETURN : ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            ClassDesc returnDesc = returnType.describeConstable().orElseThrow();\n+            MethodTypeDesc mt = MethodTypeDesc.of(returnDesc);\n+            cw = cw.andThen(clb -> {\n+                clb.withMethodBody(\"classData\", mt, accessFlags, cob -> {\n+                    cob.constantInstruction(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA_AT, DEFAULT_NAME, returnDesc, index));\n+                    cob.returnInstruction(TypeKind.from(returnType));\n+                });\n+            });\n@@ -418,10 +415,9 @@\n-        ClassByteBuilder classData(int accessFlags, String name, Class<?> returnType, ConstantDynamic dynamic) {\n-            MethodType mtype = MethodType.methodType(returnType);\n-            MethodVisitor mv = cw.visitMethod(accessFlags,\n-                                              name,\n-                                              mtype.descriptorString(), null, null);\n-            mv.visitCode();\n-            mv.visitLdcInsn(dynamic);\n-            mv.visitInsn(returnType == int.class? IRETURN : ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+        ClassByteBuilder classData(int accessFlags, String name, Class<?> returnType, DynamicConstantDesc<?> dynamic) {\n+            ClassDesc returnDesc = returnType.describeConstable().orElseThrow();\n+            MethodTypeDesc mt = MethodTypeDesc.of(returnDesc);\n+            cw = cw.andThen(clb -> {\n+                clb.withMethodBody(name, mt, accessFlags, cob -> {\n+                    cob.constantInstruction(dynamic);\n+                    cob.returnInstruction(TypeKind.from(returnType));\n+                });\n+            });\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/classData\/ClassDataTest.java","additions":56,"deletions":60,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          jdk.compiler\n+ * @modules jdk.compiler\n@@ -29,0 +28,2 @@\n+ * @enablePreview\n+ * @comment Change enablePreview with the flag in setup's compileSources\n@@ -39,0 +40,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n@@ -40,4 +43,0 @@\n-\n-import static java.lang.invoke.MethodHandles.lookup;\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;\n-\n@@ -55,2 +54,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Type;\n@@ -64,1 +61,5 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.CD_Enum;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;\n@@ -81,1 +82,1 @@\n-        compileSources(SRC_DIR, CLASSES_DIR);\n+        compileSources(SRC_DIR, CLASSES_DIR, \"--enable-preview\", \"--release\", \"23\");\n@@ -268,2 +269,2 @@\n-        byte[] bytes = (accessFlags == (ACC_ENUM | ACC_IDENTITY)) ? classBytes(name, Enum.class, accessFlags)\n-                                                 : classBytes(name, accessFlags);\n+        byte[] bytes = (accessFlags == (ACC_ENUM | ACC_IDENTITY)) ? classBytes(name, CD_Enum, accessFlags)\n+                : classBytes(name, accessFlags);\n@@ -518,1 +519,1 @@\n-        return classBytes(classname, Object.class, accessFlags);\n+        return classBytes(classname, CD_Object, accessFlags);\n@@ -521,6 +522,5 @@\n-    private static byte[] classBytes(String classname, Class<?> supertType, int accessFlags) {\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V14, ACC_PUBLIC|accessFlags, classname, null, Type.getInternalName(supertType), null);\n-        cw.visitEnd();\n-\n-        return cw.toByteArray();\n+    private static byte[] classBytes(String classname, ClassDesc superType, int accessFlags) {\n+        return ClassFile.of().build(ClassDesc.ofInternalName(classname), clb -> clb\n+                .withVersion(JAVA_14_VERSION, 0)\n+                .withFlags(accessFlags | ACC_PUBLIC)\n+                .withSuperclass(superType));\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/BasicTest.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n- * @modules java.base\/jdk.internal.misc java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.misc\n+ * @enablePreview\n@@ -33,0 +34,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -37,1 +41,1 @@\n-import jdk.internal.org.objectweb.asm.*;\n+import java.lang.reflect.AccessFlag;\n@@ -40,1 +44,6 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -109,23 +118,14 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-\n-        cw.visit(52, ACC_SUPER | ACC_PUBLIC, pkg+\"\/MyClass\", null, \"java\/lang\/Object\", null);\n-        {\n-            mv = cw.visitMethod(0, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"get\", \"(I)Ljava\/lang\/Object;\", null, null);\n-            mv.visitCode();\n-            mv.visitInsn(ACONST_NULL);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return ClassFile.of().build(ClassDesc.of(pkg.replace('\/', '.'), \"MyClass\"), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+            clb.withMethodBody(INIT_NAME, MTD_void, 0, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object, CD_int),\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                cob.aconst_null();\n+                cob.areturn();\n+            });\n+        });\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/StaticInvocableTest.java","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @enablePreview\n@@ -33,0 +33,4 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -36,1 +40,2 @@\n-import jdk.internal.org.objectweb.asm.*;\n+import java.lang.reflect.AccessFlag;\n+\n@@ -38,1 +43,5 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.constant.DirectMethodHandleDesc.Kind.SPECIAL;\n@@ -75,0 +84,6 @@\n+    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n+    private static final MethodTypeDesc MTD_Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup);\n+    private static final String METHOD_NAME = \"m\";\n+    private static final ClassDesc CD_T1 = ClassDesc.of(\"T1\");\n+    private static final ClassDesc CD_T2 = ClassDesc.of(\"T2\");\n+    private static final ClassDesc CD_T3 = ClassDesc.of(\"T3\");\n@@ -106,22 +121,13 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-\n-        cw.visit(52, ACC_PUBLIC + ACC_SUPER, \"T1\", null, \"java\/lang\/Object\", null);\n-\n-        mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitCode();\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(ACC_PUBLIC, \"m\", \"()I\", null, null);\n-        mv.visitCode();\n-        mv.visitIntInsn(BIPUSH, 1);\n-        mv.visitInsn(IRETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return ClassFile.of().build(CD_T1, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(METHOD_NAME, MTD_int, ACC_PUBLIC, cob -> {\n+                cob.bipush(1);\n+                cob.ireturn();\n+            });\n+        });\n@@ -131,22 +137,13 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-\n-        cw.visit(52, ACC_PUBLIC + ACC_SUPER, \"T2\", null, \"T1\", null);\n-\n-        mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitCode();\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"T1\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"m\", \"()I\", null, null);\n-        mv.visitCode();\n-        mv.visitIntInsn(BIPUSH, 2);\n-        mv.visitInsn(IRETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return ClassFile.of().build(CD_T2, clb -> {\n+            clb.withSuperclass(CD_T1);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_T1, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(METHOD_NAME, MTD_int, ACC_PUBLIC | ACC_STATIC, cob -> {\n+                cob.bipush(2);\n+                cob.ireturn();\n+            });\n+        });\n@@ -156,38 +153,23 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-\n-        cw.visit(52, ACC_PUBLIC + ACC_SUPER, \"T3\", null, \"T2\", null);\n-\n-        mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitCode();\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"T2\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(ACC_PUBLIC, \"m\", \"()I\", null, null);\n-        mv.visitCode();\n-        mv.visitIntInsn(BIPUSH, 3);\n-        mv.visitInsn(IRETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        \/\/ getMethodHandle\n-        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"getMethodHandle\", \"()Ljava\/lang\/invoke\/MethodHandle;\", null, null);\n-        mv.visitCode();\n-        mv.visitLdcInsn(new Handle(H_INVOKESPECIAL, \"T1\", \"m\", \"()I\"));\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(1, 0);\n-        mv.visitEnd();\n-\n-        \/\/ getLookup\n-        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"getLookup\", \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null, null);\n-        mv.visitCode();\n-        mv.visitMethodInsn(INVOKESTATIC, \"java\/lang\/invoke\/MethodHandles\", \"lookup\", \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(1, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return ClassFile.of().build(CD_T3, clb -> {\n+            clb.withSuperclass(CD_T2);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_T2, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(METHOD_NAME, MTD_int, ACC_PUBLIC, cob -> {\n+                cob.bipush(3);\n+                cob.ireturn();\n+            });\n+            clb.withMethodBody(\"getMethodHandle\", MethodTypeDesc.of(CD_MethodHandle),\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                cob.constantInstruction(MethodHandleDesc.ofMethod(SPECIAL, CD_T1, METHOD_NAME, MTD_int));\n+                cob.areturn();\n+            });\n+            clb.withMethodBody(\"getLookup\", MTD_Lookup,\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                cob.invokestatic(CD_MethodHandles, \"lookup\", MTD_Lookup);\n+                cob.areturn();\n+            });\n+        });\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/SpecialStatic.java","additions":68,"deletions":86,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @enablePreview\n@@ -35,2 +35,3 @@\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -39,2 +40,3 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n+\n+import java.lang.classfile.attribute.RecordAttribute;\n+import java.lang.classfile.attribute.RecordComponentInfo;\n@@ -45,1 +47,3 @@\n-import static jdk.internal.org.objectweb.asm.ClassWriter.*;\n+import static java.lang.classfile.ClassFile.ACC_ABSTRACT;\n+import static java.lang.classfile.ClassFile.ACC_FINAL;\n+import static java.lang.constant.ConstantDescs.CD_int;\n@@ -86,1 +90,1 @@\n-        List<RecordComponentEntry> rc = null;\n+        List<RecordComponentInfo> rc = null;\n@@ -88,1 +92,1 @@\n-            rc = List.of(new RecordComponentEntry(\"x\", \"I\"));\n+            rc = List.of(RecordComponentInfo.of(\"x\", CD_int));\n@@ -113,1 +117,1 @@\n-        List<RecordComponentEntry> rc = null;\n+        List<RecordComponentInfo> rc = null;\n@@ -115,1 +119,1 @@\n-            rc = List.of(new RecordComponentEntry(\"x\", \"I\"));\n+            rc = List.of(RecordComponentInfo.of(\"x\", CD_int));\n@@ -165,21 +169,12 @@\n-                              List<RecordComponentEntry> components) {\n-        ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n-\n-        int access = 0;\n-        if (isFinal)\n-            access = access | Opcodes.ACC_FINAL;\n-        if (isAbstract)\n-            access = access | Opcodes.ACC_ABSTRACT;\n-\n-        cw.visit(Opcodes.V16,\n-                 access | Opcodes.ACC_IDENTITY,\n-                 className,\n-                 null,\n-                 superName,\n-                 null);\n-\n-        if (components != null)\n-            components.forEach(rc -> cw.visitRecordComponent(rc.name(), rc.descriptor(), null));\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+                              List<RecordComponentInfo> components) {\n+        return ClassFile.of().build(ClassDesc.ofInternalName(className), clb -> {\n+            int access = 0;\n+            if (isFinal)\n+                access = access | ACC_FINAL;\n+            if (isAbstract)\n+                access = access | ACC_ABSTRACT;\n+            clb.withFlags(access);\n+            clb.withSuperclass(ClassDesc.ofInternalName(superName));\n+            if (components != null)\n+                clb.accept(RecordAttribute.of(components));\n+        });\n@@ -188,2 +183,0 @@\n-    record RecordComponentEntry (String name, String descriptor) { }\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/IsRecordTest.java","additions":26,"deletions":33,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          jdk.compiler\n+ * @modules jdk.compiler\n+ * @enablePreview\n@@ -35,0 +35,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -37,0 +40,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -48,4 +52,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-\n@@ -56,0 +56,7 @@\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.MTD_void;\n+\n@@ -210,43 +217,24 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V9,\n-                ACC_PUBLIC + ACC_SUPER,\n-                \"p\/ProviderFactory\",\n-                null,\n-                \"java\/lang\/Object\",\n-                null);\n-\n-        \/\/ public static p.Service provider()\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC,\n-                \"provider\",\n-                \"()Lp\/Service;\",\n-                null,\n-                null);\n-        mv.visitTypeInsn(NEW, \"p\/ProviderFactory$1\");\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL,\n-                \"p\/ProviderFactory$1\",\n-                \"<init>\", \"()V\",\n-                false);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ public static p.ProviderFactory$1 provider()\n-        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC,\n-                \"provider\",\n-                \"()Lp\/ProviderFactory$1;\",\n-                null,\n-                null);\n-        mv.visitTypeInsn(NEW, \"p\/ProviderFactory$1\");\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL,\n-                \"p\/ProviderFactory$1\",\n-                \"<init>\",\n-                \"()V\",\n-                false);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n+        var bytes = ClassFile.of().build(ClassDesc.of(\"p\", \"ProviderFactory\"), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.IDENTITY);\n+\n+            var providerFactory$1 = ClassDesc.of(\"p\", \"ProviderFactory$1\");\n+\n+            \/\/ public static p.Service provider()\n+            clb.withMethodBody(\"provider\", MethodTypeDesc.of(ClassDesc.of(\"p\", \"Service\")),\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                        cob.new_(providerFactory$1);\n+                        cob.dup();\n+                        cob.invokespecial(providerFactory$1, INIT_NAME, MTD_void);\n+                        cob.areturn();\n+                    });\n+\n+            \/\/ public static p.ProviderFactory$1 provider()\n+            clb.withMethodBody(\"provider\", MethodTypeDesc.of(providerFactory$1),\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                        cob.new_(providerFactory$1);\n+                        cob.dup();\n+                        cob.invokespecial(providerFactory$1, INIT_NAME, MTD_void);\n+                        cob.areturn();\n+                    });\n+        });\n@@ -258,1 +246,1 @@\n-        Files.write(classFile, cw.toByteArray());\n+        Files.write(classFile, bytes);\n","filename":"test\/jdk\/java\/util\/ServiceLoader\/BadProvidersTest.java","additions":39,"deletions":51,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-import java.util.stream.Collectors;\n@@ -87,4 +86,0 @@\n-\n-        public void putAll(Map<String, String> map) {\n-            map.entrySet().forEach(e -> put(e.getKey(), () -> e.getValue()));\n-        }\n@@ -143,1 +138,0 @@\n-        map.putAll(xOptFlags()); \/\/ -Xmx4g -> @requires vm.opt.x.Xmx == \"4g\" )\n@@ -723,21 +717,0 @@\n-    \/**\n-     * Parses extra options, options that start with -X excluding the\n-     * bare -X option (as it is not considered an extra option).\n-     * Ignores extra options not starting with -X\n-     *\n-     * This could be improved to handle extra options not starting\n-     * with -X as well as \"standard\" options.\n-     *\/\n-    private Map<String, String> xOptFlags() {\n-        return allFlags()\n-            .filter(s -> s.startsWith(\"-X\") && !s.startsWith(\"-XX:\") && !s.equals(\"-X\"))\n-            .map(s -> s.replaceFirst(\"-\", \"\"))\n-            .map(flag -> flag.splitWithDelimiters(\"[:0123456789]\", 2))\n-            .collect(Collectors.toMap(a -> \"vm.opt.x.\" + a[0],\n-                                      a -> (a.length == 1)\n-                                      ? \"true\" \/\/ -Xnoclassgc\n-                                      : (a[1].equals(\":\")\n-                                         ? a[2]            \/\/ [\"-XshowSettings\", \":\", \"system\"]\n-                                         : a[1] + a[2]))); \/\/ [\"-Xmx\", \"4\", \"g\"]\n-    }\n-\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"}]}