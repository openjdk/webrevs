{"files":[{"patch":"@@ -1672,1 +1672,1 @@\n-        boolean isConstructor() { return !isPartial() && \"<init>\".equals(name); }\n+        boolean isConstructor() { return !isPartial() && (\"<init>\".equals(name) || \"<vnew>\".equals(name)); }\n@@ -3835,1 +3835,1 @@\n-        throw new NoSuchMethodException(methodToString(\"<init>\", parameterTypes));\n+        throw new NoSuchMethodException(methodToString(isValue() ? \"<vnew>\" : \"<init>\", parameterTypes));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    private static final Set<String> pointyNames = Set.of(\"<init>\", \"<clinit>\");\n+    private static final Set<String> pointyNames = Set.of(\"<init>\", \"<vnew>\", \"<clinit>\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-     * For constructors, returns the reserved name {@code \"<init>\"}.\n+     * For constructors, returns the reserved name {@code \"<init>\"} or {@code \"<vnew>\"}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDesc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-            name = \"<init>\";\n+            name = owner.isPrimitiveValueType() ? \"<vnew>\" : \"<init>\";\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDescImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-     *  For a constructor, it is always {@code \"<init>\"}.\n+     *  For a constructor, it is {@code \"<init>\"} or {@code \"<vnew>\"}.\n@@ -488,1 +488,2 @@\n-    static final String CONSTRUCTOR_NAME = \"<init>\";  \/\/ the ever-popular\n+    static final String CONSTRUCTOR_NAME = \"<init>\";\n+    static final String VALUE_FACTORY_NAME = \"<vnew>\";  \/\/ the ever-popular\n@@ -525,0 +526,4 @@\n+    \/** Query whether this member is a constructor. *\/\n+    boolean isConstructor(String name) {\n+        return CONSTRUCTOR_NAME.equals(name) || VALUE_FACTORY_NAME.equals(name);\n+    }\n@@ -527,1 +532,1 @@\n-        return isObjectConstructor() || (getName().equals(CONSTRUCTOR_NAME) && testAllFlags(IS_METHOD));\n+        return isObjectConstructor() || (isConstructor(getName()) && isMethod());\n@@ -698,1 +703,2 @@\n-        this.name = CONSTRUCTOR_NAME;\n+        this.name = this.clazz.isValue() ? VALUE_FACTORY_NAME\n+                                          : CONSTRUCTOR_NAME;\n@@ -841,1 +847,1 @@\n-     *  It will be a constructor if and only if the name is {@code \"<init>\"}.\n+     *  It will be a constructor if and only if the name is {@code \"<init>\"} or {@code \"<vnew>\"}.\n@@ -847,1 +853,1 @@\n-        int initFlags = (name != null && name.equals(CONSTRUCTOR_NAME) && type.returnType() == void.class ? IS_OBJECT_CONSTRUCTOR : IS_METHOD);\n+        int initFlags = isConstructor(name) ? IS_OBJECT_CONSTRUCTOR : IS_METHOD;\n@@ -867,1 +873,1 @@\n-                !CONSTRUCTOR_NAME.equals(name))\n+                !isConstructor(name))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -163,2 +163,2 @@\n-     * This is {@code \"<init>\"} if the underlying member was a constructor,\n-     * else it is a simple method name or field name.\n+     * This is {@code \"<init>\"} or {@code \"<vnew>\"} if the underlying member\n+     * was a constructor, else it is a simple method name or field name.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -709,1 +709,1 @@\n-     * with special names ({@code \"<init>\"} and {@code \"<clinit>\"}).\n+     * with special names ({@code \"<init>\"}, {@code \"<vnew>\"} and {@code \"<clinit>\"}).\n@@ -2602,1 +2602,1 @@\n-            if (!method.isStatic() && name.equals(\"<init>\")) {\n+            if (!method.isStatic() && (name.equals(\"<init>\") || name.equals(\"<vnew>\"))) {\n@@ -2753,1 +2753,1 @@\n-         * This method does not find a static {@code <init>} factory method as it is invoked\n+         * This method does not find a static {@code <init>\/<vnew>} factory method as it is invoked\n@@ -2755,1 +2755,1 @@\n-         * object constructor.  To look up static {@code <init>} factory method, use\n+         * object constructor.  To look up static {@code <init>\/<vnew>} factory method, use\n@@ -2776,1 +2776,1 @@\n-            String name = \"<init>\";\n+            String name = refc.isValue() ? \"<vnew>\" : \"<init>\";\n@@ -2972,1 +2972,1 @@\n-         * <em>(Note:  JVM internal methods named {@code \"<init>\"} are not visible to this API,\n+         * <em>(Note:  JVM internal methods named {@code \"<init>\"\/\"<vnew>\"} are not visible to this API,\n@@ -3745,1 +3745,1 @@\n-                    !(refKind == REF_invokeStatic && name.equals(\"<init>\"))) {\n+                    !(refKind == REF_invokeStatic && (name.equals(\"<init>\") || name.equals(\"<vnew>\")))) {\n@@ -4021,1 +4021,1 @@\n-                assert(!method.getName().equals(\"<init>\"));  \/\/ not this code path\n+                assert(!method.getName().equals(\"<init>\") && !method.getName().equals(\"<vnew>\"));  \/\/ not this code path\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+        boolean isValueClass = declaringClass.isValue();\n@@ -119,1 +120,1 @@\n-                     \"<init>\",\n+                     isValueClass ? \"<vnew>\" : \"<init>\",\n@@ -121,1 +122,1 @@\n-                     Void.TYPE,\n+                     isValueClass ? declaringClass : Void.TYPE,\n@@ -188,1 +189,1 @@\n-        \/\/ +   [UTF-8] \"<init>\"\n+        \/\/ +   [UTF-8] \"<init>\" or \"<vnew>\"\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodAccessorGenerator.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -142,4 +142,4 @@\n-     * initializer}  For a constructor, the name {@code \"<init>\"} is\n-     * returned, for a static initializer, the name {@code \"<clinit>\"}\n-     * is returned, and for an anonymous class or instance\n-     * initializer, an <a href=Name.html#empty_name>empty name<\/a> is\n+     * initializer}  For a constructor, the name {@code \"<init>\"} or\n+     * {@code \"<vnew>\"} is returned, for a static initializer, the\n+     * name {@code \"<clinit>\"} is returned, and for an anonymous class\n+     * or instance initializer, an <a href=Name.html#empty_name>empty name<\/a> is\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ExecutableElement.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -618,1 +618,2 @@\n-        for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n+        Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n+        for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n@@ -638,1 +639,1 @@\n-        if (methodName == names.init)\n+        if (names.isInitOrVNew(methodName))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -388,3 +388,1 @@\n-            String ms = (s.name == s.name.table.names.init)\n-                    ? s.owner.name.toString()\n-                    : s.name.toString();\n+            String ms = s.isInitOrVNew() ? s.owner.name.toString() : s.name.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-        if (name == name.table.names.init && owner.hasOuterInstance()) {\n+        if (isInitOrVNew() && owner.hasOuterInstance()) {\n@@ -427,0 +427,4 @@\n+    public boolean isConcreteValueClass() {\n+        return isValueClass() && !isAbstract();\n+    }\n+\n@@ -486,1 +490,7 @@\n-        return ((name == name.table.names.init && this.type.getReturnType().tsym == this.owner));\n+        return name == name.table.names.vnew && this.type.getReturnType().tsym == this.owner;\n+    }\n+\n+    \/** Is this symbol a constructor or value factory?\n+     *\/\n+    public boolean isInitOrVNew() {\n+        return name.table.names.isInitOrVNew(name);\n@@ -1992,1 +2002,1 @@\n-                String s = (name == name.table.names.init)\n+                String s = isInitOrVNew()\n@@ -2054,1 +2064,1 @@\n-            if (isConstructor() || _other.kind != MTH) return false;\n+            if (isInitOrVNew() || _other.kind != MTH) return false;\n@@ -2123,1 +2133,1 @@\n-            if (isConstructor() || _other.kind != MTH) return false;\n+            if (isInitOrVNew() || _other.kind != MTH) return false;\n@@ -2248,1 +2258,1 @@\n-            if (name == name.table.names.init)\n+            if (isInitOrVNew())\n@@ -2421,1 +2431,1 @@\n-                if (refSym.isConstructor()) {\n+                if (refSym.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-                    !s.isConstructor())\n+                    !s.isInitOrVNew())\n@@ -243,1 +243,1 @@\n-                    (s.kind == MTH && !s.isConstructor() &&\n+                    (s.kind == MTH && !s.isInitOrVNew() &&\n@@ -245,1 +245,1 @@\n-                    (s.kind == MTH && s.isConstructor()))\n+                    (s.kind == MTH && s.isInitOrVNew()))\n@@ -1056,1 +1056,1 @@\n-                    } else if (exsym.isConstructor()) {\n+                    } else if (exsym.isInitOrVNew()) {\n@@ -1159,1 +1159,1 @@\n-                    if (tree.sym.isConstructor()) {\n+                    if (tree.sym.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -978,1 +978,1 @@\n-                        t.name != names.init &&\n+                        !names.isInitOrVNew(t.name) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-            ((owner.name == names.init ||    \/\/ i.e. we are in a constructor\n+            ((names.isInitOrVNew(owner.name) ||    \/\/ i.e. we are in a constructor\n@@ -1080,1 +1080,1 @@\n-                if (tree.name == names.init) {\n+                if (names.isInitOrVNew(tree.name)) {\n@@ -1195,1 +1195,1 @@\n-                if (tree.name == names.init && owner.type != syms.objectType) {\n+                if (names.isInitOrVNew(tree.name) && owner.type != syms.objectType) {\n@@ -2643,1 +2643,1 @@\n-            if (enclMethod != null && enclMethod.name == names.init) {\n+            if (enclMethod != null && names.isInitOrVNew(enclMethod.name)) {\n@@ -3544,1 +3544,2 @@\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n+                    Name constructorName = owner.isConcreteValueClass() ? names.vnew : names.init;\n+                    for (Symbol s : enclClass.members_field.getSymbolsByName(constructorName)) {\n@@ -3607,0 +3608,1 @@\n+            Symbol lhsSym = TreeInfo.symbol(that.expr);\n@@ -3608,0 +3610,4 @@\n+                \/\/ TODO - a bit hacky but...\n+                if (lhsSym != null && lhsSym.isConcreteValueClass() && that.name == names.init) {\n+                    that.name = names.vnew;\n+                }\n@@ -3613,1 +3619,0 @@\n-                Symbol lhsSym = TreeInfo.symbol(that.expr);\n@@ -3697,1 +3702,1 @@\n-            that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;\n+            that.sym = refSym.isInitOrVNew() ? refSym.baseSymbol() : refSym;\n@@ -4761,1 +4766,1 @@\n-            if (sym.name != names.init || tree.hasTag(REFERENCE)) {\n+            if (!names.isInitOrVNew(sym.name) || tree.hasTag(REFERENCE)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -784,1 +784,1 @@\n-                    } else if (s.isConstructor()) {\n+                    } else if (s.isInitOrVNew()) {\n@@ -795,1 +795,1 @@\n-                                log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, fragment));\n+                            log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, fragment));\n@@ -1127,1 +1127,1 @@\n-                (s.isConstructor() ||\n+                (s.isInitOrVNew() ||\n@@ -1203,0 +1203,1 @@\n+        \/\/ TODO - is enum so <init>\n@@ -1386,1 +1387,1 @@\n-            if (sym.name == names.init) {\n+            if (names.isInitOrVNew(sym.name)) {\n@@ -1789,1 +1790,1 @@\n-                    env.enclMethod != null && env.enclMethod.name == names.init;\n+                    env.enclMethod != null && names.isInitOrVNew(env.enclMethod.name);\n@@ -2385,1 +2386,1 @@\n-                (env.info.isAnonymousDiamond && !m.isConstructor() && !m.isPrivate());\n+                (env.info.isAnonymousDiamond && !m.isInitOrVNew() && !m.isPrivate());\n@@ -2936,1 +2937,1 @@\n-                     !s.isConstructor();\n+                     !s.isInitOrVNew();\n@@ -2995,1 +2996,1 @@\n-                     !s.isConstructor();\n+                     !s.isInitOrVNew();\n@@ -3682,1 +3683,1 @@\n-                if (s.kind == MTH && !s.isConstructor())\n+                if (s.kind == MTH && !s.isInitOrVNew())\n@@ -3690,1 +3691,1 @@\n-                if (s.kind == MTH && s.isConstructor())\n+                if (s.kind == MTH && s.isInitOrVNew())\n@@ -3709,1 +3710,1 @@\n-                        (s.kind == MTH && !s.isConstructor() &&\n+                        (s.kind == MTH && !s.isInitOrVNew() &&\n@@ -3711,1 +3712,1 @@\n-                        (s.kind == MTH && s.isConstructor())) {\n+                        (s.kind == MTH && s.isInitOrVNew())) {\n@@ -4975,1 +4976,1 @@\n-                    if (sym.isConstructor() &&\n+                    if (sym.isInitOrVNew() &&\n@@ -5003,1 +5004,1 @@\n-                        if (sym.isConstructor()) {\n+                        if (sym.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-                Name name = msym.name == msym.name.table.names.init ?\n+                Name name = msym.name.table.names.isInitOrVNew(msym.name) ?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -356,1 +356,2 @@\n-            if ((init = (owner.name == names.init)) || owner.name == names.clinit) {\n+            \/\/ TODO - can <vnew> exist in this context?\n+            if ((init = names.isInitOrVNew(owner.name)) || owner.name == names.clinit) {\n@@ -1664,1 +1665,2 @@\n-                for (Symbol s : csym.members_field.getSymbolsByName(names.init)) {\n+                Name constructorName = csym.isConcreteValueClass() ? names.vnew : names.init;\n+                for (Symbol s : csym.members_field.getSymbolsByName(constructorName)) {\n@@ -1768,1 +1770,1 @@\n-                    && sym.name != names.init;\n+                    && !names.isInitOrVNew(sym.name);\n@@ -1890,0 +1892,2 @@\n+                } else if (methodName.equals(\"<vnew>\")) {\n+                    methodName = \"vnew\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1054,1 +1054,1 @@\n-        } else if (sym.name == names.init && sym.owner.isDirectlyOrIndirectlyLocal()) {\n+        } else if (names.isInitOrVNew(sym.name) && sym.owner.isDirectlyOrIndirectlyLocal()) {\n@@ -1267,0 +1267,1 @@\n+                Name constructorName = accOwner.isConcreteValueClass() ? names.vnew : names.init;\n@@ -1269,1 +1270,1 @@\n-                    names.init,\n+                    constructorName,\n@@ -1313,1 +1314,1 @@\n-        if (sym.name == names.init) {\n+        if (names.isInitOrVNew(sym.name)) {\n@@ -1527,1 +1528,1 @@\n-            (owner.isConstructor() && owner.isAnonymous()) ||\n+            (owner.isInitOrVNew() && owner.isAnonymous()) ||\n@@ -1529,1 +1530,1 @@\n-            (owner.isConstructor() && c.isInner() &&\n+            (owner.isInitOrVNew() && c.isInner() &&\n@@ -2662,0 +2663,1 @@\n+        \/\/ TODO - enum so is always <init>\n@@ -2703,1 +2705,1 @@\n-        if (tree.name == names.init &&\n+        if (names.isInitOrVNew(tree.name) &&\n@@ -2784,1 +2786,1 @@\n-        if (tree.name == names.init && (tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+        if (names.isInitOrVNew(tree.name) && (tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n@@ -3025,1 +3027,2 @@\n-        if (meth.name == names.init && meth.owner == syms.enumSym)\n+        \/\/ TODO - is enum so always <init>.\n+        if (names.isInitOrVNew(meth.name) && meth.owner == syms.enumSym)\n@@ -3030,1 +3033,1 @@\n-        if (meth.name==names.init) {\n+        if (names.isInitOrVNew(meth.name)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    private final boolean allowValueClasses;\n@@ -84,0 +85,2 @@\n+        Source source = Source.instance(context);\n+        allowValueClasses = Source.Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -180,0 +183,3 @@\n+        if (tree.name == tree.name.table.names.init && allowValueClasses && enclScope.owner.isConcreteValueClass()) {\n+            tree.name = tree.name.table.names.vnew;\n+        }\n@@ -233,1 +239,1 @@\n-        if (m.isConstructor() && m.type.getParameterTypes().size() == 0) {\n+        if (m.isInitOrVNew() && m.type.getParameterTypes().size() == 0) {\n@@ -347,1 +353,1 @@\n-        if (m.isConstructor()) {\n+        if (m.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1058,1 +1058,2 @@\n-            for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n+            Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n+            for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+    public final boolean allowValueClasses;\n@@ -143,1 +144,0 @@\n-        Target target = Target.instance(context);\n@@ -150,0 +150,1 @@\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -219,1 +220,1 @@\n-        if (bestSoFar.name == names.init &&\n+        if (names.isInitOrVNew(bestSoFar.name) &&\n@@ -292,1 +293,1 @@\n-        return owner.isConstructor() ||\n+        return owner.isInitOrVNew() ||\n@@ -404,1 +405,1 @@\n-        if (sym.name == names.init && sym.owner != site.tsym) return false;\n+        if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) return false;\n@@ -481,1 +482,1 @@\n-        if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())\n+        if (sym.kind != MTH || sym.isInitOrVNew() || sym.isStatic())\n@@ -1884,1 +1885,1 @@\n-            if (name == names.init) return bestSoFar;\n+            if (names.isInitOrVNew(name)) return bestSoFar;\n@@ -2929,1 +2930,2 @@\n-        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n+        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n+        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n@@ -2963,0 +2965,1 @@\n+        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2964,1 +2967,1 @@\n-                                    names.init, argtypes,\n+                                    constructorName, argtypes,\n@@ -2987,0 +2990,1 @@\n+        Name constructorName = allowValueClasses && site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2988,1 +2992,1 @@\n-                new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n+                new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n@@ -3003,1 +3007,1 @@\n-                                sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);\n+                                sym = accessMethod(sym, pos, site, constructorName, true, argtypes, typeargtypes);\n@@ -3050,1 +3054,2 @@\n-        for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n+        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n+        for (final Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n@@ -3059,1 +3064,1 @@\n-                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {\n+                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), constructorName, constrType, site.tsym) {\n@@ -3101,1 +3106,1 @@\n-        if (!name.equals(names.init)) {\n+        if (!names.isInitOrVNew(name)) {\n@@ -3693,1 +3698,2 @@\n-            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n+            \/\/ TODO - array constructor will be <init>\n+            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -3725,1 +3731,1 @@\n-            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -4130,1 +4136,1 @@\n-            boolean isConstructor = name == names.init;\n+            boolean isConstructor = names.isInitOrVNew(name);\n@@ -4222,1 +4228,1 @@\n-                      ws.name == names.init ? ws.owner.name : ws.name,\n+                      names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n@@ -4278,0 +4284,1 @@\n+                boolean isConstructor = names.isInitOrVNew(name);\n@@ -4286,2 +4293,2 @@\n-                        name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),\n-                        name == names.init ? site.tsym.name : name,\n+                        isConstructor ? KindName.CONSTRUCTOR : kind.absentKind(),\n+                        isConstructor ? site.tsym.name : name,\n@@ -4447,1 +4454,1 @@\n-            if (sym.name == names.init && sym.owner != site.tsym) {\n+            if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) {\n@@ -4660,1 +4667,1 @@\n-            if (sname == names.init) sname = s1.owner.name;\n+            if (names.isInitOrVNew(sname)) sname = s1.owner.name;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -324,1 +324,1 @@\n-                sym.name != names.init &&\n+                !names.isInitOrVNew(sym.name) &&\n@@ -680,0 +680,1 @@\n+        \/\/ TODO - is enum so <init>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1154,1 +1154,1 @@\n-                            } else if (s.isConstructor()) {\n+                            } else if (s.isInitOrVNew()) {\n@@ -1364,1 +1364,2 @@\n-                constructorSymbol = new MethodSymbol(flags, names.init,\n+                Name constructorName = owner().isConcreteValueClass() ? names.vnew : names.init;\n+                constructorSymbol = new MethodSymbol(flags, constructorName,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -821,1 +821,1 @@\n-                    if (sym.isConstructor()  && sym.type.getParameterTypes().size() == 0) {\n+                    if (sym.isInitOrVNew()  && sym.type.getParameterTypes().size() == 0) {\n@@ -1011,1 +1011,1 @@\n-                        if (sym.kind == MTH  && sym.name == names.init && !sym.type.getReturnType().hasTag(TypeTag.VOID)) {\n+                        if (sym.kind == MTH  && sym.name == names.vnew && !sym.type.getReturnType().hasTag(TypeTag.VOID)) {\n@@ -1362,1 +1362,1 @@\n-        if (nt.name != names.init)\n+        if (!names.isInitOrVNew(nt.name))\n@@ -2275,1 +2275,1 @@\n-        if (name == names.init && ((flags & STATIC) != 0)) {\n+        if (names.isInitOrVNew(name) && ((flags & STATIC) != 0)) {\n@@ -2283,1 +2283,1 @@\n-        if (name == names.init && currentOwner.hasOuterInstance()) {\n+        if (names.isInitOrVNew(name) && currentOwner.hasOuterInstance()) {\n@@ -2326,1 +2326,1 @@\n-            (name == names.init && !t.getReturnType().hasTag(TypeTag.VOID))) {\n+            ((name == names.init || name ==names.vnew) && !t.getReturnType().hasTag(TypeTag.VOID))) {\n@@ -2396,1 +2396,1 @@\n-            if (sym.name == names.init && currentOwner.hasOuterInstance()) {\n+            if (names.isInitOrVNew(sym.name) && currentOwner.hasOuterInstance()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1037,1 +1037,1 @@\n-                || ((m.flags_field & RECORD) != 0 && (m.isConstructor() || m.isValueObjectFactory())))) {\n+                || ((m.flags_field & RECORD) != 0 && (m.isInitOrVNew() || m.isValueObjectFactory())))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-        if (member.isConstructor())\n+        if (member.isInitOrVNew())\n@@ -1385,1 +1385,1 @@\n-            if (meth.isConstructor() && thisType != syms.objectType) {\n+            if (meth.isInitOrVNew() && thisType != syms.objectType) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-        else items.makeMemberItem(msym, name == names.init).invoke();\n+        else items.makeMemberItem(msym, names.isInitOrVNew(name)).invoke();\n@@ -564,1 +564,1 @@\n-        if (md.name == names.init && TreeInfo.isInitialConstructor(md)) {\n+        if (names.isInitOrVNew(md.name) && TreeInfo.isInitialConstructor(md)) {\n@@ -967,1 +967,1 @@\n-            if (meth.isConstructor()) {\n+            if (meth.isInitOrVNew()) {\n@@ -1074,1 +1074,1 @@\n-                if (meth.isConstructor() && selfType != syms.objectType)\n+                if (meth.isInitOrVNew() && selfType != syms.objectType)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import static com.sun.tools.javac.code.Flags.RECORD;\n@@ -374,1 +375,1 @@\n-        return currentClass != null && (currentClass.sym.flags() & (ABSTRACT | VALUE_CLASS)) == VALUE_CLASS && currentMethod != null && currentMethod.sym.isConstructor();\n+        return currentClass != null && (currentClass.sym.flags() & (ABSTRACT | VALUE_CLASS)) == VALUE_CLASS && currentMethod != null && currentMethod.sym.name == names.vnew;\n@@ -385,1 +386,1 @@\n-        Assert.check(init.name.equals(names.init));\n+        Assert.check(init.name.equals(names.vnew));\n@@ -396,1 +397,1 @@\n-                                        names.init,\n+                                        names.vnew,\n@@ -415,1 +416,1 @@\n-        if (md.name == names.init && md.body != null) {\n+        if (names.isInitOrVNew(md.name) && md.body != null) {\n@@ -430,15 +431,0 @@\n-\n-    private MethodSymbol getDefaultConstructor(Symbol klass) {\n-        for (Symbol method : klass.members().getSymbolsByName(names.init, s->s.kind == MTH && s.type.getParameterTypes().size() == 0, LookupKind.NON_RECURSIVE)) {\n-            return (MethodSymbol) method;\n-        }\n-        \/\/ class defines a non-nullary but no nullary constructor, fabricate a symbol.\n-        MethodType dctorType = new MethodType(List.nil(),\n-                klass.type,\n-                List.nil(),\n-                klass.type.tsym);\n-        return new MethodSymbol(Flags.PUBLIC,\n-                names.init,\n-                dctorType,\n-                klass);\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":5,"deletions":19,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1702,1 +1702,1 @@\n-                                ((JCMethodDecl) t).sym.name == names.init ||\n+                                names.isInitOrVNew(((JCMethodDecl) t).sym.name) ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2370,0 +2370,1 @@\n+            \/\/ TODO - will be converted in Attr\n@@ -4104,1 +4105,2 @@\n-                if (methDef.name == names.init && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+                \/\/ TODO - specifically for record.\n+                if (names.isInitOrVNew(methDef.name) && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n@@ -4698,1 +4700,1 @@\n-            if (!isRecord || name != names.init || token.kind == LPAREN) {\n+            if (!isRecord || !names.isInitOrVNew(name) || token.kind == LPAREN) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -961,0 +961,4 @@\n+\n+        public boolean isInitOrVNew() {\n+            return name.table.names.isInitOrVNew(name);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -596,1 +596,1 @@\n-            if (tree.name == tree.name.table.names.init &&\n+            if (tree.isInitOrVNew() &&\n@@ -603,1 +603,1 @@\n-            if (tree.name == tree.name.table.names.init) {\n+            if (tree.isInitOrVNew()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,12 @@\n-            return name == name.table.names.init;\n+            return name == name.table.names.init || name == name.table.names.vnew;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    \/** Is tree a value factory declaration?\n+     *\/\n+    public static boolean isValueFactory(JCTree tree) {\n+        if (tree.hasTag(METHODDEF)) {\n+            Name name = ((JCMethodDecl) tree).name;\n+            return name == name.table.names.vnew;\n@@ -109,1 +120,1 @@\n-            if (isConstructor(l.head)) return true;\n+            if (isConstructor(l.head) || isValueFactory(l.head)) return true;\n@@ -255,2 +266,1 @@\n-        Names names = md.name.table.names;\n-        if (md.name != names.init) return null;\n+        if (!md.isInitOrVNew()) return null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+    public final Name vnew;\n@@ -288,0 +289,1 @@\n+        vnew = fromString(\"<vnew>\");\n@@ -434,0 +436,4 @@\n+    public boolean isInitOrVNew(Name name) {\n+        return name == init || name == vnew;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -434,3 +434,1 @@\n-                String ms = (s.name == s.name.table.names.init)\n-                    ? ownerName\n-                    : s.name.toString();\n+                String ms = (s.isInitOrVNew()) ? ownerName : s.name.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    valueFactoryName = null;\n@@ -98,0 +99,1 @@\n+  private static String valueFactoryName;\n@@ -105,0 +107,6 @@\n+  private static String valueFactoryName() {\n+    if (valueFactoryName == null) {\n+      valueFactoryName = \"<vnew>\";\n+    }\n+    return classInitializerName;\n+  }\n@@ -248,1 +256,1 @@\n-     return (!isStatic()) && getName().equals(objectInitializerName());\n+     return (!isStatic()) && (getName().equals(objectInitializerName()) || getName().equals(valueFactoryName()));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Method.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-      if (name.equals(\"<init>\")) {\n+      if (name.equals(\"<init>\") || name.equals(\"<vnew>\")) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/ObjectReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-        return getDeclaringClass().isJavaLangObject() && getName().equals(\"<init>\");\n+        return getDeclaringClass().isJavaLangObject() && (getName().equals(\"<init>\") || getName().equals(\"<vnew>\"));\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -532,0 +532,1 @@\n+            case \"<vnew>\":\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+               s.equals(\"<vnew>\") ||\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/BreakpointSpec.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-        return name().equals(\"<init>\");\n+        return name().equals(\"<init>\") || name().equals(\"<vnew>\");\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/MethodImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        return name.equals(\"<init>\");\n+        return name.equals(\"<init>\") || name.equals(\"<vnew>\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/ConstructorTracerWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,24 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n+ * @test \/nodynamiccopyright\/\n@@ -29,2 +6,2 @@\n- * @compile --source 16 ConsumeValueClassAtLowerLevel.java\n- * @run main ConsumeValueClassAtLowerLevel\n+ * @compile ConsumeValueClassAtLowerLevel.java\n+ * @compile\/fail\/ref=ConsumeValueClassAtLowerLevel.out --source 16 -XDrawDiagnostics ConsumeValueClassAtLowerLevel.java\n@@ -34,10 +11,4 @@\n-    public static void main(String [] args) {\n-\n-        \/* Attempting to instantiate a value\/primitive class in earlier source level should\n-         * result in an InstantiationError since javac's class reader downgrades\n-         * the value class to an identity class if current source level does not\n-         * support value\/primitive class. And so rather than invoke the factory method,\n-         * the source code of earlier vintage would attempt to invoke the constructor\n-         * and so should crash and burn with an InstantiationError.\n-         *\n-         * This behavior is subject to change - see JDK-8282525\n+    void m() {\n+        \/* GenericPoint was compiled with a source that allows value classes but ConsumeValueClassAtLowerLevel was not\n+         * so GenericPoint has a <vnew> initializer but in a source that doesn't allow value classes we look for <ini>\n+         * thus the compiler error in the second compilation of ConsumeValueClassAtLowerLevel.java\n@@ -45,9 +16,1 @@\n-        boolean gotIE = false;\n-        try {\n-            GenericPoint<Integer> gl = new GenericPoint<>(0, 0);\n-        } catch (java.lang.InstantiationError ie) {\n-            gotIE = true;\n-        }\n-        if (!gotIE) {\n-            throw new AssertionError(\"Did not see instantiation error!\");\n-        }\n+        GenericPoint<Integer> gl = new GenericPoint<>(0, 0);\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConsumeValueClassAtLowerLevel.java","additions":8,"deletions":45,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+- compiler.warn.source.no.system.modules.path: 16\n+ConsumeValueClassAtLowerLevel.java:16:36: compiler.err.cant.resolve.location.args: kindname.constructor, GenericPoint, , int,int, (compiler.misc.location: kindname.class, GenericPoint<T>, null)\n+1 error\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConsumeValueClassAtLowerLevel.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n-        V foo(X x) {\n+        V bar(X x) {\n@@ -40,1 +40,1 @@\n-            void foo(X x) {\n+            void ooo(X x) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/FlattenableTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-         \"4: invokestatic  #10                 \/\/ Method \\\"<init>\\\":(II)LValueCreationTest$Point;\",\n+         \"4: invokestatic  #10                 \/\/ Method \\\"<vnew>\\\":(II)LValueCreationTest$Point;\",\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueCreationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}