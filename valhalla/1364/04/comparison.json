{"files":[{"patch":"@@ -2549,0 +2549,7 @@\n+    if (bt != alias_type->basic_type()) {\n+      \/\/ Type mismatch. Is it an access to a nested flat field?\n+      field = k->get_field_by_offset(off, false);\n+      if (field != nullptr) {\n+        bt = type2field[field->type()->basic_type()];\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1645,0 +1645,4 @@\n+            @Override\n+            public MethodHandle assertAsType(MethodHandle original, MethodType assertedType) {\n+                return original.viewAsType(assertedType, false);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -54,0 +55,1 @@\n+import jdk.internal.value.LayoutIteration;\n@@ -95,9 +97,1 @@\n-            Stream<MethodHandle> s = Arrays.stream(type.getDeclaredFields())\n-                .filter(f -> !Modifier.isStatic(f.getModifiers()))\n-                .map(f -> {\n-                    try {\n-                        return JLIA.unreflectField(f, false);\n-                    } catch (IllegalAccessException e) {\n-                        throw newLinkageError(e);\n-                    }\n-                });\n+            List<MethodHandle> mhs = LayoutIteration.ELEMENTS.get(type);\n@@ -105,1 +99,2 @@\n-                s = s.sorted(comparator);\n+                mhs = new ArrayList<>(mhs);\n+                mhs.sort(comparator);\n@@ -107,1 +102,1 @@\n-            return s;\n+            return mhs.stream();\n@@ -144,7 +139,5 @@\n-            List<Class<?>> result = new ArrayList<>();\n-            Arrays.stream(type.getDeclaredFields())\n-                  .filter(f -> !Modifier.isStatic(f.getModifiers()))\n-                  .map(f -> f.getType())\n-                  .filter(ft -> ft.isValue() && !result.contains(ft))\n-                  .forEach(result::add);\n-            return result;\n+            return LayoutIteration.ELEMENTS.get(type).stream()\n+                    .<Class<?>>map(mh -> mh.type().returnType())\n+                    .filter(Class::isValue)\n+                    .distinct()\n+                    .toList();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ValueObjectMethods.java","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -179,0 +179,10 @@\n+\n+    \/**\n+     * Asserts a method handle to be another type without the conversion adaptions.\n+     * Useful to avoid many redundant casts.\n+     *\n+     * @param original original MH\n+     * @param assertedType the asserted type the origina MH can execute as\n+     * @return the cheap view without extra adaptions\n+     *\/\n+    MethodHandle assertAsType(MethodHandle original, MethodType assertedType);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.value;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.Unsafe;\n+import sun.invoke.util.Wrapper;\n+\n+\/**\n+ * Iterates the layout elements of a value type.\n+ * <p>\n+ * In the long run, we should do this:\n+ * Iterate the layout, create a mask masking bytes used by Object\/abstract value\n+ * class reference fields.  Do a byte-wise compare and get the mask of value\n+ * mismatch; if the mask's all clear, fine; if the mask has bits beyond our\n+ * mask, fail; otherwise, compare reference fields indicated by the mismatch\n+ * mask. There may be paddings to ignore, too, depends...\n+ *\/\n+public final class LayoutIteration {\n+    \/\/ Initializer in static initializers below, order dependent\n+    public static final ClassValue<List<MethodHandle>> ELEMENTS;\n+\n+    \/**\n+     * {@return a list of method handles accessing the basic elements}\n+     * Basic elements are 8 primitives and pointers (to identity or value objects).\n+     * Primitives and pointers are distinguished by the MH return types.\n+     * The MH types are {@code flatType -> fieldType}.\n+     *\n+     * @param flatType the class that has a flat layout\n+     * @return the accessors\n+     * @throws IllegalArgumentException if argument has no flat layout\n+     *\/\n+    public static List<MethodHandle> computeElementGetters(Class<?> flatType) {\n+        if (!canHaveFlatLayout(flatType))\n+            throw new IllegalArgumentException(flatType + \" cannot be flat\");\n+        var sink = new Sink(flatType);\n+        iterateFields(U.valueHeaderSize(flatType), flatType, sink);\n+        return List.copyOf(sink.getters);\n+    }\n+\n+    \/\/ Ensures the given class has a potential a flat layout\n+    private static boolean canHaveFlatLayout(Class<?> flatType) {\n+        return flatType.isValue() && Modifier.isFinal(flatType.getModifiers());\n+    }\n+\n+    private static final class Sink {\n+        final Class<?> receiverType;\n+        final List<MethodHandle> getters = new ArrayList<>();\n+\n+        Sink(Class<?> receiverType) {\n+            this.receiverType = receiverType;\n+        }\n+\n+        void accept(long offsetNoHeader, Class<?> itemType) {\n+            Wrapper w = itemType.isPrimitive() ? Wrapper.forPrimitiveType(itemType) : Wrapper.OBJECT;\n+            var mh = MethodHandles.insertArguments(FIELD_GETTERS.get(w.ordinal()), 1, offsetNoHeader);\n+            assert mh.type() == MethodType.methodType(w.primitiveType(), Object.class);\n+            mh = JLIA.assertAsType(mh, MethodType.methodType(itemType, receiverType));\n+            getters.add(mh);\n+        }\n+    }\n+\n+    \/\/ Sink is good for one to many mappings\n+    private static void iterateFields(long enclosingOffset, Class<?> currentClass, Sink sink) {\n+        assert canHaveFlatLayout(currentClass) : currentClass + \" cannot be flat\";\n+        long memberOffsetDelta = enclosingOffset - U.valueHeaderSize(currentClass);\n+        for (Field f : currentClass.getDeclaredFields()) {\n+            if (Modifier.isStatic(f.getModifiers()))\n+                continue;\n+            var type = f.getType();\n+            long memberOffset = U.objectFieldOffset(f) + memberOffsetDelta;\n+            if (!U.isFlatField(f)) {\n+                sink.accept(memberOffset, type);\n+            } else {\n+                iterateFields(memberOffset, type, sink);\n+            }\n+        }\n+    }\n+\n+    private static boolean getBoolean(Object o, long offset) {\n+        return U.getBoolean(o, offset);\n+    }\n+    private static byte getByte(Object o, long offset) {\n+        return U.getByte(o, offset);\n+    }\n+    private static short getShort(Object o, long offset) {\n+        return U.getShort(o, offset);\n+    }\n+    private static char getCharacter(Object o, long offset) {\n+        return U.getChar(o, offset);\n+    }\n+    private static int getInteger(Object o, long offset) {\n+        return U.getInt(o, offset);\n+    }\n+    private static long getLong(Object o, long offset) {\n+        return U.getLong(o, offset);\n+    }\n+    private static float getFloat(Object o, long offset) {\n+        return U.getFloat(o, offset);\n+    }\n+    private static double getDouble(Object o, long offset) {\n+        return U.getDouble(o, offset);\n+    }\n+    public static Object getObject(Object o, long offset) {\n+        return U.getReference(o, offset);\n+    }\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+    private static final List<MethodHandle> FIELD_GETTERS;\n+    static {\n+        MethodHandle[] fieldGetters = new MethodHandle[9];\n+        var lookup = MethodHandles.lookup();\n+        var type = MethodType.methodType(void.class, Object.class, long.class);\n+        try {\n+            for (Wrapper w : Wrapper.values()) {\n+                if (w != Wrapper.VOID) {\n+                    fieldGetters[w.ordinal()] = lookup.findStatic(LayoutIteration.class,\n+                            \"get\" + w.wrapperSimpleName(), type.changeReturnType(w.primitiveType()));\n+                }\n+            }\n+        } catch (ReflectiveOperationException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+        FIELD_GETTERS = List.of(fieldGetters);\n+        ELEMENTS = new ClassValue<>() {\n+            @Override\n+            protected List<MethodHandle> computeValue(Class<?> type) {\n+                return computeElementGetters(type);\n+            }\n+        };\n+    }\n+\n+    private LayoutIteration() {}\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/LayoutIteration.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.value.LayoutIteration;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @summary test LayoutIteration\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.value\n+ * @run junit\/othervm LayoutIterationTest\n+ *\/\n+class LayoutIterationTest {\n+\n+    @LooselyConsistentValue\n+    static value class One {\n+        int a;\n+        short b;\n+\n+        One(int a, short b) {\n+            this.a = a;\n+            this.b = b;\n+            super();\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Two {\n+        @NullRestricted\n+        One one = new One(5, (short) 3);\n+        One anotherOne = new One(4, (short) 2);\n+        long l = 5L;\n+    }\n+\n+    @Test\n+    void test() {\n+        Two t = new Two();\n+        Set<Class<?>> classes = LayoutIteration.computeElementGetters(One.class).stream()\n+                .map(mh -> mh.type().returnType()).collect(Collectors.toSet());\n+        assertEquals(Set.of(int.class, short.class), classes);\n+        Map<Class<?>, Object> values = LayoutIteration.computeElementGetters(Two.class).stream()\n+                .collect(Collectors.toMap(mh -> mh.type().returnType(), mh -> {\n+                    try {\n+                        return (Object) mh.invoke(t);\n+                    } catch (Throwable ex) {\n+                        return Assertions.fail(ex);\n+                    }\n+                }));\n+        assertEquals(Map.of(\n+                int.class, t.one.a,\n+                short.class, t.one.b,\n+                One.class, t.anotherOne,\n+                long.class, t.l\n+        ), values);\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/LayoutIterationTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}