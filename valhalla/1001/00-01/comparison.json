{"files":[{"patch":"@@ -124,2 +124,1 @@\n-    valhalla \\\n-    java\/lang\/instrument\/valhalla\n+    valhalla\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,538 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8274800\n- * @library \/test\/lib\n- * @summary [lworld] Primitive classes can't be retransformed\n- * @modules java.instrument\n- * @compile -XDenablePrimitiveClasses RedefinePrimitive.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses RedefinePrimitive master\n- *\/\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.lang.RuntimeException;\n-import java.lang.instrument.ClassFileTransformer;\n-import java.lang.instrument.Instrumentation;\n-import java.security.ProtectionDomain;\n-import java.lang.instrument.IllegalClassFormatException;\n-import java.nio.file.Files;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.regex.Pattern;\n-import java.util.spi.ToolProvider;\n-\n-import jdk.test.lib.JDKToolLauncher;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-import jdk.test.lib.util.ClassTransformer;\n-\n-\n-primitive class MyPrimitive {\n-\n-    long sum() {\n-        \/\/ This adds a number of new entries in the beginning of the CP\n-        \/\/ and this causes CP mapping during class redefinition.\n-        \/\/ @2 uncomment System.out.println(RedefinePrimitive.class);\n-        return x + z;\n-    }\n-    public MyPrimitive(int x, long z) {\n-        this.x = x;\n-        this.y = String.valueOf(x);\n-        this.z = z;\n-        \/\/ @1 uncomment z2 = z+1;\n-    }\n-\n-    public static MyPrimitive create(int x, long z) {\n-        return new MyPrimitive(x,z);\n-    }\n-\n-    int x;\n-    public String y;\n-    public long z;\n-    \/\/ @1 uncomment long z2;\n-\n-    void method1(CountDownLatch ready, Object wait) {\n-        ready.countDown();\n-        try {\n-            synchronized (wait) {\n-                wait.wait();\n-            }\n-        } catch (InterruptedException ex) {\n-            ex.printStackTrace();\n-        }\n-    }\n-}\n-\n-primitive   \/\/ @1 commentout\n-class TestClass2 {\n-    public TestClass2(int x) {\n-        this.x = x;\n-    }\n-    int x;\n-}\n-\n-\/\/ @1 uncomment primitive\n-class TestClass3 {\n-    public TestClass3(int x) {\n-        this.x = x;\n-    }\n-    int x;\n-}\n-\n-class InlineHolder {\n-    MyPrimitive primField;\n-    InlineHolder() {\n-        primField = new MyPrimitive(8, 12);\n-    }\n-}\n-\n-public class RedefinePrimitive {\n-\n-    private static Instrumentation inst;\n-\n-    private static final ToolProvider JAR = ToolProvider.findFirst(\"jar\")\n-        .orElseThrow(() -> new RuntimeException(\"ToolProvider for jar not found\"));\n-\n-    static class MyTransformer implements ClassFileTransformer {\n-        private Test test;\n-        Exception exceptionThrown;\n-\n-        public MyTransformer(Test t) {\n-            test = t;\n-        }\n-\n-        public byte[] transform(ClassLoader loader, String className,\n-                                Class classBeingRedefined, ProtectionDomain protectionDomain,\n-                                byte[] classfileBuffer) throws IllegalClassFormatException {\n-            byte[] result = null;\n-            if (className.equals(test.className)) {\n-                log(\">>transform, class=\" + className);\n-                try {\n-                    result = test.transform(className, classfileBuffer);\n-                } catch (Exception ex) {\n-                    exceptionThrown = ex;\n-                    log(\"Exception thrown by test.transform:\");\n-                    ex.printStackTrace();\n-                }\n-                log(\"<<transform, class=\" + className);\n-            }\n-            return result;\n-        }\n-    }\n-\n-    public static void premain(String agentArgs, Instrumentation inst1) throws Exception {\n-        inst = inst1;\n-    }\n-\n-    private static void buildAgent() {\n-        try {\n-            ClassFileInstaller.main(\"RedefinePrimitive\");\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Could not write agent classfile\", e);\n-        }\n-\n-        try (PrintWriter pw = new PrintWriter(\"MANIFEST.MF\")) {\n-            pw.println(\"Premain-Class: RedefinePrimitive\");\n-            \/\/pw.println(\"Agent-Class: RedefinePrimitive\");\n-            \/\/pw.println(\"Can-Redefine-Classes: true\");\n-            pw.println(\"Can-Retransform-Classes: true\");\n-        } catch (FileNotFoundException e) {\n-            throw new RuntimeException(\"Could not write manifest file for the agent\", e);\n-        }\n-\n-        if (JAR.run(System.out, System.err, \"-cmf\", \"MANIFEST.MF\", \"redefineagent.jar\", \"RedefinePrimitive.class\") != 0) {\n-            throw new RuntimeException(\"Could not write the agent jar file\");\n-        }\n-    }\n-\n-    private static File getClassFile(String className) {\n-        return new File(System.getProperty(\"test.classes\", \".\"), className + \".class\");\n-    }\n-\n-    private static byte[] loadClassBytes(File f) throws IOException {\n-        log(\"Reading test class from \" + f);\n-        return Files.readAllBytes(f.toPath());\n-    }\n-\n-    private static byte[] loadClassBytes(String className) throws IOException {\n-        return loadClassBytes(new File(System.getProperty(\"test.classes\", \".\"), className + \".class\"));\n-    }\n-\n-    private static void compareClassBytes(String className, byte[] expected, byte[] actual) throws Exception {\n-        log(\"comparing class bytes for class \" + className);\n-        if (Arrays.equals(expected, actual)) {\n-            log(\"identical\");\n-        } else {\n-            log(\"class bytes mismatch\");\n-            File redefinedFile = new File(className + \"_redefined.class\");\n-            try (FileOutputStream stream = new FileOutputStream(redefinedFile)) {\n-                stream.write(actual);\n-                log(\".class saved to \" + redefinedFile);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-                throw new RuntimeException(ex);\n-            }\n-\n-            compareClassFiles(getClassFile(className), redefinedFile);\n-        }\n-    }\n-\n-    private static List<String> disassembleClassFile(File file) throws Exception {\n-        JDKToolLauncher javap = JDKToolLauncher.create(\"javap\")\n-                .addToolArg(\"-c\")\n-                .addToolArg(\"-s\")\n-                .addToolArg(\"-verbose\")\n-                .addToolArg(file.toString());\n-        ProcessBuilder pb = new ProcessBuilder(javap.getCommand());\n-        OutputAnalyzer out = ProcessTools.executeProcess(pb);\n-        return out.asLines();\n-    }\n-\n-    private static final String[] expectedDifferentStrings = {\n-            \"^Classfile .+$\",\n-            \"^[\\\\s]+SHA-256 checksum .[^\\\\s]+$\"\n-    };\n-\n-    private static boolean expectedDifferent(String line) {\n-        for (String s: expectedDifferentStrings) {\n-            Pattern p = Pattern.compile(s);\n-            if (p.matcher(line).find()) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private static void compareClassFiles(File original, File redefined) throws Exception {\n-        log(\"Disassembly difference (\" + original + \" vs \" + redefined+\"):\");\n-        \/\/ compare javap output for the class files\n-        List<String> out1 = disassembleClassFile(original);\n-        List<String> out2 = disassembleClassFile(redefined);\n-\n-        boolean different = false;\n-        boolean orderChanged = false;\n-        int lineNum = 0;\n-        for (String line: out1) {\n-            if (!expectedDifferent(line)) {\n-                if (!out2.contains(line)) {\n-                    different = true;\n-                    log(\"< (\" + (lineNum + 1) + \") \" + line);\n-                } else {\n-                    if (lineNum < out2.size() && out1.get(lineNum) != out2.get(lineNum)) {\n-                        \/\/ out2 contains line, but at different position\n-                        orderChanged = true;\n-                    }\n-                }\n-            }\n-            lineNum++;\n-        }\n-        lineNum = 0;\n-        for (String line: out2) {\n-            if (!expectedDifferent(line)) {\n-                if (!out1.contains(line)) {\n-                    different = true;\n-                    log(\"> (\" + (lineNum + 1) + \") \" + line);\n-                }\n-            }\n-            lineNum++;\n-        }\n-        if (different || orderChanged) {\n-            log(\"original:\");\n-            log(\"-------------------\");\n-            for (String line: out1) {\n-                log(line);\n-            }\n-            log(\"===================\");\n-            log(\"-------------------\");\n-            log(\"redefined:\");\n-            for (String line: out2) {\n-                log(line);\n-            }\n-            log(\"===================\");\n-        }\n-        \/\/ accordingly the spec orderChanged is fine\n-        if (different) {\n-            throw new Exception(\"classfile bytes mismatch\");\n-        } else if (orderChanged) {\n-            log(\"classfile bytes are different - only order changed\");\n-        }\n-    }\n-\n-    public static String getPropOpt(String prop) {\n-        String propVal = System.getProperty(prop);\n-        if (propVal == null) propVal = \"\";\n-        System.out.println(prop + \": '\" + propVal  + \"'\");\n-        return \"-D\" + prop + \"=\" + propVal;\n-    }\n-\n-    private static void log(Object msg) {\n-        System.out.println(String.valueOf(msg));\n-        System.out.flush();\n-    }\n-\n-    public static void main(String argv[]) throws Exception {\n-        if (argv.length == 1 && argv[0].equals(\"master\")) {\n-            buildAgent();\n-\n-            for (int i = 0; i < tests.length; i++) {\n-                log(\"Starting \" + tests[i].name + \"...\");\n-                ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                        \"-javaagent:redefineagent.jar\",\n-                        \"-XX:+EnableValhalla\", \"-XX:+EnablePrimitiveClasses\",\n-                        getPropOpt(\"test.jdk\"),\n-                        getPropOpt(\"test.classes\"),\n-                        getPropOpt(\"test.java.opts\"),\n-                        getPropOpt(\"test.vm.opts\"),\n-                        getPropOpt(\"test.src\"),\n-                        \"RedefinePrimitive\", String.valueOf(i));\n-                OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-                output.shouldNotContain(\"processing of -javaagent failed\");\n-                output.shouldHaveExitValue(0);\n-                log(\"test stdout: [\" + output.getStdout() + \"]\");\n-                log(\"test stderr: [\" + output.getStderr() + \"]\");\n-                log(\"\");\n-            }\n-        } else {\n-            int i = Integer.parseInt(argv[0]);\n-            Test t = tests[i];\n-            t.run();\n-        }\n-   }\n-\n-\n-    private static final String SOURCE_FILE = \"RedefinePrimitive.java\";\n-    private static class Test {\n-        String name;\n-        String className;\n-        boolean transformErrorExpected;\n-\n-        public Test(String name, String className) {\n-            this.name = name;\n-            this.className = className;\n-            transformErrorExpected = false;\n-        }\n-\n-        public void prologue() throws Exception {}\n-        public byte[] transform(String className, byte[] classBytes) throws Exception { return null; }\n-        public void epilogue() throws Exception {}\n-\n-        public void run() throws Exception {\n-            log(\">>main (\" + name + \")\");\n-\n-            Class theClass = Class.forName(className);\n-\n-            MyTransformer transformer = new MyTransformer(this);\n-            inst.addTransformer(transformer, true);\n-\n-            prologue();\n-\n-            try {\n-                log(\">>retransformClasses (\" + className + \")\");\n-                inst.retransformClasses(theClass);\n-                log(\"<<retransformClasses (\" + className + \")\");\n-\n-                if (transformErrorExpected) {\n-                    throw new Exception(\"retransformClasses is expected to fail, but no exception thrown\");\n-                }\n-            } catch (Exception ex) {\n-                if (transformErrorExpected) {\n-                    log(\"retransformClasses is expected to fail, got exception:\");\n-                    ex.printStackTrace(System.out);\n-                } else {\n-                    throw ex;\n-                }\n-            }\n-            if (transformer.exceptionThrown != null) {\n-                throw transformer.exceptionThrown;\n-            }\n-\n-            inst.removeTransformer(transformer);\n-\n-            epilogue();\n-\n-            log(\"<<main (\" + name + \")\");\n-        }\n-    }\n-\n-    private static Test[] tests = {\n-            new Test(\"Reconstituter sanity\", \"MyPrimitive\") {\n-                byte[] savedClassBytes;\n-                @Override\n-                public void prologue() {\n-                }\n-\n-                @Override\n-                public byte[] transform(String className, byte[] classBytes) {\n-                    savedClassBytes = classBytes;\n-                    return null;\n-                }\n-\n-                @Override\n-                public void epilogue() throws Exception {\n-                    compareClassBytes(className, loadClassBytes(className), savedClassBytes);\n-                }\n-            },\n-\n-            new Test(\"Class in in use\", \"MyPrimitive\") {\n-                CountDownLatch ready;\n-                Object wait;\n-\n-                @Override\n-                public void prologue() throws Exception {\n-                    MyPrimitive o1 = new MyPrimitive(2, 5);\n-                    CountDownLatch ready = new CountDownLatch(1);\n-                    wait = new Object();\n-\n-                    Thread t = new Thread(\n-                            () -> {\n-                                log(\">>o1.method1\");\n-                                o1.method1(ready, wait);\n-                                log(\"<<o1.method1\");\n-                            });\n-                    t.setDaemon(true);\n-                    t.start();\n-                    ready.await();\n-                }\n-\n-                @Override\n-                public byte[] transform(String className, byte[] classBytes) {\n-                    return null;\n-                }\n-\n-                @Override\n-                public void epilogue() throws Exception {\n-                    synchronized (wait) {\n-                        wait.notifyAll();\n-                    }\n-                }\n-            },\n-\n-            new Test(\"Redefine primitive with instance\", \"TestClass2\") {\n-                byte[] redefineClassBytes;\n-                @Override\n-                public void prologue() throws Exception {\n-                    transformErrorExpected = true;\n-                    String transformedClassFile = ClassTransformer.fromTestSource(SOURCE_FILE)\n-                            .transform(1, className, \"-XDenablePrimitiveClasses\");\n-                    redefineClassBytes = loadClassBytes(new File(transformedClassFile));\n-                }\n-\n-                @Override\n-                public byte[] transform(String className, byte[] classBytes) {\n-                    return redefineClassBytes;\n-                }\n-\n-                @Override\n-                public void epilogue() throws Exception {\n-                }\n-            },\n-\n-            new Test(\"Redefine instance with primitive\", \"TestClass3\") {\n-                byte[] redefineClassBytes;\n-                @Override\n-                public void prologue() throws Exception {\n-                    transformErrorExpected = true;\n-                    String transformedClassFile = ClassTransformer.fromTestSource(SOURCE_FILE)\n-                            .transform(1, className, \"-XDenablePrimitiveClasses\");\n-                    redefineClassBytes = loadClassBytes(new File(transformedClassFile));\n-                }\n-\n-                @Override\n-                public byte[] transform(String className, byte[] classBytes) {\n-                    return redefineClassBytes;\n-                }\n-\n-                @Override\n-                public void epilogue() throws Exception {\n-                }\n-            },\n-\n-            new Test(\"Change object size\", \"MyPrimitive\") {\n-                byte[] redefineClassBytes;\n-                @Override\n-                public void prologue() throws Exception {\n-                    transformErrorExpected = true;\n-                    String transformedClassFile = ClassTransformer.fromTestSource(SOURCE_FILE)\n-                            .transform(1, className, \"-XDenablePrimitiveClasses\");\n-                    redefineClassBytes = loadClassBytes(new File(transformedClassFile));\n-                }\n-\n-                @Override\n-                public byte[] transform(String className, byte[] classBytes) {\n-                    return redefineClassBytes;\n-                }\n-\n-                @Override\n-                public void epilogue() throws Exception {\n-                }\n-            },\n-\n-            new Test(\"Reconstitute class with inlined field\", \"InlineHolder\") {\n-                byte[] savedClassBytes;\n-                @Override\n-                public void prologue() {\n-                }\n-\n-                @Override\n-                public byte[] transform(String className, byte[] classBytes) {\n-                    savedClassBytes = classBytes;\n-                    return null;\n-                }\n-\n-                @Override\n-                public void epilogue() throws Exception {\n-                    compareClassBytes(className, loadClassBytes(className), savedClassBytes);\n-                }\n-            },\n-\n-            new Test(\"CP mapping\", \"MyPrimitive\") {\n-                byte[] redefineClassBytes;\n-\n-                @Override\n-                public void prologue() throws Exception {\n-                    String transformedClassFile = ClassTransformer.fromTestSource(SOURCE_FILE)\n-                            .transform(2, className, \"-XDenablePrimitiveClasses\");\n-                    redefineClassBytes = loadClassBytes(new File(transformedClassFile));\n-                }\n-\n-                @Override\n-                public byte[] transform(String className, byte[] classBytes) {\n-                    \/\/ with wrong mapping retransformClasses() fails with InternalError\n-                    return redefineClassBytes;\n-                }\n-\n-                @Override\n-                public void epilogue() throws Exception {\n-                }\n-            },\n-    };\n-\n-}\n","filename":"test\/jdk\/java\/lang\/instrument\/valhalla\/RedefinePrimitive.java","additions":0,"deletions":538,"binary":false,"changes":538,"status":"deleted"}]}