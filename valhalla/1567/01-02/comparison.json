{"files":[{"patch":"@@ -1393,2 +1393,2 @@\n-            \/\/ make sure the symbol is not static\n-            if (sym.isStatic()) {\n+            \/\/ make sure that there is a symbol and it is not static\n+            if (sym == null || sym.isStatic()) {\n@@ -1405,1 +1405,0 @@\n-\n@@ -1415,30 +1414,16 @@\n-            if (sym != null) {\n-                if (!sym.isStatic() && sym.kind == VAR && sym.owner.kind == TYP) {\n-                    if (sym.name == names._this || sym.name == names._super) {\n-                        \/\/ are we seeing something like `this` or `CurrentClass.this` or `SuperClass.super::foo`?\n-                        if (TreeInfo.isExplicitThisReference(\n-                                types,\n-                                (ClassType)localEnv.enclClass.sym.type,\n-                                tree)) {\n-                            reportPrologueError(tree, sym);\n-                        }\n-                    } else if (sym.kind == VAR && sym.owner.kind == TYP) { \/\/ now fields only\n-                        if (sym.owner != localEnv.enclClass.sym) {\n-                            if (localEnv.enclClass.sym.isSubClass(sym.owner, types) &&\n-                                    sym.isInheritedIn(localEnv.enclClass.sym, types)) {\n-                                \/* if we are dealing with a field that doesn't belong to the current class, but the\n-                                 * field is inherited, this is an error. Unless, the super class is also an outer\n-                                 * class and the field's qualifier refers to the outer class\n-                                 *\/\n-                                if (tree.hasTag(IDENT) ||\n-                                    TreeInfo.isExplicitThisReference(\n-                                            types,\n-                                            (ClassType)localEnv.enclClass.sym.type,\n-                                            ((JCFieldAccess)tree).selected)) {\n-                                    reportPrologueError(tree, sym);\n-                                }\n-                            }\n-                        } else if (isEarlyReference(localEnv, tree, sym)) {\n-                            \/* now this is a `proper` instance field of the current class\n-                             * references to fields of identity classes which happen to have initializers are\n-                             * not allowed in the prologue\n+            if (!sym.isStatic() && sym.kind == VAR && sym.owner.kind == TYP) {\n+                if (sym.name == names._this || sym.name == names._super) {\n+                    \/\/ are we seeing something like `this` or `CurrentClass.this` or `SuperClass.super::foo`?\n+                    if (TreeInfo.isExplicitThisReference(\n+                            types,\n+                            (ClassType)localEnv.enclClass.sym.type,\n+                            tree)) {\n+                        reportPrologueError(tree, sym);\n+                    }\n+                } else if (sym.kind == VAR && sym.owner.kind == TYP) { \/\/ now fields only\n+                    if (sym.owner != localEnv.enclClass.sym) {\n+                        if (localEnv.enclClass.sym.isSubClass(sym.owner, types) &&\n+                                sym.isInheritedIn(localEnv.enclClass.sym, types)) {\n+                            \/* if we are dealing with a field that doesn't belong to the current class, but the\n+                             * field is inherited, this is an error. Unless, the super class is also an outer\n+                             * class and the field's qualifier refers to the outer class\n@@ -1446,2 +1431,21 @@\n-                            if (insideLambdaOrClassDef ||\n-                                (!localEnv.enclClass.sym.isValueClass() && (sym.flags_field & HASINIT) != 0))\n+                            if (tree.hasTag(IDENT) ||\n+                                TreeInfo.isExplicitThisReference(\n+                                        types,\n+                                        (ClassType)localEnv.enclClass.sym.type,\n+                                        ((JCFieldAccess)tree).selected)) {\n+                                reportPrologueError(tree, sym);\n+                            }\n+                        }\n+                    } else if (isEarlyReference(localEnv, tree, sym)) {\n+                        \/* now this is a `proper` instance field of the current class\n+                         * references to fields of identity classes which happen to have initializers are\n+                         * not allowed in the prologue\n+                         *\/\n+                        if (insideLambdaOrClassDef ||\n+                            (!localEnv.enclClass.sym.isValueClass() && (sym.flags_field & HASINIT) != 0))\n+                            reportPrologueError(tree, sym);\n+                        \/\/ we will need to generate a proxy for this field later on\n+                        if (!isInLHS) {\n+                            if (allowValueClasses) {\n+                                localProxyVarsGen.addFieldReadInPrologue(localEnv.enclMethod, sym);\n+                            } else {\n@@ -1449,7 +1453,0 @@\n-                            \/\/ we will need to generate a proxy for this field later on\n-                            if (!isInLHS) {\n-                                if (allowValueClasses) {\n-                                    localProxyVarsGen.addFieldReadInPrologue(localEnv.enclMethod, sym);\n-                                } else {\n-                                    reportPrologueError(tree, sym);\n-                                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":39,"deletions":42,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.util.Iterator;\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitGood.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}