{"files":[{"patch":"@@ -34,1 +34,1 @@\n-StackMapFrame::StackMapFrame(u2 max_locals, u2 max_stack, ClassVerifier* v) :\n+StackMapFrame::StackMapFrame(u2 max_locals, u2 max_stack, AssertUnsetFieldTable* initial_strict_fields, ClassVerifier* v) :\n@@ -37,1 +37,1 @@\n-                      _max_stack(max_stack), _flags(0), _verifier(v) {\n+                      _max_stack(max_stack), _flags(0), _assert_unset_fields(initial_strict_fields), _verifier(v) {\n@@ -50,0 +50,11 @@\n+void StackMapFrame::print_strict_fields(AssertUnsetFieldTable* table) {\n+  ResourceMark rm;\n+  auto printfields = [&] (const NameAndSig& key, const NameAndSig& value) {\n+    log_info(verification)(\"Strict field: %s%s (Satisfied: %s)\",\n+                           value._name->as_C_string(),\n+                           value._signature->as_C_string(),\n+                           value._satisfied ? \"true\" : \"false\");\n+  };\n+  table->iterate_all(printfields);\n+}\n+\n@@ -53,1 +64,3 @@\n-  StackMapFrame* frame = new StackMapFrame(_offset, flags, _locals_size, 0, _max_locals, _max_stack, _locals, stack, _verifier);\n+  StackMapFrame* frame = new StackMapFrame(_offset, flags, _locals_size, 0,\n+                                           _max_locals, _max_stack, _locals, stack,\n+                                           _assert_unset_fields, _verifier);\n@@ -191,0 +204,8 @@\n+  \/\/ Check that assert unset fields are compatible\n+  bool compatible = is_unset_fields_compatible(target->assert_unset_fields());\n+  if (!compatible) {\n+    *ctx = ErrorContext::strict_fields_mismatch(target->offset(),\n+        (StackMapFrame*)this, (StackMapFrame*)target);\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.cpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,14 @@\n+ public:\n+  static unsigned int nameandsig_hash(NameAndSig const& field) {\n+    Symbol* name = field._name;\n+    return (unsigned int) name->identity_hash();\n+  }\n+\n+  static inline bool nameandsig_equals(NameAndSig const& f1, NameAndSig const& f2) {\n+    return f1._name == f2._name &&\n+           f1._signature == f2._signature;\n+  }\n+\n+  typedef ResourceHashtable<NameAndSig, NameAndSig, 17,\n+                    AnyObj::RESOURCE_AREA, mtInternal,\n+                    nameandsig_hash, nameandsig_equals> AssertUnsetFieldTable;\n@@ -63,0 +77,2 @@\n+  AssertUnsetFieldTable* _assert_unset_fields; \/\/ List of unsatisfied strict fields in the basic block\n+\n@@ -88,0 +104,1 @@\n+    _assert_unset_fields = cp._assert_unset_fields;\n@@ -97,1 +114,1 @@\n-  StackMapFrame(u2 max_locals, u2 max_stack, ClassVerifier* verifier);\n+  StackMapFrame(u2 max_locals, u2 max_stack, AssertUnsetFieldTable* initial_strict_fields, ClassVerifier* verifier);\n@@ -109,0 +126,1 @@\n+                AssertUnsetFieldTable* assert_unset_fields,\n@@ -116,0 +134,1 @@\n+                                    _assert_unset_fields(assert_unset_fields),\n@@ -139,0 +158,58 @@\n+  AssertUnsetFieldTable* assert_unset_fields() const {\n+    return _assert_unset_fields;\n+  }\n+\n+  void set_assert_unset_fields(AssertUnsetFieldTable* table) {\n+    _assert_unset_fields = table;\n+  }\n+\n+  bool satisfy_unset_field(Symbol* name, Symbol* signature) {\n+    NameAndSig dummy_field(name, signature);\n+\n+    if (_assert_unset_fields->contains(dummy_field)) {\n+      NameAndSig* field = _assert_unset_fields->get(dummy_field);\n+      field->_satisfied = true;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  bool is_unset_fields_satisfied() {\n+    bool all_satisfied = true;\n+    auto check_satisfied = [&] (const NameAndSig& key, const NameAndSig& value) {\n+      all_satisfied &= value._satisfied;\n+    };\n+    _assert_unset_fields->iterate_all(check_satisfied);\n+    return all_satisfied;\n+  }\n+\n+  \/\/ Merge incoming unset strict fields from StackMapTable with\n+  \/\/ initial strict instance fields\n+  AssertUnsetFieldTable* merge_unset_fields(AssertUnsetFieldTable* new_fields) {\n+    auto merge_satisfied = [&] (const NameAndSig& key, const NameAndSig& value) {\n+      if (!new_fields->contains(key)) {\n+        NameAndSig dummy = value;\n+        dummy._satisfied = true;\n+        new_fields->put(key, dummy);\n+      }\n+    };\n+    _assert_unset_fields->iterate_all(merge_satisfied);\n+    return new_fields;\n+  }\n+\n+  bool is_unset_fields_compatible(AssertUnsetFieldTable* target_table) const {\n+    bool compatible = true;\n+    auto is_unset = [&] (const NameAndSig& key, const NameAndSig& value) {\n+      \/\/ Successor must have same debts as current frame\n+      if (!value._satisfied) {\n+        if (target_table->get(key)->_satisfied == true) {\n+          compatible = false;\n+        }\n+      }\n+    };\n+    _assert_unset_fields->iterate_all(is_unset);\n+    return compatible;\n+  }\n+\n+  static void print_strict_fields(AssertUnsetFieldTable* table);\n+\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.hpp","additions":79,"deletions":2,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+    frame->set_assert_unset_fields(stackmap_frame->assert_unset_fields());\n@@ -160,1 +161,2 @@\n-                               u2 max_locals, u2 max_stack, TRAPS) :\n+                               u2 max_locals, u2 max_stack,\n+                               StackMapFrame::AssertUnsetFieldTable* initial_strict_fields, TRAPS) :\n@@ -164,1 +166,2 @@\n-                                  _max_stack(max_stack), _first(true) {\n+                                  _max_stack(max_stack), _assert_unset_fields_buffer(initial_strict_fields),\n+                                  _first(true) {\n@@ -245,0 +248,32 @@\n+  if (frame_type == ASSERT_UNSET_FIELDS) {\n+    u2 num_unset_fields = _stream->get_u2(CHECK_NULL);\n+    StackMapFrame::AssertUnsetFieldTable* new_fields = new StackMapFrame::AssertUnsetFieldTable();\n+\n+    for (u2 i = 0; i < num_unset_fields; i++) {\n+      u2 index = _stream->get_u2(CHECK_NULL);\n+      Symbol* name = _cp->symbol_at(_cp->name_ref_index_at(index));\n+      Symbol* sig = _cp->symbol_at(_cp->signature_ref_index_at(index));\n+      NameAndSig tmp(name, sig);\n+\n+      if (!_prev_frame->assert_unset_fields()->contains(tmp)) {\n+        log_info(verification)(\"Field %s%s is not found among initial strict instance fields\", name->as_C_string(), sig->as_C_string());\n+        StackMapFrame::print_strict_fields(_prev_frame->assert_unset_fields());\n+        _prev_frame->verifier()->verify_error(\n+            ErrorContext::bad_strict_fields(_prev_frame->offset(), _prev_frame),\n+            \"Strict fields not a subset of initial strict instance fields\");\n+      } else {\n+        new_fields->put(tmp, tmp);\n+      }\n+    }\n+\n+    \/\/ Only modify strict instance fields the frame has uninitialized this\n+    if (_prev_frame->flag_this_uninit()) {\n+      _assert_unset_fields_buffer = _prev_frame->merge_unset_fields(new_fields);\n+    } else if (new_fields->number_of_entries() > 0) {\n+      _prev_frame->verifier()->verify_error(\n+        ErrorContext::bad_strict_fields(_prev_frame->offset(), _prev_frame),\n+        \"Cannot have uninitialized strict fields after class initialization\");\n+    }\n+\n+    return nullptr;\n+  }\n@@ -260,1 +295,2 @@\n-      _max_locals, _max_stack, locals, nullptr, _verifier);\n+      _max_locals, _max_stack, locals, nullptr,\n+      _assert_unset_fields_buffer, _verifier);\n@@ -292,1 +328,2 @@\n-      _max_locals, _max_stack, locals, stack, _verifier);\n+      _max_locals, _max_stack, locals, stack,\n+      _assert_unset_fields_buffer, _verifier);\n@@ -302,1 +339,1 @@\n-  if (frame_type < SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n+  if (frame_type < ASSERT_UNSET_FIELDS) {\n@@ -333,1 +370,2 @@\n-      _max_locals, _max_stack, locals, stack, _verifier);\n+      _max_locals, _max_stack, locals, stack,\n+      _assert_unset_fields_buffer, _verifier);\n@@ -375,1 +413,2 @@\n-      locals, nullptr, _verifier);\n+      locals, nullptr,\n+      _assert_unset_fields_buffer, _verifier);\n@@ -409,1 +448,2 @@\n-      _max_stack, locals, nullptr, _verifier);\n+      _max_stack, locals, nullptr,\n+      _assert_unset_fields_buffer, _verifier);\n@@ -457,1 +497,2 @@\n-      _max_locals, _max_stack, locals, stack, _verifier);\n+      _max_locals, _max_stack, locals, stack,\n+      _assert_unset_fields_buffer, _verifier);\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":50,"deletions":9,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,3 @@\n+  \/\/ Contains assert_unset_fields generated from classfile\n+  StackMapFrame::AssertUnsetFieldTable* _assert_unset_fields_buffer;\n+\n@@ -151,0 +154,1 @@\n+    ASSERT_UNSET_FIELDS = 246,\n@@ -161,1 +165,2 @@\n-                 u2 max_locals, u2 max_stack, TRAPS);\n+                 u2 max_locals, u2 max_stack,\n+                 StackMapFrame::AssertUnsetFieldTable* initial_strict_fields, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -52,1 +53,1 @@\n-#include \"runtime\/fieldDescriptor.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -724,0 +725,20 @@\n+  \/\/ Collect the initial strict instance fields\n+  StackMapFrame::AssertUnsetFieldTable* strict_fields = new StackMapFrame::AssertUnsetFieldTable();\n+  if (m->is_object_constructor()) {\n+    for (AllFieldStream fs(m->method_holder()); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_strict() && !fs.access_flags().is_static()) {\n+        NameAndSig new_field(fs.name(), fs.signature());\n+        strict_fields->put(new_field, new_field);\n+      }\n+    }\n+\n+    \/\/ Ignore processing of strict fields\n+    if (VerifyNoDebts) {\n+      auto satisfy_all = [&] (const NameAndSig& key, const NameAndSig& value) {\n+        NameAndSig* field = strict_fields->get(key);\n+        field->_satisfied = true;\n+      };\n+      strict_fields->iterate_all(satisfy_all);\n+    }\n+  }\n+\n@@ -725,1 +746,1 @@\n-  StackMapFrame current_frame(max_locals, max_stack, this);\n+  StackMapFrame current_frame(max_locals, max_stack, strict_fields, this);\n@@ -752,1 +773,1 @@\n-  StackMapReader reader(this, &stream, code_data, code_length, &current_frame, max_locals, max_stack, THREAD);\n+  StackMapReader reader(this, &stream, code_data, code_length, &current_frame, max_locals, max_stack, strict_fields, THREAD);\n@@ -2396,0 +2417,10 @@\n+\n+          if (fd.access_flags().is_strict()) {\n+            ResourceMark rm(THREAD);\n+            if (!current_frame->satisfy_unset_field(fd.name(), fd.signature())) {\n+              log_info(verification)(\"Attempting to initialize field not found in initial strict instance fields: %s%s\",\n+                                     fd.name()->as_C_string(), fd.signature()->as_C_string());\n+              verify_error(ErrorContext::bad_strict_fields(bci, current_frame),\n+                           \"Initializing unknown strict field\");\n+            }\n+          }\n@@ -2685,0 +2716,7 @@\n+    } else if (ref_class_type.name() == superk->name()) {\n+      \/\/ Strict final fields must be satisfied by this point\n+      if (!current_frame->is_unset_fields_satisfied()) {\n+        log_info(verification)(\"Strict instance fields not initialized\");\n+        StackMapFrame::print_strict_fields(current_frame->assert_unset_fields());\n+        verify_error(ErrorContext::bad_code(bci), \"All strict final fields must be initialized before super()\");\n+      }\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,8 @@\n+struct NameAndSig {\n+  Symbol* _name;\n+  Symbol* _signature;\n+  bool _satisfied;\n+\n+  NameAndSig(Symbol* n, Symbol* s) : _name(n), _signature(s), _satisfied(false) {}\n+};\n+\n@@ -153,0 +161,1 @@\n+    BAD_STRICT_FIELDS,    \/\/ Strict instance fields must be initialized before super constructor\n@@ -155,0 +164,1 @@\n+    STRICT_FIELDS_MISMATCH, \/\/ Frames have incompatible uninitialized strict instance fields\n@@ -201,0 +211,3 @@\n+  static ErrorContext bad_strict_fields(int bci, StackMapFrame* cur) {\n+    return ErrorContext(bci, BAD_STRICT_FIELDS, TypeOrigin::frame(cur));\n+  }\n@@ -211,0 +224,5 @@\n+  static ErrorContext strict_fields_mismatch(\n+      int bci, StackMapFrame* frame0, StackMapFrame* frame1) {\n+        return ErrorContext(bci, STRICT_FIELDS_MISMATCH,\n+          TypeOrigin::frame(frame0), TypeOrigin::frame(frame1));\n+  }\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1789,0 +1789,3 @@\n+  product(bool, VerifyNoDebts, false, DIAGNOSTIC,                           \\\n+          \"Ignore assert_unset_fields\")                                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n@@ -80,0 +81,7 @@\n+    \/**\n+     * {@return the expanded unset fields}\n+     *\n+     * @see <a href=\"https:\/\/cr.openjdk.org\/~dlsmith\/jep401\/jep401-20241108\/specs\/value-objects-jvms.html\">Specs<\/a>\n+     *\/\n+    List<NameAndTypeEntry> unsetFields();\n+\n@@ -90,1 +98,17 @@\n-        return new StackMapDecoder.StackMapFrameImpl(255, target, locals, stack);\n+\n+        return of(target, locals, stack, List.of());\n+    }\n+\n+    \/**\n+     * {@return a new stack map frame}\n+     * @param target the location of the frame\n+     * @param locals the complete list of frame locals\n+     * @param stack the complete frame stack\n+     * @param unsetFields the complete list of unset fields\n+     *\/\n+    public static StackMapFrameInfo of(Label target,\n+                                       List<VerificationTypeInfo> locals,\n+                                       List<VerificationTypeInfo> stack,\n+                                       List<NameAndTypeEntry> unsetFields) {\n+\n+        return new StackMapDecoder.StackMapFrameImpl(255, target, locals, stack, unsetFields);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -283,1 +283,1 @@\n-            int offsetDelta;\n+            int offsetDelta = -1;\n@@ -292,1 +292,1 @@\n-            else\n+            else {\n@@ -294,0 +294,6 @@\n+                    case 246 -> {\n+                        int numberOfUnsetFields = classReader.readU2(p + 1);\n+                        p += 3;\n+                        p += 2 * numberOfUnsetFields;\n+                        continue; \/\/ do not move bci\/create label\n+                    }\n@@ -326,0 +332,1 @@\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.classfile.constantpool.PoolEntry;\n@@ -41,0 +43,1 @@\n+import java.util.ArrayList;\n@@ -46,0 +49,2 @@\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -53,0 +58,1 @@\n+                    ASSERT_UNSET_FIELDS = 246,\n@@ -55,0 +61,1 @@\n+    private static final int RESERVED_TAGS_UPPER_LIMIT = ASSERT_UNSET_FIELDS; \/\/ not inclusive\n@@ -184,0 +191,12 @@\n+    \/\/ Copied from BoundAttribute\n+    <E extends PoolEntry> List<E> readEntryList(int p, Class<E> type) {\n+        int cnt = classReader.readU2(p);\n+        p += 2;\n+        var entries = new Object[cnt];\n+        int end = p + (cnt * 2);\n+        for (int i = 0; p < end; i++, p += 2) {\n+            entries[i] = classReader.readEntry(p, type);\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(entries);\n+    }\n+\n@@ -187,0 +206,1 @@\n+        List<NameAndTypeEntry> unsetFields = List.of();\n@@ -188,2 +208,6 @@\n-        var entries = new StackMapFrameInfo[u2()];\n-        for (int ei = 0; ei < entries.length; ei++) {\n+        int len = u2();\n+        var entries = new ArrayList<StackMapFrameInfo>(len);\n+        List<List<NameAndTypeEntry>> deferredUnsetFields = new ArrayList<>();\n+        for (int ei = 0; ei < len; ei++) {\n+            var oldLocals = locals;\n+            var oldStack = stack;\n@@ -198,1 +222,1 @@\n-                if (frameType < SAME_LOCALS_1_STACK_ITEM_EXTENDED)\n+                if (frameType < RESERVED_TAGS_UPPER_LIMIT)\n@@ -200,0 +224,6 @@\n+                if (frameType == ASSERT_UNSET_FIELDS) {\n+                    unsetFields = readEntryList(p, NameAndTypeEntry.class);\n+                    p += 2 + unsetFields.size() * 2;\n+                    deferredUnsetFields.add(unsetFields);\n+                    continue; \/\/ defer entry until we can get the bci\n+                }\n@@ -226,2 +256,12 @@\n-            entries[ei] = new StackMapFrameImpl(frameType,\n-                        ctx.getLabel(bci),\n+            Label label = ctx.getLabel(bci);\n+            if (!deferredUnsetFields.isEmpty()) {\n+                \/\/ technically we only have one assert at once, just in case\n+                \/\/ of duplicate asserts...\n+                for (var deferredList : deferredUnsetFields) {\n+                    entries.add(new StackMapFrameImpl(ASSERT_UNSET_FIELDS,\n+                                label, oldLocals, oldStack, deferredList));\n+                }\n+                deferredUnsetFields.clear();\n+            }\n+            entries.add(new StackMapFrameImpl(frameType,\n+                        label,\n@@ -229,1 +269,1 @@\n-                        stack);\n+                        stack));\n@@ -231,1 +271,1 @@\n-        return List.of(entries);\n+        return List.copyOf(entries);\n@@ -302,1 +342,2 @@\n-                                           List<VerificationTypeInfo> stack)\n+                                           List<VerificationTypeInfo> stack,\n+                                           List<NameAndTypeEntry> unsetFields)\n@@ -308,0 +349,8 @@\n+            unsetFields = List.copyOf(unsetFields);\n+        }\n+\n+        public StackMapFrameImpl(int frameType,\n+                                 Label target,\n+                                 List<VerificationTypeInfo> locals,\n+                                 List<VerificationTypeInfo> stack) {\n+            this(frameType, target, locals, stack, List.of());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":58,"deletions":9,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,0 +162,1 @@\n+                        ASSERT_UNSET_FIELDS = 246,\n@@ -165,0 +166,1 @@\n+        private static final int RESERVED_TAGS_UPPER_LIMIT = ASSERT_UNSET_FIELDS; \/\/ not inclusive\n@@ -281,1 +283,1 @@\n-            if (frame_type < SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n+            if (frame_type < RESERVED_TAGS_UPPER_LIMIT) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationTable.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.LinkedHashSet;\n@@ -219,0 +220,1 @@\n+    private final UnsetFieldsInfo unsetFieldsInfo;\n@@ -344,1 +346,1 @@\n-        Source source = Source.instance(context);\n+        unsetFieldsInfo = UnsetFieldsInfo.instance(context);\n@@ -2293,0 +2295,4 @@\n+            letInit(tree, (JCAssign) null);\n+        }\n+\n+        void letInit(JCTree tree, JCAssign assign) {\n@@ -2298,0 +2304,6 @@\n+                    if (isConstructor && sym.isStrict()) {\n+                        \/* we are initializing a strict field inside of a constructor, we now need to find which fields\n+                         * haven't been initialized yet\n+                         *\/\n+                        unsetFieldsInfo.addUnsetFieldsInfo(classDef.sym, assign != null ? assign : tree, findUninitStrictFields());\n+                    }\n@@ -2529,0 +2541,7 @@\n+                    if (isConstructor) {\n+                        Set<VarSymbol> unsetFields = findUninitStrictFields();\n+                        if (unsetFields != null && !unsetFields.isEmpty()) {\n+                            unsetFieldsInfo.addUnsetFieldsInfo(classDef.sym, tree.body, unsetFields);\n+                        }\n+                    }\n+\n@@ -2584,0 +2603,11 @@\n+        Set<VarSymbol> findUninitStrictFields() {\n+            Set<VarSymbol> unsetFields = new LinkedHashSet<>();\n+            for (int i = uninits.nextBit(0); i >= 0; i = uninits.nextBit(i + 1)) {\n+                JCVariableDecl variableDecl = vardecls[i];\n+                if (variableDecl.sym.isStrict()) {\n+                    unsetFields.add(variableDecl.sym);\n+                }\n+            }\n+            return unsetFields;\n+        }\n+\n@@ -3148,1 +3178,1 @@\n-            letInit(tree.lhs);\n+            letInit(tree.lhs, tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+\n+import com.sun.tools.javac.util.List;\n+\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.util.Context;\n+\n+\/**\n+ * A Context class, that can keep useful information about unset fields.\n+ * This information will be produced during flow analysis and used during\n+ * code generation.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public class UnsetFieldsInfo {\n+    protected static final Context.Key<UnsetFieldsInfo> unsetFieldsInfoKey = new Context.Key<>();\n+\n+    public static UnsetFieldsInfo instance(Context context) {\n+        UnsetFieldsInfo instance = context.get(unsetFieldsInfoKey);\n+        if (instance == null)\n+            instance = new UnsetFieldsInfo(context);\n+        return instance;\n+    }\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected UnsetFieldsInfo(Context context) {\n+        context.put(unsetFieldsInfoKey, this);\n+    }\n+\n+    private WeakHashMap<ClassSymbol, Map<JCTree, Set<VarSymbol>>> unsetFieldsMap = new WeakHashMap<>();\n+\n+    public void addUnsetFieldsInfo(ClassSymbol csym, JCTree tree, Set<VarSymbol> unsetFields) {\n+        Map<JCTree, Set<VarSymbol>> treeToFieldsMap = unsetFieldsMap.get(csym);\n+        if (treeToFieldsMap == null) {\n+            treeToFieldsMap = new HashMap<>();\n+            treeToFieldsMap.put(tree, unsetFields);\n+            unsetFieldsMap.put(csym, treeToFieldsMap);\n+        } else {\n+            if (!treeToFieldsMap.containsKey(tree)) {\n+                \/\/ only add if there is no info for the given tree\n+                treeToFieldsMap.put(tree, unsetFields);\n+            }\n+        }\n+    }\n+\n+    public Set<VarSymbol> getUnsetFields(ClassSymbol csym, JCTree tree) {\n+        Map<JCTree, Set<VarSymbol>> treeToFieldsMap = unsetFieldsMap.get(csym);\n+        if (treeToFieldsMap != null) {\n+            Set<VarSymbol> result = treeToFieldsMap.get(tree);\n+            if (result != null) {\n+                return result;\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/UnsetFieldsInfo.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,0 +149,1 @@\n+    static final int ASSERT_UNSET_FIELDS = 246;\n@@ -1266,1 +1267,1 @@\n-                StackMapTableFrame frame = code.stackMapTableBuffer[i];\n+                StackMapTableEntry frame = code.stackMapTableBuffer[i];\n@@ -1332,2 +1333,7 @@\n-    abstract static class StackMapTableFrame {\n-        abstract int getFrameType();\n+    abstract static class StackMapTableEntry {\n+        abstract int getEntryType();\n+        int pc;\n+\n+        StackMapTableEntry(int pc) {\n+            this.pc = pc;\n+        }\n@@ -1336,3 +1342,3 @@\n-            int frameType = getFrameType();\n-            writer.databuf.appendByte(frameType);\n-            if (writer.debugstackmap) System.out.print(\" frame_type=\" + frameType);\n+            int entryType = getEntryType();\n+            writer.databuf.appendByte(entryType);\n+            if (writer.debugstackmap) System.out.println(\" frame_type=\" + entryType + \" bytecode offset \" + pc);\n@@ -1341,1 +1347,1 @@\n-        static class SameFrame extends StackMapTableFrame {\n+        static class SameFrame extends StackMapTableEntry {\n@@ -1343,1 +1349,2 @@\n-            SameFrame(int offsetDelta) {\n+            SameFrame(int pc, int offsetDelta) {\n+                super(pc);\n@@ -1346,1 +1353,1 @@\n-            int getFrameType() {\n+            int getEntryType() {\n@@ -1352,1 +1359,1 @@\n-                if (getFrameType() == SAME_FRAME_EXTENDED) {\n+                if (getEntryType() == SAME_FRAME_EXTENDED) {\n@@ -1361,1 +1368,1 @@\n-        static class SameLocals1StackItemFrame extends StackMapTableFrame {\n+        static class SameLocals1StackItemFrame extends StackMapTableEntry {\n@@ -1364,1 +1371,2 @@\n-            SameLocals1StackItemFrame(int offsetDelta, Type stack) {\n+            SameLocals1StackItemFrame(int pc, int offsetDelta, Type stack) {\n+                super(pc);\n@@ -1368,1 +1376,1 @@\n-            int getFrameType() {\n+            int getEntryType() {\n@@ -1376,1 +1384,1 @@\n-                if (getFrameType() == SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n+                if (getEntryType() == SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n@@ -1389,1 +1397,1 @@\n-        static class ChopFrame extends StackMapTableFrame {\n+        static class ChopFrame extends StackMapTableEntry {\n@@ -1392,1 +1400,2 @@\n-            ChopFrame(int frameType, int offsetDelta) {\n+            ChopFrame(int pc, int frameType, int offsetDelta) {\n+                super(pc);\n@@ -1396,1 +1405,1 @@\n-            int getFrameType() { return frameType; }\n+            int getEntryType() { return frameType; }\n@@ -1407,1 +1416,1 @@\n-        static class AppendFrame extends StackMapTableFrame {\n+        static class AppendFrame extends StackMapTableEntry {\n@@ -1411,1 +1420,2 @@\n-            AppendFrame(int frameType, int offsetDelta, Type[] locals) {\n+            AppendFrame(int pc, int frameType, int offsetDelta, Type[] locals) {\n+                super(pc);\n@@ -1416,1 +1426,1 @@\n-            int getFrameType() { return frameType; }\n+            int getEntryType() { return frameType; }\n@@ -1431,1 +1441,1 @@\n-        static class FullFrame extends StackMapTableFrame {\n+        static class FullFrame extends StackMapTableEntry {\n@@ -1435,1 +1445,2 @@\n-            FullFrame(int offsetDelta, Type[] locals, Type[] stack) {\n+            FullFrame(int pc, int offsetDelta, Type[] locals, Type[] stack) {\n+                super(pc);\n@@ -1440,1 +1451,1 @@\n-            int getFrameType() { return FULL_FRAME; }\n+            int getEntryType() { return FULL_FRAME; }\n@@ -1464,0 +1475,27 @@\n+        static class AssertUnsetFields extends StackMapTableEntry {\n+            Set<VarSymbol> unsetFields;\n+\n+            AssertUnsetFields(int pc, Set<VarSymbol> unsetFields) {\n+                super(pc);\n+                this.unsetFields = unsetFields;\n+            }\n+\n+            int getEntryType() { return ASSERT_UNSET_FIELDS; }\n+\n+            @Override\n+            void write(ClassWriter writer) {\n+                super.write(writer);\n+                writer.databuf.appendChar(unsetFields.size());\n+                if (writer.debugstackmap) {\n+                    System.out.println(\"    # writing: AssertUnsetFields stackmap entry with \" + unsetFields.size() + \" fields\");\n+                }\n+                for (VarSymbol vsym : unsetFields) {\n+                    int index = writer.poolWriter.putNameAndType(vsym);\n+                    writer.databuf.appendChar(index);\n+                    if (writer.debugstackmap) {\n+                        System.out.println(\"    #writing unset field: \" + index + \", with name: \" + vsym.name.toString());\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -1466,4 +1504,4 @@\n-        static StackMapTableFrame getInstance(Code.StackMapFrame this_frame,\n-                                              int prev_pc,\n-                                              Type[] prev_locals,\n-                                              Types types) {\n+        static StackMapTableEntry getInstance(Code.StackMapFrame this_frame,\n+                                              Code.StackMapFrame prevFrame,\n+                                              Types types,\n+                                              int pc) {\n@@ -1472,1 +1510,1 @@\n-            int offset_delta = this_frame.pc - prev_pc - 1;\n+            int offset_delta = this_frame.pc - prevFrame.pc - 1;\n@@ -1474,3 +1512,3 @@\n-                if (locals.length == prev_locals.length\n-                    && compare(prev_locals, locals, types) == 0) {\n-                    return new SameLocals1StackItemFrame(offset_delta, stack[0]);\n+                if (locals.length == prevFrame.locals.length\n+                    && compare(prevFrame.locals, locals, types) == 0) {\n+                    return new SameLocals1StackItemFrame(pc, offset_delta, stack[0]);\n@@ -1479,1 +1517,1 @@\n-                int diff_length = compare(prev_locals, locals, types);\n+                int diff_length = compare(prevFrame.locals, locals, types);\n@@ -1481,1 +1519,1 @@\n-                    return new SameFrame(offset_delta);\n+                    return new SameFrame(pc, offset_delta);\n@@ -1485,1 +1523,1 @@\n-                    for (int i=prev_locals.length, j=0; i<locals.length; i++,j++) {\n+                    for (int i=prevFrame.locals.length, j=0; i<locals.length; i++,j++) {\n@@ -1488,1 +1526,1 @@\n-                    return new AppendFrame(SAME_FRAME_EXTENDED - diff_length,\n+                    return new AppendFrame(pc, SAME_FRAME_EXTENDED - diff_length,\n@@ -1493,1 +1531,1 @@\n-                    return new ChopFrame(SAME_FRAME_EXTENDED - diff_length,\n+                    return new ChopFrame(pc, SAME_FRAME_EXTENDED - diff_length,\n@@ -1498,1 +1536,1 @@\n-            return new FullFrame(offset_delta, locals, stack);\n+            return new FullFrame(pc, offset_delta, locals, stack);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":76,"deletions":38,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.function.ToIntFunction;\n@@ -42,11 +41,0 @@\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Class;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Double;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Fieldref;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Float;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Integer;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_InterfaceMethodref;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Long;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodHandle;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodType;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Methodref;\n-import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_String;\n@@ -54,1 +42,1 @@\n-import static com.sun.tools.javac.jvm.ClassWriter.StackMapTableFrame;\n+import static com.sun.tools.javac.jvm.ClassWriter.StackMapTableEntry;\n@@ -56,0 +44,3 @@\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Set;\n@@ -200,0 +191,6 @@\n+    private Map<Integer, Set<VarSymbol>> cpToUnsetFieldsMap = new HashMap<>();\n+\n+    public Set<VarSymbol> currentUnsetFields;\n+\n+    boolean generateAssertUnsetFieldsFrame;\n+\n@@ -212,1 +209,2 @@\n-                PoolWriter poolWriter) {\n+                PoolWriter poolWriter,\n+                boolean generateAssertUnsetFieldsFrame) {\n@@ -234,0 +232,1 @@\n+        this.generateAssertUnsetFieldsFrame = generateAssertUnsetFieldsFrame;\n@@ -1084,1 +1083,0 @@\n-\n@@ -1231,0 +1229,1 @@\n+        Set<VarSymbol> unsetFields;\n@@ -1237,1 +1236,1 @@\n-    StackMapTableFrame[] stackMapTableBuffer = null;\n+    StackMapTableEntry[] stackMapTableBuffer = null;\n@@ -1358,0 +1357,3 @@\n+        Set<VarSymbol> unsetFieldsAtPC = cpToUnsetFieldsMap.get(pc);\n+        boolean generateAssertUnsetFieldsEntry = unsetFieldsAtPC != null && generateAssertUnsetFieldsFrame;\n+\n@@ -1359,1 +1361,1 @@\n-            stackMapTableBuffer = new StackMapTableFrame[20];\n+            stackMapTableBuffer = new StackMapTableEntry[20];\n@@ -1363,1 +1365,8 @@\n-                                    stackMapBufferSize);\n+                                    stackMapBufferSize + (generateAssertUnsetFieldsEntry ? 1 : 0));\n+        }\n+\n+        if (generateAssertUnsetFieldsEntry) {\n+            if (lastFrame.unsetFields == null || !lastFrame.unsetFields.equals(unsetFieldsAtPC)) {\n+                stackMapTableBuffer[stackMapBufferSize++] = new StackMapTableEntry.AssertUnsetFields(pc, unsetFieldsAtPC);\n+                frame.unsetFields = unsetFieldsAtPC;\n+            }\n@@ -1366,1 +1375,1 @@\n-                StackMapTableFrame.getInstance(frame, lastFrame.pc, lastFrame.locals, types);\n+                StackMapTableEntry.getInstance(frame, lastFrame, types, pc);\n@@ -1372,0 +1381,4 @@\n+    public void addUnsetFieldsAtPC(int pc, Set<VarSymbol> unsetFields) {\n+        cpToUnsetFieldsMap.put(pc, unsetFields);\n+    }\n+\n@@ -1471,0 +1484,3 @@\n+            if (currentUnsetFields != null) {\n+                addUnsetFieldsAtPC(result.pc, currentUnsetFields);\n+            }\n@@ -1482,0 +1498,1 @@\n+        int originalTarget = target;\n@@ -1508,1 +1525,1 @@\n-                if (fatcode)\n+                if (fatcode) {\n@@ -1510,0 +1527,4 @@\n+                    if (cpToUnsetFieldsMap.get(chain.pc) != null) {\n+                        addUnsetFieldsAtPC(originalTarget, cpToUnsetFieldsMap.get(chain.pc));\n+                    }\n+                }\n@@ -1513,1 +1534,1 @@\n-                else\n+                else {\n@@ -1515,0 +1536,4 @@\n+                    if (cpToUnsetFieldsMap.get(chain.pc) != null) {\n+                        addUnsetFieldsAtPC(originalTarget, cpToUnsetFieldsMap.get(chain.pc));\n+                    }\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":47,"deletions":22,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,2 @@\n+    private final UnsetFieldsInfo unsetFieldsInfo;\n+\n@@ -130,0 +132,1 @@\n+        unsetFieldsInfo = UnsetFieldsInfo.instance(context);\n@@ -135,0 +138,1 @@\n+        generateAssertUnsetFieldsFrame = options.isSet(\"generateAssertUnsetFieldsFrame\");\n@@ -144,0 +148,1 @@\n+    private boolean generateAssertUnsetFieldsFrame;\n@@ -992,0 +997,4 @@\n+                Set<VarSymbol> prevUnsetFields = code.currentUnsetFields;\n+                if (meth.isConstructor()) {\n+                    code.currentUnsetFields = unsetFieldsInfo.getUnsetFields(env.enclClass.sym, tree.body);\n+                }\n@@ -999,0 +1008,2 @@\n+                } finally {\n+                    code.currentUnsetFields = prevUnsetFields;\n@@ -1067,1 +1078,2 @@\n-                                        poolWriter);\n+                                        poolWriter,\n+                                        generateAssertUnsetFieldsFrame);\n@@ -1203,0 +1215,13 @@\n+            Set<VarSymbol> prevCodeUnsetFields = code.currentUnsetFields;\n+            try {\n+                genLoopHelper(loop, body, cond, step, testFirst);\n+            } finally {\n+                code.currentUnsetFields = prevCodeUnsetFields;\n+            }\n+        }\n+\n+        private void genLoopHelper(JCStatement loop,\n+                             JCStatement body,\n+                             JCExpression cond,\n+                             List<JCExpressionStatement> step,\n+                             boolean testFirst) {\n@@ -1269,0 +1294,1 @@\n+        Set<VarSymbol> prevCodeUnsetFields = code.currentUnsetFields;\n@@ -1274,0 +1300,1 @@\n+            code.currentUnsetFields = prevCodeUnsetFields;\n@@ -1349,0 +1376,10 @@\n+        Set<VarSymbol> prevCodeUnsetFields = code.currentUnsetFields;\n+        try {\n+            handleSwitchHelper(swtch, selector, cases, patternSwitch);\n+        } finally {\n+            code.currentUnsetFields = prevCodeUnsetFields;\n+        }\n+    }\n+\n+    void handleSwitchHelper(JCTree swtch, JCExpression selector, List<JCCase> cases,\n+                      boolean patternSwitch) {\n@@ -1360,1 +1397,1 @@\n-                             CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());\n+                        CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());\n@@ -1366,1 +1403,1 @@\n-                             CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());\n+                        CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());\n@@ -1402,5 +1439,5 @@\n-                nlabels > 0 &&\n-                table_space_cost + 3 * table_time_cost <=\n-                lookup_space_cost + 3 * lookup_time_cost\n-                ?\n-                tableswitch : lookupswitch;\n+                    nlabels > 0 &&\n+                            table_space_cost + 3 * table_time_cost <=\n+                                    lookup_space_cost + 3 * lookup_time_cost\n+                            ?\n+                            tableswitch : lookupswitch;\n@@ -1442,2 +1479,2 @@\n-                            tableBase + 4 * (labels[i] - lo + 3),\n-                            pc - startpc);\n+                                tableBase + 4 * (labels[i] - lo + 3),\n+                                pc - startpc);\n@@ -1497,2 +1534,2 @@\n-                 \/\/ Emit line position for the end of a switch expression\n-                 code.statBegin(TreeInfo.endPos(swtch));\n+                \/\/ Emit line position for the end of a switch expression\n+                code.statBegin(TreeInfo.endPos(swtch));\n@@ -1601,0 +1638,9 @@\n+            Set<VarSymbol> prevCodeUnsetFields = code.currentUnsetFields;\n+            try {\n+                genTryHelper(body, catchers, env);\n+            } finally {\n+                code.currentUnsetFields = prevCodeUnsetFields;\n+            }\n+        }\n+\n+        void genTryHelper(JCTree body, List<JCCatch> catchers, Env<GenContext> env) {\n@@ -1620,2 +1666,2 @@\n-                env.info.finalize != null &&\n-                env.info.finalize.hasFinalizer();\n+                    env.info.finalize != null &&\n+                            env.info.finalize.hasFinalizer();\n@@ -1630,1 +1676,1 @@\n-                                                 code.branch(goto_));\n+                            code.branch(goto_));\n@@ -1653,1 +1699,1 @@\n-                                  catchallpc, 0);\n+                            catchallpc, 0);\n@@ -1668,2 +1714,2 @@\n-                              env.info.gaps.next().intValue(),\n-                              catchallpc, 0);\n+                        env.info.gaps.next().intValue(),\n+                        catchallpc, 0);\n@@ -1812,0 +1858,9 @@\n+        Set<VarSymbol> prevCodeUnsetFields = code.currentUnsetFields;\n+        try {\n+            visitIfHelper(tree);\n+        } finally {\n+            code.currentUnsetFields = prevCodeUnsetFields;\n+        }\n+    }\n+\n+    public void visitIfHelper(JCIf tree) {\n@@ -1816,1 +1871,1 @@\n-                             CRT_FLOW_CONTROLLER);\n+                CRT_FLOW_CONTROLLER);\n@@ -2143,0 +2198,2 @@\n+        Set<VarSymbol> tmpUnsetSymbols = unsetFieldsInfo.getUnsetFields(env.enclClass.sym, tree);\n+        code.currentUnsetFields = tmpUnsetSymbols != null ? tmpUnsetSymbols : code.currentUnsetFields;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":77,"deletions":20,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,4 @@\n-    public int[] bits = null;\n+    \/* every int in the bits array is used to represent 32 bits, so the bits array will have\n+     * length == 1 until we need to represent the 33rd bit and so on.\n+     *\/\n+    private int[] bits = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Bits.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -736,1 +736,1 @@\n-            for (stack_map_frame f: attr.entries)\n+            for (stack_map_entry f: attr.entries)\n@@ -747,1 +747,1 @@\n-            for (stack_map_frame f: attr.entries)\n+            for (stack_map_entry f: attr.entries)\n@@ -776,1 +776,1 @@\n-            implements stack_map_frame.Visitor<Void,ClassOutputStream> {\n+            implements stack_map_entry.Visitor<Void,ClassOutputStream> {\n@@ -778,2 +778,2 @@\n-        public void write(stack_map_frame frame, ClassOutputStream out) {\n-            out.write(frame.frame_type);\n+        public void write(stack_map_entry frame, ClassOutputStream out) {\n+            out.write(frame.entry_type);\n@@ -833,0 +833,9 @@\n+        @Override\n+        public Void visit_assert_unset_fields(assert_unset_fields frame, ClassOutputStream out) {\n+            out.writeShort(frame.number_of_unset_fields);\n+            for (int uf: frame.unset_fields) {\n+                out.writeShort(uf);\n+            }\n+            return null;\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-        entries = new stack_map_frame[number_of_entries];\n+        entries = new stack_map_entry[number_of_entries];\n@@ -52,1 +52,1 @@\n-            entries[i] = stack_map_frame.read(cr);\n+            entries[i] = stack_map_entry.read(cr);\n@@ -55,1 +55,1 @@\n-    public StackMapTable_attribute(ConstantPool constant_pool, stack_map_frame[] entries)\n+    public StackMapTable_attribute(ConstantPool constant_pool, stack_map_entry[] entries)\n@@ -60,1 +60,1 @@\n-    public StackMapTable_attribute(int name_index, stack_map_frame[] entries) {\n+    public StackMapTable_attribute(int name_index, stack_map_entry[] entries) {\n@@ -70,1 +70,1 @@\n-    static int length(stack_map_frame[] entries) {\n+    static int length(stack_map_entry[] entries) {\n@@ -72,1 +72,1 @@\n-        for (stack_map_frame entry: entries)\n+        for (stack_map_entry entry: entries)\n@@ -78,1 +78,1 @@\n-    public final stack_map_frame entries[];\n+    public final stack_map_entry entries[];\n@@ -80,2 +80,2 @@\n-    public abstract static class stack_map_frame {\n-        static stack_map_frame read(ClassReader cr)\n+    public abstract static class stack_map_entry {\n+        static stack_map_entry read(ClassReader cr)\n@@ -83,15 +83,17 @@\n-            int frame_type = cr.readUnsignedByte();\n-            if (frame_type <= 63)\n-                return new same_frame(frame_type);\n-            else if (frame_type <= 127)\n-                return new same_locals_1_stack_item_frame(frame_type, cr);\n-            else if (frame_type <= 246)\n-                throw new Error(\"unknown frame_type \" + frame_type);\n-            else if (frame_type == 247)\n-                return new same_locals_1_stack_item_frame_extended(frame_type, cr);\n-            else if (frame_type <= 250)\n-                return new chop_frame(frame_type, cr);\n-            else if (frame_type == 251)\n-                return new same_frame_extended(frame_type, cr);\n-            else if (frame_type <= 254)\n-                return new append_frame(frame_type, cr);\n+            int entry_type = cr.readUnsignedByte();\n+            if (entry_type <= 63)\n+                return new same_frame(entry_type);\n+            else if (entry_type <= 127)\n+                return new same_locals_1_stack_item_frame(entry_type, cr);\n+            else if (entry_type <= 245)\n+                throw new Error(\"unknown frame_type \" + entry_type);\n+            else if (entry_type == 246)\n+                return new assert_unset_fields(entry_type, cr);\n+            else if (entry_type == 247)\n+                return new same_locals_1_stack_item_frame_extended(entry_type, cr);\n+            else if (entry_type <= 250)\n+                return new chop_frame(entry_type, cr);\n+            else if (entry_type == 251)\n+                return new same_frame_extended(entry_type, cr);\n+            else if (entry_type <= 254)\n+                return new append_frame(entry_type, cr);\n@@ -99,1 +101,1 @@\n-                return new full_frame(frame_type, cr);\n+                return new full_frame(entry_type, cr);\n@@ -102,2 +104,2 @@\n-        protected stack_map_frame(int frame_type) {\n-            this.frame_type = frame_type;\n+        protected stack_map_entry(int entry_type) {\n+            this.entry_type = entry_type;\n@@ -110,2 +112,0 @@\n-        public abstract int getOffsetDelta();\n-\n@@ -114,1 +114,1 @@\n-        public final int frame_type;\n+        public final int entry_type;\n@@ -116,1 +116,1 @@\n-        public static interface Visitor<R,P> {\n+        public interface Visitor<R,P> {\n@@ -124,0 +124,1 @@\n+            R visit_assert_unset_fields(assert_unset_fields frame, P p);\n@@ -127,3 +128,3 @@\n-    public static class same_frame extends stack_map_frame {\n-        same_frame(int frame_type) {\n-            super(frame_type);\n+    public static class same_frame extends stack_map_entry {\n+        same_frame(int entry_type) {\n+            super(entry_type);\n@@ -135,4 +136,0 @@\n-\n-        public int getOffsetDelta() {\n-            return frame_type;\n-        }\n@@ -141,2 +138,2 @@\n-    public static class same_locals_1_stack_item_frame extends stack_map_frame {\n-        same_locals_1_stack_item_frame(int frame_type, ClassReader cr)\n+    public static class same_locals_1_stack_item_frame extends stack_map_entry {\n+        same_locals_1_stack_item_frame(int entry_type, ClassReader cr)\n@@ -144,1 +141,1 @@\n-            super(frame_type);\n+            super(entry_type);\n@@ -158,4 +155,0 @@\n-        public int getOffsetDelta() {\n-            return frame_type - 64;\n-        }\n-\n@@ -165,2 +158,2 @@\n-    public static class same_locals_1_stack_item_frame_extended extends stack_map_frame {\n-        same_locals_1_stack_item_frame_extended(int frame_type, ClassReader cr)\n+    public static class same_locals_1_stack_item_frame_extended extends stack_map_entry {\n+        same_locals_1_stack_item_frame_extended(int entry_type, ClassReader cr)\n@@ -168,1 +161,1 @@\n-            super(frame_type);\n+            super(entry_type);\n@@ -183,4 +176,0 @@\n-        public int getOffsetDelta() {\n-            return offset_delta;\n-        }\n-\n@@ -191,3 +180,3 @@\n-    public static class chop_frame extends stack_map_frame {\n-        chop_frame(int frame_type, ClassReader cr) throws IOException {\n-            super(frame_type);\n+    public static class chop_frame extends stack_map_entry {\n+        chop_frame(int entry_type, ClassReader cr) throws IOException {\n+            super(entry_type);\n@@ -206,4 +195,0 @@\n-        public int getOffsetDelta() {\n-            return offset_delta;\n-        }\n-\n@@ -213,3 +198,3 @@\n-    public static class same_frame_extended extends stack_map_frame {\n-        same_frame_extended(int frame_type, ClassReader cr) throws IOException {\n-            super(frame_type);\n+    public static class same_frame_extended extends stack_map_entry {\n+        same_frame_extended(int entry_type, ClassReader cr) throws IOException {\n+            super(entry_type);\n@@ -228,4 +213,0 @@\n-        public int getOffsetDelta() {\n-            return offset_delta;\n-        }\n-\n@@ -235,2 +216,2 @@\n-    public static class append_frame extends stack_map_frame {\n-        append_frame(int frame_type, ClassReader cr)\n+    public static class append_frame extends stack_map_entry {\n+        append_frame(int entry_type, ClassReader cr)\n@@ -238,1 +219,1 @@\n-            super(frame_type);\n+            super(entry_type);\n@@ -240,1 +221,1 @@\n-            locals = new verification_type_info[frame_type - 251];\n+            locals = new verification_type_info[entry_type - 251];\n@@ -257,4 +238,0 @@\n-        public int getOffsetDelta() {\n-            return offset_delta;\n-        }\n-\n@@ -265,2 +242,2 @@\n-    public static class full_frame extends stack_map_frame {\n-        full_frame(int frame_type, ClassReader cr)\n+    public static class full_frame extends stack_map_entry {\n+        full_frame(int entry_type, ClassReader cr)\n@@ -268,1 +245,1 @@\n-            super(frame_type);\n+            super(entry_type);\n@@ -295,4 +272,0 @@\n-        public int getOffsetDelta() {\n-            return offset_delta;\n-        }\n-\n@@ -306,0 +279,18 @@\n+    public static class assert_unset_fields extends stack_map_entry {\n+        assert_unset_fields(int entry_type, ClassReader cr) throws IOException {\n+            super(entry_type);\n+            number_of_unset_fields = cr.readUnsignedShort();\n+            unset_fields = new int[number_of_unset_fields];\n+            for (int i = 0; i < number_of_unset_fields; i++) {\n+                unset_fields[i] = cr.readUnsignedShort();\n+            }\n+        }\n+\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visit_assert_unset_fields(this, data);\n+        }\n+\n+        public final int number_of_unset_fields;\n+        public final int[] unset_fields;\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/StackMapTable_attribute.java","additions":73,"deletions":82,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-        entries = new stack_map_frame[number_of_entries];\n+        entries = new stack_map_entry[number_of_entries];\n@@ -43,1 +43,1 @@\n-            entries[i] = new stack_map_frame(cr);\n+            entries[i] = new stack_map_entry(cr);\n@@ -46,1 +46,1 @@\n-    public StackMap_attribute(ConstantPool constant_pool, stack_map_frame[] entries)\n+    public StackMap_attribute(ConstantPool constant_pool, stack_map_entry[] entries)\n@@ -51,1 +51,1 @@\n-    public StackMap_attribute(int name_index, stack_map_frame[] entries) {\n+    public StackMap_attribute(int name_index, stack_map_entry[] entries) {\n@@ -62,1 +62,1 @@\n-    public final stack_map_frame entries[];\n+    public final stack_map_entry entries[];\n@@ -64,2 +64,2 @@\n-    public static class stack_map_frame extends StackMapTable_attribute.full_frame {\n-        stack_map_frame(ClassReader cr)\n+    public static class stack_map_entry extends StackMapTable_attribute.full_frame {\n+        stack_map_entry(ClassReader cr)\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/StackMap_attribute.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -572,1 +572,1 @@\n-                        int offsetDelta = lr.labelToBci(frame.target()) - lastOffset - 1;\n+                        int offsetDelta = frameType != 246 ? lr.labelToBci(frame.target()) - lastOffset - 1 : 0;\n@@ -574,0 +574,13 @@\n+                            case 246 -> {\n+                                printHeader(frameType, \"\/* assert_unset_fields *\/\");\n+                                indent(+1);\n+                                println(\"number of unset_fields = \" + frame.unsetFields().size());\n+                                    indent(+1);\n+                                    for (NameAndTypeEntry field : frame.unsetFields()) {\n+                                        print(\"unset_field = #\");\n+                                        constantWriter.write(field.index());\n+                                        println();\n+                                    }\n+                                    indent(-1);\n+                                indent(-1);\n+                            }\n@@ -575,1 +588,1 @@\n-                                printHeader(frameType, \"\/* same_locals_1_stack_item_frame_extended *\/\");\n+                                printHeader(frameType, \"\/* same_locals_1_stack_item_entry_extended *\/\");\n@@ -588,1 +601,1 @@\n-                                printHeader(frameType, \"\/* same_frame_extended *\/\");\n+                                printHeader(frameType, \"\/* same_entry_extended *\/\");\n@@ -603,1 +616,1 @@\n-                                printHeader(frameType, \"\/* full_frame *\/\");\n+                                printHeader(frameType, \"\/* full_entry *\/\");\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n@@ -101,0 +102,3 @@\n+            if (!m.unsetFields().isEmpty()) {\n+                printFields(\"StackMap unset fields: \", m.unsetFields());\n+            }\n@@ -105,0 +109,16 @@\n+    void printFields(String label, List<NameAndTypeEntry> entries) {\n+        print(label);\n+        boolean first = true;\n+        for (var e : entries) {\n+            if (!first) {\n+                print(\", \");\n+            } else {\n+                first = false;\n+            }\n+            print(e::name);\n+            print(\":\");\n+            print(e::type);\n+        }\n+        println();\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/StackMapWriter.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -45,1 +45,2 @@\n-            if (!ve.getMessage().startsWith(\"Illegal use of putfield on a strict field\")) {\n+            \/\/ Once strict non-final is possible, expect \"Illegal use of putfield on a strict field\"\n+            if (!ve.getMessage().startsWith(\"All strict final fields must be initialized before super()\")) {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFields.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED -XDgenerateAssertUnsetFieldsFrame StrictFinalInstanceFieldsTest.java\n+ * @run main\/othervm -Xlog:verification StrictFinalInstanceFieldsTest\n+ *\/\n+\n+import jdk.internal.vm.annotation.Strict;\n+\n+public class StrictFinalInstanceFieldsTest {\n+    public static void main(String[] args) {\n+        \/\/ Base case\n+        Child c = new Child();\n+        System.out.println(c);\n+\n+        \/\/ Field not initialized before super call\n+        try {\n+            BadChild0 bc0 = new BadChild0();\n+            System.out.println(bc0);\n+            throw new RuntimeException(\"Should fail verification\");\n+        } catch (java.lang.VerifyError e) {\n+            if (!e.getMessage().contains(\"All strict final fields must be initialized before super()\")) {\n+                throw new RuntimeException(\"wrong exception: \" + e.getMessage());\n+            }\n+            e.printStackTrace();\n+        }\n+\n+        \/\/ Field not initialized before super call\n+        try {\n+            BadChild1 bc1 = new BadChild1();\n+            System.out.println(bc1);\n+            throw new RuntimeException(\"Should fail verification\");\n+        } catch (java.lang.VerifyError e) {\n+            if (!e.getMessage().contains(\"All strict final fields must be initialized before super()\")) {\n+                throw new RuntimeException(\"wrong exception: \" + e.getMessage());\n+            }\n+            e.printStackTrace();\n+        }\n+\n+        \/\/ Test constructor with control flow. Should pass\n+        Child1 c1 = new Child1(true, false);\n+        System.out.println(c1);\n+\n+        \/\/ Test constructor with control flow and nested constructor calls. Should pass\n+        Child1 c1_2 = new Child1();\n+        System.out.println(c1_2);\n+\n+        \/\/ Test assignment in conditional. Should pass\n+        Child2 c2 = new Child2();\n+        System.out.println(c2);\n+\n+        \/\/ Test constructor with control flow in switch case. Should pass\n+        Child3 c3 = new Child3(2);\n+        System.out.println(c3);\n+\n+        System.out.println(\"Passed\");\n+    }\n+}\n+\n+class Parent {\n+    int z;\n+\n+    Parent() {\n+        z = 0;\n+    }\n+\n+    int get_z() { return z; }\n+\n+    @Override\n+    public String toString() {\n+        return \"z: \" + get_z();\n+    }\n+}\n+\n+class Child extends Parent {\n+\n+    @Strict\n+    final int x;\n+    @Strict\n+    final int y;\n+\n+    Child() {\n+        x = y = 1;\n+        super();\n+    }\n+\n+    int get_x() { return x; }\n+    int get_y() { return y; }\n+\n+    @Override\n+    public String toString() {\n+        return \"x: \" + get_x() + \"\\n\" + \"y: \" + get_y() + \"\\n\" + super.toString();\n+    }\n+}\n+\n+class BadChild0 extends Parent {\n+\n+    @Strict\n+    final int x;\n+    @Strict\n+    final int y;\n+\n+    \/\/ Should fail with \"All strict final fields must be initialized before super()\"\n+    BadChild0() {\n+        x = 1;\n+        super();\n+        y = 1;\n+    }\n+\n+    int get_x() { return x; }\n+    int get_y() { return y; }\n+\n+    @Override\n+    public String toString() {\n+        return \"x: \" + get_x() + \"\\n\" + \"y: \" + get_y() + \"\\n\" + super.toString();\n+    }\n+}\n+\n+class BadChild1 extends Parent {\n+\n+    @Strict\n+    final int x;\n+    @Strict\n+    final int y;\n+\n+    \/\/ Should fail with \"All strict final fields must be initialized before super()\"\n+    BadChild1() {\n+        y = 1;\n+        super();\n+        x = 1;\n+    }\n+\n+    int get_x() { return x; }\n+    int get_y() { return y; }\n+\n+    @Override\n+    public String toString() {\n+        return \"x: \" + get_x() + \"\\n\" + \"y: \" + get_y() + \"\\n\" + super.toString();\n+    }\n+}\n+\n+class Child1 extends Parent {\n+\n+    @Strict\n+    final int x;\n+    @Strict\n+    final int y;\n+\n+    Child1(boolean a, boolean b) {\n+        if (a) {\n+            x = 1;\n+            if (b) {\n+                y = 1;\n+            } else {\n+                y = 2;\n+            }\n+        } else {\n+            x = y = 3;\n+        }\n+        super();\n+    }\n+\n+    Child1() {\n+        this(true, true);\n+    }\n+\n+    int get_x() { return x; }\n+    int get_y() { return y; }\n+\n+    @Override\n+    public String toString() {\n+        return \"x: \" + get_x() + \"\\n\" + \"y: \" + get_y() + \"\\n\" + super.toString();\n+    }\n+}\n+\n+class Child2 extends Parent {\n+\n+    @Strict\n+    final int x;\n+    @Strict\n+    final int y;\n+\n+    Child2() {\n+        if ((x=1) == 1) {\n+            y = 1;\n+        } else {\n+            y = 2;\n+        }\n+        super();\n+    }\n+\n+    int get_x() { return x; }\n+    int get_y() { return y; }\n+\n+    @Override\n+    public String toString() {\n+        return \"x: \" + get_x() + \"\\n\" + \"y: \" + get_y() + \"\\n\" + super.toString();\n+    }\n+}\n+\n+class Child3 extends Parent {\n+\n+    @Strict\n+    final int x;\n+    @Strict\n+    final int y;\n+\n+    Child3(int n) {\n+        switch(n) {\n+            case 0:\n+                x = y = 0;\n+                break;\n+            case 1:\n+                x = y = 1;\n+                break;\n+            case 2:\n+                x = y = 2;\n+                break;\n+            default:\n+                x = y = 100;\n+                break;\n+        }\n+        super();\n+    }\n+\n+    int get_x() { return x; }\n+    int get_y() { return y; }\n+\n+    @Override\n+    public String toString() {\n+        return \"x: \" + get_x() + \"\\n\" + \"y: \" + get_y() + \"\\n\" + super.toString();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFinalInstanceFieldsTest.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+import com.sun.tools.classfile.StackMapTable_attribute;\n@@ -1394,0 +1395,102 @@\n+    @Test\n+    void testAssertUnsetFieldsSMEntry() throws Exception {\n+        String[] previousOptions = getCompileOptions();\n+        try {\n+            String[] testOptions = {\n+                    \"--enable-preview\",\n+                    \"-source\", Integer.toString(Runtime.version().feature()),\n+                    \"-XDgenerateAssertUnsetFieldsFrame\",\n+                    \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+            };\n+            setCompileOptions(testOptions);\n+\n+            record Data(String src, int[] expectedFrameTypes, String[][] expectedUnsetFields) {}\n+            for (Data data : List.of(\n+                    new Data(\n+                            \"\"\"\n+                            import jdk.internal.vm.annotation.Strict;\n+                            class Test {\n+                                @Strict\n+                                final int x;\n+                                @Strict\n+                                final int y;\n+                                Test(boolean a, boolean b) {\n+                                    if (a) { \/\/ assert_unset_fields {x, y}\n+                                        x = 1;\n+                                        if (b) { \/\/ assert_unset_fields {y}\n+                                            y = 1;\n+                                        } else { \/\/ assert_unset_fields {y}\n+                                            y = 2;\n+                                        }\n+                                    } else { \/\/ assert_unset_fields {x, y}\n+                                        x = y = 3;\n+                                    }\n+                                    super();\n+                                }\n+                            }\n+                            \"\"\",\n+                            \/\/ three unset_fields entries, entry type 246, are expected in the stackmap table\n+                            new int[] {246, 21, 246, 7, 246, 9},\n+                            \/\/ expected fields for each of them:\n+                            new String[][] { new String[] { \"y:I\" }, new String[] { \"x:I\", \"y:I\" }, new String[] {} }\n+                    ),\n+                    new Data(\n+                            \"\"\"\n+                            import jdk.internal.vm.annotation.Strict;\n+                            class Test {\n+                                @Strict\n+                                final int x;\n+                                @Strict\n+                                final int y;\n+                                Test(int n) {\n+                                    switch(n) {\n+                                        case 2:\n+                                            x = y = 2;\n+                                            break;\n+                                        default:\n+                                            x = y = 100;\n+                                            break;\n+                                    }\n+                                    super();\n+                                }\n+                            }\n+                            \"\"\",\n+                            \/\/ here we expect only one\n+                            new int[] {20, 12, 246, 10},\n+                            \/\/ stating that no field is unset\n+                            new String[][] { new String[] {} }\n+                    )\n+            )) {\n+                File dir = assertOK(true, data.src());\n+                for (final File fileEntry : dir.listFiles()) {\n+                    ClassFile classFile = ClassFile.read(fileEntry);\n+                    for (Method method : classFile.methods) {\n+                        if (method.getName(classFile.constant_pool).equals(\"<init>\")) {\n+                            Code_attribute code = (Code_attribute)method.attributes.get(\"Code\");\n+                            StackMapTable_attribute stackMapTable = (StackMapTable_attribute)code.attributes.get(\"StackMapTable\");\n+                            int entryIndex = 0;\n+                            Assert.check(data.expectedFrameTypes().length == stackMapTable.entries.length, \"unexpected stackmap length\");\n+                            int expectedUnsetFieldsIndex = 0;\n+                            for (StackMapTable_attribute.stack_map_entry entry : stackMapTable.entries) {\n+                                Assert.check(data.expectedFrameTypes()[entryIndex++] == entry.entry_type);\n+                                if (entry.entry_type == 246) {\n+                                    StackMapTable_attribute.assert_unset_fields auf = (StackMapTable_attribute.assert_unset_fields)entry;\n+                                    Assert.check(data.expectedUnsetFields()[expectedUnsetFieldsIndex].length == auf.number_of_unset_fields);\n+                                    int index = 0;\n+                                    for (int i : auf.unset_fields) {\n+                                        String unsetStr = classFile.constant_pool.getNameAndTypeInfo(i).getName() + \":\" +\n+                                                classFile.constant_pool.getNameAndTypeInfo(i).getType();\n+                                        Assert.check(data.expectedUnsetFields()[expectedUnsetFieldsIndex][index++].equals(unsetStr));\n+                                    }\n+                                    expectedUnsetFieldsIndex++;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":104,"deletions":1,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,2 +69,2 @@\n-        \"        frame_type = 255 \/* full_frame *\/\\n\" +\n-        \"        frame_type = 255 \/* full_frame *\/\\n\" +\n+        \"        frame_type = 255 \/* full_entry *\/\\n\" +\n+        \"        frame_type = 255 \/* full_entry *\/\\n\" +\n@@ -72,1 +72,1 @@\n-        \"        frame_type = 255 \/* full_frame *\/\\n\" +\n+        \"        frame_type = 255 \/* full_entry *\/\\n\" +\n","filename":"test\/langtools\/tools\/javap\/stackmap\/StackmapTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}