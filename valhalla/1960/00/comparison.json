{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.vm.annotation.Strict;\n@@ -31,0 +30,1 @@\n+import jdk.test.lib.helpers.StrictInit;\n@@ -41,0 +41,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -53,0 +56,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -67,0 +73,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -81,0 +90,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -95,0 +107,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -109,0 +124,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -123,0 +141,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -137,0 +158,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -151,0 +175,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -165,0 +192,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -180,0 +210,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -195,0 +228,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -210,0 +246,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -225,0 +264,3 @@\n+ * @compile TestFieldNullMarkers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestFieldNullMarkers$StrictFieldHolder\n@@ -533,1 +575,1 @@\n-        @Strict\n+        @StrictInit\n@@ -535,1 +577,1 @@\n-        @Strict\n+        @StrictInit\n@@ -541,1 +583,1 @@\n-        @Strict\n+        @StrictInit\n@@ -546,1 +588,1 @@\n-        @Strict\n+        @StrictInit\n@@ -548,1 +590,1 @@\n-        @Strict\n+        @StrictInit\n@@ -554,1 +596,1 @@\n-        @Strict\n+        @StrictInit\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFieldNullMarkers.java","additions":49,"deletions":7,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -39,1 +39,0 @@\n-import jdk.internal.vm.annotation.Strict;\n@@ -60,1 +59,0 @@\n-        @Strict\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMemBars.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -31,0 +31,8 @@\n+ * @compile TestStrictFieldBarriers.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             compiler.valhalla.inlinetypes.TestStrictFieldBarriers$A1\n+ *             compiler.valhalla.inlinetypes.TestStrictFieldBarriers$B1\n+ *             compiler.valhalla.inlinetypes.TestStrictFieldBarriers$C1\n+ *             compiler.valhalla.inlinetypes.TestStrictFieldBarriers$A2\n+ *             compiler.valhalla.inlinetypes.TestStrictFieldBarriers$B2\n+ *             compiler.valhalla.inlinetypes.TestStrictFieldBarriers$C2\n@@ -48,3 +56,1 @@\n-import jdk.internal.vm.annotation.Strict;\n-\n-import jdk.test.lib.Asserts;\n+import jdk.test.lib.helpers.StrictInit;\n@@ -69,1 +75,1 @@\n-        @Strict\n+        @StrictInit\n@@ -80,1 +86,1 @@\n-        @Strict\n+        @StrictInit\n@@ -97,1 +103,1 @@\n-        @Strict\n+        @StrictInit\n@@ -132,1 +138,1 @@\n-        @Strict\n+        @StrictInit\n@@ -143,1 +149,1 @@\n-        @Strict\n+        @StrictInit\n@@ -160,1 +166,1 @@\n-        @Strict\n+        @StrictInit\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestStrictFieldBarriers.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+ * @compile StrictFinalTest.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor StrictFinalTest\n+ *             StrictFinalTest$Container5 StrictFinalTest$Container6\n@@ -40,2 +43,0 @@\n-import jdk.internal.vm.annotation.NullRestricted;\n-import jdk.internal.vm.annotation.Strict;\n@@ -46,0 +47,1 @@\n+import jdk.test.lib.helpers.StrictInit;\n@@ -147,1 +149,1 @@\n-    \/\/     @Strict\n+    \/\/     @StrictInit\n@@ -186,1 +188,1 @@\n-        @Strict\n+        @StrictInit\n@@ -209,1 +211,1 @@\n-        @Strict\n+        @StrictInit\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/StrictFinalTest.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,2 +30,3 @@\n- * @modules java.base\/jdk.internal.vm.annotation\n- * @compile -XDnoLocalProxyVars StrictFieldsOld.java StrictFieldsNew.java\n+ * @compile StrictFieldsOld.java StrictFieldsNew.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             StrictFieldsOld StrictFieldsNew\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/RedefineStrictFieldsTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import jdk.internal.vm.annotation.Strict;\n+import jdk.test.lib.helpers.StrictInit;\n@@ -28,1 +28,1 @@\n-    @Strict\n+    @StrictInit\n@@ -30,1 +30,1 @@\n-    @Strict\n+    @StrictInit\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFieldsNew.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import jdk.internal.vm.annotation.Strict;\n+import jdk.test.lib.helpers.StrictInit;\n@@ -27,1 +27,1 @@\n-    @Strict\n+    @StrictInit\n@@ -29,1 +29,1 @@\n-    @Strict\n+    @StrictInit\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFieldsOld.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib\n@@ -36,1 +36,4 @@\n- * @compile -XDnoLocalProxyVars StrictInstanceFieldsTest.java\n+ * @compile StrictInstanceFieldsTest.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor StrictInstanceFieldsTest\n+ *             Child ControlFlowChild TryCatchChild AssignedInConditionalChild\n+ *             SwitchCaaseChild NestedConstructorChild FinalChild\n@@ -41,1 +44,1 @@\n-import jdk.internal.vm.annotation.Strict;\n+import jdk.test.lib.helpers.StrictInit;\n@@ -207,1 +210,1 @@\n-    @Strict\n+    @StrictInit\n@@ -209,1 +212,1 @@\n-    @Strict\n+    @StrictInit\n@@ -220,1 +223,1 @@\n-    @Strict\n+    @StrictInit\n@@ -222,1 +225,1 @@\n-    @Strict\n+    @StrictInit\n@@ -242,1 +245,1 @@\n-    @Strict\n+    @StrictInit\n@@ -244,1 +247,1 @@\n-    @Strict\n+    @StrictInit\n@@ -263,1 +266,1 @@\n-    @Strict\n+    @StrictInit\n@@ -265,1 +268,1 @@\n-    @Strict\n+    @StrictInit\n@@ -280,1 +283,1 @@\n-    @Strict\n+    @StrictInit\n@@ -282,1 +285,1 @@\n-    @Strict\n+    @StrictInit\n@@ -306,1 +309,1 @@\n-    @Strict\n+    @StrictInit\n@@ -308,1 +311,1 @@\n-    @Strict\n+    @StrictInit\n@@ -332,1 +335,1 @@\n-    @Strict\n+    @StrictInit\n@@ -334,1 +337,1 @@\n-    @Strict\n+    @StrictInit\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictInstanceFieldsTest.java","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -34,1 +35,7 @@\n- * @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED StrictStaticFieldsTest.java\n+ * @compile StrictStaticFieldsTest.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor\n+ *             runtime.valhalla.inlinetypes.verifier.StrictStaticFieldsTest\n+ *             runtime.valhalla.inlinetypes.verifier.Aregular_OK\n+ *             runtime.valhalla.inlinetypes.verifier.Anulls_OK\n+ *             runtime.valhalla.inlinetypes.verifier.Arepeat_OK\n+ *             runtime.valhalla.inlinetypes.verifier.Aupdate_OK\n@@ -41,1 +48,1 @@\n-import jdk.internal.vm.annotation.Strict;\n+import jdk.test.lib.helpers.StrictInit;\n@@ -164,2 +171,2 @@\n-        @Strict static final String F1__STRICT = \"hello\";\n-        @Strict static final int    F2__STRICT = 42;\n+        @StrictInit static final String F1__STRICT = \"hello\";\n+        @StrictInit static final int    F2__STRICT = 42;\n@@ -169,2 +176,2 @@\n-    @Strict static String F1__STRICT = null;\n-    @Strict static int    F2__STRICT = 0;\n+    @StrictInit static String F1__STRICT = null;\n+    @StrictInit static int    F2__STRICT = 0;\n@@ -174,2 +181,2 @@\n-    @Strict static String F1__STRICT = \"hello\";\n-    @Strict static int    F2__STRICT = 42;\n+    @StrictInit static String F1__STRICT = \"hello\";\n+    @StrictInit static int    F2__STRICT = 42;\n@@ -183,2 +190,2 @@\n-    @Strict static String F1__STRICT = \"hello\";\n-    @Strict static int    F2__STRICT = 42;\n+    @StrictInit static String F1__STRICT = \"hello\";\n+    @StrictInit static int    F2__STRICT = 42;\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictStaticFieldsTest.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8351362\n+ * @summary Unit Test for StrictProcessor super rewrite\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @compile StrictProcessorSuperTest.java\n+ * @run driver jdk.test.lib.helpers.StrictProcessor --deferSuperCall\n+ *             StrictProcessorSuperTest$Rec StrictProcessorSuperTest$Exp\n+ *             StrictProcessorSuperTest$Inner\n+ * @run junit StrictProcessorSuperTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CompoundElement;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Opcode;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.helpers.StrictInit;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class StrictProcessorSuperTest {\n+    static Stream<Class<?>> testClasses() {\n+        return Stream.of(Rec.class, Exp.class, Inner.class);\n+    }\n+\n+    static Stream<ClassModel> testClassModels() {\n+        return testClasses().map(cls -> {\n+            try (var in = StrictProcessorSuperTest.class.getResourceAsStream(\"\/\" + cls.getName() + \".class\")) {\n+                return ClassFile.of().parse(in.readAllBytes());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        });\n+    }\n+\n+    @MethodSource(\"testClasses\")\n+    @ParameterizedTest\n+    void testReflectRewrittenRecord(Class<?> cls) throws Throwable {\n+        for (var field : cls.getDeclaredFields()) {\n+            if (Modifier.isStatic(field.getModifiers()) || field.isSynthetic())\n+                continue;\n+            assertEquals(ACC_PRIVATE | ACC_STRICT_INIT | ACC_FINAL, field.getModifiers(), () -> \"For field: \" + field.getName());\n+        }\n+    }\n+\n+    @MethodSource(\"testClassModels\")\n+    @ParameterizedTest\n+    void testRewrittenStrictAccessInClassFile(ClassModel cm) throws Throwable {\n+        for (var f : cm.fields()) {\n+            if (f.flags().has(AccessFlag.STATIC) || f.flags().has(AccessFlag.SYNTHETIC))\n+                continue;\n+            assertEquals(ACC_PRIVATE | ACC_STRICT_INIT | ACC_FINAL, f.flags().flagsMask(), () -> \"Field \" + f);\n+        }\n+    }\n+\n+    @MethodSource(\"testClassModels\")\n+    @ParameterizedTest\n+    void testRewrittenCtorBytecode(ClassModel cm) throws Throwable {\n+        var ctor = cm.methods().stream().filter(m -> m.methodName().equalsString(INIT_NAME)).findFirst().orElseThrow();\n+        var insts = new ArrayList<Instruction>();\n+        ctor.findAttribute(Attributes.code()).orElseThrow().forEach(ce -> {\n+            if (ce instanceof Instruction inst) {\n+                insts.add(inst);\n+            }\n+        });\n+        assertSame(Opcode.RETURN, insts.getLast().opcode());\n+        assertSame(Opcode.INVOKESPECIAL, insts.get(insts.size() - 2).opcode());\n+    }\n+\n+    record Rec(@StrictInit int a, @StrictInit long b) {\n+        static final String NOISE = \"noise\";\n+    }\n+\n+    static class Exp {\n+        private @StrictInit final int a;\n+        private @StrictInit final long b;\n+\n+        Exp(int a, long b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+    }\n+\n+    class Inner {\n+        private @StrictInit final int a;\n+        private @StrictInit final long b;\n+\n+        Inner(int a, long b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return a + \" \" + StrictProcessorSuperTest.this + \" \" + b;\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/StrictProcessorSuperTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8351362\n+ * @summary Unit Test for StrictProcessor\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @build StrictProcessorTest\n+ * @run driver jdk.test.lib.helpers.StrictProcessor StrictProcessorTest$StrictTarget\n+ * @run junit StrictProcessorTest\n+ *\/\n+\n+import jdk.test.lib.helpers.StrictInit;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class StrictProcessorTest {\n+    @Test\n+    void testReflectMyself() throws Throwable {\n+        for (var field : StrictTarget.class.getDeclaredFields()) {\n+            assertEquals(ACC_STRICT_INIT | ACC_FINAL, field.getModifiers(), () -> field.getName());\n+        }\n+    }\n+\n+    static final class StrictTarget {\n+        @StrictInit\n+        final int a;\n+        @StrictInit\n+        final Object b;\n+\n+        StrictTarget() {\n+            this.a = 1;\n+            this.b = 2392352234L;\n+            super();\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/StrictProcessorTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.helpers;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Annotated field should be marked ACC_STRICT_INIT.\n+ *\/\n+@Target(ElementType.FIELD)\n+@Retention(RetentionPolicy.CLASS)\n+public @interface StrictInit {\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/helpers\/StrictInit.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.helpers;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.classfile.instruction.FieldInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.classfile.instruction.ReturnInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+\n+\/**\n+ * Modify a class file to include strict init field access flag.\n+ *\/\n+public final class StrictProcessor {\n+    public static final String TEST_CLASSES = System.getProperty(\"test.classes\", \"\").trim();\n+    private static final ClassDesc CD_StrictInit = ClassDesc.of(\"jdk.test.lib.helpers.StrictInit\");\n+    \/\/ NR will stay in jdk.internal for now until we expose as a more formal feature\n+    private static final ClassDesc CD_NullRestricted = ClassDesc.of(\"jdk.internal.vm.annotation.NullRestricted\");\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean deferSuperCall = false;\n+        int i;\n+        for (i = 0; i < args.length; i++) {\n+            String opt = args[i];\n+            if (!opt.startsWith(\"--\")) {\n+                break;\n+            }\n+            switch (opt) {\n+                case \"--deferSuperCall\" -> deferSuperCall = true;\n+                default -> throw new IllegalArgumentException(\"Unknown option %s\".formatted(opt));\n+            }\n+        }\n+\n+        for (; i < args.length; i++) {\n+            String name = args[i];\n+            byte[] bytes = findClassBytes(name);\n+            bytes = deferSuperCall ? fixSuperAndPatchStrictInit(bytes) : patchStrictInit(bytes);\n+            ClassFileInstaller.writeClassToDisk(name, bytes, TEST_CLASSES);\n+        }\n+    }\n+\n+    static byte[] findClassBytes(String className) {\n+        ClassLoader cl = StrictProcessor.class.getClassLoader();\n+\n+        String pathName = className.replace('.', '\/').concat(\".class\");\n+\n+        try (InputStream is = cl.getResourceAsStream(pathName)) {\n+            if (is == null) {\n+                throw new RuntimeException(\"Failed to find \" + pathName);\n+            }\n+            return is.readAllBytes();\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    public static byte[] fixSuperAndPatchStrictInit(byte[] rawBytes) {\n+        var cm = ClassFile.of().parse(rawBytes);\n+        record FieldKey(Utf8Entry name, Utf8Entry type) {}\n+        Set<FieldKey> strictInstances = new HashSet<>();\n+        for (var f : cm.fields()) {\n+            if (f.flags().has(AccessFlag.STATIC))\n+                continue;\n+            var riaa = f.findAttribute(Attributes.runtimeInvisibleAnnotations());\n+            if (riaa.isPresent()) {\n+                for (var anno : riaa.get().annotations()) {\n+                    var descString = anno.className();\n+                    if (descString.equalsString(CD_StrictInit.descriptorString())) {\n+                        strictInstances.add(new FieldKey(f.fieldName(), f.fieldType()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        var thisClass = cm.thisClass();\n+        var superName = cm.superclass().orElseThrow().name();\n+\n+        var rewritten = ClassFile.of().transformClass(cm, (clb, cle) -> {\n+            cond:\n+            if (cle instanceof MethodModel mm\n+                    && mm.methodName().equalsString(INIT_NAME)) {\n+                var code = mm.findAttribute(Attributes.code()).orElseThrow();\n+                var elements = code.elementList();\n+                int len = elements.size();\n+                int superCallPos = -1;\n+                int returnPos = -1;\n+                boolean deferSuperCall = false;\n+                for (int i = 0; i < len; i++) {\n+                    var e = elements.get(i);\n+                    if (superCallPos == -1) {\n+                        if (e instanceof InvokeInstruction inv &&\n+                                inv.opcode() == Opcode.INVOKESPECIAL &&\n+                                inv.method().name().equalsString(INIT_NAME) &&\n+                                inv.method().type().equalsString(\"()V\") &&\n+                                inv.owner().name().equals(superName)) {\n+                            \/\/ Assume we are calling on uninitializedThis...\n+                            superCallPos = i;\n+                        }\n+                    } else if (!deferSuperCall) {\n+                        if (e instanceof FieldInstruction ins &&\n+                                ins.opcode() == Opcode.PUTFIELD &&\n+                                ins.owner().equals(thisClass) &&\n+                                strictInstances.contains(new FieldKey(ins.name(), ins.type()))) {\n+                            deferSuperCall = true;\n+                        }\n+                    }\n+                    if (e instanceof ReturnInstruction inst && inst.opcode() == Opcode.RETURN) {\n+                        if (returnPos != -1) {\n+                            throw new IllegalArgumentException(\"Control flow too complex\");\n+                        } else {\n+                            returnPos = i;\n+                        }\n+                    }\n+                }\n+                if (elements.reversed().stream()\n+                        .<Instruction>mapMulti((e, sink) -> {\n+                            if (e instanceof Instruction i) {\n+                                sink.accept(i);\n+                            }\n+                        })\n+                        .findFirst()\n+                        .orElseThrow()\n+                        .opcode() != Opcode.RETURN) {\n+                    throw new IllegalArgumentException(\"Control flow too complex\");\n+                }\n+                if (!deferSuperCall) {\n+                    break cond;\n+                }\n+                var suppliedElements = new ArrayList<>(elements);\n+                var foundLoad = suppliedElements.remove(superCallPos - 1);\n+                var foundSuperCall = suppliedElements.remove(superCallPos - 1);\n+                var foundReturnInst = suppliedElements.remove(returnPos - 2);\n+                suppliedElements.add(foundLoad);\n+                suppliedElements.add(foundSuperCall);\n+                suppliedElements.add(foundReturnInst);\n+                clb.withMethod(INIT_NAME, mm.methodTypeSymbol(), mm.flags().flagsMask(), mb -> mb\n+                        .transform(mm, MethodTransform.dropping(ce -> ce instanceof CodeModel))\n+                        .withCode(suppliedElements::forEach));\n+                return;\n+            }\n+            clb.with(cle);\n+        });\n+\n+        return patchStrictInit(rewritten);\n+    }\n+\n+    public static byte[] patchStrictInit(byte[] rawBytes) {\n+        var cm = ClassFile.of().parse(rawBytes);\n+\n+        var classTransform = ClassTransform.transformingFields(FieldTransform.ofStateful(() -> new FieldTransform() {\n+            int oldAccessFlags;\n+            boolean nullRestricted;\n+            boolean strictInit;\n+\n+            @Override\n+            public void accept(FieldBuilder builder, FieldElement element) {\n+                if (element instanceof AccessFlags af) {\n+                    oldAccessFlags = af.flagsMask();\n+                    return;\n+                }\n+                builder.with(element);\n+                switch (element) {\n+                    case RuntimeInvisibleAnnotationsAttribute riaa -> {\n+                        for (var anno : riaa.annotations()) {\n+                            var descString = anno.className();\n+                            if (descString.equalsString(CD_StrictInit.descriptorString())) {\n+                                strictInit = true;\n+                            }\n+                        }\n+                    }\n+                    case RuntimeVisibleAnnotationsAttribute rvaa -> {\n+                        for (var anno : rvaa.annotations()) {\n+                            var descString = anno.className();\n+                            if (descString.equalsString(CD_NullRestricted.descriptorString())) {\n+                                nullRestricted = true;\n+                            }\n+                        }\n+                    }\n+                    default -> {}\n+                }\n+            }\n+\n+            @Override\n+            public void atEnd(FieldBuilder builder) {\n+                if (strictInit) {\n+                    oldAccessFlags |= ACC_STRICT_INIT;\n+                }\n+                builder.withFlags(oldAccessFlags);\n+                assert !nullRestricted || strictInit : cm.thisClass().asInternalName();\n+            }\n+        }));\n+\n+        if (cm.minorVersion() != PREVIEW_MINOR_VERSION) {\n+            \/\/ We need to patch minor version and InnerClasses\n+            classTransform = classTransform.andThen((clb, cle) -> {\n+                if (cle instanceof InnerClassesAttribute ica) {\n+                    \/\/ VM needs identity bit fixed\n+                    var fixedInfos = ica.classes().stream().map(info -> InnerClassInfo.of(info.innerClass(), info.outerClass(), info.innerName(), info.flagsMask() | ACC_IDENTITY)).toList();\n+                    clb.with(InnerClassesAttribute.of(fixedInfos));\n+                } else if (cle instanceof ClassFileVersion cfv) {\n+                    clb.withVersion(cfv.majorVersion(), PREVIEW_MINOR_VERSION);\n+                } else {\n+                    clb.with(cle);\n+                }\n+            });\n+        }\n+\n+        return ClassFile.of().transformClass(cm, classTransform);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/helpers\/StrictProcessor.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"}]}