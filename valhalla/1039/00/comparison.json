{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -85,0 +87,22 @@\n+        private static final HashMap<Class<?>, MethodHandle> primitiveSubstitutable = new HashMap<>();\n+\n+        static {\n+            try {\n+                MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+                @SuppressWarnings(\"removal\")\n+                ClassLoader loader = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n+                    @Override public ClassLoader run() { return ClassLoader.getPlatformClassLoader(); }\n+                });\n+\n+                primitiveSubstitutable.putAll(primitiveEquals); \/\/ adopt all the primitive eq methods\n+                primitiveSubstitutable.put(float.class, lookup.findStatic(MethodHandleBuilder.class, \"eqValue\",\n+                        MethodType.fromMethodDescriptorString(\"(FF)Z\", loader)));\n+                primitiveSubstitutable.put(double.class, lookup.findStatic(MethodHandleBuilder.class, \"eqValue\",\n+                        MethodType.fromMethodDescriptorString(\"(DD)Z\", loader)));\n+\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n@@ -111,2 +135,2 @@\n-        static MethodHandle builtinPrimitiveEquals(Class<?> type) {\n-            return primitiveEquals.get(type);\n+        static MethodHandle builtinPrimitiveSubstitutable(Class<?> type) {\n+            return primitiveSubstitutable.get(type);\n@@ -312,0 +336,8 @@\n+        \/\/ Substitutability test for float\n+        private static boolean eqValue(float a, float b) {\n+            return Float.floatToRawIntBits(a) == Float.floatToRawIntBits(b);\n+        }\n+        \/\/ Substitutability test for double\n+        private static boolean eqValue(double a, double b) {\n+            return Double.doubleToRawLongBits(a) == Double.doubleToRawLongBits(b);\n+        }\n@@ -1057,7 +1089,3 @@\n-     *     <li> If {@code a} and {@code b} both represent {@code NaN},\n-     *          this method returns {@code true}, even though {@code NaN == NaN}\n-     *          has the value {@code false}.\n-     *     <li> If {@code a} is floating point positive zero while {@code b} is\n-     *          floating point negative zero, or vice versa, this method\n-     *          returns {@code false}, even though {@code +0.0 == -0.0} has\n-     *          the value {@code true}.\n+     *     <li> For primitive types {@code float} and {@code double} the\n+     *          comparison uses the raw bits corresponding to {@link Float#floatToRawIntBits(float)}\n+     *          and {@link Double#doubleToRawLongBits(double)} respectively.\n@@ -1107,2 +1135,2 @@\n-     * @see Float#equals(Object)\n-     * @see Double#equals(Object)\n+     * @see Float#floatToRawIntBits(float)\n+     * @see Double#doubleToRawLongBits(double)\n@@ -1145,2 +1173,2 @@\n-     *     returns a method handle representing {@link Float#equals(Object)} or\n-     *     {@link Double#equals(Object)} respectively.\n+     *     returns a method handle representing {@link Float#floatToRawIntBits(float)} or\n+     *     {@link Double#doubleToRawLongBits(double)} respectively.\n@@ -1167,1 +1195,1 @@\n-            return MethodHandleBuilder.builtinPrimitiveEquals(type);\n+            return MethodHandleBuilder.builtinPrimitiveSubstitutable(type);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ValueObjectMethods.java","additions":42,"deletions":14,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,0 +94,26 @@\n+    @ImplicitlyConstructible\n+    static value class MyFloat {\n+        public static float NaN1 = Float.intBitsToFloat(0x7ff00001);\n+        public static float NaN2 = Float.intBitsToFloat(0x7ff00002);\n+        float x;\n+        MyFloat(float x) {\n+            this.x = x;\n+        }\n+        public String toString() {\n+            return Float.toString(x);\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class MyDouble {\n+        public static double NaN1 = Double.longBitsToDouble(0x7ff0000000000001L);\n+        public static double NaN2 = Double.longBitsToDouble(0x7ff0000000000002L);\n+        double x;\n+        MyDouble(double x) {\n+            this.x = x;\n+        }\n+        public String toString() {\n+            return Double.toString(x);\n+        }\n+    }\n+\n@@ -104,0 +130,4 @@\n+                Arguments.of(new MyFloat(1.0f), new MyFloat(1.0f)),\n+                Arguments.of(new MyDouble(1.0), new MyDouble(1.0)),\n+                Arguments.of(new MyFloat(Float.NaN), new MyFloat(Float.NaN)),\n+                Arguments.of(new MyDouble(Double.NaN), new MyDouble(Double.NaN)),\n@@ -124,0 +154,4 @@\n+                Arguments.of(new MyFloat(1.0f), new MyFloat(2.0f)),\n+                Arguments.of(new MyDouble(1.0), new MyDouble(2.0)),\n+                Arguments.of(new MyFloat(MyFloat.NaN1), new MyFloat(MyFloat.NaN2)),\n+                Arguments.of(new MyDouble(MyDouble.NaN1), new MyDouble(MyDouble.NaN2)),\n","filename":"test\/jdk\/valhalla\/valuetypes\/SubstitutabilityTest.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"}]}