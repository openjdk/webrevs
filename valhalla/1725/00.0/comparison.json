{"files":[{"patch":"@@ -55,1 +55,0 @@\n-define_pd_global(uint64_t, MaxRAM,                    1ULL*G);\n","filename":"src\/hotspot\/cpu\/x86\/c1_globals_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -560,16 +560,0 @@\n-\/\/ Support for intptr_t get_previous_sp()\n-\/\/\n-\/\/ This routine is used to find the previous stack pointer for the\n-\/\/ caller.\n-address StubGenerator::generate_get_previous_sp() {\n-  StubId stub_id = StubId::stubgen_get_previous_sp_id;\n-  StubCodeMark mark(this, stub_id);\n-  address start = __ pc();\n-\n-  __ movptr(rax, rsp);\n-  __ addptr(rax, 8); \/\/ return address is at the top of the stack.\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n@@ -4169,2 +4153,0 @@\n-  StubRoutines::x86::_get_previous_sp_entry = generate_get_previous_sp();\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -71,6 +71,0 @@\n-  \/\/ Support for intptr_t get_previous_sp()\n-  \/\/\n-  \/\/ This routine is used to find the previous stack pointer for the\n-  \/\/ caller.\n-  address generate_get_previous_sp();\n-\n@@ -396,0 +390,2 @@\n+  void check_key_offset(Register key, int offset, int load_size);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    NOT_IA32( ShouldNotReachHere(); ) \/\/ used only on x86-32\n+    ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -537,10 +537,0 @@\n-#ifdef IA32\n-    case lir_fxch:\n-      fxch(op->in_opr()->as_jint());\n-      break;\n-\n-    case lir_fld:\n-      fld(op->in_opr()->as_jint());\n-      break;\n-#endif \/\/ IA32\n-\n@@ -743,6 +733,0 @@\n-#ifdef IA32\n-    case lir_fpop_raw:\n-      fpop();\n-      break;\n-#endif \/\/ IA32\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -185,1 +185,0 @@\n-    header_version[JVM_IDENT_MAX-1] = 0;  \/\/ Null terminate.\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -484,2 +484,2 @@\n-  \/* support for com.sun.crypto.provider.AESCrypt and some of its callers *\/                                            \\\n-  do_class(com_sun_crypto_provider_aescrypt,      \"com\/sun\/crypto\/provider\/AESCrypt\")                                   \\\n+  \/* support for com.sun.crypto.provider.AES_Crypt and some of its callers *\/                                            \\\n+  do_class(com_sun_crypto_provider_aescrypt,      \"com\/sun\/crypto\/provider\/AES_Crypt\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -947,0 +947,1 @@\n+      nm->print_code_snippet(st, addr);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2660,1 +2660,1 @@\n-  if (!MethodFlushing || is_native_method() || is_not_installed()) {\n+  if (!MethodFlushing || is_not_installed()) {\n@@ -4372,0 +4372,40 @@\n+void nmethod::print_code_snippet(outputStream* st, address addr) const {\n+  if (entry_point() <= addr && addr < code_end()) {\n+    \/\/ Pointing into the nmethod's code. Try to disassemble some instructions around addr.\n+    \/\/ Determine conservative start and end points.\n+    address start;\n+    if (frame_complete_offset() != CodeOffsets::frame_never_safe &&\n+        addr >= code_begin() + frame_complete_offset()) {\n+      start = code_begin() + frame_complete_offset();\n+    } else {\n+      start = (addr < verified_entry_point()) ? entry_point() : verified_entry_point();\n+    }\n+    address start_for_hex_dump = start; \/\/ We can choose a different starting point for hex dump, below.\n+    address end = code_end();\n+\n+    \/\/ Try using relocations to find closer instruction start and end points.\n+    \/\/ (Some platforms have variable length instructions and can only\n+    \/\/ disassemble correctly at instruction start addresses.)\n+    RelocIterator iter((nmethod*)this, start);\n+    while (iter.next() && iter.addr() < addr) { \/\/ find relocation before addr\n+      \/\/ Note: There's a relocation which doesn't point to an instruction start:\n+      \/\/ ZBarrierRelocationFormatStoreGoodAfterMov with ZGC on x86_64\n+      \/\/ We could detect and skip it, but hex dump is still usable when\n+      \/\/ disassembler produces garbage in such a very rare case.\n+      start = iter.addr();\n+      \/\/ We want at least 64 Bytes ahead in hex dump.\n+      if (iter.addr() <= (addr - 64)) start_for_hex_dump = iter.addr();\n+    }\n+    if (iter.has_current()) {\n+      if (iter.addr() == addr) iter.next(); \/\/ find relocation after addr\n+      if (iter.has_current()) end = iter.addr();\n+    }\n+\n+    \/\/ Always print hex. Disassembler may still have problems when hitting an incorrect instruction start.\n+    os::print_hex_dump(st, start_for_hex_dump, end, 1, \/* print_ascii=*\/false);\n+    if (!Disassembler::is_abstract()) {\n+      Disassembler::decode(start, end, st);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1029,0 +1029,1 @@\n+  void print_code_snippet(outputStream* st, address addr) const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,4 +59,0 @@\n-inline void ParCompactionManager::push(oop obj) {\n-  marking_stack()->push(ScannerTask(obj));\n-}\n-\n@@ -77,17 +73,8 @@\n-  if (!CompressedOops::is_null(heap_oop)) {\n-    oop obj = CompressedOops::decode_not_null(heap_oop);\n-    assert(ParallelScavengeHeap::heap()->is_in(obj), \"should be in heap\");\n-\n-    if (mark_bitmap()->mark_obj(obj)) {\n-      if (StringDedup::is_enabled() &&\n-          java_lang_String::is_instance(obj) &&\n-          psStringDedup::is_candidate_from_mark(obj)) {\n-        _string_dedup_requests.add(obj);\n-      }\n-\n-      ContinuationGCSupport::transform_stack_chunk(obj);\n-\n-      assert(_marking_stats_cache != nullptr, \"inv\");\n-      _marking_stats_cache->push(obj, obj->size());\n-      push(obj);\n-    }\n+  if (CompressedOops::is_null(heap_oop)) {\n+    return;\n+  }\n+\n+  oop obj = CompressedOops::decode_not_null(heap_oop);\n+  if (!mark_bitmap()->mark_obj(obj)) {\n+    \/\/ Marked by another worker.\n+    return;\n@@ -95,0 +82,11 @@\n+\n+  if (StringDedup::is_enabled() &&\n+      java_lang_String::is_instance(obj) &&\n+      psStringDedup::is_candidate_from_mark(obj)) {\n+    _string_dedup_requests.add(obj);\n+  }\n+\n+  ContinuationGCSupport::transform_stack_chunk(obj);\n+\n+  _marking_stats_cache->push(obj, obj->size());\n+  marking_stack()->push(ScannerTask(obj));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -861,2 +861,2 @@\n-  phase->lazy_replace(outer, new_outer);\n-  phase->lazy_replace(le, new_le);\n+  phase->replace_node_and_forward_ctrl(outer, new_outer);\n+  phase->replace_node_and_forward_ctrl(le, new_le);\n@@ -1325,1 +1325,1 @@\n-      phase->lazy_replace(head, new_head);\n+      phase->replace_node_and_forward_ctrl(head, new_head);\n@@ -1778,1 +1778,1 @@\n-            _phase->lazy_replace(u, n);\n+            _phase->igvn().replace_node(u, n);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-#if !defined(ZERO) && (defined(IA32) || defined(AMD64))\n+#if !defined(ZERO) && defined(AMD64)\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1022,0 +1022,1 @@\n+      case Bytecodes::_invokestatic:    LinkResolver::cds_resolve_static_call   (call_info, link_info, CHECK); break;\n@@ -1574,1 +1575,1 @@\n-#if defined(IA32) || defined(AMD64) || defined(ARM)\n+#if defined(AMD64) || defined(ARM)\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -159,2 +159,2 @@\n-#if defined(IA32) || defined(AMD64) || defined(ARM)\n-  \/\/ Popframe support (only needed on x86, AMD64 and ARM)\n+#if defined(AMD64) || defined(ARM)\n+  \/\/ Popframe support (only needed on AMD64 and ARM)\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1130,0 +1130,4 @@\n+void LinkResolver::cds_resolve_static_call(CallInfo& result, const LinkInfo& link_info, TRAPS) {\n+  resolve_static_call(result, link_info, \/*initialize_class*\/false, CHECK);\n+}\n+\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+  static void cds_resolve_static_call(CallInfo& result, const LinkInfo& link_info, TRAPS);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  LOG_TAG(asan) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -178,1 +178,2 @@\n-             method->method_holder()->is_reentrant_initialization(JavaThread::current()),\n+             method->method_holder()->is_reentrant_initialization(JavaThread::current()) ||\n+             (CDSConfig::is_dumping_archive() && VM_Version::supports_fast_class_init_checks()),\n@@ -432,2 +433,7 @@\n-    bool resolved = rfi->is_resolved(Bytecodes::_getfield)  ||\n-                    rfi->is_resolved(Bytecodes::_putfield);\n+    bool resolved = false;\n+\n+    if (rfi->is_resolved(Bytecodes::_getfield) || rfi->is_resolved(Bytecodes::_putfield) ||\n+        ((rfi->is_resolved(Bytecodes::_getstatic) || rfi->is_resolved(Bytecodes::_putstatic)) && VM_Version::supports_fast_class_init_checks())) {\n+      resolved = true;\n+    }\n+\n@@ -448,1 +454,1 @@\n-      log.print(\"%s field  CP entry [%3d]: %s => %s.%s:%s\",\n+      log.print(\"%s field  CP entry [%3d]: %s => %s.%s:%s%s\",\n@@ -452,1 +458,2 @@\n-                klass_name->as_C_string(), name->as_C_string(), signature->as_C_string());\n+                klass_name->as_C_string(), name->as_C_string(), signature->as_C_string(),\n+                rfi->is_resolved(Bytecodes::_getstatic) || rfi->is_resolved(Bytecodes::_putstatic) ? \" *** static\" : \"\");\n@@ -468,4 +475,2 @@\n-                    rme->is_resolved(Bytecodes::_invokehandle);\n-\n-    \/\/ Just for safety -- this should not happen, but do not archive if we ever see this.\n-    resolved &= !(rme->is_resolved(Bytecodes::_invokestatic));\n+                    rme->is_resolved(Bytecodes::_invokehandle)    ||\n+                    (rme->is_resolved(Bytecodes::_invokestatic) && VM_Version::supports_fast_class_init_checks());\n@@ -499,1 +504,1 @@\n-      ArchiveBuilder::alloc_stats()->record_method_cp_entry(archived, resolved && !archived);\n+    ArchiveBuilder::alloc_stats()->record_method_cp_entry(archived, resolved && !archived);\n@@ -538,0 +543,1 @@\n+  LogStreamHandle(Trace, aot, resolve) log;\n@@ -558,0 +564,6 @@\n+    if (method_entry->is_resolved(Bytecodes::_invokehandle) && !CDSConfig::is_dumping_method_handles()) {\n+      return false;\n+    }\n+    if (method_entry->method()->is_method_handle_intrinsic() && !CDSConfig::is_dumping_method_handles()) {\n+      return false;\n+    }\n@@ -566,15 +578,1 @@\n-\n-  if (method_entry->is_resolved(Bytecodes::_invokeinterface) ||\n-      method_entry->is_resolved(Bytecodes::_invokevirtual) ||\n-      method_entry->is_resolved(Bytecodes::_invokespecial)) {\n-    return true;\n-  } else if (method_entry->is_resolved(Bytecodes::_invokehandle)) {\n-    if (CDSConfig::is_dumping_method_handles()) {\n-      \/\/ invokehandle depends on archived MethodType and LambdaForms.\n-      return true;\n-    } else {\n-      return false;\n-    }\n-  } else {\n-    return false;\n-  }\n+  return true;\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -223,0 +223,9 @@\n+  const TypeInstPtr* dest_type = phase->type(base_dest)->is_instptr();\n+  if (dest_type->instance_klass() != ik) {\n+    \/\/ At parse time, the exact type of the object to clone was not known. That inexact type was captured by the CheckCastPP\n+    \/\/ of the newly allocated cloned object (in dest). The exact type is now known (in src), but the type for the cloned object\n+    \/\/ (dest) was not updated. When copying the fields below, Store nodes may write to offsets for fields that don't exist in\n+    \/\/ the inexact class. The stores would then be assigned an incorrect slice.\n+    return NodeSentinel;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -978,1 +978,0 @@\n-          \/\/ IA32     2     1     1          1    1          6           6\n@@ -994,6 +993,0 @@\n-#elif defined(IA32)\n-          if( ireg == Op_RegL ) {\n-            lrg.set_reg_pressure(2);\n-          } else {\n-            lrg.set_reg_pressure(1);\n-          }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -941,3 +941,0 @@\n-  \/\/ IA32 would only execute this for non-strict FP, which is never the\n-  \/\/ case now.\n-#if ! defined(IA32)\n@@ -949,1 +946,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -166,0 +166,2 @@\n+  const bool check_access = !orig_callee->is_method_handle_intrinsic(); \/\/ method handle intrinsics don't perform access checks\n+\n@@ -317,1 +319,2 @@\n-                                                   speculative_receiver_type);\n+                                                   speculative_receiver_type,\n+                                                   check_access);\n@@ -334,0 +337,1 @@\n+        assert(check_access, \"required\");\n@@ -335,1 +339,1 @@\n-                                                      profile.receiver(0));\n+                                                 profile.receiver(0));\n@@ -346,0 +350,1 @@\n+            assert(check_access, \"required\");\n@@ -347,1 +352,1 @@\n-                                                               profile.receiver(1));\n+                                                          profile.receiver(1));\n@@ -420,0 +425,1 @@\n+        assert(check_access, \"required\");\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7963,1 +7963,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n@@ -8049,1 +8049,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n@@ -8119,1 +8119,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n@@ -8159,1 +8159,1 @@\n-  assert (objSessionK != nullptr, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n+  assert (objSessionK != nullptr, \"wrong version of com.sun.crypto.provider.AES_Crypt\");\n@@ -8167,1 +8167,1 @@\n-  assert (objAESCryptKey != nullptr, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n+  assert (objAESCryptKey != nullptr, \"wrong version of com.sun.crypto.provider.AES_Crypt\");\n@@ -8202,1 +8202,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n@@ -8265,1 +8265,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n@@ -8325,1 +8325,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n@@ -9298,1 +9298,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n@@ -9352,1 +9352,1 @@\n-  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AES_Crypt\"));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -704,1 +704,1 @@\n-  \/\/ Hook region into slow_path, in stead of the multiversion_slow_proj.\n+  \/\/ Hook region into slow_path, instead of the multiversion_slow_proj.\n@@ -706,3 +706,4 @@\n-  \/\/ The lazy_replace ensures that any get_ctrl that used to have multiversion_slow_proj\n-  \/\/ as their control are forwarded to the new region node as their control.\n-  lazy_replace(multiversion_slow_proj, region);\n+  \/\/ The replace_node_and_forward_ctrl ensures that any get_ctrl that used to have\n+  \/\/ multiversion_slow_proj as their control are forwarded to the new region node as\n+  \/\/ their control.\n+  replace_node_and_forward_ctrl(multiversion_slow_proj, region);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -897,0 +897,3 @@\n+  \/\/\n+  \/\/ Exception: dead CFG nodes may instead have a ctrl\/idom forwarding\n+  \/\/            installed. See: forward_ctrl\n@@ -963,1 +966,7 @@\n-  \/\/ Returns true if \"n\" is a data node, false if it's a control node.\n+  \/\/ Returns true if \"n\" is a data node, false if it's a CFG node.\n+  \/\/\n+  \/\/ Exception:\n+  \/\/ control nodes that are dead because of \"replace_node_and_forward_ctrl\"\n+  \/\/ or have otherwise modified their ctrl state by \"forward_ctrl\".\n+  \/\/ They return \"true\", because they have a ctrl \"forwarding\" to the other ctrl node they\n+  \/\/ were replaced with.\n@@ -1077,5 +1086,2 @@\n-  \/\/ Control nodes can be replaced or subsumed.  During this pass they\n-  \/\/ get their replacement Node in slot 1.  Instead of updating the block\n-  \/\/ location of all Nodes in the subsumed block, we lazily do it.  As we\n-  \/\/ pull such a subsumed block out of the array, we write back the final\n-  \/\/ correct block.\n+\n+  \/\/ Retrieves the ctrl for a data node i.\n@@ -1083,2 +1089,6 @@\n-    assert(has_node(i), \"\");\n-    Node *n = get_ctrl_no_update(i);\n+    assert(has_node(i) && has_ctrl(i), \"must be data node with ctrl\");\n+    Node* n = get_ctrl_no_update(i);\n+    \/\/ We store the found ctrl in the side-table again. In most cases,\n+    \/\/ this is a no-op, since we just read from _loop_or_ctrl. But in cases\n+    \/\/ where there was a ctrl forwarding via dead ctrl nodes, this shortens the path.\n+    \/\/ See: forward_ctrl\n@@ -1086,2 +1096,2 @@\n-    assert(has_node(i) && has_ctrl(i), \"\");\n-    assert(n == find_non_split_ctrl(n), \"must return legal ctrl\" );\n+    assert(has_node(i) && has_ctrl(i), \"must still be data node with ctrl\");\n+    assert(n == find_non_split_ctrl(n), \"must return legal ctrl\");\n@@ -1104,0 +1114,1 @@\n+private:\n@@ -1105,1 +1116,4 @@\n-    assert(has_ctrl(i), \"should be control, not loop\");\n+    \/\/ We expect only data nodes (which must have a ctrl set), or\n+    \/\/ dead ctrl nodes that have a ctrl \"forwarding\".\n+    \/\/ See: forward_ctrl.\n+    assert(has_ctrl(i), \"only data nodes or ctrl nodes with ctrl forwarding expected\");\n@@ -1109,0 +1123,1 @@\n+  \/\/ Compute the ctrl of node i, jumping over ctrl forwardings.\n@@ -1110,4 +1125,8 @@\n-    assert( has_ctrl(i), \"\" );\n-    Node *n = get_ctrl_no_update_helper(i);\n-    if (!n->in(0)) {\n-      \/\/ Skip dead CFG nodes\n+    assert(has_ctrl(i), \"only data nodes expected\");\n+    Node* n = get_ctrl_no_update_helper(i);\n+    if (n->in(0) == nullptr) {\n+      \/\/ We encountered a dead CFG node.\n+      \/\/ If everything went right, this dead CFG node should have had a ctrl\n+      \/\/ forwarding installed, using \"forward_ctrl\". We now have to jump from\n+      \/\/ the old (dead) ctrl node to the new (live) ctrl node, in possibly\n+      \/\/ multiple ctrl forwarding steps.\n@@ -1116,1 +1135,1 @@\n-      } while (!n->in(0));\n+      } while (n->in(0) == nullptr);\n@@ -1122,0 +1141,1 @@\n+public:\n@@ -1132,5 +1152,24 @@\n-  \/\/ Lazy-dazy update of 'get_ctrl' and 'idom_at' mechanisms.  Replace\n-  \/\/ the 'old_node' with 'new_node'.  Kill old-node.  Add a reference\n-  \/\/ from old_node to new_node to support the lazy update.  Reference\n-  \/\/ replaces loop reference, since that is not needed for dead node.\n-  void lazy_update(Node *old_node, Node *new_node) {\n+\n+  \/\/ Install a ctrl \"forwarding\" from an old (dead) control node.\n+  \/\/ This is a \"lazy\" update of the \"get_ctrl\" and \"idom\" mechanism:\n+  \/\/ - Install a forwarding from old_node (dead ctrl) to new_node.\n+  \/\/ - When querying \"get_ctrl\": jump from data node over possibly\n+  \/\/   multiple dead ctrl nodes with ctrl forwarding to eventually\n+  \/\/   reach a live ctrl node. Shorten the path to avoid chasing the\n+  \/\/   forwarding in the future.\n+  \/\/ - When querying \"idom\": from some node get its old idom, which\n+  \/\/   may be dead but has an idom forwarding to the new and live\n+  \/\/   idom. Shorten the path to avoid chasing the forwarding in the\n+  \/\/   future.\n+  \/\/   Note: while the \"idom\" information is stored in the \"_idom\"\n+  \/\/   side-table, the idom forwarding piggybacks on the ctrl\n+  \/\/   forwarding on \"_loop_or_ctrl\".\n+  \/\/ Using \"forward_ctrl\" allows us to only edit the entry for the old\n+  \/\/ dead node now, and we do not have to update all the nodes that had\n+  \/\/ the old_node as their \"get_ctrl\" or \"idom\". We clean up the forwarding\n+  \/\/ links when we query \"get_ctrl\" or \"idom\" for these nodes the next time.\n+  void forward_ctrl(Node* old_node, Node* new_node) {\n+    assert(!has_ctrl(old_node) && old_node->is_CFG() && old_node->in(0) == nullptr,\n+           \"must be dead ctrl (CFG) node\");\n+    assert(!has_ctrl(new_node) && new_node->is_CFG() && new_node->in(0) != nullptr,\n+           \"must be live ctrl (CFG) node\");\n@@ -1141,0 +1180,1 @@\n+    assert(has_ctrl(old_node), \"must have installed ctrl forwarding\");\n@@ -1142,1 +1182,5 @@\n-  void lazy_replace(Node *old_node, Node *new_node) {\n+\n+  \/\/ Replace the old ctrl node with a new ctrl node.\n+  \/\/ - Update the node inputs of all uses.\n+  \/\/ - Lazily update the ctrl and idom info of all uses, via a ctrl\/idom forwarding.\n+  void replace_node_and_forward_ctrl(Node* old_node, Node* new_node) {\n@@ -1144,1 +1188,1 @@\n-    lazy_update(old_node, new_node);\n+    forward_ctrl(old_node, new_node);\n@@ -1215,1 +1259,0 @@\n-public:\n@@ -1220,3 +1263,3 @@\n-  Node* idom_no_update(uint didx) const {\n-    assert(didx < _idom_size, \"oob\");\n-    Node* n = _idom[didx];\n+  Node* idom_no_update(uint node_idx) const {\n+    assert(node_idx < _idom_size, \"oob\");\n+    Node* n = _idom[node_idx];\n@@ -1225,0 +1268,8 @@\n+      \/\/ We encountered a dead CFG node.\n+      \/\/ If everything went right, this dead CFG node should have had an idom\n+      \/\/ forwarding installed, using \"forward_ctrl\". We now have to jump from\n+      \/\/ the old (dead) idom node to the new (live) idom node, in possibly\n+      \/\/ multiple idom forwarding steps.\n+      \/\/ Note that we piggyback on \"_loop_or_ctrl\" to do the forwarding,\n+      \/\/ since we forward both \"get_ctrl\" and \"idom\" from the dead to the\n+      \/\/ new live ctrl\/idom nodes.\n@@ -1231,2 +1282,3 @@\n-  Node *idom(Node* d) const {\n-    return idom(d->_idx);\n+public:\n+  Node* idom(Node* n) const {\n+    return idom(n->_idx);\n@@ -1235,3 +1287,7 @@\n-  Node *idom(uint didx) const {\n-    Node *n = idom_no_update(didx);\n-    _idom[didx] = n; \/\/ Lazily remove dead CFG nodes from table.\n+  Node* idom(uint node_idx) const {\n+    Node* n = idom_no_update(node_idx);\n+    \/\/ We store the found idom in the side-table again. In most cases,\n+    \/\/ this is a no-op, since we just read from _idom. But in cases where\n+    \/\/ there was an idom forwarding via dead idom nodes, this shortens the path.\n+    \/\/ See: forward_ctrl\n+    _idom[node_idx] = n;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":88,"deletions":32,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2925,1 +2925,1 @@\n-        \/\/ lazy_replace() below moves all nodes that are:\n+        \/\/ replace_node_and_forward_ctrl() below moves all nodes that are:\n@@ -2928,3 +2928,4 @@\n-        \/\/ below the post-loop merge point. lazy_replace() takes a dead control as first input. To make it\n-        \/\/ possible to use it, the loop exit projection is cloned and becomes the new exit projection. The initial one\n-        \/\/ becomes dead and is \"replaced\" by the region.\n+        \/\/ below the post-loop merge point.\n+        \/\/ replace_node_and_forward_ctrl() takes a dead control as first input.\n+        \/\/ To make it possible to use it, the loop exit projection is cloned and becomes the\n+        \/\/ new exit projection. The initial one becomes dead and is \"replaced\" by the region.\n@@ -2939,1 +2940,1 @@\n-        lazy_replace(use, r);\n+        replace_node_and_forward_ctrl(use, r);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-#if defined(IA32) || defined(AMD64)\n+#if defined(AMD64)\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -217,8 +217,0 @@\n-#if defined(IA32)\n-  \/\/ Can't trust native compilers to properly fold strict double\n-  \/\/ multiplication with round-to-zero on this platform.\n-  if (op == Op_MulD) {\n-    return TypeD::DOUBLE;\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3578,1 +3578,1 @@\n-    jio_snprintf(buffer, sizeof(buffer), \"Bytecode %d: %s, map: %d\", bci(), Bytecodes::name(bc()), map() == nullptr ? -1 : map()->_idx);\n+    jio_snprintf(buffer, sizeof(buffer), \"Bytecode %d: %s\", bci(), Bytecodes::name(bc()));\n@@ -3581,0 +3581,1 @@\n+    printer->set_parse(this);\n@@ -3583,0 +3584,1 @@\n+    printer->set_parse(nullptr);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -913,2 +913,3 @@\n-  fields = TypeTuple::fields(0);\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms] = TypeInstPtr::BOTTOM;\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,0 +51,6 @@\n+\/\/\n+\/\/ Please ensure the return type of the runtime call matches its signature,\n+\/\/ even if the return value is unused. This is crucial for correct handling\n+\/\/ of runtime calls that return an oop and may trigger deoptimization\n+\/\/ on return. See rematerialize_objects() in deoptimization.cpp.\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -658,1 +658,1 @@\n-    lazy_replace(ifp, ifpx);\n+    replace_node_and_forward_ctrl(ifp, ifpx);\n@@ -672,3 +672,4 @@\n-  lazy_replace(iff, region_dom);\n-  lazy_update(region, region_dom); \/\/ idom must be update before handle_uses\n-  region->set_req(0, nullptr);        \/\/ Break the self-cycle. Required for lazy_update to work on region\n+  replace_node_and_forward_ctrl(iff, region_dom);\n+  \/\/ Break the self-cycle. Required for forward_ctrl to work on region.\n+  region->set_req(0, nullptr);\n+  forward_ctrl(region, region_dom); \/\/ idom must be updated before handle_use\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -356,0 +356,1 @@\n+  static mask unsigned_mask(mask btm) { return mask(btm | unsigned_compare); }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1004,7 +1004,5 @@\n-  Klass* from_class = (from_class_oop == nullptr)\n-                           ? (Klass*)nullptr\n-                           : java_lang_Class::as_Klass(from_class_oop);\n-  oop class_loader = nullptr;\n-  if (from_class != nullptr) {\n-    class_loader = from_class->class_loader();\n-  }\n+  assert(from_class_oop != nullptr, \"must be\");\n+  Klass* from_class = java_lang_Class::as_Klass(from_class_oop);\n+  assert(from_class != nullptr, \"must be\");\n+  oop class_loader = from_class->class_loader();\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -516,0 +516,8 @@\n+WB_ENTRY(jboolean, WB_HasExternalSymbolsStripped(JNIEnv* env, jobject o))\n+#if defined(HAS_STRIPPED_DEBUGINFO)\n+  return true;\n+#else\n+  return false;\n+#endif\n+WB_END\n+\n@@ -2923,0 +2931,1 @@\n+  {CC\"hasExternalSymbolsStripped\",       CC\"()Z\",                   (void*)&WB_HasExternalSymbolsStripped},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -552,0 +552,1 @@\n+  { \"MaxRAM\",                       JDK_Version::jdk(26),  JDK_Version::jdk(27), JDK_Version::jdk(28) },\n@@ -561,2 +562,0 @@\n-  { \"ZGenerational\",                JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::undefined() },\n-  { \"ZMarkStackSpaceLimit\",         JDK_Version::undefined(), JDK_Version::jdk(25), JDK_Version::undefined() },\n@@ -1529,2 +1528,0 @@\n-  uint64_t physical_memory;\n-\n@@ -1537,5 +1534,4 @@\n-  if (has_ram_limit) {\n-    if (!FLAG_IS_DEFAULT(MaxRAM)) {\n-      \/\/ The user has configured MaxRAM, use that instead of physical memory\n-      \/\/ reported by the OS.\n-      physical_memory = MaxRAM;\n+  if (FLAG_IS_DEFAULT(MaxRAM)) {\n+    if (CompilerConfig::should_set_client_emulation_mode_flags()) {\n+      \/\/ Limit the available memory if client emulation mode is enabled.\n+      FLAG_SET_ERGO(MaxRAM, 1ULL*G);\n@@ -1543,4 +1539,2 @@\n-      \/\/ The user has configured a limit, make sure MaxRAM reflects the physical\n-      \/\/ memory limit that heap sizing takes into account.\n-      physical_memory = os::physical_memory();\n-      FLAG_SET_ERGO(MaxRAM, physical_memory);\n+      \/\/ Use the available physical memory on the system.\n+      FLAG_SET_ERGO(MaxRAM, os::physical_memory());\n@@ -1548,5 +1542,0 @@\n-  } else {\n-    \/\/ If the user did not specify any limit, choose the lowest of the available\n-    \/\/ physical memory and MaxRAM. MaxRAM is typically set to 128GB on 64-bit\n-    \/\/ architecture.\n-    physical_memory = MIN2(os::physical_memory(), MaxRAM);\n@@ -1559,2 +1548,2 @@\n-    uint64_t min_memory = (uint64_t)(((double)physical_memory * MinRAMPercentage) \/ 100);\n-    uint64_t max_memory = (uint64_t)(((double)physical_memory * MaxRAMPercentage) \/ 100);\n+    uint64_t min_memory = (uint64_t)(((double)MaxRAM * MinRAMPercentage) \/ 100);\n+    uint64_t max_memory = (uint64_t)(((double)MaxRAM * MaxRAMPercentage) \/ 100);\n@@ -1647,1 +1636,1 @@\n-      uint64_t initial_memory = (uint64_t)(((double)physical_memory * InitialRAMPercentage) \/ 100);\n+      uint64_t initial_memory = (uint64_t)(((double)MaxRAM * InitialRAMPercentage) \/ 100);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -505,1 +505,1 @@\n-          range(0, 17)                                                      \\\n+          range(0, 18)                                                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -557,1 +557,1 @@\n-        jio_snprintf(msg, len - 1,\n+        jio_snprintf(msg, len,\n@@ -568,1 +568,1 @@\n-        jio_snprintf(msg, len - 1,\n+        jio_snprintf(msg, len,\n@@ -584,1 +584,1 @@\n-        jio_snprintf(msg, len - 1,\n+        jio_snprintf(msg, len,\n@@ -595,1 +595,1 @@\n-        jio_snprintf(msg, len - 1,\n+        jio_snprintf(msg, len,\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+#include \"sanitizers\/address.hpp\"\n@@ -706,0 +707,4 @@\n+#ifdef ADDRESS_SANITIZER\n+  Asan::initialize();\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -36,0 +37,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -712,1 +714,1 @@\n-        if (!isFinite(d) )\n+        if (!isFinite(d)) {\n@@ -715,3 +717,11 @@\n-        else {\n-            \/\/ Initialized to maximum size of output.\n-            StringBuilder answer = new StringBuilder(24);\n+        }\n+\n+        long doubleToLongBits = Double.doubleToLongBits(d);\n+        boolean negative = doubleToLongBits < 0;\n+\n+        if (d == 0.0) {\n+            return negative ? \"-0x0.0p0\" : \"0x0.0p0\";\n+        }\n+        d = Math.abs(d);\n+        \/\/ Check if the value is subnormal (less than the smallest normal value)\n+        boolean subnormal = d < Double.MIN_NORMAL;\n@@ -719,2 +729,4 @@\n-            if (Math.copySign(1.0, d) == -1.0)    \/\/ value is negative,\n-                answer.append(\"-\");                  \/\/ so append sign info\n+        \/\/ Isolate significand bits and OR in a high-order bit\n+        \/\/ so that the string representation has a known length.\n+        \/\/ This ensures we always have 13 hex digits to work with (52 bits \/ 4 bits per hex digit)\n+        long signifBits = doubleToLongBits & DoubleConsts.SIGNIF_BIT_MASK;\n@@ -722,1 +734,5 @@\n-            answer.append(\"0x\");\n+        \/\/ Calculate the number of trailing zeros in the significand (in groups of 4 bits)\n+        \/\/ This is used to remove trailing zeros from the hex representation\n+        \/\/ We limit to 12 because we want to keep at least 1 hex digit (13 total - 12 = 1)\n+        \/\/ assert 0 <= trailingZeros && trailingZeros <= 12\n+        int trailingZeros = Long.numberOfTrailingZeros(signifBits | 1L << 4 * 12) >> 2;\n@@ -724,1 +740,3 @@\n-            d = Math.abs(d);\n+        \/\/ Determine the exponent value based on whether the number is subnormal or normal\n+        \/\/ Subnormal numbers use the minimum exponent, normal numbers use the actual exponent\n+        int exp = subnormal ? Double.MIN_EXPONENT : Math.getExponent(d);\n@@ -726,4 +744,8 @@\n-            if(d == 0.0) {\n-                answer.append(\"0.0p0\");\n-            } else {\n-                boolean subnormal = (d < Double.MIN_NORMAL);\n+        \/\/ Calculate the total length of the resulting string:\n+        \/\/ Sign (optional) + prefix \"0x\" + implicit bit + \".\" + hex digits + \"p\" + exponent\n+        int charlen = (negative ? 1 : 0) \/\/ sign character\n+                + 4 \/\/ \"0x1.\" or \"0x0.\"\n+                + 13 - trailingZeros \/\/ hex digits (13 max, minus trailing zeros)\n+                + 1 \/\/ \"p\"\n+                + DecimalDigits.stringSize(exp) \/\/ exponent\n+                ;\n@@ -731,6 +753,3 @@\n-                \/\/ Isolate significand bits and OR in a high-order bit\n-                \/\/ so that the string representation has a known\n-                \/\/ length.\n-                long signifBits = (Double.doubleToLongBits(d)\n-                                   & DoubleConsts.SIGNIF_BIT_MASK) |\n-                    0x1000000000000000L;\n+        \/\/ Create a byte array to hold the result characters\n+        byte[] chars = new byte[charlen];\n+        int index = 0;\n@@ -738,3 +757,4 @@\n-                \/\/ Subnormal values have a 0 implicit bit; normal\n-                \/\/ values have a 1 implicit bit.\n-                answer.append(subnormal ? \"0.\" : \"1.\");\n+        \/\/ Add the sign character if the number is negative\n+        if (negative) {  \/\/ value is negative\n+            chars[index++] = '-';\n+        }\n@@ -742,8 +762,7 @@\n-                \/\/ Isolate the low-order 13 digits of the hex\n-                \/\/ representation.  If all the digits are zero,\n-                \/\/ replace with a single 0; otherwise, remove all\n-                \/\/ trailing zeros.\n-                String signif = Long.toHexString(signifBits).substring(3,16);\n-                answer.append(signif.equals(\"0000000000000\") ? \/\/ 13 zeros\n-                              \"0\":\n-                              signif.replaceFirst(\"0{1,12}$\", \"\"));\n+        \/\/ Add the prefix and the implicit bit ('1' for normal, '0' for subnormal)\n+        \/\/ Subnormal values have a 0 implicit bit; normal values have a 1 implicit bit.\n+        chars[index    ] = '0';      \/\/ Hex prefix\n+        chars[index + 1] = 'x';  \/\/ Hex prefix\n+        chars[index + 2] = (byte) (subnormal ? '0' : '1');  \/\/ Implicit bit\n+        chars[index + 3] = '.';  \/\/ Decimal point\n+        index += 4;\n@@ -751,10 +770,8 @@\n-                answer.append('p');\n-                \/\/ If the value is subnormal, use the E_min exponent\n-                \/\/ value for double; otherwise, extract and report d's\n-                \/\/ exponent (the representation of a subnormal uses\n-                \/\/ E_min -1).\n-                answer.append(subnormal ?\n-                              Double.MIN_EXPONENT:\n-                              Math.getExponent(d));\n-            }\n-            return answer.toString();\n+        \/\/ Convert significand to hex digits manually to avoid creating temporary strings\n+        \/\/ Extract the 13 hex digits (52 bits) from signifBits\n+        \/\/ We need to extract bits 48-51, 44-47, ..., 0-3 (13 groups of 4 bits)\n+        for (int sh = 4 * 12, end = 4 * trailingZeros; sh >= end; sh -= 4) {\n+            \/\/ Extract 4 bits at a time from left to right\n+            \/\/ Shift right by sh positions and mask with 0xF\n+            \/\/ Integer.digits maps values 0-15 to '0'-'f' characters\n+            chars[index++] = Integer.digits[((int)(signifBits >> sh)) & 0xF];\n@@ -762,0 +779,9 @@\n+\n+        \/\/ Add the exponent indicator\n+        chars[index] = 'p';\n+\n+        \/\/ Append the exponent value to the character array\n+        \/\/ This method writes the decimal representation of exp directly into the byte array\n+        DecimalDigits.uncheckedGetCharsLatin1(exp, charlen, chars);\n+\n+        return String.newStringWithLatin1Bytes(chars);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":65,"deletions":39,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -377,9 +377,3 @@\n-        if (COMPACT_STRINGS) {\n-            byte[] buf = new byte[chars];\n-            formatUnsignedInt(val, shift, buf, chars);\n-            return new String(buf, LATIN1);\n-        } else {\n-            byte[] buf = new byte[chars * 2];\n-            formatUnsignedIntUTF16(val, shift, buf, chars);\n-            return new String(buf, UTF16);\n-        }\n+        byte[] buf = new byte[chars];\n+        formatUnsignedInt(val, shift, buf, chars);\n+        return String.newStringWithLatin1Bytes(buf);\n@@ -408,20 +402,0 @@\n-    \/**\n-     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n-     * {@code len} exceeds the formatted ASCII representation of {@code val},\n-     * {@code buf} will be padded with leading zeroes.\n-     *\n-     * @param val the unsigned int to format\n-     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n-     * @param buf the byte buffer to write to\n-     * @param len the number of characters to write\n-     *\/\n-    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n-        int charPos = len;\n-        int radix = 1 << shift;\n-        int mask = radix - 1;\n-        do {\n-            StringUTF16.putChar(buf, --charPos, Integer.digits[val & mask]);\n-            val >>>= shift;\n-        } while (charPos > 0);\n-    }\n-\n@@ -441,9 +415,3 @@\n-        if (COMPACT_STRINGS) {\n-            byte[] buf = new byte[size];\n-            DecimalDigits.uncheckedGetCharsLatin1(i, size, buf);\n-            return new String(buf, LATIN1);\n-        } else {\n-            byte[] buf = new byte[size * 2];\n-            DecimalDigits.uncheckedGetCharsUTF16(i, size, buf);\n-            return new String(buf, UTF16);\n-        }\n+        byte[] buf = new byte[size];\n+        DecimalDigits.uncheckedGetCharsLatin1(i, size, buf);\n+        return String.newStringWithLatin1Bytes(buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":6,"deletions":38,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -406,9 +406,3 @@\n-        if (COMPACT_STRINGS) {\n-            byte[] buf = new byte[chars];\n-            formatUnsignedLong0(val, shift, buf, 0, chars);\n-            return new String(buf, LATIN1);\n-        } else {\n-            byte[] buf = new byte[chars * 2];\n-            formatUnsignedLong0UTF16(val, shift, buf, 0, chars);\n-            return new String(buf, UTF16);\n-        }\n+        byte[] buf = new byte[chars];\n+        formatUnsignedLong0(val, shift, buf, 0, chars);\n+        return String.newStringWithLatin1Bytes(buf);\n@@ -438,21 +432,0 @@\n-    \/**\n-     * Format a long (treated as unsigned) into a byte buffer (UTF16 version). If\n-     * {@code len} exceeds the formatted ASCII representation of {@code val},\n-     * {@code buf} will be padded with leading zeroes.\n-     *\n-     * @param val the unsigned long to format\n-     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n-     * @param buf the byte buffer to write to\n-     * @param offset the offset in the destination buffer to start at\n-     * @param len the number of characters to write\n-     *\/\n-    private static void formatUnsignedLong0UTF16(long val, int shift, byte[] buf, int offset, int len) {\n-        int charPos = offset + len;\n-        int radix = 1 << shift;\n-        int mask = radix - 1;\n-        do {\n-            StringUTF16.putChar(buf, --charPos, Integer.digits[((int) val) & mask]);\n-            val >>>= shift;\n-        } while (charPos > offset);\n-    }\n-\n@@ -471,9 +444,3 @@\n-        if (COMPACT_STRINGS) {\n-            byte[] buf = new byte[size];\n-            DecimalDigits.uncheckedGetCharsLatin1(i, size, buf);\n-            return new String(buf, LATIN1);\n-        } else {\n-            byte[] buf = new byte[size * 2];\n-            DecimalDigits.uncheckedGetCharsUTF16(i, size, buf);\n-            return new String(buf, UTF16);\n-        }\n+        byte[] buf = new byte[size];\n+        DecimalDigits.uncheckedGetCharsLatin1(i, size, buf);\n+        return String.newStringWithLatin1Bytes(buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":6,"deletions":39,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -428,1 +428,1 @@\n-                \/\/ virtual thread's interrupt status needs to be cleared\n+                \/\/ virtual thread's interrupted status needs to be cleared\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.vm.annotation.AOTRuntimeSetup;\n@@ -1539,5 +1538,0 @@\n-        runtimeSetup();\n-    }\n-\n-    @AOTRuntimeSetup\n-    private static void runtimeSetup() {\n@@ -1566,1 +1560,0 @@\n-                assert memberName.isField();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.vm.annotation.AOTRuntimeSetup;\n@@ -304,5 +303,0 @@\n-        runtimeSetup();\n-    }\n-\n-    @AOTRuntimeSetup\n-    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -799,0 +799,26 @@\n+    \/**\n+     * Returns a copy of this instant with the specified duration added, with\n+     * saturated semantics.\n+     * <p>\n+     * If the result is \"earlier\" than {@link Instant#MIN}, this method returns\n+     * {@code MIN}. If the result is \"later\" than {@link Instant#MAX}, it\n+     * returns {@code MAX}. Otherwise it returns {@link #plus(TemporalAmount) plus(duration)}.\n+     *\n+     * @apiNote This method can be used to calculate a deadline from\n+     * this instant and a timeout. Unlike {@code plus(duration)},\n+     * this method never throws {@link ArithmeticException} or {@link DateTimeException}\n+     * due to numeric overflow or {@code Instant} range violation.\n+     *\n+     * @param duration the duration to add, not null\n+     * @return an {@code Instant} based on this instant with the addition made, not null\n+     *\n+     * @since 26\n+     *\/\n+    public Instant plusSaturating(Duration duration) {\n+        if (duration.isNegative()) {\n+            return until(Instant.MIN).compareTo(duration) >= 0 ? Instant.MIN : plus(duration);\n+        } else {\n+            return until(Instant.MAX).compareTo(duration) <= 0 ? Instant.MAX : plus(duration);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -337,0 +337,7 @@\n+            if (env.info.isAnonymousNewClass) {\n+                \/\/ Annotations on anonymous class instantiations should be attributed,\n+                \/\/ but not attached to the enclosing element. They will be visited\n+                \/\/ separately and attached to the synthetic class declaration.\n+                continue;\n+            }\n+\n@@ -1165,1 +1172,2 @@\n-            if (tree.def == null) {\n+            try {\n+                env.info.isAnonymousNewClass = tree.def != null;\n@@ -1167,0 +1175,2 @@\n+            } finally {\n+                env.info.isAnonymousNewClass = false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1175,1 +1175,1 @@\n-                    log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);\n+                    log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract(tree.sym, owner));\n@@ -3143,10 +3143,3 @@\n-        Type clazztype;\n-\n-        try {\n-            env.info.isAnonymousNewClass = tree.def != null;\n-            clazztype = TreeInfo.isEnumInit(env.tree) ?\n-                attribIdentAsEnumType(env, (JCIdent)clazz) :\n-                attribType(clazz, env);\n-        } finally {\n-            env.info.isAnonymousNewClass = false;\n-        }\n+        Type clazztype = TreeInfo.isEnumInit(env.tree) ?\n+            attribIdentAsEnumType(env, (JCIdent)clazz) :\n+            attribType(clazz, env);\n@@ -5623,2 +5616,1 @@\n-        if (!env.info.isAnonymousNewClass)\n-            annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);\n+        annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2176,1 +2176,1 @@\n-                      explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :\n+                      explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride(m, m.enclClass()) : Errors.MethodDoesNotOverrideSuperclass(m, m.enclClass())) :\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -908,0 +908,1 @@\n+# 0: symbol, 1: symbol\n@@ -909,1 +910,1 @@\n-    method does not override or implement a method from a supertype\n+    {0} in {1} does not override or implement a method from a supertype\n@@ -911,0 +912,1 @@\n+# 0: symbol, 1: symbol\n@@ -912,1 +914,1 @@\n-    static methods cannot be annotated with @Override\n+    static method {0} in {1} cannot be annotated with @Override\n@@ -914,0 +916,1 @@\n+# 0: symbol, 1: symbol\n@@ -915,1 +918,1 @@\n-    missing method body, or declare abstract\n+    method {0} in {1} is missing a method body, or should be declared abstract\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -85,10 +85,1 @@\n-compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#G1 8369147 generic-all\n-compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#Parallel 8369147 generic-all\n-compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#Serial 8369147 generic-all\n-compiler\/whitebox\/DeoptimizeRelocatedNMethod.java#ZGC 8369147 generic-all\n-compiler\/whitebox\/RelocateNMethod.java#G1 8369147 generic-all\n-compiler\/whitebox\/RelocateNMethod.java#Parallel 8369147 generic-all\n-compiler\/whitebox\/RelocateNMethod.java#Serial 8369147 generic-all\n-compiler\/whitebox\/RelocateNMethod.java#ZGC 8369147 generic-all\n-compiler\/whitebox\/StressNMethodRelocation.java 8369147,8369148,8369149 generic-all\n-serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java 8369150,8369151 generic-all\n+serviceability\/jvmti\/NMethodRelocation\/NMethodRelocationTest.java 8369150 generic-all\n@@ -100,0 +91,3 @@\n+compiler\/whitebox\/DeoptimizeRelocatedNMethod.java 8370571 generic-all\n+compiler\/whitebox\/RelocateNMethodMultiplePaths.java#C1 8370571 generic-all\n+compiler\/whitebox\/RelocateNMethodMultiplePaths.java#C2 8370571 generic-all\n@@ -108,0 +102,1 @@\n+compiler\/whitebox\/StressNMethodRelocation.java 8370571 generic-all\n@@ -167,0 +162,2 @@\n+runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java#aot                 8371456 generic-all\n+runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java#static              8371456 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -586,0 +586,1 @@\n+ -runtime\/cds\/appcds\/SignedJar.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,1 +145,5 @@\n-                if (output.contains(\"CompressedClassSpaceBaseAddress=\" + thisBaseString + \" given, but reserving class space failed.\")) {\n+                if (output.contains(\"CompressedClassSpaceBaseAddress=\" + thisBaseString + \" given, but reserving class space failed.\") ||\n+                    output.matches (\"CompressedClassSpaceBaseAddress=\" + thisBaseString + \" given with shift .*, cannot be used to encode class pointers\")) {\n+                    \/\/ possible output:\n+                    \/\/     CompressedClassSpaceBaseAddress=0x0000000c00000000 given, but reserving class space failed.\n+                    \/\/     CompressedClassSpaceBaseAddress=0x0000000d00000000 given with shift 6, cannot be used to encode class pointers\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/AccessZeroNKlassHitsProtectionZone.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-java\/awt\/Mixing\/AWT_Mixing\/OpaqueOverlapping.java 8294264 windows-x64\n+java\/awt\/Mixing\/AWT_Mixing\/OpaqueOverlapping.java 8370584 windows-x64\n@@ -598,0 +598,1 @@\n+java\/nio\/channels\/AsyncCloseAndInterrupt.java                   8368290 macosx-26.0.1\n@@ -647,0 +648,2 @@\n+sun\/security\/ssl\/SSLLogger\/DebugPropertyValuesTest.java         8370852 generic-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+  public native boolean  hasExternalSymbolsStripped();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1063,1 +1063,0 @@\n-            \"\/modules\/java.base\/sun\/nio\/ByteBuffered.class\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/internal\/jrtfs\/ImageReaderBenchmark.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}