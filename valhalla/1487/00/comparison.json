{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/klassFactory.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"classfile\/stackMapTable.hpp\"\n@@ -33,1 +35,0 @@\n-#include \"classfile\/klassFactory.hpp\"\n@@ -3292,0 +3293,8 @@\n+   if (frame_type == 246) {  \/\/ EARLY_LARVAL\n+     \/\/ rewrite_cp_refs in  unset fields and fall through.\n+     rewrite_cp_refs_in_early_larval_stackmaps(stackmap_p, stackmap_end, calc_number_of_entries, frame_type);\n+     \/\/ The larval frames point to the next frame, so advance to the next frame and fall through.\n+     frame_type = *stackmap_p;\n+     stackmap_p++;\n+   }\n+\n@@ -3309,1 +3318,1 @@\n-    else if (frame_type >= 128 && frame_type <= 246) {\n+    else if (frame_type >= 128 && frame_type <= 245) {\n@@ -3497,0 +3506,23 @@\n+void VM_RedefineClasses::rewrite_cp_refs_in_early_larval_stackmaps(\n+       address& stackmap_p_ref, address stackmap_end, u2 frame_i,\n+       u1 frame_type) {\n+\n+    u2 num_early_larval_stackmaps = Bytes::get_Java_u2(stackmap_p_ref);\n+    stackmap_p_ref += 2;\n+\n+    for (u2 i = 0; i < num_early_larval_stackmaps; i++) {\n+\n+      u2 name_and_ref_index = Bytes::get_Java_u2(stackmap_p_ref);\n+      u2 new_cp_index = find_new_index(name_and_ref_index);\n+      if (new_cp_index != 0) {\n+        log_debug(redefine, class, stackmap)(\"mapped old name_and_ref_index=%d\", name_and_ref_index);\n+        Bytes::put_Java_u2(stackmap_p_ref, new_cp_index);\n+        name_and_ref_index = new_cp_index;\n+      }\n+      log_debug(redefine, class, stackmap)\n+        (\"frame_i=%u, frame_type=%u, name_and_ref_index=%d\", frame_i, frame_type, name_and_ref_index);\n+\n+      stackmap_p_ref += 2;\n+    }\n+} \/\/ rewrite_cp_refs_in_early_larval_stackmaps\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -491,0 +491,4 @@\n+  void rewrite_cp_refs_in_early_larval_stackmaps(\n+         address& stackmap_p_ref, address stackmap_end, u2 frame_i,\n+         u1 frame_type);\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Redefinition tests that larval_frame stackmaps are adjusted\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @run main RedefineClassHelper\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @compile -XDgenerateEarlyLarvalFrame -XDnoLocalProxyVars StrictFieldsOld.java StrictFieldsNew.java\n+ * @run main\/othervm -Xverify:remote -javaagent:redefineagent.jar RedefineStrictFieldsTest\n+ *\/\n+\n+import java.io.InputStream;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+public class RedefineStrictFieldsTest {\n+\n+    \/\/ All of this should be moved to RedefineClassHelper\n+    private static byte[] getBytecodes(Class<?> thisClass, String name) throws Exception {\n+        InputStream is = thisClass.getClassLoader().getResourceAsStream(name + \".class\");\n+        byte[] buf = is.readAllBytes();\n+        System.out.println(\"sizeof(\" + name + \".class) == \" + buf.length);\n+        return buf;\n+    }\n+\n+    private static int getStringIndex(String needle, byte[] buf) {\n+        return getStringIndex(needle, buf, 0);\n+    }\n+\n+    private static int getStringIndex(String needle, byte[] buf, int offset) {\n+        outer:\n+        for (int i = offset; i < buf.length - offset - needle.length(); i++) {\n+            for (int j = 0; j < needle.length(); j++) {\n+                if (buf[i + j] != (byte)needle.charAt(j)) continue outer;\n+            }\n+            return i;\n+        }\n+        return 0;\n+    }\n+\n+    private static void replaceString(byte[] buf, String name, int index) {\n+        for (int i = index; i < index + name.length(); i++) {\n+            buf[i] = (byte)name.charAt(i - index);\n+        }\n+    }\n+\n+    private static byte[] replaceAllStrings(String oldString, String newString) throws Exception {\n+        byte [] buf = getBytecodes(RedefineStrictFieldsTest.class, oldString);\n+        assertTrue(oldString.length() == newString.length(), \"must have same length\");\n+        int index = -1;\n+        while ((index = getStringIndex(oldString, buf, index + 1)) != 0) {\n+            replaceString(buf, newString, index);\n+        }\n+        return buf;\n+    }\n+\n+    \/\/ This should fail because x and y are no longer strict.\n+    static String newClassBytes = \"class StrictFieldsOld { \" +\n+                                     \"int x; int y; \" +\n+                                     \"StrictFieldsOld(boolean a, boolean b) { }\" +\n+                                     \"public void foo() { System.out.println(x + y );}}\";\n+\n+    public static void main(java.lang.String[] unused) throws Exception {\n+\n+        StrictFieldsOld old = new StrictFieldsOld(true, false);\n+        old.foo();\n+\n+        \/\/ Rename class \"StrictFieldsNew\" to \"StrictFieldsOld\" so we can redefine it.\n+        byte [] buf = replaceAllStrings(\"StrictFieldsNew\", \"StrictFieldsOld\");\n+        \/\/ Now redefine the original version.\n+        \/\/ If the stackmaps aren't rewritten to point to new constant pool indices, this should get a VerifyError\n+        \/\/ which RedefineClasses eats and makes into an InternalError.  Either way, this test will fail.\n+        RedefineClassHelper.redefineClass(StrictFieldsOld.class, buf);\n+        StrictFieldsOld newOld = new StrictFieldsOld(true, false);\n+        newOld.foo();  \/\/ should call the new foo\n+\n+        \/\/ Redefine class without strict fields. Should get a redefinition error.\n+        try {\n+            RedefineClassHelper.redefineClass(StrictFieldsOld.class, newClassBytes);\n+            StrictFieldsOld shouldThrow = new StrictFieldsOld(false, false);\n+            shouldThrow.foo();  \/\/ Should not be called.\n+            throw new RuntimeException(\"Redefinition should have failed\");\n+        } catch (java.lang.UnsupportedOperationException uoe) {\n+            String msg = uoe.getMessage();\n+            assertTrue(msg.contains(\"class redefinition failed: attempted to change the schema (add\/remove fields)\"), \"FAILED\");\n+        }\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/RedefineStrictFieldsTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.vm.annotation.Strict;\n+\n+class StrictFieldsNew {\n+\n+    @Strict\n+    int x;\n+    @Strict\n+    int y;\n+\n+    StrictFieldsNew(boolean a, boolean b) {\n+        System.out.println(\"Calling new constructor with \" + a + \" \" + b);\n+        if (a) {\n+            x = 4;\n+            if (b) {\n+                y = 4;\n+            } else {\n+                y = 5;\n+            }\n+        } else {\n+            x = y = 7;\n+        }\n+        super();\n+    }\n+\n+    public void foo() {\n+        System.out.println(\"Hello new fool \" + x + \" \" + y );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFieldsNew.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.vm.annotation.Strict;\n+\n+class StrictFieldsOld {\n+    @Strict\n+    int x;\n+    @Strict\n+    int y;\n+\n+    StrictFieldsOld(boolean a, boolean b) {\n+        if (a) {\n+            x = 1;\n+            if (b) {\n+                y = 1;\n+            } else {\n+                y = 2;\n+            }\n+        } else {\n+            x = y = 3;\n+        }\n+        super();\n+    }\n+\n+    public void foo() {\n+        System.out.println(\"Hello old fool \" + x + \" \" + y );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFieldsOld.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"}]}