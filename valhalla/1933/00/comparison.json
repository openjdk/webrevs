{"files":[{"patch":"@@ -141,0 +141,4 @@\n+        var sanitizedExceptions = List.copyOf(requireNonNull(exceptions));\n+        for (var each : sanitizedExceptions) {\n+            SignaturesImpl.validateUnmarked((Signature.RefTypeSig) each);\n+        }\n@@ -143,1 +147,1 @@\n-                List.copyOf(requireNonNull(exceptions)),\n+                sanitizedExceptions,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodSignature.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -145,0 +145,53 @@\n+\n+        \/**\n+         * The null marker on a reference type signature. A null marker is\n+         * a prefix to reference type signatures.\n+         *\n+         * @since Valhalla\n+         *\/\n+        \/\/ TODO preview under NR\n+        enum NullMarker {\n+            \/**\n+             * No null marker on a reference type.  This indicates no null\n+             * restriction, or when null restriction is insignificant.\n+             *\/\n+            UNMARKED,\n+            \/**\n+             * A null-checked marker on a reference type, {@code !}.  This\n+             * indicates null restriction for the values accepted by this type.\n+             *\/\n+            CHECKED,\n+            ;\n+        }\n+\n+        \/**\n+         * {@return the null marker on this reference type signature}\n+         *\n+         * @since Valhalla\n+         *\/\n+        NullMarker nullMarker();\n+\n+        \/**\n+         * {@return a reference type signature with updated null marker,\n+         * otherwise equivalent to this signature}\n+         *\n+         * @param marker the updated marker\n+         * @since Valhalla\n+         *\/\n+        RefTypeSig nullMarker(NullMarker marker);\n+\n+        \/**\n+         * {@return a reference type signature with no null marker, otherwise\n+         * equivalent to this signature}\n+         *\n+         * @since Valhalla\n+         *\/\n+        RefTypeSig nullUnmarked();\n+\n+        \/**\n+         * {@return a reference type signature with null check, otherwise\n+         * equivalent to this signature}\n+         *\n+         * @since Valhalla\n+         *\/\n+        RefTypeSig nullChecked();\n@@ -219,0 +272,13 @@\n+        @Override\n+        ClassTypeSig nullMarker(NullMarker marker);\n+\n+        @Override\n+        default ClassTypeSig nullUnmarked() {\n+            return nullMarker(NullMarker.UNMARKED);\n+        }\n+\n+        @Override\n+        default ClassTypeSig nullChecked() {\n+            return nullMarker(NullMarker.CHECKED);\n+        }\n+\n@@ -278,0 +344,1 @@\n+                SignaturesImpl.validateUnmarked(outerType);\n@@ -282,1 +349,1 @@\n-            return new SignaturesImpl.ClassTypeSigImpl(Optional.ofNullable(outerType), className, List.of(typeArgs));\n+            return new SignaturesImpl.ClassTypeSigImpl(NullMarker.UNMARKED, Optional.ofNullable(outerType), className, List.of(typeArgs));\n@@ -434,0 +501,13 @@\n+        @Override\n+        TypeVarSig nullMarker(NullMarker marker);\n+\n+        @Override\n+        default TypeVarSig nullUnmarked() {\n+            return nullMarker(NullMarker.UNMARKED);\n+        }\n+\n+        @Override\n+        default TypeVarSig nullChecked() {\n+            return nullMarker(NullMarker.CHECKED);\n+        }\n+\n@@ -442,1 +522,1 @@\n-            return new SignaturesImpl.TypeVarSigImpl(SignaturesImpl.validateIdentifier(identifier));\n+            return new SignaturesImpl.TypeVarSigImpl(NullMarker.UNMARKED, SignaturesImpl.validateIdentifier(identifier));\n@@ -462,0 +542,13 @@\n+        @Override\n+        ArrayTypeSig nullMarker(NullMarker marker);\n+\n+        @Override\n+        default ArrayTypeSig nullUnmarked() {\n+            return nullMarker(NullMarker.UNMARKED);\n+        }\n+\n+        @Override\n+        default ArrayTypeSig nullChecked() {\n+            return nullMarker(NullMarker.CHECKED);\n+        }\n+\n@@ -465,1 +558,2 @@\n-         * @throws IllegalArgumentException if the component type is void\n+         * @throws IllegalArgumentException if the component type is void or\n+         *         null-checked\n@@ -477,1 +571,1 @@\n-         *         type is void\n+         *         type is void or the component type is null-checked\n@@ -481,0 +575,3 @@\n+            if (componentSignature instanceof RefTypeSig ref) {\n+                SignaturesImpl.validateUnmarked(ref);\n+            }\n@@ -484,1 +581,1 @@\n-                return new SignaturesImpl.ArrayTypeSigImpl(dims + arr.arrayDepth(), arr.elemType());\n+                return new SignaturesImpl.ArrayTypeSigImpl(NullMarker.UNMARKED, dims + arr.arrayDepth(), arr.elemType());\n@@ -488,1 +585,1 @@\n-            return new SignaturesImpl.ArrayTypeSigImpl(dims, componentSignature);\n+            return new SignaturesImpl.ArrayTypeSigImpl(NullMarker.UNMARKED, dims, componentSignature);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":103,"deletions":6,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-            ClassTypeSig superclass = classTypeSig();\n+            ClassTypeSig superclass = unmarkedClassTypeSig();\n@@ -60,1 +60,1 @@\n-                superinterfaces.add(classTypeSig());\n+                superinterfaces.add(unmarkedClassTypeSig());\n@@ -84,1 +84,1 @@\n-                var t = referenceTypeSig();\n+                var t = unmarkedReferenceTypeSig();\n@@ -126,1 +126,1 @@\n-                            classBound = referenceTypeSig();\n+                            classBound = unmarkedReferenceTypeSig();\n@@ -135,1 +135,1 @@\n-                    interfaceBounds.add(referenceTypeSig());\n+                    interfaceBounds.add(unmarkedReferenceTypeSig());\n@@ -145,3 +145,4 @@\n-        switch (c) {\n-            case 'B','C','D','F','I','J','V','S','Z': return Signature.BaseTypeSig.of(c);\n-            default:\n+        return switch (c) {\n+            case 'B', 'C', 'D', 'F', 'I', 'J', 'V', 'S', 'Z' -> Signature.BaseTypeSig.of(c);\n+            case '!' -> unmarkedReferenceTypeSig().nullChecked();\n+            case 'L', 'T', '[' -> {\n@@ -149,2 +150,4 @@\n-                return referenceTypeSig();\n-        }\n+                yield unmarkedReferenceTypeSig();\n+            }\n+            default -> throw unexpectedError(\"a type signature\");\n+        };\n@@ -153,1 +156,1 @@\n-    private RefTypeSig referenceTypeSig() {\n+    private RefTypeSig unmarkedReferenceTypeSig() {\n@@ -155,1 +158,1 @@\n-            case 'L' -> classTypeSig();\n+            case 'L' -> unmarkedClassTypeSig();\n@@ -166,5 +169,1 @@\n-            case '?', '!', '=' -> {\n-                sigp++;\n-                yield referenceTypeSig();\n-            }\n-            default -> throw unexpectedError(\"a type signature\");\n+            default -> throw unexpectedError(\"an unmarked reference type signature\");\n@@ -178,2 +177,2 @@\n-            case '+': return TypeArg.extendsOf(referenceTypeSig());\n-            case '-': return TypeArg.superOf(referenceTypeSig());\n+            case '+': return TypeArg.extendsOf(unmarkedReferenceTypeSig());\n+            case '-': return TypeArg.superOf(unmarkedReferenceTypeSig());\n@@ -182,1 +181,1 @@\n-                return TypeArg.of(referenceTypeSig());\n+                return TypeArg.of(unmarkedReferenceTypeSig());\n@@ -186,1 +185,1 @@\n-    private ClassTypeSig classTypeSig() {\n+    private ClassTypeSig unmarkedClassTypeSig() {\n@@ -213,1 +212,1 @@\n-                t = new ClassTypeSigImpl(Optional.ofNullable(t), className, null2Empty(argTypes));\n+                t = new ClassTypeSigImpl(RefTypeSig.NullMarker.UNMARKED, Optional.ofNullable(t), className, null2Empty(argTypes));\n@@ -314,0 +313,9 @@\n+    \/\/\/ Validates the signature to have no null marker.\n+    public static <T extends RefTypeSig> T validateUnmarked(T incoming) {\n+        \/\/ implicit null check\n+        if (incoming.nullMarker() != RefTypeSig.NullMarker.UNMARKED) {\n+            throw new IllegalArgumentException(\"Must not have null marker: \" + incoming);\n+        }\n+        return incoming;\n+    }\n+\n@@ -337,1 +345,13 @@\n-    public static record TypeVarSigImpl(String identifier) implements Signature.TypeVarSig {\n+    public static String marker(RefTypeSig.NullMarker marker) {\n+        return switch (marker) {\n+            case UNMARKED -> \"\";\n+            case CHECKED -> \"!\";\n+        };\n+    }\n+\n+    public static record TypeVarSigImpl(NullMarker nullMarker, String identifier) implements Signature.TypeVarSig {\n+\n+        @Override\n+        public TypeVarSig nullMarker(NullMarker marker) {\n+            return marker == nullMarker ? this : new TypeVarSigImpl(marker, identifier);\n+        }\n@@ -341,1 +361,1 @@\n-            return \"T\" + identifier + ';';\n+            return marker(nullMarker) + \"T\" + identifier + ';';\n@@ -345,1 +365,12 @@\n-    public static record ArrayTypeSigImpl(int arrayDepth, Signature elemType) implements Signature.ArrayTypeSig {\n+    public static record ArrayTypeSigImpl(NullMarker nullMarker, int arrayDepth, Signature elemType) implements Signature.ArrayTypeSig {\n+\n+        public ArrayTypeSigImpl {\n+            if (elemType instanceof RefTypeSig ref) {\n+                validateUnmarked(ref);\n+            }\n+        }\n+\n+        @Override\n+        public ArrayTypeSig nullMarker(NullMarker marker) {\n+            return marker == nullMarker ? this : new ArrayTypeSigImpl(marker, arrayDepth, elemType);\n+        }\n@@ -349,1 +380,1 @@\n-            return arrayDepth > 1 ? new ArrayTypeSigImpl(arrayDepth - 1, elemType) : elemType;\n+            return arrayDepth > 1 ? new ArrayTypeSigImpl(NullMarker.UNMARKED, arrayDepth - 1, elemType) : elemType;\n@@ -354,1 +385,1 @@\n-            return \"[\".repeat(arrayDepth) + elemType.signatureString();\n+            return marker(nullMarker) + \"[\".repeat(arrayDepth) + elemType.signatureString();\n@@ -358,1 +389,1 @@\n-    public static record ClassTypeSigImpl(Optional<ClassTypeSig> outerType, String className, List<Signature.TypeArg> typeArgs)\n+    public static record ClassTypeSigImpl(NullMarker nullMarker, Optional<ClassTypeSig> outerType, String className, List<Signature.TypeArg> typeArgs)\n@@ -361,0 +392,5 @@\n+        @Override\n+        public ClassTypeSig nullMarker(NullMarker marker) {\n+            return marker == nullMarker ? this : new ClassTypeSigImpl(marker, outerType, className, typeArgs);\n+        }\n+\n@@ -387,1 +423,1 @@\n-            return prefix + className + suffix;\n+            return marker(nullMarker) + prefix + className + suffix;\n@@ -396,0 +432,3 @@\n+        public TypeArgImpl {\n+            validateUnmarked(boundType);\n+        }\n@@ -400,0 +439,8 @@\n+        public TypeParamImpl {\n+            if (classBound.isPresent()) {\n+                validateUnmarked(classBound.get());\n+            }\n+            for (var each : interfaceBounds) {\n+                validateUnmarked(each);\n+            }\n+        }\n@@ -421,0 +468,7 @@\n+        public ClassSignatureImpl {\n+            validateUnmarked(superclassSignature);\n+            for (var each : superinterfaceSignatures) {\n+                validateUnmarked(each);\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":83,"deletions":29,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -138,0 +138,11 @@\n+\n+        assertEqualsDeep(\n+                MethodSignature.of(\n+                        List.of(),\n+                        List.of(),\n+                        BaseTypeSig.of('V'),\n+                        TypeVarSig.of(\"E\").nullChecked(),\n+                        ArrayTypeSig.of(BaseTypeSig.of('I')).nullChecked(),\n+                        ClassTypeSig.of(\"Generic\", TypeArg.unbounded()).nullChecked()),\n+                MethodSignature.parseFrom(\"(!TE;![I!LGeneric<*>;)V\")\n+        );\n@@ -156,0 +167,24 @@\n+    @Test\n+    void testBangRestrictions() {\n+        var plainClass = ClassTypeSig.of(CD_Class);\n+        var bangClass = plainClass.nullChecked();\n+        \/\/ class superclass\n+        assertThrows(IllegalArgumentException.class, () -> ClassSignature.of(bangClass));\n+        \/\/ class interfaces\n+        assertThrows(IllegalArgumentException.class, () -> ClassSignature.of(plainClass, bangClass));\n+        \/\/ method throws\n+        assertThrows(IllegalArgumentException.class, () -> MethodSignature.of(List.of(), List.of(bangClass), BaseTypeSig.of('V')));\n+        \/\/ type arg bounds\n+        assertThrows(IllegalArgumentException.class, () -> TypeArg.of(bangClass));\n+        assertThrows(IllegalArgumentException.class, () -> TypeArg.superOf(bangClass));\n+        assertThrows(IllegalArgumentException.class, () -> TypeArg.extendsOf(bangClass));\n+        \/\/ type param superclass\n+        assertThrows(IllegalArgumentException.class, () -> TypeParam.of(\"T\", bangClass));\n+        \/\/ type param interfaces\n+        assertThrows(IllegalArgumentException.class, () -> TypeParam.of(\"T\", Optional.empty(), bangClass));\n+        \/\/ array component\n+        assertThrows(IllegalArgumentException.class, () -> ArrayTypeSig.of(bangClass));\n+        \/\/ outer class\/enclosing instance\n+        assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(bangClass, \"Nested\"));\n+    }\n+\n@@ -313,0 +348,6 @@\n+                !I\n+                [!Ljava\/lang\/Class;\n+                ![!Ljava\/lang\/Class;\n+                !Ljava\/util\/Optional<!Ljava\/lang\/Integer;>;\n+                Ljava\/util\/Optional<+!Ljava\/lang\/Integer;>;\n+                Ljava\/util\/Optional<-!Ljava\/lang\/Integer;>;\n@@ -329,0 +370,5 @@\n+                ![B\n+                ![[I\n+                !Ljava\/lang\/Class<*>;\n+                !Ljava\/lang\/String;\n+                !TT;\n@@ -363,0 +409,3 @@\n+                !Ljava\/lang\/Object;\n+                Ljava\/lang\/Object;!Ljava\/lang\/Runnable;\n+                <>Ljava\/lang\/Object;\n@@ -395,0 +444,4 @@\n+                ()!I\n+                ()[!Ljava\/lang\/Object;\n+                ()V^!Ljava\/lang\/Throwable;\n+                <T::!Ljava\/lang\/Runnable;>()V\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"}]}