{"files":[{"patch":"@@ -70,0 +70,6 @@\n+\n+  \/\/ Repair the sender sp if the frame has been extended\n+  if (sender_cb->is_nmethod()) {\n+    sender_sp = f.repair_sender_sp(sender_sp, link_addr);\n+  }\n+\n@@ -78,1 +84,1 @@\n-frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n+frame FreezeBase::new_heap_frame(frame& f, frame& caller, int size_adjust) {\n@@ -109,2 +115,2 @@\n-    sp = caller.unextended_sp() - fsize;\n-    if (caller.is_interpreted_frame()) {\n+    sp = caller.unextended_sp() - fsize - size_adjust;\n+    if (caller.is_interpreted_frame() && size_adjust == 0) {\n@@ -183,1 +189,1 @@\n-inline void FreezeBase::patch_pd(frame& hf, const frame& caller) {\n+inline void FreezeBase::patch_pd(frame& hf, const frame& caller, bool is_bottom_frame) {\n@@ -187,1 +193,2 @@\n-  } else {\n+  } else if (is_bottom_frame && caller.pc() != nullptr) {\n+    assert(caller.is_compiled_frame(), \"\");\n@@ -218,1 +225,1 @@\n-template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom) {\n+template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom, int size_adjust) {\n@@ -246,1 +253,1 @@\n-    intptr_t* frame_sp = caller.unextended_sp() - fsize;\n+    intptr_t* frame_sp = caller.unextended_sp() - fsize - size_adjust;\n@@ -248,7 +255,4 @@\n-      int argsize = FKind::stack_argsize(hf);\n-\n-      fsize += argsize;\n-      frame_sp   -= argsize;\n-      caller.set_sp(caller.sp() - argsize);\n-      assert(caller.sp() == frame_sp + (fsize-argsize), \"\");\n-\n+      if (size_adjust == 0) {\n+        int argsize = FKind::stack_argsize(hf);\n+        frame_sp -= argsize;\n+      }\n@@ -257,0 +261,2 @@\n+    caller.set_sp(frame_sp + fsize);\n+    assert(is_aligned(frame_sp, frame::frame_alignment), \"\");\n@@ -263,1 +269,1 @@\n-      fp = frame_sp + FKind::size(hf) - frame::sender_sp_offset;\n+      fp = frame_sp + fsize - frame::sender_sp_offset;\n@@ -278,1 +284,0 @@\n-    caller.set_sp(caller.sp() - 1);\n@@ -282,1 +287,0 @@\n-\n@@ -287,1 +291,3 @@\n-  patch_callee_link(caller, caller.fp());\n+  if (caller.is_interpreted_frame() || PreserveFramePointer) {\n+    patch_callee_link(caller, caller.fp());\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,2 +144,2 @@\n-inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc) {\n-  address* pc_addr = &(((address*) f.sp())[-1]);\n+inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc, bool callee_augmented) {\n+  address* pc_addr = &(((address*) (callee_augmented ? f.unextended_sp() : f.sp()))[-1]);\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationHelper_aarch64.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -673,0 +673,3 @@\n+      if (cb()->is_nmethod() && cb()->as_nmethod_or_null()->needs_stack_repair()) {\n+        values.describe(frame_no, fp_loc - 1, err_msg(\"fsize for #%d\", frame_no), 1);\n+      }\n@@ -844,0 +847,22 @@\n+intptr_t* frame::repair_sender_sp(nmethod* nm, intptr_t* sp, intptr_t** saved_fp_addr) {\n+  assert(nm != nullptr && nm->needs_stack_repair(), \"\");\n+  \/\/ The stack increment resides just below the saved FP on the stack and\n+  \/\/ records the total frame size excluding the two words for saving FP and LR.\n+  intptr_t* real_frame_size_addr = (intptr_t*) (saved_fp_addr - 1);\n+  int real_frame_size = (*real_frame_size_addr \/ wordSize) + 2;\n+  assert(real_frame_size >= nm->frame_size() && real_frame_size <= 1000000, \"invalid frame size\");\n+  return sp + real_frame_size;\n+}\n+\n+bool frame::was_augmented_on_entry(int& real_size) const {\n+  assert(is_compiled_frame(), \"\");\n+  if (_cb->as_nmethod_or_null()->needs_stack_repair()) {\n+    intptr_t* real_frame_size_addr = unextended_sp() + _cb->frame_size() - sender_sp_offset - 1;\n+    log_trace(continuations)(\"real_frame_size is addr is \" INTPTR_FORMAT, p2i(real_frame_size_addr));\n+    real_size = (*real_frame_size_addr \/ wordSize) + 2;\n+    return real_size != _cb->frame_size();\n+  }\n+  real_size = _cb->frame_size();\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+ public:\n@@ -157,0 +158,4 @@\n+  static intptr_t* repair_sender_sp(nmethod* nm, intptr_t* sp, intptr_t** saved_fp_addr);\n+  bool was_augmented_on_entry(int& real_size) const;\n+\n+ private:\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,2 +38,24 @@\n-  int argsize = is_compiled() ? (_cb->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n-  int frame_size = _cb->frame_size() + argsize;\n+  int frame_size = _cb->frame_size();\n+  if (is_compiled()) {\n+    nmethod* nm = _cb->as_nmethod_or_null();\n+    if (nm->needs_stack_repair() && nm->is_compiled_by_c2()) {\n+      frame f = to_frame();\n+      bool augmented = f.was_augmented_on_entry(frame_size);\n+      if (!augmented) {\n+        \/\/ Fix: C2 caller, so frame was not extended and thus the\n+        \/\/ size read from the frame does not include the arguments.\n+        \/\/ Ideally we have to count the arg size for the scalarized\n+        \/\/ convention. For now we include the size of the caller frame\n+        \/\/ which would at least be equal to that.\n+        RegisterMap map(nullptr,\n+                        RegisterMap::UpdateMap::skip,\n+                        RegisterMap::ProcessFrames::skip,\n+                        RegisterMap::WalkContinuation::skip);\n+        frame caller = to_frame().sender(&map);\n+        assert(caller.is_compiled_frame() && caller.cb()->as_nmethod()->is_compiled_by_c2(), \"\");\n+        frame_size += (caller.real_fp() - caller.sp());\n+      }\n+    } else {\n+      frame_size += _cb->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size >> LogBytesPerWord;\n+    }\n+  }\n@@ -49,1 +71,7 @@\n-    return frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap, true);\n+    frame f = frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap, true);\n+    \/\/ If caller tries to get the sender of this frame and PreserveFramePointer\n+    \/\/ is set, fp() will be used which contains the old value at the time of\n+    \/\/ freeze (fp is reconstructed again during thaw). Setting sp as trusted\n+    \/\/ causes the sender code to use _unextended_sp instead (see sender_for_compiled_frame()).\n+    f.set_sp_is_trusted();\n+    return f;\n@@ -57,1 +85,1 @@\n-  return pauth_strip_pointer(*(address*)(_sp - 1));\n+  return pauth_strip_pointer(*(address*)((_callee_augmented ? _unextended_sp : _sp) - 1));\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -10483,0 +10483,24 @@\n+  static void save_return_registers(MacroAssembler* masm) {\n+    if (InlineTypeReturnedAsFields) {\n+      masm->push(RegSet::range(r0, r7), sp);\n+      masm->sub(sp, sp, 4 * wordSize);\n+      masm->st1(v0, v1, v2, v3, masm->T1D, Address(sp));\n+      masm->sub(sp, sp, 4 * wordSize);\n+      masm->st1(v4, v5, v6, v7, masm->T1D, Address(sp));\n+    } else {\n+      masm->fmovd(rscratch1, v0);\n+      masm->stp(rscratch1, r0, Address(masm->pre(sp, -2 * wordSize)));\n+    }\n+  }\n+\n+  static void restore_return_registers(MacroAssembler* masm) {\n+    if (InlineTypeReturnedAsFields) {\n+      masm->ld1(v4, v5, v6, v7, masm->T1D, Address(masm->post(sp, 4 * wordSize)));\n+      masm->ld1(v0, v1, v2, v3, masm->T1D, Address(masm->post(sp, 4 * wordSize)));\n+      masm->pop(RegSet::range(r0, r7), sp);\n+    } else {\n+      masm->ldp(rscratch1, r0, Address(masm->post(sp, 2 * wordSize)));\n+      masm->fmovd(v0, rscratch1);\n+    }\n+  }\n+\n@@ -10497,2 +10521,1 @@\n-      __ fmovd(rscratch1, v0);\n-      __ stp(rscratch1, r0, Address(__ pre(sp, -2 * wordSize)));\n+      save_return_registers(_masm);\n@@ -10507,2 +10530,1 @@\n-      __ ldp(rscratch1, r0, Address(__ post(sp, 2 * wordSize)));\n-      __ fmovd(v0, rscratch1);\n+      restore_return_registers(_masm);\n@@ -10527,2 +10549,1 @@\n-      __ fmovd(rscratch1, v0);\n-      __ stp(rscratch1, r0, Address(__ pre(sp, -2 * wordSize)));\n+      save_return_registers(_masm);\n@@ -10539,2 +10560,1 @@\n-      __ ldp(rscratch1, r0, Address(__ post(sp, 2 * wordSize)));\n-      __ fmovd(v0, rscratch1);\n+      restore_return_registers(_masm);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc) {\n+inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc, bool callee_augmented) {\n","filename":"src\/hotspot\/cpu\/arm\/continuationHelper_arm.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc) {\n+inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc, bool callee_augmented) {\n","filename":"src\/hotspot\/cpu\/ppc\/continuationHelper_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc) {\n+inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc, bool callee_augmented) {\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc) {\n+inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc, bool callee_augmented) {\n","filename":"src\/hotspot\/cpu\/s390\/continuationHelper_s390.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,6 @@\n+\n+  \/\/ Repair the sender sp if the frame has been extended\n+  if (sender_cb->is_nmethod()) {\n+    sender_sp = f.repair_sender_sp(sender_sp, link_addr);\n+  }\n+\n@@ -75,1 +81,1 @@\n-frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n+frame FreezeBase::new_heap_frame(frame& f, frame& caller, int size_adjust) {\n@@ -106,2 +112,2 @@\n-    sp = caller.unextended_sp() - fsize;\n-    if (caller.is_interpreted_frame()) {\n+    sp = caller.unextended_sp() - fsize - size_adjust;\n+    if (caller.is_interpreted_frame() && size_adjust == 0) {\n@@ -174,1 +180,1 @@\n-inline void FreezeBase::patch_pd(frame& hf, const frame& caller) {\n+inline void FreezeBase::patch_pd(frame& hf, const frame& caller, bool is_bottom_frame) {\n@@ -178,1 +184,2 @@\n-  } else {\n+  } else if (is_bottom_frame && caller.pc() != nullptr) {\n+    assert(caller.is_compiled_frame(), \"\");\n@@ -209,1 +216,1 @@\n-template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom) {\n+template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom, int size_adjust) {\n@@ -236,1 +243,1 @@\n-    intptr_t* frame_sp = caller.unextended_sp() - fsize;\n+    intptr_t* frame_sp = caller.unextended_sp() - fsize - size_adjust;\n@@ -238,7 +245,4 @@\n-      int argsize = FKind::stack_argsize(hf);\n-\n-      fsize += argsize;\n-      frame_sp   -= argsize;\n-      caller.set_sp(caller.sp() - argsize);\n-      assert(caller.sp() == frame_sp + (fsize-argsize), \"\");\n-\n+      if (size_adjust == 0) {\n+        int argsize = FKind::stack_argsize(hf);\n+        frame_sp -= argsize;\n+      }\n@@ -247,0 +251,2 @@\n+    caller.set_sp(frame_sp + fsize);\n+    assert(is_aligned(frame_sp, frame::frame_alignment), \"\");\n@@ -253,1 +259,1 @@\n-      fp = frame_sp + FKind::size(hf) - frame::sender_sp_offset;\n+      fp = frame_sp + fsize - frame::sender_sp_offset;\n@@ -267,1 +273,0 @@\n-    caller.set_sp(caller.sp() - 1);\n@@ -274,1 +279,3 @@\n-  patch_callee_link(caller, caller.fp());\n+  if (caller.is_interpreted_frame() || PreserveFramePointer) {\n+    patch_callee_link(caller, caller.fp());\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -122,2 +122,2 @@\n-inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc) {\n-  address* pc_addr = &(((address*) f.sp())[-1]);\n+inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc, bool callee_augmented) {\n+  address* pc_addr = &(((address*) (callee_augmented ? f.unextended_sp() : f.sp()))[-1]);\n","filename":"src\/hotspot\/cpu\/x86\/continuationHelper_x86.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -679,0 +679,3 @@\n+      if (cb()->is_nmethod() && cb()->as_nmethod_or_null()->needs_stack_repair()) {\n+        values.describe(frame_no, fp_loc - 1, err_msg(\"fsize for #%d\", frame_no), 1);\n+      }\n@@ -717,0 +720,22 @@\n+intptr_t* frame::repair_sender_sp(nmethod* nm, intptr_t* sp, intptr_t** saved_fp_addr) {\n+  assert(nm != nullptr && nm->needs_stack_repair(), \"\");\n+  \/\/ The stack increment resides just below the saved rbp on the stack\n+  \/\/ and does not account for the return address.\n+  intptr_t* real_frame_size_addr = (intptr_t*) (saved_fp_addr - 1);\n+  int real_frame_size = ((*real_frame_size_addr) + wordSize) \/ wordSize;\n+  assert(real_frame_size >= nm->frame_size() && real_frame_size <= 1000000, \"invalid frame size\");\n+  return sp + real_frame_size;\n+}\n+\n+bool frame::was_augmented_on_entry(int& real_size) const {\n+  assert(is_compiled_frame(), \"\");\n+  if (_cb->as_nmethod_or_null()->needs_stack_repair()) {\n+    intptr_t* real_frame_size_addr = unextended_sp() + _cb->frame_size() - sender_sp_offset - 1;\n+    log_trace(continuations)(\"real_frame_size is addr is \" INTPTR_FORMAT, p2i(real_frame_size_addr));\n+    real_size = ((*real_frame_size_addr) + wordSize) \/ wordSize;\n+    return real_size != _cb->frame_size();\n+  }\n+  real_size = _cb->frame_size();\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -147,0 +147,1 @@\n+ public:\n@@ -149,0 +150,2 @@\n+  static intptr_t* repair_sender_sp(nmethod* nm, intptr_t* sp, intptr_t** saved_fp_addr);\n+  bool was_augmented_on_entry(int& real_size) const;\n@@ -150,0 +153,1 @@\n+ private:\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,24 @@\n-  int argsize = is_compiled() ? (_cb->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n-  int frame_size = _cb->frame_size() + argsize;\n+  int frame_size = _cb->frame_size();\n+  if (is_compiled()) {\n+    nmethod* nm = _cb->as_nmethod_or_null();\n+    if (nm->needs_stack_repair() && nm->is_compiled_by_c2()) {\n+      frame f = to_frame();\n+      bool augmented = f.was_augmented_on_entry(frame_size);\n+      if (!augmented) {\n+        \/\/ Fix: C2 caller, so frame was not extended and thus the\n+        \/\/ size read from the frame does not include the arguments.\n+        \/\/ Ideally we have to count the arg size for the scalarized\n+        \/\/ convention. For now we include the size of the caller frame\n+        \/\/ which would at least be equal to that.\n+        RegisterMap map(nullptr,\n+                        RegisterMap::UpdateMap::skip,\n+                        RegisterMap::ProcessFrames::skip,\n+                        RegisterMap::WalkContinuation::skip);\n+        frame caller = to_frame().sender(&map);\n+        assert(caller.is_compiled_frame() && caller.cb()->as_nmethod()->is_compiled_by_c2(), \"\");\n+        frame_size += (caller.real_fp() - caller.sp());\n+      }\n+    } else {\n+      frame_size += _cb->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size >> LogBytesPerWord;\n+    }\n+  }\n@@ -55,1 +77,1 @@\n-  return *(address*)(_sp - 1);\n+  return *(address*)((_callee_augmented ? _unextended_sp : _sp) - 1);\n","filename":"src\/hotspot\/cpu\/x86\/stackChunkFrameStream_x86.inline.hpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3781,0 +3781,61 @@\n+static void save_return_registers(MacroAssembler* masm) {\n+  masm->push(rax);\n+  if (InlineTypeReturnedAsFields) {\n+    masm->push(rdi);\n+    masm->push(rsi);\n+    masm->push(rdx);\n+    masm->push(rcx);\n+    masm->push(r8);\n+    masm->push(r9);\n+  }\n+  masm->push_d(xmm0);\n+  if (InlineTypeReturnedAsFields) {\n+    masm->push_d(xmm1);\n+    masm->push_d(xmm2);\n+    masm->push_d(xmm3);\n+    masm->push_d(xmm4);\n+    masm->push_d(xmm5);\n+    masm->push_d(xmm6);\n+    masm->push_d(xmm7);\n+  }\n+#ifdef ASSERT\n+  masm->movq(rax, 0xBADC0FFE);\n+  masm->movq(rdi, rax);\n+  masm->movq(rsi, rax);\n+  masm->movq(rdx, rax);\n+  masm->movq(rcx, rax);\n+  masm->movq(r8, rax);\n+  masm->movq(r9, rax);\n+  masm->movq(xmm0, rax);\n+  masm->movq(xmm1, rax);\n+  masm->movq(xmm2, rax);\n+  masm->movq(xmm3, rax);\n+  masm->movq(xmm4, rax);\n+  masm->movq(xmm5, rax);\n+  masm->movq(xmm6, rax);\n+  masm->movq(xmm7, rax);\n+#endif\n+}\n+\n+static void restore_return_registers(MacroAssembler* masm) {\n+  if (InlineTypeReturnedAsFields) {\n+    masm->pop_d(xmm7);\n+    masm->pop_d(xmm6);\n+    masm->pop_d(xmm5);\n+    masm->pop_d(xmm4);\n+    masm->pop_d(xmm3);\n+    masm->pop_d(xmm2);\n+    masm->pop_d(xmm1);\n+  }\n+  masm->pop_d(xmm0);\n+  if (InlineTypeReturnedAsFields) {\n+    masm->pop(r9);\n+    masm->pop(r8);\n+    masm->pop(rcx);\n+    masm->pop(rdx);\n+    masm->pop(rsi);\n+    masm->pop(rdi);\n+  }\n+  masm->pop(rax);\n+}\n+\n@@ -3832,2 +3893,1 @@\n-    __ push(rax);\n-    __ push_d(xmm0);\n+    save_return_registers(_masm);\n@@ -3844,2 +3904,1 @@\n-    __ pop_d(xmm0);\n-    __ pop(rax);\n+    restore_return_registers(_masm);\n@@ -3871,2 +3930,1 @@\n-    __ push(rax);\n-    __ push_d(xmm0);\n+    save_return_registers(_masm);\n@@ -3884,2 +3942,1 @@\n-    __ pop_d(xmm0);\n-    __ pop(rax);\n+    restore_return_registers(_masm);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":65,"deletions":8,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc) {\n+inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc, bool callee_augmented) {\n","filename":"src\/hotspot\/cpu\/zero\/continuationHelper_zero.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -173,6 +173,0 @@\n-#ifndef PRODUCT\n-static jlong java_tid(JavaThread* thread) {\n-  return java_lang_Thread::thread_id(thread->threadObj());\n-}\n-#endif\n-\n@@ -408,3 +402,2 @@\n-  log_develop_debug(continuations)(\"continuation_bottom_sender: [\" JLONG_FORMAT \"] [%d] callee: \" INTPTR_FORMAT\n-    \" sender_sp: \" INTPTR_FORMAT,\n-    java_tid(thread), thread->osthread()->thread_id(), p2i(callee.sp()), p2i(sender_sp));\n+  log_develop_debug(continuations)(\"continuation_bottom_sender: [%d] callee: \" INTPTR_FORMAT \" sender_sp: \" INTPTR_FORMAT,\n+      thread->osthread()->thread_id(), p2i(callee.sp()), p2i(sender_sp));\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -460,1 +460,1 @@\n-  template<typename FKind> frame new_heap_frame(frame& f, frame& caller);\n+  template<typename FKind> frame new_heap_frame(frame& f, frame& caller, int size_adjust = 0);\n@@ -462,1 +462,1 @@\n-  inline void patch_pd(frame& callee, const frame& caller);\n+  inline void patch_pd(frame& callee, const frame& caller, bool is_bottom_frame);\n@@ -1162,1 +1162,1 @@\n-  patch_pd(hf, caller);\n+  patch_pd(hf, caller, is_bottom_frame);\n@@ -1259,2 +1259,24 @@\n-  const int argsize = ContinuationHelper::CompiledFrame::stack_argsize(f) + frame::metadata_words_at_top;\n-  const int fsize = pointer_delta_as_int(stack_frame_bottom + argsize, stack_frame_top);\n+  int argsize = ContinuationHelper::CompiledFrame::stack_argsize(f) + frame::metadata_words_at_top;\n+  int fsize = pointer_delta_as_int(stack_frame_bottom + argsize, stack_frame_top);\n+\n+  int real_frame_size = 0;\n+  bool augmented = f.was_augmented_on_entry(real_frame_size);\n+  if (augmented) {\n+    \/\/ The args reside inside the frame so clear argsize. If the caller is compiled,\n+    \/\/ this will cause the stack arguments passed by the caller to be freezed when\n+    \/\/ freezing the caller frame itself. If the caller is interpreted this will have\n+    \/\/ the effect of discarding the arg area created in the i2c stub.\n+    argsize = 0;\n+    fsize = real_frame_size - (callee_interpreted ? 0 : callee_argsize);\n+#ifdef ASSERT\n+    nmethod* nm = f.cb()->as_nmethod();\n+    Method* method = nm->method();\n+    address return_pc = ContinuationHelper::CompiledFrame::return_pc(f);\n+    CodeBlob* caller_cb = CodeCache::find_blob_fast(return_pc);\n+    assert(nm->is_compiled_by_c2() || (caller_cb->is_nmethod() && caller_cb->as_nmethod()->is_compiled_by_c2()), \"caller or callee should be c2 compiled\");\n+    assert((!caller_cb->is_nmethod() && nm->is_compiled_by_c2()) ||\n+           (nm->compiler_type() != caller_cb->as_nmethod()->compiler_type()) ||\n+           (nm->is_compiled_by_c2() && !method->is_static() && method->method_holder()->is_inline_klass()),\n+           \"frame should not be extended\");\n+#endif\n+  }\n@@ -1262,1 +1284,1 @@\n-  log_develop_trace(continuations)(\"recurse_freeze_compiled_frame %s _size: %d fsize: %d argsize: %d\",\n+  log_develop_trace(continuations)(\"recurse_freeze_compiled_frame %s _size: %d fsize: %d argsize: %d augmented: %d\",\n@@ -1265,1 +1287,1 @@\n-                             _freeze_size, fsize, argsize);\n+                             _freeze_size, fsize, argsize, augmented);\n@@ -1276,0 +1298,1 @@\n+  assert(!is_bottom_frame || !augmented, \"thaw extended frame without caller?\");\n@@ -1279,1 +1302,1 @@\n-  frame hf = new_heap_frame<ContinuationHelper::CompiledFrame>(f, caller);\n+  frame hf = new_heap_frame<ContinuationHelper::CompiledFrame>(f, caller, augmented ? real_frame_size - f.cb()->as_nmethod()->frame_size() : 0);\n@@ -1941,0 +1964,1 @@\n+  int remove_scalarized_frames(StackChunkFrameStream<ChunkFrames::CompiledOnly>& scfs, stackChunkOop chunk, int &argsize);\n@@ -1964,1 +1988,1 @@\n-  inline void patch(frame& f, const frame& caller, bool bottom);\n+  inline void patch(frame& f, const frame& caller, bool bottom, bool augmented = false);\n@@ -1974,1 +1998,1 @@\n-  template<typename FKind> frame new_stack_frame(const frame& hf, frame& caller, bool bottom);\n+  template<typename FKind> frame new_stack_frame(const frame& hf, frame& caller, bool bottom, int size_adjust = 0);\n@@ -2051,0 +2075,41 @@\n+int ThawBase::remove_scalarized_frames(StackChunkFrameStream<ChunkFrames::CompiledOnly>& f, stackChunkOop chunk, int &argsize) {\n+  DEBUG_ONLY(intptr_t* const chunk_sp = chunk->start_address() + chunk->sp();)\n+  intptr_t* top = f.sp();\n+\n+  while (f.cb()->as_nmethod_or_null()->needs_stack_repair()) {\n+    f.next(SmallRegisterMap::instance(), false \/* stop *\/);\n+  }\n+  assert(!f.is_done(), \"\");\n+  assert(f.is_compiled(), \"\");\n+\n+  intptr_t* bottom = f.sp() + f.cb()->frame_size();\n+  argsize = f.stack_argsize();\n+  int frames_size = bottom - top;\n+\n+  f.next(SmallRegisterMap::instance(), true \/* stop *\/);\n+  bool empty = f.is_done();\n+  assert(!empty || argsize == chunk->argsize(), \"\");\n+\n+  if (empty) {\n+    clear_chunk(chunk);\n+  } else {\n+    chunk->set_sp(chunk->sp() + frames_size);\n+    chunk->set_max_thawing_size(chunk->max_thawing_size() - frames_size);\n+    \/\/ We set chunk->pc to the return pc into the next frame\n+    chunk->set_pc(f.pc());\n+#ifdef ASSERT\n+    {\n+      intptr_t* retaddr_slot = (chunk_sp\n+                                + frames_size\n+                                - frame::sender_sp_ret_address_offset());\n+      assert(f.pc() == ContinuationHelper::return_address_at(retaddr_slot),\n+             \"unexpected pc\");\n+    }\n+#endif\n+  }\n+  assert(empty == chunk->is_empty(), \"\");\n+  \/\/ returns the size required to store the frame on stack, and because it is a\n+  \/\/ compiled frame, it must include a copy of the arguments passed by the caller\n+  return frames_size + argsize + frame::metadata_words_at_top;\n+}\n+\n@@ -2059,0 +2124,4 @@\n+  if (f.cb()->as_nmethod_or_null()->needs_stack_repair()) {\n+    return remove_scalarized_frames(f, chunk, argsize);\n+  }\n+\n@@ -2360,0 +2429,1 @@\n+  CodeBlob* cb = _stream.cb();\n@@ -2364,3 +2434,8 @@\n-  \/\/ we never leave a compiled caller of an interpreted frame as the top frame in the chunk\n-  \/\/ as it makes detecting that situation and adjusting unextended_sp tricky\n-  if (num_frames == 1 && !_stream.is_done() && FKind::interpreted && _stream.is_compiled()) {\n+  \/\/ We never leave a compiled caller of an interpreted frame as the top frame in the chunk\n+  \/\/ as it makes detecting that situation and adjusting unextended_sp tricky. We also always\n+  \/\/ thaw the caller of a frame that needs_stack_repair, as it would otherwise complicate things:\n+  \/\/ - Regardless of whether the frame was extended or not, we would need to copy the right arg\n+  \/\/   size if its greater than the one given by the normal method signature (non-scalarized).\n+  \/\/ - If the frame was indeed extended, leaving its caller as the top frame would complicate walking\n+  \/\/   the chunk (we need unextended_sp, but we only have sp).\n+  if (num_frames == 1 && !_stream.is_done() && ((FKind::interpreted && _stream.is_compiled()) || (FKind::compiled && cb->as_nmethod_or_null()->needs_stack_repair()))) {\n@@ -2426,1 +2501,1 @@\n-inline void ThawBase::patch(frame& f, const frame& caller, bool bottom) {\n+inline void ThawBase::patch(frame& f, const frame& caller, bool bottom, bool augmented) {\n@@ -2431,1 +2506,1 @@\n-  } else {\n+  } else if (caller.is_compiled_frame()){\n@@ -2434,1 +2509,1 @@\n-    ContinuationHelper::Frame::patch_pc(caller, caller.raw_pc());\n+    ContinuationHelper::Frame::patch_pc(caller, caller.raw_pc(), augmented \/*callee_augmented*\/);\n@@ -2597,0 +2672,10 @@\n+  int fsize = 0;\n+  int added_argsize = 0;\n+  bool augmented = hf.was_augmented_on_entry(fsize);\n+  if (!augmented) {\n+    added_argsize = (is_bottom_frame || caller.is_interpreted_frame()) ? hf.compiled_frame_stack_argsize() : 0;\n+    fsize += added_argsize;\n+  }\n+  assert(!is_bottom_frame || !augmented, \"\");\n+\n+\n@@ -2600,1 +2685,3 @@\n-  frame f = new_stack_frame<ContinuationHelper::CompiledFrame>(hf, caller, is_bottom_frame);\n+  frame f = new_stack_frame<ContinuationHelper::CompiledFrame>(hf, caller, is_bottom_frame, augmented ? fsize - hf.cb()->frame_size() : 0);\n+  assert(f.cb()->frame_size() == (int)(caller.sp() - f.sp()), \"\");\n+\n@@ -2603,5 +2690,0 @@\n-\n-  const int added_argsize = (is_bottom_frame || caller.is_interpreted_frame()) ? hf.compiled_frame_stack_argsize() : 0;\n-  int fsize = ContinuationHelper::CompiledFrame::size(hf) + added_argsize;\n-  assert(fsize <= (int)(caller.unextended_sp() - f.unextended_sp()), \"\");\n-\n@@ -2620,1 +2702,1 @@\n-  patch(f, caller, is_bottom_frame);\n+  patch(f, caller, is_bottom_frame, augmented);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":105,"deletions":23,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  static const bool compiled = false;\n@@ -74,1 +75,1 @@\n-  static inline void patch_pc(const frame& f, address pc);\n+  static inline void patch_pc(const frame& f, address pc, bool callee_augmented = false);\n@@ -130,0 +131,2 @@\n+  static const bool compiled = true;\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1481,2 +1481,2 @@\n-                    FormatBuffer<1024>(\"#%d nmethod \" INTPTR_FORMAT \" for method J %s%s\", frame_no,\n-                                       p2i(nm),\n+                    FormatBuffer<1024>(\"#%d nmethod (%s %d) \" INTPTR_FORMAT \" for method J %s%s\", frame_no,\n+                                       nm->is_compiled_by_c1() ? \"c1\" : \"c2\", nm->frame_size(), p2i(nm),\n@@ -1492,0 +1492,5 @@\n+      CompiledEntrySignature ces(m);\n+      ces.compute_calling_conventions(false);\n+      const GrowableArray<SigEntry>* sig_cc = nm->is_compiled_by_c2() ? ces.sig_cc() : ces.sig();\n+      const VMRegPair* regs = nm->is_compiled_by_c2() ? ces.regs_cc() : ces.regs();\n+\n@@ -1493,21 +1498,0 @@\n-      int sizeargs = m->size_of_parameters();\n-\n-      BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);\n-      VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);\n-      {\n-        int sig_index = 0;\n-        if (!m->is_static()) {\n-          sig_bt[sig_index++] = T_OBJECT; \/\/ 'this'\n-        }\n-        for (SignatureStream ss(m->signature()); !ss.at_return_type(); ss.next()) {\n-          BasicType t = ss.type();\n-          assert(type2size[t] == 1 || type2size[t] == 2, \"size is 1 or 2\");\n-          sig_bt[sig_index++] = t;\n-          if (type2size[t] == 2) {\n-            sig_bt[sig_index++] = T_VOID;\n-          }\n-        }\n-        assert(sig_index == sizeargs, \"\");\n-      }\n-      int stack_arg_slots = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n-      assert(stack_arg_slots ==  nm->as_nmethod()->num_stack_arg_slots(false \/* rounded *\/) || nm->is_osr_method(), \"\");\n@@ -1517,1 +1501,1 @@\n-      for (SignatureStream ss(m->signature()); !ss.at_return_type(); ) {\n+      for (ExtendedSignature sig = ExtendedSignature(sig_cc, SigEntryFilter()); !sig.at_end(); ++sig) {\n@@ -1519,3 +1503,1 @@\n-        bool at_old_sp = false;\n-        BasicType t = (at_this ? T_OBJECT : ss.type());\n-        assert(t == sig_bt[sig_index], \"sigs in sync\");\n+        BasicType t = (*sig)._bt;\n@@ -1535,3 +1517,0 @@\n-        if (!at_this) {\n-          ss.next();\n-        }\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":9,"deletions":30,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  bool _callee_augmented;\n@@ -71,1 +72,1 @@\n-  inline intptr_t* unextended_sp() const { return frame_kind == ChunkFrames::Mixed ? _unextended_sp : _sp; }\n+  inline intptr_t* unextended_sp() const { return _unextended_sp; }\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  _callee_augmented = false;\n@@ -64,0 +65,2 @@\n+  } else {\n+    _unextended_sp = _sp;\n@@ -65,1 +68,0 @@\n-  DEBUG_ONLY(else _unextended_sp = nullptr;)\n@@ -89,0 +91,2 @@\n+  } else {\n+    _unextended_sp = _sp;\n@@ -90,1 +94,0 @@\n-  DEBUG_ONLY(else _unextended_sp = nullptr;)\n@@ -93,0 +96,1 @@\n+  _callee_augmented = false;\n@@ -219,0 +223,1 @@\n+  _callee_augmented = false;\n@@ -227,1 +232,8 @@\n-      _unextended_sp = is_interpreted() ? unextended_sp_for_interpreter_frame() : _sp;\n+      if (is_interpreted()) {\n+        _unextended_sp = unextended_sp_for_interpreter_frame();\n+      } else if (cb()->is_nmethod() && cb()->as_nmethod()->needs_stack_repair()) {\n+        _unextended_sp = frame::repair_sender_sp(cb()->as_nmethod(), _unextended_sp, (intptr_t**)(_sp - frame::sender_sp_offset));\n+        _callee_augmented = _unextended_sp != _sp;\n+      } else {\n+        _unextended_sp = _sp;\n+      }\n@@ -231,1 +243,7 @@\n-    _sp += cb()->frame_size();\n+    _sp = _unextended_sp + cb()->frame_size();\n+    if (cb()->is_nmethod() && cb()->as_nmethod()->needs_stack_repair()) {\n+      _unextended_sp = frame::repair_sender_sp(cb()->as_nmethod(), _unextended_sp, (intptr_t**)(_sp - frame::sender_sp_offset));\n+      _callee_augmented = _unextended_sp != _sp;\n+    } else {\n+      _unextended_sp = _sp;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,686 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @summary Test that Virtual Threads work well with Value Objects.\n+ * @library \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   TestVirtualThreads\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=compileonly,TestVirtualThreads*::*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=compileonly,TestVirtualThreads*::test*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=dontinline,*::test*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=dontinline,*::*Helper\n+ *                   TestVirtualThreads\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=exclude,*::*Helper\n+ *                   TestVirtualThreads\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                    -Xcomp -XX:CompileCommand=compileonly,TestVirtualThreads*::*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xcomp -XX:CompileCommand=compileonly,TestVirtualThreads*::test*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xcomp -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=dontinline,*::test*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xcomp -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=dontinline,*::*Helper\n+ *                   TestVirtualThreads\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xcomp -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=exclude,*::*Helper\n+ *                   TestVirtualThreads\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*::* -XX:CompileCommand=compileonly,TestVirtualThreads*::*\n+ *                   TestVirtualThreads 250000\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xcomp -XX:CompileCommand=dontinline,*::* -XX:CompileCommand=compileonly,TestVirtualThreads*::*\n+ *                   TestVirtualThreads 250000\n+ **\/\n+\n+import java.lang.reflect.Method;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.Random;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestVirtualThreads {\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    static final int COMP_LEVEL_SIMPLE = 1; \/\/ C1\n+    static final int COMP_LEVEL_FULL_OPTIMIZATION = 4; \/\/ C2 or JVMCI\n+    static final Random RAND = Utils.getRandomInstance();\n+    static final int PARK_DURATION = 10;\n+\n+    static value class SmallValue {\n+        int x1;\n+        int x2;\n+\n+        public SmallValue(int i) {\n+            this.x1 = i;\n+            this.x2 = i;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2;\n+        }\n+\n+        public void verify(String loc, int i) {\n+            if (x1 != i || x2 != i) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(SmallValue val, String loc, int i, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, i);\n+            }\n+        }\n+    }\n+\n+    \/\/ Large value class\n+    static value class LargeValue {\n+        int x1;\n+        int x2;\n+        int x3;\n+        int x4;\n+        int x5;\n+        int x6;\n+        int x7;\n+\n+        public LargeValue(int i) {\n+            this.x1 = i;\n+            this.x2 = i;\n+            this.x3 = i;\n+            this.x4 = i;\n+            this.x5 = i;\n+            this.x6 = i;\n+            this.x7 = i;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2 + \", x3 = \" + x3 + \", x4 = \" + x4 + \", x5 = \" + x5 +\n+                   \", x6 = \" + x6 + \", x7 = \" + x7;\n+        }\n+\n+        public void verify(String loc, int i) {\n+            if (x1 != i || x2 != i || x3 != i || x4 != i || x5 != i ||\n+                x6 != i || x7 != i) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(LargeValue val, String loc, int i, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, i);\n+            }\n+        }\n+    }\n+\n+    \/\/ Large value class with fields of different types\n+    static value class LargeValue2 {\n+        byte x1;\n+        short x2;\n+        int x3;\n+        long x4;\n+        double x5;\n+        boolean x6;\n+\n+        public LargeValue2(int i) {\n+            this.x1 = (byte)i;\n+            this.x2 = (short)i;\n+            this.x3 = i;\n+            this.x4 = i;\n+            this.x5 = i;\n+            this.x6 = (i % 2) == 0;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2 + \", x3 = \" + x3 + \", x4 = \" + x4 + \", x5 = \" + x5 +\n+                   \", x6 = \" + x6;\n+        }\n+\n+        public void verify(String loc, int i) {\n+            if (x1 != (byte)i || x2 != (short)i || x3 != i || x4 != i || x5 != i ||\n+                x6 != ((i % 2) == 0)) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(LargeValue2 val, String loc, int i, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, i);\n+            }\n+        }\n+    }\n+\n+    \/\/ Large value class with oops (and different number of fields) that requires stack extension\/repair\n+    static value class LargeValueWithOops {\n+        Object x1;\n+        Object x2;\n+        Object x3;\n+        Object x4;\n+        Object x5;\n+\n+        public LargeValueWithOops(Object obj) {\n+            this.x1 = obj;\n+            this.x2 = obj;\n+            this.x3 = obj;\n+            this.x4 = obj;\n+            this.x5 = obj;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2 + \", x3 = \" + x3 + \", x4 = \" + x4 + \", x5 = \" + x5;\n+        }\n+\n+        public void verify(String loc, Object obj) {\n+            if (x1 != obj || x2 != obj || x3 != obj || x4 != obj || x5 != obj) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for obj = \" + obj + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(LargeValueWithOops val, String loc, Object obj, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for obj = \" + obj + \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, obj);\n+            }\n+        }\n+    }\n+\n+    public static value class DoubleValue {\n+        double d;\n+\n+        public DoubleValue(double d) {\n+            this.d = d;\n+        }\n+\n+        public String toString() {\n+            return \"d = \" + d;\n+        }\n+\n+        public void verify(String loc, double d) {\n+            if (this.d != d) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for d = \" + d + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(DoubleValue val, String loc, double d, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for d = \" + d+ \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, d);\n+            }\n+        }\n+    }\n+\n+    public static value class DoubleValue2 {\n+        double d1;\n+        double d2;\n+        double d3;\n+        double d4;\n+        double d5;\n+\n+        public DoubleValue2(double d) {\n+            this.d1 = d;\n+            this.d2 = d + 1;\n+            this.d3 = d + 2;\n+            this.d4 = d + 3;\n+            this.d5 = d + 4;\n+        }\n+\n+        public String toString() {\n+            return \"d1 = \" + d1 + \", d2 = \" + d2 + \", d3 = \" + d3 + \", d4= \" + d4 + \", d5= \" + d5;\n+        }\n+\n+        public void verify(String loc, double d) {\n+            if (this.d1 != d || this.d2 != (d+1) || this.d3 != (d+2) || this.d4 != (d+3) || this.d5 != (d+4)) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for d = \" + d + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(DoubleValue2 val, String loc, double d, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for d = \" + d + \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, d);\n+            }\n+        }\n+    }\n+\n+    static abstract value class BaseValue {\n+        public abstract void verify(String loc, int i);\n+    };\n+\n+    static value class ValueExtendsAbstract extends BaseValue {\n+        int x1;\n+        int x2;\n+        int x3;\n+        int x4;\n+        int x5;\n+        int x6;\n+        int x7;\n+\n+        public ValueExtendsAbstract(int i) {\n+            this.x1 = i;\n+            this.x2 = i;\n+            this.x3 = i;\n+            this.x4 = i;\n+            this.x5 = i;\n+            this.x6 = i;\n+            this.x7 = i;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2 + \", x3 = \" + x3 + \", x4 = \" + x4 + \", x5 = \" + x5 +\n+                   \", x6 = \" + x6 + \", x7 = \" + x7;\n+        }\n+\n+        public void verify(String loc, int i) {\n+            if (x1 != i || x2 != i || x3 != i || x4 != i || x5 != i ||\n+                x6 != i || x7 != i) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + this);\n+            }\n+        }\n+    }\n+\n+    public static void dontInline() { }\n+\n+    public static SmallValue testSmall(SmallValue val, int i, boolean useNull, boolean park) {\n+        SmallValue.verify(val, \"entry\", i, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        SmallValue.verify(val, \"exit\", i, useNull);\n+        return val;\n+    }\n+\n+    public static SmallValue testSmallHelper(int i, boolean useNull, boolean park) {\n+        SmallValue val = useNull ? null : new SmallValue(i);\n+        val = testSmall(val, i, useNull, park);\n+        SmallValue.verify(val, \"helper\", i, useNull);\n+        return val;\n+    }\n+\n+    public static LargeValue testLarge(LargeValue val, int i, boolean useNull, boolean park) {\n+        LargeValue.verify(val, \"entry\", i, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValue.verify(val, \"exit\", i, useNull);\n+        return val;\n+    }\n+\n+    public static LargeValue testLargeHelper(int i, boolean useNull, boolean park) {\n+        LargeValue val = useNull ? null : new LargeValue(i);\n+        val = testLarge(val, i, useNull, park);\n+        LargeValue.verify(val, \"helper\", i, useNull);\n+        return val;\n+    }\n+\n+    \/\/ Version that already has values on the stack even before stack extensions\n+    public static LargeValue testLargeManyArgs(LargeValue val1, LargeValue val2, LargeValue val3, LargeValue val4, int i, boolean useNull, boolean park) {\n+        LargeValue.verify(val1, \"entry\", i, useNull);\n+        LargeValue.verify(val2, \"entry\", i + 1, useNull);\n+        LargeValue.verify(val3, \"entry\", i + 2, useNull);\n+        LargeValue.verify(val4, \"entry\", i + 3, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValue.verify(val1, \"exit\", i, useNull);\n+        LargeValue.verify(val2, \"exit\", i + 1, useNull);\n+        LargeValue.verify(val3, \"exit\", i + 2, useNull);\n+        LargeValue.verify(val4, \"exit\", i + 3, useNull);\n+        return val4;\n+    }\n+\n+    public static LargeValue testLargeManyArgsHelper(int i, boolean useNull, boolean park) {\n+        LargeValue val1 = useNull ? null : new LargeValue(i);\n+        LargeValue val2 = useNull ? null : new LargeValue(i + 1);\n+        LargeValue val3 = useNull ? null : new LargeValue(i + 2);\n+        LargeValue val4 = useNull ? null : new LargeValue(i + 3);\n+        LargeValue val = testLargeManyArgs(val1, val2, val3, val4, i, useNull, park);\n+        LargeValue.verify(val, \"helper\", i + 3, useNull);\n+        return val;\n+    }\n+\n+    public static LargeValue2 testLarge2(LargeValue2 val, int i, boolean useNull, boolean park) {\n+        LargeValue2.verify(val, \"entry\", i, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValue2.verify(val, \"exit\", i, useNull);\n+        return val;\n+    }\n+\n+    public static LargeValue2 testLarge2Helper(int i, boolean useNull, boolean park) {\n+        LargeValue2 val = useNull ? null : new LargeValue2(i);\n+        val = testLarge2(val, i, useNull, park);\n+        LargeValue2.verify(val, \"helper\", i, useNull);\n+        return val;\n+    }\n+\n+    \/\/ Version that already has values on the stack even before stack extensions\n+    public static LargeValue2 testLarge2ManyArgs(LargeValue2 val1, LargeValue2 val2, LargeValue2 val3, LargeValue2 val4, int i, boolean useNull, boolean park) {\n+        LargeValue2.verify(val1, \"entry\", i, useNull);\n+        LargeValue2.verify(val2, \"entry\", i + 1, useNull);\n+        LargeValue2.verify(val3, \"entry\", i + 2, useNull);\n+        LargeValue2.verify(val4, \"entry\", i + 3, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValue2.verify(val1, \"exit\", i, useNull);\n+        LargeValue2.verify(val2, \"exit\", i + 1, useNull);\n+        LargeValue2.verify(val3, \"exit\", i + 2, useNull);\n+        LargeValue2.verify(val4, \"exit\", i + 3, useNull);\n+        return val4;\n+    }\n+\n+    public static LargeValue2 testLarge2ManyArgsHelper(int i, boolean useNull, boolean park) {\n+        LargeValue2 val1 = useNull ? null : new LargeValue2(i);\n+        LargeValue2 val2 = useNull ? null : new LargeValue2(i + 1);\n+        LargeValue2 val3 = useNull ? null : new LargeValue2(i + 2);\n+        LargeValue2 val4 = useNull ? null : new LargeValue2(i + 3);\n+        LargeValue2 val = testLarge2ManyArgs(val1, val2, val3, val4, i, useNull, park);\n+        return val;\n+    }\n+\n+    public static ValueExtendsAbstract testExtendsAbstractHelper(int i, boolean park) {\n+        ValueExtendsAbstract val1 = new ValueExtendsAbstract(i);\n+        ValueExtendsAbstract val2 = new ValueExtendsAbstract(i + 1);\n+        ValueExtendsAbstract val3 = new ValueExtendsAbstract(i + 2);\n+        ValueExtendsAbstract val4 = new ValueExtendsAbstract(i + 3);\n+\n+        val1.verify(\"entry\", i);\n+        val2.verify(\"entry\", i + 1);\n+        val3.verify(\"entry\", i + 2);\n+        val4.verify(\"entry\", i + 3);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        val1.verify(\"exit\", i);\n+        val2.verify(\"exit\", i + 1);\n+        val3.verify(\"exit\", i + 2);\n+        val4.verify(\"exit\", i + 3);\n+        return val4;\n+    }\n+\n+    public static LargeValueWithOops testLargeValueWithOops(LargeValueWithOops val, Object obj, boolean useNull, boolean park) {\n+        LargeValueWithOops.verify(val, \"entry\", obj, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValueWithOops.verify(val, \"exit\", obj, useNull);\n+        return val;\n+    }\n+\n+    public static LargeValueWithOops testLargeValueWithOopsHelper(Object obj, boolean useNull, boolean park) {\n+        LargeValueWithOops val = useNull ? null : new LargeValueWithOops(obj);\n+        val = testLargeValueWithOops(val, obj, useNull, park);\n+        LargeValueWithOops.verify(val, \"helper\", obj, useNull);\n+        return val;\n+    }\n+\n+    \/\/ Version that already has values on the stack even before stack extensions\n+    public static LargeValueWithOops testLargeValueWithOops2(LargeValueWithOops val1, LargeValueWithOops val2, LargeValueWithOops val3, LargeValueWithOops val4, LargeValueWithOops val5, Object obj, boolean useNull, boolean park) {\n+        LargeValueWithOops.verify(val1, \"entry\", obj, useNull);\n+        LargeValueWithOops.verify(val2, \"entry\", obj, useNull);\n+        LargeValueWithOops.verify(val3, \"entry\", obj, useNull);\n+        LargeValueWithOops.verify(val4, \"entry\", obj, useNull);\n+        LargeValueWithOops.verify(val5, \"entry\", obj, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValueWithOops.verify(val1, \"exit\", obj, useNull);\n+        LargeValueWithOops.verify(val2, \"exit\", obj, useNull);\n+        LargeValueWithOops.verify(val3, \"exit\", obj, useNull);\n+        LargeValueWithOops.verify(val4, \"exit\", obj, useNull);\n+        LargeValueWithOops.verify(val5, \"exit\", obj, useNull);\n+        return val5;\n+    }\n+\n+    public static LargeValueWithOops testLargeValueWithOops2Helper(Object obj, boolean useNull, boolean park) {\n+        LargeValueWithOops val1 = useNull ? null : new LargeValueWithOops(obj);\n+        LargeValueWithOops val2 = useNull ? null : new LargeValueWithOops(obj);\n+        LargeValueWithOops val3 = useNull ? null : new LargeValueWithOops(obj);\n+        LargeValueWithOops val4 = useNull ? null : new LargeValueWithOops(obj);\n+        LargeValueWithOops val5 = useNull ? null : new LargeValueWithOops(obj);\n+        LargeValueWithOops val = testLargeValueWithOops2(val1, val2, val3, val4, val5, obj, useNull, park);\n+        LargeValueWithOops.verify(val, \"helper\", obj, useNull);\n+        return val;\n+    }\n+\n+    \/\/ Pass via fields to not affect number of arguments\n+    static double testDoubleValueDP;\n+    static boolean testDoubleValueUseNullP;\n+    static boolean testDoubleValueParkP;\n+    static double testDoubleValueDV;\n+    static boolean testDoubleValueUseNullV;\n+    static boolean testDoubleValueParkV;\n+\n+    \/\/ This method needs less stack space when scalarized because (some of) the arguments can then be passed in floating point registers\n+    public static DoubleValue testDoubleValue(DoubleValue val1, DoubleValue val2, DoubleValue val3, DoubleValue val4, DoubleValue val5, DoubleValue val6, DoubleValue val7) {\n+        boolean isVirtual = Thread.currentThread().isVirtual();\n+        double d = isVirtual ? testDoubleValueDV : testDoubleValueDP;\n+        boolean useNull = isVirtual ? testDoubleValueUseNullV : testDoubleValueUseNullP;\n+        boolean park = isVirtual ? testDoubleValueParkV : testDoubleValueParkP;\n+\n+        DoubleValue.verify(val1, \"entry\", d, useNull);\n+        DoubleValue.verify(val2, \"entry\", d + 1, useNull);\n+        DoubleValue.verify(val3, \"entry\", d + 2, useNull);\n+        DoubleValue.verify(val4, \"entry\", d + 3, useNull);\n+        DoubleValue.verify(val5, \"entry\", d + 4, useNull);\n+        DoubleValue.verify(val6, \"entry\", d + 4, useNull);\n+        DoubleValue.verify(val7, \"entry\", d + 4, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        DoubleValue.verify(val1, \"exit\", d, useNull);\n+        DoubleValue.verify(val2, \"exit\", d + 1, useNull);\n+        DoubleValue.verify(val3, \"exit\", d + 2, useNull);\n+        DoubleValue.verify(val4, \"exit\", d + 3, useNull);\n+        DoubleValue.verify(val5, \"exit\", d + 4, useNull);\n+        DoubleValue.verify(val6, \"exit\", d + 4, useNull);\n+        DoubleValue.verify(val7, \"exit\", d + 4, useNull);\n+        return val1;\n+    }\n+\n+    public static DoubleValue testDoubleValueHelper(double d, boolean useNull, boolean park) {\n+        if (Thread.currentThread().isVirtual()) {\n+            testDoubleValueDV = d;\n+            testDoubleValueUseNullV = useNull;\n+            testDoubleValueParkV = park;\n+        } else {\n+            testDoubleValueDP = d;\n+            testDoubleValueUseNullP = useNull;\n+            testDoubleValueParkP = park;\n+        }\n+\n+        DoubleValue val1 = useNull ? null : new DoubleValue(d);\n+        DoubleValue val2 = useNull ? null : new DoubleValue(d + 1);\n+        DoubleValue val3 = useNull ? null : new DoubleValue(d + 2);\n+        DoubleValue val4 = useNull ? null : new DoubleValue(d + 3);\n+        DoubleValue val5 = useNull ? null : new DoubleValue(d + 4);\n+        DoubleValue val6 = useNull ? null : new DoubleValue(d + 4);\n+        DoubleValue val7 = useNull ? null : new DoubleValue(d + 4);\n+        val1 = testDoubleValue(val1, val2, val3, val4, val5, val6, val7);\n+        DoubleValue.verify(val1, \"helper\", d, useNull);\n+        return val1;\n+    }\n+\n+    public static DoubleValue2 recurseTestDoubleValue2(double d, boolean useNull, boolean park, int depth) {\n+        if (depth > 0) {\n+            DoubleValue2 val = recurseTestDoubleValue2(d, useNull, park, depth - 1);\n+            DoubleValue2.verify(val, \"entry\", d, useNull);\n+            dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+            DoubleValue2.verify(val, \"exit\", d, useNull);\n+            return val;\n+        } else {\n+            if (park) {\n+                LockSupport.parkNanos(PARK_DURATION);\n+            }\n+            return useNull ? null : new DoubleValue2(d);\n+        }\n+    }\n+\n+    public static DoubleValue2 testDoubleValue2Helper(double d, boolean useNull, boolean park) {\n+        DoubleValue2 val = recurseTestDoubleValue2(d, useNull, park, 4);\n+        DoubleValue2.verify(val, \"helper\", d, useNull);\n+        return val;\n+    }\n+\n+    static class GarbageProducerThread extends Thread {\n+        public void run() {\n+            for (;;) {\n+                \/\/ Produce some garbage and then let the GC do its work\n+                Object[] arrays = new Object[1024];\n+                for (int i = 0; i < arrays.length; i++) {\n+                    arrays[i] = new int[1024];\n+                }\n+                System.gc();\n+            }\n+        }\n+    }\n+\n+    public static void startTest(CountDownLatch cdl, Thread.Builder builder, int iterations) {\n+        builder.start(() -> {\n+            try {\n+                \/\/ Trigger compilation\n+                boolean isVirtual = Thread.currentThread().isVirtual();\n+                for (int i = 0; i < iterations; i++) {\n+                    boolean park = (i % 1000) == 0;\n+                    boolean useNull = RAND.nextBoolean();\n+                    Object val = useNull ? null : new SmallValue(i);\n+                    SmallValue.verify(testSmallHelper(i, useNull, park), \"return\", i, useNull);\n+                    LargeValue.verify(testLargeHelper(i, useNull, park), \"return\", i, useNull);\n+                    LargeValue.verify(testLargeManyArgsHelper(i, useNull, park), \"return\", i + 3, useNull);\n+                    LargeValue2.verify(testLarge2Helper(i, useNull, park), \"return\", i, useNull);\n+                    LargeValue2.verify(testLarge2ManyArgsHelper(i, useNull, park), \"return\", i + 3, useNull);\n+                    testExtendsAbstractHelper(i, park).verify(\"return\", i + 3);\n+                    LargeValueWithOops.verify(testLargeValueWithOopsHelper(val, useNull, park), \"return\", val, useNull);\n+                    LargeValueWithOops.verify(testLargeValueWithOops2Helper(val, useNull, park), \"return\", val, useNull);\n+                    DoubleValue.verify(testDoubleValueHelper(i, useNull, park), \"return\", i, useNull);\n+                    DoubleValue2.verify(testDoubleValue2Helper(i, useNull, park), \"return\", i, useNull);\n+                    if (i % 1000 == 0) {\n+                        System.out.format(\"%s => %s %d of %d%n\", Instant.now(), isVirtual ? \"Virtual: \" : \"Platform:\", i, iterations);\n+                    }\n+                }\n+                cdl.countDown();\n+            } catch (Exception e) {\n+                System.out.println(\"Exception thrown: \" + e);\n+                e.printStackTrace(System.out);\n+                System.exit(1);\n+            }\n+        });\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Sometimes, exclude some methods from compilation with C1 and\/or C2 to stress test the calling convention\n+        if (Utils.getRandomInstance().nextBoolean()) {\n+            ArrayList<Method> methods = new ArrayList<Method>();\n+            Collections.addAll(methods, SmallValue.class.getDeclaredMethods());\n+            Collections.addAll(methods, LargeValue.class.getDeclaredMethods());\n+            Collections.addAll(methods, LargeValue2.class.getDeclaredMethods());\n+            Collections.addAll(methods, LargeValueWithOops.class.getDeclaredMethods());\n+            Collections.addAll(methods, DoubleValue.class.getDeclaredMethods());\n+            Collections.addAll(methods, TestVirtualThreads.class.getDeclaredMethods());\n+            System.out.println(\"Excluding methods from C1 compilation:\");\n+            for (Method m : methods) {\n+                if (Utils.getRandomInstance().nextBoolean()) {\n+                    System.out.println(m);\n+                    WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_SIMPLE, false);\n+                }\n+            }\n+            System.out.println(\"Excluding methods from C2 compilation:\");\n+            for (Method m : methods) {\n+                if (Utils.getRandomInstance().nextBoolean()) {\n+                    System.out.println(m);\n+                    WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false);\n+                }\n+            }\n+        }\n+\n+        \/\/ Start another thread that does some allocations and calls System.gc()\n+        \/\/ to trigger GCs while virtual threads are parked.\n+        Thread garbage_producer = new GarbageProducerThread();\n+        garbage_producer.setDaemon(true);\n+        garbage_producer.start();\n+\n+        int iterations = args.length > 0 ? Integer.parseInt(args[0]) : 300_000;\n+        if (Platform.isDebugBuild()) {\n+            iterations \/= 4;\n+        }\n+        CountDownLatch cdlPlatform = new CountDownLatch(1);\n+        CountDownLatch cdlVirtual = new CountDownLatch(1);\n+        startTest(cdlPlatform, Thread.ofPlatform(), iterations);\n+        startTest(cdlVirtual, Thread.ofVirtual(), iterations);\n+        cdlPlatform.await();\n+        cdlVirtual.await();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestVirtualThreads.java","additions":686,"deletions":0,"binary":false,"changes":686,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+ * @enablePreview\n@@ -50,0 +51,1 @@\n+ * @enablePreview\n@@ -86,0 +88,1 @@\n+    static final Random RAND = Utils.getRandomInstance();\n@@ -113,1 +116,1 @@\n-        if (RANDOM) testRandom(System.currentTimeMillis(), 50);\n+        if (RANDOM) testRandom(RAND.nextLong(), 50);\n@@ -119,2 +122,2 @@\n-        CALL_I_INT, CALL_I_DBL, CALL_I_MANY,\n-        CALL_C_INT, CALL_C_DBL, CALL_C_MANY,\n+        CALL_I_INT, CALL_I_DBL, CALL_I_MANY, CALL_I_VAL,\n+        CALL_C_INT, CALL_C_DBL, CALL_C_MANY, CALL_C_VAL,\n@@ -283,1 +286,1 @@\n-    static final Op[] WARMUP_TRACE = {Op.MH_C_INT, Op.MH_C_MANY, Op.REF_C_INT, Op.REF_C_MANY, Op.CALL_C_INT};\n+    static final Op[] WARMUP_TRACE = {Op.MH_C_INT, Op.MH_C_MANY, Op.REF_C_INT, Op.REF_C_MANY, Op.CALL_C_INT, Op.CALL_C_VAL};\n@@ -602,0 +605,112 @@\n+    \/\/\/\/ Value Classes\n+\n+    static abstract value class BaseValue {\n+        public abstract int res();\n+    };\n+\n+    static value class SmallValue extends BaseValue {\n+        int x1;\n+        int x2;\n+\n+        public SmallValue(int i) {\n+            x1 = i;\n+            x2 = i;\n+        }\n+\n+        public int res() {\n+            return x1 + x2;\n+        }\n+    };\n+\n+    static value class LargeValue extends BaseValue {\n+        int x1;\n+        int x2;\n+        int x3;\n+        int x4;\n+        int x5;\n+        int x6;\n+        int x7;\n+\n+        public LargeValue(int i) {\n+            x1 = i;\n+            x2 = i;\n+            x3 = i;\n+            x4 = i;\n+            x5 = i;\n+            x6 = i;\n+            x7 = i;\n+        }\n+\n+        public int res() {\n+            return x1 + x2 + x3 + x4 + x5 + x6 + x7;\n+        }\n+    };\n+\n+    static value class OopsValue extends BaseValue {\n+        Object x1;\n+        Object x2;\n+        Object x3;\n+        Object x4;\n+        Object x5;\n+        int x6;\n+\n+        public OopsValue(int i) {\n+            x1 = new Object();\n+            x2 = new Object();\n+            x3 = new Object();\n+            x4 = new Object();\n+            x5 = new Object();\n+            x6 = i;\n+        }\n+\n+        public int res() {\n+            return x6;\n+        }\n+    };\n+\n+    public static value class DoubleValue extends BaseValue {\n+        double d1;\n+        double d2;\n+        double d3;\n+        double d4;\n+        double d5;\n+        double d6;\n+        double d7;\n+\n+        public DoubleValue(double d) {\n+            d1 = d;\n+            d2 = d + 1;\n+            d3 = d + 2;\n+            d4 = d + 3;\n+            d5 = d + 4;\n+            d6 = d + 4;\n+            d7 = d + 4;\n+        }\n+\n+        public int res() {\n+            return (int)(d1 + d2 + d3 + d4 + d5 + d6 + d7);\n+        }\n+    };\n+\n+    static value class MixedValue extends BaseValue {\n+        byte x1;\n+        short x2;\n+        int x3;\n+        long x4;\n+        double x5;\n+        boolean x6;\n+\n+        public MixedValue(int i) {\n+            x1 = (byte)i;\n+            x2 = (short)i;\n+            x3 = i;\n+            x4 = i;\n+            x5 = i;\n+            x6 = (i % 2) == 0;\n+        }\n+\n+        public int res() {\n+            return (int)x1 + (int)x2 + (int)x3 + (int)x4 + (int)x5 + (x6 ? 1 : 0);\n+        }\n+    };\n+\n@@ -637,0 +752,2 @@\n+    static final Class<?>[] val_sig = new Class<?>[]{int.class, SmallValue.class,\n+        LargeValue.class, OopsValue.class, DoubleValue.class, MixedValue.class};\n@@ -662,0 +779,2 @@\n+            method.put(Op.CALL_I_VAL,  Fuzz.class.getDeclaredMethod(\"int_val\", val_sig));\n+            method.put(Op.CALL_C_VAL,  Fuzz.class.getDeclaredMethod(\"com_val\", val_sig));\n@@ -706,0 +825,5 @@\n+        SmallValue sv = new SmallValue(res);\n+        LargeValue lv = new LargeValue(res);\n+        OopsValue ov = new OopsValue(res);\n+        DoubleValue dv = new DoubleValue((double)res);\n+        MixedValue mv = new MixedValue(res);\n@@ -717,0 +841,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -743,0 +869,5 @@\n+        SmallValue sv = new SmallValue(x);\n+        LargeValue lv = new LargeValue(x);\n+        OopsValue ov = new OopsValue(x);\n+        DoubleValue dv = new DoubleValue((double)x);\n+        MixedValue mv = new MixedValue(x);\n@@ -754,0 +885,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -780,0 +913,5 @@\n+        SmallValue sv = new SmallValue(x);\n+        LargeValue lv = new LargeValue(x);\n+        OopsValue ov = new OopsValue(x);\n+        DoubleValue dv = new DoubleValue((double)x);\n+        MixedValue mv = new MixedValue(x);\n@@ -791,0 +929,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -817,0 +957,5 @@\n+        SmallValue sv = new SmallValue(x1);\n+        LargeValue lv = new LargeValue(x1);\n+        OopsValue ov = new OopsValue(x1);\n+        DoubleValue dv = new DoubleValue((double)x1);\n+        MixedValue mv = new MixedValue(x1);\n@@ -828,0 +973,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -854,0 +1001,5 @@\n+        SmallValue sv = new SmallValue(x1);\n+        LargeValue lv = new LargeValue(x1);\n+        OopsValue ov = new OopsValue(x1);\n+        DoubleValue dv = new DoubleValue((double)x1);\n+        MixedValue mv = new MixedValue(x1);\n@@ -865,0 +1017,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -882,0 +1036,104 @@\n+    @DontInline\n+    BaseValue int_val(final int depth, SmallValue x1, LargeValue x2, OopsValue x3, DoubleValue x4, MixedValue x5) {\n+        int res = x1.res();\n+\n+        int x11 = (int)res, x12 = (int)res, x13 = (int)res, x14 = (int)res;\n+        double d1 = (double)res, d2 = (double)res, d3 = (double)res, d4 = (double)res;\n+        long l1 = (long)res, l2 = (long)res, l3 = (long)res, l4 = (long)res;\n+        float f1 = (float)res, f2 = (float)res, f3 = (float)res, f4 = (float)res;\n+        Object o1 = res, o2 = res, o3 = res, o4 = res;\n+        SmallValue sv = new SmallValue(res);\n+        LargeValue lv = new LargeValue(res);\n+        OopsValue ov = new OopsValue(res);\n+        DoubleValue dv = new DoubleValue((double)res);\n+        MixedValue mv = new MixedValue(res);\n+\n+        for (int c = 1, index0 = index; c > 0; c--, maybeResetIndex(index0)) { \/\/ index0 is the index to which we return when we loop\n+            switch (next(c)) {\n+            case THROW -> throwException();\n+            case LOOP  -> { c += 2; index0 = index; }\n+            case YIELD -> { preYield(); boolean y = Continuation.yield(SCOPE); postYield(y); c++; }\n+            case DONE  -> { break; }\n+            case CALL_I_INT  -> res += int_int(depth+1, (int)res);\n+            case CALL_C_INT  -> res += com_int(depth+1, (int)res);\n+            case CALL_I_DBL  -> res += (int)int_dbl(depth+1, res);\n+            case CALL_C_DBL  -> res += (int)com_dbl(depth+1, res);\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_I_PIN  -> res += int_pin(depth+1, (int)res);\n+            case CALL_C_PIN  -> res += com_pin(depth+1, (int)res);\n+            case CALL_I_MANY -> res += int_mny(depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4);\n+            case CALL_C_MANY -> res += com_mny(depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4);\n+            case CALL_I_CTCH -> {try { res += int_int(depth+1, (int)res); } catch (FuzzException e) {}}\n+            case CALL_C_CTCH -> {try { res += com_int(depth+1, (int)res); } catch (FuzzException e) {}}\n+            case MH_I_INT, MH_C_INT     -> {try { res += (int)handle(current()).invokeExact(this, depth+1, (int)res);  } catch (Throwable e) { rethrow(e); }}\n+            case MH_I_MANY, MH_C_MANY   -> {try { res += (int)handle(current()).invokeExact(this, depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4); } catch (Throwable e) { rethrow(e); }}\n+            case REF_I_INT,  REF_C_INT  -> {try { res += (int)method(current()).invoke(this, depth+1, (int)res); } catch (InvocationTargetException e) { rethrow(e.getCause()); } catch (IllegalAccessException e) { assert false; }}\n+            case REF_I_MANY, REF_C_MANY -> {try { res += (int)method(current()).invoke(this, depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4); } catch (InvocationTargetException e) { rethrow(e.getCause()); } catch (IllegalAccessException e) { assert false; }}\n+            default -> throw new AssertionError(\"Unknown op: \" + current());\n+            }\n+        }\n+\n+        int positiveRes = (res == Integer.MIN_VALUE) ? Integer.MAX_VALUE : Math.abs(res);\n+        switch (positiveRes % 5) {\n+            case 0 -> { return log(new SmallValue(res)); }\n+            case 1 -> { return log(new LargeValue(res)); }\n+            case 2 -> { return log(new OopsValue(res)); }\n+            case 3 -> { return log(new DoubleValue((double)res)); }\n+            case 4 -> { return log(new MixedValue(res)); }\n+            default -> throw new AssertionError(\"Invalid case\");\n+        }\n+    }\n+\n+    @DontInline\n+    BaseValue com_val(final int depth, SmallValue x1, LargeValue x2, OopsValue x3, DoubleValue x4, MixedValue x5) {\n+        int res = x1.res();\n+\n+        int x11 = (int)res, x12 = (int)res, x13 = (int)res, x14 = (int)res;\n+        double d1 = (double)res, d2 = (double)res, d3 = (double)res, d4 = (double)res;\n+        long l1 = (long)res, l2 = (long)res, l3 = (long)res, l4 = (long)res;\n+        float f1 = (float)res, f2 = (float)res, f3 = (float)res, f4 = (float)res;\n+        Object o1 = res, o2 = res, o3 = res, o4 = res;\n+        SmallValue sv = new SmallValue(res);\n+        LargeValue lv = new LargeValue(res);\n+        OopsValue ov = new OopsValue(res);\n+        DoubleValue dv = new DoubleValue((double)res);\n+        MixedValue mv = new MixedValue(res);\n+\n+        for (int c = 1, index0 = index; c > 0; c--, maybeResetIndex(index0)) { \/\/ index0 is the index to which we return when we loop\n+            switch (next(c)) {\n+            case THROW -> throwException();\n+            case LOOP  -> { c += 2; index0 = index; }\n+            case YIELD -> { preYield(); boolean y = Continuation.yield(SCOPE); postYield(y); c++; }\n+            case DONE  -> { break; }\n+            case CALL_I_INT  -> res += int_int(depth+1, (int)res);\n+            case CALL_C_INT  -> res += com_int(depth+1, (int)res);\n+            case CALL_I_DBL  -> res += (int)int_dbl(depth+1, res);\n+            case CALL_C_DBL  -> res += (int)com_dbl(depth+1, res);\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_I_PIN  -> res += int_pin(depth+1, (int)res);\n+            case CALL_C_PIN  -> res += com_pin(depth+1, (int)res);\n+            case CALL_I_MANY -> res += int_mny(depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4);\n+            case CALL_C_MANY -> res += com_mny(depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4);\n+            case CALL_I_CTCH -> {try { res += int_int(depth+1, (int)res); } catch (FuzzException e) {}}\n+            case CALL_C_CTCH -> {try { res += com_int(depth+1, (int)res); } catch (FuzzException e) {}}\n+            case MH_I_INT, MH_C_INT     -> {try { res += (int)handle(current()).invokeExact(this, depth+1, (int)res);  } catch (Throwable e) { rethrow(e); }}\n+            case MH_I_MANY, MH_C_MANY   -> {try { res += (int)handle(current()).invokeExact(this, depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4); } catch (Throwable e) { rethrow(e); }}\n+            case REF_I_INT,  REF_C_INT  -> {try { res += (int)method(current()).invoke(this, depth+1, (int)res); } catch (InvocationTargetException e) { rethrow(e.getCause()); } catch (IllegalAccessException e) { assert false; }}\n+            case REF_I_MANY, REF_C_MANY -> {try { res += (int)method(current()).invoke(this, depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4); } catch (InvocationTargetException e) { rethrow(e.getCause()); } catch (IllegalAccessException e) { assert false; }}\n+            default -> throw new AssertionError(\"Unknown op: \" + current());\n+            }\n+        }\n+\n+        int positiveRes = (res == Integer.MIN_VALUE) ? Integer.MAX_VALUE : Math.abs(res);\n+        switch (positiveRes % 5) {\n+            case 0 -> { return log(new SmallValue(res)); }\n+            case 1 -> { return log(new LargeValue(res)); }\n+            case 2 -> { return log(new OopsValue(res)); }\n+            case 3 -> { return log(new DoubleValue((double)res)); }\n+            case 4 -> { return log(new MixedValue(res)); }\n+            default -> throw new AssertionError(\"Invalid case\");\n+        }\n+    }\n+\n@@ -891,0 +1149,5 @@\n+        SmallValue sv = new SmallValue(x);\n+        LargeValue lv = new LargeValue(x);\n+        OopsValue ov = new OopsValue(x);\n+        DoubleValue dv = new DoubleValue((double)x);\n+        MixedValue mv = new MixedValue(x);\n@@ -904,0 +1167,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -932,0 +1197,5 @@\n+        SmallValue sv = new SmallValue(x);\n+        LargeValue lv = new LargeValue(x);\n+        OopsValue ov = new OopsValue(x);\n+        DoubleValue dv = new DoubleValue((double)x);\n+        MixedValue mv = new MixedValue(x);\n@@ -945,0 +1215,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -972,0 +1244,5 @@\n+        SmallValue sv = new SmallValue(x1);\n+        LargeValue lv = new LargeValue(x1);\n+        OopsValue ov = new OopsValue(x1);\n+        DoubleValue dv = new DoubleValue((double)x1);\n+        MixedValue mv = new MixedValue(x1);\n@@ -983,0 +1260,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -1008,0 +1287,5 @@\n+        SmallValue sv = new SmallValue(x1);\n+        LargeValue lv = new LargeValue(x1);\n+        OopsValue ov = new OopsValue(x1);\n+        DoubleValue dv = new DoubleValue((double)x1);\n+        MixedValue mv = new MixedValue(x1);\n@@ -1019,0 +1303,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":290,"deletions":4,"binary":false,"changes":294,"status":"modified"}]}