{"files":[{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @ignore\n@@ -31,1 +31,0 @@\n-\/\/ see JDK-8316628\n@@ -41,1 +40,2 @@\n-        \/\/ ALL fields are assigned now.\n+        \/\/ all fields are assigned now, but we need a explicit `super()` invocation before accessing `this`\n+        super();\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CanonicalCtorTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * @ignore\n+ * @enablePreview\n@@ -18,1 +18,1 @@\n-        CheckSynchronized.ref csr = cs;\n+        CheckSynchronized csr = cs;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckSynchronized.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-CheckSynchronized.java:19:9: compiler.err.type.found.req: CheckSynchronized.ref, (compiler.misc.type.req.identity)\n+CheckSynchronized.java:19:9: compiler.err.type.found.req: CheckSynchronized, (compiler.misc.type.req.identity)\n@@ -7,0 +7,2 @@\n+- compiler.note.preview.filename: CheckSynchronized.java, DEFAULT\n+- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckSynchronized.out","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,13 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8279839\n- * @summary [lworld] Javac has started incorrectly accepting native as a modifer for classes\n- * @compile\/fail\/ref=NativeModifierTest.out -XDrawDiagnostics -XDdev NativeModifierTest.java\n- *\/\n-\n-public native class NativeModifierTest {\n-\n-    public native class NativeClassIsNotAThing {\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/NativeModifierTest.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-NativeModifierTest.java:8:15: compiler.err.mod.not.allowed.here: native\n-NativeModifierTest.java:10:19: compiler.err.mod.not.allowed.here: native\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/NativeModifierTest.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8287713\n- * @summary [lw4] Javac incorrectly flags subclasses as being ACC_IDENTITY classes.\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @enablePreview\n- * @run main NoAutoInheritanceOfIdentityFlagBit\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-\n-public class NoAutoInheritanceOfIdentityFlagBit { \/\/ ACC_IDENTITY not a value class\n-\n-    abstract class A {}  \/\/ ACC_IDENTITY not a value class\n-\n-    static abstract class B {}  \/\/ ACC_IDENTITY not a value class\n-\n-    static abstract class C {} \/\/ ACC_IDENTITY not a value class\n-\n-    static abstract value class D {} \/\/ No ACC_IDENTITY since an express abstract value class.\n-\n-    static value class E {} \/\/ No ACC_IDENTITY since an express concrete value class.\n-\n-    static abstract class F extends C {} \/\/ ACC_IDENTITY no value class\n-\n-    public static void main(String[] args) throws Exception {\n-        ClassFile cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$A.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$B.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$C.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$D.class\"));\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n-\n-        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$E.class\"));\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n-\n-        cls = ClassFile.read(NoAutoInheritanceOfIdentityFlagBit.class.getResourceAsStream(\"NoAutoInheritanceOfIdentityFlagBit$F.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/NoAutoInheritanceOfIdentityFlagBit.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8287763\n- * @summary [lw4] Javac does not implement the spec for non-trivial constructors in toto\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @run main NontrivialCtorInducedIdentity\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-\n-public class NontrivialCtorInducedIdentity {\n-\n-    public static abstract class A0 { \/\/ ACC_IDENTITY\n-        public A0() {\n-            super();\n-        }\n-    }\n-\n-    public static abstract class A1 { \/\/ ACC_IDENTITY\n-        private A1() {}\n-    }\n-\n-    public static abstract class A2 { \/\/ ACC_IDENTITY\n-        public <T> A2() {}\n-    }\n-\n-    public static abstract class A3 { \/\/ ACC_IDENTITY\n-        public A3() throws RuntimeException {}\n-    }\n-\n-    public static abstract class A4 { \/\/ ACC_IDENTITY\n-        public A4(int x) {}\n-    }\n-\n-    public static abstract class A5 { \/\/ ACC_IDENTITY\n-        public A5() {\n-            System.out.println(\"Bodied constructor\");\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        ClassFile cls = ClassFile.read(NontrivialCtorInducedIdentity.class.getResourceAsStream(\"NontrivialCtorInducedIdentity$A0.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(NontrivialCtorInducedIdentity.class.getResourceAsStream(\"NontrivialCtorInducedIdentity$A1.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(NontrivialCtorInducedIdentity.class.getResourceAsStream(\"NontrivialCtorInducedIdentity$A2.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(NontrivialCtorInducedIdentity.class.getResourceAsStream(\"NontrivialCtorInducedIdentity$A3.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(NontrivialCtorInducedIdentity.class.getResourceAsStream(\"NontrivialCtorInducedIdentity$A4.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(NontrivialCtorInducedIdentity.class.getResourceAsStream(\"NontrivialCtorInducedIdentity$A5.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/NontrivialCtorInducedIdentity.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8280194\n- * @summary Abstract classes that allow value subclasses should NOT be marked ACC_IDENTITY\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @enablePreview\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-\n-public class PermitsValueTest {\n-\n-    static abstract class A0 extends PermitsValueTest {\n-       \/\/ ACC_IDENTITY\n-    }\n-\n-    static abstract class A1 {\n-       \/\/ ACC_IDENTITY\n-    }\n-\n-    static abstract class A2 {\n-        int f; \/\/ ACC_IDENTITY as it declares an instance field.\n-    }\n-\n-    static abstract class A3 extends A2 {\n-        \/\/ ACC_IDENTITY\n-    }\n-\n-    static abstract class A4 {\n-        \/\/ ACC_IDENTITY\n-        {\n-            System.out.println(\"initializer block\");\n-        }\n-    }\n-\n-    static abstract class A5 extends A4 {\n-        \/\/ ACC_IDENTITY\n-    }\n-\n-    static abstract class A6 {\n-        \/\/ ACC_IDENTITY\n-        synchronized void foo() {\n-        }\n-    }\n-\n-    static abstract class A7 extends A6 {\n-        \/\/ ACC_IDENTITY\n-    }\n-\n-    abstract class A8 {\n-        \/\/ ACC_IDENTITY\n-    }\n-\n-    static abstract class A9 {\n-        \/\/ ACC_IDENTITY\n-        A9(int x) {}\n-    }\n-\n-    static abstract class A10 {\n-        \/\/ ACC_IDENTITY\n-        A10() {\n-            super();\n-        }\n-    }\n-    static abstract class A10_Alt {\n-        \/\/ ACC_IDENTITY\n-        A10_Alt() {\n-            super();\n-            System.out.println(\"\");\n-        }\n-    }\n-    static abstract value class A11 { \/\/ ACC_IDENTITY.\n-        static int f; \/\/ static field is OK.\n-        static {\n-            System.out.println(\"Static initializer block is OK\");\n-        }\n-        A11() {\n-            \/\/ empty constructor is OK.\n-        }\n-        static synchronized void foo() {\n-            \/\/ static method may be synchronized.\n-        }\n-        {\n-            \/\/ empty init block is OK.\n-        }\n-    }\n-\n-    static abstract value class A12 extends A11 {\n-        \/\/ !ACC_IDENTITY\n-    }\n-\n-    static abstract class A13 extends A12 {\n-        \/\/ ACC_IDENTITY\n-    }\n-\n-\n-    public static void main(String[] args) throws Exception {\n-        ClassFile cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A0.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A1.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A2.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A3.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A4.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A5.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A6.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A7.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A8.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A9.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A10.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A10_Alt.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-\n-\n-        \/\/ The following two classes are proper non-identity classes\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A11.class\"));\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should not be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A12.class\"));\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should not be set!\");\n-\n-        cls = ClassFile.read(PermitsValueTest.class.getResourceAsStream(\"PermitsValueTest$A13.class\"));\n-        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/PermitsValueTest.java","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -34,0 +34,1 @@\n+ * @enablePreview\n@@ -35,1 +36,0 @@\n- * @ignore Verifier error\n@@ -95,0 +95,1 @@\n+                .options(\"--enable-preview\", \"-source\", String.valueOf(Runtime.version().feature()))\n@@ -102,0 +103,1 @@\n+                .vmOptions(\"--enable-preview\")\n@@ -117,0 +119,1 @@\n+                .options(\"--enable-preview\", \"-source\", String.valueOf(Runtime.version().feature()))\n@@ -124,0 +127,1 @@\n+                    .vmOptions(\"--enable-preview\")\n@@ -134,0 +138,1 @@\n+                    .vmOptions(\"--enable-preview\")\n@@ -139,5 +144,3 @@\n-    public void testAbstractClassCompatibility(Path base) throws Exception {\n-        \/* If one of the identity or value modifiers is added to an abstract class, a pre-existing binary that attempts\n-         * to extend the class may fail to load. Specifically, if the subclass has an incompatible identity or value\n-         * modifier, or implements an interface with an incompatible identity or value modifier, class loading will fail\n-         * with an IncompatibleClassChangeError.\n+    public void testAbstractValueToValueClass(Path base) throws Exception {\n+        \/* Removing the abstract modifier from a value class declaration has the side-effect of making the class final,\n+         * with binary compatibility risks outlined in 13.4.2.3\n@@ -145,69 +148,0 @@\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public abstract identity class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public value class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                IncompatibleClassChangeError.class\n-        );\n-\n-        \/\/ another variation of the assertion above\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public abstract value class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public identity class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                IncompatibleClassChangeError.class\n-        );\n-\n-        \/\/ Removing one of the identity or value modifiers from an abstract class does not break compatibility with pre-existing binaries.\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract identity class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public identity class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                false,\n-                null\n-        );\n-\n-        \/\/ another variation of the assertion above\n@@ -222,100 +156,0 @@\n-                public abstract class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public value class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                false,\n-                null\n-        );\n-\n-        \/* Changing an identity class that is declared abstract to no longer be declared abstract does not break\n-         * compatibility with pre-existing binaries.\n-         *\/\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract identity class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public identity class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public identity class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                false,\n-                null\n-        );\n-\n-        \/\/ another variation of the assertion above\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract identity class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public identity class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                false,\n-                null\n-        );\n-\n-        \/* Modifying a non-abstract identity class to be a value class is a binary compatible change, as long as the class\n-         * is already final and all its constructors are private. If the class is not final, declaring it a value class\n-         * has the effect of declaring the class final (13.4.2.3). If the class has a non-private constructor,\n-         * pre-existing binaries that attempt to invoke that constructor will behave as if the constructor had been\n-         * removed (13.4.12).\n-         *\/\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public final identity class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public value class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public identity class Client {\n-                    public static void main(String... args) {\n-                        A a = new A();\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                InstantiationError.class\n-        );\n-\n-        \/\/ another variation of the assertion above\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public identity class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n@@ -326,111 +160,0 @@\n-                public identity class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                IncompatibleClassChangeError.class\n-        );\n-\n-        \/* Modifying a non-abstract value class to be an identity class is a binary compatible change, as long as all\n-         * of the class's constructors are private. If the class has a non-private constructor, pre-existing binaries\n-         * that attempt to invoke that constructor will behave as if the constructor had been removed\n-         *\/\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public value class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public identity class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public identity class Client {\n-                    public static void main(String... args) {\n-                        A a = new A();\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                NoSuchMethodError.class\n-        );\n-    }\n-\n-    @Test\n-    public void testFieldCompatibility(Path base) throws Exception {\n-        \/* Adding an instance field to an abstract class that is not an identity class also has the side-effect of\n-         * making the class an identity class\n-         *\/\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    int i;\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public value class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                IncompatibleClassChangeError.class\n-        );\n-\n-        \/\/ another variation of the assertion above\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    static int i; \/\/ OK no instance field\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public value class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                false,\n-                null\n-        );\n-\n-        \/* Removing a static modifier from a field of an abstract class that is not an identity class also has the\n-         * side-effect of making the class an identity class\n-         *\/\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    static int i;\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    int i;\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n@@ -449,3 +172,3 @@\n-    public void testSynchronizedCompatibility(Path base) throws Exception {\n-        \/* Adding a synchronized modifier to a method of an identity class does not break compatibility with\n-         * pre-existing binaries\n+    public void testAbstractOrFinalIdentityToValueClass(Path base) throws Exception {\n+        \/* Modifying an abstract or final identity class to be a value class does not break compatibility\n+         * with pre-existing binaries\n@@ -457,3 +180,1 @@\n-                public identity class A {\n-                    void m() {}\n-                }\n+                public abstract class A {}\n@@ -463,3 +184,1 @@\n-                public identity class A {\n-                    synchronized void m() {}\n-                }\n+                public abstract value class A {}\n@@ -469,1 +188,1 @@\n-                public identity class Client extends A {\n+                public class Client extends A {\n@@ -479,31 +198,0 @@\n-        \/* Adding a synchronized modifier to a method of an abstract class that is not an identity class has the\n-         * side-effect of making the class an identity class\n-         *\/\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    void m() {}\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    synchronized void m() {}\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public value class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                IncompatibleClassChangeError.class\n-        );\n-\n-        \/* Deleting a synchronized modifier of a method does not break compatibility with pre-existing binaries\n-         *\/\n@@ -514,3 +202,1 @@\n-                public abstract class A {\n-                    synchronized void m() {}\n-                }\n+                public final class A {}\n@@ -520,3 +206,1 @@\n-                public abstract class A {\n-                    void m() {}\n-                }\n+                public final value class A {}\n@@ -526,1 +210,2 @@\n-                public class Client extends A {\n+                public class Client {\n+                    A a;\n@@ -538,32 +223,3 @@\n-    public void testConstructorCompatibility(Path base) throws Exception {\n-        \/* Adding a throws clause to the constructor of an abstract class that is not an identity class has the\n-         * side-effect of making the class an identity class\n-         *\/\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    public A() {}\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    public A() throws Exception {}\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public value class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                IncompatibleClassChangeError.class\n-        );\n-\n-        \/* changes to the body of the constructor of an abstract class that is not an identity class, other than adding\n-         * or removing the super(); call, have the side-effect of making the class an identity class\n+    public void testAddingValueModifier(Path base) throws Exception {\n+        \/* Adding the value modifier to a non-abstract, non-final class declaration has the side-effect of making\n+         * the class final, with binary compatibility risks outlined in 13.4.2.3\n@@ -575,11 +231,1 @@\n-                public abstract class A {\n-                    public A() { super(); }\n-                    void m() {}\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    public A() { super(); m(); }\n-                    void m() {}\n-                }\n+                public class A {}\n@@ -589,26 +235,1 @@\n-                public value class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                IncompatibleClassChangeError.class\n-        );\n-\n-        \/* Adding type parameters to the constructor of an abstract class that is not an identity class has the\n-         * side-effect of making the class an identity class\n-         *\/\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    public A() {}\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    public <T> A() {}\n-                }\n+                public value class A {}\n@@ -618,1 +239,1 @@\n-                public value class Client extends A {\n+                public class Client extends A {\n@@ -627,30 +248,0 @@\n-\n-        \/* Changing the declared access of the constructor of an abstract class that is not an identity class to permit\n-         * less access may also have the side-effect of making the class an identity class\n-         *\/\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    public A() {}\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public abstract class A {\n-                    \/\/ this constructor has less access than the class so it will be considered an identity class\n-                    protected A() {}\n-                }\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public value class Client extends A {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                IncompatibleClassChangeError.class  \/\/currently failing with this error, but the spec mentions NoSuchMethodError\n-        );\n@@ -660,5 +251,3 @@\n-    public void testInterfaceCompatibility(Path base) throws Exception {\n-        \/* If one of the identity or value modifiers is added to an interface, a pre-existing binary that attempts to\n-         * extend or implement the interface may fail to load. Specifically, if the subclass or subinterface has an\n-         * incompatible identity or value modifier, or extends a class or interface with an incompatible identity or\n-         * value modifier, class loading will fail with an IncompatibleClassChangeError\n+    public void testValueToIdentityClass(Path base) throws Exception {\n+        \/* If a value class is changed to be an identity class, then an IncompatibleClassChangeError is thrown if a\n+         * binary of a pre-existing value subclass of this class is loaded\n@@ -670,24 +259,1 @@\n-                public interface I {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public identity interface I {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public value class Client implements I {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                true,\n-                IncompatibleClassChangeError.class\n-        );\n-\n-        \/\/ another variation of the assertion above\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public interface I {}\n+                public abstract value class A {}\n@@ -697,1 +263,1 @@\n-                public value interface I {}\n+                public abstract class A {}\n@@ -701,1 +267,1 @@\n-                public identity class Client implements I {\n+                public value class Client extends A {\n@@ -710,48 +276,0 @@\n-\n-        \/* Removing one of the identity or value modifiers from an interface does not break compatibility with\n-         * pre-existing binaries\n-         *\/\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public identity interface I {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public interface I {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public identity class Client implements I {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                false,\n-                null\n-        );\n-\n-        \/\/ another variation of the assertion above\n-        testCompatibilityAfterChange(\n-                base,\n-                \"\"\"\n-                package pkg;\n-                public value interface I {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public interface I {}\n-                \"\"\",\n-                \"\"\"\n-                package pkg;\n-                public value class Client implements I {\n-                    public static void main(String... args) {\n-                        System.out.println(\"Hello World!\");\n-                    }\n-                }\n-                \"\"\",\n-                false,\n-                null\n-        );\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectsBinaryCompatibilityTests.java","additions":31,"deletions":513,"binary":false,"changes":544,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @enablePreview\n@@ -33,1 +34,0 @@\n- * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/separate_compilation\/ConcreteValue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}