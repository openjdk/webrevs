{"files":[{"patch":"@@ -71,2 +71,3 @@\n-  \/\/ Fields declared in the bytecode (without nested fields in flat fields), ordered by\n-  \/\/ offset.\n+  \/\/ Fields declared in the bytecode (without nested fields in flat fields),\n+  \/\/ ordered in JavaFieldStream order, with superclasses first (i.e. from lang.java.Object\n+  \/\/ to most derived class).\n@@ -77,1 +78,4 @@\n-  \/\/ superclasses, ordered by offset.\n+  \/\/ superclasses.\n+  \/\/ Fields are in the same order as in _declared_nonstatic_fields, but flat fields are replaced by\n+  \/\/ the list of their own fields, ordered the same way (hierarchy traversed top-down, in\n+  \/\/ JavaFieldStream order).\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -196,0 +196,11 @@\n+\/* Very generally, a base class for a stream adapter, a derived class just implements\n+ * current_stream that returns a FieldStreamType, and this adapter takes care of providing\n+ * the methods of FieldStreamBase.\n+ *\n+ * In practice, this is used to provide a stream over the fields of a class and its superclasses\n+ * and interfaces. The derived class of HierarchicalFieldStreamBase decides in which order we iterate\n+ * on the superclasses (and interfaces), and the template parameter FieldStreamType is the underlying\n+ * stream we use to iterate over the fields each class. Methods such as done and next are still up to\n+ * the derived classes, allowing them to iterate over the class hierarchy, but also skip elements that\n+ * the underlying FieldStreamType would otherwise include.\n+ *\/\n@@ -261,1 +272,4 @@\n-\/\/ Iterate over fields including the ones declared in supertypes\n+\/* Iterate over fields including the ones declared in supertypes.\n+ * Derived classes are traversed before base classes, and interfaces\n+ * at the end.\n+ *\/\n@@ -323,1 +337,4 @@\n- * Doesn't traverse interfaces for now (let's decide how when\/if the needs appear).\n+ * Doesn't traverse interfaces for now, because it's not clear which order would make sense\n+ * Let's decide how  when\/if the needs appear. Since we are not traversing interfaces, we\n+ * wouldn't get all the static fields, and since the current use-case of this stream does not\n+ * care about static fields, we restrict it to regular non-static fields.\n@@ -325,2 +342,1 @@\n-template<typename FieldStreamType>\n-class TopDownHierarchicalFieldStreamBase : public HierarchicalFieldStreamBase<FieldStreamType> {\n+class TopDownHierarchicalNonStaticFieldStreamBase : public HierarchicalFieldStreamBase<JavaFieldStream> {\n@@ -329,1 +345,1 @@\n-  FieldStreamType _current_stream;\n+  JavaFieldStream _current_stream;\n@@ -338,1 +354,1 @@\n-      _current_stream = FieldStreamType(_super_types->at(_current_stream_index));\n+      _current_stream = JavaFieldStream(_super_types->at(_current_stream_index));\n@@ -350,0 +366,11 @@\n+  void raw_next() {\n+    _current_stream.next();\n+    next_stream_if_needed();\n+  }\n+\n+  void closest_non_static() {\n+    while (!done() && access_flags().is_static()) {\n+      raw_next();\n+    }\n+  }\n+\n@@ -351,2 +378,2 @@\n-  FieldStreamType& current_stream() override { return _current_stream; }\n-  const FieldStreamType& current_stream() const override { return _current_stream; }\n+  JavaFieldStream& current_stream() override { return _current_stream; }\n+  const JavaFieldStream& current_stream() const override { return _current_stream; }\n@@ -355,1 +382,1 @@\n-  explicit TopDownHierarchicalFieldStreamBase(InstanceKlass* klass) :\n+  explicit TopDownHierarchicalNonStaticFieldStreamBase(InstanceKlass* klass) :\n@@ -358,1 +385,1 @@\n-    _current_stream(FieldStreamType(_super_types->at(_current_stream_index))) {\n+    _current_stream(JavaFieldStream(_super_types->at(_current_stream_index))) {\n@@ -360,0 +387,1 @@\n+    closest_non_static();\n@@ -363,2 +391,2 @@\n-    _current_stream.next();\n-    next_stream_if_needed();\n+    raw_next();\n+    closest_non_static();\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":40,"deletions":12,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -401,2 +401,2 @@\n-  for (TopDownHierarchicalFieldStreamBase<JavaFieldStream> fs(this); !fs.done(); fs.next()) {\n-    if (fs.access_flags().is_static()) continue;\n+  for (TopDownHierarchicalNonStaticFieldStreamBase fs(this); !fs.done(); fs.next()) {\n+    assert(!fs.access_flags().is_static(), \"TopDownHierarchicalNonStaticFieldStreamBase should not let static fields pass.\");\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -591,30 +591,0 @@\n-#if 0\n-  static int compare(SigEntry* e1, SigEntry* e2) {\n-    if (e1->_sort_offset < e2->_sort_offset) {\n-      return -1;\n-    } else if (e1->_sort_offset > e2->_sort_offset) {\n-      return 1;\n-    }\n-\n-    if (e1->_offset != e2->_offset) {\n-      return e1->_offset - e2->_offset;\n-    }\n-    assert((e1->_bt == T_LONG && (e2->_bt == T_LONG || e2->_bt == T_VOID)) ||\n-           (e1->_bt == T_DOUBLE && (e2->_bt == T_DOUBLE || e2->_bt == T_VOID)) ||\n-           e1->_bt == T_METADATA || e2->_bt == T_METADATA || e1->_bt == T_VOID || e2->_bt == T_VOID, \"bad bt\");\n-    if (e1->_bt == e2->_bt) {\n-      assert(e1->_bt == T_METADATA || e1->_bt == T_VOID, \"only ones with duplicate offsets\");\n-      return 0;\n-    }\n-    if (e1->_bt == T_VOID ||\n-        e2->_bt == T_METADATA) {\n-      return 1;\n-    }\n-    if (e1->_bt == T_METADATA ||\n-        e2->_bt == T_VOID) {\n-      return -1;\n-    }\n-    ShouldNotReachHere();\n-    return 0;\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -135,1 +135,0 @@\n-runtime\/cds\/appcds\/RewriteBytecodesInlineTest.java 8361082 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}