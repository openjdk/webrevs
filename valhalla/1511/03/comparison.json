{"files":[{"patch":"@@ -474,5 +474,0 @@\n-static int sort_field_by_offset(ciField** a, ciField** b) {\n-  return (*a)->offset_in_bytes() - (*b)->offset_in_bytes();\n-  \/\/ (no worries about 32-bit overflow...)\n-}\n-\n@@ -562,1 +557,0 @@\n-      int field_offset = fd.offset();\n@@ -584,1 +578,0 @@\n-    tmp_declared_fields->sort(sort_field_by_offset);\n@@ -593,1 +586,0 @@\n-    tmp_fields->sort(sort_field_by_offset);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,2 +71,3 @@\n-  \/\/ Fields declared in the bytecode (without nested fields in flat fields), ordered by\n-  \/\/ offset.\n+  \/\/ Fields declared in the bytecode (without nested fields in flat fields),\n+  \/\/ ordered in JavaFieldStream order, with superclasses first (i.e. from lang.java.Object\n+  \/\/ to most derived class).\n@@ -77,1 +78,4 @@\n-  \/\/ superclasses, ordered by offset.\n+  \/\/ superclasses.\n+  \/\/ Fields are in the same order as in _declared_nonstatic_fields, but flat fields are replaced by\n+  \/\/ the list of their own fields, ordered the same way (hierarchy traversed top-down, in\n+  \/\/ JavaFieldStream order).\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3840,1 +3840,1 @@\n-        Symbol* name = (*sig)._symbol;\n+        Symbol* name = (*sig)._name;\n@@ -3846,2 +3846,1 @@\n-      \/\/ If the entry has a non-default sort_offset, it must be a null marker\n-      if ((*sig)._sort_offset != (*sig)._offset) {\n+      if ((*sig)._null_marker) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -196,1 +196,11 @@\n-\/\/ Iterate over fields including the ones declared in supertypes\n+\/* Very generally, a base class for a stream adapter, a derived class just implements\n+ * current_stream that returns a FieldStreamType, and this adapter takes care of providing\n+ * the methods of FieldStreamBase.\n+ *\n+ * In practice, this is used to provide a stream over the fields of a class and its superclasses\n+ * and interfaces. The derived class of HierarchicalFieldStreamBase decides in which order we iterate\n+ * on the superclasses (and interfaces), and the template parameter FieldStreamType is the underlying\n+ * stream we use to iterate over the fields each class. Methods such as done and next are still up to\n+ * the derived classes, allowing them to iterate over the class hierarchy, but also skip elements that\n+ * the underlying FieldStreamType would otherwise include.\n+ *\/\n@@ -198,1 +208,69 @@\n-class HierarchicalFieldStream : public StackObj  {\n+class HierarchicalFieldStreamBase : public StackObj {\n+  virtual FieldStreamType& current_stream() = 0;\n+  virtual const FieldStreamType& current_stream() const = 0;\n+\n+public:\n+  \/\/ bridge functions from FieldStreamBase\n+  int index() const {\n+    return current_stream().index();\n+  }\n+\n+  AccessFlags access_flags() const {\n+    return current_stream().access_flags();\n+  }\n+\n+  FieldInfo::FieldFlags field_flags() const {\n+    return current_stream().field_flags();\n+  }\n+\n+  Symbol* name() const {\n+    return current_stream().name();\n+  }\n+\n+  Symbol* signature() const {\n+    return current_stream().signature();\n+  }\n+\n+  Symbol* generic_signature() const {\n+    return current_stream().generic_signature();\n+  }\n+\n+  int offset() const {\n+    return current_stream().offset();\n+  }\n+\n+  bool is_contended() const {\n+    return current_stream().is_contended();\n+  }\n+\n+  int contended_group() const {\n+    return current_stream().contended_group();\n+  }\n+\n+  FieldInfo to_FieldInfo() {\n+    return current_stream().to_FieldInfo();\n+  }\n+\n+  fieldDescriptor& field_descriptor() const {\n+    return current_stream().field_descriptor();\n+  }\n+\n+  bool is_flat() const {\n+    return current_stream().is_flat();\n+  }\n+\n+  bool is_null_free_inline_type() {\n+    return current_stream().is_null_free_inline_type();\n+  }\n+\n+  int null_marker_offset() {\n+    return current_stream().null_marker_offset();\n+  }\n+};\n+\n+\/* Iterate over fields including the ones declared in supertypes.\n+ * Derived classes are traversed before base classes, and interfaces\n+ * at the end.\n+ *\/\n+template<typename FieldStreamType>\n+class HierarchicalFieldStream final : public HierarchicalFieldStreamBase<FieldStreamType>  {\n@@ -236,0 +314,3 @@\n+  FieldStreamType& current_stream() override { return _current_stream; }\n+  const FieldStreamType& current_stream() const override { return _current_stream; }\n+\n@@ -237,1 +318,1 @@\n-  HierarchicalFieldStream(InstanceKlass* klass) :\n+  explicit HierarchicalFieldStream(InstanceKlass* klass) :\n@@ -251,0 +332,1 @@\n+};\n@@ -252,27 +334,20 @@\n-  \/\/ bridge functions from FieldStreamBase\n-  int index() const {\n-    return _current_stream.index();\n-  }\n-\n-  AccessFlags access_flags() const {\n-    return _current_stream.access_flags();\n-  }\n-\n-  FieldInfo::FieldFlags field_flags() const {\n-    return _current_stream.field_flags();\n-  }\n-\n-  Symbol* name() const {\n-    return _current_stream.name();\n-  }\n-\n-  Symbol* signature() const {\n-    return _current_stream.signature();\n-  }\n-\n-  Symbol* generic_signature() const {\n-    return _current_stream.generic_signature();\n-  }\n-\n-  int offset() const {\n-    return _current_stream.offset();\n+\/* Iterates on the fields of a class and its super-class top-down (java.lang.Object first)\n+ * Doesn't traverse interfaces for now, because it's not clear which order would make sense\n+ * Let's decide when or if the need arises. Since we are not traversing interfaces, we\n+ * wouldn't get all the static fields, and since the current use-case of this stream does not\n+ * care about static fields, we restrict it to regular non-static fields.\n+ *\/\n+class TopDownHierarchicalNonStaticFieldStreamBase final : public HierarchicalFieldStreamBase<JavaFieldStream> {\n+  GrowableArray<InstanceKlass*>* _super_types;  \/\/ Self and super type, bottom up\n+  int _current_stream_index;\n+  JavaFieldStream _current_stream;\n+\n+  void next_stream_if_needed() {\n+    precond(_current_stream_index >= 0);\n+    while (_current_stream.done()) {\n+      _current_stream_index--;\n+      if (_current_stream_index < 0) {\n+        return;\n+      }\n+      _current_stream = JavaFieldStream(_super_types->at(_current_stream_index));\n+    }\n@@ -281,2 +356,6 @@\n-  bool is_contended() const {\n-    return _current_stream.is_contended();\n+  GrowableArray<InstanceKlass*>* get_super_types(InstanceKlass* klass) {\n+    auto super_types = new GrowableArray<InstanceKlass*>();\n+    do {\n+      super_types->push(klass);\n+    } while ((klass = klass->java_super()) != nullptr);\n+    return super_types;\n@@ -285,2 +364,3 @@\n-  int contended_group() const {\n-    return _current_stream.contended_group();\n+  void raw_next() {\n+    _current_stream.next();\n+    next_stream_if_needed();\n@@ -289,2 +369,4 @@\n-  FieldInfo to_FieldInfo() {\n-    return _current_stream.to_FieldInfo();\n+  void closest_non_static() {\n+    while (!done() && access_flags().is_static()) {\n+      raw_next();\n+    }\n@@ -293,3 +375,2 @@\n-  fieldDescriptor& field_descriptor() const {\n-    return _current_stream.field_descriptor();\n-  }\n+  JavaFieldStream& current_stream() override { return _current_stream; }\n+  const JavaFieldStream& current_stream() const override { return _current_stream; }\n@@ -297,2 +378,7 @@\n-  bool is_flat() const {\n-    return _current_stream.is_flat();\n+ public:\n+  explicit TopDownHierarchicalNonStaticFieldStreamBase(InstanceKlass* klass) :\n+    _super_types(get_super_types(klass)),\n+    _current_stream_index(_super_types->length() - 1),\n+    _current_stream(JavaFieldStream(_super_types->at(_current_stream_index))) {\n+    next_stream_if_needed();\n+    closest_non_static();\n@@ -301,2 +387,3 @@\n-  bool is_null_free_inline_type() {\n-    return _current_stream.is_null_free_inline_type();\n+  void next() {\n+    raw_next();\n+    closest_non_static();\n@@ -305,3 +392,1 @@\n-  int null_marker_offset() {\n-    return _current_stream.null_marker_offset();\n-  }\n+  bool done() const { return _current_stream_index < 0; }\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":131,"deletions":46,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-int InlineKlass::collect_fields(GrowableArray<SigEntry>* sig, float& max_offset, int base_off, int null_marker_offset) {\n+int InlineKlass::collect_fields(GrowableArray<SigEntry>* sig, int base_off, int null_marker_offset) {\n@@ -401,3 +401,2 @@\n-  max_offset = base_off;\n-  for (HierarchicalFieldStream<JavaFieldStream> fs(this); !fs.done(); fs.next()) {\n-    if (fs.access_flags().is_static()) continue;\n+  for (TopDownHierarchicalNonStaticFieldStreamBase fs(this); !fs.done(); fs.next()) {\n+    assert(!fs.access_flags().is_static(), \"TopDownHierarchicalNonStaticFieldStreamBase should not let static fields pass.\");\n@@ -414,1 +413,1 @@\n-      count += InlineKlass::cast(vk)->collect_fields(sig, max_offset, offset, field_null_marker_offset);\n+      count += InlineKlass::cast(vk)->collect_fields(sig, offset, field_null_marker_offset);\n@@ -417,1 +416,1 @@\n-      SigEntry::add_entry(sig, bt, fs.signature(), offset);\n+      SigEntry::add_entry(sig, bt,  fs.name(), offset);\n@@ -426,1 +425,0 @@\n-    max_offset = MAX2(max_offset, (float)offset);\n@@ -431,2 +429,1 @@\n-    max_offset += 0.1f; \/\/ We add the markers \"in-between\" because they are no real fields\n-    SigEntry::add_entry(sig, T_BOOLEAN, name(), null_marker_offset, max_offset);\n+    SigEntry::add_null_marker(sig, name(), null_marker_offset);\n@@ -436,3 +433,0 @@\n-  if (base_off == 0) {\n-    sig->sort(SigEntry::compare);\n-  }\n@@ -450,2 +444,15 @@\n-    float max_offset = 0;\n-    int nb_fields = collect_fields(&sig_vk, max_offset);\n+    int nb_fields = collect_fields(&sig_vk);\n+    if (*PrintInlineKlassFields != '\\0') {\n+      const char* class_name_str = _name->as_C_string();\n+      if (StringUtils::class_list_match(PrintInlineKlassFields, class_name_str)) {\n+        ttyLocker ttyl;\n+        tty->print_cr(\"Fields of InlineKlass: %s\", class_name_str);\n+        for (const SigEntry& entry : sig_vk) {\n+          tty->print(\"  %s: %s+%d\", entry._name->as_C_string(), type2name(entry._bt), entry._offset);\n+          if (entry._null_marker) {\n+            tty->print(\" (null marker)\");\n+          }\n+          tty->print_cr(\"\");\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-    return *(int*)adr_payload_offset();\n+    return offset;\n@@ -223,1 +223,1 @@\n-  int collect_fields(GrowableArray<SigEntry>* sig, float& max_offset, int base_off = 0, int null_marker_offset = -1);\n+  int collect_fields(GrowableArray<SigEntry>* sig, int base_off = 0, int null_marker_offset = -1);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -835,0 +835,2 @@\n+  develop(ccstrlist, PrintInlineKlassFields, \"\",                            \\\n+          \"Print fields collected by InlineKlass::collect_fields\")          \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1518,5 +1518,0 @@\n-static int compare(ReassignedField* left, ReassignedField* right) {\n-  return left->_offset - right->_offset;\n-}\n-\n-\n@@ -1550,2 +1545,0 @@\n-  fields->sort(compare);\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2868,4 +2868,3 @@\n-              \/\/ Nullable inline type argument, insert InlineTypeNode::NullMarker field right after T_METADATA delimiter\n-              \/\/ Set the sort_offset so that the field is detected as null marker by nmethod::print_nmethod_labels.\n-              _sig_cc->insert_before(last+1, SigEntry(T_BOOLEAN, -1, 0));\n-              _sig_cc_ro->insert_before(last_ro+1, SigEntry(T_BOOLEAN, -1, 0));\n+              \/\/ Nullable inline type argument, insert InlineTypeNode::NullMarker field right after T_METADATA delimite\n+              _sig_cc->insert_before(last+1, SigEntry(T_BOOLEAN, -1, nullptr, true));\n+              _sig_cc_ro->insert_before(last_ro+1, SigEntry(T_BOOLEAN, -1, nullptr, true));\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -683,5 +683,2 @@\n-void SigEntry::add_entry(GrowableArray<SigEntry>* sig, BasicType bt, Symbol* symbol, int offset, float sort_offset) {\n-  if (sort_offset == -1) {\n-    sort_offset = offset;\n-  }\n-  sig->append(SigEntry(bt, offset, sort_offset, symbol));\n+void SigEntry::add_entry(GrowableArray<SigEntry>* sig, BasicType bt, Symbol* name, int offset) {\n+  sig->append(SigEntry(bt, offset, name, false));\n@@ -689,1 +686,1 @@\n-    sig->append(SigEntry(T_VOID, offset, sort_offset, symbol)); \/\/ Longs and doubles take two stack slots\n+    sig->append(SigEntry(T_VOID, offset, name, false)); \/\/ Longs and doubles take two stack slots\n@@ -692,0 +689,3 @@\n+void SigEntry::add_null_marker(GrowableArray<SigEntry>* sig, Symbol* name, int offset) {\n+  sig->append(SigEntry(T_BOOLEAN, offset, name, true));\n+}\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -582,2 +582,2 @@\n-  float _sort_offset; \/\/ Offset used for sorting\n-  Symbol* _symbol;    \/\/ Symbol for printing\n+  Symbol* _name;      \/\/ Symbol for printing\n+  bool _null_marker;  \/\/ Is it a null marker? For printing\n@@ -586,1 +586,1 @@\n-    : _bt(T_ILLEGAL), _offset(-1), _sort_offset(-1), _symbol(nullptr) {}\n+    : _bt(T_ILLEGAL), _offset(-1), _name(nullptr) {}\n@@ -588,2 +588,2 @@\n-  SigEntry(BasicType bt, int offset = -1, float sort_offset = -1, Symbol* symbol = nullptr)\n-    : _bt(bt), _offset(offset), _sort_offset(sort_offset), _symbol(symbol) {}\n+  SigEntry(BasicType bt, int offset, Symbol* name, bool null_marker)\n+    : _bt(bt), _offset(offset), _name(name), _null_marker(null_marker) {}\n@@ -591,29 +591,2 @@\n-  static int compare(SigEntry* e1, SigEntry* e2) {\n-    if (e1->_sort_offset < e2->_sort_offset) {\n-      return -1;\n-    } else if (e1->_sort_offset > e2->_sort_offset) {\n-      return 1;\n-    }\n-\n-    if (e1->_offset != e2->_offset) {\n-      return e1->_offset - e2->_offset;\n-    }\n-    assert((e1->_bt == T_LONG && (e2->_bt == T_LONG || e2->_bt == T_VOID)) ||\n-           (e1->_bt == T_DOUBLE && (e2->_bt == T_DOUBLE || e2->_bt == T_VOID)) ||\n-           e1->_bt == T_METADATA || e2->_bt == T_METADATA || e1->_bt == T_VOID || e2->_bt == T_VOID, \"bad bt\");\n-    if (e1->_bt == e2->_bt) {\n-      assert(e1->_bt == T_METADATA || e1->_bt == T_VOID, \"only ones with duplicate offsets\");\n-      return 0;\n-    }\n-    if (e1->_bt == T_VOID ||\n-        e2->_bt == T_METADATA) {\n-      return 1;\n-    }\n-    if (e1->_bt == T_METADATA ||\n-        e2->_bt == T_VOID) {\n-      return -1;\n-    }\n-    ShouldNotReachHere();\n-    return 0;\n-  }\n-  static void add_entry(GrowableArray<SigEntry>* sig, BasicType bt, Symbol* symbol = nullptr, int offset = -1, float sort_offset = -1);\n+  static void add_entry(GrowableArray<SigEntry>* sig, BasicType bt, Symbol* name = nullptr, int offset = -1);\n+  static void add_null_marker(GrowableArray<SigEntry>* sig, Symbol* name, int offset);\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":7,"deletions":34,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-    private static final SortByOffset fieldSortingMethod = new SortByOffset();\n@@ -785,6 +784,0 @@\n-    static class SortByOffset implements Comparator<ResolvedJavaField> {\n-        public int compare(ResolvedJavaField a, ResolvedJavaField b) {\n-            return a.getOffset() - b.getOffset();\n-        }\n-    }\n-\n@@ -820,1 +813,0 @@\n-                Arrays.sort(result, fieldSortingMethod);\n@@ -879,1 +871,0 @@\n-        Arrays.sort(result, fieldSortingMethod);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -135,1 +135,0 @@\n-compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java 8357785 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,0 +73,30 @@\n+        @Override\n+        public String toString() {\n+            var builder = new StringBuilder()\n+                    .append(\"{l: \")\n+                    .append(longField)\n+                    .append(\"; \")\n+                    .append(\"i: \")\n+                    .append(intField)\n+                    .append(\"; \")\n+                    .append(\"f: \")\n+                    .append(floatField)\n+                    .append(\"; \")\n+                    .append(\"a[\")\n+                    .append(arrayField.length)\n+                    .append(\"]: \");\n+            for (int i = 0; i < arrayField.length; ++i) {\n+                if (i != 0) {\n+                    builder.append(\"; \");\n+                }\n+                builder.append(\"[\").append(i).append(\"]=\");\n+                if (arrayField[i] == this) {\n+                    builder.append(\"this\");\n+                } else {\n+                    builder.append(arrayField[i]);\n+                }\n+            }\n+            builder.append(\"}\");\n+            return builder.toString();\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/VirtualObjectDebugInfoTest.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"}]}