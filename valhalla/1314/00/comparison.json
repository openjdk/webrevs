{"files":[{"patch":"@@ -108,16 +108,0 @@\n-  } else {\n-    ciKlass* klass = element_type->as_klass();\n-    if (null_free && klass->is_loaded()) {\n-      GUARDED_VM_ENTRY(\n-        EXCEPTION_CONTEXT;\n-        Klass* ak = InlineKlass::cast(klass->get_Klass())->value_array_klass(THREAD);\n-        if (HAS_PENDING_EXCEPTION) {\n-          CLEAR_PENDING_EXCEPTION;\n-        } else if (ak->is_flatArray_klass()) {\n-          return CURRENT_THREAD_ENV->get_flat_array_klass(ak);\n-        } else if (ak->is_objArray_klass()) {\n-          return CURRENT_THREAD_ENV->get_obj_array_klass(ak);\n-        }\n-      )\n-    }\n-    return ciObjArrayKlass::make(klass);\n@@ -125,0 +109,18 @@\n+\n+  ciKlass* klass = element_type->as_klass();\n+  assert(!null_free || !klass->is_loaded() || klass->is_inlinetype() || klass->is_abstract() ||\n+         klass->is_java_lang_Object(), \"only value classes are null free\");\n+  if (null_free && klass->is_loaded() && klass->is_inlinetype()) {\n+    GUARDED_VM_ENTRY(\n+      EXCEPTION_CONTEXT;\n+      Klass* ak = InlineKlass::cast(klass->get_Klass())->value_array_klass(THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION;\n+      } else if (ak->is_flatArray_klass()) {\n+        return CURRENT_THREAD_ENV->get_flat_array_klass(ak);\n+      } else if (ak->is_objArray_klass()) {\n+        return CURRENT_THREAD_ENV->get_obj_array_klass(ak);\n+      }\n+    )\n+  }\n+  return ciObjArrayKlass::make(klass);\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1838,1 +1838,12 @@\n-  uint shift = arytype->is_flat() ? arytype->flat_log_elem_size() : exact_log2(type2aelembytes(elembt));\n+  assert(!arytype->is_flat() || elembt == T_OBJECT, \"element type of flat arrays are T_OBJECT\");\n+  uint shift;\n+  if (arytype->is_flat() && arytype->klass_is_exact()) {\n+    \/\/ We can only determine the flat array layout statically if the klass is exact. Otherwise, we could have different\n+    \/\/ value classes at runtime with a potentially different layout. The caller needs to fall back to call\n+    \/\/ load\/store_unknown_inline_Type() at runtime. We could return a sentinel node for the non-exact case but that\n+    \/\/ might mess with other GVN transformations in between. Thus, we just continue in the else branch normally, even\n+    \/\/ though we don't need the address node in this case and throw it away again.\n+    shift = arytype->flat_log_elem_size();\n+  } else {\n+    shift = exact_log2(type2aelembytes(elembt));\n+  }\n@@ -3496,1 +3507,1 @@\n-  assert(!null_free || toop->is_inlinetypeptr(), \"must be an inline type pointer\");\n+  assert(!null_free || toop->can_be_inline_type(), \"must be an inline type pointer\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -497,0 +497,1 @@\n+  Node* load_from_unknown_flat_array(Node* array, Node* array_index, const TypeOopPtr* element_ptr);\n@@ -499,0 +500,1 @@\n+  void store_to_unknown_flat_array(Node* array, Node* idx, Node* non_null_stored_value);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-  Node* idx = pop();\n-  Node* ary = pop();\n+  Node* array_index = pop();\n+  Node* array = pop();\n@@ -83,3 +83,3 @@\n-  const TypeOopPtr* elemptr = elemtype->make_oopptr();\n-  const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n-  if (ary_t->is_flat()) {\n+  const TypeOopPtr* element_ptr = elemtype->make_oopptr();\n+  const TypeAryPtr* array_type = _gvn.type(array)->is_aryptr();\n+  if (array_type->is_flat()) {\n@@ -87,2 +87,10 @@\n-    Node* vt = InlineTypeNode::make_from_flat(this, elemtype->inline_klass(), ary, adr);\n-    push(vt);\n+    Node* inline_type;\n+    if (element_ptr->klass_is_exact()) {\n+      inline_type = InlineTypeNode::make_from_flat(this, elemtype->inline_klass(), array, adr);\n+    } else {\n+      \/\/ Element type of flat array is not exact. Therefore, we cannot determine the flat array layout statically.\n+      \/\/ Emit a runtime call to load the element from the flat array.\n+      inline_type = load_from_unknown_flat_array(array, array_index, element_ptr);\n+      inline_type = record_profile_for_speculation_at_array_load(inline_type);\n+    }\n+    push(inline_type);\n@@ -90,4 +98,3 @@\n-  } else if (ary_t->is_null_free()) {\n-    \/\/ Load from non-flat inline type array (elements can never be null)\n-    bt = T_OBJECT;\n-  } else if (!ary_t->is_not_flat()) {\n+  }\n+\n+  if (!array_type->is_not_flat()) {\n@@ -95,2 +102,2 @@\n-    assert(UseFlatArray && is_reference_type(bt) && elemptr->can_be_inline_type() && !ary_t->is_not_null_free() &&\n-           (!elemptr->is_inlinetypeptr() || elemptr->inline_klass()->flat_in_array()), \"array can't be flat\");\n+    assert(UseFlatArray && is_reference_type(bt) && element_ptr->can_be_inline_type() && !array_type->is_not_null_free() &&\n+           (!element_ptr->is_inlinetypeptr() || element_ptr->inline_klass()->flat_in_array()), \"array can't be flat\");\n@@ -100,2 +107,2 @@\n-    ideal.if_then(flat_array_test(ary, \/* flat = *\/ false)); {\n-      \/\/ non-flat array\n+    ideal.if_then(flat_array_test(array, \/* flat = *\/ false)); {\n+      \/\/ Non-flat array\n@@ -106,1 +113,1 @@\n-      if (needs_range_check(ary_t->size(), idx)) {\n+      if (needs_range_check(array_type->size(), array_index)) {\n@@ -112,4 +119,4 @@\n-      Node* ld = access_load_at(ary, adr, adr_type, elemptr, bt, decorator_set);\n-      if (elemptr->is_inlinetypeptr()) {\n-        assert(elemptr->maybe_null(), \"null free array should be handled above\");\n-        ld = InlineTypeNode::make_from_oop(this, ld, elemptr->inline_klass(), false);\n+      Node* ld = access_load_at(array, adr, adr_type, element_ptr, bt, decorator_set);\n+      if (element_ptr->is_inlinetypeptr()) {\n+        assert(element_ptr->maybe_null(), \"null free array should be handled above\");\n+        ld = InlineTypeNode::make_from_oop(this, ld, element_ptr->inline_klass(), false);\n@@ -120,1 +127,1 @@\n-      \/\/ flat array\n+      \/\/ Flat array\n@@ -122,4 +129,4 @@\n-      if (elemptr->is_inlinetypeptr()) {\n-        \/\/ Element type is known, cast and load from flat representation\n-        ciInlineKlass* vk = elemptr->inline_klass();\n-        assert(vk->flat_in_array() && elemptr->maybe_null(), \"never\/always flat - should be optimized\");\n+      if (element_ptr->is_inlinetypeptr()) {\n+        \/\/ Element type is known, cast and load from flat array layout.\n+        ciInlineKlass* vk = element_ptr->inline_klass();\n+        assert(vk->flat_in_array() && element_ptr->maybe_null(), \"never\/always flat - should be optimized\");\n@@ -128,2 +135,2 @@\n-        Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, arytype));\n-        Node* casted_adr = array_element_address(cast, idx, T_OBJECT, ary_t->size(), control());\n+        Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, arytype));\n+        Node* casted_adr = array_element_address(cast, array_index, T_OBJECT, array_type->size(), control());\n@@ -138,29 +145,3 @@\n-        \/\/ Element type is unknown, emit runtime call\n-\n-        \/\/ Below membars keep this access to an unknown flat array correctly\n-        \/\/ ordered with other unknown and known flat array accesses.\n-        insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n-\n-        Node* call = nullptr;\n-        {\n-          \/\/ Re-execute flat array load if runtime call triggers deoptimization\n-          PreserveReexecuteState preexecs(this);\n-          jvms()->set_bci(_bci);\n-          jvms()->set_should_reexecute(true);\n-          inc_sp(2);\n-          kill_dead_locals();\n-          call = make_runtime_call(RC_NO_LEAF | RC_NO_IO,\n-                                   OptoRuntime::load_unknown_inline_Type(),\n-                                   OptoRuntime::load_unknown_inline_Java(),\n-                                   nullptr, TypeRawPtr::BOTTOM,\n-                                   ary, idx);\n-        }\n-        make_slow_call_ex(call, env()->Throwable_klass(), false);\n-        Node* buffer = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-\n-        insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n-\n-        \/\/ Keep track of the information that the inline type is in flat arrays\n-        const Type* unknown_value = elemptr->is_instptr()->cast_to_flat_in_array();\n-        buffer = _gvn.transform(new CheckCastPPNode(control(), buffer, unknown_value));\n-\n+        \/\/ Element type is unknown, and thus we cannot statically determine the exact flat array layout. Emit a\n+        \/\/ runtime call to correctly load the inline type element from the flat array.\n+        Node* inline_type = load_from_unknown_flat_array(array, array_index, element_ptr);\n@@ -168,1 +149,1 @@\n-        ideal.set(res, buffer);\n+        ideal.set(res, inline_type);\n@@ -178,0 +159,5 @@\n+  if (array_type->is_null_free()) {\n+    \/\/ Load from non-flat inline type array (elements can never be null)\n+    bt = T_OBJECT;\n+  }\n+\n@@ -182,1 +168,1 @@\n-  Node* ld = access_load_at(ary, adr, adr_type, elemtype, bt,\n+  Node* ld = access_load_at(array, adr, adr_type, elemtype, bt,\n@@ -186,3 +172,3 @@\n-  if (elemptr != nullptr && elemptr->is_inlinetypeptr()) {\n-    assert(!ary_t->is_null_free() || !elemptr->maybe_null(), \"inline type array elements should never be null\");\n-    ld = InlineTypeNode::make_from_oop(this, ld, elemptr->inline_klass(), !elemptr->maybe_null());\n+  if (element_ptr != nullptr && element_ptr->is_inlinetypeptr()) {\n+    assert(!array_type->is_null_free() || !element_ptr->maybe_null(), \"inline type array elements should never be null\");\n+    ld = InlineTypeNode::make_from_oop(this, ld, element_ptr->inline_klass(), !element_ptr->maybe_null());\n@@ -193,0 +179,28 @@\n+Node* Parse::load_from_unknown_flat_array(Node* array, Node* array_index, const TypeOopPtr* element_ptr) {\n+  \/\/ Below membars keep this access to an unknown flat array correctly\n+  \/\/ ordered with other unknown and known flat array accesses.\n+  insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+\n+  Node* call = nullptr;\n+  {\n+    \/\/ Re-execute flat array load if runtime call triggers deoptimization\n+    PreserveReexecuteState preexecs(this);\n+    jvms()->set_bci(_bci);\n+    jvms()->set_should_reexecute(true);\n+    inc_sp(2);\n+    kill_dead_locals();\n+    call = make_runtime_call(RC_NO_LEAF | RC_NO_IO,\n+                             OptoRuntime::load_unknown_inline_Type(),\n+                             OptoRuntime::load_unknown_inline_Java(),\n+                             nullptr, TypeRawPtr::BOTTOM,\n+                             array, array_index);\n+  }\n+  make_slow_call_ex(call, env()->Throwable_klass(), false);\n+  Node* buffer = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+\n+  insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+\n+  \/\/ Keep track of the information that the inline type is in flat arrays\n+  const Type* unknown_value = element_ptr->is_instptr()->cast_to_flat_in_array();\n+  return _gvn.transform(new CheckCastPPNode(control(), buffer, unknown_value));\n+}\n@@ -199,1 +213,1 @@\n-  Node* cast_val = nullptr;\n+  Node* stored_value_casted = nullptr;\n@@ -201,2 +215,4 @@\n-    cast_val = array_store_check(adr, elemtype);\n-    if (stopped()) return;\n+    stored_value_casted = array_store_check(adr, elemtype);\n+    if (stopped()) {\n+      return;\n+    }\n@@ -204,3 +220,3 @@\n-  Node* val = pop_node(bt); \/\/ Value to store\n-  Node* idx = pop();        \/\/ Index in the array\n-  Node* ary = pop();        \/\/ The array itself\n+  Node* const stored_value = pop_node(bt); \/\/ Value to store\n+  Node* const array_index = pop();         \/\/ Index in the array\n+  Node* array = pop();                     \/\/ The array itself\n@@ -208,1 +224,1 @@\n-  const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n+  const TypeAryPtr* array_type = _gvn.type(array)->is_aryptr();\n@@ -215,1 +231,1 @@\n-    const Type* tval = _gvn.type(cast_val);\n+    const Type* stored_value_casted_type = _gvn.type(stored_value_casted);\n@@ -218,4 +234,6 @@\n-    \/\/ if the array is null-free. Null stores are handled in GraphKit::gen_inline_array_null_guard().\n-    bool not_null_free = !tval->maybe_null() && !tval->is_oopptr()->can_be_inline_type();\n-    bool not_flat = not_null_free || (tval->is_inlinetypeptr() && !tval->inline_klass()->flat_in_array());\n-    if (!ary_t->is_not_null_free() && not_null_free) {\n+    \/\/ if the array is null-free. Null stores are handled in GraphKit::inline_array_null_guard().\n+    bool not_null_free = !stored_value_casted_type->maybe_null() &&\n+                         !stored_value_casted_type->is_oopptr()->can_be_inline_type();\n+    bool not_flat = not_null_free || (stored_value_casted_type->is_inlinetypeptr() &&\n+                                      !stored_value_casted_type->inline_klass()->flat_in_array());\n+    if (!array_type->is_not_null_free() && not_null_free) {\n@@ -223,5 +241,5 @@\n-      ary_t = ary_t->cast_to_not_null_free();\n-      Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));\n-      replace_in_map(ary, cast);\n-      ary = cast;\n-    } else if (!ary_t->is_not_flat() && not_flat) {\n+      array_type = array_type->cast_to_not_null_free();\n+      Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, array_type));\n+      replace_in_map(array, cast);\n+      array = cast;\n+    } else if (!array_type->is_not_flat() && not_flat) {\n@@ -229,4 +247,4 @@\n-      ary_t = ary_t->cast_to_not_flat();\n-      Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));\n-      replace_in_map(ary, cast);\n-      ary = cast;\n+      array_type = array_type->cast_to_not_flat();\n+      Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, array_type));\n+      replace_in_map(array, cast);\n+      array = cast;\n@@ -235,1 +253,1 @@\n-    if (ary_t->is_flat()) {\n+    if (array_type->is_flat()) {\n@@ -237,6 +255,13 @@\n-      assert(!tval->maybe_null(), \"should be guaranteed by array store check\");\n-      \/\/ Re-execute flat array store if buffering triggers deoptimization\n-      PreserveReexecuteState preexecs(this);\n-      inc_sp(3);\n-      jvms()->set_should_reexecute(true);\n-      cast_val->as_InlineType()->store_flat(this, ary, adr, nullptr, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+      assert(!stored_value_casted_type->maybe_null(), \"should be guaranteed by array store check\");\n+      if (array_type->klass_is_exact()) {\n+        \/\/ Store to exact flat inline type array where we know the flat array layout statically.\n+        \/\/ Re-execute flat array store if buffering triggers deoptimization\n+        PreserveReexecuteState preexecs(this);\n+        inc_sp(3);\n+        jvms()->set_should_reexecute(true);\n+        stored_value_casted->as_InlineType()->store_flat(this, array, adr, nullptr, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+      } else {\n+        \/\/ Element type of flat array is not exact. Therefore, we cannot determine the flat array layout statically.\n+        \/\/ Emit a runtime call to store the element to the flat array.\n+        store_to_unknown_flat_array(array, array_index, stored_value_casted);\n+      }\n@@ -244,3 +269,4 @@\n-    } else if (ary_t->is_null_free()) {\n-      \/\/ Store to non-flat inline type array (elements can never be null)\n-      assert(!tval->maybe_null(), \"should be guaranteed by array store check\");\n+    }\n+    if (array_type->is_null_free()) {\n+      \/\/ Store to non-flat null-free inline type array (elements can never be null)\n+      assert(!stored_value_casted_type->maybe_null(), \"should be guaranteed by array store check\");\n@@ -251,1 +277,1 @@\n-    } else if (!ary_t->is_not_flat() && (tval != TypePtr::NULL_PTR || StressReflectiveCode)) {\n+    } else if (!array_type->is_not_flat() && (stored_value_casted_type != TypePtr::NULL_PTR || StressReflectiveCode)) {\n@@ -254,1 +280,1 @@\n-             !ary_t->klass_is_exact() && !ary_t->is_not_null_free(), \"array can't be a flat array\");\n+             !array_type->klass_is_exact() && !array_type->is_not_null_free(), \"array can't be a flat array\");\n@@ -256,2 +282,2 @@\n-      ideal.if_then(flat_array_test(ary, \/* flat = *\/ false)); {\n-        \/\/ non-flat array\n+      ideal.if_then(flat_array_test(array, \/* flat = *\/ false)); {\n+        \/\/ Non-flat array\n@@ -260,1 +286,1 @@\n-        Node* cast_ary = inline_array_null_guard(ary, cast_val, 3);\n+        Node* cast_array = inline_array_null_guard(array, stored_value_casted, 3);\n@@ -262,1 +288,1 @@\n-        access_store_at(cast_ary, adr, adr_type, cast_val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);\n+        access_store_at(cast_array, adr, adr_type, stored_value_casted, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);\n@@ -269,1 +295,1 @@\n-        Node* val = null_check_oop(cast_val, &null_ctl);\n+        Node* null_checked_stored_value_casted = null_check_oop(stored_value_casted, &null_ctl);\n@@ -278,3 +304,3 @@\n-        ciInlineKlass* vk = nullptr;\n-        if (tval->is_inlinetypeptr()) {\n-          vk = tval->inline_klass();\n+        ciInlineKlass* inline_Klass = nullptr;\n+        if (stored_value_casted_type->is_inlinetypeptr()) {\n+          inline_Klass = stored_value_casted_type->inline_klass();\n@@ -282,1 +308,1 @@\n-          vk = elemtype->inline_klass();\n+          inline_Klass = elemtype->inline_klass();\n@@ -284,11 +310,22 @@\n-        Node* casted_ary = ary;\n-        if (vk != nullptr && !stopped()) {\n-          \/\/ Element type is known, cast and store to flat representation\n-          assert(vk->flat_in_array() && elemtype->maybe_null(), \"never\/always flat - should be optimized\");\n-          ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n-          const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n-          casted_ary = _gvn.transform(new CheckCastPPNode(control(), casted_ary, arytype));\n-          Node* casted_adr = array_element_address(casted_ary, idx, T_OBJECT, arytype->size(), control());\n-          if (!val->is_InlineType()) {\n-            assert(!gvn().type(val)->maybe_null(), \"inline type array elements should never be null\");\n-            val = InlineTypeNode::make_from_oop(this, val, vk);\n+        if (!stopped()) {\n+          if (inline_Klass != nullptr) {\n+            \/\/ Element type is known, cast and store to flat array layout.\n+            assert(inline_Klass->flat_in_array() && elemtype->maybe_null(), \"never\/always flat - should be optimized\");\n+            ciArrayKlass* array_klass = ciArrayKlass::make(inline_Klass, \/* null_free *\/ true);\n+            const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n+            Node* casted_array = _gvn.transform(new CheckCastPPNode(control(), array, arytype));\n+            Node* casted_adr = array_element_address(casted_array, array_index, T_OBJECT, arytype->size(), control());\n+            if (!null_checked_stored_value_casted->is_InlineType()) {\n+              assert(!gvn().type(null_checked_stored_value_casted)->maybe_null(),\n+                     \"inline type array elements should never be null\");\n+              null_checked_stored_value_casted = InlineTypeNode::make_from_oop(this, null_checked_stored_value_casted,\n+                                                                               inline_Klass);\n+            }\n+            \/\/ Re-execute flat array store if buffering triggers deoptimization\n+            PreserveReexecuteState preexecs(this);\n+            inc_sp(3);\n+            jvms()->set_should_reexecute(true);\n+            null_checked_stored_value_casted->as_InlineType()->store_flat(this, casted_array, casted_adr, nullptr, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+          } else {\n+            \/\/ Element type is unknown, emit a runtime call since the flat array layout is not statically known.\n+            store_to_unknown_flat_array(array, array_index, null_checked_stored_value_casted);\n@@ -296,19 +333,0 @@\n-          \/\/ Re-execute flat array store if buffering triggers deoptimization\n-          PreserveReexecuteState preexecs(this);\n-          inc_sp(3);\n-          jvms()->set_should_reexecute(true);\n-          val->as_InlineType()->store_flat(this, casted_ary, casted_adr, nullptr, 0, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n-        } else if (!stopped()) {\n-          \/\/ Element type is unknown, emit runtime call\n-\n-          \/\/ Below membars keep this access to an unknown flat array correctly\n-          \/\/ ordered with other unknown and known flat array accesses.\n-          insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n-\n-          make_runtime_call(RC_LEAF,\n-                            OptoRuntime::store_unknown_inline_Type(),\n-                            CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_inline_C),\n-                            \"store_unknown_inline\", TypeRawPtr::BOTTOM,\n-                            val, casted_ary, idx);\n-\n-          insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n@@ -321,1 +339,1 @@\n-    } else if (!ary_t->is_not_null_free()) {\n+    } else if (!array_type->is_not_null_free()) {\n@@ -324,1 +342,1 @@\n-      ary = inline_array_null_guard(ary, cast_val, 3, true);\n+      array = inline_array_null_guard(array, stored_value_casted, 3, true);\n@@ -328,1 +346,1 @@\n-  access_store_at(ary, adr, adr_type, val, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+  access_store_at(array, adr, adr_type, stored_value, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n@@ -332,0 +350,15 @@\n+\/\/ Emit a runtime call to store to a flat array whose element type is either unknown (i.e. we do not know the flat\n+\/\/ array layout) or not exact (could have different flat array layouts at runtime).\n+void Parse::store_to_unknown_flat_array(Node* array, Node* const idx, Node* non_null_stored_value) {\n+  \/\/ Below membars keep this access to an unknown flat array correctly\n+  \/\/ ordered with other unknown and known flat array accesses.\n+  insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+\n+  make_runtime_call(RC_LEAF,\n+                    OptoRuntime::store_unknown_inline_Type(),\n+                    CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_inline_C),\n+                    \"store_unknown_inline\", TypeRawPtr::BOTTOM,\n+                    non_null_stored_value, array, idx);\n+\n+  insert_mem_bar_volatile(Op_MemBarCPUOrder, C->get_alias_index(TypeAryPtr::INLINES));\n+}\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":169,"deletions":136,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -265,1 +265,2 @@\n-  bool null_free = false;\n+  const TypePtr* elem_ptr = elemtype->make_ptr();\n+  bool null_free;\n@@ -270,0 +271,22 @@\n+  } else {\n+    \/\/ TODO: Should move to TypeAry::is_null_free() with JDK-8345681\n+    TypePtr::PTR ptr = elem_ptr->ptr();\n+    null_free = ptr == TypePtr::NotNull || ptr == TypePtr::AnyNull;\n+#ifdef ASSERT\n+    \/\/ If the element type is exact, the array can be null-free (i.e. the element type is NotNull) if:\n+    \/\/   - The elements are inline types\n+    \/\/   - The array is from an autobox cache.\n+    \/\/ If the element type is inexact, it could represent multiple null-free arrays. Since autobox cache arrays\n+    \/\/ are local to very few cache classes and are only used in the valueOf() methods, they are always exact and are not\n+    \/\/ merged or hidden behind super types. Therefore, an inexact null-free array always represents some kind of\n+    \/\/ inline type array - either of an abstract value class or Object.\n+    if (null_free) {\n+      ciKlass* klass = elem_ptr->is_instptr()->instance_klass();\n+      if (klass->exact_klass()) {\n+        assert(elem_ptr->is_inlinetypeptr() || arytype->is_autobox_cache(), \"elements must be inline type or autobox cache\");\n+      } else {\n+        assert(!arytype->is_autobox_cache() && elem_ptr->can_be_inline_type() &&\n+               (klass->is_java_lang_Object() || klass->is_abstract()), \"cannot have inexact non-inline type elements\");\n+      }\n+    }\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -6661,1 +6661,3 @@\n-      assert(!is_null_free() && !is_flat(), \"null-free (or flat) inline type arrays should always be exact\");\n+      assert((!is_null_free() && !is_flat()) ||\n+             _elem->is_klassptr()->klass()->is_abstract() || _elem->is_klassptr()->klass()->is_java_lang_Object(),\n+             \"null-free (or flat) concrete inline type arrays should always be exact\");\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4500,0 +4500,157 @@\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ValueClassWithInt {\n+        int i;\n+\n+        ValueClassWithInt(int i) {\n+            this.i = i;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ValueClassWithDouble {\n+        double d;\n+\n+        ValueClassWithDouble(double d) {\n+            this.d = d;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static abstract value class AbstractValueClassWithByte {\n+        byte b;\n+\n+        AbstractValueClassWithByte(byte b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class SubValueClassWithInt extends AbstractValueClassWithByte {\n+        int i;\n+\n+        SubValueClassWithInt(int i) {\n+            this.i = i;\n+            super((byte)(i + 1));\n+        }\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class SubValueClassWithDouble extends AbstractValueClassWithByte {\n+        double d;\n+\n+        SubValueClassWithDouble(double d) {\n+            this.d = d;\n+            super((byte)(d + 1));\n+        }\n+    }\n+\n+    static final ValueClassWithInt[] VALUE_CLASS_WITH_INT_ARRAY = (ValueClassWithInt[]) ValueClass.newNullRestrictedArray(ValueClassWithInt.class, 2);\n+    static final ValueClassWithDouble[] VALUE_CLASS_WITH_DOUBLE_ARRAY = (ValueClassWithDouble[]) ValueClass.newNullRestrictedArray(ValueClassWithDouble.class, 2);\n+    static final SubValueClassWithInt[] SUB_VALUE_CLASS_WITH_INT_ARRAY = (SubValueClassWithInt[]) ValueClass.newNullRestrictedArray(SubValueClassWithInt.class, 2);\n+    static final SubValueClassWithDouble[] SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY = (SubValueClassWithDouble[]) ValueClass.newNullRestrictedArray(SubValueClassWithDouble.class, 2);\n+\n+\/\/ TODO: Can only be enabled once JDK-8343835 is fixed. Otherwise, we hit the mismatched stores assert.\n+\/\/    static {\n+\/\/        VALUE_CLASS_WITH_INT_ARRAY[0] = new ValueClassWithInt(5);\n+\/\/        VALUE_CLASS_WITH_DOUBLE_ARRAY[0] = new ValueClassWithDouble(6);\n+\/\/        SUB_VALUE_CLASS_WITH_INT_ARRAY[0] = new SubValueClassWithInt(7);\n+\/\/        SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY[0] = new SubValueClassWithDouble(8);\n+\/\/    }\n+\n+    @Test\n+    static void testFlatArrayInexactObjectStore(Object o, boolean flag) {\n+        Object[] oArr;\n+        if (flag) {\n+            oArr = VALUE_CLASS_WITH_INT_ARRAY; \/\/ VALUE_CLASS_WITH_INT_ARRAY is statically known to be flat.\n+        } else {\n+            oArr = VALUE_CLASS_WITH_DOUBLE_ARRAY; \/\/ VALUE_CLASS_WITH_DOUBLE_ARRAY is statically known to be flat.\n+        }\n+        \/\/ The type of 'oArr' is inexact here because we merge two arrays. Since both arrays are flat, 'oArr' is also flat:\n+        \/\/     Type: flat:narrowoop: java\/lang\/Object:NotNull * (flat in array)[int:2]\n+        \/\/ Since the type is inexact, we do not know the exact flat array layout statically and thus need to fall back\n+        \/\/ to call \"store_unknown_inline_Type()\" at runtime where we know the flat array layout\n+        oArr[0] = o;\n+    }\n+\n+    @Test\n+    static Object testFlatArrayInexactObjectLoad(boolean flag) {\n+        Object[] oArr;\n+        if (flag) {\n+            oArr = VALUE_CLASS_WITH_INT_ARRAY; \/\/ VALUE_CLASS_WITH_INT_ARRAY is statically known to be flat.\n+        } else {\n+            oArr = VALUE_CLASS_WITH_DOUBLE_ARRAY; \/\/ VALUE_CLASS_WITH_DOUBLE_ARRAY is statically known to be flat.\n+        }\n+        \/\/ The type of 'oArr' is inexact here because we merge two arrays. Since both arrays are flat, 'oArr' is also flat:\n+        \/\/     Type: flat:narrowoop: java\/lang\/Object:NotNull * (flat in array)[int:2]\n+        \/\/ Since the type is inexact, we do not know the exact flat array layout statically and thus need to fall back\n+        \/\/ to call \"load_unknown_inline_Type()\" at runtime where we know the flat array layout\n+        return oArr[0];\n+    }\n+\n+    @Test\n+    static void testFlatArrayInexactAbstractValueClassStore(AbstractValueClassWithByte abstractValueClassWithByte,\n+                                                            boolean flag) {\n+        AbstractValueClassWithByte[] avArr;\n+        if (flag) {\n+            avArr = SUB_VALUE_CLASS_WITH_INT_ARRAY;\n+        } else {\n+            avArr = SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY;\n+        }\n+        \/\/ Same as testFlatArrayInexactObjectStore() but the inexact type is with an abstract value class:\n+        \/\/    flat:narrowoop: compiler\/valhalla\/inlinetypes\/TestLWorld$AbstractValueClassWithByte:NotNull * (flat in array)[int:2]\n+        avArr[0] = abstractValueClassWithByte;\n+    }\n+\n+    @Test\n+    static AbstractValueClassWithByte testFlatArrayInexactAbstractValueClassLoad(boolean flag) {\n+        AbstractValueClassWithByte[] avArr;\n+        if (flag) {\n+            avArr = SUB_VALUE_CLASS_WITH_INT_ARRAY;\n+        } else {\n+            avArr = SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY;\n+        }\n+        \/\/ Same as testFlatArrayInexactObjectLoad() but the inexact type is with an abstract value class:\n+        \/\/    flat:narrowoop: compiler\/valhalla\/inlinetypes\/TestLWorld$AbstractValueClassWithByte:NotNull * (flat in array)[int:2]\n+        return avArr[0];\n+    }\n+\n+    @Run(test = {\"testFlatArrayInexactObjectStore\",\n+                 \"testFlatArrayInexactObjectLoad\",\n+                 \"testFlatArrayInexactAbstractValueClassStore\",\n+                 \"testFlatArrayInexactAbstractValueClassLoad\"})\n+    static void runFlatArrayInexactLoadAndStore() {\n+        \/\/ TODO: Remove these again once JDK-8343835 is fixed and uncomment static initializer above\n+        VALUE_CLASS_WITH_INT_ARRAY[0] = new ValueClassWithInt(5);\n+        VALUE_CLASS_WITH_DOUBLE_ARRAY[0] = new ValueClassWithDouble(6);\n+        SUB_VALUE_CLASS_WITH_INT_ARRAY[0] = new SubValueClassWithInt(7);\n+        SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY[0] = new SubValueClassWithDouble(8);\n+\n+        boolean flag = true;\n+        ValueClassWithInt valueClassWithInt = new ValueClassWithInt(15);\n+        ValueClassWithDouble valueClassWithDouble = new ValueClassWithDouble(16);\n+\n+        testFlatArrayInexactObjectStore(valueClassWithInt, true);\n+        Asserts.assertEQ(valueClassWithInt, VALUE_CLASS_WITH_INT_ARRAY[0]);\n+        testFlatArrayInexactObjectStore(valueClassWithDouble, false);\n+        Asserts.assertEQ(valueClassWithDouble, VALUE_CLASS_WITH_DOUBLE_ARRAY[0]);\n+\n+        Asserts.assertEQ(valueClassWithInt, testFlatArrayInexactObjectLoad(true));\n+        Asserts.assertEQ(valueClassWithDouble, testFlatArrayInexactObjectLoad(false));\n+\n+        SubValueClassWithInt subValueClassWithInt = new SubValueClassWithInt(17);\n+        SubValueClassWithDouble subValueClassWithDouble = new SubValueClassWithDouble(18);\n+\n+        testFlatArrayInexactAbstractValueClassStore(subValueClassWithInt, true);\n+        Asserts.assertEQ(subValueClassWithInt, SUB_VALUE_CLASS_WITH_INT_ARRAY[0]);\n+        testFlatArrayInexactAbstractValueClassStore(subValueClassWithDouble, false);\n+        Asserts.assertEQ(subValueClassWithDouble, SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY[0]);\n+\n+        Asserts.assertEQ(subValueClassWithInt, testFlatArrayInexactAbstractValueClassLoad(true));\n+        Asserts.assertEQ(subValueClassWithDouble, testFlatArrayInexactAbstractValueClassLoad(false));\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"modified"}]}