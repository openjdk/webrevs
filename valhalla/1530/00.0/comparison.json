{"files":[{"patch":"@@ -82,2 +82,0 @@\n-    -taglet build.tools.taglet.PreviewNote \\\n-    --preview-note-tag previewNote \\\n@@ -547,1 +545,3 @@\n-SPEC_FILTER := %\n+ifeq ($(SPEC_FILTER), )\n+  SPEC_FILTER := %\n+endif\n","filename":"make\/Docs.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,1 +130,2 @@\n-      systemDictionaryShared.cpp\n+      systemDictionaryShared.cpp \\\n+      trainingData.cpp\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7789,2 +7789,1 @@\n-  format %{ \"movw   $src, $src\\n\\t\"\n-            \"mov    $tmp, $src\\t# vector (1D)\\n\\t\"\n+  format %{ \"fmovs  $tmp, $src\\t# vector (1S)\\n\\t\"\n@@ -7795,2 +7794,1 @@\n-    __ movw($src$$Register, $src$$Register); \/\/ ensure top 32 bits 0\n-    __ mov($tmp$$FloatRegister, __ D, 0, $src$$Register);\n+    __ fmovs($tmp$$FloatRegister, $src$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,2 +89,0 @@\n-  product(bool, NearCpool, true,                                        \\\n-         \"constant pool is close to instructions\")                      \\\n@@ -103,0 +101,2 @@\n+  product(bool, UseSIMDForSHA3Intrinsic, true,                          \\\n+          \"Use SIMD SHA3 instructions for SHA3 intrinsic\")              \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1022,3 +1022,2 @@\n-                                                      int constant,\n-                                                      bool decrement) {\n-  increment_mdp_data_at(mdp_in, noreg, constant, decrement);\n+                                                      int constant) {\n+  increment_mdp_data_at(mdp_in, noreg, constant);\n@@ -1028,3 +1027,2 @@\n-                                                      Register reg,\n-                                                      int constant,\n-                                                      bool decrement) {\n+                                                      Register index,\n+                                                      int constant) {\n@@ -1032,3 +1030,1 @@\n-  \/\/ %%% this does 64bit counters at best it is wasting space\n-  \/\/ at worst it is a rare bug when counters overflow\n-  assert_different_registers(rscratch2, rscratch1, mdp_in, reg);\n+  assert_different_registers(rscratch2, rscratch1, mdp_in, index);\n@@ -1038,1 +1034,1 @@\n-  Address addr2(rscratch2, reg, Address::lsl(0));\n+  Address addr2(rscratch2, index, Address::lsl(0));\n@@ -1040,1 +1036,1 @@\n-  if (reg != noreg) {\n+  if (index != noreg) {\n@@ -1045,31 +1041,1 @@\n-  if (decrement) {\n-    \/\/ Decrement the register.  Set condition codes.\n-    \/\/ Intel does this\n-    \/\/ addptr(data, (int32_t) -DataLayout::counter_increment);\n-    \/\/ If the decrement causes the counter to overflow, stay negative\n-    \/\/ Label L;\n-    \/\/ jcc(Assembler::negative, L);\n-    \/\/ addptr(data, (int32_t) DataLayout::counter_increment);\n-    \/\/ so we do this\n-    ldr(rscratch1, addr);\n-    subs(rscratch1, rscratch1, (unsigned)DataLayout::counter_increment);\n-    Label L;\n-    br(Assembler::LO, L);       \/\/ skip store if counter underflow\n-    str(rscratch1, addr);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    \/\/ Intel does this\n-    \/\/ Increment the register.  Set carry flag.\n-    \/\/ addptr(data, DataLayout::counter_increment);\n-    \/\/ If the increment causes the counter to overflow, pull back by 1.\n-    \/\/ sbbptr(data, (int32_t)0);\n-    \/\/ so we do this\n-    ldr(rscratch1, addr);\n-    adds(rscratch1, rscratch1, DataLayout::counter_increment);\n-    Label L;\n-    br(Assembler::CS, L);       \/\/ skip store if counter overflow\n-    str(rscratch1, addr);\n-    bind(L);\n-  }\n+  increment(addr, DataLayout::counter_increment);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":8,"deletions":42,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -272,5 +272,2 @@\n-  void increment_mdp_data_at(Address data, bool decrement = false);\n-  void increment_mdp_data_at(Register mdp_in, int constant,\n-                             bool decrement = false);\n-  void increment_mdp_data_at(Register mdp_in, Register reg, int constant,\n-                             bool decrement = false);\n+  void increment_mdp_data_at(Register mdp_in, int constant);\n+  void increment_mdp_data_at(Register mdp_in, Register index, int constant);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -331,0 +331,21 @@\n+  inline void rolw(Register Rd, Register Rn, unsigned imm) {\n+    extrw(Rd, Rn, Rn, (32 - imm));\n+  }\n+\n+  inline void rol(Register Rd, Register Rn, unsigned imm) {\n+    extr(Rd, Rn, Rn, (64 - imm));\n+  }\n+\n+  using Assembler::rax1;\n+  using Assembler::eor3;\n+\n+  inline void rax1(Register Rd, Register Rn, Register Rm) {\n+    eor(Rd, Rn, Rm, ROR, 63); \/\/ Rd = Rn ^ rol(Rm, 1)\n+  }\n+\n+  inline void eor3(Register Rd, Register Rn, Register Rm, Register Rk) {\n+    assert(Rd != Rn, \"Use tmp register\");\n+    eor(Rd, Rm, Rk);\n+    eor(Rd, Rd, Rn);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -7106,0 +7106,360 @@\n+  void bcax5(Register a0, Register a1, Register a2, Register a3, Register a4,\n+             Register tmp0, Register tmp1, Register tmp2) {\n+    __ bic(tmp0, a2, a1); \/\/ for a0\n+    __ bic(tmp1, a3, a2); \/\/ for a1\n+    __ bic(tmp2, a4, a3); \/\/ for a2\n+    __ eor(a2, a2, tmp2);\n+    __ bic(tmp2, a0, a4); \/\/ for a3\n+    __ eor(a3, a3, tmp2);\n+    __ bic(tmp2, a1, a0); \/\/ for a4\n+    __ eor(a0, a0, tmp0);\n+    __ eor(a1, a1, tmp1);\n+    __ eor(a4, a4, tmp2);\n+  }\n+\n+  void keccak_round_gpr(bool can_use_fp, bool can_use_r18, Register rc,\n+                        Register a0, Register a1, Register a2, Register a3, Register a4,\n+                        Register a5, Register a6, Register a7, Register a8, Register a9,\n+                        Register a10, Register a11, Register a12, Register a13, Register a14,\n+                        Register a15, Register a16, Register a17, Register a18, Register a19,\n+                        Register a20, Register a21, Register a22, Register a23, Register a24,\n+                        Register tmp0, Register tmp1, Register tmp2) {\n+    __ eor3(tmp1, a4, a9, a14);\n+    __ eor3(tmp0, tmp1, a19, a24); \/\/ tmp0 = a4^a9^a14^a19^a24 = c4\n+    __ eor3(tmp2, a1, a6, a11);\n+    __ eor3(tmp1, tmp2, a16, a21); \/\/ tmp1 = a1^a6^a11^a16^a21 = c1\n+    __ rax1(tmp2, tmp0, tmp1); \/\/ d0\n+    {\n+\n+      Register tmp3, tmp4;\n+      if (can_use_fp && can_use_r18) {\n+        tmp3 = rfp;\n+        tmp4 = r18_tls;\n+      } else {\n+        tmp3 = a4;\n+        tmp4 = a9;\n+        __ stp(tmp3, tmp4, __ pre(sp, -16));\n+      }\n+\n+      __ eor3(tmp3, a0, a5, a10);\n+      __ eor3(tmp4, tmp3, a15, a20); \/\/ tmp4 = a0^a5^a10^a15^a20 = c0\n+      __ eor(a0, a0, tmp2);\n+      __ eor(a5, a5, tmp2);\n+      __ eor(a10, a10, tmp2);\n+      __ eor(a15, a15, tmp2);\n+      __ eor(a20, a20, tmp2); \/\/ d0(tmp2)\n+      __ eor3(tmp3, a2, a7, a12);\n+      __ eor3(tmp2, tmp3, a17, a22); \/\/ tmp2 = a2^a7^a12^a17^a22 = c2\n+      __ rax1(tmp3, tmp4, tmp2); \/\/ d1\n+      __ eor(a1, a1, tmp3);\n+      __ eor(a6, a6, tmp3);\n+      __ eor(a11, a11, tmp3);\n+      __ eor(a16, a16, tmp3);\n+      __ eor(a21, a21, tmp3); \/\/ d1(tmp3)\n+      __ rax1(tmp3, tmp2, tmp0); \/\/ d3\n+      __ eor3(tmp2, a3, a8, a13);\n+      __ eor3(tmp0, tmp2, a18, a23);  \/\/ tmp0 = a3^a8^a13^a18^a23 = c3\n+      __ eor(a3, a3, tmp3);\n+      __ eor(a8, a8, tmp3);\n+      __ eor(a13, a13, tmp3);\n+      __ eor(a18, a18, tmp3);\n+      __ eor(a23, a23, tmp3);\n+      __ rax1(tmp2, tmp1, tmp0); \/\/ d2\n+      __ eor(a2, a2, tmp2);\n+      __ eor(a7, a7, tmp2);\n+      __ eor(a12, a12, tmp2);\n+      __ rax1(tmp0, tmp0, tmp4); \/\/ d4\n+      if (!can_use_fp || !can_use_r18) {\n+        __ ldp(tmp3, tmp4, __ post(sp, 16));\n+      }\n+      __ eor(a17, a17, tmp2);\n+      __ eor(a22, a22, tmp2);\n+      __ eor(a4, a4, tmp0);\n+      __ eor(a9, a9, tmp0);\n+      __ eor(a14, a14, tmp0);\n+      __ eor(a19, a19, tmp0);\n+      __ eor(a24, a24, tmp0);\n+    }\n+\n+    __ rol(tmp0, a10, 3);\n+    __ rol(a10, a1, 1);\n+    __ rol(a1, a6, 44);\n+    __ rol(a6, a9, 20);\n+    __ rol(a9, a22, 61);\n+    __ rol(a22, a14, 39);\n+    __ rol(a14, a20, 18);\n+    __ rol(a20, a2, 62);\n+    __ rol(a2, a12, 43);\n+    __ rol(a12, a13, 25);\n+    __ rol(a13, a19, 8) ;\n+    __ rol(a19, a23, 56);\n+    __ rol(a23, a15, 41);\n+    __ rol(a15, a4, 27);\n+    __ rol(a4, a24, 14);\n+    __ rol(a24, a21, 2);\n+    __ rol(a21, a8, 55);\n+    __ rol(a8, a16, 45);\n+    __ rol(a16, a5, 36);\n+    __ rol(a5, a3, 28);\n+    __ rol(a3, a18, 21);\n+    __ rol(a18, a17, 15);\n+    __ rol(a17, a11, 10);\n+    __ rol(a11, a7, 6);\n+    __ mov(a7, tmp0);\n+\n+    bcax5(a0, a1, a2, a3, a4, tmp0, tmp1, tmp2);\n+    bcax5(a5, a6, a7, a8, a9, tmp0, tmp1, tmp2);\n+    bcax5(a10, a11, a12, a13, a14, tmp0, tmp1, tmp2);\n+    bcax5(a15, a16, a17, a18, a19, tmp0, tmp1, tmp2);\n+    bcax5(a20, a21, a22, a23, a24, tmp0, tmp1, tmp2);\n+\n+    __ ldr(tmp1, __ post(rc, 8));\n+    __ eor(a0, a0, tmp1);\n+\n+  }\n+\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - byte[]  source+offset\n+  \/\/   c_rarg1   - byte[]  SHA.state\n+  \/\/   c_rarg2   - int     block_size\n+  \/\/   c_rarg3   - int     offset\n+  \/\/   c_rarg4   - int     limit\n+  \/\/\n+  address generate_sha3_implCompress_gpr(StubGenStubId stub_id) {\n+    bool multi_block;\n+    switch (stub_id) {\n+    case sha3_implCompress_id:\n+      multi_block = false;\n+      break;\n+    case sha3_implCompressMB_id:\n+      multi_block = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+\n+    static const uint64_t round_consts[24] = {\n+      0x0000000000000001L, 0x0000000000008082L, 0x800000000000808AL,\n+      0x8000000080008000L, 0x000000000000808BL, 0x0000000080000001L,\n+      0x8000000080008081L, 0x8000000000008009L, 0x000000000000008AL,\n+      0x0000000000000088L, 0x0000000080008009L, 0x000000008000000AL,\n+      0x000000008000808BL, 0x800000000000008BL, 0x8000000000008089L,\n+      0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,\n+      0x000000000000800AL, 0x800000008000000AL, 0x8000000080008081L,\n+      0x8000000000008080L, 0x0000000080000001L, 0x8000000080008008L\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, stub_id);\n+    address start = __ pc();\n+\n+    Register buf           = c_rarg0;\n+    Register state         = c_rarg1;\n+    Register block_size    = c_rarg2;\n+    Register ofs           = c_rarg3;\n+    Register limit         = c_rarg4;\n+\n+    \/\/ use r3.r17,r19..r28 to keep a0..a24.\n+    \/\/ a0..a24 are respective locals from SHA3.java\n+    Register a0 = r25,\n+             a1 = r26,\n+             a2 = r27,\n+             a3 = r3,\n+             a4 = r4,\n+             a5 = r5,\n+             a6 = r6,\n+             a7 = r7,\n+             a8 = rscratch1, \/\/ r8\n+             a9 = rscratch2, \/\/ r9\n+             a10 = r10,\n+             a11 = r11,\n+             a12 = r12,\n+             a13 = r13,\n+             a14 = r14,\n+             a15 = r15,\n+             a16 = r16,\n+             a17 = r17,\n+             a18 = r28,\n+             a19 = r19,\n+             a20 = r20,\n+             a21 = r21,\n+             a22 = r22,\n+             a23 = r23,\n+             a24 = r24;\n+\n+    Register tmp0 = block_size, tmp1 = buf, tmp2 = state, tmp3 = r30;\n+\n+    Label sha3_loop, rounds24_preloop, loop_body;\n+    Label sha3_512_or_sha3_384, shake128;\n+\n+    bool can_use_r18 = false;\n+#ifndef R18_RESERVED\n+    can_use_r18 = true;\n+#endif\n+    bool can_use_fp = !PreserveFramePointer;\n+\n+    __ enter();\n+\n+    \/\/ save almost all yet unsaved gpr registers on stack\n+    __ str(block_size, __ pre(sp, -128));\n+    if (multi_block) {\n+      __ stpw(ofs, limit, Address(sp, 8));\n+    }\n+    \/\/ 8 bytes at sp+16 will be used to keep buf\n+    __ stp(r19, r20, Address(sp, 32));\n+    __ stp(r21, r22, Address(sp, 48));\n+    __ stp(r23, r24, Address(sp, 64));\n+    __ stp(r25, r26, Address(sp, 80));\n+    __ stp(r27, r28, Address(sp, 96));\n+    if (can_use_r18 && can_use_fp) {\n+      __ stp(r18_tls, state, Address(sp, 112));\n+    } else {\n+      __ str(state, Address(sp, 112));\n+    }\n+\n+    \/\/ begin sha3 calculations: loading a0..a24 from state arrary\n+    __ ldp(a0, a1, state);\n+    __ ldp(a2, a3, Address(state, 16));\n+    __ ldp(a4, a5, Address(state, 32));\n+    __ ldp(a6, a7, Address(state, 48));\n+    __ ldp(a8, a9, Address(state, 64));\n+    __ ldp(a10, a11, Address(state, 80));\n+    __ ldp(a12, a13, Address(state, 96));\n+    __ ldp(a14, a15, Address(state, 112));\n+    __ ldp(a16, a17, Address(state, 128));\n+    __ ldp(a18, a19, Address(state, 144));\n+    __ ldp(a20, a21, Address(state, 160));\n+    __ ldp(a22, a23, Address(state, 176));\n+    __ ldr(a24, Address(state, 192));\n+\n+    __ BIND(sha3_loop);\n+\n+    \/\/ load input\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a0, a0, tmp3);\n+    __ eor(a1, a1, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a2, a2, tmp3);\n+    __ eor(a3, a3, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a4, a4, tmp3);\n+    __ eor(a5, a5, tmp2);\n+    __ ldr(tmp3, __ post(buf, 8));\n+    __ eor(a6, a6, tmp3);\n+\n+    \/\/ block_size == 72, SHA3-512; block_size == 104, SHA3-384\n+    __ tbz(block_size, 7, sha3_512_or_sha3_384);\n+\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a7, a7, tmp3);\n+    __ eor(a8, a8, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a9, a9, tmp3);\n+    __ eor(a10, a10, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a11, a11, tmp3);\n+    __ eor(a12, a12, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a13, a13, tmp3);\n+    __ eor(a14, a14, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a15, a15, tmp3);\n+    __ eor(a16, a16, tmp2);\n+\n+    \/\/ block_size == 136, bit4 == 0 and bit5 == 0, SHA3-256 or SHAKE256\n+    __ andw(tmp2, block_size, 48);\n+    __ cbzw(tmp2, rounds24_preloop);\n+    __ tbnz(block_size, 5, shake128);\n+    \/\/ block_size == 144, bit5 == 0, SHA3-244\n+    __ ldr(tmp3, __ post(buf, 8));\n+    __ eor(a17, a17, tmp3);\n+    __ b(rounds24_preloop);\n+\n+    __ BIND(shake128);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a17, a17, tmp3);\n+    __ eor(a18, a18, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a19, a19, tmp3);\n+    __ eor(a20, a20, tmp2);\n+    __ b(rounds24_preloop); \/\/ block_size == 168, SHAKE128\n+\n+    __ BIND(sha3_512_or_sha3_384);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a7, a7, tmp3);\n+    __ eor(a8, a8, tmp2);\n+    __ tbz(block_size, 5, rounds24_preloop); \/\/ SHA3-512\n+\n+    \/\/ SHA3-384\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a9, a9, tmp3);\n+    __ eor(a10, a10, tmp2);\n+    __ ldp(tmp3, tmp2, __ post(buf, 16));\n+    __ eor(a11, a11, tmp3);\n+    __ eor(a12, a12, tmp2);\n+\n+    __ BIND(rounds24_preloop);\n+    __ fmovs(v0, 24.0); \/\/ float loop counter,\n+    __ fmovs(v1, 1.0);  \/\/ exact representation\n+\n+    __ str(buf, Address(sp, 16));\n+    __ lea(tmp3, ExternalAddress((address) round_consts));\n+\n+    __ BIND(loop_body);\n+    keccak_round_gpr(can_use_fp, can_use_r18, tmp3,\n+                     a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,\n+                     a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24,\n+                     tmp0, tmp1, tmp2);\n+    __ fsubs(v0, v0, v1);\n+    __ fcmps(v0, 0.0);\n+    __ br(__ NE, loop_body);\n+\n+    if (multi_block) {\n+      __ ldrw(block_size, sp); \/\/ block_size\n+      __ ldpw(tmp2, tmp1, Address(sp, 8)); \/\/ offset, limit\n+      __ addw(tmp2, tmp2, block_size);\n+      __ cmpw(tmp2, tmp1);\n+      __ strw(tmp2, Address(sp, 8)); \/\/ store offset in case we're jumping\n+      __ ldr(buf, Address(sp, 16)); \/\/ restore buf in case we're jumping\n+      __ br(Assembler::LE, sha3_loop);\n+      __ movw(c_rarg0, tmp2); \/\/ return offset\n+    }\n+    if (can_use_fp && can_use_r18) {\n+      __ ldp(r18_tls, state, Address(sp, 112));\n+    } else {\n+      __ ldr(state, Address(sp, 112));\n+    }\n+    \/\/ save calculated sha3 state\n+    __ stp(a0, a1, Address(state));\n+    __ stp(a2, a3, Address(state, 16));\n+    __ stp(a4, a5, Address(state, 32));\n+    __ stp(a6, a7, Address(state, 48));\n+    __ stp(a8, a9, Address(state, 64));\n+    __ stp(a10, a11, Address(state, 80));\n+    __ stp(a12, a13, Address(state, 96));\n+    __ stp(a14, a15, Address(state, 112));\n+    __ stp(a16, a17, Address(state, 128));\n+    __ stp(a18, a19, Address(state, 144));\n+    __ stp(a20, a21, Address(state, 160));\n+    __ stp(a22, a23, Address(state, 176));\n+    __ str(a24, Address(state, 192));\n+\n+    \/\/ restore required registers from stack\n+    __ ldp(r19, r20, Address(sp, 32));\n+    __ ldp(r21, r22, Address(sp, 48));\n+    __ ldp(r23, r24, Address(sp, 64));\n+    __ ldp(r25, r26, Address(sp, 80));\n+    __ ldp(r27, r28, Address(sp, 96));\n+    if (can_use_fp && can_use_r18) {\n+      __ add(rfp, sp, 128); \/\/ leave() will copy rfp to sp below\n+    } \/\/ else no need to recalculate rfp, since it wasn't changed\n+\n+    __ leave();\n+\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -11673,1 +12033,1 @@\n-      StubRoutines::_sha3_implCompress     = generate_sha3_implCompress(StubGenStubId::sha3_implCompress_id);\n+\n@@ -11675,1 +12035,7 @@\n-      StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress(StubGenStubId::sha3_implCompressMB_id);\n+      if (UseSIMDForSHA3Intrinsic) {\n+         StubRoutines::_sha3_implCompress     = generate_sha3_implCompress(StubGenStubId::sha3_implCompress_id);\n+         StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress(StubGenStubId::sha3_implCompressMB_id);\n+      } else {\n+         StubRoutines::_sha3_implCompress     = generate_sha3_implCompress_gpr(StubGenStubId::sha3_implCompress_id);\n+         StubRoutines::_sha3_implCompressMB   = generate_sha3_implCompress_gpr(StubGenStubId::sha3_implCompressMB_id);\n+      }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":368,"deletions":2,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -874,0 +874,4 @@\n+  \/\/ Save ConstMethod* in r5_const_method for later use to avoid loading multiple times\n+  Register r5_const_method = r5;\n+  __ ldr(r5_const_method, Address(rmethod, Method::const_offset()));\n+\n@@ -884,2 +888,1 @@\n-    __ ldr(rscratch1, Address(rmethod, Method::const_offset()));    \/\/ get ConstMethod\n-    __ add(rbcp, rscratch1, in_bytes(ConstMethod::codes_offset())); \/\/ get codebase\n+    __ add(rbcp, r5_const_method, in_bytes(ConstMethod::codes_offset())); \/\/ get codebase\n@@ -905,3 +908,4 @@\n-  __ ldr(rcpool, Address(rmethod, Method::const_offset()));\n-  __ ldr(rcpool, Address(rcpool, ConstMethod::constants_offset()));\n-  __ ldr(rcpool, Address(rcpool, ConstantPool::cache_offset()));\n+  \/\/ Save ConstantPool* in r11_constants for later use to avoid loading multiple times\n+  Register r11_constants = r11;\n+  __ ldr(r11_constants, Address(r5_const_method, ConstMethod::constants_offset()));\n+  __ ldr(rcpool, Address(r11_constants, ConstantPool::cache_offset()));\n@@ -917,2 +921,4 @@\n-  \/\/ Get mirror\n-  __ load_mirror(r10, rmethod, r5, rscratch2);\n+  \/\/ Get mirror. Resolve ConstantPool* -> InstanceKlass* -> Java mirror.\n+  __ ldr(r10, Address(r11_constants, ConstantPool::pool_holder_offset()));\n+  __ ldr(r10, Address(r10, in_bytes(Klass::java_mirror_offset())));\n+  __ resolve_oop_handle(r10, rscratch1, rscratch2);\n@@ -920,2 +926,1 @@\n-    __ ldr(rscratch1, Address(rmethod, Method::const_offset()));\n-    __ ldrh(rscratch1, Address(rscratch1, ConstMethod::max_stack_offset()));\n+    __ ldrh(rscratch1, Address(r5_const_method, ConstMethod::max_stack_offset()));\n@@ -1897,0 +1902,1 @@\n+  __ restore_bcp(); \/\/ We could have returned from deoptimizing this frame, so restore rbcp.\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1176,0 +1176,1 @@\n+  \/\/ Clobbers: r10, r11, r3\n@@ -1199,0 +1200,1 @@\n+  \/\/ Clobbers: r10, r11, r3\n@@ -3052,0 +3054,1 @@\n+      \/\/ Clobbers: r10, r11, r3\n@@ -3073,0 +3076,1 @@\n+        \/\/ Clobbers: r10, r11, r3\n@@ -3086,0 +3090,1 @@\n+        \/\/ Clobbers: r10, r11, r3\n@@ -3303,2 +3308,2 @@\n-  \/\/ R1: field offset, R2: field holder, R3: flags\n-  load_resolved_field_entry(r2, r2, noreg, r1, r3);\n+  \/\/ R1: field offset, R2: field holder, R5: flags\n+  load_resolved_field_entry(r2, r2, noreg, r1, r5);\n@@ -3308,1 +3313,1 @@\n-    __ tbz(r3, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r5, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n@@ -3351,0 +3356,1 @@\n+    \/\/ Clobbers: r10, r11, r3\n@@ -3383,1 +3389,1 @@\n-    __ tbz(r3, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r5, ResolvedFieldEntry::is_volatile_shift, notVolatile);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -121,2 +121,2 @@\n-  product(bool, SuperwordUseVSX, true,                                      \\\n-          \"Use Power8 VSX instructions for superword optimization.\")        \\\n+  product(bool, SuperwordUseVSX, false,                                     \\\n+          \"Use VSX instructions for superword optimization.\")               \\\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -748,1 +748,2 @@\n-      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dtanh\n+      x->id() == vmIntrinsics::_dlog10 || x->id() == vmIntrinsics::_dtanh ||\n+      x->id() == vmIntrinsics::_dcbrt\n@@ -835,1 +836,1 @@\n-       if (StubRoutines::dpow() != nullptr) {\n+      if (StubRoutines::dpow() != nullptr) {\n@@ -856,1 +857,1 @@\n-       if (StubRoutines::dtan() != nullptr) {\n+      if (StubRoutines::dtan() != nullptr) {\n@@ -863,2 +864,2 @@\n-       assert(StubRoutines::dtanh() != nullptr, \"tanh intrinsic not found\");\n-       if (StubRoutines::dtanh() != nullptr) {\n+      assert(StubRoutines::dtanh() != nullptr, \"tanh intrinsic not found\");\n+      if (StubRoutines::dtanh() != nullptr) {\n@@ -868,0 +869,6 @@\n+    case vmIntrinsics::_dcbrt:\n+      assert(StubRoutines::dcbrt() != nullptr, \"cbrt intrinsic not found\");\n+      if (StubRoutines::dcbrt() != nullptr) {\n+        __ call_runtime_leaf(StubRoutines::dcbrt(), getThreadTemp(), result_reg, cc->args());\n+      }\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1459,2 +1459,1 @@\n-void InterpreterMacroAssembler::profile_taken_branch(Register mdp,\n-                                                     Register bumped_count) {\n+void InterpreterMacroAssembler::profile_taken_branch(Register mdp) {\n@@ -1465,1 +1464,0 @@\n-    \/\/ Otherwise, assign to mdp\n@@ -1469,9 +1467,1 @@\n-    \/\/ We inline increment_mdp_data_at to return bumped_count in a register\n-    \/\/increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));\n-    Address data(mdp, in_bytes(JumpData::taken_offset()));\n-    movptr(bumped_count, data);\n-    assert(DataLayout::counter_increment == 1,\n-            \"flow-free idiom only works with 1\");\n-    addptr(bumped_count, DataLayout::counter_increment);\n-    sbbptr(bumped_count, 0);\n-    movptr(data, bumped_count); \/\/ Store back out\n+    increment_mdp_data_at(mdp, in_bytes(JumpData::taken_offset()));\n@@ -1493,1 +1483,1 @@\n-    \/\/ We are taking a branch.  Increment the not taken count.\n+    \/\/ We are not taking a branch.  Increment the not taken count.\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-  void profile_taken_branch(Register mdp, Register bumped_count);\n+  void profile_taken_branch(Register mdp);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2264,0 +2264,10 @@\n+void MacroAssembler::movapd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::movapd(dst, as_Address(src));\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::movapd(dst, Address(rscratch, 0));\n+  }\n+}\n@@ -5735,0 +5745,1 @@\n+  BLOCK_COMMENT(\"encode_klass_not_null {\");\n@@ -5740,1 +5751,1 @@\n-      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+      movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n@@ -5747,0 +5758,1 @@\n+  BLOCK_COMMENT(\"} encode_klass_not_null\");\n@@ -5750,0 +5762,1 @@\n+  BLOCK_COMMENT(\"encode_and_move_klass_not_null {\");\n@@ -5752,1 +5765,1 @@\n-    mov64(dst, -(int64_t)CompressedKlassPointers::base());\n+    movptr(dst, -(intptr_t)CompressedKlassPointers::base());\n@@ -5760,0 +5773,1 @@\n+  BLOCK_COMMENT(\"} encode_and_move_klass_not_null\");\n@@ -5763,0 +5777,1 @@\n+  BLOCK_COMMENT(\"decode_klass_not_null {\");\n@@ -5776,1 +5791,1 @@\n-      mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+      movptr(tmp, (intptr_t)CompressedKlassPointers::base());\n@@ -5780,0 +5795,1 @@\n+  BLOCK_COMMENT(\"} decode_klass_not_null\");\n@@ -5783,0 +5799,1 @@\n+  BLOCK_COMMENT(\"decode_and_move_klass_not_null {\");\n@@ -5798,1 +5815,1 @@\n-        mov64(dst, (int64_t)CompressedKlassPointers::base());\n+        movptr(dst, (intptr_t)CompressedKlassPointers::base());\n@@ -5810,3 +5827,3 @@\n-        const uint64_t base_right_shifted =\n-            (uint64_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n-        mov64(dst, base_right_shifted);\n+        const intptr_t base_right_shifted =\n+            (intptr_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n+        movptr(dst, base_right_shifted);\n@@ -5820,0 +5837,1 @@\n+  BLOCK_COMMENT(\"} decode_and_move_klass_not_null\");\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1053,0 +1053,2 @@\n+  void andnpd(XMMRegister dst, XMMRegister src) { Assembler::andnpd(dst, src); }\n+\n@@ -1065,0 +1067,2 @@\n+  void orpd(XMMRegister dst, XMMRegister src) { Assembler::orpd(dst, src); }\n+\n@@ -1299,0 +1303,3 @@\n+  using Assembler::movapd;\n+  void movapd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3711,0 +3711,3 @@\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dcbrt)) {\n+      StubRoutines::_dcbrt = generate_libmCbrt(); \/\/ from stubGenerator_x86_64_cbrt.cpp\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -559,0 +559,1 @@\n+  address generate_libmCbrt();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1449,0 +1449,1 @@\n+  __ restore_bcp(); \/\/ We could have returned from deoptimizing this frame, so restore rbcp.\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1750,2 +1750,1 @@\n-  __ profile_taken_branch(rax, rbx); \/\/ rax holds updated MDP, rbx\n-                                     \/\/ holds bumped taken count\n+  __ profile_taken_branch(rax); \/\/ rax holds updated MDP\n@@ -1802,1 +1801,0 @@\n-    \/\/ rbx: MDO bumped taken-count\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -912,1 +912,1 @@\n-  if (FLAG_IS_DEFAULT(EnableX86ECoreOpts) && is_intel() && cpu_family() == 6 &&\n+  if (FLAG_IS_DEFAULT(EnableX86ECoreOpts) && is_intel() && is_intel_server_family() &&\n@@ -1597,1 +1597,1 @@\n-    if (cpu_family() == 6 || cpu_family() == 15) {\n+    if (is_intel_server_family() || cpu_family() == 15) {\n@@ -1613,1 +1613,1 @@\n-    if (cpu_family() == 6 && supports_sse3()) { \/\/ New Intel cpus\n+    if (is_intel_server_family() && supports_sse3()) { \/\/ New Intel cpus\n@@ -1851,1 +1851,1 @@\n-  if (is_intel() && cpu_family() == 6 && supports_sse3()) {\n+  if (is_intel() && is_intel_server_family() && supports_sse3()) {\n@@ -3265,1 +3265,1 @@\n-    if (supports_sse3() && cpu_family() == 6) {\n+    if (supports_sse3() && is_intel_server_family()) {\n@@ -3273,1 +3273,1 @@\n-      if (cpu_family() == 6) {\n+      if (is_intel_server_family()) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7106,15 +7106,0 @@\n-instruct addI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddI (LoadI src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eaddl($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n@@ -7424,15 +7409,0 @@\n-instruct addL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AddL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eaddq($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n@@ -8650,1 +8620,0 @@\n-  predicate(!UseAPX);\n@@ -8662,14 +8631,0 @@\n-instruct mulI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulI src1 src2));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eimull($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n@@ -8706,1 +8661,0 @@\n-  predicate(!UseAPX);\n@@ -8718,14 +8672,0 @@\n-instruct mulI_rReg_mem_imm(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulI (LoadI src1) src2));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ eimull($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_mem_alu0);\n-%}\n-\n@@ -8772,1 +8712,0 @@\n-  predicate(!UseAPX);\n@@ -8784,14 +8723,0 @@\n-instruct mulL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulL src1 src2));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eimulq($dst$$Register, $src1$$Register, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_reg_alu0);\n-%}\n-\n@@ -8828,1 +8753,0 @@\n-  predicate(!UseAPX);\n@@ -8840,14 +8764,0 @@\n-instruct mulL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (MulL (LoadL src1) src2));\n-  effect(KILL cr);\n-\n-  ins_cost(300);\n-  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eimulq($dst$$Register, $src1$$Address, $src2$$constant, false);\n-  %}\n-  ins_pipe(ialu_reg_mem_alu0);\n-%}\n-\n@@ -10743,15 +10653,0 @@\n-instruct xorI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (XorI (LoadI src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n-  ins_encode %{\n-    __ exorl($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n@@ -10937,15 +10832,0 @@\n-instruct andL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (AndL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ eandq($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n@@ -11447,15 +11327,0 @@\n-instruct xorL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n-%{\n-  predicate(UseAPX);\n-  match(Set dst (XorL (LoadL src1) src2));\n-  effect(KILL cr);\n-  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n-\n-  ins_cost(150);\n-  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n-  ins_encode %{\n-    __ exorq($dst$$Register, $src1$$Address, $src2$$Register, false);\n-  %}\n-  ins_pipe(ialu_reg_mem);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":135,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -436,0 +436,2 @@\n+  void init();\n+\n@@ -462,0 +464,2 @@\n+  void init();\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3580,0 +3580,1 @@\n+  case vmIntrinsics::_dcbrt         : \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3370,0 +3370,1 @@\n+  case vmIntrinsics::_dcbrt :         \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -378,0 +378,1 @@\n+  FUNCTION_CASE(entry, StubRoutines::dcbrt());\n@@ -648,1 +649,1 @@\n-  JRT_BLOCK\n+  JRT_BLOCK_NO_ASYNC\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+bool CDSConfig::_is_single_command_training = false;\n+bool CDSConfig::_has_temp_aot_config_file = false;\n@@ -422,1 +424,1 @@\n-  \/\/ \"New\" AOT flags must not be mixed with \"classic\" flags such as -Xshare:dump\n+  \/\/ \"New\" AOT flags must not be mixed with \"classic\" CDS flags such as -Xshare:dump\n@@ -424,0 +426,1 @@\n+  CHECK_NEW_FLAG(AOTCacheOutput);\n@@ -428,0 +431,1 @@\n+  CHECK_SINGLE_PATH(AOTCacheOutput);\n@@ -437,2 +441,7 @@\n-  if (FLAG_IS_DEFAULT(AOTCache) && FLAG_IS_DEFAULT(AOTConfiguration) && FLAG_IS_DEFAULT(AOTMode)) {\n-    \/\/ AOTCache\/AOTConfiguration\/AOTMode not used -> using the \"classic CDS\" workflow.\n+  bool has_cache = !FLAG_IS_DEFAULT(AOTCache);\n+  bool has_cache_output = !FLAG_IS_DEFAULT(AOTCacheOutput);\n+  bool has_config = !FLAG_IS_DEFAULT(AOTConfiguration);\n+  bool has_mode = !FLAG_IS_DEFAULT(AOTMode);\n+\n+  if (!has_cache && !has_cache_output && !has_config && !has_mode) {\n+    \/\/ AOT flags are not used. Use classic CDS workflow\n@@ -440,2 +449,0 @@\n-  } else {\n-    _new_aot_flags_used = true;\n@@ -444,0 +451,16 @@\n+  if (has_cache && has_cache_output) {\n+    vm_exit_during_initialization(\"Only one of AOTCache or AOTCacheOutput can be specified\");\n+  }\n+\n+  if (!has_cache && (!has_mode || strcmp(AOTMode, \"auto\") == 0)) {\n+    if (has_cache_output) {\n+      \/\/ If AOTCacheOutput has been set, effective mode is \"record\".\n+      \/\/ Default value for AOTConfiguration, if necessary, will be assigned in check_aotmode_record().\n+      log_info(aot)(\"Selected AOTMode=record because AOTCacheOutput is specified\");\n+      FLAG_SET_ERGO(AOTMode, \"record\");\n+    }\n+  }\n+\n+  \/\/ At least one AOT flag has been used\n+  _new_aot_flags_used = true;\n+\n@@ -448,0 +471,2 @@\n+  } else if (strcmp(AOTMode, \"record\") == 0) {\n+    check_aotmode_record();\n@@ -449,11 +474,2 @@\n-    \/\/ AOTMode is record or create\n-    if (FLAG_IS_DEFAULT(AOTConfiguration)) {\n-      vm_exit_during_initialization(err_msg(\"-XX:AOTMode=%s cannot be used without setting AOTConfiguration\", AOTMode));\n-    }\n-\n-    if (strcmp(AOTMode, \"record\") == 0) {\n-      check_aotmode_record();\n-    } else {\n-      assert(strcmp(AOTMode, \"create\") == 0, \"checked by AOTModeConstraintFunc\");\n-      check_aotmode_create();\n-    }\n+    assert(strcmp(AOTMode, \"create\") == 0, \"checked by AOTModeConstraintFunc\");\n+    check_aotmode_create();\n@@ -474,1 +490,2 @@\n-    vm_exit_during_initialization(\"AOTConfiguration can only be used with -XX:AOTMode=record or -XX:AOTMode=create\");\n+    vm_exit_during_initialization(err_msg(\"AOTConfiguration can only be used with when AOTMode is record or create (selected AOTMode = %s)\",\n+                                          FLAG_IS_DEFAULT(AOTMode) ? \"auto\" : AOTMode));\n@@ -486,0 +503,29 @@\n+\/\/ %p substitution in AOTCache, AOTCacheOutput and AOTCacheConfiguration\n+static void substitute_aot_filename(JVMFlagsEnum flag_enum) {\n+  JVMFlag* flag = JVMFlag::flag_from_enum(flag_enum);\n+  const char* filename = flag->read<const char*>();\n+  assert(filename != nullptr, \"must not have default value\");\n+\n+  \/\/ For simplicity, we don't allow %p\/%t to be specified twice, because make_log_name()\n+  \/\/ substitutes only the first occurrence. Otherwise, if we run with\n+  \/\/     java -XX:AOTCacheOutput=%p%p.aot\n+ \/\/ it will end up with both the pid of the training process and the assembly process.\n+  const char* first_p = strstr(filename, \"%p\");\n+  if (first_p != nullptr && strstr(first_p + 2, \"%p\") != nullptr) {\n+    vm_exit_during_initialization(err_msg(\"%s cannot contain more than one %%p\", flag->name()));\n+  }\n+  const char* first_t = strstr(filename, \"%t\");\n+  if (first_t != nullptr && strstr(first_t + 2, \"%t\") != nullptr) {\n+    vm_exit_during_initialization(err_msg(\"%s cannot contain more than one %%t\", flag->name()));\n+  }\n+\n+  \/\/ Note: with single-command training, %p will be the pid of the training process, not the\n+  \/\/ assembly process.\n+  const char* new_filename = make_log_name(filename, nullptr);\n+  if (strcmp(filename, new_filename) != 0) {\n+    JVMFlag::Error err = JVMFlagAccess::set_ccstr(flag, &new_filename, JVMFlagOrigin::ERGONOMIC);\n+    assert(err == JVMFlag::SUCCESS, \"must never fail\");\n+  }\n+  FREE_C_HEAP_ARRAY(char, new_filename);\n+}\n+\n@@ -487,0 +533,21 @@\n+  bool has_config = !FLAG_IS_DEFAULT(AOTConfiguration);\n+  bool has_output = !FLAG_IS_DEFAULT(AOTCacheOutput);\n+\n+  if (!has_output && !has_config) {\n+      vm_exit_during_initialization(\"At least one of AOTCacheOutput and AOTConfiguration must be specified when using -XX:AOTMode=record\");\n+  }\n+\n+  if (has_output) {\n+    _is_single_command_training = true;\n+    substitute_aot_filename(FLAG_MEMBER_ENUM(AOTCacheOutput));\n+    if (!has_config) {\n+      \/\/ Too early; can't use resource allocation yet.\n+      size_t len = strlen(AOTCacheOutput) + 10;\n+      char* temp = AllocateHeap(len, mtArguments);\n+      jio_snprintf(temp, len, \"%s.config\", AOTCacheOutput);\n+      FLAG_SET_ERGO(AOTConfiguration, temp);\n+      FreeHeap(temp);\n+      _has_temp_aot_config_file = true;\n+    }\n+  }\n+\n@@ -491,0 +558,2 @@\n+  substitute_aot_filename(FLAG_MEMBER_ENUM(AOTConfiguration));\n+\n@@ -502,2 +571,11 @@\n-  if (FLAG_IS_DEFAULT(AOTCache)) {\n-    vm_exit_during_initialization(\"AOTCache must be specified when using -XX:AOTMode=create\");\n+  if (FLAG_IS_DEFAULT(AOTConfiguration)) {\n+    vm_exit_during_initialization(\"AOTConfiguration must be specified when using -XX:AOTMode=create\");\n+  }\n+\n+  bool has_cache = !FLAG_IS_DEFAULT(AOTCache);\n+  bool has_cache_output = !FLAG_IS_DEFAULT(AOTCacheOutput);\n+\n+  assert(!(has_cache && has_cache_output), \"already checked\");\n+\n+  if (!has_cache && !has_cache_output) {\n+    vm_exit_during_initialization(\"AOTCache or AOTCacheOutput must be specified when using -XX:AOTMode=create\");\n@@ -506,0 +584,8 @@\n+  if (!has_cache) {\n+    precond(has_cache_output);\n+    FLAG_SET_ERGO(AOTCache, AOTCacheOutput);\n+  }\n+  \/\/ No need to check for (!has_cache_output), as we don't look at AOTCacheOutput after here.\n+\n+  substitute_aot_filename(FLAG_MEMBER_ENUM(AOTCache));\n+\n@@ -556,0 +642,2 @@\n+  setup_compiler_args();\n+\n@@ -628,0 +716,22 @@\n+void CDSConfig::setup_compiler_args() {\n+  \/\/ AOT profiles are supported only in the JEP 483 workflow.\n+  bool can_dump_profiles = AOTClassLinking && new_aot_flags_used();\n+\n+  if (is_dumping_preimage_static_archive() && can_dump_profiles) {\n+    \/\/ JEP 483 workflow -- training\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTRecordTraining, true);\n+    FLAG_SET_ERGO(AOTReplayTraining, false);\n+  } else if (is_dumping_final_static_archive() && can_dump_profiles) {\n+    \/\/ JEP 483 workflow -- assembly\n+    FLAG_SET_ERGO(AOTRecordTraining, false);\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTReplayTraining, true);\n+  } else if (is_using_archive() && new_aot_flags_used()) {\n+    \/\/ JEP 483 workflow -- production\n+    FLAG_SET_ERGO(AOTRecordTraining, false);\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTReplayTraining, true);\n+  } else {\n+    FLAG_SET_ERGO(AOTReplayTraining, false);\n+    FLAG_SET_ERGO(AOTRecordTraining, false);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":129,"deletions":19,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  static bool _is_single_command_training;\n+  static bool _has_temp_aot_config_file;\n@@ -74,0 +76,1 @@\n+  static void setup_compiler_args();\n@@ -153,0 +156,3 @@\n+  static bool is_single_command_training()                   { return CDS_ONLY(_is_single_command_training) NOT_CDS(false); }\n+  static bool has_temp_aot_config_file()                     { return CDS_ONLY(_has_temp_aot_config_file) NOT_CDS(false); }\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/methodCounters.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -67,0 +69,2 @@\n+  f(MethodData) \\\n+  f(MethodCounters) \\\n@@ -70,1 +74,4 @@\n-  f(InlineKlass)\n+  f(InlineKlass) \\\n+  f(KlassTrainingData) \\\n+  f(MethodTrainingData) \\\n+  f(CompileTrainingData)\n@@ -288,1 +295,0 @@\n-  case MetaspaceObj::MethodCountersType:\n@@ -294,4 +300,0 @@\n-  case MetaspaceObj::MethodDataType:\n-    \/\/ We don't archive MethodData <-- should have been removed in removed_unsharable_info\n-    ShouldNotReachHere();\n-    break;\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -299,0 +300,8 @@\n+  _type_profile_level = TypeProfileLevel;\n+  _type_profile_args_limit = TypeProfileArgsLimit;\n+  _type_profile_parms_limit = TypeProfileParmsLimit;\n+  _type_profile_width = TypeProfileWidth;\n+  _bci_profile_width = BciProfileWidth;\n+  _profile_traps = ProfileTraps;\n+  _type_profile_casts = TypeProfileCasts;\n+  _spec_trap_limit_extra_entries = SpecTrapLimitExtraEntries;\n@@ -388,1 +397,1 @@\n-  if (!config->validate(header()->has_aot_linked_classes(), &has_extra_module_paths)) {\n+  if (!config->validate(full_path(), header()->has_aot_linked_classes(), &has_extra_module_paths)) {\n@@ -811,1 +820,1 @@\n-      log_info(aot)(\"Writing binary AOTConfiguration file: %s\",  _full_path);\n+      log_info(aot)(\"Writing AOTCache file: %s\",  _full_path);\n@@ -1733,1 +1742,4 @@\n-  if (MetaspaceShared::use_windows_memory_mapping()) {\n+  if (MetaspaceShared::use_windows_memory_mapping() || UseLargePages) {\n+    \/\/ With UseLargePages, memory mapping may fail on some OSes if the size is not\n+    \/\/ large page aligned, so let's use read() instead. In this case, the memory region\n+    \/\/ is already commited by G1 so we don't need to commit it again.\n@@ -1736,1 +1748,1 @@\n-                     \/* do_commit = *\/ true)) {\n+                     \/* do_commit = *\/ !UseLargePages)) {\n@@ -1999,0 +2011,58 @@\n+  if (TrainingData::have_data()) {\n+    if (_type_profile_level != TypeProfileLevel) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileLevel setting (%d)\"\n+                                            \" does not equal the current TypeProfileLevel setting (%d).\", file_type,\n+                                            _type_profile_level, TypeProfileLevel);\n+      return false;\n+    }\n+    if (_type_profile_args_limit != TypeProfileArgsLimit) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileArgsLimit setting (%d)\"\n+                                            \" does not equal the current TypeProfileArgsLimit setting (%d).\", file_type,\n+                                            _type_profile_args_limit, TypeProfileArgsLimit);\n+      return false;\n+    }\n+    if (_type_profile_parms_limit != TypeProfileParmsLimit) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileParamsLimit setting (%d)\"\n+                                            \" does not equal the current TypeProfileParamsLimit setting (%d).\", file_type,\n+                                            _type_profile_args_limit, TypeProfileArgsLimit);\n+      return false;\n+\n+    }\n+    if (_type_profile_width != TypeProfileWidth) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileWidth setting (%d)\"\n+                                            \" does not equal the current TypeProfileWidth setting (%d).\", file_type,\n+                                            (int)_type_profile_width, (int)TypeProfileWidth);\n+      return false;\n+\n+    }\n+    if (_bci_profile_width != BciProfileWidth) {\n+      MetaspaceShared::report_loading_error(\"The %s's BciProfileWidth setting (%d)\"\n+                                            \" does not equal the current BciProfileWidth setting (%d).\", file_type,\n+                                            (int)_bci_profile_width, (int)BciProfileWidth);\n+      return false;\n+    }\n+    if (_type_profile_casts != TypeProfileCasts) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileCasts setting (%s)\"\n+                                            \" does not equal the current TypeProfileCasts setting (%s).\", file_type,\n+                                            _type_profile_casts ? \"enabled\" : \"disabled\",\n+                                            TypeProfileCasts    ? \"enabled\" : \"disabled\");\n+\n+      return false;\n+\n+    }\n+    if (_profile_traps != ProfileTraps) {\n+      MetaspaceShared::report_loading_error(\"The %s's ProfileTraps setting (%s)\"\n+                                            \" does not equal the current ProfileTraps setting (%s).\", file_type,\n+                                            _profile_traps ? \"enabled\" : \"disabled\",\n+                                            ProfileTraps   ? \"enabled\" : \"disabled\");\n+\n+      return false;\n+    }\n+    if (_spec_trap_limit_extra_entries != SpecTrapLimitExtraEntries) {\n+      MetaspaceShared::report_loading_error(\"The %s's SpecTrapLimitExtraEntries setting (%d)\"\n+                                            \" does not equal the current SpecTrapLimitExtraEntries setting (%d).\", file_type,\n+                                            _spec_trap_limit_extra_entries, SpecTrapLimitExtraEntries);\n+      return false;\n+\n+    }\n+  }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":74,"deletions":4,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -182,0 +182,11 @@\n+\n+  \/\/ The following are parameters that affect MethodData layout.\n+  uint    _type_profile_level;\n+  int     _type_profile_args_limit;\n+  int     _type_profile_parms_limit;\n+  intx    _type_profile_width;\n+  intx    _bci_profile_width;\n+  bool    _profile_traps;\n+  bool    _type_profile_casts;\n+  int     _spec_trap_limit_extra_entries;\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -86,0 +87,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -488,0 +490,1 @@\n+  TrainingData::serialize(soc);\n@@ -574,0 +577,1 @@\n+    TrainingData::iterate_roots(it);\n@@ -613,0 +617,3 @@\n+\n+  TrainingData::dump_training_data();\n+\n@@ -678,0 +685,3 @@\n+  log_info(cds)(\"Make training data shareable\");\n+  _builder.make_training_data_shareable();\n+\n@@ -796,0 +806,7 @@\n+ HandleMark hm(THREAD);\n+\n+ if (CDSConfig::is_dumping_final_static_archive() && AOTPrintTrainingInfo) {\n+   tty->print_cr(\"==================== archived_training_data ** before dumping ====================\");\n+   TrainingData::print_archived_training_data_on(tty);\n+ }\n+\n@@ -804,0 +821,1 @@\n+      oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n@@ -805,1 +823,1 @@\n-                     java_lang_String::as_utf8_string(java_lang_Throwable::message(PENDING_EXCEPTION)));\n+                         message == nullptr ? \"(null)\" : java_lang_String::as_utf8_string(message));\n@@ -816,1 +834,0 @@\n-      tty->print_cr(\"AOTConfiguration recorded: %s\", AOTConfiguration);\n@@ -960,0 +977,1 @@\n+  TrainingData::init_dumptime_table(CHECK); \/\/ captures TrainingDataSetLocker\n@@ -1014,1 +1032,10 @@\n-  if (!write_static_archive(&builder, op.map_info(), op.heap_info())) {\n+  bool status = write_static_archive(&builder, op.map_info(), op.heap_info());\n+  if (status && CDSConfig::is_dumping_preimage_static_archive()) {\n+    tty->print_cr(\"%s AOTConfiguration recorded: %s\",\n+                  CDSConfig::has_temp_aot_config_file() ? \"Temporary\" : \"\", AOTConfiguration);\n+    if (CDSConfig::is_single_command_training()) {\n+      fork_and_dump_final_static_archive(CHECK);\n+    }\n+  }\n+\n+  if (!status) {\n@@ -1037,0 +1064,126 @@\n+static void print_java_launcher(outputStream* st) {\n+  st->print(\"%s%sbin%sjava\", Arguments::get_java_home(), os::file_separator(), os::file_separator());\n+}\n+\n+static void append_args(GrowableArray<Handle>* args, const char* arg, TRAPS) {\n+  Handle string = java_lang_String::create_from_str(arg, CHECK);\n+  args->append(string);\n+}\n+\n+\/\/ Pass all options in Arguments::jvm_args_array() to a child JVM process\n+\/\/ using the JAVA_TOOL_OPTIONS environment variable.\n+static int exec_jvm_with_java_tool_options(const char* java_launcher_path, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n+  GrowableArray<Handle> args;\n+\n+  const char* cp = Arguments::get_appclasspath();\n+  if (cp != nullptr && strlen(cp) > 0 && strcmp(cp, \".\") != 0) {\n+    \/\/ We cannot use \"-cp\", because \"-cp\" is only interpreted by the java launcher,\n+    \/\/ and is not interpreter by arguments.cpp when it loads args from JAVA_TOOL_OPTIONS\n+    stringStream ss;\n+    ss.print(\"-Djava.class.path=\");\n+    ss.print_raw(cp);\n+    append_args(&args, ss.freeze(), CHECK_0);\n+    \/\/ CDS$ProcessLauncher::execWithJavaToolOptions() must unset CLASSPATH, which has\n+    \/\/ a higher priority than -Djava.class.path=\n+  }\n+\n+  \/\/ Pass all arguments. These include those from JAVA_TOOL_OPTIONS and _JAVA_OPTIONS.\n+  for (int i = 0; i < Arguments::num_jvm_args(); i++) {\n+    const char* arg = Arguments::jvm_args_array()[i];\n+    if (strstr(arg, \"-XX:AOTCacheOutput=\") == arg || \/\/ arg starts with ...\n+        strstr(arg, \"-XX:AOTConfiguration=\") == arg ||\n+        strstr(arg, \"-XX:AOTMode=\") == arg) {\n+      \/\/ Filter these out. They wiill be set below.\n+    } else {\n+      append_args(&args, arg, CHECK_0);\n+    }\n+  }\n+\n+  \/\/ Note: because we are running in AOTMode=record, JDK_AOT_VM_OPTIONS have not been\n+  \/\/ parsed, so they are not in Arguments::jvm_args_array. If JDK_AOT_VM_OPTIONS is in\n+  \/\/ the environment, it will be inherited and parsed by the child JVM process\n+  \/\/ in Arguments::parse_java_tool_options_environment_variable().\n+  precond(strcmp(AOTMode, \"record\") == 0);\n+\n+  \/\/ We don't pass Arguments::jvm_flags_array(), as those will be added by\n+  \/\/ the child process when it loads .hotspotrc\n+\n+  {\n+    \/\/ If AOTCacheOutput contains %p, it should have been already substituted with the\n+    \/\/ pid of the training process.\n+    stringStream ss;\n+    ss.print(\"-XX:AOTCacheOutput=\");\n+    ss.print_raw(AOTCacheOutput);\n+    append_args(&args, ss.freeze(), CHECK_0);\n+  }\n+  {\n+    \/\/ If AOTCacheConfiguration contains %p, it should have been already substituted with the\n+    \/\/ pid of the training process.\n+    \/\/ If AOTCacheConfiguration was not explicitly specified, it should have been assigned a\n+    \/\/ temporary file name.\n+    stringStream ss;\n+    ss.print(\"-XX:AOTConfiguration=\");\n+    ss.print_raw(AOTConfiguration);\n+    append_args(&args, ss.freeze(), CHECK_0);\n+  }\n+\n+  append_args(&args, \"-XX:AOTMode=create\", CHECK_0);\n+\n+  Symbol* klass_name = SymbolTable::new_symbol(\"jdk\/internal\/misc\/CDS$ProcessLauncher\");\n+  Klass* k = SystemDictionary::resolve_or_fail(klass_name, true, CHECK_0);\n+  Symbol* methodName = SymbolTable::new_symbol(\"execWithJavaToolOptions\");\n+  Symbol* methodSignature = SymbolTable::new_symbol(\"(Ljava\/lang\/String;[Ljava\/lang\/String;)I\");\n+\n+  Handle launcher = java_lang_String::create_from_str(java_launcher_path, CHECK_0);\n+  objArrayOop array = oopFactory::new_objArray(vmClasses::String_klass(), args.length(), CHECK_0);\n+  for (int i = 0; i < args.length(); i++) {\n+    array->obj_at_put(i, args.at(i)());\n+  }\n+  objArrayHandle launcher_args(THREAD, array);\n+\n+  \/\/ The following call will pass all options inside the JAVA_TOOL_OPTIONS env variable to\n+  \/\/ the child process. It will also clear the _JAVA_OPTIONS and CLASSPATH env variables for\n+  \/\/ the child process.\n+  \/\/\n+  \/\/ Note: the env variables are set only for the child process. They are not changed\n+  \/\/ for the current process. See java.lang.ProcessBuilder::environment().\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments javacall_args(2);\n+  javacall_args.push_oop(launcher);\n+  javacall_args.push_oop(launcher_args);\n+  JavaCalls::call_static(&result,\n+                          InstanceKlass::cast(k),\n+                          methodName,\n+                          methodSignature,\n+                          &javacall_args,\n+                          CHECK_0);\n+  return result.get_jint();\n+}\n+\n+void MetaspaceShared::fork_and_dump_final_static_archive(TRAPS) {\n+  assert(CDSConfig::is_dumping_preimage_static_archive(), \"sanity\");\n+\n+  ResourceMark rm;\n+  stringStream ss;\n+  print_java_launcher(&ss);\n+  const char* cmd = ss.freeze();\n+  tty->print_cr(\"Launching child process %s to assemble AOT cache %s using configuration %s\", cmd, AOTCacheOutput, AOTConfiguration);\n+  int status = exec_jvm_with_java_tool_options(cmd, CHECK);\n+  if (status != 0) {\n+    log_error(aot)(\"Child process failed; status = %d\", status);\n+    \/\/ We leave the temp config file for debugging\n+  } else if (CDSConfig::has_temp_aot_config_file()) {\n+    const char* tmp_config = AOTConfiguration;\n+    \/\/ On Windows, need WRITE permission to remove the file.\n+    WINDOWS_ONLY(chmod(tmp_config, _S_IREAD | _S_IWRITE));\n+    status = remove(tmp_config);\n+    if (status != 0) {\n+      log_error(aot)(\"Failed to remove temporary AOT configuration file %s\", tmp_config);\n+    } else {\n+      tty->print_cr(\"Removed temporary AOT configuration file %s\", tmp_config);\n+    }\n+  }\n+}\n+\n@@ -1869,0 +2022,2 @@\n+    TrainingData::print_archived_training_data_on(tty);\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":158,"deletions":3,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+  static void fork_and_dump_final_static_archive(TRAPS);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1168,0 +1168,7 @@\n+  CompileTrainingData* ctd = task()->training_data();\n+  if (ctd != nullptr) {\n+    GUARDED_VM_ENTRY({\n+      methodHandle mh(Thread::current(), method->get_Method());\n+      ctd->notice_inlined_method(task(), mh);\n+    });\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  friend class CompileTrainingData;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -50,0 +51,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -1209,0 +1211,22 @@\n+  if (_inline_instructions_size == -1) {\n+    if (TrainingData::have_data()) {\n+      GUARDED_VM_ENTRY(\n+        CompLevel level = static_cast<CompLevel>(CURRENT_ENV->comp_level());\n+        methodHandle top_level_mh(Thread::current(), CURRENT_ENV->task()->method());\n+        MethodTrainingData* mtd = MethodTrainingData::find(top_level_mh);\n+        if (mtd != nullptr) {\n+          CompileTrainingData* ctd = mtd->last_toplevel_compile(level);\n+          if (ctd != nullptr) {\n+            methodHandle mh(Thread::current(), get_Method());\n+            MethodTrainingData* this_mtd = MethodTrainingData::find(mh);\n+            if (this_mtd != nullptr) {\n+              auto r = ctd->ci_records().ciMethod__inline_instructions_size.find(this_mtd);\n+              if (r.is_valid()) {\n+                _inline_instructions_size = r.result();\n+              }\n+            }\n+          }\n+        }\n+      );\n+    }\n+  }\n@@ -1218,0 +1242,8 @@\n+      if (TrainingData::need_data()) {\n+        CompileTrainingData* ctd = CURRENT_ENV->task()->training_data();\n+        if (ctd != nullptr) {\n+          methodHandle mh(Thread::current(), get_Method());\n+          MethodTrainingData* this_mtd = MethodTrainingData::make(mh);\n+          ctd->ci_records().ciMethod__inline_instructions_size.append_if_missing(_inline_instructions_size, this_mtd);\n+        }\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -57,0 +58,5 @@\n+\n+static bool is_klass_loaded(Klass* k) {\n+  return TrainingData::is_klass_loaded(k);\n+}\n+\n@@ -71,1 +77,2 @@\n-    if (!m->method_holder()->is_loader_alive()) {\n+    Klass* holder = m->method_holder();\n+    if (holder == nullptr || !holder->is_loader_present_and_alive() || !is_klass_loaded(holder)) {\n@@ -306,1 +313,1 @@\n-    if (k != nullptr) {\n+    if (k != nullptr && k->class_loader_data() != nullptr && is_klass_loaded(k)) {\n@@ -324,1 +331,1 @@\n-    if (klass != nullptr && !klass->is_loader_alive()) {\n+    if (klass == nullptr || !klass->is_loader_present_and_alive() || !is_klass_loaded(klass)) {\n@@ -336,1 +343,1 @@\n-  if (klass != nullptr && !klass->is_loader_alive()) {\n+  if (klass == nullptr || !klass->is_loader_present_and_alive() || !is_klass_loaded(klass)) {\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -114,1 +116,1 @@\n-  Arena* arena = new (mtCompiler) Arena(mtCompiler, Arena::Tag::tag_cienv);\n+  Arena* arena = new (mtCompiler) Arena(mtCompiler);\n@@ -238,1 +240,2 @@\n-  assert(Universe::heap()->is_in(key), \"must be\");\n+  Handle keyHandle(Thread::current(), key);\n+  assert(Universe::heap()->is_in(keyHandle()), \"must be\");\n@@ -240,1 +243,1 @@\n-  NonPermObject* &bucket = find_non_perm(key);\n+  NonPermObject* &bucket = find_non_perm(keyHandle);\n@@ -247,1 +250,0 @@\n-  Handle keyHandle(Thread::current(), key);\n@@ -254,1 +256,2 @@\n-  insert_non_perm(bucket, keyHandle(), new_object);\n+  insert_non_perm(bucket, keyHandle, new_object);\n+  notice_new_object(new_object);\n@@ -258,0 +261,13 @@\n+void ciObjectFactory::notice_new_object(ciBaseObject* new_object) {\n+  if (TrainingData::need_data()) {\n+    ciEnv* env = ciEnv::current();\n+    if (env->task() != nullptr) {\n+      \/\/ Note: task will be null during init_compiler_runtime.\n+      CompileTrainingData* td = env->task()->training_data();\n+      if (td != nullptr) {\n+        td->notice_jit_observation(env, new_object);\n+      }\n+    }\n+  }\n+}\n+\n@@ -337,0 +353,1 @@\n+    notice_new_object(new_object);\n@@ -655,3 +672,3 @@\n-ciObjectFactory::NonPermObject* &ciObjectFactory::find_non_perm(oop key) {\n-  assert(Universe::heap()->is_in(key), \"must be\");\n-  ciMetadata* klass = get_metadata(key->klass());\n+ciObjectFactory::NonPermObject* &ciObjectFactory::find_non_perm(Handle keyHandle) {\n+  assert(Universe::heap()->is_in(keyHandle()), \"must be\");\n+  ciMetadata* klass = get_metadata(keyHandle->klass()); \/\/ This may safepoint!\n@@ -660,1 +677,1 @@\n-    if (is_equal(p, key))  break;\n+    if (is_equal(p, keyHandle()))  break;\n@@ -683,2 +700,2 @@\n-void ciObjectFactory::insert_non_perm(ciObjectFactory::NonPermObject* &where, oop key, ciObject* obj) {\n-  assert(Universe::heap()->is_in_or_null(key), \"must be\");\n+void ciObjectFactory::insert_non_perm(ciObjectFactory::NonPermObject* &where, Handle keyHandle, ciObject* obj) {\n+  assert(Universe::heap()->is_in_or_null(keyHandle()), \"must be\");\n@@ -686,3 +703,3 @@\n-  NonPermObject* p = new (arena()) NonPermObject(where, key, obj);\n-  assert(where == p && is_equal(p, key) && p->object() == obj, \"entry must match\");\n-  assert(find_non_perm(key) == p, \"must find the same spot\");\n+  NonPermObject* p = new (arena()) NonPermObject(where, keyHandle(), obj);\n+  assert(where == p && is_equal(p, keyHandle()) && p->object() == obj, \"entry must match\");\n+  assert(find_non_perm(keyHandle) == p, \"must find the same spot\");\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":31,"deletions":14,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  friend class VMStructs;\n@@ -80,2 +81,2 @@\n-  NonPermObject* &find_non_perm(oop key);\n-  void insert_non_perm(NonPermObject* &where, oop key, ciObject* obj);\n+  NonPermObject* &find_non_perm(Handle keyHandle);\n+  void insert_non_perm(NonPermObject* &where, Handle keyHandle, ciObject* obj);\n@@ -109,0 +110,3 @@\n+  \/\/ Called on every new object made.\n+  void notice_new_object(ciBaseObject* new_object);\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1893,1 +1893,1 @@\n-  return java_thread->obj_field(_park_blocker_offset);\n+  return java_thread->obj_field_access<MO_RELAXED>(_park_blocker_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,6 @@\n-bool VerificationType::resolve_and_check_assignability(InstanceKlass* klass, Symbol* name,\n-         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object, TRAPS) {\n+\/\/ Potentially resolve the target class and from class, and check whether the from class is assignable\n+\/\/ to the target class. The current_klass is the class being verified - it could also be the target in some\n+\/\/ cases, and otherwise is needed to obtain the correct classloader for resolving the other classes.\n+bool VerificationType::resolve_and_check_assignability(InstanceKlass* current_klass, Symbol* target_name, Symbol* from_name,\n+                                                       bool from_field_is_protected, bool from_is_array,\n+                                                       bool from_is_object, bool* target_is_interface, TRAPS) {\n@@ -54,3 +58,3 @@\n-  Klass* this_class;\n-  if (klass->is_hidden() && klass->name() == name) {\n-    this_class = klass;\n+  Klass* target_klass;\n+  if (current_klass->is_hidden() && current_klass->name() == target_name) {\n+    target_klass = current_klass;\n@@ -58,2 +62,2 @@\n-    this_class = SystemDictionary::resolve_or_fail(\n-      name, Handle(THREAD, klass->class_loader()), true, CHECK_false);\n+    target_klass = SystemDictionary::resolve_or_fail(\n+      target_name, Handle(THREAD, current_klass->class_loader()), true, CHECK_false);\n@@ -61,1 +65,1 @@\n-      Verifier::trace_class_resolution(this_class, klass);\n+      Verifier::trace_class_resolution(target_klass, current_klass);\n@@ -72,1 +76,6 @@\n-  if (this_class->is_interface() && (!from_field_is_protected ||\n+  bool is_intf = target_klass->is_interface();\n+  if (target_is_interface != nullptr) {\n+    *target_is_interface = is_intf;\n+  }\n+\n+  if (is_intf && (!from_field_is_protected ||\n@@ -79,2 +88,2 @@\n-      this_class == vmClasses::Cloneable_klass() ||\n-      this_class == vmClasses::Serializable_klass();\n+      target_klass == vmClasses::Cloneable_klass() ||\n+      target_klass == vmClasses::Serializable_klass();\n@@ -82,3 +91,3 @@\n-    Klass* from_class;\n-    if (klass->is_hidden() && klass->name() == from_name) {\n-      from_class = klass;\n+    Klass* from_klass;\n+    if (current_klass->is_hidden() && current_klass->name() == from_name) {\n+      from_klass = current_klass;\n@@ -86,2 +95,2 @@\n-      from_class = SystemDictionary::resolve_or_fail(\n-        from_name, Handle(THREAD, klass->class_loader()), true, CHECK_false);\n+      from_klass = SystemDictionary::resolve_or_fail(\n+        from_name, Handle(THREAD, current_klass->class_loader()), true, CHECK_false);\n@@ -89,1 +98,1 @@\n-        Verifier::trace_class_resolution(from_class, klass);\n+        Verifier::trace_class_resolution(from_klass, current_klass);\n@@ -92,1 +101,1 @@\n-    return from_class->is_subclass_of(this_class);\n+    return from_klass->is_subclass_of(target_klass);\n@@ -100,2 +109,2 @@\n-    bool from_field_is_protected, TRAPS) const {\n-  InstanceKlass* klass = context->current_class();\n+    bool from_field_is_protected, bool* this_is_interface, TRAPS) const {\n+\n@@ -119,1 +128,1 @@\n-      SystemDictionaryShared::add_verification_constraint(klass,\n+      SystemDictionaryShared::add_verification_constraint(context->current_class(),\n@@ -129,2 +138,3 @@\n-    return resolve_and_check_assignability(klass, name(), from.name(),\n-          from_field_is_protected, from.is_array(), from.is_object(), THREAD);\n+    return resolve_and_check_assignability(context->current_class(), name(), from.name(),\n+                                           from_field_is_protected, from.is_array(),\n+                                           from.is_object(), this_is_interface, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":33,"deletions":23,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -294,1 +294,1 @@\n-                                                THREAD);\n+                                                nullptr, THREAD);\n@@ -333,1 +333,2 @@\n- private:\n+  bool is_reference_assignable_from(const VerificationType& from, ClassVerifier* context,\n+                                    bool from_field_is_protected, bool* this_is_interface, TRAPS) const;\n@@ -335,3 +336,7 @@\n-  bool is_reference_assignable_from(\n-    const VerificationType&, ClassVerifier*, bool from_field_is_protected,\n-    TRAPS) const;\n+  static bool resolve_and_check_assignability(InstanceKlass* current_klass, Symbol* target_name,\n+                                              Symbol* from_name, bool from_field_is_protected,\n+                                              bool from_is_array, bool from_is_object,\n+                                              TRAPS) {\n+    return resolve_and_check_assignability(current_klass, target_name, from_name, from_field_is_protected,\n+                                           from_is_array, from_is_object, nullptr, THREAD);\n+  }\n@@ -339,2 +344,2 @@\n- public:\n-  static bool resolve_and_check_assignability(InstanceKlass* klass, Symbol* name,\n+ private:\n+  static bool resolve_and_check_assignability(InstanceKlass* current_klass, Symbol* target_name,\n@@ -343,0 +348,1 @@\n+                                              bool* target_is_interface,\n@@ -344,0 +350,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2955,14 +2955,23 @@\n-  } else if (opcode == Bytecodes::_invokespecial\n-             && !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)\n-             && !ref_class_type.equals(VerificationType::reference_type(\n-                  current_class()->super()->name()))) { \/\/ super() can never be an inline_type.\n-    bool subtype = false;\n-    bool have_imr_indirect = cp->tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;\n-    subtype = ref_class_type.is_assignable_from(\n-               current_type(), this, false, CHECK_VERIFY(this));\n-    if (!subtype) {\n-      verify_error(ErrorContext::bad_code(bci),\n-          \"Bad invokespecial instruction: \"\n-          \"current class isn't assignable to reference class.\");\n-       return;\n-    } else if (have_imr_indirect) {\n+  }\n+  \/\/ invokespecial, when not <init>, must be to a method in the current class, a direct superinterface,\n+  \/\/ or any superclass (including Object).\n+  else if (opcode == Bytecodes::_invokespecial\n+           && !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)\n+           && !ref_class_type.equals(VerificationType::reference_type(current_class()->super()->name()))) { \/\/ super() can never be an inline_type.\n+\n+    \/\/ We know it is not current class, direct superinterface or immediate superclass. That means it\n+    \/\/ could be:\n+    \/\/ - a totally unrelated class or interface\n+    \/\/ - an indirect superinterface\n+    \/\/ - an indirect superclass (including Object)\n+    \/\/ We use the assignability test to see if it is a superclass, or else an interface, and keep track\n+    \/\/ of the latter. Note that subtype can be true if we are dealing with an interface that is not actually\n+    \/\/ implemented as assignability treats all interfaces as Object.\n+\n+    bool is_interface = false; \/\/ This can only be set true if the assignability check will return true\n+                               \/\/ and we loaded the class. For any other \"true\" returns (e.g. same class\n+                               \/\/ or Object) we either can't get here (same class already excluded above)\n+                               \/\/ or we know it is not an interface (i.e. Object).\n+    bool subtype = ref_class_type.is_reference_assignable_from(current_type(), this, false,\n+                                                               &is_interface, CHECK_VERIFY(this));\n+    if (!subtype) {  \/\/ Totally unrelated class\n@@ -2970,2 +2979,2 @@\n-          \"Bad invokespecial instruction: \"\n-          \"interface method reference is in an indirect superinterface.\");\n+                   \"Bad invokespecial instruction: \"\n+                   \"current class isn't assignable to reference class.\");\n@@ -2973,0 +2982,9 @@\n+    } else {\n+      \/\/ Indirect superclass (including Object), indirect interface, or unrelated interface.\n+      \/\/ Any interface use is an error.\n+      if (is_interface) {\n+        verify_error(ErrorContext::bad_code(bci),\n+                     \"Bad invokespecial instruction: \"\n+                     \"interface method to invoke is not in a direct superinterface.\");\n+        return;\n+      }\n@@ -2974,1 +2992,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+  case vmIntrinsics::_dcbrt:\n@@ -147,0 +148,1 @@\n+  case vmIntrinsics::_dcbrt:\n@@ -294,0 +296,1 @@\n+  case vmIntrinsics::_dcbrt:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  do_name(round_name, \"round\")  do_name(tanh_name,\"tanh\")                                                               \\\n+  do_name(round_name, \"round\")  do_name(tanh_name,\"tanh\")       do_name(cbrt_name,\"cbrt\")                                                               \\\n@@ -164,1 +164,2 @@\n-  do_intrinsic(_dtanh,                    java_lang_Math,         tanh_name,   double_double_signature,          F_S)   \\\n+  do_intrinsic(_dtanh,                    java_lang_Math,         tanh_name,  double_double_signature,           F_S)   \\\n+  do_intrinsic(_dcbrt,                    java_lang_Math,         cbrt_name,  double_double_signature,           F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -784,0 +784,6 @@\n+  template(jdk_internal_vm_ThreadSnapshot,         \"jdk\/internal\/vm\/ThreadSnapshot\")                              \\\n+  template(jdk_internal_vm_ThreadLock,             \"jdk\/internal\/vm\/ThreadSnapshot$ThreadLock\")                   \\\n+  template(jdk_internal_vm_ThreadLock_signature,   \"Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;\")                 \\\n+  template(jdk_internal_vm_ThreadLock_array,       \"[Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;\")                \\\n+  template(java_lang_StackTraceElement_of_name,    \"of\")                                                          \\\n+  template(java_lang_StackTraceElement_of_signature, \"([Ljava\/lang\/StackTraceElement;)[Ljava\/lang\/StackTraceElement;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -128,0 +128,2 @@\n+\/\/ This method is called during universe_init()\n+\/\/ and does final AOT state and flags settings.\n@@ -200,0 +202,5 @@\n+static AOTCodeCache*  opened_cache = nullptr; \/\/ Use this until we verify the cache\n+AOTCodeCache* AOTCodeCache::_cache = nullptr;\n+\n+\/\/ This method is called after universe_init()\n+\/\/ when all GC settings are finalized.\n@@ -201,1 +208,1 @@\n-  if (!is_on()) {\n+  if (opened_cache == nullptr) {\n@@ -204,2 +211,3 @@\n-  if (!verify_vm_config()) {\n-    close();\n+  if (!opened_cache->verify_config()) {\n+    delete opened_cache;\n+    opened_cache = nullptr;\n@@ -207,0 +215,1 @@\n+    return;\n@@ -211,3 +220,4 @@\n-  init_extrs_table();\n-  init_early_stubs_table();\n-}\n+  AOTCodeAddressTable* table = opened_cache->_table;\n+  assert(table != nullptr, \"should be initialized already\");\n+  table->init_extrs();\n+  table->init_early_stubs();\n@@ -215,1 +225,3 @@\n-AOTCodeCache* AOTCodeCache::_cache = nullptr;\n+  \/\/ Now cache and address table are ready for AOT code generation\n+  _cache = opened_cache;\n+}\n@@ -218,4 +230,4 @@\n-  AOTCodeCache* cache = new AOTCodeCache(is_dumping, is_using);\n-  if (cache->failed()) {\n-    delete cache;\n-    _cache = nullptr;\n+  opened_cache = new AOTCodeCache(is_dumping, is_using);\n+  if (opened_cache->failed()) {\n+    delete opened_cache;\n+    opened_cache = nullptr;\n@@ -224,1 +236,0 @@\n-  _cache = cache;\n@@ -232,0 +243,1 @@\n+    opened_cache = nullptr;\n@@ -279,1 +291,1 @@\n-    if (!_load_header->verify_config(_load_size)) {\n+    if (!_load_header->verify(_load_size)) {\n@@ -303,14 +315,0 @@\n-void AOTCodeCache::init_extrs_table() {\n-  AOTCodeAddressTable* table = addr_table();\n-  if (table != nullptr) {\n-    table->init_extrs();\n-  }\n-}\n-\n-void AOTCodeCache::init_early_stubs_table() {\n-  AOTCodeAddressTable* table = addr_table();\n-  if (table != nullptr) {\n-    table->init_early_stubs();\n-  }\n-}\n-\n@@ -384,1 +382,0 @@\n-  _objectAlignment       = ObjectAlignmentInBytes;\n@@ -389,0 +386,1 @@\n+  \/\/ First checks affect all cached AOT code\n@@ -407,4 +405,0 @@\n-  if (((_flags & compressedOops) != 0) != UseCompressedOops) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseCompressedOops = %s\", UseCompressedOops ? \"false\" : \"true\");\n-    return false;\n-  }\n@@ -415,7 +409,2 @@\n-\n-  if (((_flags & systemClassAssertions) != 0) != JavaAssertions::systemClassDefault()) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with JavaAssertions::systemClassDefault() = %s\", JavaAssertions::systemClassDefault() ? \"disabled\" : \"enabled\");\n-    return false;\n-  }\n-  if (((_flags & userClassAssertions) != 0) != JavaAssertions::userClassDefault()) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with JavaAssertions::userClassDefault() = %s\", JavaAssertions::userClassDefault() ? \"disabled\" : \"enabled\");\n+  if (_compressedKlassShift != (uint)CompressedKlassPointers::shift()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with CompressedKlassPointers::shift() = %d vs current %d\", _compressedKlassShift, CompressedKlassPointers::shift());\n@@ -425,7 +414,5 @@\n-  if (((_flags & enableContendedPadding) != 0) != EnableContended) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with EnableContended = %s\", EnableContended ? \"false\" : \"true\");\n-    return false;\n-  }\n-  if (((_flags & restrictContendedPadding) != 0) != RestrictContended) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with RestrictContended = %s\", RestrictContended ? \"false\" : \"true\");\n-    return false;\n+  \/\/ The following checks do not affect AOT adapters caching\n+\n+  if (((_flags & compressedOops) != 0) != UseCompressedOops) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseCompressedOops = %s\", UseCompressedOops ? \"false\" : \"true\");\n+    AOTStubCaching = false;\n@@ -435,13 +422,1 @@\n-    return false;\n-  }\n-  if (_compressedKlassShift != (uint)CompressedKlassPointers::shift()) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with CompressedKlassPointers::shift() = %d vs current %d\", _compressedKlassShift, CompressedKlassPointers::shift());\n-    return false;\n-  }\n-  if (_contendedPaddingWidth != (uint)ContendedPaddingWidth) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with ContendedPaddingWidth = %d vs current %d\", _contendedPaddingWidth, ContendedPaddingWidth);\n-    return false;\n-  }\n-  if (_objectAlignment != (uint)ObjectAlignmentInBytes) {\n-    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with ObjectAlignmentInBytes = %d vs current %d\", _objectAlignment, ObjectAlignmentInBytes);\n-    return false;\n+    AOTStubCaching = false;\n@@ -459,1 +434,1 @@\n-bool AOTCodeCache::Header::verify_config(uint load_size) const {\n+bool AOTCodeCache::Header::verify(uint load_size) const {\n@@ -488,12 +463,3 @@\n-  assert(size > 0, \"sanity\");\n-  bool by_words = true;\n-  if ((size > 2 * HeapWordSize) && (((intptr_t)from | (intptr_t)to) & (HeapWordSize - 1)) == 0) {\n-    \/\/ Use wordwise copies if possible:\n-    Copy::disjoint_words((HeapWord*)from,\n-                         (HeapWord*)to,\n-                         ((size_t)size + HeapWordSize-1) \/ HeapWordSize);\n-  } else {\n-    by_words = false;\n-    Copy::conjoint_jbytes(from, to, (size_t)size);\n-  }\n-  log_trace(aot, codecache)(\"Copied %d bytes as %s from \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, size, (by_words ? \"HeapWord\" : \"bytes\"), p2i(from), p2i(to));\n+  assert((int)size > 0, \"sanity\");\n+  memcpy(to, from, size);\n+  log_trace(aot, codecache)(\"Copied %d bytes from \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, size, p2i(from), p2i(to));\n@@ -860,0 +826,4 @@\n+    if (!cache->failed()) {\n+      \/\/ We may miss an address in AOT table - skip this code blob.\n+      cache->set_write_position(entry_position);\n+    }\n@@ -939,7 +909,0 @@\n-#ifndef PRODUCT\n-  AsmRemarks asm_remarks;\n-  read_asm_remarks(asm_remarks);\n-  DbgStrings dbg_strings;\n-  read_dbg_strings(dbg_strings);\n-#endif \/\/ PRODUCT\n-\n@@ -950,4 +913,0 @@\n-#ifndef PRODUCT\n-                                         , asm_remarks\n-                                         , dbg_strings\n-#endif\n@@ -959,0 +918,7 @@\n+#ifndef PRODUCT\n+  code_blob->asm_remarks().init();\n+  read_asm_remarks(code_blob->asm_remarks());\n+  code_blob->dbg_strings().init();\n+  read_dbg_strings(code_blob->dbg_strings());\n+#endif \/\/ PRODUCT\n+\n@@ -988,0 +954,4 @@\n+\/\/ Can't use -1. It is valid value for jump to iteself destination\n+\/\/ used by static call stub: see NativeJump::jump_destination().\n+#define BAD_ADDRESS_ID -2\n+\n@@ -1004,1 +974,5 @@\n-        reloc_data.at_put(idx, _table->id_for_address(dest, iter, &code_blob));\n+        int id = _table->id_for_address(dest, iter, &code_blob);\n+        if (id == BAD_ADDRESS_ID) {\n+          return false;\n+        }\n+        reloc_data.at_put(idx, id);\n@@ -1008,2 +982,2 @@\n-        fatal(\"runtime_call_w_cp_type unimplemented\");\n-        break;\n+        log_debug(aot, codecache, reloc)(\"runtime_call_w_cp_type relocation is not implemented\");\n+        return false;\n@@ -1013,1 +987,5 @@\n-        reloc_data.at_put(idx, _table->id_for_address(target, iter, &code_blob));\n+        int id = _table->id_for_address(target, iter, &code_blob);\n+        if (id == BAD_ADDRESS_ID) {\n+          return false;\n+        }\n+        reloc_data.at_put(idx, id);\n@@ -1023,1 +1001,2 @@\n-        fatal(\"relocation %d unimplemented\", (int)iter.type());\n+        log_debug(aot, codecache, reloc)(\"relocation %d unimplemented\", (int)iter.type());\n+        return false;\n@@ -1072,1 +1051,2 @@\n-        fatal(\"runtime_call_w_cp_type unimplemented\");\n+        \/\/ this relocation should not be in cache (see write_relocations)\n+        assert(false, \"runtime_call_w_cp_type relocation is not implemented\");\n@@ -1098,1 +1078,1 @@\n-        fatal(\"relocation %d unimplemented\", (int)iter.type());\n+        assert(false,\"relocation %d unimplemented\", (int)iter.type());\n@@ -1415,0 +1395,2 @@\n+\n+  \/\/ Divide _shared_blobs_addr array to chunks because they could be initialized in parrallel\n@@ -1417,1 +1399,3 @@\n-  _shared_blobs_length = _C1_blobs_length = 0;\n+\n+  _shared_blobs_length = 0;\n+  _C1_blobs_length = 0;\n@@ -1574,1 +1558,1 @@\n-      fatal(\"Number of C strings >= MAX_STR_COUNT\");\n+      assert(false, \"Number of C strings >= MAX_STR_COUNT\");\n@@ -1613,1 +1597,1 @@\n-  return -1;\n+  return BAD_ADDRESS_ID;\n@@ -1617,3 +1601,1 @@\n-  if (!_extrs_complete) {\n-    fatal(\"AOT Code Cache VM runtime addresses table is not complete\");\n-  }\n+  assert(_extrs_complete, \"AOT Code Cache VM runtime addresses table is not complete\");\n@@ -1630,0 +1612,1 @@\n+    return nullptr;\n@@ -1652,3 +1635,1 @@\n-  if (!_extrs_complete) {\n-    fatal(\"AOT Code Cache VM runtime addresses table is not complete\");\n-  }\n+  assert(_extrs_complete, \"AOT Code Cache VM runtime addresses table is not complete\");\n@@ -1673,1 +1654,1 @@\n-      fatal(\"Address \" INTPTR_FORMAT \" for Stub:%s is missing in AOT Code Cache addresses table\", p2i(addr), sub_name);\n+      assert(false, \"Address \" INTPTR_FORMAT \" for Stub:%s is missing in AOT Code Cache addresses table\", p2i(addr), sub_name);\n@@ -1684,1 +1665,1 @@\n-        fatal(\"Address \" INTPTR_FORMAT \" for Blob:%s is missing in AOT Code Cache addresses table\", p2i(addr), cb->name());\n+        assert(false, \"Address \" INTPTR_FORMAT \" for Blob:%s is missing in AOT Code Cache addresses table\", p2i(addr), cb->name());\n@@ -1705,0 +1686,1 @@\n+#ifdef ASSERT\n@@ -1708,1 +1690,2 @@\n-          fatal(\"Address \" INTPTR_FORMAT \" for runtime target '%s+%d' is missing in AOT Code Cache addresses table\", p2i(addr), func_name, offset);\n+          assert(false, \"Address \" INTPTR_FORMAT \" for runtime target '%s+%d' is missing in AOT Code Cache addresses table\", p2i(addr), func_name, offset);\n+#endif\n@@ -1710,0 +1693,1 @@\n+#ifdef ASSERT\n@@ -1714,1 +1698,2 @@\n-          fatal(\"Address \" INTPTR_FORMAT \" for <unknown>\/('%s') is missing in AOT Code Cache addresses table\", p2i(addr), (const char*)addr);\n+          assert(false, \"Address \" INTPTR_FORMAT \" for <unknown>\/('%s') is missing in AOT Code Cache addresses table\", p2i(addr), (const char*)addr);\n+#endif\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":88,"deletions":103,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -286,4 +286,0 @@\n-#ifndef PRODUCT\n-                           , AsmRemarks& archived_asm_remarks\n-                           , DbgStrings& archived_dbg_strings\n-#endif \/\/ PRODUCT\n@@ -306,7 +302,1 @@\n-#ifndef PRODUCT\n-      blob->use_remarks(archived_asm_remarks);\n-      archived_asm_remarks.clear();\n-      blob->use_strings(archived_dbg_strings);\n-      archived_dbg_strings.clear();\n-#endif \/\/ PRODUCT\n-\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -324,6 +324,1 @@\n-                          ImmutableOopMapSet* archived_oop_maps\n-#ifndef PRODUCT\n-                          , AsmRemarks& archived_asm_remarks\n-                          , DbgStrings& archived_dbg_strings\n-#endif \/\/ PRODUCT\n-                         );\n+                          ImmutableOopMapSet* archived_oop_maps);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -802,0 +802,2 @@\n+    } else if (md->is_methodCounters()) {\n+      klass = ((MethodCounters*)md)->method()->method_holder();\n@@ -2165,4 +2167,13 @@\n-  log_debug(codecache)(\"*flushing %s nmethod %3d\/\" INTPTR_FORMAT \". Live blobs:\" UINT32_FORMAT\n-                       \"\/Free CodeCache:%zuKb\",\n-                       is_osr_method() ? \"osr\" : \"\",_compile_id, p2i(this), CodeCache::blob_count(),\n-                       CodeCache::unallocated_capacity(CodeCache::get_code_blob_type(this))\/1024);\n+\n+  LogTarget(Debug, codecache) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    const char* method_name = method()->name()->as_C_string();\n+    const size_t codecache_capacity = CodeCache::capacity()\/1024;\n+    const size_t codecache_free_space = CodeCache::unallocated_capacity(CodeCache::get_code_blob_type(this))\/1024;\n+    ls.print(\"Flushing nmethod %6d\/\" INTPTR_FORMAT \", level=%d, osr=%d, cold=%d, epoch=\" UINT64_FORMAT \", cold_count=\" UINT64_FORMAT \". \"\n+              \"Cache capacity: %zuKb, free space: %zuKb. method %s (%s)\",\n+              _compile_id, p2i(this), _comp_level, is_osr_method(), is_cold(), _gc_epoch, CodeCache::cold_gc_count(),\n+              codecache_capacity, codecache_free_space, method_name, compiler_name());\n+  }\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -233,1 +234,1 @@\n-      MutexLocker notifier(thread, task->lock());\n+      MutexLocker notifier(thread, CompileTaskWait_lock);\n@@ -247,1 +248,1 @@\n-        task->lock()->notify_all();\n+        CompileTaskWait_lock->notify_all();\n@@ -350,0 +351,7 @@\n+  if (TrainingData::need_data() && !CDSConfig::is_dumping_final_static_archive()) {\n+    CompileTrainingData* ctd = CompileTrainingData::make(task);\n+    if (ctd != nullptr) {\n+      task->set_training_data(ctd);\n+    }\n+  }\n+\n@@ -370,1 +378,1 @@\n-      MutexLocker ct_lock(current->lock());\n+      MutexLocker ct_lock(CompileTaskWait_lock);\n@@ -375,1 +383,1 @@\n-        current->lock()->notify();\n+        CompileTaskWait_lock->notify_all();\n@@ -444,1 +452,1 @@\n-    task = CompilationPolicy::select_task(this);\n+    task = CompilationPolicy::select_task(this, thread);\n@@ -784,0 +792,4 @@\n+void TrainingReplayThread::training_replay_thread_entry(JavaThread* thread, TRAPS) {\n+  CompilationPolicy::replay_training_at_init_loop(thread);\n+}\n+\n@@ -861,0 +873,3 @@\n+    case training_replay_t:\n+      new_thread = new TrainingReplayThread();\n+      break;\n@@ -1018,0 +1033,10 @@\n+void CompileBroker::init_training_replay() {\n+  \/\/ Ensure any exceptions lead to vm_exit_during_initialization.\n+  EXCEPTION_MARK;\n+  if (TrainingData::have_data()) {\n+    Handle thread_oop = JavaThread::create_system_thread_object(\"Training replay thread\", CHECK);\n+    jobject thread_handle = JNIHandles::make_local(THREAD, thread_oop());\n+    make_thread(training_replay_t, thread_handle, nullptr, nullptr, THREAD);\n+  }\n+}\n+\n@@ -1633,1 +1658,1 @@\n-  MonitorLocker ml(thread, task->lock());\n+  MonitorLocker ml(thread, CompileTaskWait_lock);\n@@ -1701,1 +1726,1 @@\n-    MonitorLocker ml(thread, task->lock());\n+    MonitorLocker ml(thread, CompileTaskWait_lock);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -262,5 +262,0 @@\n-  \/\/ Return \"true\" if the part of the heap that allocates Java\n-  \/\/ objects has reached the maximal committed limit that it can\n-  \/\/ reach, without a garbage collection.\n-  virtual bool is_maximal_no_gc() const = 0;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -307,0 +307,3 @@\n+JNIEXPORT jobject JNICALL\n+JVM_CreateThreadSnapshot(JNIEnv* env, jobject thread);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1206,1 +1206,1 @@\n-  \/\/ a direct superinterface, not an indirect superinterface\n+  \/\/ a direct superinterface, not an indirect superinterface or unrelated interface\n@@ -1215,1 +1215,1 @@\n-      ss.print(\"', is in an indirect superinterface of %s\",\n+      ss.print(\"', is not in a direct superinterface of %s\",\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+  method_entry(java_lang_math_cbrt )\n@@ -457,0 +458,1 @@\n+  case Interpreter::java_lang_math_cbrt    : \/\/ fall thru\n@@ -491,1 +493,0 @@\n-\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -508,2 +509,5 @@\n-      klass = *((Klass**) (intptr_t) (base_address + offset));\n-      if (klass == nullptr || !klass->is_loader_alive()) {\n+      Klass* k = *((Klass**) (intptr_t) (base_address + offset));\n+      if (k == nullptr || k->class_loader_data() == nullptr || !TrainingData::is_klass_loaded(k)) {\n+        return nullptr;\n+      }\n+      if (!k->is_loader_alive()) {\n@@ -513,0 +517,1 @@\n+      klass = k;\n@@ -811,0 +816,8 @@\n+C2V_VMENTRY_0(jint, getNumIndyEntries, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp)))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n+  if (cp->cache()->resolved_indy_entries() == nullptr) {\n+    return 0;\n+  }\n+  return cp->resolved_indy_entries_length();\n+C2V_END\n+\n@@ -2222,0 +2235,20 @@\n+C2V_VMENTRY_NULL(jobjectArray, getAllMethods, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n+    JVMCI_THROW_NULL(NullPointerException);\n+  }\n+  if (!klass->is_instance_klass()) {\n+    JVMCIObjectArray methods = JVMCIENV->new_ResolvedJavaMethod_array(0, JVMCI_CHECK_NULL);\n+    return JVMCIENV->get_jobjectArray(methods);\n+  }\n+\n+  InstanceKlass* iklass = InstanceKlass::cast(klass);\n+  JVMCIObjectArray methods = JVMCIENV->new_ResolvedJavaMethod_array(iklass->methods()->length(), JVMCI_CHECK_NULL);\n+  for (int i = 0; i < iklass->methods()->length(); i++) {\n+    methodHandle mh(THREAD, iklass->methods()->at(i));\n+    JVMCIObject method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n+    JVMCIENV->put_object_at(methods, i, method);\n+  }\n+  return JVMCIENV->get_jobjectArray(methods);\n+C2V_END\n+\n@@ -2834,1 +2867,1 @@\n-          oop nmethod_mirror = data->get_nmethod_mirror(nm, \/* phantom_ref *\/ true);\n+          oop nmethod_mirror = data->get_nmethod_mirror(nm);\n@@ -2866,1 +2899,1 @@\n-          if (data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) != nullptr) {\n+          if (data->get_nmethod_mirror(nm) != nullptr) {\n@@ -3299,0 +3332,1 @@\n+  {CC \"getNumIndyEntries\",                            CC \"(\" HS_CONSTANT_POOL2 \")I\",                                                        FN_PTR(getNumIndyEntries)},\n@@ -3358,0 +3392,1 @@\n+  {CC \"getAllMethods\",                                CC \"(\" HS_KLASS2 \")[\" RESOLVED_METHOD,                                                FN_PTR(getAllMethods)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":39,"deletions":4,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n@@ -144,0 +145,1 @@\n+  static_field(CompilerToVM::Data,             dcbrt,                                  address)                                      \\\n@@ -694,0 +696,1 @@\n+  declare_constant(ConstMethodFlags::_misc_is_overpass)                   \\\n@@ -974,0 +977,7 @@\n+   declare_constant_with_value(\"ShenandoahHeap::HAS_FORWARDED\", ShenandoahHeap::HAS_FORWARDED)                                           \\\n+   declare_constant_with_value(\"ShenandoahHeap::MARKING\", ShenandoahHeap::MARKING)                                                       \\\n+   declare_constant_with_value(\"ShenandoahHeap::EVACUATION\", ShenandoahHeap::EVACUATION)                                                 \\\n+   declare_constant_with_value(\"ShenandoahHeap::UPDATE_REFS\", ShenandoahHeap::UPDATE_REFS)                                               \\\n+   declare_constant_with_value(\"ShenandoahHeap::WEAK_ROOTS\", ShenandoahHeap::WEAK_ROOTS)                                                 \\\n+   declare_constant_with_value(\"ShenandoahHeap::YOUNG_MARKING\", ShenandoahHeap::YOUNG_MARKING)                                           \\\n+   declare_constant_with_value(\"ShenandoahHeap::OLD_MARKING\", ShenandoahHeap::OLD_MARKING)                                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,1 @@\n+  LOG_TAG(methodtrace) \\\n@@ -209,0 +210,1 @@\n+  LOG_TAG(training) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -319,0 +319,3 @@\n+  f(KlassTrainingData) \\\n+  f(MethodTrainingData) \\\n+  f(CompileTrainingData) \\\n@@ -358,0 +361,2 @@\n+  \/\/ This is used for allocating training data. We are allocating training data in many cases where a GC cannot be triggered.\n+  void* operator new(size_t size, MemTag flags);\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-  assert(klass->is_klass(), \"must be instance class\");\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -154,1 +154,2 @@\n-  FieldInfo() : _name_index(0),\n+  FieldInfo() : _index(0),\n+                _name_index(0),\n@@ -166,0 +167,1 @@\n+            _index(0),\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1552,0 +1552,1 @@\n+    CompilationPolicy::replay_training_at_init(this, THREAD);\n@@ -2950,0 +2951,2 @@\n+  _misc_flags.set_has_init_deps_processed(false);\n+\n@@ -3264,2 +3267,2 @@\n-InstanceKlass* InstanceKlass::get_klass_version(int version) {\n-  for (InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n+const InstanceKlass* InstanceKlass::get_klass_version(int version) const {\n+  for (const InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n@@ -4809,1 +4812,1 @@\n-Method* InstanceKlass::method_with_idnum(int idnum) {\n+Method* InstanceKlass::method_with_idnum(int idnum) const {\n@@ -4828,1 +4831,1 @@\n-Method* InstanceKlass::method_with_orig_idnum(int idnum) {\n+Method* InstanceKlass::method_with_orig_idnum(int idnum) const {\n@@ -4848,2 +4851,2 @@\n-Method* InstanceKlass::method_with_orig_idnum(int idnum, int version) {\n-  InstanceKlass* holder = get_klass_version(version);\n+Method* InstanceKlass::method_with_orig_idnum(int idnum, int version) const {\n+  const InstanceKlass* holder = get_klass_version(version);\n@@ -4853,2 +4856,1 @@\n-  Method* method = holder->method_with_orig_idnum(idnum);\n-  return method;\n+  return holder->method_with_orig_idnum(idnum);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -436,3 +436,3 @@\n-  Method* method_with_idnum(int idnum);\n-  Method* method_with_orig_idnum(int idnum);\n-  Method* method_with_orig_idnum(int idnum, int version);\n+  Method* method_with_idnum(int idnum) const;\n+  Method* method_with_orig_idnum(int idnum) const;\n+  Method* method_with_orig_idnum(int idnum, int version) const;\n@@ -790,1 +790,1 @@\n-  InstanceKlass* get_klass_version(int version);\n+  const InstanceKlass* get_klass_version(int version) const;\n@@ -1253,0 +1253,6 @@\n+  bool     has_init_deps_processed() const { return _misc_flags.has_init_deps_processed(); }\n+  void set_has_init_deps_processed() {\n+    assert(is_initialized(), \"\");\n+    assert(!has_init_deps_processed(), \"already set\"); \/\/ one-off action\n+    _misc_flags.set_has_init_deps_processed(true);\n+  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+    status(has_init_deps_processed           , 1 << 5) \/* all init dependencies are processed *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -796,4 +796,12 @@\n-  \/\/ FIXME: validation in Klass::hash_secondary_supers() may fail for shared klasses.\n-  \/\/ Even though the bitmaps always match, the canonical order of elements in the table\n-  \/\/ is not guaranteed to stay the same (see tie breaker during Robin Hood hashing in Klass::hash_insert).\n-  \/\/assert(compute_secondary_supers_bitmap(secondary_supers()) == _secondary_supers_bitmap, \"broken table\");\n+  if (CDSConfig::is_dumping_classic_static_archive()) {\n+    \/\/ \"Classic\" static archives are required to have deterministic contents.\n+    \/\/ The elements in _secondary_supers are addresses in the ArchiveBuilder\n+    \/\/ output buffer, so they should have deterministic values. If we rehash\n+    \/\/ _secondary_supers, its elements will appear in a deterministic order.\n+    \/\/\n+    \/\/ Note that the bitmap is guaranteed to be deterministic, regardless of the\n+    \/\/ actual addresses of the elements in _secondary_supers. So rehashing shouldn't\n+    \/\/ change it.\n+    uintx bitmap = hash_secondary_supers(secondary_supers(), true);\n+    assert(bitmap == _secondary_supers_bitmap, \"bitmap should not be changed due to rehashing\");\n+  }\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -760,0 +760,1 @@\n+  inline bool is_loader_present_and_alive() const;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,0 +80,5 @@\n+inline bool Klass::is_loader_present_and_alive() const {\n+  ClassLoaderData* cld = class_loader_data();\n+  return (cld != nullptr) ? cld->is_alive() : false;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -421,0 +422,6 @@\n+  if (method_data() != nullptr) {\n+    method_data()->remove_unshareable_info();\n+  }\n+  if (method_counters() != nullptr) {\n+    method_counters()->remove_unshareable_info();\n+  }\n@@ -430,0 +437,6 @@\n+  if (method_data() != nullptr) {\n+    method_data()->restore_unshareable_info(CHECK);\n+  }\n+  if (method_counters() != nullptr) {\n+    method_counters()->restore_unshareable_info(CHECK);\n+  }\n@@ -603,0 +616,31 @@\n+MethodTrainingData* Method::training_data_or_null() const {\n+  MethodCounters* mcs = method_counters();\n+  if (mcs == nullptr) {\n+    return nullptr;\n+  } else {\n+    MethodTrainingData* mtd = mcs->method_training_data();\n+    if (mtd == mcs->method_training_data_sentinel()) {\n+      return nullptr;\n+    }\n+    return mtd;\n+  }\n+}\n+\n+bool Method::init_training_data(MethodTrainingData* td) {\n+  MethodCounters* mcs = method_counters();\n+  if (mcs == nullptr) {\n+    return false;\n+  } else {\n+    return mcs->init_method_training_data(td);\n+  }\n+}\n+\n+bool Method::install_training_method_data(const methodHandle& method) {\n+  MethodTrainingData* mtd = MethodTrainingData::find(method);\n+  if (mtd != nullptr && mtd->final_profile() != nullptr) {\n+    Atomic::replace_if_null(&method->_method_data, mtd->final_profile());\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -606,0 +650,3 @@\n+  if (install_training_method_data(method)) {\n+    return;\n+  }\n@@ -1210,0 +1257,6 @@\n+  clear_is_not_c1_compilable();\n+  clear_is_not_c1_osr_compilable();\n+  clear_is_not_c2_compilable();\n+  clear_is_not_c2_osr_compilable();\n+  clear_queued_for_compilation();\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+class MethodTrainingData;\n@@ -317,1 +318,1 @@\n-  MethodData* method_data() const              {\n+  MethodData* method_data() const {\n@@ -320,0 +321,4 @@\n+  void set_method_data(MethodData* data);\n+\n+  MethodTrainingData* training_data_or_null() const;\n+  bool init_training_data(MethodTrainingData* td);\n@@ -348,1 +353,1 @@\n-\n+  static bool install_training_method_data(const methodHandle& method);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -26,0 +27,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -322,0 +324,20 @@\n+static bool is_excluded(Klass* k) {\n+#if INCLUDE_CDS\n+  if (SafepointSynchronize::is_at_safepoint() &&\n+      CDSConfig::is_dumping_archive() &&\n+      CDSConfig::current_thread_is_vm_or_dumper()) {\n+    if (k->is_instance_klass() && !InstanceKlass::cast(k)->is_loaded()) {\n+      log_debug(aot, training)(\"Purged %s from MDO: unloaded class\", k->name()->as_C_string());\n+      return true;\n+    } else {\n+      bool excluded = SystemDictionaryShared::should_be_excluded(k);\n+      if (excluded) {\n+        log_debug(aot, training)(\"Purged %s from MDO: excluded class\", k->name()->as_C_string());\n+      }\n+      return excluded;\n+    }\n+  }\n+#endif\n+  return false;\n+}\n+\n@@ -326,2 +348,7 @@\n-    if (k != nullptr && (always_clean || !k->is_loader_alive())) {\n-      set_type(i, with_status((Klass*)nullptr, p));\n+    if (k != nullptr) {\n+      if (!always_clean && k->is_instance_klass() && InstanceKlass::cast(k)->is_not_initialized()) {\n+        continue; \/\/ skip not-yet-initialized classes \/\/ TODO: maybe clear the slot instead?\n+      }\n+      if (always_clean || !k->is_loader_present_and_alive() || is_excluded(k)) {\n+        set_type(i, with_status((Klass*)nullptr, p));\n+      }\n@@ -332,0 +359,7 @@\n+void TypeStackSlotEntries::metaspace_pointers_do(MetaspaceClosure* it) {\n+  for (int i = 0; i < _number_of_entries; i++) {\n+    Klass** k = (Klass**)type_adr(i); \/\/ tagged\n+    it->push(k);\n+  }\n+}\n+\n@@ -335,2 +369,7 @@\n-  if (k != nullptr && (always_clean || !k->is_loader_alive())) {\n-    set_type(with_status((Klass*)nullptr, p));\n+  if (k != nullptr) {\n+    if (!always_clean && k->is_instance_klass() && InstanceKlass::cast(k)->is_not_initialized()) {\n+      return; \/\/ skip not-yet-initialized classes \/\/ TODO: maybe clear the slot instead?\n+    }\n+    if (always_clean || !k->is_loader_present_and_alive() || is_excluded(k)) {\n+      set_type(with_status((Klass*)nullptr, p));\n+    }\n@@ -340,0 +379,5 @@\n+void SingleTypeEntry::metaspace_pointers_do(MetaspaceClosure* it) {\n+  Klass** k = (Klass**)type_adr(); \/\/ tagged\n+  it->push(k);\n+}\n+\n@@ -415,2 +459,7 @@\n-    if (p != nullptr && (always_clean || !p->is_loader_alive())) {\n-      clear_row(row);\n+    if (p != nullptr) {\n+      if (!always_clean && p->is_instance_klass() && InstanceKlass::cast(p)->is_not_initialized()) {\n+        continue; \/\/ skip not-yet-initialized classes \/\/ TODO: maybe clear the slot instead?\n+      }\n+      if (always_clean || !p->is_loader_present_and_alive() || is_excluded(p)) {\n+        clear_row(row);\n+      }\n@@ -421,0 +470,7 @@\n+void ReceiverTypeData::metaspace_pointers_do(MetaspaceClosure *it) {\n+  for (uint row = 0; row < row_limit(); row++) {\n+    Klass** recv = (Klass**)intptr_at_adr(receiver_cell_index(row));\n+    it->push(recv);\n+  }\n+}\n+\n@@ -653,0 +709,5 @@\n+void SpeculativeTrapData::metaspace_pointers_do(MetaspaceClosure* it) {\n+  Method** m = (Method**)intptr_at_adr(speculative_trap_method);\n+  it->push(m);\n+}\n+\n@@ -1293,1 +1354,0 @@\n-    _extra_data_lock(Mutex::nosafepoint, \"MDOExtraData_lock\"),\n@@ -1296,1 +1356,8 @@\n-  initialize();\n+    _extra_data_lock = nullptr;\n+    initialize();\n+}\n+\n+#if INCLUDE_CDS\n+MethodData::MethodData() {\n+  \/\/ Used by cppVtables.cpp only\n+  assert(CDSConfig::is_dumping_static_archive() || UseSharedSpaces, \"only for CDS\");\n@@ -1298,0 +1365,1 @@\n+#endif\n@@ -1434,1 +1502,1 @@\n-  return CompilationPolicy::is_mature(_method);\n+  return CompilationPolicy::is_mature(const_cast<MethodData*>(this));\n@@ -1622,1 +1690,2 @@\n-  ConditionalMutexLocker ml(extra_data_lock(), !extra_data_lock()->owned_by_self(),\n+  Mutex* lock = const_cast<MethodData*>(this)->extra_data_lock();\n+  ConditionalMutexLocker ml(lock, !lock->owned_by_self(),\n@@ -1795,1 +1864,1 @@\n-  log_trace(aot)(\"Iter(MethodData): %p\", this);\n+  log_trace(aot, training)(\"Iter(MethodData): %p for %p %s\", this, _method, _method->name_and_sig_as_C_string());\n@@ -1797,0 +1866,18 @@\n+  if (_parameters_type_data_di != no_parameters) {\n+    parameters_type_data()->metaspace_pointers_do(it);\n+  }\n+  for (ProfileData* data = first_data(); is_valid(data); data = next_data(data)) {\n+    data->metaspace_pointers_do(it);\n+  }\n+  for (DataLayout* dp = extra_data_base();\n+                   dp < extra_data_limit();\n+                   dp = MethodData::next_extra(dp)) {\n+    if (dp->tag() == DataLayout::speculative_trap_data_tag) {\n+      ResourceMark rm;\n+      SpeculativeTrapData* data = new SpeculativeTrapData(dp);\n+      data->metaspace_pointers_do(it);\n+    } else if (dp->tag() == DataLayout::no_tag ||\n+               dp->tag() == DataLayout::arg_info_data_tag) {\n+      break;\n+    }\n+  }\n@@ -1828,0 +1915,3 @@\n+    if (!_always_clean && m->method_holder()->is_instance_klass() && InstanceKlass::cast(m->method_holder())->is_not_initialized()) {\n+      return true; \/\/ TODO: treat as unloaded instead?\n+    }\n@@ -1839,0 +1929,14 @@\n+Mutex* MethodData::extra_data_lock() {\n+  Mutex* lock = Atomic::load(&_extra_data_lock);\n+  if (lock == nullptr) {\n+    \/\/ This lock could be acquired while we are holding DumpTimeTable_lock\/nosafepoint\n+    lock = new Mutex(Mutex::nosafepoint-1, \"MDOExtraData_lock\");\n+    Mutex* old = Atomic::cmpxchg(&_extra_data_lock, (Mutex*)nullptr, lock);\n+    if (old != nullptr) {\n+      \/\/ Another thread created the lock before us. Use that lock instead.\n+      delete lock;\n+      return old;\n+    }\n+  }\n+  return lock;\n+}\n@@ -1855,1 +1959,1 @@\n-      if (!cl->is_live(m)) {\n+      if (is_excluded(m->method_holder()) || !cl->is_live(m)) {\n@@ -1959,0 +2063,13 @@\n+#if INCLUDE_CDS\n+void MethodData::remove_unshareable_info() {\n+  _extra_data_lock = nullptr;\n+#if INCLUDE_JVMCI\n+  _failed_speculations = nullptr;\n+#endif\n+}\n+\n+void MethodData::restore_unshareable_info(TRAPS) {\n+  \/\/_extra_data_lock = new Mutex(Mutex::nosafepoint, \"MDOExtraData_lock\");\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -1965,1 +2082,1 @@\n-    assert(self->extra_data_lock()->owned_by_self(), \"must have lock\");\n+    assert(self->extra_data_lock()->owned_by_self() || CDSConfig::is_dumping_archive(), \"must have lock\");\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":130,"deletions":13,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"oops\/oop.hpp\"\n@@ -208,0 +207,3 @@\n+  intptr_t* cell_at_adr(int index) const {\n+    return const_cast<intptr_t*>(&_cells[index]);\n+  }\n@@ -354,0 +356,4 @@\n+  intptr_t* intptr_at_adr(int index) const {\n+    assert(0 <= index && index < cell_count(), \"oob\");\n+    return data()->cell_at_adr(index);\n+  }\n@@ -371,6 +377,0 @@\n-  void set_oop_at(int index, oop value) {\n-    set_intptr_at(index, cast_from_oop<intptr_t>(value));\n-  }\n-  oop oop_at(int index) const {\n-    return cast_to_oop(intptr_at(index));\n-  }\n@@ -512,1 +512,4 @@\n-  \/\/ CI translation: ProfileData can represent both MethodDataOop data\n+  \/\/ CDS support\n+  virtual void metaspace_pointers_do(MetaspaceClosure* it) {}\n+\n+    \/\/ CI translation: ProfileData can represent both MethodDataOop data\n@@ -879,0 +882,5 @@\n+  intptr_t* type_adr(int i) const {\n+    assert(i >= 0 && i < _number_of_entries, \"oob\");\n+    return _pd->intptr_at_adr(type_offset_in_cells(i));\n+  }\n+\n@@ -900,0 +908,3 @@\n+  \/\/ CDS support\n+  virtual void metaspace_pointers_do(MetaspaceClosure* it);\n+\n@@ -924,0 +935,4 @@\n+  intptr_t* type_adr() const {\n+    return _pd->intptr_at_adr(_base_off);\n+  }\n+\n@@ -943,0 +958,3 @@\n+  \/\/ CDS support\n+  virtual void metaspace_pointers_do(MetaspaceClosure* it);\n+\n@@ -1134,0 +1152,10 @@\n+  \/\/ CDS support\n+  virtual void metaspace_pointers_do(MetaspaceClosure* it) {\n+    if (has_arguments()) {\n+      _args.metaspace_pointers_do(it);\n+    }\n+    if (has_return()) {\n+      _ret.metaspace_pointers_do(it);\n+    }\n+  }\n+\n@@ -1245,0 +1273,3 @@\n+  \/\/ CDS support\n+  virtual void metaspace_pointers_do(MetaspaceClosure* it);\n+\n@@ -1410,0 +1441,11 @@\n+  \/\/ CDS support\n+  virtual void metaspace_pointers_do(MetaspaceClosure* it) {\n+    ReceiverTypeData::metaspace_pointers_do(it);\n+    if (has_arguments()) {\n+      _args.metaspace_pointers_do(it);\n+    }\n+    if (has_return()) {\n+      _ret.metaspace_pointers_do(it);\n+    }\n+  }\n+\n@@ -1593,4 +1635,0 @@\n-  oop array_oop_at(int index) const {\n-    int aindex = index + array_start_off_set;\n-    return oop_at(aindex);\n-  }\n@@ -1809,0 +1847,5 @@\n+  \/\/ CDS support\n+  virtual void metaspace_pointers_do(MetaspaceClosure* it) {\n+    _parameters.metaspace_pointers_do(it);\n+  }\n+\n@@ -1879,0 +1922,3 @@\n+  \/\/ CDS support\n+  virtual void metaspace_pointers_do(MetaspaceClosure* it);\n+\n@@ -2197,1 +2243,1 @@\n-  Mutex _extra_data_lock;\n+  Mutex* volatile _extra_data_lock;\n@@ -2204,0 +2250,2 @@\n+  MethodData();\n+\n@@ -2501,0 +2549,5 @@\n+#if INCLUDE_CDS\n+  void remove_unshareable_info();\n+  void restore_unshareable_info(TRAPS);\n+#endif\n+\n@@ -2739,1 +2792,1 @@\n-  Mutex* extra_data_lock() const { return const_cast<Mutex*>(&_extra_data_lock); }\n+  Mutex* extra_data_lock();\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":67,"deletions":14,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -621,0 +621,1 @@\n+  case vmIntrinsics::_dcbrt:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -409,0 +409,2 @@\n+  C->print_method(PHASE_INITIAL_LIVENESS, 4);\n+\n@@ -425,0 +427,1 @@\n+    C->print_method(PHASE_LIVE_RANGE_STRETCHING, 4);\n@@ -427,2 +430,0 @@\n-  C->print_method(PHASE_INITIAL_LIVENESS, 4);\n-\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -90,0 +90,5 @@\n+      \/\/ Skip the transformation if input is unexpected.\n+      if (cmp == nullptr) {\n+        return nullptr;\n+      }\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -825,7 +825,13 @@\n-void PhaseCFG::set_next_call(Block* block, Node* n, VectorSet& next_call) {\n-  if( next_call.test_set(n->_idx) ) return;\n-  for( uint i=0; i<n->len(); i++ ) {\n-    Node *m = n->in(i);\n-    if( !m ) continue;  \/\/ must see all nodes in block that precede call\n-    if (get_block_for_node(m) == block) {\n-      set_next_call(block, m, next_call);\n+void PhaseCFG::set_next_call(const Block* block, Node* init, VectorSet& next_call) const {\n+  Node_List worklist;\n+  worklist.push(init);\n+\n+  while (worklist.size() > 0) {\n+    Node* n = worklist.pop();\n+    if (next_call.test_set(n->_idx)) continue;\n+    for (uint i = 0; i < n->len(); i++) {\n+      Node* m = n->in(i);\n+      if (m == nullptr) continue;  \/\/ must see all nodes in block that precede call\n+      if (get_block_for_node(m) == block) {\n+        worklist.push(m);\n+      }\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+  case vmIntrinsics::_dcbrt:\n@@ -1911,0 +1912,3 @@\n+  case vmIntrinsics::_dcbrt:\n+    return StubRoutines::dcbrt() != nullptr ?\n+      runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dcbrt(), \"dcbrt\") : false;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -310,1 +310,3 @@\n-  void set_trip_count(uint tc) { _trip_count = tc; }\n+  \/\/ We use max_juint for the default value of _trip_count to signal it wasn't set.\n+  \/\/ We shouldn't set _trip_count to max_juint explicitly.\n+  void set_trip_count(uint tc) { assert(tc < max_juint, \"Cannot set trip count to max_juint\"); _trip_count = tc; }\n@@ -315,0 +317,1 @@\n+    assert(tc < max_juint, \"Cannot set trip count to max_juint\");\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+  flags(LIVE_RANGE_STRETCHING,          \"Live range stretching\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -259,0 +259,7 @@\n+      if (bol->is_Con()) {\n+        \/\/ A BoolNode shared by two diamond Region\/If sub-graphs\n+        \/\/ was replaced by a constant zero in a previous call to this method.\n+        \/\/ Do nothing as the transformation in the previous call ensures both are folded away.\n+        assert(bol == _stringopts->gvn()->intcon(0), \"shared condition should have been set to false\");\n+        continue;\n+      }\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3154,0 +3154,9 @@\n+JVM_ENTRY(jobject, JVM_CreateThreadSnapshot(JNIEnv* env, jobject jthread))\n+#if INCLUDE_JVMTI\n+  oop snapshot = ThreadSnapshotFactory::get_thread_snapshot(jthread, THREAD);\n+  return JNIHandles::make_local(THREAD, snapshot);\n+#else\n+  return nullptr;\n+#endif\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4439,0 +4439,2 @@\n+  JFR_ONLY(ON_KLASS_REDEFINITION(the_class, current);)\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,0 +140,5 @@\n+struct VMInitArgsGroup {\n+  const JavaVMInitArgs* _args;\n+  JVMFlagOrigin _origin;\n+};\n+\n@@ -540,0 +545,1 @@\n+  { \"PerfDataSamplingInterval\",     JDK_Version::undefined(), JDK_Version::jdk(25), JDK_Version::jdk(26) },\n@@ -543,0 +549,3 @@\n+#if defined(AARCH64)\n+  { \"NearCpool\",                    JDK_Version::undefined(), JDK_Version::jdk(25), JDK_Version::undefined() },\n+#endif\n@@ -1952,6 +1961,1 @@\n-\/\/ Parse JavaVMInitArgs structure\n-\n-jint Arguments::parse_vm_init_args(const JavaVMInitArgs *vm_options_args,\n-                                   const JavaVMInitArgs *java_tool_options_args,\n-                                   const JavaVMInitArgs *java_options_args,\n-                                   const JavaVMInitArgs *cmd_line_args) {\n+jint Arguments::parse_vm_init_args(GrowableArrayCHeap<VMInitArgsGroup, mtArguments>* all_args) {\n@@ -1970,24 +1974,6 @@\n-  \/\/ Parse args structure generated from java.base vm options resource\n-  jint result = parse_each_vm_init_arg(vm_options_args, JVMFlagOrigin::JIMAGE_RESOURCE);\n-  if (result != JNI_OK) {\n-    return result;\n-  }\n-\n-  \/\/ Parse args structure generated from JAVA_TOOL_OPTIONS environment\n-  \/\/ variable (if present).\n-  result = parse_each_vm_init_arg(java_tool_options_args, JVMFlagOrigin::ENVIRON_VAR);\n-  if (result != JNI_OK) {\n-    return result;\n-  }\n-\n-  \/\/ Parse args structure generated from the command line flags.\n-  result = parse_each_vm_init_arg(cmd_line_args, JVMFlagOrigin::COMMAND_LINE);\n-  if (result != JNI_OK) {\n-    return result;\n-  }\n-\n-  \/\/ Parse args structure generated from the _JAVA_OPTIONS environment\n-  \/\/ variable (if present) (mimics classic VM)\n-  result = parse_each_vm_init_arg(java_options_args, JVMFlagOrigin::ENVIRON_VAR);\n-  if (result != JNI_OK) {\n-    return result;\n+  jint result;\n+  for (int i = 0; i < all_args->length(); i++) {\n+    result = parse_each_vm_init_arg(all_args->at(i)._args, all_args->at(i)._origin);\n+    if (result != JNI_OK) {\n+      return result;\n+    }\n@@ -3176,0 +3162,44 @@\n+static JavaVMOption* get_last_aotmode_arg(const JavaVMInitArgs* args) {\n+  for (int index = args->nOptions - 1; index >= 0; index--) {\n+    JavaVMOption* option = args->options + index;\n+    if (strstr(option->optionString, \"-XX:AOTMode=\") == option->optionString) {\n+      return option;\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n+jint Arguments::parse_jdk_aot_vm_options_environment_variable(GrowableArrayCHeap<VMInitArgsGroup, mtArguments>* all_args,\n+                                                            ScopedVMInitArgs* jdk_aot_vm_options_args) {\n+  \/\/ Don't bother scanning all the args if this env variable is not set\n+  if (::getenv(\"JDK_AOT_VM_OPTIONS\") == nullptr) {\n+    return JNI_OK;\n+  }\n+\n+  \/\/ Scan backwards and find the last occurrence of -XX:AOTMode=xxx, which will decide the value\n+  \/\/ of AOTMode.\n+  JavaVMOption* option = nullptr;\n+  for (int i = all_args->length() - 1; i >= 0; i--) {\n+    if ((option = get_last_aotmode_arg(all_args->at(i)._args)) != nullptr) {\n+      break;\n+    }\n+  }\n+\n+  if (option != nullptr) {\n+    \/\/ We have found the last -XX:AOTMode=xxx. At this point <option> has NOT been parsed yet,\n+    \/\/ so its value is not reflected inside the global variable AOTMode.\n+    if (strcmp(option->optionString, \"-XX:AOTMode=create\") != 0) {\n+      return JNI_OK; \/\/ Do not parse JDK_AOT_VM_OPTIONS\n+    }\n+  } else {\n+    \/\/ -XX:AOTMode is not specified in any of 4 options_args, let's check AOTMode,\n+    \/\/ which would have been set inside process_settings_file();\n+    if (AOTMode == nullptr || strcmp(AOTMode, \"create\") != 0) {\n+      return JNI_OK; \/\/ Do not parse JDK_AOT_VM_OPTIONS\n+    }\n+  }\n+\n+  return parse_options_environment_variable(\"JDK_AOT_VM_OPTIONS\", jdk_aot_vm_options_args);\n+}\n+\n@@ -3554,0 +3584,1 @@\n+  ScopedVMInitArgs initial_jdk_aot_vm_options_args(\"env_var='JDK_AOT_VM_OPTIONS'\");\n@@ -3560,0 +3591,1 @@\n+  JavaVMInitArgs* cur_jdk_aot_vm_options_args;\n@@ -3566,0 +3598,1 @@\n+  ScopedVMInitArgs mod_jdk_aot_vm_options_args(\"env_var='_JDK_AOT_VM_OPTIONS'\");\n@@ -3567,0 +3600,1 @@\n+  GrowableArrayCHeap<VMInitArgsGroup, mtArguments> all_args;\n@@ -3574,0 +3608,2 @@\n+  \/\/ Yet another environment variable: _JAVA_OPTIONS. This mimics the classic VM.\n+  \/\/ This is an undocumented feature.\n@@ -3620,7 +3656,1 @@\n-  if (IgnoreUnrecognizedVMOptions) {\n-    cur_cmd_args->ignoreUnrecognized = true;\n-    cur_java_tool_options_args->ignoreUnrecognized = true;\n-    cur_java_options_args->ignoreUnrecognized = true;\n-  }\n-\n-  \/\/ Parse specified settings file\n+  \/\/ Parse specified settings file (s) -- the effects are applied immediately into the JVM global flags.\n@@ -3629,1 +3659,1 @@\n-                               cur_cmd_args->ignoreUnrecognized)) {\n+                               IgnoreUnrecognizedVMOptions)) {\n@@ -3636,1 +3666,1 @@\n-                               cur_cmd_args->ignoreUnrecognized)) {\n+                               IgnoreUnrecognizedVMOptions)) {\n@@ -3647,0 +3677,43 @@\n+  \/\/ The settings in the args are applied in this order to the the JVM global flags.\n+  \/\/ For historical reasons, the order is DIFFERENT than the scanning order of\n+  \/\/ the above expand_vm_options_as_needed() calls.\n+  all_args.append({cur_vm_options_args, JVMFlagOrigin::JIMAGE_RESOURCE});\n+  all_args.append({cur_java_tool_options_args, JVMFlagOrigin::ENVIRON_VAR});\n+  all_args.append({cur_cmd_args, JVMFlagOrigin::COMMAND_LINE});\n+  all_args.append({cur_java_options_args, JVMFlagOrigin::ENVIRON_VAR});\n+\n+  \/\/ JDK_AOT_VM_OPTIONS are parsed only if -XX:AOTMode=create has been detected from all\n+  \/\/ the options that have been gathered above.\n+  code = parse_jdk_aot_vm_options_environment_variable(&all_args, &initial_jdk_aot_vm_options_args);\n+  if (code != JNI_OK) {\n+    return code;\n+  }\n+  code = expand_vm_options_as_needed(initial_jdk_aot_vm_options_args.get(),\n+                                     &mod_jdk_aot_vm_options_args,\n+                                     &cur_jdk_aot_vm_options_args);\n+  if (code != JNI_OK) {\n+    return code;\n+  }\n+\n+  for (int index = 0; index < cur_jdk_aot_vm_options_args->nOptions; index++) {\n+    JavaVMOption* option = cur_jdk_aot_vm_options_args->options + index;\n+    const char* optionString = option->optionString;\n+    if (strstr(optionString, \"-XX:AOTMode=\") == optionString &&\n+        strcmp(optionString, \"-XX:AOTMode=create\") != 0) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"Option %s cannot be specified in JDK_AOT_VM_OPTIONS\\n\", optionString);\n+      return JNI_ERR;\n+    }\n+  }\n+\n+  all_args.append({cur_jdk_aot_vm_options_args, JVMFlagOrigin::ENVIRON_VAR});\n+\n+  if (IgnoreUnrecognizedVMOptions) {\n+    \/\/ Note: unrecognized options in cur_vm_options_arg cannot be ignored. They are part of\n+    \/\/ the JDK so it shouldn't have bad options.\n+    cur_cmd_args->ignoreUnrecognized = true;\n+    cur_java_tool_options_args->ignoreUnrecognized = true;\n+    cur_java_options_args->ignoreUnrecognized = true;\n+    cur_jdk_aot_vm_options_args->ignoreUnrecognized = true;\n+  }\n+\n@@ -3648,0 +3721,1 @@\n+    \/\/ For historical reasons, options specified in cur_vm_options_arg and -XX:Flags are not printed.\n@@ -3651,0 +3725,1 @@\n+    print_options(cur_jdk_aot_vm_options_args);\n@@ -3653,5 +3728,2 @@\n-  \/\/ Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS\n-  jint result = parse_vm_init_args(cur_vm_options_args,\n-                                   cur_java_tool_options_args,\n-                                   cur_java_options_args,\n-                                   cur_cmd_args);\n+  \/\/ Apply the settings in these args to the JVM global flags.\n+  jint result = parse_vm_init_args(&all_args);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":116,"deletions":44,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -152,0 +152,3 @@\n+struct VMInitArgsGroup;\n+template <typename E, MemTag MT> class GrowableArrayCHeap;\n+\n@@ -314,0 +317,2 @@\n+  static jint parse_jdk_aot_vm_options_environment_variable(GrowableArrayCHeap<VMInitArgsGroup, mtArguments>* all_args,\n+                                                            ScopedVMInitArgs* jdk_aot_vm_options_args);\n@@ -331,4 +336,1 @@\n-  static jint parse_vm_init_args(const JavaVMInitArgs *vm_options_args,\n-                                 const JavaVMInitArgs *java_tool_options_args,\n-                                 const JavaVMInitArgs *java_options_args,\n-                                 const JavaVMInitArgs *cmd_line_args);\n+  static jint parse_vm_init_args(GrowableArrayCHeap<VMInitArgsGroup, mtArguments>* all_args);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1755,5 +1755,0 @@\n-  product(int, PerfDataSamplingInterval, 50,                                \\\n-          \"Data sampling interval (in milliseconds)\")                       \\\n-          range(PeriodicTask::min_interval, max_jint)                       \\\n-          constraint(PerfDataSamplingIntervalFunc, AfterErgo)               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/trainingData.hpp\"\n@@ -191,0 +192,5 @@\n+  \/\/ Initialize TrainingData only we're recording\/replaying\n+  if (TrainingData::have_data() || TrainingData::need_data()) {\n+   TrainingData::initialize();\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1799,1 +1799,1 @@\n-        jvf->print_lock_info_on(st, count);\n+        jvf->print_lock_info_on(st, false\/*is_virtual*\/, count);\n@@ -1841,1 +1841,1 @@\n-        jvf->print_lock_info_on(st, count);\n+        jvf->print_lock_info_on(st, true\/*is_virtual*\/, count);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2274,1 +2274,0 @@\n-static int _compact; \/\/ number of equals calls with compact signature\n@@ -2285,1 +2284,0 @@\n-    _compact_int_count = 3\n@@ -2291,1 +2289,5 @@\n-  int _value[_compact_int_count];\n+\n+  static int data_offset() { return sizeof(AdapterFingerPrint); }\n+  int* data_pointer() {\n+    return (int*)((address)this + data_offset());\n+  }\n@@ -2295,0 +2297,1 @@\n+    int* data = data_pointer();\n@@ -2296,2 +2299,2 @@\n-    int total_args_passed = (sig != nullptr) ? sig->length() : 0;\n-    _length = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n+    int total_args_passed = total_args_passed_in_sig(sig);\n+    _length = length(total_args_passed);\n@@ -2331,1 +2334,1 @@\n-      _value[index] = value;\n+      data[index] = value;\n@@ -2338,1 +2341,13 @@\n-    FreeHeap(this);\n+    ShouldNotCallThis();\n+  }\n+\n+  static int total_args_passed_in_sig(const GrowableArray<SigEntry>* sig) {\n+    return (sig != nullptr) ? sig->length() : 0;\n+  }\n+\n+  static int length(int total_args) {\n+    return (total_args + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n+  }\n+\n+  static int compute_size_in_words(int len) {\n+    return (int)heap_word_size(sizeof(AdapterFingerPrint) + (len * sizeof(int)));\n@@ -2401,6 +2416,0 @@\n-  static int allocation_size(const GrowableArray<SigEntry>* sig) {\n-    int total_args_passed = (sig != nullptr) ? sig->length() : 0;\n-    int len = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n-    return sizeof(AdapterFingerPrint) + (len > _compact_int_count ? (len - _compact_int_count) * sizeof(int) : 0);\n-  }\n-\n@@ -2408,2 +2417,6 @@\n-    int size_in_bytes = allocation_size(sig);\n-    return new (size_in_bytes) AdapterFingerPrint(sig, has_ro_adapter);\n+    int total_args_passed = total_args_passed_in_sig(sig);\n+    int len = length(total_args_passed);\n+    int size_in_bytes = BytesPerWord * compute_size_in_words(len);\n+    AdapterFingerPrint* afp = new (size_in_bytes) AdapterFingerPrint(sig, has_ro_adapter);\n+    assert((afp->size() * BytesPerWord) == size_in_bytes, \"should match\");\n+    return afp;\n@@ -2413,1 +2426,1 @@\n-    fp->~AdapterFingerPrint();\n+    FreeHeap(fp);\n@@ -2417,1 +2430,2 @@\n-    return _value[index];\n+    int* data = data_pointer();\n+    return data[index];\n@@ -2421,1 +2435,0 @@\n-    if (_length < 0) return -_length;\n@@ -2425,4 +2438,0 @@\n-  bool is_compact() {\n-    return _length <= _compact_int_count;\n-  }\n-\n@@ -2477,1 +2486,1 @@\n-        if (_value[i] != other->_value[i]) {\n+        if (value(i) != other->value(i)) {\n@@ -2487,1 +2496,1 @@\n-  int size() const { return (int)heap_word_size(sizeof(AdapterFingerPrint) + (_length > _compact_int_count ? (_length - _compact_int_count) * sizeof(int) : 0)); }\n+  int size() const { return compute_size_in_words(_length); }\n@@ -2531,4 +2540,1 @@\n-    if (entry != nullptr) {\n-      if (fp->is_compact()) {\n-        _compact++;\n-      }\n+    if (entry != nullptr) {\n@@ -2537,1 +2543,1 @@\n-#endif\n+#endif\n@@ -2550,1 +2556,0 @@\n-      if (fp->is_compact()) _compact++;\n@@ -2569,2 +2574,2 @@\n-  tty->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d (archived=%d+runtime=%d) compact %d\",\n-                _lookups, _equals, total_hits, _archived_hits, _runtime_hits, _compact);\n+  tty->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d (archived=%d+runtime=%d)\",\n+                _lookups, _equals, total_hits, _archived_hits, _runtime_hits);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":37,"deletions":32,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -748,0 +748,1 @@\n+    assert(size == BytesPerWord * heap_word_size(sizeof(AdapterHandlerEntry)), \"should match\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -604,0 +604,2 @@\n+  do_stub(initial, dcbrt)                                               \\\n+  do_entry(initial, dcbrt, dcbrt, dcbrt)                                \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -91,1 +92,0 @@\n-#include \"runtime\/statSampler.hpp\"\n@@ -816,0 +816,5 @@\n+  \/\/ Initiate replay training processing once preloading is over.\n+  CompileBroker::init_training_replay();\n+\n+  AOTLinkedClassBulkLoader::replay_training_at_init_for_preloaded_classes(CHECK_JNI_ERR);\n+\n@@ -846,7 +851,16 @@\n-  Management::initialize(THREAD);\n-\n-  if (HAS_PENDING_EXCEPTION) {\n-    \/\/ management agent fails to start possibly due to\n-    \/\/ configuration problem and is responsible for printing\n-    \/\/ stack trace if appropriate. Simply exit VM.\n-    vm_exit(1);\n+  bool start_agent = true;\n+#if INCLUDE_CDS\n+  start_agent = !CDSConfig::is_dumping_final_static_archive();\n+  if (!start_agent) {\n+    log_info(aot)(\"Not starting management agent during creation of AOT cache.\");\n+  }\n+#endif \/\/ INCLUDE_CDS\n+  if (start_agent) {\n+    Management::initialize(THREAD);\n+\n+    if (HAS_PENDING_EXCEPTION) {\n+      \/\/ management agent fails to start possibly due to\n+      \/\/ configuration problem and is responsible for printing\n+      \/\/ stack trace if appropriate. Simply exit VM.\n+      vm_exit(1);\n+    }\n@@ -856,1 +870,1 @@\n-  StatSampler::engage();\n+  if (UsePerfData)         PerfDataManager::create_misc_perfdata();\n@@ -910,1 +924,1 @@\n-\/\/      > stop StatSampler, watcher thread,\n+\/\/      > stop watcher thread,\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -119,0 +119,2 @@\n+  template(JFRInitializeCPUTimeSampler)       \\\n+  template(JFRTerminateCPUTimeSampler)        \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1031,0 +1031,1 @@\n+        declare_type(TrainingReplayThread, JavaThread)                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+#if INCLUDE_JVMTI\n@@ -132,0 +133,1 @@\n+#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2273,4 +2273,0 @@\n-            public boolean isCarrierThreadLocalPresent(CarrierThreadLocal<?> local) {\n-                return ((ThreadLocal<?>)local).isCarrierThreadLocalPresent();\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -970,0 +970,1 @@\n+     * @throws  NullPointerException if {@code proxy} is {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-    private final short month;\n+    private final byte month;\n@@ -197,1 +197,1 @@\n-    private final short day;\n+    private final byte day;\n@@ -501,2 +501,2 @@\n-        this.month = (short) month;\n-        this.day = (short) dayOfMonth;\n+        this.month = (byte) month;\n+        this.day = (byte) dayOfMonth;\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    private final int month;\n+    private final byte month;\n@@ -161,1 +161,1 @@\n-    private final int day;\n+    private final byte day;\n@@ -330,2 +330,2 @@\n-        this.month = month;\n-        this.day = dayOfMonth;\n+        this.month = (byte) month;\n+        this.day = (byte) dayOfMonth;\n","filename":"src\/java.base\/share\/classes\/java\/time\/MonthDay.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-    private final int month;\n+    private final byte month;\n@@ -317,1 +317,1 @@\n-        this.month = month;\n+        this.month = (byte) month;\n","filename":"src\/java.base\/share\/classes\/java\/time\/YearMonth.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,1 @@\n-    private final transient int monthOfYear;\n+    private final transient byte monthOfYear;\n@@ -152,1 +152,1 @@\n-    private final transient int dayOfMonth;\n+    private final transient byte dayOfMonth;\n@@ -284,2 +284,2 @@\n-        this.monthOfYear = monthOfYear;\n-        this.dayOfMonth = dayOfMonth;\n+        this.monthOfYear = (byte) monthOfYear;\n+        this.dayOfMonth = (byte) dayOfMonth;\n@@ -298,2 +298,2 @@\n-        this.monthOfYear = dateInfo[1];\n-        this.dayOfMonth = dateInfo[2];\n+        this.monthOfYear = (byte) dateInfo[1];\n+        this.dayOfMonth = (byte) dateInfo[2];\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/HijrahDate.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -550,6 +550,0 @@\n-    \/**\n-     * Returns {@code true} if there is a value in the current carrier thread's copy of\n-     * thread-local, even if that values is {@code null}.\n-     *\/\n-    boolean isCarrierThreadLocalPresent(CarrierThreadLocal<?> local);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-        @JEP(number=487, title=\"Scoped Values\", status=\"Fourth Preview\")\n@@ -84,0 +83,2 @@\n+        @JEP(number=470, title=\"PEM Encodings of Cryptographic Objects\", status=\"Preview\")\n+        PEM_API,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -274,0 +274,3 @@\n+        java.naming,\n+        java.rmi,\n+        java.net.http,\n@@ -277,0 +280,1 @@\n+        jdk.httpserver,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5748,1 +5748,1 @@\n-            tree.vartype = make.at(Position.NOPOS).Erroneous();\n+            tree.vartype = make.at(tree.pos()).Erroneous();\n@@ -5750,1 +5750,1 @@\n-            tree.vartype = make.at(Position.NOPOS).Type(type);\n+            tree.vartype = make.at(tree.pos()).Type(type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,2 @@\n-    metadataTypeArray = new Type[11];\n+    metadataTypeArray = new Type[13];\n+    \/\/ The order needs to match up with CPP_VTABLE_TYPES_DO in src\/hotspot\/share\/cds\/cppVtables.cpp\n@@ -128,4 +129,6 @@\n-    metadataTypeArray[7] = db.lookupType(\"ObjArrayKlass\");\n-    metadataTypeArray[8] = db.lookupType(\"TypeArrayKlass\");\n-    metadataTypeArray[9] = db.lookupType(\"FlatArrayKlass\");\n-    metadataTypeArray[10] = db.lookupType(\"InlineKlass\");\n+    metadataTypeArray[7] = db.lookupType(\"MethodData\");\n+    metadataTypeArray[8] = db.lookupType(\"MethodCounters\");\n+    metadataTypeArray[9] = db.lookupType(\"ObjArrayKlass\");\n+    metadataTypeArray[10] = db.lookupType(\"TypeArrayKlass\");\n+    metadataTypeArray[11] = db.lookupType(\"FlatArrayKlass\");\n+    metadataTypeArray[12] = db.lookupType(\"InlineKlass\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -449,13 +449,1 @@\n-    static class RawItemProfile<T> {\n-        final int entries;\n-        final T[] items;\n-        final long[] counts;\n-        final long totalCount;\n-\n-        RawItemProfile(int entries, T[] items, long[] counts, long totalCount) {\n-            this.entries = entries;\n-            this.items = items;\n-            this.counts = counts;\n-            this.totalCount = totalCount;\n-        }\n-    }\n+    record RawItemProfile<T>(int entries, T[] items, long[] counts, long totalCount) {}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+    final int constMethodFlagsIsOverpass = getConstant(\"ConstMethodFlags::_misc_is_overpass\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -117,0 +117,6 @@\n+    \/**\n+     * Returns {@code true} if this method is contained in the array returned by\n+     * {@code getDeclaringClass().getDeclaredMethods()}\n+     *\/\n+    boolean isDeclared();\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+compiler\/startup\/StartupOutput.java 8358129 windows-all\n+\n@@ -84,1 +86,0 @@\n-compiler\/startup\/StartupOutput.java 8365895 windows-x64\n@@ -116,1 +117,0 @@\n-runtime\/ErrorHandling\/CreateCoredumpOnCrash.java 8267433 macosx-x64\n@@ -243,1 +243,1 @@\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/TestDescription.java 8202971 generic-all\n+vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/TestDescription.java 8358094 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -439,0 +439,1 @@\n+ -runtime\/cds\/appcds\/aotFlags \\\n@@ -540,0 +541,1 @@\n+ -runtime\/cds\/appcds\/aotFlags \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1025,0 +1025,12 @@\n+    @Test\n+    public void getAllMethodsTest() {\n+        for (Class<?> c : classes) {\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            Set<ResolvedJavaMethod> allMethods = new HashSet<>(type.getAllMethods(true));\n+            Stream<ResolvedJavaMethod> allKnownMethods = Stream.concat(Arrays.stream(type.getDeclaredMethods()), Arrays.stream(type.getDeclaredConstructors()));\n+            allKnownMethods = Stream.concat(allKnownMethods, Stream.ofNullable(type.getClassInitializer()));\n+            List<ResolvedJavaMethod> missingMethods = allKnownMethods.filter(m -> !allMethods.contains(m)).toList();\n+            assertTrue(missingMethods.toString(), missingMethods.isEmpty());\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -491,1 +491,0 @@\n-java\/awt\/Graphics2D\/CopyAreaOOB.java 8343106 macosx-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}