{"files":[{"patch":"@@ -823,1 +823,1 @@\n-      && super_type->super() != nullptr \/* Super is not j.l.Object *\/) {\n+      && super_type->name() != vmSymbols::java_lang_Object()) {\n@@ -4924,1 +4924,0 @@\n-  const bool is_value_class  = !class_access_flags.is_identity_class();\n@@ -4987,14 +4986,6 @@\n-    if (is_value_class && is_initializer) {\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_ClassFormatError(),\n-        \"Method <init> is not allowed in value class %s\",\n-        _class_name->as_C_string());\n-    } else {\n-      Exceptions::fthrow(\n-        THREAD_AND_LOCATION,\n-        vmSymbols::java_lang_ClassFormatError(),\n-        \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n-        name->as_C_string(), _class_name->as_C_string(),\n-        class_note, flags);\n-    }\n+    Exceptions::fthrow(\n+      THREAD_AND_LOCATION,\n+      vmSymbols::java_lang_ClassFormatError(),\n+      \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n+      name->as_C_string(), _class_name->as_C_string(),\n+      class_note, flags);\n@@ -6418,3 +6409,2 @@\n-    if (_super_klass != nullptr  \/\/ not j.l.Object\n-              && _parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_LooselyConsistentValue)\n-              && (_super_klass == vmClasses::Object_klass() || !_super_klass->must_be_atomic())) {\n+    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_LooselyConsistentValue)\n+        && (_super_klass == vmClasses::Object_klass() || !_super_klass->must_be_atomic())) {\n@@ -6423,1 +6413,2 @@\n-    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ImplicitlyConstructible)) {\n+    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ImplicitlyConstructible)\n+        && (_super_klass == vmClasses::Object_klass() || _super_klass->is_implicitly_constructible())) {\n@@ -6595,1 +6586,1 @@\n-      access_flags().is_abstract() && !access_flags().is_identity_class(),\n+      access_flags().is_abstract() && !access_flags().is_identity_class() && !access_flags().is_interface(),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -603,0 +603,1 @@\n+  \/\/ Being an inline type means being a concrete value class\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1013,4 +1013,0 @@\n-      if (element_klass->is_inline_klass()) {\n-        InlineKlass* ik = InlineKlass::cast(element_klass);\n-        comp_oop = ik->java_mirror();\n-      }\n@@ -1105,6 +1101,1 @@\n-  \/\/ Inline classes encapsulate two mirror objects, a value mirror (primitive value mirror)\n-  \/\/ and a reference mirror (primitive class mirror), skip over scratch mirror allocation\n-  \/\/ for inline classes, they will not be part of shared archive and will be created while\n-  \/\/ restoring unshared fileds. Refer Klass::restore_unshareable_info() for more details.\n-  if (k->is_inline_klass() ||\n-      (k->class_loader() != nullptr &&\n+  if ((k->class_loader() != nullptr &&\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-\/\/#include \"oops\/oop.inline.hpp\"\n@@ -35,1 +34,2 @@\n-\/\/ An InlineKlass is a specialized InstanceKlass for inline types.\n+\/\/ An InlineKlass is a specialized InstanceKlass for concrete value classes\n+\/\/ (abstract value classes are represented by InstanceKlass)\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1008,1 +1008,10 @@\n-          \/\/ the inline_type_field_klass_array is not updated because of CDS (see verifications in SystemDictionary::load_shared_class())\n+          \/\/ the inline_type_field_klasses_array might have been loaded with CDS, so update only if not already set and check consistency\n+          if (inline_type_field_klasses_array()->at(fs.index()) == nullptr) {\n+            set_inline_type_field_klass(fs.index(), InlineKlass::cast(ik));\n+          }\n+          assert(get_inline_type_field_klass(fs.index()) == ik, \"Must match\");\n+        } else {\n+          if (inline_type_field_klasses_array()->at(fs.index()) == nullptr) {\n+            set_inline_type_field_klass(fs.index(), InlineKlass::cast(this));\n+          }\n+          assert(get_inline_type_field_klass(fs.index()) == this, \"Must match\");\n@@ -1386,9 +1395,0 @@\n-        Klass* klass = get_inline_type_field_klass_or_null(fs.index());\n-        if (fs.access_flags().is_static() && klass == nullptr) {\n-          klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())->fundamental_name(THREAD),\n-              Handle(THREAD, class_loader()),\n-              Handle(THREAD, protection_domain()),\n-              true, THREAD);\n-          assert(klass->is_inline_klass(), \"Must be\");\n-          set_inline_type_field_klass(fs.index(), InlineKlass::cast(klass));\n-        }\n@@ -1396,7 +1396,7 @@\n-        if (!HAS_PENDING_EXCEPTION) {\n-          assert(klass != nullptr, \"Must  be\");\n-          InstanceKlass::cast(klass)->initialize(THREAD);\n-          if (fs.access_flags().is_static()) {\n-            if (java_mirror()->obj_field(fs.offset()) == nullptr) {\n-              java_mirror()->obj_field_put(fs.offset(), InlineKlass::cast(klass)->default_value());\n-            }\n+        \/\/ inline type field klass array entries must have alreadyt been filed at load time or link time\n+        Klass* klass = get_inline_type_field_klass(fs.index());\n+\n+        InstanceKlass::cast(klass)->initialize(THREAD);\n+        if (fs.access_flags().is_static()) {\n+          if (java_mirror()->obj_field(fs.offset()) == nullptr) {\n+            java_mirror()->obj_field_put(fs.offset(), InlineKlass::cast(klass)->default_value());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -668,3 +668,1 @@\n-  bool is_inline_klass()                const { return is_inline_klass_slow(); } \/\/temporary hack\n-  \/\/ Other is anything that is not one of the more specialized kinds of InstanceKlass.\n-  bool is_other_instance_klass()        const { return _kind <= InlineKlassKind; }\n+  bool is_inline_klass()                const { return assert_same_query(_kind == InlineKlassKind, is_inline_klass_slow()); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -440,1 +440,1 @@\n-    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not annotated with @ImplicitlyConstructible\");\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,2 @@\n-  return is_final() && (is_static() || ik->is_hidden() || ik->is_record() || ik->is_inline_klass());\n+  return is_final() && (is_static() || ik->is_hidden() || ik->is_record() || ik->is_inline_klass()\n+                        || (ik->is_abstract() && !ik->is_identity_class() && !ik->is_interface()));\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4176,0 +4176,1 @@\n+    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1112,0 +1112,1 @@\n+    @ImplicitlyConstructible\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -364,0 +364,50 @@\n+\n+    \/\/ Test that a value class annotated with @ImplicitlyConstructible but extending\n+    \/\/ an abstract value class not annotated with @ImplicitlyConstructible is not\n+    \/\/ considered as implicitely constructible\n+\n+    static abstract value class AbstractValue14 { }\n+    @ImplicitlyConstructible\n+    static value class Value14 extends AbstractValue14 { }\n+\n+    static class Test14 {\n+        @NullRestricted\n+        Value14 val;\n+    }\n+\n+    void test_14() {\n+        Throwable exception = null;\n+        try {\n+            Test14 t14 = new Test14();\n+        } catch(IncompatibleClassChangeError e) {\n+            exception = e;\n+            System.out.println(\"Received \"+ e);\n+        }\n+        Asserts.assertNotNull(exception, \"Expected IncompatibleClassChangeError not received\");\n+    }\n+\n+    \/\/ Test that a value class annotated with @ImplicitlyConstructible but extending\n+    \/\/ an abstract value class also annotated with @ImplicitlyConstructible is\n+    \/\/ considered as implicitely constructible\n+\n+    @ImplicitlyConstructible\n+    static abstract value class AbstractValue15 { }\n+    @ImplicitlyConstructible\n+    static value class Value15 extends AbstractValue15 { }\n+\n+    static class Test15 {\n+        @NullRestricted\n+        Value15 val;\n+    }\n+\n+    void test_15() {\n+        Throwable exception = null;\n+        try {\n+            Test15 t15 = new Test15();\n+        } catch(IncompatibleClassChangeError e) {\n+            exception = e;\n+            System.out.println(\"Received \"+ e);\n+        }\n+        Asserts.assertNull(exception, \"Unexpected IncompatibleClassChangeError received\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/AnnotationsTests.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"}]}