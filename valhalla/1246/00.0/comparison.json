{"files":[{"patch":"@@ -34,0 +34,2 @@\n+include CopyFiles.gmk\n+\n","filename":"make\/CompileJavaModules.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/Docs.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/Images.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+include CopyFiles.gmk\n","filename":"make\/test\/BuildTestLib.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+include CopyFiles.gmk\n@@ -846,3 +848,5 @@\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeinvoke := -ljvm -lpthread\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-gap := -ljvm -lpthread\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-tls := -ljvm\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exeinvoke := java.base:libjvm\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exestack-gap := java.base:libjvm\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exestack-tls := java.base:libjvm\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeinvoke := -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exestack-gap := -lpthread\n@@ -863,1 +867,3 @@\n-BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exesigtest := -ljvm\n+BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exesigtest := java.base:libjvm\n+BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libatExit := java.base:libjvm\n+BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exedaemonDestroy := java.base:libjvm\n@@ -868,3 +874,1 @@\n-  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit := jvm.lib\n-  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativeStack := jvm.lib\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exedaemonDestroy := jvm.lib\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_JDK_LIBS_libnativeStack := java.base:libjvm\n@@ -872,1 +876,0 @@\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exedaemonDestroy := -ljvm\n@@ -1508,1 +1511,0 @@\n-  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit += -ljvm\n@@ -1512,1 +1514,2 @@\n-  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeGetCreatedJavaVMs := -ljvm -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exeGetCreatedJavaVMs := -lpthread\n+  BUILD_HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exeGetCreatedJavaVMs := java.base:libjvm\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2014, 2021, Red Hat, Inc. All rights reserved.\n+\/\/ Copyright (c) 2014, 2024, Red Hat, Inc. All rights reserved.\n@@ -1151,2 +1151,2 @@\n-  static int emit_exception_handler(CodeBuffer &cbuf);\n-  static int emit_deopt_handler(CodeBuffer& cbuf);\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n+  static int emit_deopt_handler(C2_MacroAssembler* masm);\n@@ -1605,1 +1605,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -1663,2 +1663,1 @@\n-void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n+void MachBreakpointNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1680,2 +1679,1 @@\n-  void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc*) const {\n-    C2_MacroAssembler _masm(&cbuf);\n+  void MachNopNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc*) const {\n@@ -1703,1 +1701,1 @@\n-void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {\n+void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n@@ -1757,1 +1755,1 @@\n-void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1759,1 +1757,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1779,1 +1776,1 @@\n-  C->output()->set_frame_complete(cbuf.insts_size());\n+  C->output()->set_frame_complete(__ offset());\n@@ -1827,1 +1824,1 @@\n-void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachEpilogNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1829,1 +1826,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1896,1 +1892,1 @@\n-uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {\n+uint MachSpillCopyNode::implementation(C2_MacroAssembler *masm, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {\n@@ -1929,2 +1925,1 @@\n-    if (ireg == Op_VecA && cbuf) {\n-      C2_MacroAssembler _masm(cbuf);\n+    if (ireg == Op_VecA && masm) {\n@@ -1949,1 +1944,1 @@\n-    } else if (cbuf) {\n+    } else if (masm) {\n@@ -1951,1 +1946,0 @@\n-      C2_MacroAssembler _masm(cbuf);\n@@ -1978,2 +1972,1 @@\n-  } else if (cbuf) {\n-    C2_MacroAssembler _masm(cbuf);\n+  } else if (masm) {\n@@ -1987,1 +1980,0 @@\n-            C2_MacroAssembler _masm(cbuf);\n@@ -2115,2 +2107,2 @@\n-void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  implementation(&cbuf, ra_, false, nullptr);\n+void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  implementation(masm, ra_, false, nullptr);\n@@ -2134,3 +2126,1 @@\n-void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  C2_MacroAssembler _masm(&cbuf);\n-\n+void BoxLockNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -2169,1 +2159,1 @@\n-void MachVEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+void MachVEPNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc* ra_) const\n@@ -2171,2 +2161,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n-\n@@ -2219,1 +2207,1 @@\n-void MachUEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+void MachUEPNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n@@ -2221,2 +2209,0 @@\n-  \/\/ This is the unverified entry point.\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -2231,1 +2217,1 @@\n-int HandlerImpl::emit_exception_handler(CodeBuffer& cbuf)\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n@@ -2237,1 +2223,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -2251,1 +2236,1 @@\n-int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf)\n+int HandlerImpl::emit_deopt_handler(C2_MacroAssembler* masm)\n@@ -2255,1 +2240,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -2674,1 +2658,0 @@\n-  C2_MacroAssembler _masm(&cbuf);                                       \\\n@@ -2719,1 +2702,1 @@\n-  static void loadStore(C2_MacroAssembler masm, mem_insn insn,\n+  static void loadStore(C2_MacroAssembler* masm, mem_insn insn,\n@@ -2729,1 +2712,1 @@\n-      addr = masm.legitimize_address(addr, size_in_memory, rscratch1);\n+      addr = __ legitimize_address(addr, size_in_memory, rscratch1);\n@@ -2731,1 +2714,1 @@\n-    (masm.*insn)(reg, addr);\n+    (masm->*insn)(reg, addr);\n@@ -2734,1 +2717,1 @@\n-  static void loadStore(C2_MacroAssembler masm, mem_float_insn insn,\n+  static void loadStore(C2_MacroAssembler* masm, mem_float_insn insn,\n@@ -2757,2 +2740,2 @@\n-      addr = masm.legitimize_address(addr, size_in_memory, rscratch1);\n-      (masm.*insn)(reg, addr);\n+      addr = __ legitimize_address(addr, size_in_memory, rscratch1);\n+      (masm->*insn)(reg, addr);\n@@ -2761,1 +2744,1 @@\n-      (masm.*insn)(reg, Address(base, as_Register(index), scale));\n+      (masm->*insn)(reg, Address(base, as_Register(index), scale));\n@@ -2765,1 +2748,1 @@\n-  static void loadStore(C2_MacroAssembler masm, mem_vector_insn insn,\n+  static void loadStore(C2_MacroAssembler* masm, mem_vector_insn insn,\n@@ -2770,1 +2753,1 @@\n-      (masm.*insn)(reg, T, Address(base, disp));\n+      (masm->*insn)(reg, T, Address(base, disp));\n@@ -2773,1 +2756,1 @@\n-      (masm.*insn)(reg, T, Address(base, as_Register(index), Address::lsl(size)));\n+      (masm->*insn)(reg, T, Address(base, as_Register(index), Address::lsl(size)));\n@@ -2818,1 +2801,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2828,1 +2810,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsbw, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrsbw, dst_reg, $mem->opcode(),\n@@ -2836,1 +2818,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsb, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrsb, dst_reg, $mem->opcode(),\n@@ -2844,1 +2826,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrb, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrb, dst_reg, $mem->opcode(),\n@@ -2852,1 +2834,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrb, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrb, dst_reg, $mem->opcode(),\n@@ -2860,1 +2842,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrshw, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrshw, dst_reg, $mem->opcode(),\n@@ -2868,1 +2850,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsh, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrsh, dst_reg, $mem->opcode(),\n@@ -2876,1 +2858,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrh, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrh, dst_reg, $mem->opcode(),\n@@ -2884,1 +2866,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrh, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrh, dst_reg, $mem->opcode(),\n@@ -2892,1 +2874,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrw, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrw, dst_reg, $mem->opcode(),\n@@ -2900,1 +2882,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrw, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrw, dst_reg, $mem->opcode(),\n@@ -2908,1 +2890,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrsw, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrsw, dst_reg, $mem->opcode(),\n@@ -2916,1 +2898,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldr, dst_reg, $mem->opcode(),\n@@ -2924,1 +2906,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrs, dst_reg, $mem->opcode(),\n@@ -2932,1 +2914,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, dst_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrd, dst_reg, $mem->opcode(),\n@@ -2940,1 +2922,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strb, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strb, src_reg, $mem->opcode(),\n@@ -2947,2 +2929,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    loadStore(_masm, &MacroAssembler::strb, zr, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strb, zr, $mem->opcode(),\n@@ -2956,1 +2937,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strh, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strh, src_reg, $mem->opcode(),\n@@ -2963,2 +2944,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    loadStore(_masm, &MacroAssembler::strh, zr, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strh, zr, $mem->opcode(),\n@@ -2972,1 +2952,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strw, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strw, src_reg, $mem->opcode(),\n@@ -2979,2 +2959,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    loadStore(_masm, &MacroAssembler::strw, zr, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strw, zr, $mem->opcode(),\n@@ -2991,1 +2970,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n@@ -2996,1 +2974,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::str, src_reg, $mem->opcode(),\n@@ -3003,2 +2981,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    loadStore(_masm, &MacroAssembler::str, zr, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::str, zr, $mem->opcode(),\n@@ -3012,1 +2989,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strs, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strs, src_reg, $mem->opcode(),\n@@ -3020,1 +2997,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::strd, src_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::strd, src_reg, $mem->opcode(),\n@@ -3027,2 +3004,1 @@\n-      C2_MacroAssembler _masm(&cbuf);\n-      loadStore(_masm, &MacroAssembler::strb, zr, $mem->opcode(),\n+      loadStore(masm, &MacroAssembler::strb, zr, $mem->opcode(),\n@@ -3038,1 +3014,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::H,\n+    loadStore(masm, &MacroAssembler::ldr, dst_reg, MacroAssembler::H,\n@@ -3044,1 +3020,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::S,\n+    loadStore(masm, &MacroAssembler::ldr, dst_reg, MacroAssembler::S,\n@@ -3050,1 +3026,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::D,\n+    loadStore(masm, &MacroAssembler::ldr, dst_reg, MacroAssembler::D,\n@@ -3056,1 +3032,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::Q,\n+    loadStore(masm, &MacroAssembler::ldr, dst_reg, MacroAssembler::Q,\n@@ -3062,1 +3038,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::H,\n+    loadStore(masm, &MacroAssembler::str, src_reg, MacroAssembler::H,\n@@ -3068,1 +3044,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::S,\n+    loadStore(masm, &MacroAssembler::str, src_reg, MacroAssembler::S,\n@@ -3074,1 +3050,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::D,\n+    loadStore(masm, &MacroAssembler::str, src_reg, MacroAssembler::D,\n@@ -3080,1 +3056,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::Q,\n+    loadStore(masm, &MacroAssembler::str, src_reg, MacroAssembler::Q,\n@@ -3196,1 +3172,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n@@ -3212,1 +3187,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n@@ -3222,1 +3196,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n@@ -3233,1 +3206,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3262,1 +3234,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3292,1 +3263,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3300,1 +3270,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3308,1 +3277,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3316,1 +3284,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3329,1 +3296,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3337,1 +3303,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3345,1 +3310,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3353,1 +3317,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3362,1 +3325,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3370,1 +3332,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3391,1 +3352,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3402,1 +3362,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3413,1 +3372,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3439,1 +3397,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3445,1 +3402,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3451,1 +3407,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3456,1 +3411,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3469,1 +3423,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3475,1 +3428,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3490,1 +3442,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3504,1 +3455,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3518,1 +3468,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3526,1 +3475,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3534,1 +3482,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3542,1 +3489,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3552,1 +3498,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3559,1 +3504,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3570,1 +3514,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3578,1 +3521,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3585,1 +3527,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3600,1 +3541,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3608,1 +3548,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3615,1 +3554,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3622,1 +3560,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3628,1 +3565,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3634,1 +3570,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3640,1 +3575,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3646,1 +3580,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3659,1 +3592,0 @@\n-     C2_MacroAssembler _masm(&cbuf);\n@@ -3670,2 +3602,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-\n@@ -3687,1 +3617,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -3698,1 +3628,1 @@\n-        cbuf.shared_stub_to_interp_for(_method, call - cbuf.insts_begin());\n+        __ code()->shared_stub_to_interp_for(_method, call - __ begin());\n@@ -3701,1 +3631,1 @@\n-        address stub = CompiledDirectCall::emit_to_interp_stub(cbuf, call);\n+        address stub = CompiledDirectCall::emit_to_interp_stub(masm, call);\n@@ -3718,2 +3648,1 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-    int method_index = resolved_method_index(cbuf);\n+    int method_index = resolved_method_index(masm);\n@@ -3732,1 +3661,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3771,2 +3699,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n-\n@@ -3803,1 +3729,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3808,1 +3733,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3818,1 +3742,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -3824,1 +3747,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -4593,1 +4515,1 @@\n-\/\/ Null Pointer Immediate\n+\/\/ nullptr Pointer Immediate\n@@ -4701,1 +4623,1 @@\n-\/\/ Narrow Null Pointer Immediate\n+\/\/ Narrow nullptr Pointer Immediate\n@@ -6796,1 +6718,1 @@\n-  format %{ \"mov  $dst, $con\\t# null pointer\" %}\n+  format %{ \"mov  $dst, $con\\t# nullptr ptr\" %}\n@@ -6810,1 +6732,1 @@\n-  format %{ \"mov  $dst, $con\\t# null pointer\" %}\n+  format %{ \"mov  $dst, $con\\t# nullptr ptr\" %}\n@@ -6852,1 +6774,1 @@\n-  format %{ \"mov  $dst, $con\\t# compressed null pointer\" %}\n+  format %{ \"mov  $dst, $con\\t# compressed nullptr ptr\" %}\n@@ -7763,1 +7685,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, tmp_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrs, tmp_reg, $mem->opcode(),\n@@ -7804,1 +7726,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, tmp_reg, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrd, tmp_reg, $mem->opcode(),\n@@ -16357,0 +16279,33 @@\n+instruct partialSubtypeCheckConstSuper(iRegP_R4 sub, iRegP_R0 super_reg, immP super_con, vRegD_V0 vtemp, iRegP_R5 result,\n+                                       iRegP_R1 tempR1, iRegP_R2 tempR2, iRegP_R3 tempR3,\n+                                       rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub (Binary super_reg super_con)));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP tempR1, TEMP tempR2, TEMP tempR3, TEMP vtemp);\n+\n+  ins_cost(700);  \/\/ smaller than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, super\" %}\n+\n+  ins_encode %{\n+    bool success = false;\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      success = __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register,\n+                                                 $tempR1$$Register, $tempR2$$Register, $tempR3$$Register,\n+                                                 $vtemp$$FloatRegister,\n+                                                 $result$$Register,\n+                                                 super_klass_slot);\n+    } else {\n+      address call = __ trampoline_call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n+      success = (call != nullptr);\n+    }\n+    if (!success) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n+    }\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -16950,1 +16905,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, $tsrc$$FloatRegister, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrs, $tsrc$$FloatRegister, $mem->opcode(),\n@@ -16987,1 +16942,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, $tsrc$$FloatRegister, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrd, $tsrc$$FloatRegister, $mem->opcode(),\n@@ -17024,1 +16979,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrs, $tsrc$$FloatRegister, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrs, $tsrc$$FloatRegister, $mem->opcode(),\n@@ -17062,1 +17017,1 @@\n-    loadStore(C2_MacroAssembler(&cbuf), &MacroAssembler::ldrd, $tsrc$$FloatRegister, $mem->opcode(),\n+    loadStore(masm, &MacroAssembler::ldrd, $tsrc$$FloatRegister, $mem->opcode(),\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":112,"deletions":157,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -178,2 +178,4 @@\n-      LIR_Opr tmp = new_pointer_register();\n-      __ shift_left(index, shift, tmp);\n+      \/\/ Use long register to avoid overflow when shifting large index values left.\n+      LIR_Opr tmp = new_register(T_LONG);\n+      __ convert(Bytecodes::_i2l, index, tmp);\n+      __ shift_left(tmp, shift, tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  return (cb()->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -1556,0 +1556,3 @@\n+  \/\/ NB! Callers may assume that, when temp2_reg is a valid register,\n+  \/\/ this code sets it to a nonzero value.\n+\n@@ -1635,0 +1638,235 @@\n+\/\/ Ensure that the inline code and the stub are using the same registers.\n+#define LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS                    \\\n+do {                                                               \\\n+  assert(r_super_klass  == r0                                   && \\\n+         r_array_base   == r1                                   && \\\n+         r_array_length == r2                                   && \\\n+         (r_array_index == r3        || r_array_index == noreg) && \\\n+         (r_sub_klass   == r4        || r_sub_klass   == noreg) && \\\n+         (r_bitmap      == rscratch2 || r_bitmap      == noreg) && \\\n+         (result        == r5        || result        == noreg), \"registers must match aarch64.ad\"); \\\n+} while(0)\n+\n+\/\/ Return true: we succeeded in generating this code\n+bool MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   FloatRegister vtemp,\n+                                                   Register result,\n+                                                   u1 super_klass_slot,\n+                                                   bool stub_is_near) {\n+  assert_different_registers(r_sub_klass, temp1, temp2, temp3, result, rscratch1, rscratch2);\n+\n+  Label L_fallthrough;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_base   = temp1, \/\/ r1\n+    r_array_length = temp2, \/\/ r2\n+    r_array_index  = temp3, \/\/ r3\n+    r_bitmap       = rscratch2;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  u1 bit = super_klass_slot;\n+\n+  \/\/ Make sure that result is nonzero if the TBZ below misses.\n+  mov(result, 1);\n+\n+  \/\/ We're going to need the bitmap in a vector reg and in a core reg,\n+  \/\/ so load both now.\n+  ldr(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  if (bit != 0) {\n+    ldrd(vtemp, Address(r_sub_klass, Klass::bitmap_offset()));\n+  }\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  tbz(r_bitmap, bit, L_fallthrough);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    shld(vtemp, vtemp, Klass::SECONDARY_SUPERS_TABLE_MASK - bit);\n+    cnt(vtemp, T8B, vtemp);\n+    addv(vtemp, T8B, vtemp);\n+    fmovd(r_array_index, vtemp);\n+  } else {\n+    mov(r_array_index, (u1)1);\n+  }\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+\n+  \/\/ We will consult the secondary-super array.\n+  ldr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the\n+  \/\/ data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  ldr(result, Address(r_array_base, r_array_index, Address::lsl(LogBytesPerWord)));\n+  eor(result, result, r_super_klass);\n+  cbz(result, L_fallthrough); \/\/ Found a match\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  tbz(r_bitmap, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK, L_fallthrough);\n+\n+  \/\/ Linear probe.\n+  if (bit != 0) {\n+    ror(r_bitmap, r_bitmap, bit);\n+  }\n+\n+  \/\/ The slot we just inspected is at secondary_supers[r_array_index - 1].\n+  \/\/ The next slot to be inspected, by the stub we're about to call,\n+  \/\/ is secondary_supers[r_array_index]. Bits 0 and 1 in the bitmap\n+  \/\/ have been checked.\n+  Address stub = RuntimeAddress(StubRoutines::lookup_secondary_supers_table_slow_path_stub());\n+  if (stub_is_near) {\n+    bl(stub);\n+  } else {\n+    address call = trampoline_call(stub);\n+    if (call == nullptr) {\n+      return false; \/\/ trampoline allocation failed\n+    }\n+  }\n+\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  bind(L_fallthrough);\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, \/\/ r4, r0\n+                                  temp1, temp2, result);      \/\/ r1, r2, r5\n+  }\n+  return true;\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                                             Register r_array_base,\n+                                                             Register r_array_index,\n+                                                             Register r_bitmap,\n+                                                             Register temp1,\n+                                                             Register result) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, temp1, result, rscratch1);\n+\n+  const Register\n+    r_array_length = temp1,\n+    r_sub_klass    = noreg; \/\/ unused\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  Label L_fallthrough, L_huge;\n+\n+  \/\/ Load the array length.\n+  ldrw(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  \/\/ NB! Effectively increments current slot index by 1.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"\");\n+  add(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ The bitmap is full to bursting.\n+  \/\/ Implicit invariant: BITMAP_FULL implies (length > 0)\n+  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"\");\n+  cmn(r_bitmap, (u1)1);\n+  br(EQ, L_huge);\n+\n+  \/\/ NB! Our caller has checked bits 0 and 1 in the bitmap. The\n+  \/\/ current slot (at secondary_supers[r_array_index]) has not yet\n+  \/\/ been inspected, and r_array_index may be out of bounds if we\n+  \/\/ wrapped around the end of the array.\n+\n+  { \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n+    \/\/ eventually terminates.\n+    Label L_loop;\n+    bind(L_loop);\n+\n+    \/\/ Check for wraparound.\n+    cmp(r_array_index, r_array_length);\n+    csel(r_array_index, zr, r_array_index, GE);\n+\n+    ldr(rscratch1, Address(r_array_base, r_array_index, Address::lsl(LogBytesPerWord)));\n+    eor(result, rscratch1, r_super_klass);\n+    cbz(result, L_fallthrough);\n+\n+    tbz(r_bitmap, 2, L_fallthrough); \/\/ look-ahead check (Bit 2); result is non-zero\n+\n+    ror(r_bitmap, r_bitmap, 1);\n+    add(r_array_index, r_array_index, 1);\n+    b(L_loop);\n+  }\n+\n+  { \/\/ Degenerate case: more than 64 secondary supers.\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+    bind(L_huge);\n+    cmp(sp, zr); \/\/ Clear Z flag; SP is never zero\n+    repne_scan(r_array_base, r_super_klass, r_array_length, rscratch1);\n+    cset(result, NE); \/\/ result == 0 iff we got a match.\n+  }\n+\n+  bind(L_fallthrough);\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register result) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, result, rscratch1);\n+\n+  const Register\n+    r_array_base   = temp1,\n+    r_array_length = temp2,\n+    r_array_index  = noreg, \/\/ unused\n+    r_bitmap       = noreg; \/\/ unused\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  BLOCK_COMMENT(\"verify_secondary_supers_table {\");\n+\n+  \/\/ We will consult the secondary-super array.\n+  ldr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ Load the array length.\n+  ldrw(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  add(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  cmp(sp, zr); \/\/ Clear Z flag; SP is never zero\n+  \/\/ Scan R2 words at [R5] for an occurrence of R0.\n+  \/\/ Set NZ\/Z based on last compare.\n+  repne_scan(\/*addr*\/r_array_base, \/*value*\/r_super_klass, \/*count*\/r_array_length, rscratch2);\n+  \/\/ rscratch1 == 0 iff we got a match.\n+  cset(rscratch1, NE);\n+\n+  Label passed;\n+  cmp(result, zr);\n+  cset(result, NE); \/\/ normalize result to 0\/1 for comparison\n+\n+  cmp(rscratch1, result);\n+  br(EQ, passed);\n+  {\n+    mov(r0, r_super_klass);         \/\/ r0 <- r0\n+    mov(r1, r_sub_klass);           \/\/ r1 <- r4\n+    mov(r2, \/*expected*\/rscratch1); \/\/ r2 <- r8\n+    mov(r3, result);                \/\/ r3 <- r5\n+    mov(r4, (address)(\"mismatch\")); \/\/ r4 <- const\n+    rt_call(CAST_FROM_FN_PTR(address, Klass::on_secondary_supers_verification_failure), rscratch2);\n+    should_not_reach_here();\n+  }\n+  bind(passed);\n+\n+  BLOCK_COMMENT(\"} verify_secondary_supers_table\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":239,"deletions":1,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -1062,0 +1062,25 @@\n+  \/\/ As above, but with a constant super_klass.\n+  \/\/ The result is in Register result, not the condition codes.\n+  bool lookup_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     FloatRegister vtemp,\n+                                     Register result,\n+                                     u1 super_klass_slot,\n+                                     bool stub_is_near = false);\n+\n+  void verify_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register result);\n+\n+  void lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                               Register r_array_base,\n+                                               Register r_array_index,\n+                                               Register r_bitmap,\n+                                               Register temp1,\n+                                               Register result);\n+\n@@ -1276,0 +1301,1 @@\n+  \/\/ Clobbers: rscratch1\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1316,1 +1316,0 @@\n-\n@@ -1319,0 +1318,41 @@\n+\n+  if (CheckJNICalls) {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n+    __ cbzw(rscratch1, L_skip_vthread_code);\n+\n+    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n+    \/\/ it failed to release a JNI monitor. So we issue the same log message\n+    \/\/ that JavaThread::exit does.\n+    __ ldr(rscratch1, Address(rthread, JavaThread::jni_monitor_count_offset()));\n+    __ cbz(rscratch1, L_skip_vthread_code);\n+\n+    \/\/ Save return value potentially containing the exception oop in callee-saved R19.\n+    __ mov(r19, r0);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n+    \/\/ Restore potential return value.\n+    __ mov(r0, r19);\n+\n+    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n+    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n+    \/\/ the parent held count (which has to be zero).\n+    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n+    __ cbzw(rscratch1, L_skip_vthread_code);\n+\n+    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n+    \/\/ needed for assertion checking.\n+    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#endif\n+\n@@ -1386,2 +1426,1 @@\n-    CodeBuffer* cbuf = masm->code_section()->outer();\n-    address stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, tr_call);\n+    address stub = CompiledDirectCall::emit_to_interp_stub(masm, tr_call);\n@@ -1451,2 +1490,1 @@\n-  CodeBuffer* cbuf = masm->code_section()->outer();\n-  address stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, tr_call);\n+  address stub = CompiledDirectCall::emit_to_interp_stub(masm, tr_call);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2022, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -6797,0 +6797,46 @@\n+  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = r0,\n+      r_array_base   = r1,\n+      r_array_length = r2,\n+      r_array_index  = r3,\n+      r_sub_klass    = r4,\n+      r_bitmap       = rscratch2,\n+      result         = r5;\n+    const FloatRegister\n+      vtemp          = v0;\n+\n+    Label L_success;\n+    __ enter();\n+    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                     r_array_base, r_array_length, r_array_index,\n+                                     vtemp, result, super_klass_index,\n+                                     \/*stub_is_near*\/true);\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n+  \/\/ Slow path implementation for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_slow_path_stub() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = r0,        \/\/ argument\n+      r_array_base   = r1,        \/\/ argument\n+      temp1          = r2,        \/\/ temp\n+      r_array_index  = r3,        \/\/ argument\n+      r_bitmap       = rscratch2, \/\/ argument\n+      result         = r5;        \/\/ argument\n+\n+    __ lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index, r_bitmap, temp1, result);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -8583,0 +8629,10 @@\n+    if (UseSecondarySupersTable) {\n+      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+      if (! InlineSecondarySupersTest) {\n+        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n+            = generate_lookup_secondary_supers_table_stub(slot);\n+        }\n+      }\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1737,0 +1737,1 @@\n+  void btq(Register src, int imm8);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-  return (cb()->as_nmethod()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+  return (cb()->as_nmethod()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5029,0 +5029,334 @@\n+#ifdef _LP64\n+\n+\/\/ population_count variant for running without the POPCNT\n+\/\/ instruction, which was introduced with SSE4.2 in 2008.\n+void MacroAssembler::population_count(Register dst, Register src,\n+                                      Register scratch1, Register scratch2) {\n+  assert_different_registers(src, scratch1, scratch2);\n+  if (UsePopCountInstruction) {\n+    Assembler::popcntq(dst, src);\n+  } else {\n+    assert_different_registers(src, scratch1, scratch2);\n+    assert_different_registers(dst, scratch1, scratch2);\n+    Label loop, done;\n+\n+    mov(scratch1, src);\n+    \/\/ dst = 0;\n+    \/\/ while(scratch1 != 0) {\n+    \/\/   dst++;\n+    \/\/   scratch1 &= (scratch1 - 1);\n+    \/\/ }\n+    xorl(dst, dst);\n+    testq(scratch1, scratch1);\n+    jccb(Assembler::equal, done);\n+    {\n+      bind(loop);\n+      incq(dst);\n+      movq(scratch2, scratch1);\n+      decq(scratch2);\n+      andq(scratch1, scratch2);\n+      jccb(Assembler::notEqual, loop);\n+    }\n+    bind(done);\n+  }\n+}\n+\n+\/\/ Ensure that the inline code and the stub are using the same registers.\n+#define LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS                      \\\n+do {                                                                 \\\n+  assert(r_super_klass  == rax, \"mismatch\");                         \\\n+  assert(r_array_base   == rbx, \"mismatch\");                         \\\n+  assert(r_array_length == rcx, \"mismatch\");                         \\\n+  assert(r_array_index  == rdx, \"mismatch\");                         \\\n+  assert(r_sub_klass    == rsi || r_sub_klass == noreg, \"mismatch\"); \\\n+  assert(r_bitmap       == r11 || r_bitmap    == noreg, \"mismatch\"); \\\n+  assert(result         == rdi || result      == noreg, \"mismatch\"); \\\n+} while(0)\n+\n+void MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   Register temp4,\n+                                                   Register result,\n+                                                   u1 super_klass_slot) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, temp3, temp4, result);\n+\n+  Label L_fallthrough, L_success, L_failure;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_index  = temp1,\n+    r_array_length = temp2,\n+    r_array_base   = temp3,\n+    r_bitmap       = temp4;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  xorq(result, result); \/\/ = 0\n+\n+  movq(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  movq(r_array_index, r_bitmap);\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  u1 bit = super_klass_slot;\n+  {\n+    \/\/ NB: If the count in a x86 shift instruction is 0, the flags are\n+    \/\/ not affected, so we do a testq instead.\n+    int shift_count = Klass::SECONDARY_SUPERS_TABLE_MASK - bit;\n+    if (shift_count != 0) {\n+      salq(r_array_index, shift_count);\n+    } else {\n+      testq(r_array_index, r_array_index);\n+    }\n+  }\n+  \/\/ We test the MSB of r_array_index, i.e. its sign bit\n+  jcc(Assembler::positive, L_failure);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    population_count(r_array_index, r_array_index, temp2, temp3);\n+  } else {\n+    movl(r_array_index, 1);\n+  }\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+\n+  \/\/ We will consult the secondary-super array.\n+  movptr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ We're asserting that the first word in an Array<Klass*> is the\n+  \/\/ length, and the second word is the first word of the data. If\n+  \/\/ that ever changes, r_array_base will have to be adjusted here.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  cmpq(r_super_klass, Address(r_array_base, r_array_index, Address::times_8));\n+  jccb(Assembler::equal, L_success);\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  btq(r_bitmap, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+  jccb(Assembler::carryClear, L_failure);\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 1.\n+  if (bit != 0) {\n+    rorq(r_bitmap, bit);\n+  }\n+\n+  \/\/ Calls into the stub generated by lookup_secondary_supers_table_slow_path.\n+  \/\/ Arguments: r_super_klass, r_array_base, r_array_index, r_bitmap.\n+  \/\/ Kills: r_array_length.\n+  \/\/ Returns: result.\n+  call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_slow_path_stub()));\n+  \/\/ Result (0\/1) is in rdi\n+  jmpb(L_fallthrough);\n+\n+  bind(L_failure);\n+  incq(result); \/\/ 0 => 1\n+\n+  bind(L_success);\n+  \/\/ result = 0;\n+\n+  bind(L_fallthrough);\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                  temp1, temp2, temp3);\n+  }\n+}\n+\n+void MacroAssembler::repne_scanq(Register addr, Register value, Register count, Register limit,\n+                                 Label* L_success, Label* L_failure) {\n+  Label L_loop, L_fallthrough;\n+  {\n+    int label_nulls = 0;\n+    if (L_success == nullptr) { L_success = &L_fallthrough; label_nulls++; }\n+    if (L_failure == nullptr) { L_failure = &L_fallthrough; label_nulls++; }\n+    assert(label_nulls <= 1, \"at most one null in the batch\");\n+  }\n+  bind(L_loop);\n+  cmpq(value, Address(addr, count, Address::times_8));\n+  jcc(Assembler::equal, *L_success);\n+  addl(count, 1);\n+  cmpl(count, limit);\n+  jcc(Assembler::less, L_loop);\n+\n+  if (&L_fallthrough != L_failure) {\n+    jmp(*L_failure);\n+  }\n+  bind(L_fallthrough);\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                                             Register r_array_base,\n+                                                             Register r_array_index,\n+                                                             Register r_bitmap,\n+                                                             Register temp1,\n+                                                             Register temp2,\n+                                                             Label* L_success,\n+                                                             Label* L_failure) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, temp1, temp2);\n+\n+  const Register\n+    r_array_length = temp1,\n+    r_sub_klass    = noreg,\n+    result         = noreg;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  Label L_fallthrough;\n+  int label_nulls = 0;\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n+\n+  \/\/ Load the array length.\n+  movl(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  \/\/ NB! Effectively increments current slot index by 1.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"\");\n+  addptr(r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ Linear probe\n+  Label L_huge;\n+\n+  \/\/ The bitmap is full to bursting.\n+  \/\/ Implicit invariant: BITMAP_FULL implies (length > 0)\n+  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"\");\n+  cmpq(r_bitmap, (int32_t)-1); \/\/ sign-extends immediate to 64-bit value\n+  jcc(Assembler::equal, L_huge);\n+\n+  \/\/ NB! Our caller has checked bits 0 and 1 in the bitmap. The\n+  \/\/ current slot (at secondary_supers[r_array_index]) has not yet\n+  \/\/ been inspected, and r_array_index may be out of bounds if we\n+  \/\/ wrapped around the end of the array.\n+\n+  { \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n+    \/\/ eventually terminates.\n+\n+    xorl(temp2, temp2); \/\/ = 0;\n+\n+    Label L_again;\n+    bind(L_again);\n+\n+    \/\/ Check for array wraparound.\n+    cmpl(r_array_index, r_array_length);\n+    cmovl(Assembler::greaterEqual, r_array_index, temp2);\n+\n+    cmpq(r_super_klass, Address(r_array_base, r_array_index, Address::times_8));\n+    jcc(Assembler::equal, *L_success);\n+\n+    \/\/ If the next bit in bitmap is zero, we're done.\n+    btq(r_bitmap, 2); \/\/ look-ahead check (Bit 2); Bits 0 and 1 are tested by now\n+    jcc(Assembler::carryClear, *L_failure);\n+\n+    rorq(r_bitmap, 1); \/\/ Bits 1\/2 => 0\/1\n+    addl(r_array_index, 1);\n+\n+    jmp(L_again);\n+  }\n+\n+  { \/\/ Degenerate case: more than 64 secondary supers.\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+    bind(L_huge);\n+    xorl(r_array_index, r_array_index); \/\/ = 0\n+    repne_scanq(r_array_base, r_super_klass, r_array_index, r_array_length,\n+                L_success,\n+                (&L_fallthrough != L_failure ? L_failure : nullptr));\n+\n+    bind(L_fallthrough);\n+  }\n+}\n+\n+struct VerifyHelperArguments {\n+  Klass* _super;\n+  Klass* _sub;\n+  intptr_t _linear_result;\n+  intptr_t _table_result;\n+};\n+\n+static void verify_secondary_supers_table_helper(const char* msg, VerifyHelperArguments* args) {\n+  Klass::on_secondary_supers_verification_failure(args->_super,\n+                                                  args->_sub,\n+                                                  args->_linear_result,\n+                                                  args->_table_result,\n+                                                  msg);\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register result,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3) {\n+  const Register\n+      r_array_index  = temp1,\n+      r_array_length = temp2,\n+      r_array_base   = temp3,\n+      r_bitmap       = noreg;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  BLOCK_COMMENT(\"verify_secondary_supers_table {\");\n+\n+  Label L_success, L_failure, L_check, L_done;\n+\n+  movptr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+  movl(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  addptr(r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  testl(r_array_length, r_array_length); \/\/ array_length == 0?\n+  jcc(Assembler::zero, L_failure);\n+\n+  movl(r_array_index, 0);\n+  repne_scanq(r_array_base, r_super_klass, r_array_index, r_array_length, &L_success);\n+  \/\/ fall through to L_failure\n+\n+  const Register linear_result = r_array_index; \/\/ reuse temp1\n+\n+  bind(L_failure); \/\/ not present\n+  movl(linear_result, 1);\n+  jmp(L_check);\n+\n+  bind(L_success); \/\/ present\n+  movl(linear_result, 0);\n+\n+  bind(L_check);\n+  cmpl(linear_result, result);\n+  jcc(Assembler::equal, L_done);\n+\n+  { \/\/ To avoid calling convention issues, build a record on the stack\n+    \/\/ and pass the pointer to that instead.\n+    push(result);\n+    push(linear_result);\n+    push(r_sub_klass);\n+    push(r_super_klass);\n+    movptr(c_rarg1, rsp);\n+    movptr(c_rarg0, (uintptr_t) \"mismatch\");\n+    call(RuntimeAddress(CAST_FROM_FN_PTR(address, verify_secondary_supers_table_helper)));\n+    should_not_reach_here();\n+  }\n+  bind(L_done);\n+\n+  BLOCK_COMMENT(\"} verify_secondary_supers_table\");\n+}\n+\n+#undef LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS\n+\n+#endif \/\/ LP64\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":334,"deletions":0,"binary":false,"changes":334,"status":"modified"},{"patch":"@@ -655,0 +655,2 @@\n+  void population_count(Register dst, Register src, Register scratch1, Register scratch2);\n+\n@@ -705,0 +707,7 @@\n+  void hashed_check_klass_subtype_slow_path(Register sub_klass,\n+                                     Register super_klass,\n+                                     Register temp_reg,\n+                                     Register temp2_reg,\n+                                     Label* L_success,\n+                                     Label* L_failure,\n+                                     bool set_cond_codes = false);\n@@ -706,1 +715,32 @@\n-  \/\/ Simplified, combined version, good for typical uses.\n+  \/\/ As above, but with a constant super_klass.\n+  \/\/ The result is in Register result, not the condition codes.\n+  void lookup_secondary_supers_table(Register sub_klass,\n+                                     Register super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     Register temp4,\n+                                     Register result,\n+                                     u1 super_klass_slot);\n+\n+  void lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                               Register r_array_base,\n+                                               Register r_array_index,\n+                                               Register r_bitmap,\n+                                               Register temp1,\n+                                               Register temp2,\n+                                               Label* L_success,\n+                                               Label* L_failure = nullptr);\n+\n+  void verify_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register expected,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3);\n+\n+  void repne_scanq(Register addr, Register value, Register count, Register limit,\n+                   Label* L_success,\n+                   Label* L_failure = nullptr);\n+\n+    \/\/ Simplified, combined version, good for typical uses.\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1627,1 +1627,0 @@\n-\n@@ -1630,0 +1629,40 @@\n+\n+  if (CheckJNICalls) {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n+    __ jcc(Assembler::equal, L_skip_vthread_code);\n+\n+    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n+    \/\/ it failed to release a JNI monitor. So we issue the same log message\n+    \/\/ that JavaThread::exit does.\n+    __ cmpptr(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n+    __ jcc(Assembler::equal, L_skip_vthread_code);\n+\n+    \/\/ rax may hold an exception oop, save it before the call\n+    __ push(rax);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n+    __ pop(rax);\n+\n+    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n+    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n+    \/\/ the parent held count (which has to be zero).\n+    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n+    __ jcc(Assembler::equal, L_skip_vthread_code);\n+\n+    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n+    \/\/ needed for assertion checking.\n+    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#endif\n+\n@@ -1714,2 +1753,1 @@\n-    CodeBuffer* cbuf = masm->code_section()->outer();\n-    address stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, __ pc());\n+    address stub = CompiledDirectCall::emit_to_interp_stub(masm, __ pc());\n@@ -1751,2 +1789,1 @@\n-  CodeBuffer* cbuf = masm->code_section()->outer();\n-  address stub = CompiledDirectCall::emit_to_interp_stub(*cbuf, __ pc());\n+  address stub = CompiledDirectCall::emit_to_interp_stub(masm, __ pc());\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -4013,0 +4013,48 @@\n+address StubGenerator::generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n+  StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+  address start = __ pc();\n+\n+  const Register\n+      r_super_klass = rax,\n+      r_sub_klass   = rsi,\n+      result        = rdi;\n+\n+  __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                   rdx, rcx, rbx, r11, \/\/ temps\n+                                   result,\n+                                   super_klass_index);\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\/\/ Slow path implementation for UseSecondarySupersTable.\n+address StubGenerator::generate_lookup_secondary_supers_table_slow_path_stub() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+  address start = __ pc();\n+\n+  const Register\n+      r_super_klass  = rax,\n+      r_array_base   = rbx,\n+      r_array_index  = rdx,\n+      r_sub_klass    = rsi,\n+      r_bitmap       = r11,\n+      result         = rdi;\n+\n+  Label L_success;\n+  __ lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index, r_bitmap,\n+                                             rcx, rdi, \/\/ temps\n+                                             &L_success);\n+  \/\/ bind(L_failure);\n+  __ movl(result, 1);\n+  __ ret(0);\n+\n+  __ bind(L_success);\n+  __ movl(result, 0);\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n@@ -4452,0 +4500,8 @@\n+  if (UseSecondarySupersTable) {\n+    StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+    if (! InlineSecondarySupersTest) {\n+      for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+        StubRoutines::_lookup_secondary_supers_table_stubs[slot] = generate_lookup_secondary_supers_table_stub(slot);\n+      }\n+    }\n+  }\n@@ -4545,0 +4601,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -611,0 +611,6 @@\n+  \/\/ Specialized stub implementations for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index);\n+\n+  \/\/ Slow path implementation for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_slow_path_stub();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -731,1 +731,2 @@\n-    arraycopy_avx3_large(to, from, temp1, temp2, temp3, temp4, count, xmm1, xmm2, xmm3, xmm4, shift);\n+      UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, false, ucme_exit_pc);\n+      arraycopy_avx3_large(to, from, temp1, temp2, temp3, temp4, count, xmm1, xmm2, xmm3, xmm4, shift);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1190,2 +1190,2 @@\n-  static int emit_exception_handler(CodeBuffer &cbuf);\n-  static int emit_deopt_handler(CodeBuffer& cbuf);\n+  static int emit_exception_handler(C2_MacroAssembler *masm);\n+  static int emit_deopt_handler(C2_MacroAssembler* masm);\n@@ -1309,1 +1309,1 @@\n-int HandlerImpl::emit_exception_handler(CodeBuffer& cbuf) {\n+int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n@@ -1313,1 +1313,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -1327,1 +1326,1 @@\n-int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf) {\n+int HandlerImpl::emit_deopt_handler(C2_MacroAssembler* masm) {\n@@ -1331,1 +1330,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -2526,1 +2524,1 @@\n-static void vec_mov_helper(CodeBuffer *cbuf, int src_lo, int dst_lo,\n+static void vec_mov_helper(C2_MacroAssembler *masm, int src_lo, int dst_lo,\n@@ -2532,2 +2530,1 @@\n-  if (cbuf) {\n-    C2_MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -2584,1 +2581,1 @@\n-void vec_spill_helper(CodeBuffer *cbuf, bool is_load,\n+void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n@@ -2586,2 +2583,1 @@\n-  if (cbuf) {\n-    C2_MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -2745,2 +2741,1 @@\n-  void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc*) const {\n-    C2_MacroAssembler _masm(&cbuf);\n+  void MachNopNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc*) const {\n@@ -2760,2 +2755,1 @@\n-  void MachBreakpointNode::emit(CodeBuffer &cbuf, PhaseRegAlloc* ra_) const {\n-    C2_MacroAssembler _masm(&cbuf);\n+  void MachBreakpointNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc* ra_) const {\n@@ -2774,1 +2768,0 @@\n-    C2_MacroAssembler _masm(&cbuf);\n@@ -2786,1 +2779,0 @@\n-      C2_MacroAssembler _masm(&cbuf);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -340,1 +340,1 @@\n-void emit_rm(CodeBuffer &cbuf, int f1, int f2, int f3) {\n+void emit_rm(C2_MacroAssembler *masm, int f1, int f2, int f3) {\n@@ -342,1 +342,1 @@\n-  cbuf.insts()->emit_int8(c);\n+  __ emit_int8(c);\n@@ -346,1 +346,1 @@\n-void emit_cc(CodeBuffer &cbuf, int f1, int f2) {\n+void emit_cc(C2_MacroAssembler *masm, int f1, int f2) {\n@@ -348,1 +348,1 @@\n-  cbuf.insts()->emit_int8(c);\n+  __ emit_int8(c);\n@@ -352,2 +352,2 @@\n-void emit_opcode(CodeBuffer &cbuf, int code) {\n-  cbuf.insts()->emit_int8((unsigned char) code);\n+void emit_opcode(C2_MacroAssembler *masm, int code) {\n+  __ emit_int8((unsigned char) code);\n@@ -357,3 +357,3 @@\n-void emit_opcode(CodeBuffer &cbuf, int code, relocInfo::relocType reloc, int offset = 0) {\n-  cbuf.relocate(cbuf.insts_mark() + offset, reloc);\n-  emit_opcode(cbuf, code);\n+void emit_opcode(C2_MacroAssembler *masm, int code, relocInfo::relocType reloc, int offset = 0) {\n+  __ relocate(__ inst_mark() + offset, reloc);\n+  emit_opcode(masm, code);\n@@ -363,2 +363,2 @@\n-void emit_d8(CodeBuffer &cbuf, int d8) {\n-  cbuf.insts()->emit_int8((unsigned char) d8);\n+void emit_d8(C2_MacroAssembler *masm, int d8) {\n+  __ emit_int8((unsigned char) d8);\n@@ -368,2 +368,2 @@\n-void emit_d16(CodeBuffer &cbuf, int d16) {\n-  cbuf.insts()->emit_int16(d16);\n+void emit_d16(C2_MacroAssembler *masm, int d16) {\n+  __ emit_int16(d16);\n@@ -373,2 +373,2 @@\n-void emit_d32(CodeBuffer &cbuf, int d32) {\n-  cbuf.insts()->emit_int32(d32);\n+void emit_d32(C2_MacroAssembler *masm, int d32) {\n+  __ emit_int32(d32);\n@@ -378,1 +378,1 @@\n-void emit_d32_reloc(CodeBuffer &cbuf, int d32, relocInfo::relocType reloc,\n+void emit_d32_reloc(C2_MacroAssembler *masm, int d32, relocInfo::relocType reloc,\n@@ -380,2 +380,2 @@\n-  cbuf.relocate(cbuf.insts_mark(), reloc, format);\n-  cbuf.insts()->emit_int32(d32);\n+  __ relocate(__ inst_mark(), reloc, format);\n+  __ emit_int32(d32);\n@@ -385,1 +385,1 @@\n-void emit_d32_reloc(CodeBuffer &cbuf, int d32, RelocationHolder const& rspec,\n+void emit_d32_reloc(C2_MacroAssembler *masm, int d32, RelocationHolder const& rspec,\n@@ -392,2 +392,2 @@\n-  cbuf.relocate(cbuf.insts_mark(), rspec, format);\n-  cbuf.insts()->emit_int32(d32);\n+  __ relocate(__ inst_mark(), rspec, format);\n+  __ emit_int32(d32);\n@@ -397,2 +397,2 @@\n-void store_to_stackslot(CodeBuffer &cbuf, int opcode, int rm_field, int disp) {\n-  emit_opcode( cbuf, opcode );               \/\/ (e.g., FILD   [ESP+src])\n+void store_to_stackslot(C2_MacroAssembler *masm, int opcode, int rm_field, int disp) {\n+  emit_opcode( masm, opcode );               \/\/ (e.g., FILD   [ESP+src])\n@@ -400,3 +400,3 @@\n-    emit_rm( cbuf, 0x01, rm_field, ESP_enc );  \/\/ R\/M byte\n-    emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    \/\/ SIB byte\n-    emit_d8 (cbuf, disp);     \/\/ Displacement  \/\/ R\/M byte\n+    emit_rm( masm, 0x01, rm_field, ESP_enc );  \/\/ R\/M byte\n+    emit_rm( masm, 0x00, ESP_enc, ESP_enc);    \/\/ SIB byte\n+    emit_d8 (masm, disp);     \/\/ Displacement  \/\/ R\/M byte\n@@ -404,3 +404,3 @@\n-    emit_rm( cbuf, 0x02, rm_field, ESP_enc );  \/\/ R\/M byte\n-    emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    \/\/ SIB byte\n-    emit_d32(cbuf, disp);     \/\/ Displacement  \/\/ R\/M byte\n+    emit_rm( masm, 0x02, rm_field, ESP_enc );  \/\/ R\/M byte\n+    emit_rm( masm, 0x00, ESP_enc, ESP_enc);    \/\/ SIB byte\n+    emit_d32(masm, disp);     \/\/ Displacement  \/\/ R\/M byte\n@@ -411,1 +411,1 @@\n-void encode_RegMem( CodeBuffer &cbuf, int reg_encoding, int base, int index, int scale, int displace, relocInfo::relocType disp_reloc ) {\n+void encode_RegMem( C2_MacroAssembler *masm, int reg_encoding, int base, int index, int scale, int displace, relocInfo::relocType disp_reloc ) {\n@@ -417,1 +417,1 @@\n-      emit_rm(cbuf, 0x0, reg_encoding, base);\n+      emit_rm(masm, 0x0, reg_encoding, base);\n@@ -422,2 +422,2 @@\n-        emit_rm(cbuf, 0x1, reg_encoding, base);\n-        emit_d8(cbuf, displace);\n+        emit_rm(masm, 0x1, reg_encoding, base);\n+        emit_d8(masm, displace);\n@@ -427,1 +427,1 @@\n-          emit_rm(cbuf, 0x0, reg_encoding, 0x5);\n+          emit_rm(masm, 0x0, reg_encoding, 0x5);\n@@ -430,1 +430,1 @@\n-            emit_d32_reloc(cbuf, displace, disp_reloc, 1);\n+            emit_d32_reloc(masm, displace, disp_reloc, 1);\n@@ -432,1 +432,1 @@\n-            emit_d32      (cbuf, displace);\n+            emit_d32      (masm, displace);\n@@ -436,1 +436,1 @@\n-          emit_rm(cbuf, 0x2, reg_encoding, base);\n+          emit_rm(masm, 0x2, reg_encoding, base);\n@@ -438,1 +438,1 @@\n-            emit_d32_reloc(cbuf, displace, disp_reloc, 1);\n+            emit_d32_reloc(masm, displace, disp_reloc, 1);\n@@ -440,1 +440,1 @@\n-            emit_d32      (cbuf, displace);\n+            emit_d32      (masm, displace);\n@@ -449,2 +449,2 @@\n-      emit_rm(cbuf, 0x0, reg_encoding, 0x4);\n-      emit_rm(cbuf, scale, index, base);\n+      emit_rm(masm, 0x0, reg_encoding, 0x4);\n+      emit_rm(masm, scale, index, base);\n@@ -455,3 +455,3 @@\n-        emit_rm(cbuf, 0x1, reg_encoding, 0x4);\n-        emit_rm(cbuf, scale, index, base);\n-        emit_d8(cbuf, displace);\n+        emit_rm(masm, 0x1, reg_encoding, 0x4);\n+        emit_rm(masm, scale, index, base);\n+        emit_d8(masm, displace);\n@@ -461,2 +461,2 @@\n-          emit_rm(cbuf, 0x2, reg_encoding, 0x4);\n-          emit_rm(cbuf, scale, index, 0x04);\n+          emit_rm(masm, 0x2, reg_encoding, 0x4);\n+          emit_rm(masm, scale, index, 0x04);\n@@ -464,2 +464,2 @@\n-          emit_rm(cbuf, 0x2, reg_encoding, 0x4);\n-          emit_rm(cbuf, scale, index, base);\n+          emit_rm(masm, 0x2, reg_encoding, 0x4);\n+          emit_rm(masm, scale, index, base);\n@@ -468,1 +468,1 @@\n-          emit_d32_reloc(cbuf, displace, disp_reloc, 1);\n+          emit_d32_reloc(masm, displace, disp_reloc, 1);\n@@ -470,1 +470,1 @@\n-          emit_d32      (cbuf, displace);\n+          emit_d32      (masm, displace);\n@@ -478,1 +478,1 @@\n-void encode_Copy( CodeBuffer &cbuf, int dst_encoding, int src_encoding ) {\n+void encode_Copy( C2_MacroAssembler *masm, int dst_encoding, int src_encoding ) {\n@@ -482,2 +482,2 @@\n-    emit_opcode( cbuf, 0x8B );\n-    emit_rm(cbuf, 0x3, dst_encoding, src_encoding );\n+    emit_opcode( masm, 0x8B );\n+    emit_rm(masm, 0x3, dst_encoding, src_encoding );\n@@ -487,1 +487,1 @@\n-void emit_cmpfp_fixup(MacroAssembler& _masm) {\n+void emit_cmpfp_fixup(MacroAssembler* masm) {\n@@ -507,1 +507,1 @@\n-static void emit_cmpfp3(MacroAssembler& _masm, Register dst) {\n+static void emit_cmpfp3(MacroAssembler* masm, Register dst) {\n@@ -530,1 +530,1 @@\n-void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {\n+void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n@@ -610,1 +610,1 @@\n-void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -612,1 +612,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -616,1 +615,1 @@\n-  C->output()->set_frame_complete(cbuf.insts_size());\n+  C->output()->set_frame_complete(__ offset());\n@@ -664,1 +663,1 @@\n-void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachEpilogNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -666,1 +665,0 @@\n-  MacroAssembler _masm(&cbuf);\n@@ -671,1 +669,1 @@\n-    _masm.vzeroupper();\n+    __ vzeroupper();\n@@ -675,1 +673,1 @@\n-    _masm.fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n+    __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n@@ -686,3 +684,3 @@\n-    emit_opcode(cbuf, 0x81); \/\/ add  SP, #framesize\n-    emit_rm(cbuf, 0x3, 0x00, ESP_enc);\n-    emit_d32(cbuf, framesize);\n+    emit_opcode(masm, 0x81); \/\/ add  SP, #framesize\n+    emit_rm(masm, 0x3, 0x00, ESP_enc);\n+    emit_d32(masm, framesize);\n@@ -690,3 +688,3 @@\n-    emit_opcode(cbuf, 0x83); \/\/ add  SP, #framesize\n-    emit_rm(cbuf, 0x3, 0x00, ESP_enc);\n-    emit_d8(cbuf, framesize);\n+    emit_opcode(masm, 0x83); \/\/ add  SP, #framesize\n+    emit_rm(masm, 0x3, 0x00, ESP_enc);\n+    emit_d8(masm, framesize);\n@@ -695,1 +693,1 @@\n-  emit_opcode(cbuf, 0x58 | EBP_enc);\n+  emit_opcode(masm, 0x58 | EBP_enc);\n@@ -703,1 +701,0 @@\n-    MacroAssembler masm(&cbuf);\n@@ -712,0 +709,1 @@\n+    __ set_inst_mark();\n@@ -713,0 +711,1 @@\n+    __ clear_inst_mark();\n@@ -749,1 +748,1 @@\n-static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,\n+static int impl_helper( C2_MacroAssembler *masm, bool do_size, bool is_load, int offset, int reg,\n@@ -751,3 +750,5 @@\n-  if( cbuf ) {\n-    emit_opcode  (*cbuf, opcode );\n-    encode_RegMem(*cbuf, Matcher::_regEncode[reg], ESP_enc, 0x4, 0, offset, relocInfo::none);\n+  if( masm ) {\n+    masm->set_inst_mark();\n+    emit_opcode  (masm, opcode );\n+    encode_RegMem(masm, Matcher::_regEncode[reg], ESP_enc, 0x4, 0, offset, relocInfo::none);\n+    masm->clear_inst_mark();\n@@ -770,1 +771,1 @@\n-static int impl_x_helper( CodeBuffer *cbuf, bool do_size, bool is_load,\n+static int impl_x_helper( C2_MacroAssembler *masm, bool do_size, bool is_load,\n@@ -778,2 +779,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -782,1 +782,1 @@\n-    _masm.set_managed();\n+    __ set_managed();\n@@ -829,1 +829,1 @@\n-static int impl_movx_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,\n+static int impl_movx_helper( C2_MacroAssembler *masm, bool do_size, int src_lo, int dst_lo,\n@@ -831,2 +831,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -834,1 +833,1 @@\n-    _masm.set_managed();\n+    __ set_managed();\n@@ -868,1 +867,1 @@\n-static int impl_movgpr2x_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,\n+static int impl_movgpr2x_helper( C2_MacroAssembler *masm, bool do_size, int src_lo, int dst_lo,\n@@ -871,2 +870,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -874,1 +872,1 @@\n-    _masm.set_managed();\n+    __ set_managed();\n@@ -886,1 +884,1 @@\n-static int impl_movx2gpr_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,\n+static int impl_movx2gpr_helper( C2_MacroAssembler *masm, bool do_size, int src_lo, int dst_lo,\n@@ -889,2 +887,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -892,1 +889,1 @@\n-    _masm.set_managed();\n+    __ set_managed();\n@@ -903,4 +900,4 @@\n-static int impl_mov_helper( CodeBuffer *cbuf, bool do_size, int src, int dst, int size, outputStream* st ) {\n-  if( cbuf ) {\n-    emit_opcode(*cbuf, 0x8B );\n-    emit_rm    (*cbuf, 0x3, Matcher::_regEncode[dst], Matcher::_regEncode[src] );\n+static int impl_mov_helper( C2_MacroAssembler *masm, bool do_size, int src, int dst, int size, outputStream* st ) {\n+  if( masm ) {\n+    emit_opcode(masm, 0x8B );\n+    emit_rm    (masm, 0x3, Matcher::_regEncode[dst], Matcher::_regEncode[src] );\n@@ -916,1 +913,1 @@\n-static int impl_fp_store_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int src_hi, int dst_lo, int dst_hi,\n+static int impl_fp_store_helper( C2_MacroAssembler *masm, bool do_size, int src_lo, int src_hi, int dst_lo, int dst_hi,\n@@ -919,3 +916,3 @@\n-    if( cbuf ) {\n-      emit_opcode( *cbuf, 0xD9 );  \/\/ FLD (i.e., push it)\n-      emit_d8( *cbuf, 0xC0-1+Matcher::_regEncode[src_lo] );\n+    if( masm ) {\n+      emit_opcode( masm, 0xD9 );  \/\/ FLD (i.e., push it)\n+      emit_d8( masm, 0xC0-1+Matcher::_regEncode[src_lo] );\n@@ -943,1 +940,1 @@\n-  return impl_helper(cbuf,do_size,false,offset,st_op,op,op_str,size, st);\n+  return impl_helper(masm,do_size,false,offset,st_op,op,op_str,size, st);\n@@ -947,1 +944,1 @@\n-static void vec_mov_helper(CodeBuffer *cbuf, int src_lo, int dst_lo,\n+static void vec_mov_helper(C2_MacroAssembler *masm, int src_lo, int dst_lo,\n@@ -950,1 +947,1 @@\n-void vec_spill_helper(CodeBuffer *cbuf, bool is_load,\n+void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n@@ -953,1 +950,1 @@\n-static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,\n+static void vec_stack_to_stack_helper(C2_MacroAssembler *masm, int src_offset,\n@@ -955,2 +952,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -1032,1 +1028,1 @@\n-uint MachSpillCopyNode::implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const {\n+uint MachSpillCopyNode::implementation( C2_MacroAssembler *masm, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const {\n@@ -1061,1 +1057,1 @@\n-      vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);\n+      vec_stack_to_stack_helper(masm, src_offset, dst_offset, ireg, st);\n@@ -1063,1 +1059,1 @@\n-      vec_mov_helper(cbuf, src_first, dst_first, src_second, dst_second, ireg, st);\n+      vec_mov_helper(masm, src_first, dst_first, src_second, dst_second, ireg, st);\n@@ -1066,1 +1062,1 @@\n-      vec_spill_helper(cbuf, false, stack_offset, src_first, ireg, st);\n+      vec_spill_helper(masm, false, stack_offset, src_first, ireg, st);\n@@ -1069,1 +1065,1 @@\n-      vec_spill_helper(cbuf, true,  stack_offset, dst_first, ireg, st);\n+      vec_spill_helper(masm, true,  stack_offset, dst_first, ireg, st);\n@@ -1081,2 +1077,2 @@\n-      size = impl_helper(cbuf,do_size,true ,ra_->reg2offset(src_second),ESI_num,0xFF,\"PUSH  \",size, st);\n-      size = impl_helper(cbuf,do_size,false,ra_->reg2offset(dst_second),EAX_num,0x8F,\"POP   \",size, st);\n+      size = impl_helper(masm,do_size,true ,ra_->reg2offset(src_second),ESI_num,0xFF,\"PUSH  \",size, st);\n+      size = impl_helper(masm,do_size,false,ra_->reg2offset(dst_second),EAX_num,0x8F,\"POP   \",size, st);\n@@ -1086,2 +1082,2 @@\n-    size = impl_helper(cbuf,do_size,true ,ra_->reg2offset(src_first),ESI_num,0xFF,\"PUSH  \",size, st);\n-    size = impl_helper(cbuf,do_size,false,ra_->reg2offset(dst_first),EAX_num,0x8F,\"POP   \",size, st);\n+    size = impl_helper(masm,do_size,true ,ra_->reg2offset(src_first),ESI_num,0xFF,\"PUSH  \",size, st);\n+    size = impl_helper(masm,do_size,false,ra_->reg2offset(dst_first),EAX_num,0x8F,\"POP   \",size, st);\n@@ -1089,2 +1085,2 @@\n-      size = impl_helper(cbuf,do_size,true ,ra_->reg2offset(src_second),ESI_num,0xFF,\"PUSH  \",size, st);\n-      size = impl_helper(cbuf,do_size,false,ra_->reg2offset(dst_second),EAX_num,0x8F,\"POP   \",size, st);\n+      size = impl_helper(masm,do_size,true ,ra_->reg2offset(src_second),ESI_num,0xFF,\"PUSH  \",size, st);\n+      size = impl_helper(masm,do_size,false,ra_->reg2offset(dst_second),EAX_num,0x8F,\"POP   \",size, st);\n@@ -1098,1 +1094,1 @@\n-    size = impl_mov_helper(cbuf,do_size,src_first,dst_first,size, st);\n+    size = impl_mov_helper(masm,do_size,src_first,dst_first,size, st);\n@@ -1102,1 +1098,1 @@\n-    size = impl_helper(cbuf,do_size,false,ra_->reg2offset(dst_first),src_first,0x89,\"MOV \",size, st);\n+    size = impl_helper(masm,do_size,false,ra_->reg2offset(dst_first),src_first,0x89,\"MOV \",size, st);\n@@ -1106,1 +1102,1 @@\n-    size = impl_helper(cbuf,do_size,true ,ra_->reg2offset(src_first),dst_first,0x8B,\"MOV \",size, st);\n+    size = impl_helper(masm,do_size,true ,ra_->reg2offset(src_first),dst_first,0x8B,\"MOV \",size, st);\n@@ -1112,1 +1108,1 @@\n-    return impl_movgpr2x_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);\n+    return impl_movgpr2x_helper(masm,do_size,src_first,dst_first,src_second, dst_second, size, st);\n@@ -1119,1 +1115,1 @@\n-    if( cbuf ) {\n+    if( masm ) {\n@@ -1126,4 +1122,4 @@\n-        emit_opcode  (*cbuf, 0xD9 );           \/\/ FLD    ST(i)\n-        emit_d8      (*cbuf, 0xC0+Matcher::_regEncode[src_first]-1 );\n-        emit_opcode  (*cbuf, 0xDD );           \/\/ FSTP   ST(i)\n-        emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );\n+        emit_opcode  (masm, 0xD9 );           \/\/ FLD    ST(i)\n+        emit_d8      (masm, 0xC0+Matcher::_regEncode[src_first]-1 );\n+        emit_opcode  (masm, 0xDD );           \/\/ FSTP   ST(i)\n+        emit_d8      (masm, 0xD8+Matcher::_regEncode[dst_first] );\n@@ -1131,2 +1127,2 @@\n-        emit_opcode  (*cbuf, 0xDD );           \/\/ FST    ST(i)\n-        emit_d8      (*cbuf, 0xD0+Matcher::_regEncode[dst_first]-1 );\n+        emit_opcode  (masm, 0xDD );           \/\/ FST    ST(i)\n+        emit_d8      (masm, 0xD0+Matcher::_regEncode[dst_first]-1 );\n@@ -1146,1 +1142,1 @@\n-    return impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,ra_->reg2offset(dst_first),size, st);\n+    return impl_fp_store_helper(masm,do_size,src_first,src_second,dst_first,dst_second,ra_->reg2offset(dst_first),size, st);\n@@ -1162,5 +1158,7 @@\n-    if( cbuf ) {\n-      emit_opcode  (*cbuf, op );\n-      encode_RegMem(*cbuf, 0x0, ESP_enc, 0x4, 0, offset, relocInfo::none);\n-      emit_opcode  (*cbuf, 0xDD );           \/\/ FSTP   ST(i)\n-      emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );\n+    if( masm ) {\n+      masm->set_inst_mark();\n+      emit_opcode  (masm, op );\n+      encode_RegMem(masm, 0x0, ESP_enc, 0x4, 0, offset, relocInfo::none);\n+      emit_opcode  (masm, 0xDD );           \/\/ FSTP   ST(i)\n+      emit_d8      (masm, 0xD8+Matcher::_regEncode[dst_first] );\n+      masm->clear_inst_mark();\n@@ -1182,1 +1180,1 @@\n-    return impl_movx_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);\n+    return impl_movx_helper(masm,do_size,src_first,dst_first,src_second, dst_second, size, st);\n@@ -1189,1 +1187,1 @@\n-    return impl_movx2gpr_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);\n+    return impl_movx2gpr_helper(masm,do_size,src_first,dst_first,src_second, dst_second, size, st);\n@@ -1194,1 +1192,1 @@\n-    return impl_x_helper(cbuf,do_size,false,ra_->reg2offset(dst_first), src_first, src_second, size, st);\n+    return impl_x_helper(masm,do_size,false,ra_->reg2offset(dst_first), src_first, src_second, size, st);\n@@ -1199,1 +1197,1 @@\n-    return impl_x_helper(cbuf,do_size,true ,ra_->reg2offset(src_first),dst_first, dst_second, size, st);\n+    return impl_x_helper(masm,do_size,true ,ra_->reg2offset(src_first),dst_first, dst_second, size, st);\n@@ -1206,5 +1204,5 @@\n-    if( cbuf ) {\n-      emit_opcode(*cbuf,0x8D);  \/\/ LEA  ESP,[ESP-8]\n-      emit_rm(*cbuf, 0x1, ESP_enc, 0x04);\n-      emit_rm(*cbuf, 0x0, 0x04, ESP_enc);\n-      emit_d8(*cbuf,0xF8);\n+    if( masm ) {\n+      emit_opcode(masm,0x8D);  \/\/ LEA  ESP,[ESP-8]\n+      emit_rm(masm, 0x1, ESP_enc, 0x04);\n+      emit_rm(masm, 0x0, 0x04, ESP_enc);\n+      emit_d8(masm,0xF8);\n@@ -1219,1 +1217,1 @@\n-    size = impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,0,size, st);\n+    size = impl_fp_store_helper(masm,do_size,src_first,src_second,dst_first,dst_second,0,size, st);\n@@ -1222,1 +1220,1 @@\n-    size = impl_x_helper(cbuf,do_size,true ,0,dst_first, dst_second, size, st);\n+    size = impl_x_helper(masm,do_size,true ,0,dst_first, dst_second, size, st);\n@@ -1224,5 +1222,5 @@\n-    if( cbuf ) {\n-      emit_opcode(*cbuf,0x8D);  \/\/ LEA  ESP,[ESP+8]\n-      emit_rm(*cbuf, 0x1, ESP_enc, 0x04);\n-      emit_rm(*cbuf, 0x0, 0x04, ESP_enc);\n-      emit_d8(*cbuf,0x08);\n+    if( masm ) {\n+      emit_opcode(masm,0x8D);  \/\/ LEA  ESP,[ESP+8]\n+      emit_rm(masm, 0x1, ESP_enc, 0x04);\n+      emit_rm(masm, 0x0, 0x04, ESP_enc);\n+      emit_d8(masm,0x08);\n@@ -1244,2 +1242,1 @@\n-    if (cbuf != nullptr) {\n-      MacroAssembler _masm(cbuf);\n+    if (masm != nullptr) {\n@@ -1259,2 +1256,1 @@\n-    if (cbuf != nullptr) {\n-      MacroAssembler _masm(cbuf);\n+    if (masm != nullptr) {\n@@ -1283,2 +1279,1 @@\n-    if (cbuf != nullptr) {\n-      MacroAssembler _masm(cbuf);\n+    if (masm != nullptr) {\n@@ -1304,1 +1299,1 @@\n-    return impl_mov_helper(cbuf,do_size,src_second,dst_second,size, st);\n+    return impl_mov_helper(masm,do_size,src_second,dst_second,size, st);\n@@ -1308,1 +1303,1 @@\n-    return impl_helper(cbuf,do_size,false,ra_->reg2offset(dst_second),src_second,0x89,\"MOV \",size, st);\n+    return impl_helper(masm,do_size,false,ra_->reg2offset(dst_second),src_second,0x89,\"MOV \",size, st);\n@@ -1312,1 +1307,1 @@\n-    return impl_helper(cbuf,do_size,true ,ra_->reg2offset(src_second),dst_second,0x8B,\"MOV \",size, st);\n+    return impl_helper(masm,do_size,true ,ra_->reg2offset(src_second),dst_second,0x8B,\"MOV \",size, st);\n@@ -1324,2 +1319,2 @@\n-void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  implementation( &cbuf, ra_, false, nullptr );\n+void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  implementation( masm, ra_, false, nullptr );\n@@ -1342,1 +1337,1 @@\n-void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void BoxLockNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -1346,4 +1341,4 @@\n-    emit_opcode(cbuf, 0x8D);      \/\/ LEA  reg,[SP+offset]\n-    emit_rm(cbuf, 0x2, reg, 0x04);\n-    emit_rm(cbuf, 0x0, 0x04, ESP_enc);\n-    emit_d32(cbuf, offset);\n+    emit_opcode(masm, 0x8D);      \/\/ LEA  reg,[SP+offset]\n+    emit_rm(masm, 0x2, reg, 0x04);\n+    emit_rm(masm, 0x0, 0x04, ESP_enc);\n+    emit_d32(masm, offset);\n@@ -1352,4 +1347,4 @@\n-    emit_opcode(cbuf, 0x8D);      \/\/ LEA  reg,[SP+offset]\n-    emit_rm(cbuf, 0x1, reg, 0x04);\n-    emit_rm(cbuf, 0x0, 0x04, ESP_enc);\n-    emit_d8(cbuf, offset);\n+    emit_opcode(masm, 0x8D);      \/\/ LEA  reg,[SP+offset]\n+    emit_rm(masm, 0x1, reg, 0x04);\n+    emit_rm(masm, 0x0, 0x04, ESP_enc);\n+    emit_d8(masm, offset);\n@@ -1381,3 +1376,2 @@\n-void MachUEPNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  MacroAssembler masm(&cbuf);\n-  masm.ic_check(CodeEntryAlignment);\n+void MachUEPNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  __ ic_check(CodeEntryAlignment);\n@@ -1528,0 +1522,12 @@\n+  \/\/ Set instruction mark in MacroAssembler. This is used only in\n+  \/\/ instructions that emit bytes directly to the CodeBuffer wraped\n+  \/\/ in the MacroAssembler. Should go away once all \"instruct\" are\n+  \/\/ patched to emit bytes only using methods in MacroAssembler.\n+  enc_class SetInstMark %{\n+    __ set_inst_mark();\n+  %}\n+\n+  enc_class ClearInstMark %{\n+    __ clear_inst_mark();\n+  %}\n+\n@@ -1530,1 +1536,1 @@\n-    emit_opcode(cbuf, $primary);\n+    emit_opcode(masm, $primary);\n@@ -1535,1 +1541,1 @@\n-    emit_opcode(cbuf, $secondary);\n+    emit_opcode(masm, $secondary);\n@@ -1540,1 +1546,1 @@\n-    emit_opcode(cbuf, $d8$$constant);\n+    emit_opcode(masm, $d8$$constant);\n@@ -1544,1 +1550,1 @@\n-    emit_opcode(cbuf,0x66);\n+    emit_opcode(masm,0x66);\n@@ -1548,1 +1554,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -1552,2 +1558,2 @@\n-    emit_opcode(cbuf,$opcode$$constant);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_opcode(masm,$opcode$$constant);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -1557,2 +1563,2 @@\n-    emit_opcode( cbuf, 0xB8 + $dst$$reg ); \/\/ 0xB8+ rd   -- MOV r32  ,imm32\n-    emit_d32   ( cbuf, 0x0  );             \/\/                         imm32==0x0\n+    emit_opcode( masm, 0xB8 + $dst$$reg ); \/\/ 0xB8+ rd   -- MOV r32  ,imm32\n+    emit_d32   ( masm, 0x0  );             \/\/                         imm32==0x0\n@@ -1585,11 +1591,11 @@\n-    emit_opcode(cbuf,0x81); emit_d8(cbuf,0xF8);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x80);                     \/\/ cmp rax,80000000h\n-    emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x85);\n-    emit_opcode(cbuf,0x0B); emit_d8(cbuf,0x00);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     \/\/ jne normal_case\n-    emit_opcode(cbuf,0x33); emit_d8(cbuf,0xD2);                     \/\/ xor rdx,edx\n-    emit_opcode(cbuf,0x83); emit_d8(cbuf,0xF9); emit_d8(cbuf,0xFF); \/\/ cmp rcx,0FFh\n-    emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x84);\n-    emit_opcode(cbuf,0x03); emit_d8(cbuf,0x00);\n-    emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     \/\/ je done\n+    emit_opcode(masm,0x81); emit_d8(masm,0xF8);\n+    emit_opcode(masm,0x00); emit_d8(masm,0x00);\n+    emit_opcode(masm,0x00); emit_d8(masm,0x80);                     \/\/ cmp rax,80000000h\n+    emit_opcode(masm,0x0F); emit_d8(masm,0x85);\n+    emit_opcode(masm,0x0B); emit_d8(masm,0x00);\n+    emit_opcode(masm,0x00); emit_d8(masm,0x00);                     \/\/ jne normal_case\n+    emit_opcode(masm,0x33); emit_d8(masm,0xD2);                     \/\/ xor rdx,edx\n+    emit_opcode(masm,0x83); emit_d8(masm,0xF9); emit_d8(masm,0xFF); \/\/ cmp rcx,0FFh\n+    emit_opcode(masm,0x0F); emit_d8(masm,0x84);\n+    emit_opcode(masm,0x03); emit_d8(masm,0x00);\n+    emit_opcode(masm,0x00); emit_d8(masm,0x00);                     \/\/ je done\n@@ -1597,1 +1603,1 @@\n-    emit_opcode(cbuf,0x99);                                         \/\/ cdq\n+    emit_opcode(masm,0x99);                                         \/\/ cdq\n@@ -1604,1 +1610,1 @@\n-    emit_opcode(cbuf, $opcode$$constant + $reg$$reg);\n+    emit_opcode(masm, $opcode$$constant + $reg$$reg);\n@@ -1612,1 +1618,1 @@\n-      emit_opcode(cbuf, $primary | 0x02);\n+      emit_opcode(masm, $primary | 0x02);\n@@ -1615,1 +1621,1 @@\n-      emit_opcode(cbuf, $primary);\n+      emit_opcode(masm, $primary);\n@@ -1623,1 +1629,1 @@\n-      emit_opcode(cbuf, $primary | 0x02);    }\n+      emit_opcode(masm, $primary | 0x02);    }\n@@ -1625,1 +1631,1 @@\n-      emit_opcode(cbuf, $primary);\n+      emit_opcode(masm, $primary);\n@@ -1628,1 +1634,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, $dst$$reg);\n+    emit_rm(masm, 0x3, $secondary, $dst$$reg);\n@@ -1646,1 +1652,1 @@\n-    emit_opcode(cbuf, ((con >= -128) && (con <= 127)) ? ($primary | 0x02) : $primary);\n+    emit_opcode(masm, ((con >= -128) && (con <= 127)) ? ($primary | 0x02) : $primary);\n@@ -1648,3 +1654,3 @@\n-    emit_rm(cbuf, 0x3, $secondary, $dst$$reg);\n-    if ((con >= -128) && (con <= 127)) emit_d8 (cbuf,con);\n-    else                               emit_d32(cbuf,con);\n+    emit_rm(masm, 0x3, $secondary, $dst$$reg);\n+    if ((con >= -128) && (con <= 127)) emit_d8 (masm,con);\n+    else                               emit_d32(masm,con);\n@@ -1657,1 +1663,1 @@\n-    emit_opcode(cbuf, ((con >= -128) && (con <= 127)) ? ($primary | 0x02) : $primary);\n+    emit_opcode(masm, ((con >= -128) && (con <= 127)) ? ($primary | 0x02) : $primary);\n@@ -1659,3 +1665,3 @@\n-    emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW_ENC($dst$$reg));\n-    if ((con >= -128) && (con <= 127)) emit_d8 (cbuf,con);\n-    else                               emit_d32(cbuf,con);\n+    emit_rm(masm, 0x3, $tertiary, HIGH_FROM_LOW_ENC($dst$$reg));\n+    if ((con >= -128) && (con <= 127)) emit_d8 (masm,con);\n+    else                               emit_d32(masm,con);\n@@ -1665,1 +1671,1 @@\n-    emit_cc(cbuf, $secondary, $dst$$reg );\n+    emit_cc(masm, $secondary, $dst$$reg );\n@@ -1672,2 +1678,2 @@\n-    emit_opcode(cbuf, 0x0F);\n-    emit_cc(cbuf, 0xC8, destlo);\n+    emit_opcode(masm, 0x0F);\n+    emit_cc(masm, 0xC8, destlo);\n@@ -1675,2 +1681,2 @@\n-    emit_opcode(cbuf, 0x0F);\n-    emit_cc(cbuf, 0xC8, desthi);\n+    emit_opcode(masm, 0x0F);\n+    emit_cc(masm, 0xC8, desthi);\n@@ -1678,2 +1684,2 @@\n-    emit_opcode(cbuf, 0x87);\n-    emit_rm(cbuf, 0x3, destlo, desthi);\n+    emit_opcode(masm, 0x87);\n+    emit_rm(masm, 0x3, destlo, desthi);\n@@ -1683,1 +1689,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, $div$$reg );\n+    emit_rm(masm, 0x3, $secondary, $div$$reg );\n@@ -1688,1 +1694,1 @@\n-    emit_cc(cbuf, $secondary, $cop$$cmpcode);\n+    emit_cc(masm, $secondary, $cop$$cmpcode);\n@@ -1693,2 +1699,2 @@\n-    emit_d8(cbuf, op >> 8 );\n-    emit_d8(cbuf, op & 255);\n+    emit_d8(masm, op >> 8 );\n+    emit_d8(masm, op & 255);\n@@ -1700,2 +1706,2 @@\n-    emit_cc( cbuf, 0x70, ($cop$$cmpcode^1) );\n-    emit_d8( cbuf, $brOffs$$constant );\n+    emit_cc( masm, 0x70, ($cop$$cmpcode^1) );\n+    emit_d8( masm, $brOffs$$constant );\n@@ -1711,1 +1717,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -1722,2 +1727,1 @@\n-    MacroAssembler masm(&cbuf);\n-    int start = masm.offset();\n+    int start = __ offset();\n@@ -1726,1 +1730,1 @@\n-        masm.verify_FPU(0, \"must be empty in SSE2+ mode\");\n+        __ verify_FPU(0, \"must be empty in SSE2+ mode\");\n@@ -1731,1 +1735,1 @@\n-      masm.empty_FPU_stack();\n+      __ empty_FPU_stack();\n@@ -1734,1 +1738,1 @@\n-      sizeof_FFree_Float_Stack_All = masm.offset() - start;\n+      sizeof_FFree_Float_Stack_All = __ offset() - start;\n@@ -1736,1 +1740,1 @@\n-      assert(masm.offset() - start == sizeof_FFree_Float_Stack_All, \"wrong size\");\n+      assert(__ offset() - start == sizeof_FFree_Float_Stack_All, \"wrong size\");\n@@ -1742,2 +1746,1 @@\n-      MacroAssembler masm(&cbuf);\n-      masm.verify_FPU( -3, \"Returning from Runtime Leaf call\");\n+      __ verify_FPU( -3, \"Returning from Runtime Leaf call\");\n@@ -1749,2 +1752,1 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n+    __ set_inst_mark();\n@@ -1753,1 +1755,1 @@\n-    emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),\n+    emit_d32_reloc(masm, ($meth$$method - (int)(__ pc()) - 4),\n@@ -1755,0 +1757,1 @@\n+    __ clear_inst_mark();\n@@ -1758,1 +1761,0 @@\n-      MacroAssembler _masm(&cbuf);\n@@ -1783,1 +1785,1 @@\n-    debug_only(int off0 = cbuf.insts_size());\n+    debug_only(int off0 = __ offset());\n@@ -1785,1 +1787,0 @@\n-      MacroAssembler _masm(&cbuf);\n@@ -1790,2 +1791,1 @@\n-    MacroAssembler _masm(&cbuf);\n-    debug_only(int off1 = cbuf.insts_size());\n+    debug_only(int off1 = __ offset());\n@@ -1799,2 +1799,1 @@\n-      MacroAssembler masm(&cbuf);\n-      masm.fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n+      __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_24()));\n@@ -1807,2 +1806,1 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n+    __ set_inst_mark();\n@@ -1812,1 +1810,1 @@\n-      emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),\n+      emit_d32_reloc(masm, ($meth$$method - (int)(__ pc()) - 4),\n@@ -1815,0 +1813,1 @@\n+      __ clear_inst_mark();\n@@ -1817,1 +1816,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -1820,1 +1819,1 @@\n-      emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),\n+      emit_d32_reloc(masm, ($meth$$method - (int)(__ pc()) - 4),\n@@ -1823,1 +1822,1 @@\n-      address mark = cbuf.insts_mark();\n+      address mark = __ inst_mark();\n@@ -1827,1 +1826,2 @@\n-        cbuf.shared_stub_to_interp_for(_method, cbuf.insts()->mark_off());\n+        __ code()->shared_stub_to_interp_for(_method, __ code()->insts()->mark_off());\n+        __ clear_inst_mark();\n@@ -1830,1 +1830,2 @@\n-        address stub = CompiledDirectCall::emit_to_interp_stub(cbuf, mark);\n+        address stub = CompiledDirectCall::emit_to_interp_stub(masm, mark);\n+        __ clear_inst_mark();\n@@ -1840,2 +1841,1 @@\n-    MacroAssembler _masm(&cbuf);\n-    __ ic_call((address)$meth$$method, resolved_method_index(cbuf));\n+    __ ic_call((address)$meth$$method, resolved_method_index(masm));\n@@ -1850,2 +1850,1 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n+    __ set_inst_mark();\n@@ -1853,2 +1852,3 @@\n-    emit_rm(cbuf, 0x01, $secondary, EAX_enc );  \/\/ R\/M byte\n-    emit_d8(cbuf, disp);             \/\/ Displacement\n+    emit_rm(masm, 0x01, $secondary, EAX_enc );  \/\/ R\/M byte\n+    emit_d8(masm, disp);             \/\/ Displacement\n+    __ clear_inst_mark();\n@@ -1858,26 +1858,0 @@\n-\/\/   Following encoding is no longer used, but may be restored if calling\n-\/\/   convention changes significantly.\n-\/\/   Became: Xor_Reg(EBP), Java_To_Runtime( labl )\n-\/\/\n-\/\/   enc_class Java_Interpreter_Call (label labl) %{    \/\/ JAVA INTERPRETER CALL\n-\/\/     \/\/ int ic_reg     = Matcher::inline_cache_reg();\n-\/\/     \/\/ int ic_encode  = Matcher::_regEncode[ic_reg];\n-\/\/     \/\/ int imo_reg    = Matcher::interpreter_method_reg();\n-\/\/     \/\/ int imo_encode = Matcher::_regEncode[imo_reg];\n-\/\/\n-\/\/     \/\/ \/\/ Interpreter expects method_ptr in EBX, currently a callee-saved register,\n-\/\/     \/\/ \/\/ so we load it immediately before the call\n-\/\/     \/\/ emit_opcode(cbuf, 0x8B);                     \/\/ MOV    imo_reg,ic_reg  # method_ptr\n-\/\/     \/\/ emit_rm(cbuf, 0x03, imo_encode, ic_encode ); \/\/ R\/M byte\n-\/\/\n-\/\/     \/\/ xor rbp,ebp\n-\/\/     emit_opcode(cbuf, 0x33);\n-\/\/     emit_rm(cbuf, 0x3, EBP_enc, EBP_enc);\n-\/\/\n-\/\/     \/\/ CALL to interpreter.\n-\/\/     cbuf.set_insts_mark();\n-\/\/     $$$emit8$primary;\n-\/\/     emit_d32_reloc(cbuf, ($labl$$label - (int)(cbuf.insts_end()) - 4),\n-\/\/                 runtime_call_Relocation::spec(), RELOC_IMM32 );\n-\/\/   %}\n-\n@@ -1886,1 +1860,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, $dst$$reg);\n+    emit_rm(masm, 0x3, $secondary, $dst$$reg);\n@@ -1893,1 +1867,1 @@\n-    emit_opcode(cbuf, 0xB8 + $dst$$reg);\n+    emit_opcode(masm, 0xB8 + $dst$$reg);\n@@ -1900,1 +1874,1 @@\n-    emit_opcode(cbuf, $primary + $dst$$reg);\n+    emit_opcode(masm, $primary + $dst$$reg);\n@@ -1911,2 +1885,2 @@\n-      emit_opcode(cbuf, 0x33);\n-      emit_rm(cbuf, 0x3, dst_enc, dst_enc);\n+      emit_opcode(masm, 0x33);\n+      emit_rm(masm, 0x3, dst_enc, dst_enc);\n@@ -1914,2 +1888,2 @@\n-      emit_opcode(cbuf, $primary + dst_enc);\n-      emit_d32(cbuf, src_con);\n+      emit_opcode(masm, $primary + dst_enc);\n+      emit_d32(masm, src_con);\n@@ -1926,2 +1900,2 @@\n-      emit_opcode(cbuf, 0x33);\n-      emit_rm(cbuf, 0x3, dst_enc, dst_enc);\n+      emit_opcode(masm, 0x33);\n+      emit_rm(masm, 0x3, dst_enc, dst_enc);\n@@ -1929,2 +1903,2 @@\n-      emit_opcode(cbuf, $primary + dst_enc);\n-      emit_d32(cbuf, src_con);\n+      emit_opcode(masm, $primary + dst_enc);\n+      emit_d32(masm, src_con);\n@@ -1937,1 +1911,1 @@\n-    encode_Copy( cbuf, $dst$$reg, $src$$reg );\n+    encode_Copy( masm, $dst$$reg, $src$$reg );\n@@ -1941,1 +1915,1 @@\n-    encode_Copy( cbuf, $dst$$reg, $src$$reg );\n+    encode_Copy( masm, $dst$$reg, $src$$reg );\n@@ -1945,1 +1919,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -1950,1 +1924,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -1955,1 +1929,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1959,1 +1933,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -1963,1 +1937,1 @@\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1967,1 +1941,1 @@\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_rm(masm, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -1979,1 +1953,1 @@\n-    emit_d32(cbuf, jf_as_bits);\n+    emit_d32(masm, jf_as_bits);\n@@ -1986,1 +1960,1 @@\n-    emit_d32(cbuf, jf_as_bits);\n+    emit_d32(masm, jf_as_bits);\n@@ -1995,1 +1969,1 @@\n-    emit_d32(cbuf,$src$$constant);\n+    emit_d32(masm,$src$$constant);\n@@ -2000,2 +1974,2 @@\n-    emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );\n-    emit_d32(cbuf, 0x00);\n+    emit_rm(masm, 0x00, $t1$$reg, 0x05 );\n+    emit_d32(masm, 0x00);\n@@ -2005,1 +1979,1 @@\n-    emit_opcode(cbuf,0xF0);         \/\/ [Lock]\n+    emit_opcode(masm,0xF0);         \/\/ [Lock]\n@@ -2016,2 +1990,2 @@\n-    emit_opcode(cbuf,0x87);\n-    emit_opcode(cbuf,0xD9);\n+    emit_opcode(masm,0x87);\n+    emit_opcode(masm,0xD9);\n@@ -2019,1 +1993,1 @@\n-    emit_opcode(cbuf,0xF0);\n+    emit_opcode(masm,0xF0);\n@@ -2021,3 +1995,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xC7);\n-    emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xC7);\n+    emit_rm( masm, 0x0, 1, $mem_ptr$$reg );\n@@ -2025,2 +1999,2 @@\n-    emit_opcode(cbuf,0x87);\n-    emit_opcode(cbuf,0xD9);\n+    emit_opcode(masm,0x87);\n+    emit_opcode(masm,0xD9);\n@@ -2031,1 +2005,1 @@\n-    emit_opcode(cbuf,0xF0);\n+    emit_opcode(masm,0xF0);\n@@ -2034,3 +2008,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xB1);\n-    emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xB1);\n+    emit_rm( masm, 0x0, 1, $mem_ptr$$reg );\n@@ -2041,1 +2015,1 @@\n-    emit_opcode(cbuf,0xF0);\n+    emit_opcode(masm,0xF0);\n@@ -2044,3 +2018,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xB0);\n-    emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xB0);\n+    emit_rm( masm, 0x0, 1, $mem_ptr$$reg );\n@@ -2051,1 +2025,1 @@\n-    emit_opcode(cbuf,0xF0);\n+    emit_opcode(masm,0xF0);\n@@ -2054,1 +2028,1 @@\n-    emit_opcode(cbuf, 0x66);\n+    emit_opcode(masm, 0x66);\n@@ -2057,3 +2031,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xB1);\n-    emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xB1);\n+    emit_rm( masm, 0x0, 1, $mem_ptr$$reg );\n@@ -2066,2 +2040,2 @@\n-    emit_opcode( cbuf, 0xB8 + res_encoding);\n-    emit_d32( cbuf, 0 );\n+    emit_opcode( masm, 0xB8 + res_encoding);\n+    emit_d32( masm, 0 );\n@@ -2069,2 +2043,2 @@\n-    emit_opcode(cbuf,0x75);\n-    emit_d8(cbuf, 5 );\n+    emit_opcode(masm,0x75);\n+    emit_d8(masm, 5 );\n@@ -2072,2 +2046,2 @@\n-    emit_opcode( cbuf, 0xB8 + res_encoding);\n-    emit_d32( cbuf, 1 );\n+    emit_opcode( masm, 0xB8 + res_encoding);\n+    emit_d32( masm, 1 );\n@@ -2077,4 +2051,0 @@\n-  enc_class set_instruction_start( ) %{\n-    cbuf.set_insts_mark();            \/\/ Mark start of opcode for reloc info in mem operand\n-  %}\n-\n@@ -2088,1 +2058,1 @@\n-    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);\n+    encode_RegMem(masm, reg_encoding, base, index, scale, displace, disp_reloc);\n@@ -2098,1 +2068,1 @@\n-    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, relocInfo::none);\n+    encode_RegMem(masm, reg_encoding, base, index, scale, displace, relocInfo::none);\n@@ -2105,7 +2075,7 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,$tertiary);\n-    emit_rm(cbuf, 0x3, r1, r2);\n-    emit_d8(cbuf,$cnt$$constant);\n-    emit_d8(cbuf,$primary);\n-    emit_rm(cbuf, 0x3, $secondary, r1);\n-    emit_d8(cbuf,$cnt$$constant);\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,$tertiary);\n+    emit_rm(masm, 0x3, r1, r2);\n+    emit_d8(masm,$cnt$$constant);\n+    emit_d8(masm,$primary);\n+    emit_rm(masm, 0x3, $secondary, r1);\n+    emit_d8(masm,$cnt$$constant);\n@@ -2115,2 +2085,2 @@\n-    emit_opcode( cbuf, 0x8B ); \/\/ Move\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_opcode( masm, 0x8B ); \/\/ Move\n+    emit_rm(masm, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2118,3 +2088,3 @@\n-      emit_d8(cbuf,$primary);\n-      emit_rm(cbuf, 0x3, $secondary, $dst$$reg);\n-      emit_d8(cbuf,$cnt$$constant-32);\n+      emit_d8(masm,$primary);\n+      emit_rm(masm, 0x3, $secondary, $dst$$reg);\n+      emit_d8(masm,$cnt$$constant-32);\n@@ -2122,3 +2092,3 @@\n-    emit_d8(cbuf,$primary);\n-    emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW_ENC($dst$$reg));\n-    emit_d8(cbuf,31);\n+    emit_d8(masm,$primary);\n+    emit_rm(masm, 0x3, $secondary, HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_d8(masm,31);\n@@ -2132,2 +2102,2 @@\n-    emit_opcode( cbuf, 0x8B ); \/\/ Move r1,r2\n-    emit_rm(cbuf, 0x3, r1, r2);\n+    emit_opcode( masm, 0x8B ); \/\/ Move r1,r2\n+    emit_rm(masm, 0x3, r1, r2);\n@@ -2135,3 +2105,3 @@\n-      emit_opcode(cbuf,$primary);\n-      emit_rm(cbuf, 0x3, $secondary, r1);\n-      emit_d8(cbuf,$cnt$$constant-32);\n+      emit_opcode(masm,$primary);\n+      emit_rm(masm, 0x3, $secondary, r1);\n+      emit_d8(masm,$cnt$$constant-32);\n@@ -2139,2 +2109,2 @@\n-    emit_opcode(cbuf,0x33);  \/\/ XOR r2,r2\n-    emit_rm(cbuf, 0x3, r2, r2);\n+    emit_opcode(masm,0x33);  \/\/ XOR r2,r2\n+    emit_rm(masm, 0x3, r2, r2);\n@@ -2146,1 +2116,1 @@\n-    emit_opcode(cbuf,$opcode$$constant);\n+    emit_opcode(masm,$opcode$$constant);\n@@ -2153,1 +2123,1 @@\n-    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);\n+    encode_RegMem(masm, reg_encoding, base, index, scale, displace, disp_reloc);\n@@ -2168,1 +2138,1 @@\n-    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, relocInfo::none);\n+    encode_RegMem(masm, rm_byte_opcode, base, index, scale, displace, relocInfo::none);\n@@ -2178,1 +2148,1 @@\n-    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n+    encode_RegMem(masm, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n@@ -2188,1 +2158,1 @@\n-    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);\n+    encode_RegMem(masm, reg_encoding, base, index, scale, displace, disp_reloc);\n@@ -2193,2 +2163,2 @@\n-    emit_opcode(cbuf,0x3B);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_opcode(masm,0x3B);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -2196,2 +2166,2 @@\n-    emit_opcode(cbuf,0x7C);\n-    emit_d8(cbuf,2);\n+    emit_opcode(masm,0x7C);\n+    emit_d8(masm,2);\n@@ -2199,2 +2169,2 @@\n-    emit_opcode(cbuf,0x8B);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_opcode(masm,0x8B);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -2205,2 +2175,2 @@\n-    emit_opcode(cbuf,0x3B);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_opcode(masm,0x3B);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -2208,2 +2178,2 @@\n-    emit_opcode(cbuf,0x7F);\n-    emit_d8(cbuf,2);\n+    emit_opcode(masm,0x7F);\n+    emit_d8(masm,2);\n@@ -2211,2 +2181,2 @@\n-    emit_opcode(cbuf,0x8B);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);\n+    emit_opcode(masm,0x8B);\n+    emit_rm(masm, 0x3, $dst$$reg, $src$$reg);\n@@ -2226,2 +2196,2 @@\n-      emit_opcode( cbuf, 0xD9 ); \/\/ FLD (i.e., push it)\n-      emit_d8( cbuf, 0xC0-1+$src$$reg );\n+      emit_opcode( masm, 0xD9 ); \/\/ FLD (i.e., push it)\n+      emit_d8( masm, 0xC0-1+$src$$reg );\n@@ -2229,3 +2199,4 @@\n-    cbuf.set_insts_mark();       \/\/ Mark start of opcode for reloc info in mem operand\n-    emit_opcode(cbuf,$primary);\n-    encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);\n+    __ set_inst_mark();       \/\/ Mark start of opcode for reloc info in mem operand\n+    emit_opcode(masm,$primary);\n+    encode_RegMem(masm, reg_encoding, base, index, scale, displace, disp_reloc);\n+    __ clear_inst_mark();\n@@ -2236,2 +2207,2 @@\n-    emit_opcode(cbuf,0xF7);\n-    emit_rm(cbuf, 0x3, 0x03, $dst$$reg );\n+    emit_opcode(masm,0xF7);\n+    emit_rm(masm, 0x3, 0x03, $dst$$reg );\n@@ -2242,3 +2213,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0x9C);\n-    emit_rm( cbuf, 0x3, 0x4, $dst$$reg );\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0x9C);\n+    emit_rm( masm, 0x3, 0x4, $dst$$reg );\n@@ -2251,2 +2222,2 @@\n-    emit_opcode(cbuf,0x2B);\n-    emit_rm(cbuf, 0x3, $p$$reg, $q$$reg);\n+    emit_opcode(masm,0x2B);\n+    emit_rm(masm, 0x3, $p$$reg, $q$$reg);\n@@ -2254,2 +2225,2 @@\n-    emit_opcode(cbuf,0x1B);\n-    emit_rm(cbuf, 0x3, tmpReg, tmpReg);\n+    emit_opcode(masm,0x1B);\n+    emit_rm(masm, 0x3, tmpReg, tmpReg);\n@@ -2257,2 +2228,2 @@\n-    emit_opcode(cbuf,0x23);\n-    emit_rm(cbuf, 0x3, tmpReg, $y$$reg);\n+    emit_opcode(masm,0x23);\n+    emit_rm(masm, 0x3, tmpReg, $y$$reg);\n@@ -2260,2 +2231,2 @@\n-    emit_opcode(cbuf,0x03);\n-    emit_rm(cbuf, 0x3, $p$$reg, tmpReg);\n+    emit_opcode(masm,0x03);\n+    emit_rm(masm, 0x3, $p$$reg, tmpReg);\n@@ -2266,3 +2237,3 @@\n-    emit_opcode(cbuf,0xF7);\n-    emit_rm(cbuf, 0x3, 0, ECX_enc);\n-    emit_d32(cbuf,0x20);\n+    emit_opcode(masm,0xF7);\n+    emit_rm(masm, 0x3, 0, ECX_enc);\n+    emit_d32(masm,0x20);\n@@ -2270,2 +2241,2 @@\n-    emit_opcode(cbuf, 0x74);\n-    emit_d8(cbuf, 0x04);\n+    emit_opcode(masm, 0x74);\n+    emit_d8(masm, 0x04);\n@@ -2273,2 +2244,2 @@\n-    emit_opcode( cbuf, 0x8B );\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n+    emit_opcode( masm, 0x8B );\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2276,2 +2247,2 @@\n-    emit_opcode(cbuf, 0x33);\n-    emit_rm(cbuf, 0x3, $dst$$reg, $dst$$reg);\n+    emit_opcode(masm, 0x33);\n+    emit_rm(masm, 0x3, $dst$$reg, $dst$$reg);\n@@ -2280,3 +2251,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xA5);\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xA5);\n+    emit_rm(masm, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2284,2 +2255,2 @@\n-    emit_opcode(cbuf,0xD3);\n-    emit_rm(cbuf, 0x3, 0x4, $dst$$reg );\n+    emit_opcode(masm,0xD3);\n+    emit_rm(masm, 0x3, 0x4, $dst$$reg );\n@@ -2290,3 +2261,3 @@\n-    emit_opcode(cbuf,0xF7);\n-    emit_rm(cbuf, 0x3, 0, ECX_enc);\n-    emit_d32(cbuf,0x20);\n+    emit_opcode(masm,0xF7);\n+    emit_rm(masm, 0x3, 0, ECX_enc);\n+    emit_d32(masm,0x20);\n@@ -2294,2 +2265,2 @@\n-    emit_opcode(cbuf, 0x74);\n-    emit_d8(cbuf, 0x04);\n+    emit_opcode(masm, 0x74);\n+    emit_d8(masm, 0x04);\n@@ -2297,2 +2268,2 @@\n-    emit_opcode( cbuf, 0x8B );\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode( masm, 0x8B );\n+    emit_rm(masm, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2300,2 +2271,2 @@\n-    emit_opcode(cbuf, 0x33);\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_opcode(masm, 0x33);\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($dst$$reg));\n@@ -2304,3 +2275,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xAD);\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xAD);\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2308,2 +2279,2 @@\n-    emit_opcode(cbuf,0xD3);\n-    emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode(masm,0xD3);\n+    emit_rm(masm, 0x3, 0x5, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2314,3 +2285,3 @@\n-    emit_opcode(cbuf,0xF7);\n-    emit_rm(cbuf, 0x3, 0, ECX_enc);\n-    emit_d32(cbuf,0x20);\n+    emit_opcode(masm,0xF7);\n+    emit_rm(masm, 0x3, 0, ECX_enc);\n+    emit_d32(masm,0x20);\n@@ -2318,2 +2289,2 @@\n-    emit_opcode(cbuf, 0x74);\n-    emit_d8(cbuf, 0x05);\n+    emit_opcode(masm, 0x74);\n+    emit_d8(masm, 0x05);\n@@ -2321,2 +2292,2 @@\n-    emit_opcode( cbuf, 0x8B );\n-    emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode( masm, 0x8B );\n+    emit_rm(masm, 0x3, $dst$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2324,3 +2295,3 @@\n-    emit_opcode(cbuf, 0xC1);\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC($dst$$reg) );\n-    emit_d8(cbuf, 0x1F );\n+    emit_opcode(masm, 0xC1);\n+    emit_rm(masm, 0x3, 7, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_d8(masm, 0x1F );\n@@ -2329,3 +2300,3 @@\n-    emit_opcode(cbuf,0x0F);\n-    emit_opcode(cbuf,0xAD);\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n+    emit_opcode(masm,0x0F);\n+    emit_opcode(masm,0xAD);\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg);\n@@ -2333,2 +2304,2 @@\n-    emit_opcode(cbuf,0xD3);\n-    emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode(masm,0xD3);\n+    emit_rm(masm, 0x3, 0x7, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2342,1 +2313,1 @@\n-    emit_rm(cbuf, 0x3, $secondary, $src$$reg );\n+    emit_rm(masm, 0x3, $secondary, $src$$reg );\n@@ -2347,2 +2318,2 @@\n-    emit_opcode( cbuf, 0xDD );\n-    emit_d8( cbuf, 0xD8 );\n+    emit_opcode( masm, 0xDD );\n+    emit_d8( masm, 0xD8 );\n@@ -2353,2 +2324,2 @@\n-    emit_opcode( cbuf, 0xDD );           \/\/ FSTP   ST(i)\n-    emit_d8( cbuf, 0xD8+$dst$$reg );\n+    emit_opcode( masm, 0xDD );           \/\/ FSTP   ST(i)\n+    emit_d8( masm, 0xD8+$dst$$reg );\n@@ -2358,2 +2329,2 @@\n-    emit_opcode( cbuf, 0xD9 );\n-    emit_d8( cbuf, 0xC0-1+$dst$$reg );   \/\/ FLD ST(i-1)\n+    emit_opcode( masm, 0xD9 );\n+    emit_d8( masm, 0xC0-1+$dst$$reg );   \/\/ FLD ST(i-1)\n@@ -2363,5 +2334,5 @@\n-    emit_opcode( cbuf, 0xDB );           \/\/ FLD m80real\n-    emit_opcode( cbuf, 0x2D );\n-    emit_d32( cbuf, (int)StubRoutines::x86::addr_fpu_subnormal_bias1() );\n-    emit_opcode( cbuf, 0xDE );           \/\/ FMULP ST(dst), ST0\n-    emit_opcode( cbuf, 0xC8+$dst$$reg );\n+    emit_opcode( masm, 0xDB );           \/\/ FLD m80real\n+    emit_opcode( masm, 0x2D );\n+    emit_d32( masm, (int)StubRoutines::x86::addr_fpu_subnormal_bias1() );\n+    emit_opcode( masm, 0xDE );           \/\/ FMULP ST(dst), ST0\n+    emit_opcode( masm, 0xC8+$dst$$reg );\n@@ -2371,5 +2342,5 @@\n-    emit_opcode( cbuf, 0xDB );           \/\/ FLD m80real\n-    emit_opcode( cbuf, 0x2D );\n-    emit_d32( cbuf, (int)StubRoutines::x86::addr_fpu_subnormal_bias2() );\n-    emit_opcode( cbuf, 0xDE );           \/\/ FMULP ST(dst), ST0\n-    emit_opcode( cbuf, 0xC8+$dst$$reg );\n+    emit_opcode( masm, 0xDB );           \/\/ FLD m80real\n+    emit_opcode( masm, 0x2D );\n+    emit_d32( masm, (int)StubRoutines::x86::addr_fpu_subnormal_bias2() );\n+    emit_opcode( masm, 0xDE );           \/\/ FMULP ST(dst), ST0\n+    emit_opcode( masm, 0xC8+$dst$$reg );\n@@ -2380,1 +2351,1 @@\n-    store_to_stackslot( cbuf, $primary, $src$$reg, $dst$$disp );\n+    store_to_stackslot( masm, $primary, $src$$reg, $dst$$disp );\n@@ -2386,3 +2357,3 @@\n-    emit_rm( cbuf, 0x02, $src$$reg, ESP_enc );   \/\/ R\/M byte\n-    emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);          \/\/ SIB byte\n-    emit_d32(cbuf, $dst$$disp);   \/\/ Displacement\n+    emit_rm( masm, 0x02, $src$$reg, ESP_enc );   \/\/ R\/M byte\n+    emit_rm( masm, 0x00, ESP_enc, ESP_enc);          \/\/ SIB byte\n+    emit_d32(masm, $dst$$disp);   \/\/ Displacement\n@@ -2393,1 +2364,1 @@\n-    store_to_stackslot( cbuf, $primary, $secondary, $src$$disp );\n+    store_to_stackslot( masm, $primary, $secondary, $src$$disp );\n@@ -2398,1 +2369,1 @@\n-    store_to_stackslot( cbuf, 0xD9, 0x03, $dst$$disp );\n+    store_to_stackslot( masm, 0xD9, 0x03, $dst$$disp );\n@@ -2404,1 +2375,1 @@\n-    store_to_stackslot( cbuf, 0xDD, 0x03, $dst$$disp );\n+    store_to_stackslot( masm, 0xDD, 0x03, $dst$$disp );\n@@ -2408,2 +2379,2 @@\n-    emit_opcode( cbuf, 0xDD );           \/\/ FSTP   ST(i)\n-    emit_d8( cbuf, 0xD8+$dst$$reg );\n+    emit_opcode( masm, 0xDD );           \/\/ FSTP   ST(i)\n+    emit_d8( masm, 0xD8+$dst$$reg );\n@@ -2413,2 +2384,2 @@\n-    emit_opcode( cbuf, 0xD9 );           \/\/ FLD    ST(i-1)\n-    emit_d8( cbuf, 0xC0-1+$dst$$reg );\n+    emit_opcode( masm, 0xD9 );           \/\/ FLD    ST(i-1)\n+    emit_d8( masm, 0xC0-1+$dst$$reg );\n@@ -2421,2 +2392,2 @@\n-      emit_opcode( cbuf, 0xD9 );         \/\/ FLD    ST(i-1)\n-      emit_d8( cbuf, 0xC0-1+$src$$reg );\n+      emit_opcode( masm, 0xD9 );         \/\/ FLD    ST(i-1)\n+      emit_d8( masm, 0xC0-1+$src$$reg );\n@@ -2425,1 +2396,1 @@\n-    store_to_stackslot( cbuf, 0xD9, pop, $dst$$disp ); \/\/ FST<P>_S  [ESP+dst]\n+    store_to_stackslot( masm, 0xD9, pop, $dst$$disp ); \/\/ FST<P>_S  [ESP+dst]\n@@ -2432,2 +2403,2 @@\n-      emit_opcode( cbuf, 0xD9 );         \/\/ FLD    ST(i-1)\n-      emit_d8( cbuf, 0xC0-1+$src$$reg );\n+      emit_opcode( masm, 0xD9 );         \/\/ FLD    ST(i-1)\n+      emit_d8( masm, 0xC0-1+$src$$reg );\n@@ -2436,1 +2407,1 @@\n-    store_to_stackslot( cbuf, 0xDD, pop, $dst$$disp ); \/\/ FST<P>_D  [ESP+dst]\n+    store_to_stackslot( masm, 0xDD, pop, $dst$$disp ); \/\/ FST<P>_D  [ESP+dst]\n@@ -2443,2 +2414,2 @@\n-      emit_opcode( cbuf, 0xD9 );         \/\/ FLD    ST(src-1)\n-      emit_d8( cbuf, 0xC0-1+$src$$reg );\n+      emit_opcode( masm, 0xD9 );         \/\/ FLD    ST(src-1)\n+      emit_d8( masm, 0xC0-1+$src$$reg );\n@@ -2447,2 +2418,2 @@\n-    emit_opcode( cbuf, 0xDD );\n-    emit_d8( cbuf, pop+$dst$$reg );      \/\/ FST<P> ST(i)\n+    emit_opcode( masm, 0xDD );\n+    emit_d8( masm, pop+$dst$$reg );      \/\/ FST<P> ST(i)\n@@ -2454,2 +2425,2 @@\n-    emit_opcode( cbuf, 0xD9 );\n-    emit_d8( cbuf, 0xC0-1+$dst$$reg );\n+    emit_opcode( masm, 0xD9 );\n+    emit_d8( masm, 0xC0-1+$dst$$reg );\n@@ -2458,2 +2429,2 @@\n-      emit_opcode (cbuf, 0xD9);\n-      emit_opcode (cbuf, 0xF7);\n+      emit_opcode (masm, 0xD9);\n+      emit_opcode (masm, 0xF7);\n@@ -2462,2 +2433,2 @@\n-      emit_opcode(cbuf, 0xD9);\n-      emit_d8(cbuf, 0xC8-1+$src$$reg );\n+      emit_opcode(masm, 0xD9);\n+      emit_d8(masm, 0xC8-1+$src$$reg );\n@@ -2465,2 +2436,2 @@\n-      emit_opcode (cbuf, 0xD9);\n-      emit_opcode (cbuf, 0xF6);\n+      emit_opcode (masm, 0xD9);\n+      emit_opcode (masm, 0xF6);\n@@ -2471,1 +2442,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2480,1 +2450,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2489,1 +2458,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2496,1 +2464,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2503,1 +2470,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2510,1 +2476,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2515,1 +2480,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2520,1 +2484,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -2528,2 +2491,2 @@\n-      emit_opcode (cbuf, 0xD9);\n-      emit_opcode (cbuf, 0xF7);\n+      emit_opcode (masm, 0xD9);\n+      emit_opcode (masm, 0xF7);\n@@ -2531,2 +2494,2 @@\n-      emit_opcode(cbuf, 0xD9);\n-      emit_d8(cbuf, 0xC8-1+$src$$reg );\n+      emit_opcode(masm, 0xD9);\n+      emit_d8(masm, 0xC8-1+$src$$reg );\n@@ -2534,2 +2497,2 @@\n-      emit_opcode (cbuf, 0xD9);\n-      emit_opcode (cbuf, 0xF6);\n+      emit_opcode (masm, 0xD9);\n+      emit_opcode (masm, 0xF6);\n@@ -2537,4 +2500,0 @@\n-    \/\/ \/\/ following asm replaced with Pop_Reg_F or Pop_Mem_F\n-    \/\/ \/\/ FSTP   FPR$dst$$reg\n-    \/\/ emit_opcode( cbuf, 0xDD );\n-    \/\/ emit_d8( cbuf, 0xD8+$dst$$reg );\n@@ -2545,2 +2504,2 @@\n-    emit_opcode( cbuf, 0xDF );\n-    emit_opcode( cbuf, 0xE0 );\n+    emit_opcode( masm, 0xDF );\n+    emit_opcode( masm, 0xE0 );\n@@ -2548,1 +2507,1 @@\n-    emit_opcode( cbuf, 0x9E );\n+    emit_opcode( masm, 0x9E );\n@@ -2550,2 +2509,2 @@\n-    emit_opcode( cbuf, 0x7B );\n-    emit_opcode( cbuf, 0x05 );\n+    emit_opcode( masm, 0x7B );\n+    emit_opcode( masm, 0x05 );\n@@ -2558,2 +2517,2 @@\n-    emit_opcode( cbuf, 0xD9 );\n-    emit_opcode( cbuf, 0xF8 );\n+    emit_opcode( masm, 0xD9 );\n+    emit_opcode( masm, 0xF8 );\n@@ -2561,1 +2520,1 @@\n-    emit_opcode( cbuf, 0x9b );\n+    emit_opcode( masm, 0x9b );\n@@ -2563,2 +2522,2 @@\n-    emit_opcode( cbuf, 0xDF );\n-    emit_opcode( cbuf, 0xE0 );\n+    emit_opcode( masm, 0xDF );\n+    emit_opcode( masm, 0xE0 );\n@@ -2566,1 +2525,1 @@\n-    emit_opcode( cbuf, 0x9E );\n+    emit_opcode( masm, 0x9E );\n@@ -2568,6 +2527,6 @@\n-    emit_opcode( cbuf, 0x0F );\n-    emit_opcode( cbuf, 0x8A );\n-    emit_opcode( cbuf, 0xF4 );\n-    emit_opcode( cbuf, 0xFF );\n-    emit_opcode( cbuf, 0xFF );\n-    emit_opcode( cbuf, 0xFF );\n+    emit_opcode( masm, 0x0F );\n+    emit_opcode( masm, 0x8A );\n+    emit_opcode( masm, 0xF4 );\n+    emit_opcode( masm, 0xFF );\n+    emit_opcode( masm, 0xFF );\n+    emit_opcode( masm, 0xFF );\n@@ -2578,2 +2537,2 @@\n-    emit_opcode( cbuf, 0xDF);\n-    emit_opcode( cbuf, 0xE0);\n+    emit_opcode( masm, 0xDF);\n+    emit_opcode( masm, 0xE0);\n@@ -2581,3 +2540,3 @@\n-    emit_opcode( cbuf, 0x66 );   \/\/ operand-size prefix for 16-bit immediate\n-    emit_opcode( cbuf, 0xA9 );\n-    emit_d16   ( cbuf, 0x0400 );\n+    emit_opcode( masm, 0x66 );   \/\/ operand-size prefix for 16-bit immediate\n+    emit_opcode( masm, 0xA9 );\n+    emit_d16   ( masm, 0x0400 );\n@@ -2586,2 +2545,2 @@\n-    \/\/ emit_opcode( cbuf, 0xA9 );\n-    \/\/ emit_d32   ( cbuf, 0x00000400 );\n+    \/\/ emit_opcode( masm, 0xA9 );\n+    \/\/ emit_d32   ( masm, 0x00000400 );\n@@ -2590,2 +2549,2 @@\n-    emit_opcode( cbuf, 0x74 );\n-    emit_d8    ( cbuf, 0x02 );\n+    emit_opcode( masm, 0x74 );\n+    emit_d8    ( masm, 0x02 );\n@@ -2593,2 +2552,2 @@\n-    emit_opcode( cbuf, 0xB4 );\n-    emit_d8    ( cbuf, 0x01 );\n+    emit_opcode( masm, 0xB4 );\n+    emit_d8    ( masm, 0x01 );\n@@ -2596,1 +2555,1 @@\n-    emit_opcode( cbuf, 0x9E);\n+    emit_opcode( masm, 0x9E);\n@@ -2603,2 +2562,2 @@\n-    emit_opcode( cbuf, 0x7B );\n-    emit_d8    ( cbuf, 0x03 );\n+    emit_opcode( masm, 0x7B );\n+    emit_d8    ( masm, 0x03 );\n@@ -2606,2 +2565,2 @@\n-    emit_opcode( cbuf, 0xB4 );\n-    emit_d8    ( cbuf, 0x01 );\n+    emit_opcode( masm, 0xB4 );\n+    emit_d8    ( masm, 0x01 );\n@@ -2609,1 +2568,1 @@\n-    emit_opcode( cbuf, 0x9E);\n+    emit_opcode( masm, 0x9E);\n@@ -2611,1 +2570,1 @@\n-    emit_opcode( cbuf, 0x90);\n+    emit_opcode( masm, 0x90);\n@@ -2631,2 +2590,2 @@\n-    emit_opcode( cbuf, 0xDF);\n-    emit_opcode( cbuf, 0xE0);\n+    emit_opcode( masm, 0xDF);\n+    emit_opcode( masm, 0xE0);\n@@ -2634,1 +2593,1 @@\n-    emit_opcode( cbuf, 0x9E);\n+    emit_opcode( masm, 0x9E);\n@@ -2636,2 +2595,2 @@\n-    emit_opcode( cbuf, 0xB8 + $dst$$reg);\n-    emit_d32( cbuf, -1 );\n+    emit_opcode( masm, 0xB8 + $dst$$reg);\n+    emit_d32( masm, -1 );\n@@ -2639,2 +2598,2 @@\n-    emit_opcode( cbuf, 0x7A );\n-    emit_d8    ( cbuf, 0x13 );\n+    emit_opcode( masm, 0x7A );\n+    emit_d8    ( masm, 0x13 );\n@@ -2642,2 +2601,2 @@\n-    emit_opcode( cbuf, 0xB8 + $dst$$reg);\n-    emit_d32( cbuf, -1 );\n+    emit_opcode( masm, 0xB8 + $dst$$reg);\n+    emit_d32( masm, -1 );\n@@ -2645,2 +2604,2 @@\n-    emit_opcode( cbuf, 0x72 );\n-    emit_d8    ( cbuf, 0x0C );\n+    emit_opcode( masm, 0x72 );\n+    emit_d8    ( masm, 0x0C );\n@@ -2648,2 +2607,2 @@\n-    emit_opcode( cbuf, 0xB8 + $dst$$reg);\n-    emit_d32( cbuf, 0 );\n+    emit_opcode( masm, 0xB8 + $dst$$reg);\n+    emit_d32( masm, 0 );\n@@ -2651,2 +2610,2 @@\n-    emit_opcode( cbuf, 0x74 );\n-    emit_d8    ( cbuf, 0x05 );\n+    emit_opcode( masm, 0x74 );\n+    emit_d8    ( masm, 0x05 );\n@@ -2654,2 +2613,2 @@\n-    emit_opcode( cbuf, 0xB8 + $dst$$reg);\n-    emit_d32( cbuf, 1 );\n+    emit_opcode( masm, 0xB8 + $dst$$reg);\n+    emit_d32( masm, 1 );\n@@ -2663,2 +2622,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2666,2 +2625,2 @@\n-    emit_opcode(cbuf,0x75);\n-    emit_d8(cbuf, 2 );\n+    emit_opcode(masm,0x75);\n+    emit_d8(masm, 2 );\n@@ -2669,2 +2628,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, $src1$$reg, $src2$$reg );\n@@ -2678,1 +2637,1 @@\n-    encode_Copy( cbuf, dst_encoding  , src_encoding );\n+    encode_Copy( masm, dst_encoding  , src_encoding );\n@@ -2680,1 +2639,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW_ENC(dst_encoding), src_encoding );\n+    encode_Copy( masm, HIGH_FROM_LOW_ENC(dst_encoding), src_encoding );\n@@ -2682,3 +2641,3 @@\n-    emit_opcode( cbuf, 0xC1 );\n-    emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW_ENC(dst_encoding) );\n-    emit_d8(cbuf, 0x1F );\n+    emit_opcode( masm, 0xC1 );\n+    emit_rm(masm, 0x3, 7, HIGH_FROM_LOW_ENC(dst_encoding) );\n+    emit_d8(masm, 0x1F );\n@@ -2689,1 +2648,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_opcode(masm, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2691,1 +2650,1 @@\n-    emit_opcode(cbuf, 0x50+$src$$reg  );\n+    emit_opcode(masm, 0x50+$src$$reg  );\n@@ -2693,4 +2652,4 @@\n-    emit_opcode(cbuf,0xdf);\n-    emit_d8(cbuf, 0x6C);\n-    emit_d8(cbuf, 0x24);\n-    emit_d8(cbuf, 0x00);\n+    emit_opcode(masm,0xdf);\n+    emit_d8(masm, 0x6C);\n+    emit_d8(masm, 0x24);\n+    emit_d8(masm, 0x00);\n@@ -2698,3 +2657,3 @@\n-    emit_opcode(cbuf, 0x83); \/\/ add  SP, #8\n-    emit_rm(cbuf, 0x3, 0x00, ESP_enc);\n-    emit_d8(cbuf, 0x8);\n+    emit_opcode(masm, 0x83); \/\/ add  SP, #8\n+    emit_rm(masm, 0x3, 0x00, ESP_enc);\n+    emit_d8(masm, 0x8);\n@@ -2705,2 +2664,2 @@\n-    emit_opcode( cbuf, 0xF7 );\n-    emit_rm( cbuf, 0x3, 0x5, $src1$$reg );\n+    emit_opcode( masm, 0xF7 );\n+    emit_rm( masm, 0x3, 0x5, $src1$$reg );\n@@ -2710,3 +2669,3 @@\n-      emit_opcode(cbuf, 0xC1);\n-      emit_rm(cbuf, 0x3, 7, $dst$$reg );\n-      emit_d8(cbuf, shift_count);\n+      emit_opcode(masm, 0xC1);\n+      emit_rm(masm, 0x3, 7, $dst$$reg );\n+      emit_d8(masm, shift_count);\n@@ -2719,1 +2678,1 @@\n-    emit_opcode(cbuf, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_opcode(masm, 0x50+HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2721,1 +2680,1 @@\n-    emit_opcode(cbuf, 0x50+$src$$reg  );\n+    emit_opcode(masm, 0x50+$src$$reg  );\n@@ -2723,4 +2682,4 @@\n-    emit_opcode(cbuf,0xdf);\n-    emit_d8(cbuf, 0x6C);\n-    emit_d8(cbuf, 0x24);\n-    emit_d8(cbuf, 0x00);\n+    emit_opcode(masm,0xdf);\n+    emit_d8(masm, 0x6C);\n+    emit_d8(masm, 0x24);\n+    emit_d8(masm, 0x00);\n@@ -2732,2 +2691,2 @@\n-    emit_opcode( cbuf, 0xF7 );\n-    emit_rm( cbuf, 0x3, 0x5, $src$$reg);\n+    emit_opcode( masm, 0xF7 );\n+    emit_rm( masm, 0x3, 0x5, $src$$reg);\n@@ -2739,2 +2698,2 @@\n-    emit_opcode( cbuf, 0xF7 );\n-    emit_rm( cbuf, 0x3, 0x4, $src$$reg);\n+    emit_opcode( masm, 0xF7 );\n+    emit_rm( masm, 0x3, 0x4, $src$$reg);\n@@ -2747,1 +2706,1 @@\n-    encode_Copy( cbuf, $tmp$$reg, $src$$reg );\n+    encode_Copy( masm, $tmp$$reg, $src$$reg );\n@@ -2749,3 +2708,3 @@\n-    emit_opcode( cbuf, 0x0F );\n-    emit_opcode( cbuf, 0xAF );\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode( masm, 0x0F );\n+    emit_opcode( masm, 0xAF );\n+    emit_rm( masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2753,1 +2712,1 @@\n-    encode_Copy( cbuf, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg) );\n+    encode_Copy( masm, HIGH_FROM_LOW_ENC($dst$$reg), HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2755,3 +2714,3 @@\n-    emit_opcode( cbuf, 0x0F );\n-    emit_opcode( cbuf, 0xAF );\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n+    emit_opcode( masm, 0x0F );\n+    emit_opcode( masm, 0xAF );\n+    emit_rm( masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $dst$$reg );\n@@ -2759,2 +2718,2 @@\n-    emit_opcode( cbuf, 0x03 );\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_opcode( masm, 0x03 );\n+    emit_rm( masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n@@ -2762,2 +2721,2 @@\n-    emit_opcode( cbuf, 0xF7 );\n-    emit_rm( cbuf, 0x3, 0x4, $src$$reg );\n+    emit_opcode( masm, 0xF7 );\n+    emit_rm( masm, 0x3, 0x4, $src$$reg );\n@@ -2765,2 +2724,2 @@\n-    emit_opcode( cbuf, 0x03 );\n-    emit_rm( cbuf, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $tmp$$reg );\n+    emit_opcode( masm, 0x03 );\n+    emit_rm( masm, 0x3, HIGH_FROM_LOW_ENC($dst$$reg), $tmp$$reg );\n@@ -2773,3 +2732,3 @@\n-    emit_opcode( cbuf, 0x6B );\n-    emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n-    emit_d8( cbuf, (int)$src$$constant );\n+    emit_opcode( masm, 0x6B );\n+    emit_rm( masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($dst$$reg) );\n+    emit_d8( masm, (int)$src$$constant );\n@@ -2777,2 +2736,2 @@\n-    emit_opcode(cbuf, 0xB8 + EDX_enc);\n-    emit_d32( cbuf, (int)$src$$constant );\n+    emit_opcode(masm, 0xB8 + EDX_enc);\n+    emit_d32( masm, (int)$src$$constant );\n@@ -2780,2 +2739,2 @@\n-    emit_opcode( cbuf, 0xF7 );\n-    emit_rm( cbuf, 0x3, 0x4, EDX_enc );\n+    emit_opcode( masm, 0xF7 );\n+    emit_rm( masm, 0x3, 0x4, EDX_enc );\n@@ -2783,2 +2742,2 @@\n-    emit_opcode( cbuf, 0x03 );\n-    emit_rm( cbuf, 0x3, EDX_enc, $tmp$$reg );\n+    emit_opcode( masm, 0x03 );\n+    emit_rm( masm, 0x3, EDX_enc, $tmp$$reg );\n@@ -2789,1 +2748,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n+    emit_opcode(masm, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2791,1 +2750,1 @@\n-    emit_opcode(cbuf,               0x50+$src1$$reg  );\n+    emit_opcode(masm,               0x50+$src1$$reg  );\n@@ -2793,1 +2752,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n+    emit_opcode(masm, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2795,1 +2754,1 @@\n-    emit_opcode(cbuf,               0x50+$src2$$reg  );\n+    emit_opcode(masm,               0x50+$src2$$reg  );\n@@ -2797,4 +2756,4 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n-    emit_opcode(cbuf,0xE8);       \/\/ Call into runtime\n-    emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::ldiv) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ set_inst_mark();\n+    emit_opcode(masm,0xE8);       \/\/ Call into runtime\n+    emit_d32_reloc(masm, (CAST_FROM_FN_PTR(address, SharedRuntime::ldiv) - __ pc()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ clear_inst_mark();\n@@ -2803,3 +2762,3 @@\n-    emit_opcode(cbuf, 0x83); \/\/ add  SP, #framesize\n-    emit_rm(cbuf, 0x3, 0x00, ESP_enc);\n-    emit_d8(cbuf, 4*4);\n+    emit_opcode(masm, 0x83); \/\/ add  SP, #framesize\n+    emit_rm(masm, 0x3, 0x00, ESP_enc);\n+    emit_d8(masm, 4*4);\n@@ -2810,1 +2769,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n+    emit_opcode(masm, HIGH_FROM_LOW_ENC(0x50+$src1$$reg) );\n@@ -2812,1 +2771,1 @@\n-    emit_opcode(cbuf,               0x50+$src1$$reg  );\n+    emit_opcode(masm,               0x50+$src1$$reg  );\n@@ -2814,1 +2773,1 @@\n-    emit_opcode(cbuf, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n+    emit_opcode(masm, HIGH_FROM_LOW_ENC(0x50+$src2$$reg) );\n@@ -2816,1 +2775,1 @@\n-    emit_opcode(cbuf,               0x50+$src2$$reg  );\n+    emit_opcode(masm,               0x50+$src2$$reg  );\n@@ -2818,4 +2777,4 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n-    emit_opcode(cbuf,0xE8);       \/\/ Call into runtime\n-    emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::lrem ) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ set_inst_mark();\n+    emit_opcode(masm,0xE8);       \/\/ Call into runtime\n+    emit_d32_reloc(masm, (CAST_FROM_FN_PTR(address, SharedRuntime::lrem ) - __ pc()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ clear_inst_mark();\n@@ -2824,3 +2783,3 @@\n-    emit_opcode(cbuf, 0x83); \/\/ add  SP, #framesize\n-    emit_rm(cbuf, 0x3, 0x00, ESP_enc);\n-    emit_d8(cbuf, 4*4);\n+    emit_opcode(masm, 0x83); \/\/ add  SP, #framesize\n+    emit_rm(masm, 0x3, 0x00, ESP_enc);\n+    emit_d8(masm, 4*4);\n@@ -2831,2 +2790,2 @@\n-    emit_opcode(cbuf, 0x8B);\n-    emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg);\n+    emit_opcode(masm, 0x8B);\n+    emit_rm(masm, 0x3, $tmp$$reg, $src$$reg);\n@@ -2834,2 +2793,2 @@\n-    emit_opcode(cbuf, 0x0B);\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n+    emit_opcode(masm, 0x0B);\n+    emit_rm(masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg));\n@@ -2840,2 +2799,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, $src1$$reg, $src2$$reg );\n@@ -2843,2 +2802,2 @@\n-    emit_cc(cbuf, 0x70, 0x5);\n-    emit_d8(cbuf,2);\n+    emit_cc(masm, 0x70, 0x5);\n+    emit_d8(masm,2);\n@@ -2846,2 +2805,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, HIGH_FROM_LOW_ENC($src1$$reg), HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2852,2 +2811,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, $src1$$reg, $src2$$reg );\n@@ -2855,2 +2814,2 @@\n-    emit_opcode( cbuf, 0x8B );\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src1$$reg) );\n+    emit_opcode( masm, 0x8B );\n+    emit_rm(masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src1$$reg) );\n@@ -2858,2 +2817,2 @@\n-    emit_opcode( cbuf, 0x1B );\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src2$$reg) );\n+    emit_opcode( masm, 0x1B );\n+    emit_rm(masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src2$$reg) );\n@@ -2864,2 +2823,2 @@\n-    emit_opcode(cbuf,0x33);  \/\/ XOR\n-    emit_rm(cbuf,0x3, $tmp$$reg, $tmp$$reg);\n+    emit_opcode(masm,0x33);  \/\/ XOR\n+    emit_rm(masm,0x3, $tmp$$reg, $tmp$$reg);\n@@ -2867,2 +2826,2 @@\n-    emit_opcode( cbuf, 0x3B );\n-    emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg );\n+    emit_opcode( masm, 0x3B );\n+    emit_rm(masm, 0x3, $tmp$$reg, $src$$reg );\n@@ -2870,2 +2829,2 @@\n-    emit_opcode( cbuf, 0x1B );\n-    emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg) );\n+    emit_opcode( masm, 0x1B );\n+    emit_rm(masm, 0x3, $tmp$$reg, HIGH_FROM_LOW_ENC($src$$reg) );\n@@ -2876,7 +2835,7 @@\n-    emit_opcode(cbuf,0xF7);    \/\/ NEG hi\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n-    emit_opcode(cbuf,0xF7);    \/\/ NEG lo\n-    emit_rm    (cbuf,0x3, 0x3,               $dst$$reg );\n-    emit_opcode(cbuf,0x83);    \/\/ SBB hi,0\n-    emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n-    emit_d8    (cbuf,0 );\n+    emit_opcode(masm,0xF7);    \/\/ NEG hi\n+    emit_rm    (masm,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_opcode(masm,0xF7);    \/\/ NEG lo\n+    emit_rm    (masm,0x3, 0x3,               $dst$$reg );\n+    emit_opcode(masm,0x83);    \/\/ SBB hi,0\n+    emit_rm    (masm,0x3, 0x3, HIGH_FROM_LOW_ENC($dst$$reg));\n+    emit_d8    (masm,0 );\n@@ -2886,1 +2845,1 @@\n-    emit_opcode(cbuf,0x5A);\n+    emit_opcode(masm,0x5A);\n@@ -2890,4 +2849,3 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n-    emit_opcode(cbuf, 0xE9);        \/\/ jmp    entry\n-    emit_d32_reloc(cbuf, (int)OptoRuntime::rethrow_stub() - ((int)cbuf.insts_end())-4,\n+    __ set_inst_mark();\n+    emit_opcode(masm, 0xE9);        \/\/ jmp    entry\n+    emit_d32_reloc(masm, (int)OptoRuntime::rethrow_stub() - ((int)__ pc())-4,\n@@ -2895,0 +2853,1 @@\n+    __ clear_inst_mark();\n@@ -2912,3 +2871,3 @@\n-    emit_opcode(cbuf,0xD9);            \/\/ FLDCW  trunc\n-    emit_opcode(cbuf,0x2D);\n-    emit_d32(cbuf,(int)StubRoutines::x86::addr_fpu_cntrl_wrd_trunc());\n+    emit_opcode(masm,0xD9);            \/\/ FLDCW  trunc\n+    emit_opcode(masm,0x2D);\n+    emit_d32(masm,(int)StubRoutines::x86::addr_fpu_cntrl_wrd_trunc());\n@@ -2916,3 +2875,3 @@\n-    emit_opcode(cbuf,0x83);            \/\/ SUB ESP,4\n-    emit_opcode(cbuf,0xEC);\n-    emit_d8(cbuf,0x04);\n+    emit_opcode(masm,0x83);            \/\/ SUB ESP,4\n+    emit_opcode(masm,0xEC);\n+    emit_d8(masm,0x04);\n@@ -2921,3 +2880,3 @@\n-    emit_opcode(cbuf,0xDB);            \/\/ FISTP [ESP]\n-    emit_opcode(cbuf,0x1C);\n-    emit_d8(cbuf,0x24);\n+    emit_opcode(masm,0xDB);            \/\/ FISTP [ESP]\n+    emit_opcode(masm,0x1C);\n+    emit_d8(masm,0x24);\n@@ -2925,3 +2884,3 @@\n-    emit_opcode(cbuf,0xD9);            \/\/ FLDCW   std\/24-bit mode\n-    emit_opcode(cbuf,0x2D);\n-    emit_d32( cbuf, Compile::current()->in_24_bit_fp_mode()\n+    emit_opcode(masm,0xD9);            \/\/ FLDCW   std\/24-bit mode\n+    emit_opcode(masm,0x2D);\n+    emit_d32( masm, Compile::current()->in_24_bit_fp_mode()\n@@ -2932,5 +2891,5 @@\n-    emit_opcode(cbuf,0x58);       \/\/ POP EAX\n-    emit_opcode(cbuf,0x3D);       \/\/ CMP EAX,imm\n-    emit_d32   (cbuf,0x80000000); \/\/         0x80000000\n-    emit_opcode(cbuf,0x75);       \/\/ JNE around_slow_call\n-    emit_d8    (cbuf,0x07);       \/\/ Size of slow_call\n+    emit_opcode(masm,0x58);       \/\/ POP EAX\n+    emit_opcode(masm,0x3D);       \/\/ CMP EAX,imm\n+    emit_d32   (masm,0x80000000); \/\/         0x80000000\n+    emit_opcode(masm,0x75);       \/\/ JNE around_slow_call\n+    emit_d8    (masm,0x07);       \/\/ Size of slow_call\n@@ -2938,2 +2897,2 @@\n-    emit_opcode(cbuf,0xD9 );      \/\/ FLD     ST(i)\n-    emit_d8    (cbuf,0xC0-1+$src$$reg );\n+    emit_opcode(masm,0xD9 );      \/\/ FLD     ST(i)\n+    emit_d8    (masm,0xC0-1+$src$$reg );\n@@ -2941,4 +2900,4 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n-    emit_opcode(cbuf,0xE8);       \/\/ Call into runtime\n-    emit_d32_reloc(cbuf, (StubRoutines::x86::d2i_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ set_inst_mark();\n+    emit_opcode(masm,0xE8);       \/\/ Call into runtime\n+    emit_d32_reloc(masm, (StubRoutines::x86::d2i_wrapper() - __ pc()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ clear_inst_mark();\n@@ -2950,3 +2909,3 @@\n-    emit_opcode(cbuf,0xD9);            \/\/ FLDCW  trunc\n-    emit_opcode(cbuf,0x2D);\n-    emit_d32(cbuf,(int)StubRoutines::x86::addr_fpu_cntrl_wrd_trunc());\n+    emit_opcode(masm,0xD9);            \/\/ FLDCW  trunc\n+    emit_opcode(masm,0x2D);\n+    emit_d32(masm,(int)StubRoutines::x86::addr_fpu_cntrl_wrd_trunc());\n@@ -2954,3 +2913,3 @@\n-    emit_opcode(cbuf,0x83);            \/\/ SUB ESP,8\n-    emit_opcode(cbuf,0xEC);\n-    emit_d8(cbuf,0x08);\n+    emit_opcode(masm,0x83);            \/\/ SUB ESP,8\n+    emit_opcode(masm,0xEC);\n+    emit_d8(masm,0x08);\n@@ -2959,3 +2918,3 @@\n-    emit_opcode(cbuf,0xDF);            \/\/ FISTP [ESP]\n-    emit_opcode(cbuf,0x3C);\n-    emit_d8(cbuf,0x24);\n+    emit_opcode(masm,0xDF);            \/\/ FISTP [ESP]\n+    emit_opcode(masm,0x3C);\n+    emit_d8(masm,0x24);\n@@ -2963,3 +2922,3 @@\n-    emit_opcode(cbuf,0xD9);            \/\/ FLDCW   std\/24-bit mode\n-    emit_opcode(cbuf,0x2D);\n-    emit_d32( cbuf, Compile::current()->in_24_bit_fp_mode()\n+    emit_opcode(masm,0xD9);            \/\/ FLDCW   std\/24-bit mode\n+    emit_opcode(masm,0x2D);\n+    emit_d32( masm, Compile::current()->in_24_bit_fp_mode()\n@@ -2970,11 +2929,11 @@\n-    emit_opcode(cbuf,0x58);       \/\/ POP EAX\n-    emit_opcode(cbuf,0x5A);       \/\/ POP EDX\n-    emit_opcode(cbuf,0x81);       \/\/ CMP EDX,imm\n-    emit_d8    (cbuf,0xFA);       \/\/ rdx\n-    emit_d32   (cbuf,0x80000000); \/\/         0x80000000\n-    emit_opcode(cbuf,0x75);       \/\/ JNE around_slow_call\n-    emit_d8    (cbuf,0x07+4);     \/\/ Size of slow_call\n-    emit_opcode(cbuf,0x85);       \/\/ TEST EAX,EAX\n-    emit_opcode(cbuf,0xC0);       \/\/ 2\/rax,\/rax,\n-    emit_opcode(cbuf,0x75);       \/\/ JNE around_slow_call\n-    emit_d8    (cbuf,0x07);       \/\/ Size of slow_call\n+    emit_opcode(masm,0x58);       \/\/ POP EAX\n+    emit_opcode(masm,0x5A);       \/\/ POP EDX\n+    emit_opcode(masm,0x81);       \/\/ CMP EDX,imm\n+    emit_d8    (masm,0xFA);       \/\/ rdx\n+    emit_d32   (masm,0x80000000); \/\/         0x80000000\n+    emit_opcode(masm,0x75);       \/\/ JNE around_slow_call\n+    emit_d8    (masm,0x07+4);     \/\/ Size of slow_call\n+    emit_opcode(masm,0x85);       \/\/ TEST EAX,EAX\n+    emit_opcode(masm,0xC0);       \/\/ 2\/rax,\/rax,\n+    emit_opcode(masm,0x75);       \/\/ JNE around_slow_call\n+    emit_d8    (masm,0x07);       \/\/ Size of slow_call\n@@ -2982,2 +2941,2 @@\n-    emit_opcode(cbuf,0xD9 );      \/\/ FLD     ST(i)\n-    emit_d8    (cbuf,0xC0-1+$src$$reg );\n+    emit_opcode(masm,0xD9 );      \/\/ FLD     ST(i)\n+    emit_d8    (masm,0xC0-1+$src$$reg );\n@@ -2985,4 +2944,4 @@\n-    MacroAssembler _masm(&cbuf);\n-    cbuf.set_insts_mark();\n-    emit_opcode(cbuf,0xE8);       \/\/ Call into runtime\n-    emit_d32_reloc(cbuf, (StubRoutines::x86::d2l_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ set_inst_mark();\n+    emit_opcode(masm,0xE8);       \/\/ Call into runtime\n+    emit_d32_reloc(masm, (StubRoutines::x86::d2l_wrapper() - __ pc()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );\n+    __ clear_inst_mark();\n@@ -2996,2 +2955,2 @@\n-    emit_opcode(cbuf, 0xD8);\n-    emit_opcode(cbuf, 0xC8 + $src1$$reg);\n+    emit_opcode(masm, 0xD8);\n+    emit_opcode(masm, 0xC8 + $src1$$reg);\n@@ -3002,2 +2961,2 @@\n-    emit_opcode(cbuf, 0xD8);\n-    emit_opcode(cbuf, 0xC0 + $src2$$reg);\n+    emit_opcode(masm, 0xD8);\n+    emit_opcode(masm, 0xC0 + $src2$$reg);\n@@ -3009,2 +2968,2 @@\n-    emit_opcode(cbuf, 0xDE);\n-    emit_opcode(cbuf, 0xC0 + $src2$$reg);\n+    emit_opcode(masm, 0xDE);\n+    emit_opcode(masm, 0xC0 + $src2$$reg);\n@@ -3016,2 +2975,2 @@\n-      emit_opcode(cbuf, 0xD8);\n-      emit_opcode(cbuf, 0xE0 + $src1$$reg);\n+      emit_opcode(masm, 0xD8);\n+      emit_opcode(masm, 0xE0 + $src1$$reg);\n@@ -3020,2 +2979,2 @@\n-      emit_opcode(cbuf, 0xD8);\n-      emit_opcode(cbuf, 0xF0 + $src2$$reg);\n+      emit_opcode(masm, 0xD8);\n+      emit_opcode(masm, 0xF0 + $src2$$reg);\n@@ -3027,2 +2986,2 @@\n-    emit_opcode(cbuf, 0xD8);\n-    emit_opcode(cbuf, 0xC0 + $src1$$reg);\n+    emit_opcode(masm, 0xD8);\n+    emit_opcode(masm, 0xC0 + $src1$$reg);\n@@ -3031,2 +2990,2 @@\n-    emit_opcode(cbuf, 0xD8);\n-    emit_opcode(cbuf, 0xC8 + $src2$$reg);\n+    emit_opcode(masm, 0xD8);\n+    emit_opcode(masm, 0xC8 + $src2$$reg);\n@@ -3039,2 +2998,2 @@\n-    emit_opcode(cbuf, 0xD8);\n-    emit_opcode(cbuf, 0xC0 + $src1$$reg);\n+    emit_opcode(masm, 0xD8);\n+    emit_opcode(masm, 0xC0 + $src1$$reg);\n@@ -3043,2 +3002,2 @@\n-    emit_opcode(cbuf, 0xDE);\n-    emit_opcode(cbuf, 0xC8 + $src2$$reg);\n+    emit_opcode(masm, 0xDE);\n+    emit_opcode(masm, 0xC8 + $src2$$reg);\n@@ -3049,1 +3008,1 @@\n-    emit_opcode(cbuf,0xDF);\n+    emit_opcode(masm,0xDF);\n@@ -3056,2 +3015,2 @@\n-    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n-    store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );\n+    encode_RegMem(masm, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n+    store_to_stackslot( masm, 0x0DF, 0x07, $dst$$disp );\n@@ -3065,3 +3024,3 @@\n-    store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );\n-    cbuf.set_insts_mark();            \/\/ Mark start of FIST in case $mem has an oop\n-    emit_opcode(cbuf,0xDF);\n+    store_to_stackslot( masm, 0x0DF, 0x05, $src$$disp );\n+    __ set_inst_mark();            \/\/ Mark start of FIST in case $mem has an oop\n+    emit_opcode(masm,0xDF);\n@@ -3074,1 +3033,2 @@\n-    encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n+    encode_RegMem(masm, rm_byte_opcode, base, index, scale, displace, disp_reloc);\n+    __ clear_inst_mark();\n@@ -5754,1 +5714,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5766,1 +5726,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5777,1 +5737,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5790,2 +5750,2 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),\n-              Pop_Reg_DPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),\n+              Pop_Reg_DPR(dst), ClearInstMark );\n@@ -5840,2 +5800,2 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),\n-              Pop_Reg_FPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -5852,1 +5812,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5862,1 +5822,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5872,1 +5832,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5882,1 +5842,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5892,1 +5852,1 @@\n-  ins_encode( OpcP, RegMem(dst,mem));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,mem), ClearInstMark);\n@@ -5901,1 +5861,1 @@\n-  ins_encode( LdImmI(dst, src) );\n+  ins_encode( SetInstMark, LdImmI(dst, src), ClearInstMark );\n@@ -5922,1 +5882,1 @@\n-  ins_encode( LdImmP(dst, src) );\n+  ins_encode( SetInstMark, LdImmP(dst, src), ClearInstMark );\n@@ -6080,1 +6040,1 @@\n-  ins_encode( OpcP, RegMem(dst,src));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,src), ClearInstMark);\n@@ -6091,1 +6051,1 @@\n-  ins_encode( OpcP, RegMem( dst, src ), OpcS, RegMem_Hi( dst, src ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, src ), OpcS, RegMem_Hi( dst, src ), ClearInstMark );\n@@ -6102,1 +6062,1 @@\n-  ins_encode( OpcP, RegMem(dst,src));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,src), ClearInstMark);\n@@ -6114,2 +6074,2 @@\n-  ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),\n-              Pop_Reg_FPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem_no_oop(0x00,src),\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -6127,2 +6087,2 @@\n-  ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),\n-              Pop_Reg_DPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem_no_oop(0x00,src),\n+              Pop_Reg_DPR(dst), ClearInstMark );\n@@ -6202,1 +6162,1 @@\n-  ins_encode( OpcP, RegMem( src, mem ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, mem ), ClearInstMark );\n@@ -6213,1 +6173,1 @@\n-  ins_encode( OpcS, OpcP, RegMem( src, mem ) );\n+  ins_encode( SetInstMark, OpcS, OpcP, RegMem( src, mem ), ClearInstMark );\n@@ -6224,1 +6184,1 @@\n-  ins_encode( OpcP, RegMem( src, mem ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, mem ), ClearInstMark );\n@@ -6237,1 +6197,1 @@\n-  ins_encode( OpcP, RegMem( src, mem ), OpcS, RegMem_Hi( src, mem ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, mem ), OpcS, RegMem_Hi( src, mem ), ClearInstMark );\n@@ -6265,1 +6225,1 @@\n-  ins_encode( OpcP, RegMem( EAX, mem ), enc_storeL_volatile(mem,src));\n+  ins_encode( SetInstMark, OpcP, RegMem( EAX, mem ), enc_storeL_volatile(mem,src), ClearInstMark);\n@@ -6312,1 +6272,1 @@\n-  ins_encode( OpcP, RegMem( src, mem ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, mem ), ClearInstMark );\n@@ -6323,1 +6283,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con32(src), ClearInstMark);\n@@ -6335,1 +6295,1 @@\n-  ins_encode( SizePrefix, OpcP, RMopc_Mem(0x00,mem),  Con16( src ));\n+  ins_encode( SetInstMark, SizePrefix, OpcP, RMopc_Mem(0x00,mem), Con16(src), ClearInstMark);\n@@ -6347,1 +6307,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con32( src ), ClearInstMark);\n@@ -6358,1 +6318,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con8or32(src), ClearInstMark);\n@@ -6369,1 +6329,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con8or32(src), ClearInstMark);\n@@ -6468,1 +6428,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32FPR_as_bits( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),  Con32FPR_as_bits(src), ClearInstMark);\n@@ -6480,1 +6440,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32F_as_bits( src ));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),  Con32F_as_bits(src), ClearInstMark);\n@@ -6514,1 +6474,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ), ClearInstMark );\n@@ -6689,1 +6649,1 @@\n-  ins_encode( enc_cmov(cop), RegMem( dst, src ) );\n+  ins_encode( SetInstMark, enc_cmov(cop), RegMem( dst, src ), ClearInstMark );\n@@ -6700,1 +6660,1 @@\n-  ins_encode( enc_cmov(cop), RegMem( dst, src ) );\n+  ins_encode( SetInstMark, enc_cmov(cop), RegMem( dst, src ), ClearInstMark );\n@@ -6998,1 +6958,1 @@\n-  ins_encode( OpcP, RegLea( dst, src0, src1 ) );\n+  ins_encode( SetInstMark, OpcP, RegLea( dst, src0, src1 ), ClearInstMark );\n@@ -7008,1 +6968,1 @@\n-  ins_encode( OpcP, RegLea( dst, src0, src1 ) );\n+  ins_encode( SetInstMark, OpcP, RegLea( dst, src0, src1 ), ClearInstMark );\n@@ -7053,1 +7013,1 @@\n-  ins_encode( OpcP, RegMem( dst, src) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, src), ClearInstMark );\n@@ -7064,1 +7024,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), ClearInstMark );\n@@ -7076,1 +7036,1 @@\n-  ins_encode( OpcSE( src ), RMopc_Mem(0x00,dst), Con8or32( src ) );\n+  ins_encode( SetInstMark, OpcSE( src ), RMopc_Mem(0x00,dst), Con8or32(src), ClearInstMark );\n@@ -7087,1 +7047,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,dst));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,dst), ClearInstMark);\n@@ -7098,1 +7058,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x01,dst));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x01,dst), ClearInstMark);\n@@ -7420,1 +7380,1 @@\n-  ins_encode( OpcP, RegMem( dst, src) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, src), ClearInstMark );\n@@ -7431,1 +7391,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), ClearInstMark );\n@@ -7537,1 +7497,1 @@\n-  ins_encode( OpcSE(imm), RegMem( dst, src ), Con8or32( imm ) );\n+  ins_encode( SetInstMark, OpcSE(imm), RegMem( dst, src ), Con8or32( imm ), ClearInstMark );\n@@ -7549,1 +7509,1 @@\n-  ins_encode( OpcS, OpcP, RegMem( dst, src) );\n+  ins_encode( SetInstMark, OpcS, OpcP, RegMem( dst, src), ClearInstMark );\n@@ -7954,1 +7914,1 @@\n-  ins_encode( OpcP, RMopc_Mem(secondary,dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(secondary,dst), ClearInstMark );\n@@ -7977,1 +7937,1 @@\n-  ins_encode( OpcP, RMopc_Mem(secondary, dst ), Con8or32( shift ) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(secondary, dst ), Con8or32(shift), ClearInstMark );\n@@ -8093,1 +8053,1 @@\n-  ins_encode( OpcP, RegMem( dst, src) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, src), ClearInstMark );\n@@ -8105,1 +8065,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), ClearInstMark );\n@@ -8118,1 +8078,1 @@\n-  ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );\n+  ins_encode( SetInstMark, OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32(src), ClearInstMark );\n@@ -8284,1 +8244,1 @@\n-  ins_encode( OpcP, RegMem( dst, src) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, src), ClearInstMark );\n@@ -8296,1 +8256,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), ClearInstMark );\n@@ -8309,1 +8269,1 @@\n-  ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );\n+  ins_encode( SetInstMark, OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32(src), ClearInstMark );\n@@ -8491,1 +8451,1 @@\n-  ins_encode( OpcP, RegMem(dst, src) );\n+  ins_encode( SetInstMark, OpcP, RegMem(dst, src), ClearInstMark );\n@@ -8503,1 +8463,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), ClearInstMark );\n@@ -8515,1 +8475,1 @@\n-  ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );\n+  ins_encode( SetInstMark, OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32(src), ClearInstMark );\n@@ -8801,1 +8761,1 @@\n-  ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem), ClearInstMark );\n@@ -8836,1 +8796,1 @@\n-  ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem), ClearInstMark );\n@@ -8879,1 +8839,1 @@\n-  ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem), ClearInstMark );\n@@ -9117,1 +9077,1 @@\n-  ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem), ClearInstMark );\n@@ -9163,1 +9123,1 @@\n-  ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );\n+  ins_encode( SetInstMark, OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem), ClearInstMark );\n@@ -9445,1 +9405,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -9474,1 +9434,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -9505,1 +9465,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9525,1 +9485,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9567,2 +9527,2 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),\n-              OpcP, RegOpc(dst) );\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src),\n+              OpcP, RegOpc(dst), ClearInstMark );\n@@ -9629,2 +9589,2 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),\n-              OpcP, RegOpc(dst) );\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src),\n+              OpcP, RegOpc(dst), ClearInstMark );\n@@ -9644,4 +9604,5 @@\n-  ins_encode( Opcode(0xDD), RMopc_Mem(0x00,dst),\n-              Opcode(0xD8), RegOpc(src),\n-              set_instruction_start,\n-              Opcode(0xDD), RMopc_Mem(0x03,dst) );\n+  ins_encode( SetInstMark, Opcode(0xDD), RMopc_Mem(0x00,dst),\n+              Opcode(0xD8), RegOpc(src), ClearInstMark,\n+              SetInstMark,\n+              Opcode(0xDD), RMopc_Mem(0x03,dst),\n+              ClearInstMark);\n@@ -9752,2 +9713,2 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),\n-              OpcP, RegOpc(dst) );\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src),\n+              OpcP, RegOpc(dst), ClearInstMark );\n@@ -9767,1 +9728,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,mem),\n@@ -9769,1 +9730,1 @@\n-              Pop_Reg_DPR(dst) );\n+              Pop_Reg_DPR(dst), ClearInstMark );\n@@ -10028,1 +9989,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -10057,1 +10018,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -10088,1 +10049,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -10108,1 +10069,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -10194,1 +10155,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10196,1 +10157,1 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst), ClearInstMark );\n@@ -10208,2 +10169,2 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),\n-              OpcP, RegOpc(dst) );\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src),\n+              OpcP, RegOpc(dst), ClearInstMark );\n@@ -10221,1 +10182,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src1),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src1),\n@@ -10223,1 +10184,1 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst), ClearInstMark );\n@@ -10235,2 +10196,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n-              set_instruction_start,\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10238,1 +10198,2 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst),\n+              ClearInstMark);\n@@ -10249,2 +10210,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n-              set_instruction_start,\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10252,1 +10212,2 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst),\n+              ClearInstMark);\n@@ -10328,1 +10289,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10330,1 +10291,1 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst), ClearInstMark );\n@@ -10342,1 +10303,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10344,1 +10305,1 @@\n-              Pop_Reg_FPR(dst) );\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -10355,2 +10316,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),\n-              set_instruction_start,\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,src2),\n@@ -10358,1 +10318,2 @@\n-              Pop_Mem_FPR(dst) );\n+              Pop_Mem_FPR(dst),\n+              ClearInstMark );\n@@ -10406,1 +10367,1 @@\n-  ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem1),\n+  ins_encode( SetInstMark, Opcode(tertiary), RMopc_Mem(0x00,mem1),\n@@ -10408,1 +10369,1 @@\n-              Pop_Reg_FPR(dst) );\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -10424,1 +10385,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem1),\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem1),\n@@ -10427,1 +10388,1 @@\n-              Pop_Reg_FPR(dst) );\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -10966,2 +10927,2 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),\n-              Pop_Reg_DPR(dst));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),\n+              Pop_Reg_DPR(dst), ClearInstMark);\n@@ -11004,2 +10965,2 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),\n-              Pop_Mem_FPR(dst));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),\n+              Pop_Mem_FPR(dst), ClearInstMark);\n@@ -11028,2 +10989,2 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,mem),\n-              Pop_Reg_FPR(dst));\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem),\n+              Pop_Reg_FPR(dst), ClearInstMark);\n@@ -11227,2 +11188,2 @@\n-  ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),\n-              Pop_Reg_FPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem_no_oop(0x00,src),\n+              Pop_Reg_FPR(dst), ClearInstMark );\n@@ -11266,1 +11227,1 @@\n-  ins_encode( OpcP, RegMem(dst,src), OpcS, RegMem_Hi(dst,src));\n+  ins_encode( SetInstMark, OpcP, RegMem(dst,src), OpcS, RegMem_Hi(dst,src), ClearInstMark);\n@@ -11317,1 +11278,1 @@\n-  ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ), ClearInstMark );\n@@ -11331,2 +11292,2 @@\n-  ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),\n-              Pop_Reg_DPR(dst) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem_no_oop(0x00,src),\n+              Pop_Reg_DPR(dst), ClearInstMark );\n@@ -12245,1 +12206,1 @@\n-  ins_encode( OpcP, RegMem( op1, op2) );\n+  ins_encode( SetInstMark, OpcP, RegMem( op1, op2), ClearInstMark );\n@@ -12273,1 +12234,1 @@\n-  ins_encode( OpcP, RegMem( src, mem ) );\n+  ins_encode( SetInstMark, OpcP, RegMem( src, mem ), ClearInstMark );\n@@ -12304,1 +12265,1 @@\n-  ins_encode( OpcP, RegMem( op1, op2) );\n+  ins_encode( SetInstMark, OpcP, RegMem( op1, op2), ClearInstMark );\n@@ -12342,1 +12303,1 @@\n-  ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );\n+  ins_encode( SetInstMark, OpcSErm( op1, op2 ), Con8or32( op2 ), ClearInstMark );\n@@ -12353,1 +12314,1 @@\n-  ins_encode( OpcP, RegMem( op1, op2) );\n+  ins_encode( SetInstMark, OpcP, RegMem( op1, op2), ClearInstMark );\n@@ -12376,1 +12337,1 @@\n-  ins_encode( OpcP, RegMem( op1, op2) );\n+  ins_encode( SetInstMark, OpcP, RegMem( op1, op2), ClearInstMark );\n@@ -12401,1 +12362,1 @@\n-  ins_encode( OpcP, RMopc_Mem(0x00,op), Con_d32(0xFFFFFFFF) );\n+  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,op), Con_d32(0xFFFFFFFF), ClearInstMark );\n@@ -12969,1 +12930,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src), ClearInstMark );\n@@ -13008,1 +12969,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem( dst, src ) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem( dst, src ), ClearInstMark );\n@@ -13178,1 +13139,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src), ClearInstMark );\n@@ -13199,1 +13160,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem( dst, src ) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem( dst, src ), ClearInstMark );\n@@ -13379,1 +13340,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src), ClearInstMark );\n@@ -13418,1 +13379,1 @@\n-  ins_encode( enc_cmov(cmp), RegMem( dst, src ) );\n+  ins_encode( SetInstMark, enc_cmov(cmp), RegMem( dst, src ), ClearInstMark );\n@@ -13765,0 +13726,1 @@\n+    __ set_inst_mark();\n@@ -13766,0 +13728,1 @@\n+    __ clear_inst_mark();\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":840,"deletions":877,"binary":false,"changes":1717,"status":"modified"},{"patch":"@@ -299,0 +299,3 @@\n+\/\/ Singleton class for R11 long register\n+reg_class long_r11_reg(R11, R11_H);\n+\n@@ -361,1 +364,1 @@\n-#define __ _masm.\n+#define __ masm->\n@@ -527,1 +530,1 @@\n-static void emit_cmpfp_fixup(MacroAssembler& _masm) {\n+static void emit_cmpfp_fixup(MacroAssembler* masm) {\n@@ -547,1 +550,1 @@\n-static void emit_cmpfp3(MacroAssembler& _masm, Register dst) {\n+static void emit_cmpfp3(MacroAssembler* masm, Register dst) {\n@@ -566,1 +569,1 @@\n-static void emit_fp_min_max(MacroAssembler& _masm, XMMRegister dst,\n+static void emit_fp_min_max(MacroAssembler* masm, XMMRegister dst,\n@@ -651,1 +654,1 @@\n-void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {\n+void MachConstantBaseNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const {\n@@ -727,1 +730,1 @@\n-void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachPrologNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -729,1 +732,0 @@\n-  C2_MacroAssembler _masm(&cbuf);\n@@ -741,1 +743,1 @@\n-  C->output()->set_frame_complete(cbuf.insts_size());\n+  C->output()->set_frame_complete(__ offset());\n@@ -787,1 +789,1 @@\n-void MachEpilogNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+void MachEpilogNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n@@ -790,1 +792,0 @@\n-  MacroAssembler _masm(&cbuf);\n@@ -807,1 +808,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -857,1 +857,1 @@\n-static void vec_mov_helper(CodeBuffer *cbuf, int src_lo, int dst_lo,\n+static void vec_mov_helper(C2_MacroAssembler *masm, int src_lo, int dst_lo,\n@@ -860,1 +860,1 @@\n-void vec_spill_helper(CodeBuffer *cbuf, bool is_load,\n+void vec_spill_helper(C2_MacroAssembler *masm, bool is_load,\n@@ -863,1 +863,1 @@\n-static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,\n+static void vec_stack_to_stack_helper(C2_MacroAssembler *masm, int src_offset,\n@@ -865,2 +865,1 @@\n-  if (cbuf) {\n-    MacroAssembler _masm(cbuf);\n+  if (masm) {\n@@ -942,1 +941,1 @@\n-uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,\n+uint MachSpillCopyNode::implementation(C2_MacroAssembler* masm,\n@@ -946,1 +945,1 @@\n-  assert(cbuf != nullptr || st  != nullptr, \"sanity\");\n+  assert(masm != nullptr || st  != nullptr, \"sanity\");\n@@ -973,1 +972,1 @@\n-      vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);\n+      vec_stack_to_stack_helper(masm, src_offset, dst_offset, ireg, st);\n@@ -975,1 +974,1 @@\n-      vec_mov_helper(cbuf, src_first, dst_first, src_second, dst_second, ireg, st);\n+      vec_mov_helper(masm, src_first, dst_first, src_second, dst_second, ireg, st);\n@@ -978,1 +977,1 @@\n-      vec_spill_helper(cbuf, false, stack_offset, src_first, ireg, st);\n+      vec_spill_helper(masm, false, stack_offset, src_first, ireg, st);\n@@ -981,1 +980,1 @@\n-      vec_spill_helper(cbuf, true,  stack_offset, dst_first, ireg, st);\n+      vec_spill_helper(masm, true,  stack_offset, dst_first, ireg, st);\n@@ -997,2 +996,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1015,2 +1013,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1038,2 +1035,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1053,2 +1049,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1071,2 +1066,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1087,2 +1081,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1105,2 +1098,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1126,2 +1118,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1141,2 +1132,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1158,2 +1148,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1174,2 +1163,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1192,2 +1180,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1206,2 +1193,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1222,2 +1208,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1244,2 +1229,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1259,2 +1243,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1276,2 +1259,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1290,2 +1272,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1307,2 +1288,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1322,2 +1302,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1346,2 +1325,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1362,2 +1340,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1379,2 +1356,1 @@\n-        if (cbuf) {\n-          MacroAssembler _masm(cbuf);\n+        if (masm) {\n@@ -1408,2 +1384,2 @@\n-void MachSpillCopyNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n-  implementation(&cbuf, ra_, false, nullptr);\n+void MachSpillCopyNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n+  implementation(masm, ra_, false, nullptr);\n@@ -1427,1 +1403,1 @@\n-void BoxLockNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+void BoxLockNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n@@ -1432,2 +1408,1 @@\n-  MacroAssembler masm(&cbuf);\n-  masm.lea(as_Register(reg), Address(rsp, offset));\n+  __ lea(as_Register(reg), Address(rsp, offset));\n@@ -1450,1 +1425,1 @@\n-void MachVEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+void MachVEPNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n@@ -1452,2 +1427,2 @@\n-  C2_MacroAssembler _masm(&cbuf);\n-  uint insts_size = cbuf.insts_size();\n+  CodeBuffer* cbuf = masm->code();\n+  uint insts_size = cbuf->insts_size();\n@@ -1478,1 +1453,1 @@\n-  int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) & 0x3);\n+  int nops_cnt = 4 - ((cbuf->insts_size() - insts_size) & 0x3);\n@@ -1500,1 +1475,1 @@\n-void MachUEPNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const\n+void MachUEPNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n@@ -1502,2 +1477,1 @@\n-  MacroAssembler masm(&cbuf);\n-  masm.ic_check(InteriorEntryAlignment);\n+  __ ic_check(InteriorEntryAlignment);\n@@ -1675,1 +1649,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -1731,1 +1704,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -1773,1 +1745,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -1784,1 +1755,1 @@\n-    debug_only(int off0 = cbuf.insts_size());\n+    debug_only(int off0 = __ offset());\n@@ -1789,1 +1760,0 @@\n-      MacroAssembler _masm(&cbuf);\n@@ -1792,1 +1762,1 @@\n-    debug_only(int off1 = cbuf.insts_size());\n+    debug_only(int off1 = __ offset());\n@@ -1798,1 +1768,0 @@\n-    MacroAssembler _masm(&cbuf);\n@@ -1809,2 +1778,0 @@\n-    MacroAssembler _masm(&cbuf);\n-\n@@ -1819,1 +1786,1 @@\n-      int method_index = resolved_method_index(cbuf);\n+      int method_index = resolved_method_index(masm);\n@@ -1828,1 +1795,1 @@\n-        cbuf.shared_stub_to_interp_for(_method, call_offset);\n+        __ code()->shared_stub_to_interp_for(_method, call_offset);\n@@ -1831,1 +1798,2 @@\n-        address stub = CompiledDirectCall::emit_to_interp_stub(cbuf, mark);\n+        address stub = CompiledDirectCall::emit_to_interp_stub(masm, mark);\n+        __ clear_inst_mark();\n@@ -1842,2 +1810,1 @@\n-    MacroAssembler _masm(&cbuf);\n-    __ ic_call((address)$meth$$method, resolved_method_index(cbuf));\n+    __ ic_call((address)$meth$$method, resolved_method_index(masm));\n@@ -2715,0 +2682,10 @@\n+operand r11_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_r11_reg));\n+  match(RegL);\n+  match(rRegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -4379,1 +4356,1 @@\n-    emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n@@ -4404,1 +4381,1 @@\n-    emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n@@ -4429,1 +4406,1 @@\n-    emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n@@ -4454,1 +4431,1 @@\n-    emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n+    emit_fp_min_max(masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,\n@@ -9773,1 +9750,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -9824,1 +9801,1 @@\n-    emit_cmpfp_fixup(_masm);\n+    emit_cmpfp_fixup(masm);\n@@ -9877,1 +9854,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9898,1 +9875,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9918,1 +9895,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9939,1 +9916,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9960,1 +9937,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -9980,1 +9957,1 @@\n-    emit_cmpfp3(_masm, $dst$$Register);\n+    emit_cmpfp3(masm, $dst$$Register);\n@@ -12362,0 +12339,25 @@\n+instruct partialSubtypeCheckConstSuper(rsi_RegP sub, rax_RegP super_reg, immP super_con, rdi_RegP result,\n+                                       rdx_RegL temp1, rcx_RegL temp2, rbx_RegP temp3, r11_RegL temp4,\n+                                       rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub (Binary super_reg super_con)));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n+\n+  ins_cost(700);  \/\/ smaller than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, super\" %}\n+\n+  ins_encode %{\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register, $temp1$$Register, $temp2$$Register,\n+                                       $temp3$$Register, $temp4$$Register, $result$$Register,\n+                                       super_klass_slot);\n+    } else {\n+      __ call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n+    }\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":108,"deletions":106,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -279,0 +279,1 @@\n+  _use_secondary_supers_table = UseSecondarySupersTable;\n@@ -343,0 +344,1 @@\n+  st->print_cr(\"- use_secondary_supers_table:     %d\", _use_secondary_supers_table);\n@@ -364,1 +366,0 @@\n-  st->print_cr(\"- ptrmap_size_in_bits:            \" SIZE_FORMAT, _ptrmap_size_in_bits);\n@@ -1528,16 +1529,0 @@\n-BitMapView FileMapRegion::bitmap_view(bool is_oopmap) {\n-  char* bitmap_base = FileMapInfo::current_info()->map_bitmap_region();\n-  bitmap_base += is_oopmap ? _oopmap_offset : _ptrmap_offset;\n-  size_t size_in_bits = is_oopmap ? _oopmap_size_in_bits : _ptrmap_size_in_bits;\n-  return BitMapView((BitMap::bm_word_t*)(bitmap_base), size_in_bits);\n-}\n-\n-BitMapView FileMapRegion::oopmap_view() {\n-  return bitmap_view(true);\n-}\n-\n-BitMapView FileMapRegion::ptrmap_view() {\n-  assert(has_ptrmap(), \"must be\");\n-  return bitmap_view(false);\n-}\n-\n@@ -1572,0 +1557,21 @@\n+BitMapView FileMapInfo::bitmap_view(int region_index, bool is_oopmap) {\n+  FileMapRegion* r = region_at(region_index);\n+  char* bitmap_base = is_static() ? FileMapInfo::current_info()->map_bitmap_region() : FileMapInfo::dynamic_info()->map_bitmap_region();\n+  bitmap_base += is_oopmap ? r->oopmap_offset() : r->ptrmap_offset();\n+  size_t size_in_bits = is_oopmap ? r->oopmap_size_in_bits() : r->ptrmap_size_in_bits();\n+\n+  log_debug(cds, reloc)(\"mapped %s relocation %smap @ \" INTPTR_FORMAT \" (\" SIZE_FORMAT \" bits)\",\n+                        region_name(region_index), is_oopmap ? \"oop\" : \"ptr\",\n+                        p2i(bitmap_base), size_in_bits);\n+\n+  return BitMapView((BitMap::bm_word_t*)(bitmap_base), size_in_bits);\n+}\n+\n+BitMapView FileMapInfo::oopmap_view(int region_index) {\n+    return bitmap_view(region_index, \/*is_oopmap*\/true);\n+  }\n+\n+BitMapView FileMapInfo::ptrmap_view(int region_index) {\n+  return bitmap_view(region_index, \/*is_oopmap*\/false);\n+}\n+\n@@ -1585,0 +1591,2 @@\n+  st->print_cr(\"- ptrmap_offset:                  \" SIZE_FORMAT_X, _ptrmap_offset);\n+  st->print_cr(\"- ptrmap_size_in_bits:            \" SIZE_FORMAT, _ptrmap_size_in_bits);\n@@ -1661,1 +1669,1 @@\n-char* FileMapInfo::write_bitmap_region(const CHeapBitMap* ptrmap, ArchiveHeapInfo* heap_info,\n+char* FileMapInfo::write_bitmap_region(const CHeapBitMap* rw_ptrmap, const CHeapBitMap* ro_ptrmap, ArchiveHeapInfo* heap_info,\n@@ -1663,1 +1671,1 @@\n-  size_in_bytes = ptrmap->size_in_bytes();\n+  size_in_bytes = rw_ptrmap->size_in_bytes() + ro_ptrmap->size_in_bytes();\n@@ -1677,2 +1685,3 @@\n-  \/\/ The bitmap region contains up to 3 parts:\n-  \/\/ ptrmap:              metaspace pointers inside the ro\/rw regions\n+  \/\/ The bitmap region contains up to 4 parts:\n+  \/\/ rw_ptrmap:           metaspace pointers inside the read-write region\n+  \/\/ ro_ptrmap:           metaspace pointers inside the read-only region\n@@ -1683,2 +1692,6 @@\n-  written = write_bitmap(ptrmap, buffer, written);\n-  header()->set_ptrmap_size_in_bits(ptrmap->size());\n+\n+  region_at(MetaspaceShared::rw)->init_ptrmap(0, rw_ptrmap->size());\n+  written = write_bitmap(rw_ptrmap, buffer, written);\n+\n+  region_at(MetaspaceShared::ro)->init_ptrmap(written, ro_ptrmap->size());\n+  written = write_bitmap(ro_ptrmap, buffer, written);\n@@ -1979,3 +1992,5 @@\n-    size_t ptrmap_size_in_bits = header()->ptrmap_size_in_bits();\n-    log_debug(cds, reloc)(\"mapped relocation bitmap @ \" INTPTR_FORMAT \" (\" SIZE_FORMAT \" bits)\",\n-                          p2i(bitmap_base), ptrmap_size_in_bits);\n+    BitMapView rw_ptrmap = ptrmap_view(MetaspaceShared::rw);\n+    BitMapView ro_ptrmap = ptrmap_view(MetaspaceShared::ro);\n+\n+    FileMapRegion* rw_region = first_core_region();\n+    FileMapRegion* ro_region = last_core_region();\n@@ -1983,1 +1998,3 @@\n-    BitMapView ptrmap((BitMap::bm_word_t*)bitmap_base, ptrmap_size_in_bits);\n+    \/\/ Patch all pointers inside the RW region\n+    address rw_patch_base = (address)rw_region->mapped_base();\n+    address rw_patch_end  = (address)rw_region->mapped_end();\n@@ -1985,3 +2002,3 @@\n-    \/\/ Patch all pointers in the mapped region that are marked by ptrmap.\n-    address patch_base = (address)mapped_base();\n-    address patch_end  = (address)mapped_end();\n+    \/\/ Patch all pointers inside the RO region\n+    address ro_patch_base = (address)ro_region->mapped_base();\n+    address ro_patch_end  = (address)ro_region->mapped_end();\n@@ -2000,1 +2017,3 @@\n-    SharedDataRelocator patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,\n+    SharedDataRelocator rw_patcher((address*)rw_patch_base, (address*)rw_patch_end, valid_old_base, valid_old_end,\n+                                valid_new_base, valid_new_end, addr_delta);\n+    SharedDataRelocator ro_patcher((address*)ro_patch_base, (address*)ro_patch_end, valid_old_base, valid_old_end,\n@@ -2002,1 +2021,2 @@\n-    ptrmap.iterate(&patcher);\n+    rw_ptrmap.iterate(&rw_patcher);\n+    ro_ptrmap.iterate(&ro_patcher);\n@@ -2513,0 +2533,5 @@\n+  if (! _use_secondary_supers_table && UseSecondarySupersTable) {\n+    log_warning(cds)(\"The shared archive was created without UseSecondarySupersTable.\");\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":57,"deletions":32,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -135,1 +135,0 @@\n-  BitMapView bitmap_view(bool is_oopmap);\n@@ -162,0 +161,2 @@\n+  size_t ptrmap_offset()            const { return _ptrmap_offset; }\n+  size_t ptrmap_size_in_bits()      const { return _ptrmap_size_in_bits; }\n@@ -171,2 +172,0 @@\n-  BitMapView oopmap_view();\n-  BitMapView ptrmap_view();\n@@ -224,0 +223,1 @@\n+  bool    _use_secondary_supers_table;            \/\/ save the flag UseSecondarySupersTable\n@@ -258,1 +258,0 @@\n-  size_t _ptrmap_size_in_bits;          \/\/ Size of pointer relocation bitmap\n@@ -301,1 +300,0 @@\n-  size_t ptrmap_size_in_bits()             const { return _ptrmap_size_in_bits; }\n@@ -316,1 +314,0 @@\n-  void set_ptrmap_size_in_bits(size_t s)         { _ptrmap_size_in_bits = s; }\n@@ -481,1 +478,1 @@\n-  char* write_bitmap_region(const CHeapBitMap* ptrmap, ArchiveHeapInfo* heap_info,\n+  char* write_bitmap_region(const CHeapBitMap* rw_ptrmap, const CHeapBitMap* ro_ptrmap, ArchiveHeapInfo* heap_info,\n@@ -564,0 +561,4 @@\n+  BitMapView bitmap_view(int region_index, bool is_oopmap);\n+  BitMapView oopmap_view(int region_index);\n+  BitMapView ptrmap_view(int region_index);\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -518,3 +518,0 @@\n-  \/\/ Initialize random for updating the hash of symbols\n-  os::init_random(0x12345678);\n-\n@@ -670,0 +667,1 @@\n+      CLEAR_PENDING_EXCEPTION;\n@@ -674,0 +672,1 @@\n+      CLEAR_PENDING_EXCEPTION;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+PerfCounter*    ClassLoader::_perf_secondary_hash_time = nullptr;\n@@ -1365,0 +1366,1 @@\n+    NEWPERFTICKCOUNTER(_perf_secondary_hash_time, SUN_CLS, \"secondarySuperHashTime\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2103,2 +2103,7 @@\n-oop java_lang_Throwable::cause(oop throwable) {\n-  return throwable->obj_field(_cause_offset);\n+const char* java_lang_Throwable::message_as_utf8(oop throwable) {\n+  oop msg = java_lang_Throwable::message(throwable);\n+  const char* msg_utf8 = nullptr;\n+  if (msg != nullptr) {\n+    msg_utf8 = java_lang_String::as_utf8_string(msg);\n+  }\n+  return msg_utf8;\n@@ -2107,8 +2112,2 @@\n-\/\/ Return Symbol for detailed_message or null\n-Symbol* java_lang_Throwable::detail_message(oop throwable) {\n-  PreserveExceptionMark pm(Thread::current());\n-  oop detailed_message = java_lang_Throwable::message(throwable);\n-  if (detailed_message != nullptr) {\n-    return java_lang_String::as_symbol(detailed_message);\n-  }\n-  return nullptr;\n+oop java_lang_Throwable::cause(oop throwable) {\n+  return throwable->obj_field(_cause_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -604,1 +604,1 @@\n-  static int get_detailMessage_offset() { CHECK_INIT(_detailMessage_offset); }\n+  static int get_detailMessage_offset() { CHECK_INIT(_detailMessage_offset); }\n@@ -607,1 +607,1 @@\n-  static oop cause(oop throwable);\n+  static const char* message_as_utf8(oop throwable);\n@@ -609,1 +609,3 @@\n-  static Symbol* detail_message(oop throwable);\n+\n+  static oop cause(oop throwable);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1837,2 +1837,2 @@\n-                                            Symbol* error, Symbol* message,\n-                                            Symbol* cause, Symbol* cause_msg) {\n+                                            Symbol* error, const char* message,\n+                                            Symbol* cause, const char* cause_msg) {\n@@ -1855,1 +1855,2 @@\n-                                                Symbol** message, Symbol** cause, Symbol** cause_msg) {\n+                                                const char** message,\n+                                                Symbol** cause, const char** cause_msg) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -277,2 +277,3 @@\n-  static void add_resolution_error(const constantPoolHandle& pool, int which, Symbol* error,\n-                                   Symbol* message, Symbol* cause = nullptr, Symbol* cause_msg = nullptr);\n+  static void add_resolution_error(const constantPoolHandle& pool, int which,\n+                                   Symbol* error, const char* message,\n+                                   Symbol* cause = nullptr, const char* cause_msg = nullptr);\n@@ -281,2 +282,2 @@\n-                                       Symbol** message, Symbol** cause, Symbol** cause_msg);\n-\n+                                       const char** message,\n+                                       Symbol** cause, const char** cause_msg);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-    \/\/ Least significant bits of _handle are always 0, so we use these as\n-    \/\/ the indicator that the _handle is valid.  Otherwise, the _data field\n+    \/\/ Least significant 2 bits of _sym are always 0, so we use these as\n+    \/\/ the indicator that _sym is a valid pointer.  Otherwise, the _data field\n@@ -55,1 +55,1 @@\n-    \/\/ and the lower bits on oops aren't 0, the assert in the constructor\n+    \/\/ and the lower 2 bits of Symbol* aren't 0, the assert in the constructor\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/c2_MacroAssembler.hpp\"\n@@ -188,1 +189,1 @@\n-  static address emit_to_interp_stub(CodeBuffer &cbuf, address mark = nullptr);\n+  static address emit_to_interp_stub(MacroAssembler *masm, address mark = nullptr);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1244,0 +1244,1 @@\n+    _num_stack_arg_slots     = _method->constMethod()->num_stack_arg_slots();\n@@ -1394,6 +1395,7 @@\n-    _entry_bci      = entry_bci;\n-    _compile_id     = compile_id;\n-    _compiler_type  = type;\n-    _comp_level     = comp_level;\n-    _orig_pc_offset = orig_pc_offset;\n-    _gc_epoch       = CodeCache::gc_epoch();\n+    _entry_bci               = entry_bci;\n+    _num_stack_arg_slots     = entry_bci != InvocationEntryBci ? 0 : _method->constMethod()->num_stack_arg_slots();\n+    _compile_id              = compile_id;\n+    _compiler_type           = type;\n+    _comp_level              = comp_level;\n+    _orig_pc_offset          = orig_pc_offset;\n+    _gc_epoch                = CodeCache::gc_epoch();\n@@ -2060,1 +2062,1 @@\n-  Events::log(Thread::current(), \"flushing nmethod \" INTPTR_FORMAT, p2i(this));\n+  Events::log_nmethod_flush(Thread::current(), \"flushing %s nmethod \" INTPTR_FORMAT, is_osr_method() ? \"osr\" : \"\", p2i(this));\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -250,0 +250,2 @@\n+  int _num_stack_arg_slots;               \/\/ Number of arguments passed on the stack\n+\n@@ -812,0 +814,4 @@\n+  int num_stack_arg_slots(bool rounded = true) const {\n+    return rounded ? align_up(_num_stack_arg_slots, 2) : _num_stack_arg_slots;\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -447,1 +447,1 @@\n-  region->update_bot_for_obj(obj_start, word_sz);\n+  region->update_bot_for_block(obj_start, obj_start + word_sz);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -646,0 +646,32 @@\n+size_t ParallelCompactData::live_words_in_space(const MutableSpace* space,\n+                                                HeapWord** full_region_prefix_end) {\n+  size_t cur_region = addr_to_region_idx(space->bottom());\n+  const size_t end_region = addr_to_region_idx(region_align_up(space->top()));\n+  size_t live_words = 0;\n+  if (full_region_prefix_end == nullptr) {\n+    for (\/* empty *\/; cur_region < end_region; ++cur_region) {\n+      live_words += _region_data[cur_region].data_size();\n+    }\n+  } else {\n+    bool first_set = false;\n+    for (\/* empty *\/; cur_region < end_region; ++cur_region) {\n+      size_t live_words_in_region = _region_data[cur_region].data_size();\n+      if (!first_set && live_words_in_region < RegionSize) {\n+        *full_region_prefix_end = region_to_addr(cur_region);\n+        first_set = true;\n+      }\n+      live_words += live_words_in_region;\n+    }\n+    if (!first_set) {\n+      \/\/ All regions are full of live objs.\n+      assert(is_region_aligned(space->top()), \"inv\");\n+      *full_region_prefix_end = space->top();\n+    }\n+    assert(*full_region_prefix_end != nullptr, \"postcondition\");\n+    assert(is_region_aligned(*full_region_prefix_end), \"inv\");\n+    assert(*full_region_prefix_end >= space->bottom(), \"in-range\");\n+    assert(*full_region_prefix_end <= space->top(), \"in-range\");\n+  }\n+  return live_words;\n+}\n+\n@@ -986,44 +1018,2 @@\n-ParallelCompactData::RegionData*\n-PSParallelCompact::first_dead_space_region(const RegionData* beg,\n-                                           const RegionData* end)\n-{\n-  const size_t region_size = ParallelCompactData::RegionSize;\n-  ParallelCompactData& sd = summary_data();\n-  size_t left = sd.region(beg);\n-  size_t right = end > beg ? sd.region(end) - 1 : left;\n-\n-  \/\/ Binary search.\n-  while (left < right) {\n-    \/\/ Equivalent to (left + right) \/ 2, but does not overflow.\n-    const size_t middle = left + (right - left) \/ 2;\n-    RegionData* const middle_ptr = sd.region(middle);\n-    HeapWord* const dest = middle_ptr->destination();\n-    HeapWord* const addr = sd.region_to_addr(middle);\n-    assert(dest != nullptr, \"sanity\");\n-    assert(dest <= addr, \"must move left\");\n-\n-    if (middle > left && dest < addr) {\n-      right = middle - 1;\n-    } else if (middle < right && middle_ptr->data_size() == region_size) {\n-      left = middle + 1;\n-    } else {\n-      return middle_ptr;\n-    }\n-  }\n-  return sd.region(left);\n-}\n-\n-\/\/ Return the address of the end of the dense prefix, a.k.a. the start of the\n-\/\/ compacted region.  The address is always on a region boundary.\n-\/\/\n-\/\/ Completely full regions at the left are skipped, since no compaction can\n-\/\/ occur in those regions.  Then the maximum amount of dead wood to allow is\n-\/\/ computed, based on the density (amount live \/ capacity) of the generation;\n-\/\/ the region with approximately that amount of dead space to the left is\n-\/\/ identified as the limit region.  Regions between the last completely full\n-\/\/ region and the limit region are scanned and the one that has the best\n-\/\/ (maximum) reclaimed_ratio() is selected.\n-HeapWord*\n-PSParallelCompact::compute_dense_prefix(const SpaceId id,\n-                                        bool maximum_compaction)\n-{\n+HeapWord* PSParallelCompact::compute_dense_prefix_for_old_space(MutableSpace* old_space,\n+                                                                HeapWord* full_region_prefix_end) {\n@@ -1033,33 +1023,1 @@\n-  const MutableSpace* const space = _space_info[id].space();\n-  HeapWord* const top = space->top();\n-  HeapWord* const top_aligned_up = sd.region_align_up(top);\n-  HeapWord* const new_top = _space_info[id].new_top();\n-  HeapWord* const new_top_aligned_up = sd.region_align_up(new_top);\n-  HeapWord* const bottom = space->bottom();\n-  const RegionData* const beg_cp = sd.addr_to_region_ptr(bottom);\n-  const RegionData* const top_cp = sd.addr_to_region_ptr(top_aligned_up);\n-  const RegionData* const new_top_cp =\n-    sd.addr_to_region_ptr(new_top_aligned_up);\n-\n-  \/\/ Skip full regions at the beginning of the space--they are necessarily part\n-  \/\/ of the dense prefix.\n-  const RegionData* const full_cp = first_dead_space_region(beg_cp, new_top_cp);\n-  assert(full_cp->destination() == sd.region_to_addr(full_cp) ||\n-         space->is_empty(), \"no dead space allowed to the left\");\n-  assert(full_cp->data_size() < region_size || full_cp == new_top_cp - 1,\n-         \"region must have dead space\");\n-\n-  \/\/ The gc number is saved whenever a maximum compaction is done, and used to\n-  \/\/ determine when the maximum compaction interval has expired.  This avoids\n-  \/\/ successive max compactions for different reasons.\n-  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n-  assert(total_invocations >= _maximum_compaction_gc_num, \"sanity\");\n-  const size_t gcs_since_max = total_invocations - _maximum_compaction_gc_num;\n-  const bool interval_ended = gcs_since_max > HeapMaximumCompactionInterval ||\n-    total_invocations == HeapFirstMaximumCompactionCount;\n-  if (maximum_compaction || full_cp == top_cp || interval_ended) {\n-    _maximum_compaction_gc_num = total_invocations;\n-    return sd.region_to_addr(full_cp);\n-  }\n-\n-  const RegionData* const start_region = full_cp;\n+  const RegionData* const start_region = sd.addr_to_region_ptr(full_region_prefix_end);\n@@ -1069,1 +1027,1 @@\n-  const RegionData* const end_region = sd.addr_to_region_ptr(space->top());\n+  const RegionData* const end_region = sd.addr_to_region_ptr(old_space->top());\n@@ -1072,1 +1030,1 @@\n-  size_t max_waste = space->capacity_in_words() * (MarkSweepDeadRatio \/ 100.0);\n+  size_t max_waste = old_space->capacity_in_words() * (MarkSweepDeadRatio \/ 100.0);\n@@ -1085,2 +1043,2 @@\n-  assert(prefix_end >= sd.region_to_addr(full_cp), \"in-range\");\n-  assert(prefix_end <= space->top(), \"in-range\");\n+  assert(prefix_end >= full_region_prefix_end, \"in-range\");\n+  assert(prefix_end <= old_space->top(), \"in-range\");\n@@ -1090,13 +1048,0 @@\n-void PSParallelCompact::summarize_spaces_quick()\n-{\n-  for (unsigned int i = 0; i < last_space_id; ++i) {\n-    const MutableSpace* space = _space_info[i].space();\n-    HeapWord** nta = _space_info[i].new_top_addr();\n-    bool result = _summary_data.summarize(_space_info[i].split_info(),\n-                                          space->bottom(), space->top(), nullptr,\n-                                          space->bottom(), space->end(), nta);\n-    assert(result, \"space must fit into itself\");\n-    _space_info[i].set_dense_prefix(space->bottom());\n-  }\n-}\n-\n@@ -1127,0 +1072,6 @@\n+  assert(_summary_data.is_region_aligned(dense_prefix_end), \"precondition\");\n+  assert(dense_prefix_end <= space(id)->top(), \"precondition\");\n+  if (dense_prefix_end == space(id)->top()) {\n+    \/\/ Must not have single-word gap right before prefix-end\/top.\n+    return;\n+  }\n@@ -1151,50 +1102,0 @@\n-void\n-PSParallelCompact::summarize_space(SpaceId id, bool maximum_compaction)\n-{\n-  assert(id < last_space_id, \"id out of range\");\n-  assert(_space_info[id].dense_prefix() == _space_info[id].space()->bottom(),\n-         \"should have been reset in summarize_spaces_quick()\");\n-\n-  const MutableSpace* space = _space_info[id].space();\n-  if (_space_info[id].new_top() != space->bottom()) {\n-    HeapWord* dense_prefix_end = compute_dense_prefix(id, maximum_compaction);\n-    _space_info[id].set_dense_prefix(dense_prefix_end);\n-\n-    \/\/ Recompute the summary data, taking into account the dense prefix.  If\n-    \/\/ every last byte will be reclaimed, then the existing summary data which\n-    \/\/ compacts everything can be left in place.\n-    if (!maximum_compaction && dense_prefix_end != space->bottom()) {\n-      \/\/ If dead space crosses the dense prefix boundary, it is (at least\n-      \/\/ partially) filled with a dummy object, marked live and added to the\n-      \/\/ summary data.  This simplifies the copy\/update phase and must be done\n-      \/\/ before the final locations of objects are determined, to prevent\n-      \/\/ leaving a fragment of dead space that is too small to fill.\n-      fill_dense_prefix_end(id);\n-\n-      \/\/ Compute the destination of each Region, and thus each object.\n-      _summary_data.summarize_dense_prefix(space->bottom(), dense_prefix_end);\n-      _summary_data.summarize(_space_info[id].split_info(),\n-                              dense_prefix_end, space->top(), nullptr,\n-                              dense_prefix_end, space->end(),\n-                              _space_info[id].new_top_addr());\n-    }\n-  }\n-\n-  if (log_develop_is_enabled(Trace, gc, compaction)) {\n-    const size_t region_size = ParallelCompactData::RegionSize;\n-    HeapWord* const dense_prefix_end = _space_info[id].dense_prefix();\n-    const size_t dp_region = _summary_data.addr_to_region_idx(dense_prefix_end);\n-    const size_t dp_words = pointer_delta(dense_prefix_end, space->bottom());\n-    HeapWord* const new_top = _space_info[id].new_top();\n-    const HeapWord* nt_aligned_up = _summary_data.region_align_up(new_top);\n-    const size_t cr_words = pointer_delta(nt_aligned_up, dense_prefix_end);\n-    log_develop_trace(gc, compaction)(\n-        \"id=%d cap=\" SIZE_FORMAT \" dp=\" PTR_FORMAT \" \"\n-        \"dp_region=\" SIZE_FORMAT \" \" \"dp_count=\" SIZE_FORMAT \" \"\n-        \"cr_count=\" SIZE_FORMAT \" \" \"nt=\" PTR_FORMAT,\n-        id, space->capacity_in_words(), p2i(dense_prefix_end),\n-        dp_region, dp_words \/ region_size,\n-        cr_words \/ region_size, p2i(new_top));\n-  }\n-}\n-\n@@ -1224,3 +1125,6 @@\n-void PSParallelCompact::summary_phase(bool maximum_compaction)\n-{\n-  GCTraceTime(Info, gc, phases) tm(\"Summary Phase\", &_gc_timer);\n+bool PSParallelCompact::reassess_maximum_compaction(bool maximum_compaction,\n+                                                    size_t total_live_words,\n+                                                    MutableSpace* const old_space,\n+                                                    HeapWord* full_region_prefix_end) {\n+  \/\/ Check if all live objs are larger than old-gen.\n+  const bool is_old_gen_overflowing = (total_live_words > old_space->capacity_in_words());\n@@ -1228,2 +1132,6 @@\n-  \/\/ Quick summarization of each space into itself, to see how much is live.\n-  summarize_spaces_quick();\n+  \/\/ JVM flags\n+  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n+  assert(total_invocations >= _maximum_compaction_gc_num, \"sanity\");\n+  const size_t gcs_since_max = total_invocations - _maximum_compaction_gc_num;\n+  const bool is_interval_ended = gcs_since_max > HeapMaximumCompactionInterval\n+                              || total_invocations == HeapFirstMaximumCompactionCount;\n@@ -1231,3 +1139,3 @@\n-  log_develop_trace(gc, compaction)(\"summary phase:  after summarizing each space to self\");\n-  NOT_PRODUCT(print_region_ranges());\n-  NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));\n+  \/\/ If all regions in old-gen are full\n+  const bool is_region_full =\n+    full_region_prefix_end >= _summary_data.region_align_down(old_space->top());\n@@ -1235,5 +1143,3 @@\n-  \/\/ The amount of live data that will end up in old space (assuming it fits).\n-  size_t old_space_total_live = 0;\n-  for (unsigned int id = old_space_id; id < last_space_id; ++id) {\n-    old_space_total_live += pointer_delta(_space_info[id].new_top(),\n-                                          _space_info[id].space()->bottom());\n+  if (maximum_compaction || is_old_gen_overflowing || is_interval_ended || is_region_full) {\n+    _maximum_compaction_gc_num = total_invocations;\n+    return true;\n@@ -1242,0 +1148,7 @@\n+  return false;\n+}\n+\n+void PSParallelCompact::summary_phase(bool maximum_compaction)\n+{\n+  GCTraceTime(Info, gc, phases) tm(\"Summary Phase\", &_gc_timer);\n+\n@@ -1243,5 +1156,28 @@\n-  const size_t old_capacity = old_space->capacity_in_words();\n-  if (old_space_total_live > old_capacity) {\n-    \/\/ XXX - should also try to expand\n-    maximum_compaction = true;\n-  }\n+  {\n+    size_t total_live_words = 0;\n+    HeapWord* full_region_prefix_end = nullptr;\n+    {\n+      \/\/ old-gen\n+      size_t live_words = _summary_data.live_words_in_space(old_space,\n+                                                            &full_region_prefix_end);\n+      total_live_words += live_words;\n+    }\n+    \/\/ young-gen\n+    for (uint i = eden_space_id; i < last_space_id; ++i) {\n+      const MutableSpace* space = _space_info[i].space();\n+      size_t live_words = _summary_data.live_words_in_space(space);\n+      total_live_words += live_words;\n+      _space_info[i].set_new_top(space->bottom() + live_words);\n+      _space_info[i].set_dense_prefix(space->bottom());\n+    }\n+\n+    maximum_compaction = reassess_maximum_compaction(maximum_compaction,\n+                                                     total_live_words,\n+                                                     old_space,\n+                                                     full_region_prefix_end);\n+    HeapWord* dense_prefix_end =\n+      maximum_compaction ? full_region_prefix_end\n+                         : compute_dense_prefix_for_old_space(old_space,\n+                                                              full_region_prefix_end);\n+    SpaceId id = old_space_id;\n+    _space_info[id].set_dense_prefix(dense_prefix_end);\n@@ -1249,2 +1185,9 @@\n-  \/\/ Old generations.\n-  summarize_space(old_space_id, maximum_compaction);\n+    if (dense_prefix_end != old_space->bottom()) {\n+      fill_dense_prefix_end(id);\n+      _summary_data.summarize_dense_prefix(old_space->bottom(), dense_prefix_end);\n+    }\n+    _summary_data.summarize(_space_info[id].split_info(),\n+                            dense_prefix_end, old_space->top(), nullptr,\n+                            dense_prefix_end, old_space->end(),\n+                            _space_info[id].new_top_addr());\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":107,"deletions":164,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-      if (!seen_gc_safepoint && gc_safepoint_happened()) {\n+      if (is_reference_type(element_type) && !seen_gc_safepoint && gc_safepoint_happened()) {\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1054,5 +1054,1 @@\n-    if (JvmtiExport::can_hotswap_or_post_breakpoint() && info.resolved_method()->is_old()) {\n-      resolved_method = methodHandle(current, info.resolved_method()->get_new_method());\n-    } else {\n-      resolved_method = methodHandle(current, info.resolved_method());\n-    }\n+    resolved_method = methodHandle(current, info.resolved_method());\n@@ -1061,0 +1057,3 @@\n+  \/\/ Don't allow safepoints until the method is cached.\n+  NoSafepointVerifier nsv;\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -115,0 +116,21 @@\n+\/\/ Redefinition safepoint may have updated the method. Make sure the new version of the method is returned.\n+\/\/ Callers are responsible for not safepointing and storing this method somewhere safe where redefinition\n+\/\/ can replace it if runs again.  Safe places are constant pool cache and code cache metadata.\n+\/\/ The old method is safe in CallInfo since its a methodHandle (it won't get deleted), and accessed with these\n+\/\/ accessors.\n+Method* CallInfo::resolved_method() const {\n+  if (JvmtiExport::can_hotswap_or_post_breakpoint() && _resolved_method->is_old()) {\n+    return _resolved_method->get_new_method();\n+  } else {\n+    return _resolved_method();\n+  }\n+}\n+\n+Method* CallInfo::selected_method() const {\n+  if (JvmtiExport::can_hotswap_or_post_breakpoint() && _selected_method->is_old()) {\n+    return _selected_method->get_new_method();\n+  } else {\n+    return _selected_method();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,2 +95,2 @@\n-  Method* resolved_method() const                { return _resolved_method(); }\n-  Method* selected_method() const                { return _selected_method(); }\n+  Method* resolved_method() const;\n+  Method* selected_method() const;\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -184,12 +184,0 @@\n-InterpreterOopMap::~InterpreterOopMap() {\n-  \/\/ The expectation is that the bit mask was allocated\n-  \/\/ last in this resource area.  That would make the free of the\n-  \/\/ bit_mask effective (see how FREE_RESOURCE_ARRAY does a free).\n-  \/\/ If it was not allocated last, there is not a correctness problem\n-  \/\/ but the space for the bit_mask is not freed.\n-  assert(_resource_allocate_bit_mask, \"Trying to free C heap space\");\n-  if (mask_size() > small_mask_limit) {\n-    FREE_RESOURCE_ARRAY(uintptr_t, _bit_mask[0], mask_word_size());\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -707,0 +707,1 @@\n+    JVMCINMethodHandle& nmethod_handle,\n@@ -808,0 +809,2 @@\n+      guarantee(nm != nullptr, \"successful compile must produce an nmethod\");\n+      nmethod_handle.set_nmethod(nm);\n@@ -816,4 +819,2 @@\n-      if (nm != nullptr) {\n-        if (_nmethod_entry_patch_offset != -1) {\n-          err_msg msg(\"\");\n-          BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+      if (_nmethod_entry_patch_offset != -1) {\n+        BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n@@ -821,3 +822,4 @@\n-          if (!bs_nm->verify_barrier(nm, msg)) {\n-            JVMCI_THROW_MSG_(IllegalArgumentException, err_msg(\"nmethod entry barrier is malformed: %s\", msg.buffer()), JVMCI::ok);\n-          }\n+        \/\/ an empty error buffer for use by the verify_barrier code\n+        err_msg msg(\"\");\n+        if (!bs_nm->verify_barrier(nm, msg)) {\n+          JVMCI_THROW_MSG_(IllegalArgumentException, err_msg(\"nmethod entry barrier is malformed: %s\", msg.buffer()), JVMCI::ok);\n@@ -1247,1 +1249,2 @@\n-      if (CompiledDirectCall::emit_to_interp_stub(buffer, _instructions->start() + pc_offset) == nullptr) {\n+      MacroAssembler masm(&buffer);\n+      if (CompiledDirectCall::emit_to_interp_stub(&masm, _instructions->start() + pc_offset) == nullptr) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -1109,0 +1110,1 @@\n+  JVMCINMethodHandle nmethod_handle(THREAD);\n@@ -1116,0 +1118,1 @@\n+      nmethod_handle,\n@@ -1207,1 +1210,2 @@\n-  nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror);\n+  JVMCINMethodHandle nmethod_handle(THREAD);\n+  nmethod* nm = JVMCIENV->get_nmethod(nmethod_mirror, nmethod_handle);\n@@ -1481,0 +1485,1 @@\n+  KeepStackGCProcessedMark keep_stack(THREAD);\n@@ -2765,1 +2770,2 @@\n-      nmethod* nm = JVMCIENV->get_nmethod(obj);\n+      JVMCINMethodHandle nmethod_handle(THREAD);\n+      nmethod* nm = JVMCIENV->get_nmethod(obj, nmethod_handle);\n@@ -2788,1 +2794,2 @@\n-      nmethod* nm = JVMCIENV->get_nmethod(obj);\n+      JVMCINMethodHandle nmethod_handle(THREAD);\n+      nmethod* nm = JVMCIENV->get_nmethod(obj, nmethod_handle);\n@@ -2840,1 +2847,2 @@\n-  JVMCIENV->get_nmethod(code);\n+  JVMCINMethodHandle nmethod_handle(THREAD);\n+  JVMCIENV->get_nmethod(code, nmethod_handle);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -166,0 +166,3 @@\n+uintx Universe::_the_array_interfaces_bitmap = 0;\n+uintx Universe::_the_empty_klass_bitmap      = 0;\n+\n@@ -443,0 +446,5 @@\n+    if (UseSecondarySupersTable) {\n+      Universe::_the_array_interfaces_bitmap = Klass::compute_secondary_supers_bitmap(_the_array_interfaces_array);\n+      Universe::_the_empty_klass_bitmap      = Klass::compute_secondary_supers_bitmap(_the_empty_klass_array);\n+    }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -99,0 +99,3 @@\n+  static uintx _the_array_interfaces_bitmap;\n+  static uintx _the_empty_klass_bitmap;\n+\n@@ -233,1 +236,2 @@\n-  static Array<Klass*>* the_array_interfaces_array()  { return _the_array_interfaces_array;   }\n+  static Array<Klass*>* the_array_interfaces_array()  { return _the_array_interfaces_array; }\n+  static uintx        the_array_interfaces_bitmap()   { return _the_array_interfaces_bitmap; }\n@@ -269,0 +273,2 @@\n+  static uintx                   the_empty_klass_bitmap() { return _the_empty_klass_bitmap; }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -203,1 +203,2 @@\n-  set_secondary_supers(Universe::the_array_interfaces_array());\n+  set_secondary_supers(Universe::the_array_interfaces_array(),\n+                       Universe::the_array_interfaces_bitmap());\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -832,1 +832,3 @@\n-static Symbol* exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception) {\n+static const char* exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception) {\n+  \/\/ Note: caller needs ResourceMark\n+\n@@ -834,3 +836,3 @@\n-  Symbol* message = java_lang_Throwable::detail_message(pending_exception);\n-  if (message != nullptr) {\n-    return message;\n+  const char* msg = java_lang_Throwable::message_as_utf8(pending_exception);\n+  if (msg != nullptr) {\n+    return msg;\n@@ -839,0 +841,1 @@\n+  Symbol* message = nullptr;\n@@ -861,1 +864,1 @@\n-  return message;\n+  return message != nullptr ? message->as_C_string() : nullptr;\n@@ -864,1 +867,1 @@\n-static void add_resolution_error(const constantPoolHandle& this_cp, int which,\n+static void add_resolution_error(JavaThread* current, const constantPoolHandle& this_cp, int which,\n@@ -867,0 +870,1 @@\n+  ResourceMark rm(current);\n@@ -872,1 +876,1 @@\n-  Symbol* cause_msg = nullptr;\n+  const char* cause_msg = nullptr;\n@@ -875,1 +879,1 @@\n-    cause_msg = java_lang_Throwable::detail_message(cause);\n+    cause_msg = java_lang_Throwable::message_as_utf8(cause);\n@@ -878,1 +882,1 @@\n-  Symbol* message = exception_message(this_cp, which, tag, pending_exception);\n+  const char* message = exception_message(this_cp, which, tag, pending_exception);\n@@ -885,1 +889,1 @@\n-  Symbol* message = nullptr;\n+  const char* message = nullptr;\n@@ -887,1 +891,1 @@\n-  Symbol* cause_msg = nullptr;\n+  const char* cause_msg = nullptr;\n@@ -890,1 +894,0 @@\n-  const char* cause_str = cause_msg != nullptr ? cause_msg->as_C_string() : nullptr;\n@@ -894,3 +897,2 @@\n-    char* msg = message->as_C_string();\n-      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_str);\n-      THROW_MSG_CAUSE(error, msg, h_cause);\n+      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_msg);\n+      THROW_MSG_CAUSE(error, message, h_cause);\n@@ -899,1 +901,1 @@\n-      THROW_MSG(error, msg);\n+      THROW_MSG(error, message);\n@@ -903,1 +905,1 @@\n-      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_str);\n+      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_msg);\n@@ -925,1 +927,1 @@\n-    add_resolution_error(this_cp, cp_index, tag, PENDING_EXCEPTION);\n+    add_resolution_error(THREAD, this_cp, cp_index, tag, PENDING_EXCEPTION);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-\n+  ResourceMark rm(THREAD);\n@@ -572,1 +572,1 @@\n-  Symbol* message = java_lang_Throwable::detail_message(PENDING_EXCEPTION);\n+  const char* message = java_lang_Throwable::message_as_utf8(PENDING_EXCEPTION);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1654,1 +1654,3 @@\n-  Array<InstanceKlass*>* interfaces = transitive_interfaces;\n+  \/\/ We need the cast because Array<Klass*> is NOT a supertype of Array<InstanceKlass*>,\n+  \/\/ (but it's safe to do here because we won't write into _secondary_supers from this point on).\n+  Array<Klass*>* interfaces = (Array<Klass*>*)(address)transitive_interfaces;\n@@ -1658,1 +1660,1 @@\n-    set_secondary_supers(Universe::the_empty_klass_array());\n+    set_secondary_supers(Universe::the_empty_klass_array(), Universe::the_empty_klass_bitmap());\n@@ -1664,10 +1666,9 @@\n-    \/\/ We need the cast because Array<Klass*> is NOT a supertype of Array<InstanceKlass*>,\n-    \/\/ (but it's safe to do here because we won't write into _secondary_supers from this point on).\n-    set_secondary_supers((Array<Klass*>*)(address)interfaces);\n-    return nullptr;\n-  } else {\n-    \/\/ Copy transitive interfaces to a temporary growable array to be constructed\n-    \/\/ into the secondary super list with extra slots.\n-    GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(interfaces->length());\n-    for (int i = 0; i < interfaces->length(); i++) {\n-      secondaries->push(interfaces->at(i));\n+    if (!UseSecondarySupersTable) {\n+      set_secondary_supers(interfaces);\n+      return nullptr;\n+    } else if (num_extra_slots == 0 && interfaces->length() <= 1) {\n+      \/\/ We will reuse the transitive interfaces list if we're certain\n+      \/\/ it's in hash order.\n+      uintx bitmap = compute_secondary_supers_bitmap(interfaces);\n+      set_secondary_supers(interfaces, bitmap);\n+      return nullptr;\n@@ -1675,1 +1676,7 @@\n-    return secondaries;\n+    \/\/ ... fall through if that didn't work.\n+  }\n+  \/\/ Copy transitive interfaces to a temporary growable array to be constructed\n+  \/\/ into the secondary super list with extra slots.\n+  GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(interfaces->length());\n+  for (int i = 0; i < interfaces->length(); i++) {\n+    secondaries->push(interfaces->at(i));\n@@ -1677,0 +1684,1 @@\n+  return secondaries;\n@@ -3825,0 +3833,23 @@\n+\n+  st->print(BULLET\"secondary supers: \"); secondary_supers()->print_value_on(st); st->cr();\n+  if (UseSecondarySupersTable) {\n+    st->print(BULLET\"hash_slot:         %d\", hash_slot()); st->cr();\n+    st->print(BULLET\"bitmap:            \" UINTX_FORMAT_X_0, _bitmap); st->cr();\n+  }\n+  if (secondary_supers() != nullptr) {\n+    if (Verbose) {\n+      bool is_hashed = UseSecondarySupersTable && (_bitmap != SECONDARY_SUPERS_BITMAP_FULL);\n+      st->print_cr(BULLET\"---- secondary supers (%d words):\", _secondary_supers->length());\n+      for (int i = 0; i < _secondary_supers->length(); i++) {\n+        ResourceMark rm; \/\/ for external_name()\n+        Klass* secondary_super = _secondary_supers->at(i);\n+        st->print(BULLET\"%2d:\", i);\n+        if (is_hashed) {\n+          int home_slot = compute_home_slot(secondary_super, _bitmap);\n+          int distance = (i - home_slot) & SECONDARY_SUPERS_TABLE_MASK;\n+          st->print(\" dist:%02d:\", distance);\n+        }\n+        st->print_cr(\" %p %s\", secondary_super, secondary_super->external_name());\n+      }\n+    }\n+  }\n@@ -3883,0 +3914,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":45,"deletions":13,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -56,0 +58,1 @@\n+#include \"utilities\/rotate_bits.hpp\"\n@@ -80,0 +83,41 @@\n+uint8_t Klass::compute_hash_slot(Symbol* n) {\n+  uint hash_code;\n+  \/\/ Special cases for the two superclasses of all Array instances.\n+  \/\/ Code elsewhere assumes, for all instances of ArrayKlass, that\n+  \/\/ these two interfaces will be in this order.\n+\n+  \/\/ We ensure there are some empty slots in the hash table between\n+  \/\/ these two very common interfaces because if they were adjacent\n+  \/\/ (e.g. Slots 0 and 1), then any other class which hashed to 0 or 1\n+  \/\/ would result in a probe length of 3.\n+  if (n == vmSymbols::java_lang_Cloneable()) {\n+    hash_code = 0;\n+  } else if (n == vmSymbols::java_io_Serializable()) {\n+    hash_code = SECONDARY_SUPERS_TABLE_SIZE \/ 2;\n+  } else {\n+    auto s = (const jbyte*) n->bytes();\n+    hash_code = java_lang_String::hash_code(s, n->utf8_length());\n+    \/\/ We use String::hash_code here (rather than e.g.\n+    \/\/ Symbol::identity_hash()) in order to have a hash code that\n+    \/\/ does not change from run to run. We want that because the\n+    \/\/ hash value for a secondary superclass appears in generated\n+    \/\/ code as a constant.\n+\n+    \/\/ This constant is magic: see Knuth, \"Fibonacci Hashing\".\n+    constexpr uint multiplier\n+      = 2654435769; \/\/ (uint)(((u8)1 << 32) \/ ((1 + sqrt(5)) \/ 2 ))\n+    constexpr uint hash_shift = sizeof(hash_code) * 8 - 6;\n+    \/\/ The leading bits of the least significant half of the product.\n+    hash_code = (hash_code * multiplier) >> hash_shift;\n+\n+    if (StressSecondarySupers) {\n+      \/\/ Generate many hash collisions in order to stress-test the\n+      \/\/ linear search fallback.\n+      hash_code = hash_code % 3;\n+      hash_code = hash_code * (SECONDARY_SUPERS_TABLE_SIZE \/ 3);\n+    }\n+  }\n+\n+  return (hash_code & SECONDARY_SUPERS_TABLE_MASK);\n+}\n+\n@@ -82,1 +126,17 @@\n-  if (_name != nullptr) _name->increment_refcount();\n+\n+  if (_name != nullptr) {\n+    _name->increment_refcount();\n+  }\n+\n+  if (UseSecondarySupersTable) {\n+    elapsedTimer selftime;\n+    selftime.start();\n+\n+    _hash_slot = compute_hash_slot(n);\n+    assert(_hash_slot < SECONDARY_SUPERS_TABLE_SIZE, \"required\");\n+\n+    selftime.stop();\n+    if (UsePerfData) {\n+      ClassLoader::perf_secondary_hash_time()->inc(selftime.ticks());\n+    }\n+  }\n@@ -240,0 +300,169 @@\n+void Klass::set_secondary_supers(Array<Klass*>* secondaries) {\n+  assert(!UseSecondarySupersTable || secondaries == nullptr, \"\");\n+  set_secondary_supers(secondaries, SECONDARY_SUPERS_BITMAP_EMPTY);\n+}\n+\n+void Klass::set_secondary_supers(Array<Klass*>* secondaries, uintx bitmap) {\n+#ifdef ASSERT\n+  if (UseSecondarySupersTable && secondaries != nullptr) {\n+    uintx real_bitmap = compute_secondary_supers_bitmap(secondaries);\n+    assert(bitmap == real_bitmap, \"must be\");\n+  }\n+#endif\n+  _bitmap = bitmap;\n+  _secondary_supers = secondaries;\n+\n+  if (secondaries != nullptr) {\n+    LogMessage(class, load) msg;\n+    NonInterleavingLogStream log {LogLevel::Debug, msg};\n+    if (log.is_enabled()) {\n+      ResourceMark rm;\n+      log.print_cr(\"set_secondary_supers: hash_slot: %d; klass: %s\", hash_slot(), external_name());\n+      print_secondary_supers_on(&log);\n+    }\n+  }\n+}\n+\n+\/\/ Hashed secondary superclasses\n+\/\/\n+\/\/ We use a compressed 64-entry hash table with linear probing. We\n+\/\/ start by creating a hash table in the usual way, followed by a pass\n+\/\/ that removes all the null entries. To indicate which entries would\n+\/\/ have been null we use a bitmap that contains a 1 in each position\n+\/\/ where an entry is present, 0 otherwise. This bitmap also serves as\n+\/\/ a kind of Bloom filter, which in many cases allows us quickly to\n+\/\/ eliminate the possibility that something is a member of a set of\n+\/\/ secondaries.\n+uintx Klass::hash_secondary_supers(Array<Klass*>* secondaries, bool rewrite) {\n+  const int length = secondaries->length();\n+\n+  if (length == 0) {\n+    return SECONDARY_SUPERS_BITMAP_EMPTY;\n+  }\n+\n+  if (length == 1) {\n+    int hash_slot = secondaries->at(0)->hash_slot();\n+    return uintx(1) << hash_slot;\n+  }\n+\n+  \/\/ For performance reasons we don't use a hashed table unless there\n+  \/\/ are at least two empty slots in it. If there were only one empty\n+  \/\/ slot it'd take a long time to create the table and the resulting\n+  \/\/ search would be no faster than linear probing.\n+  if (length > SECONDARY_SUPERS_TABLE_SIZE - 2) {\n+    return SECONDARY_SUPERS_BITMAP_FULL;\n+  }\n+\n+  {\n+    PerfTraceTime ptt(ClassLoader::perf_secondary_hash_time());\n+\n+    ResourceMark rm;\n+    uintx bitmap = SECONDARY_SUPERS_BITMAP_EMPTY;\n+    auto hashed_secondaries = new GrowableArray<Klass*>(SECONDARY_SUPERS_TABLE_SIZE,\n+                                                        SECONDARY_SUPERS_TABLE_SIZE, nullptr);\n+\n+    for (int j = 0; j < length; j++) {\n+      Klass* k = secondaries->at(j);\n+      hash_insert(k, hashed_secondaries, bitmap);\n+    }\n+\n+    \/\/ Pack the hashed secondaries array by copying it into the\n+    \/\/ secondaries array, sans nulls, if modification is allowed.\n+    \/\/ Otherwise, validate the order.\n+    int i = 0;\n+    for (int slot = 0; slot < SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      bool has_element = ((bitmap >> slot) & 1) != 0;\n+      assert(has_element == (hashed_secondaries->at(slot) != nullptr), \"\");\n+      if (has_element) {\n+        Klass* k = hashed_secondaries->at(slot);\n+        if (rewrite) {\n+          secondaries->at_put(i, k);\n+        } else if (secondaries->at(i) != k) {\n+          assert(false, \"broken secondary supers hash table\");\n+          return SECONDARY_SUPERS_BITMAP_FULL;\n+        }\n+        i++;\n+      }\n+    }\n+    assert(i == secondaries->length(), \"mismatch\");\n+\n+    return bitmap;\n+  }\n+}\n+\n+void Klass::hash_insert(Klass* klass, GrowableArray<Klass*>* secondaries, uintx& bitmap) {\n+  assert(bitmap != SECONDARY_SUPERS_BITMAP_FULL, \"\");\n+\n+  int dist = 0;\n+  for (int slot = klass->hash_slot(); true; slot = (slot + 1) & SECONDARY_SUPERS_TABLE_MASK) {\n+    Klass* existing = secondaries->at(slot);\n+    assert(((bitmap >> slot) & 1) == (existing != nullptr), \"mismatch\");\n+    if (existing == nullptr) { \/\/ no conflict\n+      secondaries->at_put(slot, klass);\n+      bitmap |= uintx(1) << slot;\n+      assert(bitmap != SECONDARY_SUPERS_BITMAP_FULL, \"\");\n+      return;\n+    } else {\n+      \/\/ Use Robin Hood hashing to minimize the worst case search.\n+      \/\/ Also, every permutation of the insertion sequence produces\n+      \/\/ the same final Robin Hood hash table, provided that a\n+      \/\/ consistent tie breaker is used.\n+      int existing_dist = (slot - existing->hash_slot()) & SECONDARY_SUPERS_TABLE_MASK;\n+      if (existing_dist < dist\n+          \/\/ This tie breaker ensures that the hash order is maintained.\n+          || ((existing_dist == dist)\n+              && (uintptr_t(existing) < uintptr_t(klass)))) {\n+        Klass* tmp = secondaries->at(slot);\n+        secondaries->at_put(slot, klass);\n+        klass = tmp;\n+        dist = existing_dist;\n+      }\n+      ++dist;\n+    }\n+  }\n+}\n+\n+Array<Klass*>* Klass::pack_secondary_supers(ClassLoaderData* loader_data,\n+                                            GrowableArray<Klass*>* primaries,\n+                                            GrowableArray<Klass*>* secondaries,\n+                                            uintx& bitmap, TRAPS) {\n+  int new_length = primaries->length() + secondaries->length();\n+  Array<Klass*>* secondary_supers = MetadataFactory::new_array<Klass*>(loader_data, new_length, CHECK_NULL);\n+\n+  \/\/ Combine the two arrays into a metadata object to pack the array.\n+  \/\/ The primaries are added in the reverse order, then the secondaries.\n+  int fill_p = primaries->length();\n+  for (int j = 0; j < fill_p; j++) {\n+    secondary_supers->at_put(j, primaries->pop());  \/\/ add primaries in reverse order.\n+  }\n+  for( int j = 0; j < secondaries->length(); j++ ) {\n+    secondary_supers->at_put(j+fill_p, secondaries->at(j));  \/\/ add secondaries on the end.\n+  }\n+#ifdef ASSERT\n+  \/\/ We must not copy any null placeholders left over from bootstrap.\n+  for (int j = 0; j < secondary_supers->length(); j++) {\n+    assert(secondary_supers->at(j) != nullptr, \"correct bootstrapping order\");\n+  }\n+#endif\n+\n+  if (UseSecondarySupersTable) {\n+    bitmap = hash_secondary_supers(secondary_supers, \/*rewrite=*\/true); \/\/ rewrites freshly allocated array\n+  } else {\n+    bitmap = SECONDARY_SUPERS_BITMAP_EMPTY;\n+  }\n+  return secondary_supers;\n+}\n+\n+uintx Klass::compute_secondary_supers_bitmap(Array<Klass*>* secondary_supers) {\n+  return hash_secondary_supers(secondary_supers, \/*rewrite=*\/false); \/\/ no rewrites allowed\n+}\n+\n+uint8_t Klass::compute_home_slot(Klass* k, uintx bitmap) {\n+  uint8_t hash = k->hash_slot();\n+  if (hash > 0) {\n+    return population_count(bitmap << (SECONDARY_SUPERS_TABLE_SIZE - hash));\n+  }\n+  return 0;\n+}\n+\n+\n@@ -330,20 +559,3 @@\n-    \/\/ The primaries are added in the reverse order, then the secondaries.\n-    int new_length = primaries->length() + secondaries->length();\n-    Array<Klass*>* s2 = MetadataFactory::new_array<Klass*>(\n-                                       class_loader_data(), new_length, CHECK);\n-    int fill_p = primaries->length();\n-    for (int j = 0; j < fill_p; j++) {\n-      s2->at_put(j, primaries->pop());  \/\/ add primaries in reverse order.\n-    }\n-    for( int j = 0; j < secondaries->length(); j++ ) {\n-      s2->at_put(j+fill_p, secondaries->at(j));  \/\/ add secondaries on the end.\n-    }\n-\n-  #ifdef ASSERT\n-      \/\/ We must not copy any null placeholders left over from bootstrap.\n-    for (int j = 0; j < s2->length(); j++) {\n-      assert(s2->at(j) != nullptr, \"correct bootstrapping order\");\n-    }\n-  #endif\n-\n-    set_secondary_supers(s2);\n+    uintx bitmap = 0;\n+    Array<Klass*>* s2 = pack_secondary_supers(class_loader_data(), primaries, secondaries, bitmap, CHECK);\n+    set_secondary_supers(s2, bitmap);\n@@ -357,1 +569,1 @@\n-  set_secondary_supers(Universe::the_empty_klass_array());\n+  set_secondary_supers(Universe::the_empty_klass_array(), Universe::the_empty_klass_bitmap());\n@@ -556,0 +768,5 @@\n+\n+  \/\/ FIXME: validation in Klass::hash_secondary_supers() may fail for shared klasses.\n+  \/\/ Even though the bitmaps always match, the canonical order of elements in the table\n+  \/\/ is not guaranteed to stay the same (see tie breaker during Robin Hood hashing in Klass::hash_insert).\n+  \/\/assert(compute_secondary_supers_bitmap(secondary_supers()) == _bitmap, \"broken table\");\n@@ -963,0 +1180,97 @@\n+\n+class LookupStats : StackObj {\n+ private:\n+  uint _no_of_samples;\n+  uint _worst;\n+  uint _worst_count;\n+  uint _average;\n+  uint _best;\n+  uint _best_count;\n+ public:\n+  LookupStats() : _no_of_samples(0), _worst(0), _worst_count(0), _average(0), _best(INT_MAX), _best_count(0) {}\n+\n+  ~LookupStats() {\n+    assert(_best <= _worst || _no_of_samples == 0, \"sanity\");\n+  }\n+\n+  void sample(uint value) {\n+    ++_no_of_samples;\n+    _average += value;\n+\n+    if (_worst < value) {\n+      _worst = value;\n+      _worst_count = 1;\n+    } else if (_worst == value) {\n+      ++_worst_count;\n+    }\n+\n+    if (_best > value) {\n+      _best = value;\n+      _best_count = 1;\n+    } else if (_best == value) {\n+      ++_best_count;\n+    }\n+  }\n+\n+  void print_on(outputStream* st) const {\n+    st->print(\"best: %2d (%4.1f%%)\", _best, (100.0 * _best_count) \/ _no_of_samples);\n+    if (_best_count < _no_of_samples) {\n+      st->print(\"; average: %4.1f; worst: %2d (%4.1f%%)\",\n+                (1.0 * _average) \/ _no_of_samples,\n+                _worst, (100.0 * _worst_count) \/ _no_of_samples);\n+    }\n+  }\n+};\n+\n+static void print_positive_lookup_stats(Array<Klass*>* secondary_supers, uintx bitmap, outputStream* st) {\n+  int num_of_supers = secondary_supers->length();\n+\n+  LookupStats s;\n+  for (int i = 0; i < num_of_supers; i++) {\n+    Klass* secondary_super = secondary_supers->at(i);\n+    int home_slot = Klass::compute_home_slot(secondary_super, bitmap);\n+    uint score = 1 + ((i - home_slot) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+    s.sample(score);\n+  }\n+  st->print(\"positive_lookup: \"); s.print_on(st);\n+}\n+\n+static uint compute_distance_to_nearest_zero(int slot, uintx bitmap) {\n+  assert(~bitmap != 0, \"no zeroes\");\n+  uintx start = rotate_right(bitmap, slot);\n+  return count_trailing_zeros(~start);\n+}\n+\n+static void print_negative_lookup_stats(uintx bitmap, outputStream* st) {\n+  LookupStats s;\n+  for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+    uint score = compute_distance_to_nearest_zero(slot, bitmap);\n+    s.sample(score);\n+  }\n+  st->print(\"negative_lookup: \"); s.print_on(st);\n+}\n+\n+void Klass::print_secondary_supers_on(outputStream* st) const {\n+  if (secondary_supers() != nullptr) {\n+    if (UseSecondarySupersTable) {\n+      st->print(\"  - \"); st->print(\"%d elements;\", _secondary_supers->length());\n+      st->print_cr(\" bitmap: \" UINTX_FORMAT_X_0 \";\", _bitmap);\n+      if (_bitmap != SECONDARY_SUPERS_BITMAP_EMPTY &&\n+          _bitmap != SECONDARY_SUPERS_BITMAP_FULL) {\n+        st->print(\"  - \"); print_positive_lookup_stats(secondary_supers(), _bitmap, st); st->cr();\n+        st->print(\"  - \"); print_negative_lookup_stats(_bitmap, st); st->cr();\n+      }\n+    }\n+  } else {\n+    st->print(\"null\");\n+  }\n+}\n+\n+void Klass::on_secondary_supers_verification_failure(Klass* super, Klass* sub, bool linear_result, bool table_result, const char* msg) {\n+  ResourceMark rm;\n+  super->print();\n+  sub->print();\n+  fatal(\"%s: %s implements %s: is_subtype_of: %d; linear_search: %d; table_lookup: %d\",\n+        msg, sub->external_name(), super->external_name(),\n+        sub->is_subtype_of(super), linear_result, table_result);\n+}\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":337,"deletions":23,"binary":false,"changes":360,"status":"modified"},{"patch":"@@ -164,0 +164,6 @@\n+  \/\/ Bitmap and hash code used by hashed secondary supers.\n+  uintx    _bitmap;\n+  uint8_t  _hash_slot;\n+\n+  static uint8_t compute_hash_slot(Symbol* s);\n+\n@@ -237,1 +243,4 @@\n-  void set_secondary_supers(Array<Klass*>* k) { _secondary_supers = k; }\n+  void set_secondary_supers(Array<Klass*>* k);\n+  void set_secondary_supers(Array<Klass*>* k, uintx bitmap);\n+\n+  uint8_t hash_slot() const { return _hash_slot; }\n@@ -388,0 +397,4 @@\n+ private:\n+  static void  hash_insert(Klass* klass, GrowableArray<Klass*>* secondaries, uintx& bitmap);\n+  static uintx hash_secondary_supers(Array<Klass*>* secondaries, bool rewrite);\n+\n@@ -389,0 +402,15 @@\n+  \/\/ Secondary supers table support\n+  static Array<Klass*>* pack_secondary_supers(ClassLoaderData* loader_data,\n+                                              GrowableArray<Klass*>* primaries,\n+                                              GrowableArray<Klass*>* secondaries,\n+                                              uintx& bitmap,\n+                                              TRAPS);\n+\n+  static uintx   compute_secondary_supers_bitmap(Array<Klass*>* secondary_supers);\n+  static uint8_t compute_home_slot(Klass* k, uintx bitmap);\n+\n+  static constexpr int SECONDARY_SUPERS_TABLE_SIZE = sizeof(_bitmap) * 8;\n+  static constexpr int SECONDARY_SUPERS_TABLE_MASK = SECONDARY_SUPERS_TABLE_SIZE - 1;\n+\n+  static constexpr uintx SECONDARY_SUPERS_BITMAP_EMPTY    = 0;\n+  static constexpr uintx SECONDARY_SUPERS_BITMAP_FULL     = ~(uintx)0;\n@@ -405,0 +433,1 @@\n+  static ByteSize bitmap_offset()                { return byte_offset_of(Klass, _bitmap); }\n@@ -751,0 +780,2 @@\n+  void print_secondary_supers_on(outputStream* st) const;\n+\n@@ -765,0 +796,2 @@\n+\n+  static void on_secondary_supers_verification_failure(Klass* super, Klass* sub, bool linear_result, bool table_result, const char* msg);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -411,4 +411,0 @@\n-  \/\/ the number of argument reg slots that the compiled method uses on the stack.\n-  int num_stack_arg_slots(bool rounded = true) const {\n-    return rounded ? align_up(constMethod()->num_stack_arg_slots(), 2) : constMethod()->num_stack_arg_slots(); }\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -331,1 +331,2 @@\n-    set_secondary_supers(Universe::the_array_interfaces_array());\n+    set_secondary_supers(Universe::the_array_interfaces_array(),\n+                         Universe::the_array_interfaces_bitmap());\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -76,4 +77,1 @@\n-  \/\/ This is called at a safepoint during dumping of a static CDS archive. The caller should have\n-  \/\/ called os::init_random() with a deterministic seed and then iterate all archived Symbols in\n-  \/\/ a deterministic order.\n-  _hash_and_refcount =  pack_hash_and_refcount((short)os::random(), PERM_REFCOUNT);\n+  _hash_and_refcount =  pack_hash_and_refcount((short)ArchiveBuilder::current()->entropy(), PERM_REFCOUNT);\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -794,0 +794,3 @@\n+                                                                            \\\n+  product(bool, InlineSecondarySupersTest, true, DIAGNOSTIC,                \\\n+          \"Inline the secondary supers hash lookup.\")                       \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -585,0 +585,4 @@\n+    if (!allow_inline && (C->print_inlining() || C->print_intrinsics())) {\n+      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n+                        \"late call devirtualization\");\n+    }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -701,1 +701,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const { }\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const { }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -747,2 +747,2 @@\n-  \/\/ Reassociate invariant add and subtract expressions.\n-  Node* reassociate_add_sub(Node* n1, int inv1_idx, int inv2_idx, PhaseIdealLoop *phase);\n+  \/\/ Reassociate invariant add, subtract, and compare expressions.\n+  Node* reassociate_add_sub_cmp(Node* n1, int inv1_idx, int inv2_idx, PhaseIdealLoop* phase);\n@@ -754,0 +754,2 @@\n+  \/\/ Return TRUE if \"n\" is an associative cmp node.\n+  bool is_associative_cmp(Node* n);\n@@ -1683,0 +1685,3 @@\n+  void register_new_node_with_ctrl_of(Node* new_node, Node* ctrl_of) {\n+    register_new_node(new_node, get_ctrl(ctrl_of));\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -477,1 +477,1 @@\n-      register_new_node(neg, get_ctrl(add->in(2)));\n+      register_new_node_with_ctrl_of(neg, add->in(2));\n@@ -664,1 +664,1 @@\n-              register_new_node(nn, get_ctrl(n));\n+              register_new_node_with_ctrl_of(nn, n);\n@@ -670,1 +670,1 @@\n-              register_new_node(nn, get_ctrl(n));\n+              register_new_node_with_ctrl_of(nn, n);\n@@ -2451,1 +2451,1 @@\n-          register_new_node(pinned_clone, get_ctrl(use));\n+          register_new_node_with_ctrl_of(pinned_clone, use);\n@@ -4097,1 +4097,1 @@\n-          register_new_node(pinned_clone, get_ctrl(n_clone));\n+          register_new_node_with_ctrl_of(pinned_clone, n_clone);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-void MachNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n@@ -623,1 +623,1 @@\n-void MachNullCheckNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {\n+void MachNullCheckNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/c2_MacroAssembler.hpp\"\n@@ -37,1 +38,0 @@\n-class CodeBuffer;\n@@ -288,2 +288,2 @@\n-  \/\/ Emit bytes into cbuf\n-  virtual void  emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  \/\/ Emit bytes using C2_MacroAssembler\n+  virtual void  emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -425,1 +425,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -451,1 +451,1 @@\n-  virtual void emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const;\n+  virtual void emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const;\n@@ -516,1 +516,1 @@\n-  virtual void emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc* ra_) const;\n@@ -532,1 +532,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -553,1 +553,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -567,1 +567,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -591,1 +591,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -649,1 +649,1 @@\n-  uint implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const;\n+  uint implementation( C2_MacroAssembler *masm, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const;\n@@ -651,1 +651,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -714,1 +714,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const { }\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const { }\n@@ -754,1 +754,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n@@ -986,1 +986,1 @@\n-  int resolved_method_index(CodeBuffer &cbuf) const {\n+  int resolved_method_index(C2_MacroAssembler *masm) const {\n@@ -992,1 +992,1 @@\n-      return cbuf.oop_recorder()->find_index(_method->constant_encoding());\n+      return masm->code()->oop_recorder()->find_index(_method->constant_encoding());\n@@ -1097,1 +1097,1 @@\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {}\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {}\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1934,5 +1934,1 @@\n-  if (leaf->is_LoadStore()) {\n-    mach->set_barrier_data(leaf->as_LoadStore()->barrier_data());\n-  } else if (leaf->is_Mem()) {\n-    mach->set_barrier_data(leaf->as_Mem()->barrier_data());\n-  }\n+  mach->set_barrier_data(MemNode::barrier_data(leaf));\n@@ -2551,0 +2547,8 @@\n+    case Op_PartialSubtypeCheck: {\n+      if (UseSecondarySupersTable && n->in(2)->is_Con()) {\n+        \/\/ PartialSubtypeCheck uses both constant and register operands for superclass input.\n+        n->set_req(2, new BinaryNode(n->in(2), n->in(2)));\n+        break;\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2507,0 +2507,6 @@\n+  if (tkls != nullptr && !UseSecondarySupersCache\n+      && tkls->offset() == in_bytes(Klass::secondary_super_cache_offset()))  {\n+    \/\/ Treat Klass::_secondary_super_cache as a constant when the cache is disabled.\n+    return TypePtr::NULL_PTR;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1102,2 +1102,2 @@\n-\/\/ Emit bytes starting at parameter 'ptr'.\n-void Node::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {}\n+\/\/ Emit bytes using C2_MacroAssembler\n+void Node::emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const {}\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+class C2_MacroAssembler;\n@@ -1198,3 +1199,2 @@\n-  \/\/ Emit bytes starting at parameter 'ptr'\n-  \/\/ Bump 'ptr' by the number of output bytes\n-  virtual void emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const;\n+  \/\/ Emit bytes using C2_MacroAssembler\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc *ra_) const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -410,1 +410,2 @@\n-  fill_buffer(cb, blk_starts);\n+  C2_MacroAssembler masm(cb);\n+  fill_buffer(&masm, blk_starts);\n@@ -1438,1 +1439,1 @@\n-void PhaseOutput::fill_buffer(CodeBuffer* cb, uint* blk_starts) {\n+void PhaseOutput::fill_buffer(C2_MacroAssembler* masm, uint* blk_starts) {\n@@ -1494,1 +1495,1 @@\n-    if (!constant_table().emit(*cb)) {\n+    if (!constant_table().emit(masm)) {\n@@ -1517,1 +1518,1 @@\n-      cb->flush_bundle(true);\n+      masm->code()->flush_bundle(true);\n@@ -1524,1 +1525,1 @@\n-      MacroAssembler(cb).block_comment(st.freeze());\n+      masm->block_comment(st.freeze());\n@@ -1534,1 +1535,1 @@\n-    MacroAssembler(cb).bind(blk_labels[block->_pre_order]);\n+    masm->bind(blk_labels[block->_pre_order]);\n@@ -1558,1 +1559,1 @@\n-        cb->flush_bundle(false);\n+        masm->code()->flush_bundle(false);\n@@ -1569,2 +1570,2 @@\n-          cb->flush_bundle(true);\n-          current_offset = cb->insts_size();\n+          masm->code()->flush_bundle(true);\n+          current_offset = masm->offset();\n@@ -1597,2 +1598,2 @@\n-          cb->insts()->maybe_expand_to_ensure_remaining(MAX_inst_size);\n-          if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n+          masm->code()->insts()->maybe_expand_to_ensure_remaining(MAX_inst_size);\n+          if ((masm->code()->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1602,3 +1603,3 @@\n-          nop->emit(*cb, C->regalloc());\n-          cb->flush_bundle(true);\n-          current_offset = cb->insts_size();\n+          nop->emit(masm, C->regalloc());\n+          masm->code()->flush_bundle(true);\n+          current_offset = masm->offset();\n@@ -1684,3 +1685,3 @@\n-                nop->emit(*cb, C->regalloc());\n-                cb->flush_bundle(true);\n-                current_offset = cb->insts_size();\n+                nop->emit(masm, C->regalloc());\n+                masm->code()->flush_bundle(true);\n+                current_offset = masm->offset();\n@@ -1751,2 +1752,2 @@\n-      cb->insts()->maybe_expand_to_ensure_remaining(MAX_inst_size);\n-      if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n+      masm->code()->insts()->maybe_expand_to_ensure_remaining(MAX_inst_size);\n+      if ((masm->code()->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -1760,1 +1761,1 @@\n-        node_offsets[n->_idx] = cb->insts_size();\n+        node_offsets[n->_idx] = masm->offset();\n@@ -1766,3 +1767,3 @@\n-      DEBUG_ONLY(uint instr_offset = cb->insts_size());\n-      n->emit(*cb, C->regalloc());\n-      current_offset = cb->insts_size();\n+      DEBUG_ONLY(uint instr_offset = masm->offset());\n+      n->emit(masm, C->regalloc());\n+      current_offset = masm->offset();\n@@ -1786,1 +1787,1 @@\n-        Disassembler::decode(cb->insts_begin() + instr_offset, cb->insts_begin() + current_offset + 1, tty);\n+        Disassembler::decode(masm->code()->insts_begin() + instr_offset, masm->code()->insts_begin() + current_offset + 1, tty);\n@@ -1817,1 +1818,1 @@\n-        cb->set_insts_end(cb->insts_end() - Pipeline::instr_unit_size());\n+        masm->code()->set_insts_end(masm->code()->insts_end() - Pipeline::instr_unit_size());\n@@ -1822,1 +1823,1 @@\n-          node_offsets[delay_slot->_idx] = cb->insts_size();\n+          node_offsets[delay_slot->_idx] = masm->offset();\n@@ -1844,1 +1845,1 @@\n-        delay_slot->emit(*cb, C->regalloc());\n+        delay_slot->emit(masm, C->regalloc());\n@@ -1861,2 +1862,2 @@\n-        nop->emit(*cb, C->regalloc());\n-        current_offset = cb->insts_size();\n+        nop->emit(masm, C->regalloc());\n+        current_offset = masm->offset();\n@@ -1880,1 +1881,1 @@\n-  MacroAssembler(cb).bind( blk_labels[nblocks] );\n+  masm->bind( blk_labels[nblocks] );\n@@ -1898,1 +1899,1 @@\n-  if (!cb->finalize_stubs()) {\n+  if (!masm->code()->finalize_stubs()) {\n@@ -1904,1 +1905,1 @@\n-  bs->emit_stubs(*cb);\n+  bs->emit_stubs(*masm->code());\n@@ -1908,1 +1909,2 @@\n-  _stub_list.emit(*cb);\n+  assert(masm->inst_mark() == nullptr, \"should be.\");\n+  _stub_list.emit(*masm);\n@@ -1913,1 +1915,1 @@\n-  Scheduling::increment_method_size(cb->insts_size());\n+  Scheduling::increment_method_size(masm->offset());\n@@ -1924,1 +1926,1 @@\n-    _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));\n+    _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(masm));\n@@ -1929,1 +1931,1 @@\n-    _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));\n+    _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(masm));\n@@ -1935,1 +1937,1 @@\n-      _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));\n+      _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(masm));\n@@ -1940,1 +1942,1 @@\n-  if ((cb->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n+  if ((masm->code()->blob() == nullptr) || (!CompileBroker::should_compile_new_jobs())) {\n@@ -3460,0 +3462,2 @@\n+  C2_MacroAssembler masm(&buf);\n+  masm.bind(fakeL);\n@@ -3461,2 +3465,0 @@\n-    MacroAssembler masm(&buf);\n-    masm.bind(fakeL);\n@@ -3466,1 +3468,1 @@\n-  n->emit(buf, C->regalloc());\n+  n->emit(&masm, C->regalloc());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":43,"deletions":41,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -759,1 +759,1 @@\n-      register_new_node(pinned_clone, get_ctrl(use));\n+      register_new_node_with_ctrl_of(pinned_clone, use);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -505,0 +505,1 @@\n+  { \"PreserveAllAnnotations\",       JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n@@ -3778,0 +3779,11 @@\n+  if (FLAG_IS_DEFAULT(UseSecondarySupersTable)) {\n+    FLAG_SET_DEFAULT(UseSecondarySupersTable, VM_Version::supports_secondary_supers_table());\n+  } else if (UseSecondarySupersTable && !VM_Version::supports_secondary_supers_table()) {\n+    warning(\"UseSecondarySupersTable is not supported\");\n+    FLAG_SET_DEFAULT(UseSecondarySupersTable, false);\n+  }\n+  if (!UseSecondarySupersTable) {\n+    FLAG_SET_DEFAULT(StressSecondarySupers, false);\n+    FLAG_SET_DEFAULT(VerifySecondarySupers, false);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -421,0 +421,1 @@\n+  DEBUG_ONLY(GrowableArray<oop> lock_order{0};)\n@@ -430,0 +431,7 @@\n+#ifdef ASSERT\n+      if (LockingMode == LM_LIGHTWEIGHT && !realloc_failures) {\n+        for (MonitorInfo* mi : *monitors) {\n+          lock_order.push(mi->owner());\n+        }\n+      }\n+#endif \/\/ ASSERT\n@@ -461,0 +469,5 @@\n+#ifdef ASSERT\n+  if (LockingMode == LM_LIGHTWEIGHT && !realloc_failures) {\n+    deoptee_thread->lock_stack().verify_consistent_lock_order(lock_order, exec_mode != Deoptimization::Unpack_none);\n+  }\n+#endif \/\/ ASSERT\n@@ -1735,1 +1748,1 @@\n-        if (LockingMode == LM_LIGHTWEIGHT && exec_mode == Unpack_none) {\n+        if (LockingMode == LM_LIGHTWEIGHT) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -977,0 +977,1 @@\n+  ResourceMark rm(thread);\n@@ -1478,1 +1479,1 @@\n-      assert(stack_arg_slots ==  m->num_stack_arg_slots(false \/* rounded *\/), \"\");\n+      assert(stack_arg_slots ==  nm->as_nmethod()->num_stack_arg_slots(false \/* rounded *\/) || nm->is_osr_method(), \"\");\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -802,1 +802,1 @@\n-          \"Preserve RuntimeInvisibleAnnotations as well \"                   \\\n+          \"(Deprecated) Preserve RuntimeInvisibleAnnotations as well \"      \\\n@@ -1306,0 +1306,5 @@\n+  product(intx, ServiceThreadCleanupInterval, 1000, DIAGNOSTIC,             \\\n+          \"Wake the ServiceThread to do periodic cleanup checks every so \"  \\\n+          \"many milliseconds (0 means none)\")                               \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n@@ -2034,0 +2039,12 @@\n+                                                                            \\\n+  product(bool, UseSecondarySupersCache, true, DIAGNOSTIC,                  \\\n+                \"Use secondary supers cache during subtype checks.\")        \\\n+                                                                            \\\n+  product(bool, UseSecondarySupersTable, false, DIAGNOSTIC,                 \\\n+                \"Use hash table to lookup secondary supers.\")               \\\n+                                                                            \\\n+  product(bool, VerifySecondarySupers, false, DIAGNOSTIC,                   \\\n+          \"Check that linear and hashed secondary lookups return the same result.\") \\\n+                                                                            \\\n+  product(bool, StressSecondarySupers, false, DIAGNOSTIC,                   \\\n+          \"Use a terrible hash function in order to generate many collisions.\") \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -471,0 +471,1 @@\n+  _live_nmethod(nullptr),\n@@ -914,0 +915,14 @@\n+    \/\/ Check for monitor counts being out of sync.\n+    assert(held_monitor_count() == jni_monitor_count(),\n+           \"held monitor count should be equal to jni: \" INTX_FORMAT \" != \" INTX_FORMAT,\n+           held_monitor_count(), jni_monitor_count());\n+    \/\/ All in-use monitors, including JNI-locked ones, should have been released above.\n+    assert(held_monitor_count() == 0, \"Failed to unlock \" INTX_FORMAT \" object monitors\",\n+           held_monitor_count());\n+  } else {\n+    \/\/ Check for monitor counts being out of sync.\n+    assert(held_monitor_count() == jni_monitor_count(),\n+           \"held monitor count should be equal to jni: \" INTX_FORMAT \" != \" INTX_FORMAT,\n+           held_monitor_count(), jni_monitor_count());\n+    \/\/ It is possible that a terminating thread failed to unlock monitors it locked\n+    \/\/ via JNI so we don't assert the count is zero.\n@@ -916,6 +931,0 @@\n-  \/\/ Since above code may not release JNI monitors and if someone forgot to do an\n-  \/\/ JNI monitorexit, held count should be equal jni count.\n-  \/\/ Consider scan all object monitor for this owner if JNI count > 0 (at least on detach).\n-  assert(held_monitor_count() == jni_monitor_count(),\n-         \"held monitor count should be equal to jni: \" INTX_FORMAT \" != \" INTX_FORMAT,\n-         held_monitor_count(), jni_monitor_count());\n@@ -926,1 +935,1 @@\n-      exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\", os::current_thread_id());\n+                   exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\", os::current_thread_id());\n@@ -964,3 +973,6 @@\n-  log_info(os, thread)(\"JavaThread %s (tid: \" UINTX_FORMAT \").\",\n-    exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\",\n-    os::current_thread_id());\n+  if (log_is_enabled(Info, os, thread)) {\n+    ResourceMark rm(this);\n+    log_info(os, thread)(\"JavaThread %s (name: \\\"%s\\\", tid: \" UINTX_FORMAT \").\",\n+                         exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\",\n+                         name(), os::current_thread_id());\n+  }\n@@ -1422,0 +1434,4 @@\n+\n+  if (_live_nmethod != nullptr && cf != nullptr) {\n+    cf->do_nmethod(_live_nmethod);\n+  }\n@@ -1477,0 +1493,6 @@\n+\n+#if INCLUDE_JVMCI\n+  if (_live_nmethod != nullptr) {\n+    cf->do_nmethod(_live_nmethod);\n+  }\n+#endif\n@@ -1584,0 +1606,2 @@\n+  \/\/ Use raw field members for stack base\/size as this could be\n+  \/\/ called before a thread has run enough to initialize them.\n@@ -1585,2 +1609,2 @@\n-            p2i(stack_end()), p2i(stack_base()),\n-            PROPERFMTARGS(stack_size()));\n+            p2i(_stack_base - _stack_size), p2i(_stack_base),\n+            PROPERFMTARGS(_stack_size));\n@@ -1992,0 +2016,2 @@\n+\/\/ Slow-path increment of the held monitor counts. JNI locking is always\n+\/\/ this slow-path.\n@@ -1994,1 +2020,1 @@\n-  assert(_held_monitor_count >= 0, \"Must always be greater than 0: \" INTX_FORMAT, _held_monitor_count);\n+  assert(_held_monitor_count >= 0, \"Must always be non-negative: \" INTX_FORMAT, _held_monitor_count);\n@@ -1997,1 +2023,1 @@\n-    assert(_jni_monitor_count >= 0, \"Must always be greater than 0: \" INTX_FORMAT, _jni_monitor_count);\n+    assert(_jni_monitor_count >= 0, \"Must always be non-negative: \" INTX_FORMAT, _jni_monitor_count);\n@@ -2000,0 +2026,2 @@\n+  assert(_held_monitor_count >= _jni_monitor_count, \"Monitor count discrepancy detected - held count \"\n+         INTX_FORMAT \" is less than JNI count \" INTX_FORMAT, _held_monitor_count, _jni_monitor_count);\n@@ -2003,0 +2031,2 @@\n+\/\/ Slow-path decrement of the held monitor counts. JNI unlocking is always\n+\/\/ this slow-path.\n@@ -2011,0 +2041,6 @@\n+  \/\/ When a thread is detaching with still owned JNI monitors, the logic that releases\n+  \/\/ the monitors doesn't know to set the \"jni\" flag and so the counts can get out of sync.\n+  \/\/ So we skip this assert if the thread is exiting. Once all monitors are unlocked the\n+  \/\/ JNI count is directly set to zero.\n+  assert(_held_monitor_count >= _jni_monitor_count || is_exiting(), \"Monitor count discrepancy detected - held count \"\n+         INTX_FORMAT \" is less than JNI count \" INTX_FORMAT, _held_monitor_count, _jni_monitor_count);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":50,"deletions":14,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -383,0 +383,4 @@\n+  \/\/ This field is used to keep an nmethod visible to the GC so that it and its contained oops can\n+  \/\/ be kept alive\n+  nmethod*  _live_nmethod;\n+\n@@ -415,0 +419,9 @@\n+  void set_live_nmethod(nmethod* nm) {\n+    assert(_live_nmethod == nullptr, \"only one\");\n+    _live_nmethod = nm;\n+  }\n+\n+  void clear_live_nmethod() {\n+    _live_nmethod = nullptr;\n+  }\n+\n@@ -819,0 +832,1 @@\n+  static ByteSize jni_monitor_count_offset()  { return byte_offset_of(JavaThread, _jni_monitor_count); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -84,6 +84,0 @@\n-static void post_safepoint_cleanup_event(EventSafepointCleanup& event, uint64_t safepoint_id) {\n-  if (event.should_commit()) {\n-    event.set_safepointId(safepoint_id);\n-    event.commit();\n-  }\n-}\n@@ -105,10 +99,0 @@\n-static void post_safepoint_cleanup_task_event(EventSafepointCleanupTask& event,\n-                                              uint64_t safepoint_id,\n-                                              const char* name) {\n-  if (event.should_commit()) {\n-    event.set_safepointId(safepoint_id);\n-    event.set_name(name);\n-    event.commit();\n-  }\n-}\n-\n@@ -439,7 +423,0 @@\n-  \/\/ We do the safepoint cleanup first since a GC related safepoint\n-  \/\/ needs cleanup to be completed before running the GC op.\n-  EventSafepointCleanup cleanup_event;\n-  do_cleanup_tasks();\n-  post_safepoint_cleanup_event(cleanup_event, _safepoint_id);\n-\n-  SafepointTracing::cleanup();\n@@ -511,62 +488,0 @@\n-class ParallelCleanupTask : public WorkerTask {\n-private:\n-  SubTasksDone _subtasks;\n-\n-  class Tracer {\n-  private:\n-    const char*               _name;\n-    EventSafepointCleanupTask _event;\n-    TraceTime                 _timer;\n-\n-  public:\n-    Tracer(const char* name) :\n-        _name(name),\n-        _event(),\n-        _timer(name, TRACETIME_LOG(Info, safepoint, cleanup)) {}\n-    ~Tracer() {\n-      post_safepoint_cleanup_task_event(_event, SafepointSynchronize::safepoint_id(), _name);\n-    }\n-  };\n-\n-public:\n-  ParallelCleanupTask() :\n-    WorkerTask(\"Parallel Safepoint Cleanup\"),\n-    _subtasks(SafepointSynchronize::SAFEPOINT_CLEANUP_NUM_TASKS) {}\n-\n-  uint expected_num_workers() const {\n-    uint workers = 0;\n-\n-    return MAX2<uint>(1, workers);\n-  }\n-\n-  void work(uint worker_id) {\n-    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_REQUEST_OOPSTORAGE_CLEANUP)) {\n-      \/\/ Don't bother reporting event or time for this very short operation.\n-      \/\/ To have any utility we'd also want to report whether needed.\n-      OopStorage::trigger_cleanup_if_needed();\n-    }\n-\n-    _subtasks.all_tasks_claimed();\n-  }\n-};\n-\n-\/\/ Various cleaning tasks that should be done periodically at safepoints.\n-void SafepointSynchronize::do_cleanup_tasks() {\n-\n-  TraceTime timer(\"safepoint cleanup tasks\", TRACETIME_LOG(Info, safepoint, cleanup));\n-\n-  CollectedHeap* heap = Universe::heap();\n-  assert(heap != nullptr, \"heap not initialized yet?\");\n-  ParallelCleanupTask cleanup;\n-  WorkerThreads* cleanup_workers = heap->safepoint_workers();\n-  const uint expected_num_workers = cleanup.expected_num_workers();\n-  if (cleanup_workers != nullptr && expected_num_workers > 1) {\n-    \/\/ Parallel cleanup using GC provided thread pool.\n-    const uint num_workers = MIN2(expected_num_workers, cleanup_workers->active_workers());\n-    cleanup_workers->run_task(&cleanup, num_workers);\n-  } else {\n-    \/\/ Serial cleanup using VMThread.\n-    cleanup.work(0);\n-  }\n-}\n-\n@@ -970,1 +885,0 @@\n-jlong SafepointTracing::_last_safepoint_cleanup_time_ns = 0;\n@@ -978,1 +892,0 @@\n-jlong     SafepointTracing::_max_cleanup_time = 0;\n@@ -994,1 +907,1 @@\n-            \"[ time:       sync    cleanup       vmop      total ]\");\n+            \"[ time:       sync    vmop      total ]\");\n@@ -1023,2 +936,1 @@\n-           INT64_FORMAT_W(10) \" \" INT64_FORMAT_W(10) \" \"\n-           INT64_FORMAT_W(10) \" \" INT64_FORMAT_W(10) \" ]\",\n+           INT64_FORMAT_W(10) \" \" INT64_FORMAT_W(10) \" \" INT64_FORMAT_W(10) \" ]\",\n@@ -1026,2 +938,1 @@\n-           (int64_t)(_last_safepoint_cleanup_time_ns - _last_safepoint_sync_time_ns),\n-           (int64_t)(_last_safepoint_end_time_ns - _last_safepoint_cleanup_time_ns),\n+           (int64_t)(_last_safepoint_end_time_ns - _last_safepoint_sync_time_ns),\n@@ -1048,2 +959,0 @@\n-  log_info(safepoint, stats)(\"Maximum cleanup time  \" INT64_FORMAT\" ns\",\n-                              (int64_t)(_max_cleanup_time));\n@@ -1062,1 +971,0 @@\n-  _last_safepoint_cleanup_time_ns = 0;\n@@ -1078,4 +986,0 @@\n-void SafepointTracing::cleanup() {\n-  _last_safepoint_cleanup_time_ns = os::javaTimeNanos();\n-}\n-\n@@ -1088,3 +992,0 @@\n-  if (_max_cleanup_time < (_last_safepoint_cleanup_time_ns - _last_safepoint_sync_time_ns)) {\n-    _max_cleanup_time = _last_safepoint_cleanup_time_ns - _last_safepoint_sync_time_ns;\n-  }\n@@ -1102,1 +1003,0 @@\n-     \"Cleanup: \" JLONG_FORMAT \" ns, \"\n@@ -1108,2 +1008,1 @@\n-      _last_safepoint_cleanup_time_ns - _last_safepoint_sync_time_ns,\n-      _last_safepoint_end_time_ns     - _last_safepoint_cleanup_time_ns,\n+      _last_safepoint_end_time_ns     - _last_safepoint_sync_time_ns,\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":4,"deletions":105,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -1445,1 +1445,1 @@\n-  return entry_for_handle_wrong_method(callee_method, false, is_optimized, caller_is_c1);\n+  return get_resolved_entry(current, callee_method, false, is_optimized, caller_is_c1);\n@@ -1505,1 +1505,1 @@\n-  return entry_for_handle_wrong_method(callee_method, is_static_call, is_optimized, caller_is_c1);\n+  return get_resolved_entry(current, callee_method, is_static_call, is_optimized, caller_is_c1);\n@@ -1542,0 +1542,21 @@\n+\/\/ return verified_code_entry if interp_only_mode is not set for the current thread;\n+\/\/ otherwise return c2i entry.\n+address SharedRuntime::get_resolved_entry(JavaThread* current, methodHandle callee_method,\n+                                          bool is_static_call, bool is_optimized, bool caller_is_c1) {\n+  if (current->is_interp_only_mode() && !callee_method->is_special_native_intrinsic()) {\n+    \/\/ In interp_only_mode we need to go to the interpreted entry\n+    \/\/ The c2i won't patch in this mode -- see fixup_callers_callsite\n+    return callee_method->get_c2i_entry();\n+  }\n+\n+  if (caller_is_c1) {\n+    assert(callee_method->verified_inline_code_entry() != nullptr, \"Jump to zero!\");\n+    return callee_method->verified_inline_code_entry();\n+  } else if (is_static_call || is_optimized) {\n+    assert(callee_method->verified_code_entry() != nullptr, \"Jump to zero!\");\n+    return callee_method->verified_code_entry();\n+  } else {\n+    assert(callee_method->verified_inline_ro_code_entry() != nullptr, \"Jump to zero!\");\n+    return callee_method->verified_inline_ro_code_entry();\n+  }\n+}\n@@ -1551,28 +1572,1 @@\n-\n-    if (current->is_interp_only_mode()) {\n-      RegisterMap reg_map(current,\n-                          RegisterMap::UpdateMap::skip,\n-                          RegisterMap::ProcessFrames::include,\n-                          RegisterMap::WalkContinuation::skip);\n-      frame stub_frame = current->last_frame();\n-      assert(stub_frame.is_runtime_frame(), \"must be a runtimeStub\");\n-      frame caller = stub_frame.sender(&reg_map);\n-      enter_special = caller.cb() != nullptr && caller.cb()->is_nmethod()\n-        && caller.cb()->as_nmethod()->method()->is_continuation_enter_intrinsic();\n-    }\n-\n-  if (current->is_interp_only_mode() && enter_special) {\n-    \/\/ enterSpecial is compiled and calls this method to resolve the call to Continuation::enter\n-    \/\/ but in interp_only_mode we need to go to the interpreted entry\n-    \/\/ The c2i won't patch in this mode -- see fixup_callers_callsite\n-    \/\/\n-    \/\/ This should probably be done in all cases, not just enterSpecial (see JDK-8218403),\n-    \/\/ but that's part of a larger fix, and the situation is worse for enterSpecial, as it has no\n-    \/\/ interpreted version.\n-    return callee_method->get_c2i_entry();\n-  }\n-\n-  address entry = caller_is_c1 ?\n-    callee_method->verified_inline_code_entry() : callee_method->verified_code_entry();\n-  assert(entry != nullptr, \"Jump to zero!\");\n-  return entry;\n+  return get_resolved_entry(current, callee_method, true, false, caller_is_c1);\n@@ -1583,1 +1577,0 @@\n-\n@@ -1593,4 +1586,1 @@\n-  address entry = caller_is_c1 ?\n-    callee_method->verified_inline_code_entry() : callee_method->verified_inline_ro_code_entry();\n-  assert(entry != nullptr, \"Jump to zero!\");\n-  return entry;\n+  return get_resolved_entry(current, callee_method, false, false, caller_is_c1);\n@@ -1610,4 +1600,1 @@\n-  address entry = caller_is_c1 ?\n-    callee_method->verified_inline_code_entry() : callee_method->verified_code_entry();\n-  assert(entry != nullptr, \"Jump to zero!\");\n-  return entry;\n+  return get_resolved_entry(current, callee_method, false, true, caller_is_c1);\n@@ -2039,0 +2026,14 @@\n+\/\/ This is only called when CheckJNICalls is true, and only\n+\/\/ for virtual thread termination.\n+JRT_LEAF(void,  SharedRuntime::log_jni_monitor_still_held())\n+  assert(CheckJNICalls, \"Only call this when checking JNI usage\");\n+  if (log_is_enabled(Debug, jni)) {\n+    JavaThread* current = JavaThread::current();\n+    int64_t vthread_id = java_lang_Thread::thread_id(current->vthread());\n+    int64_t carrier_id = java_lang_Thread::thread_id(current->threadObj());\n+    log_debug(jni)(\"VirtualThread (tid: \" INT64_FORMAT \", carrier id: \" INT64_FORMAT\n+                   \") exiting with Objects still locked by JNI MonitorEnter.\",\n+                   vthread_id, carrier_id);\n+  }\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":40,"deletions":39,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -353,12 +353,2 @@\n-  static address entry_for_handle_wrong_method(methodHandle callee_method, bool is_static_call, bool is_optimized, bool caller_is_c1) {\n-    assert(callee_method->verified_code_entry() != nullptr, \"Jump to zero!\");\n-    assert(callee_method->verified_inline_code_entry() != nullptr, \"Jump to zero!\");\n-    assert(callee_method->verified_inline_ro_code_entry() != nullptr, \"Jump to zero!\");\n-    if (caller_is_c1) {\n-      return callee_method->verified_inline_code_entry();\n-    } else if (is_static_call || is_optimized) {\n-      return callee_method->verified_code_entry();\n-    } else {\n-      return callee_method->verified_inline_ro_code_entry();\n-    }\n-  }\n+  \/\/ Issue UL warning for unlocked JNI monitor on virtual thread termination\n+  static void log_jni_monitor_still_held();\n@@ -525,0 +515,2 @@\n+  static address get_resolved_entry        (JavaThread* current, methodHandle callee_method,\n+                                            bool is_static_call, bool is_optimized, bool caller_is_c1);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"oops\/klass.hpp\"\n@@ -197,0 +198,4 @@\n+address StubRoutines::_lookup_secondary_supers_table_slow_path_stub = nullptr;\n+address StubRoutines::_lookup_secondary_supers_table_stubs[Klass::SECONDARY_SUPERS_TABLE_SIZE] = { nullptr };\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -280,0 +280,3 @@\n+  static address _lookup_secondary_supers_table_stubs[];\n+  static address _lookup_secondary_supers_table_slow_path_stub;\n+\n@@ -485,0 +488,11 @@\n+  static address lookup_secondary_supers_table_stub(u1 slot) {\n+    assert(slot < Klass::SECONDARY_SUPERS_TABLE_SIZE, \"out of bounds\");\n+    assert(_lookup_secondary_supers_table_stubs[slot] != nullptr, \"not implemented\");\n+    return _lookup_secondary_supers_table_stubs[slot];\n+  }\n+\n+  static address lookup_secondary_supers_table_slow_path_stub() {\n+    assert(_lookup_secondary_supers_table_slow_path_stub != nullptr, \"not implemented\");\n+    return _lookup_secondary_supers_table_slow_path_stub;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-  template(VirtualThreadGetCurrentLocation)       \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,0 +153,5 @@\n+#ifdef _LP64\n+#define UINTX_FORMAT_X_0         \"0x%016\"     PRIxPTR\n+#else\n+#define UINTX_FORMAT_X_0         \"0x%08\"      PRIxPTR\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -2494,0 +2493,3 @@\n+            public void putCharUTF16(byte[] bytes, int index, int ch) {\n+                StringUTF16.putChar(bytes, index, ch);\n+            }\n@@ -2534,0 +2536,4 @@\n+            public long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value) {\n+                return StringConcatHelper.prepend(indexCoder, buf, value);\n+            }\n+\n@@ -2542,3 +2548,6 @@\n-            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-            public long stringConcatCoder(char value) {\n-                return StringConcatHelper.coder(value);\n+            public long stringConcatMix(long lengthCoder, char value) {\n+                return StringConcatHelper.mix(lengthCoder, value);\n+            }\n+\n+            public int stringSize(long i) {\n+                return Long.stringSize(i);\n@@ -2547,4 +2556,2 @@\n-            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-            public long stringBuilderConcatMix(long lengthCoder,\n-                                               StringBuilder sb) {\n-                return sb.mix(lengthCoder);\n+            public int getCharsLatin1(long i, int index, byte[] buf) {\n+                return StringLatin1.getChars(i, index, buf);\n@@ -2553,4 +2560,2 @@\n-            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-            public long stringBuilderConcatPrepend(long lengthCoder, byte[] buf,\n-                                                   StringBuilder sb) {\n-                return sb.prepend(lengthCoder, buf);\n+            public int getCharsUTF16(long i, int index, byte[] buf) {\n+                return StringUTF16.getChars(i, index, buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -241,0 +241,6 @@\n+ * <p>\n+ * Unless otherwise noted, passing a {@code null} argument to a constructor\n+ * or method of any Class-File API class or interface will cause a {@link\n+ * java.lang.NullPointerException NullPointerException} to be thrown. Additionally,\n+ * invoking a method with an array or collection containing a {@code null} element\n+ * will cause a {@code NullPointerException}, unless otherwise specified. <\/p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -181,4 +181,5 @@\n-        \/\/ lambda class has no access to the resolved method. Instead, we need\n-        \/\/ to pass the live implementation method handle to the proxy class\n-        \/\/ to invoke directly. (javac prefers to avoid this situation by\n-        \/\/ generating bridges in the target class)\n+        \/\/ lambda class has no access to the resolved method, or does\n+        \/\/ 'invokestatic' on a hidden class which cannot be resolved by name.\n+        \/\/ Instead, we need to pass the live implementation method handle to\n+        \/\/ the proxy class to invoke directly. (javac prefers to avoid this\n+        \/\/ situation by generating bridges in the target class)\n@@ -187,1 +188,2 @@\n-                               implKind == H_INVOKESPECIAL;\n+                               implKind == H_INVOKESPECIAL ||\n+                               implKind == H_INVOKESTATIC && implClass.isHidden();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -368,0 +368,9 @@\n+    \/**\n+     * Put the char at index in a byte[] in internal UTF-16 representation,\n+     * with no bounds checks.\n+     *\n+     * @param bytes the UTF-16 encoded bytes\n+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)\n+     *\/\n+    void putCharUTF16(byte[] bytes, int index, int ch);\n+\n@@ -421,0 +430,6 @@\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\/\n+    long stringConcatHelperPrepend(long indexCoder, byte[] buf, String value);\n+\n@@ -431,13 +446,3 @@\n-   \/**\n-    * Get the coder for the supplied character.\n-    *\/\n-   long stringConcatCoder(char value);\n-\n-   \/**\n-    * Update lengthCoder for StringBuilder.\n-    *\/\n-   long stringBuilderConcatMix(long lengthCoder, StringBuilder sb);\n-\n-     * Prepend StringBuilder content.\n-    *\/\n-   long stringBuilderConcatPrepend(long lengthCoder, byte[] buf, StringBuilder sb);\n+     * Mix value length and coder into current length and coder.\n+     *\/\n+    long stringConcatMix(long lengthCoder, char value);\n@@ -458,0 +463,6 @@\n+    int stringSize(long i);\n+\n+    int getCharsLatin1(long i, int index, byte[] buf);\n+\n+    int getCharsUTF16(long i, int index, byte[] buf);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -629,14 +628,0 @@\n-    \/**\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n-     *\n-     * @param node {@inheritDoc}\n-     * @param p {@inheritDoc}\n-     * @return  the result of {@code defaultAction}\n-     * @since 21\n-     *\/\n-    @Override\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-    public R visitStringTemplate(StringTemplateTree node, P p) {\n-        return defaultAction(node, p);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -776,18 +775,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation scans the children in left to right order.\n-     *\n-     * @param node  {@inheritDoc}\n-     * @param p  {@inheritDoc}\n-     * @return the result of scanning\n-     * @since 21\n-     *\/\n-    @Override\n-    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n-    public R visitStringTemplate(StringTemplateTree node, P p) {\n-        R r = scan(node.getProcessor(), p);\n-        r = scanAndReduce(node.getExpressions(), p, r);\n-        return r;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -210,1 +210,0 @@\n-            case STRING_TEMPLATES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -266,1 +266,0 @@\n-        STRING_TEMPLATES(JDK21, Fragments.FeatureStringTemplates, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,6 +243,0 @@\n-    \/\/ For string templates\n-    public final Type stringTemplateType;\n-    public final Type templateRuntimeType;\n-    public final Type processorType;\n-    public final Type linkageType;\n-\n@@ -660,6 +654,0 @@\n-        \/\/ For string templates\n-        stringTemplateType = enterClass(\"java.lang.StringTemplate\");\n-        templateRuntimeType = enterClass(\"java.lang.runtime.TemplateRuntime\");\n-        processorType = enterClass(\"java.lang.StringTemplate$Processor\");\n-        linkageType = enterClass(\"java.lang.StringTemplate$Processor$Linkage\");\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -5025,26 +5025,0 @@\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        JCExpression processor = tree.processor;\n-        Type processorType = attribTree(processor, env, new ResultInfo(KindSelector.VAL, Type.noType));\n-        chk.checkProcessorType(processor, processorType, env);\n-        Type processMethodType = getProcessMethodType(tree, processorType);\n-        tree.processMethodType = processMethodType;\n-        Type resultType = processMethodType.getReturnType();\n-\n-        Env<AttrContext> localEnv = env.dup(tree, env.info.dup());\n-\n-        for (JCExpression arg : tree.expressions) {\n-            chk.checkNonVoid(arg.pos(), attribExpr(arg, localEnv));\n-        }\n-\n-        tree.type = resultType;\n-        result = resultType;\n-        check(tree, resultType, KindSelector.VAL, resultInfo);\n-    }\n-\n-    private Type getProcessMethodType(JCStringTemplate tree, Type processorType) {\n-        MethodSymbol processSymbol = rs.resolveInternalMethod(tree.pos(),\n-                env, types.skipTypeVars(processorType, false),\n-                names.process, List.of(syms.stringTemplateType), List.nil());\n-        return types.memberType(processorType, processSymbol);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4574,20 +4574,0 @@\n-    public Type checkProcessorType(JCExpression processor, Type resultType, Env<AttrContext> env) {\n-        Type processorType = processor.type;\n-        Type interfaceType = types.asSuper(processorType, syms.processorType.tsym);\n-\n-        if (interfaceType != null) {\n-            List<Type> typeArguments = interfaceType.getTypeArguments();\n-\n-            if (typeArguments.size() == 2) {\n-                resultType = typeArguments.head;\n-            } else {\n-                resultType = syms.objectType;\n-            }\n-        } else {\n-            log.error(DiagnosticFlag.RESOLVE_ERROR, processor.pos,\n-                    Errors.NotAProcessorType(processorType.tsym));\n-        }\n-\n-        return resultType;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -342,23 +342,0 @@\n-        private void staticImports(JCCompilationUnit tree, Env<AttrContext> env, ImportFilter staticImportFilter) {\n-             if (preview.isEnabled() && preview.isPreview(Feature.STRING_TEMPLATES)) {\n-                Lint prevLint = chk.setLint(lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));\n-                boolean prevPreviewCheck = chk.disablePreviewCheck;\n-\n-                try {\n-                    chk.disablePreviewCheck = true;\n-                    String autoImports = \"\"\"\n-                            import static java.lang.StringTemplate.STR;\n-                            \"\"\";\n-                    Parser parser = parserFactory.newParser(autoImports, false, false, false, false);\n-                    JCCompilationUnit importTree = parser.parseCompilationUnit();\n-\n-                    for (JCImport imp : importTree.getImports()) {\n-                        doImport(imp);\n-                    }\n-                } finally {\n-                    chk.setLint(prevLint);\n-                    chk.disablePreviewCheck = prevPreviewCheck;\n-                }\n-            }\n-        }\n-\n@@ -388,1 +365,0 @@\n-                staticImports(tree, env, staticImportFilter);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -707,53 +707,0 @@\n-    \/**\n-     * StringTemplate =\n-     *    [STRINGFRAGMENT] [EmbeddedExpression]\n-     *  | STRINGLITERAL\n-     *\n-     * EmbeddedExpression =\n-     *  LBRACE term RBRACE\n-     *\/\n-    JCExpression stringTemplate(JCExpression processor) {\n-        checkSourceLevel(Feature.STRING_TEMPLATES);\n-        \/\/ Disable standalone string templates\n-        if (processor == null) {\n-            log.error(DiagnosticFlag.SYNTAX, token.pos,\n-                    Errors.ProcessorMissingFromStringTemplateExpression);\n-        }\n-        int oldmode = mode;\n-        selectExprMode();\n-        Token stringToken = token;\n-        int pos = stringToken.pos;\n-        int endPos = stringToken.endPos;\n-        TokenKind kind = stringToken.kind;\n-        String string = token.stringVal();\n-        List<String> fragments = List.of(string);\n-        List<JCExpression> expressions = List.nil();\n-        nextToken();\n-        if (kind != STRINGLITERAL) {\n-            while (token.kind == STRINGFRAGMENT) {\n-                stringToken = token;\n-                endPos = stringToken.endPos;\n-                string = stringToken.stringVal();\n-                fragments = fragments.append(string);\n-                nextToken();\n-             }\n-            while (token.pos < endPos && token.kind != DEFAULT && token.kind != ERROR) {\n-                accept(LBRACE);\n-                JCExpression expression = token.kind == RBRACE ? F.at(pos).Literal(TypeTag.BOT, null)\n-                                                               : term(EXPR);\n-                expressions = expressions.append(expression);\n-                if (token.kind != ERROR) {\n-                    accept(RBRACE);\n-                }\n-            }\n-            \/\/ clean up remaining expression tokens if error\n-            while (token.pos < endPos && token.kind != DEFAULT) {\n-                nextToken();\n-            }\n-            S.setPrevToken(stringToken);\n-        }\n-        JCExpression t = toP(F.at(pos).StringTemplate(processor, fragments, expressions));\n-        setMode(oldmode);\n-        return t;\n-    }\n-\n@@ -1437,8 +1384,0 @@\n-         case STRINGFRAGMENT:\n-             if (typeArgs == null && isMode(EXPR)) {\n-                 selectExprMode();\n-                 t = stringTemplate(null);\n-             } else {\n-                 return illegal();\n-             }\n-             break;\n@@ -1575,6 +1514,0 @@\n-                            case STRINGFRAGMENT:\n-                            case STRINGLITERAL:\n-                                if (typeArgs != null) return illegal();\n-                                t = stringTemplate(t);\n-                                typeArgs = null;\n-                                break loop;\n@@ -1804,6 +1737,0 @@\n-                } else if (token.kind == TokenKind.STRINGFRAGMENT ||\n-                           token.kind == TokenKind.STRINGLITERAL) {\n-                    if (typeArgs != null) {\n-                        return illegal();\n-                    }\n-                    t = stringTemplate(t);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1364,13 +1364,0 @@\n-compiler.err.string.template.is.not.well.formed=\\\n-    string template is not well formed\n-\n-compiler.err.text.block.template.is.not.well.formed=\\\n-    text block template is not well formed\n-\n-compiler.err.processor.missing.from.string.template.expression=\\\n-    processor missing from string template expression\n-\n-# 0: symbol\n-compiler.err.not.a.processor.type=\\\n-    not a processor type: {0}\n-\n@@ -3231,3 +3218,0 @@\n-compiler.misc.feature.string.templates=\\\n-    string templates\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,8 +236,0 @@\n-    \/\/ templated string\n-    public final Name process;\n-    public final Name STR;\n-    public final Name RAW;\n-    public final Name newStringTemplate;\n-    public final Name newLargeStringTemplate;\n-    public final Name processStringTemplate;\n-\n@@ -426,7 +418,0 @@\n-        \/\/ templated string\n-        process = fromString(\"process\");\n-        STR = fromString(\"STR\");\n-        RAW = fromString(\"RAW\");\n-        newStringTemplate = fromString(\"newStringTemplate\");\n-        newLargeStringTemplate = fromString(\"newLargeStringTemplate\");\n-        processStringTemplate = fromString(\"processStringTemplate\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+serviceability\/jvmti\/vthread\/GetThreadStateMountedTest\/GetThreadStateMountedTest.java 8318090,8318729 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8330467\n@@ -82,1 +83,2 @@\n-        compileSources(SRC_DIR, CLASSES_DIR, \"--enable-preview\", \"--release\", \"23\");\n+        compileSources(SRC_DIR, CLASSES_DIR, \"--enable-preview\",\n+                       \"--release\", Integer.toString(Runtime.version().feature()));\n@@ -184,0 +186,14 @@\n+    \/\/ Define a hidden class that uses lambda and contains its implementation\n+    \/\/ This verifies LambdaMetaFactory supports the caller which is a hidden class\n+    @Test\n+    public void testHiddenLambda() throws Throwable {\n+        HiddenTest t = (HiddenTest)defineHiddenClass(\"HiddenLambda\").newInstance();\n+        try {\n+            t.test();\n+        } catch (Error e) {\n+            if (!e.getMessage().equals(\"thrown by \" + t.getClass().getName())) {\n+                throw e;\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/BasicTest.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"}]}