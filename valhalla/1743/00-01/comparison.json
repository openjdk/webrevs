{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import java.util.HashSet;\n@@ -42,0 +43,1 @@\n+import java.util.Set;\n@@ -45,0 +47,2 @@\n+import static java.util.stream.Collectors.toList;\n+\n@@ -83,1 +87,1 @@\n-        private List<PathNode> children;\n+        private List<String> childNames;\n@@ -85,0 +89,6 @@\n+        \/**\n+         * Creates a file based node with the given file attributes.\n+         *\n+         * <p>If the underlying path is a directory, then it is created in an\n+         * \"incomplete\" state, and its child names will be determined lazily.\n+         *\/\n@@ -93,0 +103,1 @@\n+        \/** Creates a symbolic link node to the specified target. *\/\n@@ -98,0 +109,1 @@\n+        \/** Creates a completed directory node based a list of child nodes. *\/\n@@ -100,1 +112,1 @@\n-            this.children = children;\n+            this.childNames = children.stream().map(Node::getName).collect(toList());\n@@ -110,2 +122,2 @@\n-            return children != null ||\n-                   (link == null && getFileAttributes().isDirectory());\n+            return childNames != null ||\n+                    (link == null && getFileAttributes().isDirectory());\n@@ -136,3 +148,3 @@\n-            List<PathNode> childNodes = children;\n-            if (childNodes == null) {\n-                childNodes = completeDirectory();\n+            List<String> names = childNames;\n+            if (names == null) {\n+                names = completeDirectory();\n@@ -140,1 +152,1 @@\n-            return childNodes.stream().map(Node::getName);\n+            return names.stream();\n@@ -143,3 +155,3 @@\n-        private synchronized List<PathNode> completeDirectory() {\n-            if (children != null) {\n-                return children;\n+        private synchronized List<String> completeDirectory() {\n+            if (childNames != null) {\n+                return childNames;\n@@ -147,2 +159,4 @@\n-            List<PathNode> list = new ArrayList<>();\n-            if (relPath.getNameCount() > 1 && !relPath.getName(1).equals(META_INF_DIR)) {\n+            \/\/ Process preview nodes first, so if nodes are created they take\n+            \/\/ precedence in the cache.\n+            Set<String> childNameSet = new HashSet<>();\n+            if (isPreviewMode && relPath.getNameCount() > 1 && !relPath.getName(1).equals(META_INF_DIR)) {\n@@ -154,1 +168,1 @@\n-                    collectChildNodes(absPreviewDir, list);\n+                    collectChildNodeNames(absPreviewDir, childNameSet);\n@@ -157,2 +171,2 @@\n-            collectChildNodes(modulesDir.resolve(relPath), list);\n-            return children = list;\n+            collectChildNodeNames(modulesDir.resolve(relPath), childNameSet);\n+            return childNames = childNameSet.stream().sorted().collect(toList());\n@@ -161,1 +175,1 @@\n-        private void collectChildNodes(Path absPath, List<PathNode> list) {\n+        private void collectChildNodeNames(Path absPath, Set<String> childNameSet) {\n@@ -166,1 +180,1 @@\n-                        list.add(node);\n+                        childNameSet.add(node.getName());\n@@ -256,1 +270,1 @@\n-    private Node createModulesNode(String name, Path path) {\n+    private PathNode createModulesNode(String name, Path path) {\n@@ -278,1 +292,1 @@\n-            \/\/ Since the path reference a file, any errors should not be ignored.\n+            \/\/ Since the path references a file errors should not be ignored.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/ExplodedImage.java","additions":34,"deletions":20,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import java.util.stream.Stream;\n@@ -346,1 +347,2 @@\n-        Set<String> localChildNames = dir.getChildNames()\n+        \/\/ Use a list (not a set) to avoid hiding duplicate entries.\n+        List<String> localChildNames = dir.getChildNames()\n@@ -349,1 +351,2 @@\n-                .collect(toSet());\n+                .sorted()\n+                .toList();\n@@ -351,1 +354,1 @@\n-                Set.of(expectedChildNames),\n+                Stream.of(expectedChildNames).sorted().toList(),\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/SystemImageTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}