{"files":[{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.jimage.ImageReader.Node;\n+\n@@ -33,0 +35,1 @@\n+import java.nio.file.Paths;\n@@ -39,0 +42,1 @@\n+import java.util.regex.Pattern;\n@@ -41,2 +45,0 @@\n-import jdk.internal.jimage.ImageReader.Node;\n-\n@@ -57,0 +59,2 @@\n+    private static final Path META_INF_DIR = Paths.get(\"META-INF\");\n+    private static final Path PREVIEW_DIR = META_INF_DIR.resolve(\"preview\");\n@@ -59,0 +63,1 @@\n+    private final boolean isPreviewMode;\n@@ -63,1 +68,1 @@\n-    ExplodedImage(Path modulesDir) throws IOException {\n+    ExplodedImage(Path modulesDir, boolean isPreviewMode) throws IOException {\n@@ -65,0 +70,1 @@\n+        this.isPreviewMode = isPreviewMode;\n@@ -73,3 +79,3 @@\n-\n-        \/\/ Path in underlying default file system\n-        private Path path;\n+        \/\/ Path in underlying default file system relative to modulesDir.\n+        \/\/ In preview mode this need not correspond to the node's name.\n+        private Path relPath;\n@@ -77,1 +83,1 @@\n-        private List<Node> children;\n+        private List<PathNode> children;\n@@ -81,1 +87,4 @@\n-            this.path = path;\n+            this.relPath = modulesDir.relativize(path);\n+            if (relPath.isAbsolute() || relPath.getNameCount() == 0) {\n+                throw new IllegalArgumentException(\"Invalid node path (must be relative): \" + path);\n+            }\n@@ -89,1 +98,1 @@\n-        private PathNode(String name, List<Node> children) {    \/\/ dir\n+        private PathNode(String name, List<PathNode> children) {    \/\/ dir\n@@ -120,1 +129,1 @@\n-            return Files.readAllBytes(path);\n+            return Files.readAllBytes(modulesDir.resolve(relPath));\n@@ -126,11 +135,32 @@\n-                throw new IllegalArgumentException(\"not a directory: \" + getName());\n-            if (children == null) {\n-                List<Node> list = new ArrayList<>();\n-                try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {\n-                    for (Path p : stream) {\n-                        p = modulesDir.relativize(p);\n-                        String pName = MODULES + nativeSlashToFrontSlash(p.toString());\n-                        Node node = findNode(pName);\n-                        if (node != null) {  \/\/ findNode may choose to hide certain files!\n-                            list.add(node);\n-                        }\n+                throw new IllegalStateException(\"not a directory: \" + getName());\n+            List<PathNode> childNodes = children;\n+            if (childNodes == null) {\n+                childNodes = completeDirectory();\n+            }\n+            return childNodes.stream().map(Node::getName);\n+        }\n+\n+        private synchronized List<PathNode> completeDirectory() {\n+            if (children != null) {\n+                return children;\n+            }\n+            List<PathNode> list = new ArrayList<>();\n+            if (relPath.getNameCount() > 1 && !relPath.getName(1).equals(META_INF_DIR)) {\n+                Path absPreviewDir = modulesDir\n+                        .resolve(relPath.getName(0))\n+                        .resolve(PREVIEW_DIR)\n+                        .resolve(relPath.subpath(1, relPath.getNameCount()));\n+                if (Files.exists(absPreviewDir)) {\n+                    collectChildNodes(absPreviewDir, list);\n+                }\n+            }\n+            collectChildNodes(modulesDir.resolve(relPath), list);\n+            return children = list;\n+        }\n+\n+        private void collectChildNodes(Path absPath, List<PathNode> list) {\n+            try (DirectoryStream<Path> stream = Files.newDirectoryStream(absPath)) {\n+                for (Path p : stream) {\n+                    PathNode node = (PathNode) findNode(getName() + \"\/\" + p.getFileName().toString());\n+                    if (node != null) {  \/\/ findNode may choose to hide certain files!\n+                        list.add(node);\n@@ -138,2 +168,0 @@\n-                } catch (IOException x) {\n-                    return null;\n@@ -141,1 +169,2 @@\n-                children = list;\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n@@ -143,1 +172,0 @@\n-            return children.stream().map(Node::getName);\n@@ -149,1 +177,1 @@\n-                return isDirectory() ? 0 : Files.size(path);\n+                return isDirectory() ? 0 : Files.size(modulesDir.resolve(relPath));\n@@ -183,0 +211,36 @@\n+    \/**\n+     * Returns the expected file path for name in the \"\/modules\/...\" namespace,\n+     * or {@code null} if the name is not in the \"\/modules\/...\" namespace or the\n+     * path does not reference a file.\n+     *\/\n+    private Path underlyingModulesPath(String name) {\n+        if (!isNonEmptyModulesName(name)) {\n+            return null;\n+        }\n+        String relName = name.substring(MODULES.length());\n+        Path relPath = Paths.get(frontSlashToNativeSlash(relName));\n+        \/\/ The first path segment must exist due to check above.\n+        Path modDir = relPath.getName(0);\n+        Path previewDir = modDir.resolve(PREVIEW_DIR);\n+        if (relPath.startsWith(previewDir)) {\n+            return null;\n+        }\n+        Path path = modulesDir.resolve(relPath);\n+        \/\/ Non-preview directories take precedence.\n+        if (Files.isDirectory(path)) {\n+            return path;\n+        }\n+        \/\/ Otherwise prefer preview resources over non-preview ones.\n+        if (isPreviewMode\n+                && relPath.getNameCount() > 1\n+                && !modDir.equals(META_INF_DIR)) {\n+            Path previewPath = modulesDir\n+                    .resolve(previewDir)\n+                    .resolve(relPath.subpath(1, relPath.getNameCount()));\n+            if (Files.exists(previewPath)) {\n+                return previewPath;\n+            }\n+        }\n+        return Files.exists(path) ? path : null;\n+    }\n+\n@@ -194,1 +258,1 @@\n-        assert isNonEmptyModulesPath(name) : \"Invalid modules name: \" + name;\n+        assert isNonEmptyModulesName(name) : \"Invalid modules name: \" + name;\n@@ -219,12 +283,2 @@\n-    \/**\n-     * Returns the expected file path for name in the \"\/modules\/...\" namespace,\n-     * or {@code null} if the name is not in the \"\/modules\/...\" namespace or the\n-     * path does not reference a file.\n-     *\/\n-    private Path underlyingModulesPath(String name) {\n-        if (isNonEmptyModulesPath(name)) {\n-            Path path = modulesDir.resolve(frontSlashToNativeSlash(name.substring(MODULES.length())));\n-            return Files.exists(path) ? path : null;\n-        }\n-        return null;\n-    }\n+    private static final Pattern NON_EMPTY_MODULES_NAME =\n+            Pattern.compile(\"\/modules(\/[^\/]+)+\");\n@@ -232,1 +286,1 @@\n-    private static boolean isNonEmptyModulesPath(String name) {\n+    private static boolean isNonEmptyModulesName(String name) {\n@@ -235,1 +289,5 @@\n-        return name.startsWith(MODULES) && name.length() > MODULES.length();\n+        \/\/ Also make sure we can't be tricked by \"\/modules\/\/absolute\/path\" or\n+        \/\/ \"\/modules\/..\/..\/escaped\/path\"\n+        return NON_EMPTY_MODULES_NAME.matcher(name).matches()\n+                && !name.contains(\"\/..\/\")\n+                && !name.contains(\"\/.\/\");\n@@ -243,5 +301,0 @@\n-    \/\/ convert platform path separator to \"\/\"\n-    private String nativeSlashToFrontSlash(String str) {\n-        return separator == null ? str : str.replace(separator, \"\/\");\n-    }\n-\n@@ -259,17 +312,3 @@\n-            for (Path module : stream) {\n-                if (Files.isDirectory(module)) {\n-                    String moduleName = module.getFileName().toString();\n-                    \/\/ make sure \"\/modules\/<moduleName>\" is created\n-                    Objects.requireNonNull(createModulesNode(MODULES + moduleName, module));\n-                    try (Stream<Path> contentsStream = Files.walk(module)) {\n-                        contentsStream.filter(Files::isDirectory).forEach((p) -> {\n-                            p = module.relativize(p);\n-                            String pkgName = slashesToDots(p.toString());\n-                            \/\/ skip META-INF and empty strings\n-                            if (!pkgName.isEmpty() && !pkgName.startsWith(\"META-INF\")) {\n-                                packageToModules\n-                                        .computeIfAbsent(pkgName, k -> new ArrayList<>())\n-                                        .add(moduleName);\n-                            }\n-                        });\n-                    }\n+            for (Path moduleDir : stream) {\n+                if (Files.isDirectory(moduleDir)) {\n+                    processModuleDirectory(moduleDir, packageToModules);\n@@ -285,1 +324,1 @@\n-        List<Node> packagesChildren = new ArrayList<>(packageToModules.size());\n+        List<PathNode> packagesChildren = new ArrayList<>(packageToModules.size());\n@@ -289,1 +328,1 @@\n-            List<Node> moduleLinkNodes = new ArrayList<>(moduleNameList.size());\n+            List<PathNode> moduleLinkNodes = new ArrayList<>(moduleNameList.size());\n@@ -305,1 +344,1 @@\n-        List<Node> rootChildren = new ArrayList<>();\n+        List<PathNode> rootChildren = new ArrayList<>();\n@@ -311,0 +350,30 @@\n+\n+    private void processModuleDirectory(Path moduleDir, Map<String, List<String>> packageToModules)\n+            throws IOException {\n+        String moduleName = moduleDir.getFileName().toString();\n+        \/\/ Make sure \"\/modules\/<moduleName>\" is created\n+        Objects.requireNonNull(createModulesNode(MODULES + moduleName, moduleDir));\n+        \/\/ Skip the first path (it's always the given root directory).\n+        try (Stream<Path> contentsStream = Files.walk(moduleDir).skip(1)) {\n+            contentsStream\n+                    \/\/ Non-empty relative directory paths inside each module.\n+                    .filter(Files::isDirectory)\n+                    .map(moduleDir::relativize)\n+                    \/\/ Map paths inside preview directory to non-preview versions.\n+                    .filter(p -> isPreviewMode || !p.startsWith(PREVIEW_DIR))\n+                    .map(p -> isPreviewSubpath(p) ? PREVIEW_DIR.relativize(p) : p)\n+                    \/\/ Ignore special META-INF directory (including preview directory itself).\n+                    .filter(p -> !p.startsWith(META_INF_DIR))\n+                    \/\/ Extract unique package names.\n+                    .map(p -> slashesToDots(p.toString()))\n+                    .distinct()\n+                    .forEach(pkgName ->\n+                            packageToModules\n+                                    .computeIfAbsent(pkgName, k -> new ArrayList<>())\n+                                    .add(moduleName));\n+        }\n+    }\n+\n+    private static boolean isPreviewSubpath(Path p) {\n+        return p.startsWith(PREVIEW_DIR) && p.getNameCount() > PREVIEW_DIR.getNameCount();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/ExplodedImage.java","additions":135,"deletions":66,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-@SuppressWarnings({ \"removal\", \"suppression\"} )\n-abstract class SystemImage {\n+@SuppressWarnings({\"removal\", \"suppression\"})\n+public abstract class SystemImage implements AutoCloseable {\n@@ -54,3 +54,3 @@\n-    abstract Node findNode(String path) throws IOException;\n-    abstract byte[] getResource(Node node) throws IOException;\n-    abstract void close() throws IOException;\n+    public abstract Node findNode(String path) throws IOException;\n+    public abstract byte[] getResource(Node node) throws IOException;\n+    public abstract void close() throws IOException;\n@@ -58,19 +58,10 @@\n-    static SystemImage open(PreviewMode mode) throws IOException {\n-        if (modulesImageExists) {\n-            \/\/ open a .jimage and build directory structure\n-            final ImageReader image = ImageReader.open(moduleImageFile, mode);\n-            return new SystemImage() {\n-                @Override\n-                Node findNode(String path) throws IOException {\n-                    return image.findNode(path);\n-                }\n-                @Override\n-                byte[] getResource(Node node) throws IOException {\n-                    return image.getResource(node);\n-                }\n-                @Override\n-                void close() throws IOException {\n-                    image.close();\n-                }\n-            };\n-        }\n+    \/**\n+     * Opens the system image for the current runtime.\n+     *\n+     * @param mode determines whether preview mode should be enabled.\n+     * @return a new system image based on either the jimage file or an \"exploded\"\n+     *     modules directory, according to the build state.\n+     *\/\n+    public static SystemImage open(PreviewMode mode) throws IOException {\n+        return modulesImageExists ? fromJimage(moduleImageFile, mode) : fromDirectory(explodedModulesDir, mode);\n+    }\n@@ -78,7 +69,25 @@\n-        if (Files.notExists(explodedModulesDir))\n-            throw new FileSystemNotFoundException(explodedModulesDir.toString());\n-        \/\/ TODO: Support preview mode in ExplodedImage and remove this check.\n-        if (mode.isPreviewModeEnabled())\n-            throw new UnsupportedOperationException(\n-                    \"Preview mode not yet supported for exploded images\");\n-        return new ExplodedImage(explodedModulesDir);\n+    \/** Internal factory method for testing only, use {@link SystemImage#open(PreviewMode)}. *\/\n+    public static SystemImage fromJimage(Path path, PreviewMode mode) throws IOException {\n+        final ImageReader image = ImageReader.open(path, mode);\n+        return new SystemImage() {\n+            @Override\n+            public Node findNode(String path) throws IOException {\n+                return image.findNode(path);\n+            }\n+            @Override\n+            public byte[] getResource(Node node) throws IOException {\n+                return image.getResource(node);\n+            }\n+            @Override\n+            public void close() throws IOException {\n+                image.close();\n+            }\n+        };\n+    }\n+\n+    \/** Internal factory method for testing only, use {@link SystemImage#open(PreviewMode)}. *\/\n+    public static SystemImage fromDirectory(Path modulesDir, PreviewMode mode) throws IOException {\n+        if (!Files.isDirectory(modulesDir)) {\n+            throw new FileSystemNotFoundException(modulesDir.toString());\n+        }\n+        return new ExplodedImage(modulesDir, mode.isPreviewModeEnabled());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/SystemImage.java","additions":40,"deletions":31,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -134,4 +134,4 @@\n-            assertEquals(\"Class: com.foo.HasPreviewVersion\", loader.loadAndGetToString(\"modfoo\", \"com.foo.HasPreviewVersion\"));\n-            assertEquals(\"Class: com.foo.NormalFoo\", loader.loadAndGetToString(\"modfoo\", \"com.foo.NormalFoo\"));\n-            assertEquals(\"Class: com.foo.bar.NormalBar\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.NormalBar\"));\n-            assertEquals(\"Class: com.bar.One\", loader.loadAndGetToString(\"modbar\", \"com.bar.One\"));\n+            assertNonPreviewVersion(loader, \"modfoo\", \"com.foo.HasPreviewVersion\");\n+            assertNonPreviewVersion(loader, \"modfoo\", \"com.foo.NormalFoo\");\n+            assertNonPreviewVersion(loader, \"modfoo\", \"com.foo.bar.NormalBar\");\n+            assertNonPreviewVersion(loader, \"modbar\", \"com.bar.One\");\n@@ -233,3 +233,3 @@\n-            assertEquals(\"Class: com.foo.HasPreviewVersion\", loader.loadAndGetToString(\"modfoo\", \"com.foo.HasPreviewVersion\"));\n-            assertEquals(\"Class: com.foo.NormalFoo\", loader.loadAndGetToString(\"modfoo\", \"com.foo.NormalFoo\"));\n-            assertEquals(\"Class: com.foo.bar.NormalBar\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.NormalBar\"));\n+            assertNonPreviewVersion(loader, \"modfoo\", \"com.foo.HasPreviewVersion\");\n+            assertNonPreviewVersion(loader, \"modfoo\", \"com.foo.NormalFoo\");\n+            assertNonPreviewVersion(loader, \"modfoo\", \"com.foo.bar.NormalBar\");\n@@ -251,4 +251,4 @@\n-            assertEquals(\"Preview: com.foo.HasPreviewVersion\", loader.loadAndGetToString(\"modfoo\", \"com.foo.HasPreviewVersion\"));\n-            assertEquals(\"Class: com.foo.NormalFoo\", loader.loadAndGetToString(\"modfoo\", \"com.foo.NormalFoo\"));\n-            assertEquals(\"Class: com.foo.bar.NormalBar\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.NormalBar\"));\n-            assertEquals(\"Preview: com.foo.bar.IsPreviewOnly\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.IsPreviewOnly\"));\n+            assertPreviewVersion(loader, \"modfoo\", \"com.foo.HasPreviewVersion\");\n+            assertNonPreviewVersion(loader, \"modfoo\", \"com.foo.NormalFoo\");\n+            assertNonPreviewVersion(loader, \"modfoo\", \"com.foo.bar.NormalBar\");\n+            assertPreviewVersion(loader, \"modfoo\", \"com.foo.bar.IsPreviewOnly\");\n@@ -338,3 +338,3 @@\n-            String alphaPath = \"com\/foo\/HasPreviewVersion.class\";\n-            assertNode(reader, \"\/modules\/modfoo\/\" + alphaPath);\n-            assertAbsent(reader, \"\/modules\/modfoo\/META-INF\/preview\/\" + alphaPath);\n+            String previewPath = \"com\/foo\/HasPreviewVersion.class\";\n+            assertNode(reader, \"\/modules\/modfoo\/\" + previewPath);\n+            assertAbsent(reader, \"\/modules\/modfoo\/META-INF\/preview\/\" + previewPath);\n@@ -377,0 +377,8 @@\n+    private static void assertNonPreviewVersion(ImageClassLoader loader, String module, String fqn) throws IOException {\n+        assertEquals(\"Class: \" + fqn, loader.loadAndGetToString(module, fqn));\n+    }\n+\n+    private static void assertPreviewVersion(ImageClassLoader loader, String module, String fqn) throws IOException {\n+        assertEquals(\"Preview: \" + fqn, loader.loadAndGetToString(module, fqn));\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageReaderTest.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,576 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.jimage.ImageReader;\n+import jdk.internal.jimage.PreviewMode;\n+import jdk.internal.jrtfs.SystemImage;\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import jdk.test.lib.util.JarBuilder;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.Parameter;\n+import org.junit.jupiter.params.ParameterizedClass;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import tests.Helper;\n+import tests.JImageGenerator;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.internal.jimage.PreviewMode.DISABLED;\n+import static jdk.internal.jimage.PreviewMode.ENABLED;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+\n+\/*\n+ * @test\n+ * @summary Tests for SystemImage to ensure parity between ImageReader and ExplodedImage.\n+ * @modules java.base\/jdk.internal.jimage\n+ *          java.base\/jdk.internal.jrtfs\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ * @library \/test\/jdk\/tools\/lib\n+ *          \/test\/lib\n+ * @build tests.*\n+ * @run junit\/othervm -esa -DDISABLE_PREVIEW_PATCHING=true SystemImageTest\n+ *\/\n+\/\/ FIXME: Currently the test output in Jtreg does not show the implementation.\n+\/\/ This is due to using both @ParameterizedClass and @ParameterizedTest to\n+\/\/ create a cross-product of test parameters. The parameters of parameterized\n+\/\/ tests are shown, but not the class level implementation choice.\n+\/\/\n+\/\/ If you are debugging a failure in this test, change the @EnumSource line to\n+\/\/ include 'names = {\"[SYSTEM|EXPLODED]\"}' to test a single implementation.\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+@ParameterizedClass\n+@EnumSource(SystemImageTest.ImageType.class)\n+class SystemImageTest {\n+    \/\/ Selects the underlying implementation to be tested.\n+    enum ImageType {SYSTEM, EXPLODED}\n+\n+    \/\/ The '@' prefix marks the entry as a preview entry which will be placed in\n+    \/\/ the '\/modules\/<module>\/META-INF\/preview\/...' path.\n+    private static final Map<String, List<String>> IMAGE_ENTRIES = Map.of(\n+            \"modfoo\", Arrays.asList(\n+                    \"com.foo.HasPreviewVersion\",\n+                    \"com.foo.NormalFoo\",\n+                    \"com.foo.bar.NormalBar\",\n+                    \/\/ Replaces original class in preview mode.\n+                    \"@com.foo.HasPreviewVersion\",\n+                    \/\/ New class in existing package in preview mode.\n+                    \"@com.foo.bar.IsPreviewOnly\"),\n+            \"modbar\", Arrays.asList(\n+                    \"com.bar.One\",\n+                    \"com.bar.Two\",\n+                    \/\/ Two new packages in preview mode (new symbolic links).\n+                    \"@com.bar.preview.stuff.Foo\",\n+                    \"@com.bar.preview.stuff.Bar\"),\n+            \"modgus\", Arrays.asList(\n+                    \/\/ A second module with a preview-only empty package (preview).\n+                    \"@com.bar.preview.other.Gus\"));\n+\n+    \/\/ Test data paths, built once for all tests.\n+    private Path jimageFile;\n+    private Path explodedModulesDir;\n+\n+    \/\/ The injected implementation type from @EnumSource.\n+    @Parameter(0)\n+    private ImageType implType;\n+\n+    @BeforeAll\n+    public void buildTestData(@TempDir Path modulesRoot) throws IOException {\n+        Helper helper = getHelper();\n+        \/\/ Compile into the helper's jar directory so jlink will include it.\n+        Path jarDir = compileModules(helper.getJarDir(), IMAGE_ENTRIES);\n+        this.jimageFile = buildJimage(helper, IMAGE_ENTRIES.keySet());\n+        explodeTestModules(jarDir, modulesRoot);\n+        this.explodedModulesDir = modulesRoot;\n+    }\n+\n+    \/\/ Make new images for each test based on the injected implementation type.\n+    private SystemImage getImage(PreviewMode mode) throws IOException {\n+        return switch (implType) {\n+            case SYSTEM -> SystemImage.fromJimage(jimageFile, mode);\n+            case EXPLODED -> SystemImage.fromDirectory(explodedModulesDir, mode);\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/\",\n+            \"\/modules\",\n+            \"\/modules\/modfoo\",\n+            \"\/modules\/modbar\",\n+            \"\/modules\/modfoo\/com\",\n+            \"\/modules\/modfoo\/com\/foo\",\n+            \"\/modules\/modfoo\/com\/foo\/bar\"})\n+    public void testModuleDirectories_expected(String name) throws IOException {\n+        try (var image = getImage(DISABLED)) {\n+            assertDir(image, name);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\",\n+            \"\/\/\",\n+            \"\/modules\/\",\n+            \"\/modules\/unknown\",\n+            \"\/modules\/modbar\/\",\n+            \"\/modules\/modfoo\/\/com\",\n+            \"\/modules\/modfoo\/com\/\"})\n+    public void testModuleNodes_absent(String name) throws IOException {\n+        try (var image = getImage(DISABLED)) {\n+            assertAbsent(image, name);\n+        }\n+    }\n+\n+    @Test\n+    public void testModuleResources() throws IOException {\n+        try (var image = getImage(DISABLED)) {\n+            assertNode(image, \"\/modules\/modfoo\/com\/foo\/HasPreviewVersion.class\");\n+            assertNode(image, \"\/modules\/modbar\/com\/bar\/One.class\");\n+\n+            ImageClassLoader loader = loader(image);\n+            loader.assertNonPreviewVersion(\"modfoo\", \"com.foo.HasPreviewVersion\");\n+            loader.assertNonPreviewVersion(\"modfoo\", \"com.foo.NormalFoo\");\n+            loader.assertNonPreviewVersion(\"modfoo\", \"com.foo.bar.NormalBar\");\n+            loader.assertNonPreviewVersion(\"modbar\", \"com.bar.One\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPackageDirectories() throws IOException {\n+        try (var image = getImage(DISABLED)) {\n+            ImageReader.Node root = assertDir(image, \"\/packages\");\n+            Set<String> pkgNames = root.getChildNames().collect(toSet());\n+            assertTrue(pkgNames.contains(\"\/packages\/com\"));\n+            assertTrue(pkgNames.contains(\"\/packages\/com.foo\"));\n+            assertTrue(pkgNames.contains(\"\/packages\/com.bar\"));\n+\n+            \/\/ Even though no classes exist directly in the \"com\" package, it still\n+            \/\/ creates a directory with links back to all the modules which contain it.\n+            Set<String> comLinks = assertDir(image, \"\/packages\/com\").getChildNames().collect(Collectors.toSet());\n+            assertTrue(comLinks.contains(\"\/packages\/com\/modfoo\"));\n+            assertTrue(comLinks.contains(\"\/packages\/com\/modbar\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testPackageLinks() throws IOException {\n+        try (var image = getImage(DISABLED)) {\n+            ImageReader.Node moduleFoo = assertDir(image, \"\/modules\/modfoo\");\n+            ImageReader.Node moduleBar = assertDir(image, \"\/modules\/modbar\");\n+            assertSame(assertLink(image, \"\/packages\/com.foo\/modfoo\").resolveLink(), moduleFoo);\n+            assertSame(assertLink(image, \"\/packages\/com.bar\/modbar\").resolveLink(), moduleBar);\n+        }\n+    }\n+\n+    @Test\n+    public void testPreviewResources_disabled() throws IOException {\n+        try (var image = getImage(DISABLED)) {\n+            \/\/ No preview classes visible.\n+            ImageClassLoader loader = loader(image);\n+            loader.assertNonPreviewVersion(\"modfoo\", \"com.foo.HasPreviewVersion\");\n+            loader.assertNonPreviewVersion(\"modfoo\", \"com.foo.NormalFoo\");\n+            loader.assertNonPreviewVersion(\"modfoo\", \"com.foo.bar.NormalBar\");\n+\n+            \/\/ NormalBar exists but IsPreviewOnly doesn't.\n+            assertResource(image, \"\/modules\/modfoo\/com\/foo\/bar\/NormalBar.class\");\n+            assertAbsent(image, \"\/modules\/modfoo\/com\/foo\/bar\/IsPreviewOnly.class\");\n+            assertDirContents(image, \"\/modules\/modfoo\/com\/foo\", \"HasPreviewVersion.class\", \"NormalFoo.class\", \"bar\");\n+            assertDirContents(image, \"\/modules\/modfoo\/com\/foo\/bar\", \"NormalBar.class\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPreviewResources_enabled() throws IOException {\n+        try (var image = getImage(ENABLED)) {\n+            \/\/ Preview version of classes either overwrite existing entries or are added to directories.\n+            ImageClassLoader loader = loader(image);\n+            loader.assertPreviewVersion(\"modfoo\", \"com.foo.HasPreviewVersion\");\n+            loader.assertNonPreviewVersion(\"modfoo\", \"com.foo.NormalFoo\");\n+            loader.assertNonPreviewVersion(\"modfoo\", \"com.foo.bar.NormalBar\");\n+            loader.assertPreviewVersion(\"modfoo\", \"com.foo.bar.IsPreviewOnly\");\n+\n+            \/\/ Both NormalBar and IsPreviewOnly exist (direct lookup and as child nodes).\n+            assertResource(image, \"\/modules\/modfoo\/com\/foo\/bar\/NormalBar.class\");\n+            assertResource(image, \"\/modules\/modfoo\/com\/foo\/bar\/IsPreviewOnly.class\");\n+            assertDirContents(image, \"\/modules\/modfoo\/com\/foo\", \"HasPreviewVersion.class\", \"NormalFoo.class\", \"bar\");\n+            assertDirContents(image, \"\/modules\/modfoo\/com\/foo\/bar\", \"NormalBar.class\", \"IsPreviewOnly.class\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPreviewOnlyPackages_disabled() throws IOException {\n+        try (var image = getImage(DISABLED)) {\n+            \/\/ No 'preview' package or anything inside it.\n+            assertDirContents(image, \"\/modules\/modbar\/com\/bar\", \"One.class\", \"Two.class\");\n+            assertAbsent(image, \"\/modules\/modbar\/com\/bar\/preview\");\n+            assertAbsent(image, \"\/modules\/modbar\/com\/bar\/preview\/stuff\/Foo.class\");\n+\n+            \/\/ And no package link.\n+            assertAbsent(image, \"\/packages\/com.bar.preview\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPreviewOnlyPackages_enabled() throws IOException {\n+        try (var image = getImage(ENABLED)) {\n+            \/\/ In preview mode 'preview' package exists with preview only content.\n+            assertDirContents(image, \"\/modules\/modbar\/com\/bar\", \"One.class\", \"Two.class\", \"preview\");\n+            assertDirContents(image, \"\/modules\/modbar\/com\/bar\/preview\/stuff\", \"Foo.class\", \"Bar.class\");\n+            assertResource(image, \"\/modules\/modbar\/com\/bar\/preview\/stuff\/Foo.class\");\n+\n+            \/\/ And package links exists.\n+            assertDirContents(image, \"\/packages\/com.bar.preview\", \"modbar\", \"modgus\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPreviewModeLinks_disabled() throws IOException {\n+        try (var image = getImage(DISABLED)) {\n+            assertDirContents(image, \"\/packages\/com.bar\", \"modbar\");\n+            \/\/ Missing symbolic link and directory when not in preview mode.\n+            assertAbsent(image, \"\/packages\/com.bar.preview\");\n+            assertAbsent(image, \"\/packages\/com.bar.preview.stuff\");\n+            assertAbsent(image, \"\/modules\/modbar\/com\/bar\/preview\");\n+            assertAbsent(image, \"\/modules\/modbar\/com\/bar\/preview\/stuff\");\n+        }\n+    }\n+\n+    @Test\n+    public void testPreviewModeLinks_enabled() throws IOException {\n+        try (var image = getImage(ENABLED)) {\n+            \/\/ In preview mode there is a new preview-only module visible.\n+            assertDirContents(image, \"\/packages\/com.bar\", \"modbar\", \"modgus\");\n+            \/\/ And additional packages are present.\n+            assertDirContents(image, \"\/packages\/com.bar.preview\", \"modbar\", \"modgus\");\n+            assertDirContents(image, \"\/packages\/com.bar.preview.stuff\", \"modbar\");\n+            assertDirContents(image, \"\/packages\/com.bar.preview.other\", \"modgus\");\n+            \/\/ And the preview-only content appears as we expect.\n+            assertDirContents(image, \"\/modules\/modbar\/com\/bar\", \"One.class\", \"Two.class\", \"preview\");\n+            assertDirContents(image, \"\/modules\/modbar\/com\/bar\/preview\", \"stuff\");\n+            assertDirContents(image, \"\/modules\/modbar\/com\/bar\/preview\/stuff\", \"Foo.class\", \"Bar.class\");\n+            \/\/ In both modules in which it was added.\n+            assertDirContents(image, \"\/modules\/modgus\/com\/bar\", \"preview\");\n+            assertDirContents(image, \"\/modules\/modgus\/com\/bar\/preview\", \"other\");\n+            assertDirContents(image, \"\/modules\/modgus\/com\/bar\/preview\/other\", \"Gus.class\");\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(value = PreviewMode.class, names = {\"DISABLED\", \"ENABLED\"})\n+    public void testPreviewEntriesAlwaysHidden(PreviewMode mode) throws IOException {\n+        try (var image = getImage(mode)) {\n+            \/\/ The META-INF directory exists, but does not contain the preview directory.\n+            ImageReader.Node dir = assertDir(image, \"\/modules\/modfoo\/META-INF\");\n+            assertEquals(0, dir.getChildNames().filter(n -> n.endsWith(\"\/preview\")).count());\n+            \/\/ Neither the preview directory, nor anything in it, can be looked-up directly.\n+            assertAbsent(image, \"\/modules\/modfoo\/META-INF\/preview\");\n+            assertAbsent(image, \"\/modules\/modfoo\/META-INF\/preview\/com\/foo\");\n+            \/\/ HasPreviewVersion.class is a preview class in the test data, and thus appears in\n+            \/\/ two places in the jimage). Ensure the preview version is always hidden.\n+            String previewPath = \"com\/foo\/HasPreviewVersion.class\";\n+            assertNode(image, \"\/modules\/modfoo\/\" + previewPath);\n+            assertAbsent(image, \"\/modules\/modfoo\/META-INF\/preview\/\" + previewPath);\n+        }\n+    }\n+\n+    \/\/ ======== Helper assertions with better error reporting ========\n+\n+    private static ImageReader.Node assertNode(SystemImage image, String name) throws IOException {\n+        ImageReader.Node node = image.findNode(name);\n+        assertNotNull(node, \"Could not find node: \" + name);\n+        return node;\n+    }\n+\n+    private static void assertResource(SystemImage image, String name) throws IOException {\n+        ImageReader.Node node = assertNode(image, name);\n+        assertTrue(node.isResource(), \"Node was not a resource: \" + name);\n+    }\n+\n+    private static ImageReader.Node assertDir(SystemImage image, String name) throws IOException {\n+        ImageReader.Node dir = assertNode(image, name);\n+        assertTrue(dir.isDirectory(), \"Node was not a directory: \" + name);\n+        return dir;\n+    }\n+\n+    private static void assertDirContents(SystemImage image, String name, String... expectedChildNames)\n+            throws IOException {\n+        ImageReader.Node dir = assertDir(image, name);\n+        Set<String> localChildNames = dir.getChildNames()\n+                .peek(s -> assertTrue(s.startsWith(name + \"\/\")))\n+                .map(s -> s.substring(name.length() + 1))\n+                .collect(toSet());\n+        assertEquals(\n+                Set.of(expectedChildNames),\n+                localChildNames,\n+                String.format(\"Unexpected child names in directory '%s'\", name));\n+    }\n+\n+    private static ImageReader.Node assertLink(SystemImage image, String name) throws IOException {\n+        ImageReader.Node link = assertNode(image, name);\n+        assertTrue(link.isLink(), \"Node should be a symbolic link: \" + link.getName());\n+        return link;\n+    }\n+\n+    private static void assertAbsent(SystemImage image, String name) throws IOException {\n+        assertNull(image.findNode(name), \"Should not be able to find node: \" + name);\n+    }\n+\n+    \/\/\/ Returns a custom class loader for loading instances from a given image\n+    \/\/\/ and making assertions about the class implementation.\n+    private static ImageClassLoader loader(SystemImage image) {\n+        return new ImageClassLoader(image, IMAGE_ENTRIES.keySet());\n+    }\n+\n+    \/\/ ======== Test data creation ========\n+\n+    \/\/\/ Builds a jimage file with the specified class entries. The classes in\n+    \/\/\/ the built image can be loaded and executed to return their names via\n+    \/\/\/ `toString()` to confirm the correct bytes were returned.\n+    private static Path buildJimage(Helper helper, Set<String> moduleNames) {\n+        Path outDir = helper.createNewImageDir(\"test\");\n+        \/\/ The default module path contains the directory we compiled the jars into.\n+        JImageGenerator.JLinkTask jlink = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(outDir);\n+        moduleNames.forEach(jlink::addMods);\n+        return jlink.call().assertSuccess().resolve(\"lib\", \"modules\");\n+    }\n+\n+    \/\/\/ Compiles a set of synthetic modules, as separate Jar files, in the given\n+    \/\/\/ directory.\n+    private static Path compileModules(Path jarDir, Map<String, List<String>> entries) {\n+        entries.forEach((module, classes) -> compileModuleJar(module, classes, jarDir));\n+        return jarDir;\n+    }\n+\n+    \/\/\/ Compiles a synthetic module containing test classes into a single Jar\n+    \/\/\/ file named {@code <module>.jar} in the given directory. Test classes can\n+    \/\/\/ be instantiated and have their {@code toString()} method called to\n+    \/\/\/ return a status string for testing.\n+    \/\/\/\n+    \/\/\/ If a fully qualified class name is prefixed with {@code @} then it is\n+    \/\/\/ compiled as a preview version of the class, with different\n+    \/\/\/ {@code toString()} representation.\n+    private static void compileModuleJar(String module, List<String> classNames, Path jarDir) {\n+        JarBuilder jar = new JarBuilder(jarDir.resolve(module + \".jar\").toString());\n+        String moduleInfo = \"module \" + module + \" {}\";\n+        jar.addEntry(\"module-info.class\", InMemoryJavaCompiler.compile(\"module-info\", moduleInfo));\n+\n+        classNames.forEach(fqn -> {\n+            boolean isPreviewEntry = fqn.startsWith(\"@\");\n+            if (isPreviewEntry) {\n+                fqn = fqn.substring(1);\n+            }\n+            int lastDot = fqn.lastIndexOf('.');\n+            String pkg = fqn.substring(0, lastDot);\n+            String cls = fqn.substring(lastDot + 1);\n+            String source = String.format(\n+                    \"\"\"\n+                    package %s;\n+                    public class %s {\n+                        public String toString() {\n+                            return \"%s: %s\";\n+                        }\n+                    }\n+                    \"\"\", pkg, cls, isPreviewEntry ? \"Preview\" : \"Class\", fqn);\n+            String path = (isPreviewEntry ? \"META-INF\/preview\/\" : \"\") + fqn.replace('.', '\/') + \".class\";\n+            jar.addEntry(path, InMemoryJavaCompiler.compile(fqn, source));\n+        });\n+        try {\n+            jar.build();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/\/ Unpacks Jar files in a given directory to construct an \"exploded\" view\n+    \/\/\/ of the jimage content. Modules are unpacked into a directory named after\n+    \/\/\/ the Jar file's base name, and synthetic \"marker\" files, designed to\n+    \/\/\/ mimic build artifacts which should be ignored, are added.\n+    private static void explodeTestModules(Path jarDir, Path modulesRoot) throws IOException {\n+        try (var jars = Files.list(jarDir).filter(SystemImageTest::isJarFile)) {\n+            jars.forEach(jar -> explodeModuleJar(jar, modulesRoot));\n+        }\n+    }\n+\n+    private static boolean isJarFile(Path p) {\n+        return p.getFileName().toString().endsWith(\".jar\");\n+    }\n+\n+    \/\/\/ Unpacks the content of a single Jar file into a modules directory, and\n+    \/\/\/ adds synthetic marker files to mimic build artifacts (which should be\n+    \/\/\/ ignored).\n+    private static void explodeModuleJar(Path jar, Path modulesRoot) {\n+        String modName = jar.getFileName().toString();\n+        if (!modName.endsWith(\".jar\")) {\n+            throw new IllegalArgumentException(\"Bad jar file: \" + jar);\n+        }\n+        modName = modName.substring(0, modName.length() - 4);\n+        Path modDir = modulesRoot.resolve(modName);\n+        try (FileSystem zipfs = FileSystems.newFileSystem(jar, Map.of(\"accessMode\", \"readOnly\"))) {\n+            Path rootDir = zipfs.getRootDirectories().iterator().next();\n+            Set<Path> dstDirs = new HashSet<>();\n+            try (var files = Files.walk(rootDir)) {\n+                files.filter(Files::isRegularFile).forEach(path -> {\n+                    try {\n+                        \/\/ Construct equivalent destination path in modules dir.\n+                        Path dst = StreamSupport.stream(path.spliterator(), false)\n+                                .reduce(modDir, (d, p) -> d.resolve(p.toString()));\n+                        if (dstDirs.add(dst.getParent())) {\n+                            Files.createDirectories(dst.getParent());\n+                        }\n+                        Files.copy(path, dst);\n+                    } catch (IOException ex) {\n+                        throw new UncheckedIOException(ex);\n+                    }\n+                });\n+            }\n+            \/\/ Add a marker file in each directory and the module root.\n+            dstDirs.forEach(SystemImageTest::writeIgnoredBuildMarker);\n+            writeIgnoredBuildMarker(modDir);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    \/\/\/ Writes a \"marker\" file in a given directory to mimic build artifacts\n+    \/\/\/ which must be ignored when using \"exploded\" images.\n+    private static void writeIgnoredBuildMarker(Path dir) {\n+        try {\n+            Files.writeString(dir.resolve(\"_the.ignored.marker\"), \"Ignored\", UTF_8);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    \/\/\/ Returns the helper for building JAR and jimage files.\n+    private static Helper getHelper() {\n+        Helper helper;\n+        try {\n+            boolean isLinkableRuntime = LinkableRuntimeImage.isLinkableRuntime();\n+            helper = Helper.newHelper(isLinkableRuntime);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        Assumptions.assumeTrue(helper != null, \"Cannot create test helper, skipping test!\");\n+        return helper;\n+    }\n+\n+    \/\/\/ Provides assertions for classes loaded from a specified `SystemImage`.\n+    private static class ImageClassLoader extends ClassLoader {\n+        private final SystemImage image;\n+        private final Set<String> testModules;\n+\n+        private ImageClassLoader(SystemImage image, Set<String> testModules) {\n+            this.image = image;\n+            this.testModules = testModules;\n+        }\n+\n+        \/\/\/ Asserts that a synthetic test class, loaded from a given module, is\n+        \/\/\/ the *non-preview* version.\n+        \/\/\/\n+        \/\/\/ @param module module name\n+        \/\/\/ @param fqn fully qualified class name\n+        public void assertNonPreviewVersion(String module, String fqn) throws IOException {\n+            assertEquals(\"Class: \" + fqn, loadAndGetToString(module, fqn));\n+        }\n+\n+        \/\/\/ Asserts that a synthetic test class, loaded from a given module, is\n+        \/\/\/ the *preview* version.\n+        \/\/\/\n+        \/\/\/ @param module module name\n+        \/\/\/ @param fqn fully qualified class name\n+        public void assertPreviewVersion(String module, String fqn) throws IOException {\n+            assertEquals(\"Preview: \" + fqn, loadAndGetToString(module, fqn));\n+        }\n+\n+        private String loadAndGetToString(String module, String fqn) {\n+            return loadAndCall(module, fqn, c -> c.getDeclaredConstructor().newInstance().toString());\n+        }\n+\n+        @FunctionalInterface\n+        public interface ClassAction<R, T extends Exception> {\n+            R call(Class<?> cls) throws T;\n+        }\n+\n+        private <R> R loadAndCall(String module, String fqn, ClassAction<R, ?> action) {\n+            Class<?> cls = findClass(module, fqn);\n+            assertNotNull(cls, \"Could not load class: \" + module + \"\/\" + fqn);\n+            try {\n+                return action.call(cls);\n+            } catch (Exception e) {\n+                fail(\"Class loading failed\", e);\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String module, String fqn) {\n+            assumeTrue(testModules.contains(module), \"Can only load classes in modules: \" + testModules);\n+            String name = \"\/modules\/\" + module + \"\/\" + fqn.replace('.', '\/') + \".class\";\n+            Class<?> cls = findLoadedClass(fqn);\n+            if (cls == null) {\n+                try {\n+                    ImageReader.Node node = image.findNode(name);\n+                    if (node != null && node.isResource()) {\n+                        byte[] classBytes = image.getResource(node);\n+                        cls = defineClass(fqn, classBytes, 0, classBytes.length);\n+                        resolveClass(cls);\n+                        return cls;\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/SystemImageTest.java","additions":576,"deletions":0,"binary":false,"changes":576,"status":"added"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Whitebox tests for ExplodedImage to ensure compatibility with ImageReader.\n- * @modules java.base\/jdk.internal.jrtfs java.base\/jdk.internal.jimage\n- * @run junit\/othervm java.base\/jdk.internal.jrtfs.ExplodedImageTest\n- *\/\n-public class ExplodedImageTestDriver {}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/ExplodedImageTestDriver.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-modules = \\\n-    java.base\/jdk.internal.jimage \\\n-    java.base\/jdk.internal.jrtfs\n-bootclasspath.dirs=.\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/TEST.properties","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,232 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.jrtfs;\n-\n-import jdk.internal.jimage.ImageReader;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.TestInstance;\n-import org.junit.jupiter.api.io.TempDir;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.ValueSource;\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.DirectoryStream;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.StreamSupport;\n-\n-import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-\/**\n- * Tests an {@link ExplodedImage} view of a class-file hierarchy.\n- *\n- * <p>For simplicity and performance, only a subset of the JRT files are copied\n- * to disk for testing.\n- *\/\n-@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n-public class ExplodedImageTest {\n-\n-    private Path modulesRoot;\n-    private SystemImage explodedImage;\n-    private String pathSeparator;\n-\n-    @BeforeAll\n-    public void createTestDirectory(@TempDir Path modulesRoot) throws IOException {\n-        this.modulesRoot = modulesRoot;\n-        this.pathSeparator = modulesRoot.getFileSystem().getSeparator();\n-        \/\/ Copy only a useful subset of files for testing. Use at least two\n-        \/\/ modules with \"overlapping\" packages to test \/package links better.\n-        unpackModulesDirectoriesFromJrtFileSystem(modulesRoot,\n-                \"java.base\/java\/util\",\n-                \"java.base\/java\/util\/zip\",\n-                \"java.logging\/java\/util\/logging\");\n-        this.explodedImage = new ExplodedImage(modulesRoot);\n-    }\n-\n-    \/** Unpacks a list of \"\/modules\/...\" directories non-recursively into the specified root directory. *\/\n-    private static void unpackModulesDirectoriesFromJrtFileSystem(Path modulesRoot, String... dirNames)\n-            throws IOException {\n-        FileSystem jrtfs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n-        List<Path> srcDirs = Arrays.stream(dirNames).map(s -> \"\/modules\/\" + s).map(jrtfs::getPath).toList();\n-        for (Path srcDir : srcDirs) {\n-            \/\/ Skip-1 to remove \"modules\" segment (not part of the file system path).\n-            Path dstDir = StreamSupport.stream(srcDir.spliterator(), false)\n-                    .skip(1)\n-                    .reduce(modulesRoot, (path, segment) -> path.resolve(segment.toString()));\n-            Files.createDirectories(dstDir);\n-            try (DirectoryStream<Path> files = Files.newDirectoryStream(srcDir)) {\n-                for (Path srcFile : files) {\n-                    Files.copy(srcFile, dstDir.resolve(srcFile.getFileName().toString()));\n-                }\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void topLevelNodes() throws IOException {\n-        ImageReader.Node root = explodedImage.findNode(\"\/\");\n-        ImageReader.Node modules = explodedImage.findNode(\"\/modules\");\n-        ImageReader.Node packages = explodedImage.findNode(\"\/packages\");\n-        assertEquals(\n-                Set.of(modules.getName(), packages.getName()),\n-                root.getChildNames().collect(Collectors.toSet()));\n-    }\n-\n-    @ParameterizedTest\n-    @ValueSource(strings = {\n-            \"\/modules\/java.base\/java\/util\/List.class\",\n-            \"\/modules\/java.base\/java\/util\/zip\/ZipEntry.class\",\n-            \"\/modules\/java.logging\/java\/util\/logging\/Logger.class\"})\n-    public void basicLookupResource(String expectedResourceName) throws IOException {\n-        ImageReader.Node node = assertResourceNode(expectedResourceName);\n-\n-        Path fsRelPath = getRelativePath(expectedResourceName);\n-        assertArrayEquals(\n-                Files.readAllBytes(modulesRoot.resolve(fsRelPath)),\n-                explodedImage.getResource(node));\n-    }\n-\n-    @ParameterizedTest\n-    @ValueSource(strings = {\n-            \"\/modules\/java.base\",\n-            \"\/modules\/java.logging\",\n-            \"\/modules\/java.base\/java\",\n-            \"\/modules\/java.base\/java\/util\",\n-            \"\/modules\/java.logging\/java\/util\",\n-    })\n-    public void basicLookupDirectory(String expectedDirectoryName) throws IOException {\n-        ImageReader.Node node = assertDirectoryNode(expectedDirectoryName);\n-\n-        Path fsRelPath = getRelativePath(expectedDirectoryName);\n-        List<String> fsChildBaseNames;\n-        try (DirectoryStream<Path> paths = Files.newDirectoryStream(modulesRoot.resolve(fsRelPath))) {\n-            fsChildBaseNames = StreamSupport.stream(paths.spliterator(), false)\n-                    .map(Path::getFileName)\n-                    .map(Path::toString)\n-                    .toList();\n-        }\n-        List<String> nodeChildBaseNames = node.getChildNames()\n-                .map(s -> s.substring(node.getName().length() + 1))\n-                .toList();\n-        assertEquals(fsChildBaseNames, nodeChildBaseNames, \"expected same child names\");\n-    }\n-\n-    @ParameterizedTest\n-    @ValueSource(strings = {\n-            \"\/packages\/java\/java.base\",\n-            \"\/packages\/java\/java.logging\",\n-            \"\/packages\/java.util\/java.base\",\n-            \"\/packages\/java.util\/java.logging\",\n-            \"\/packages\/java.util.zip\/java.base\"})\n-    public void basicLookupPackageLinks(String expectedLinkName) throws IOException {\n-        ImageReader.Node node = assertLinkNode(expectedLinkName);\n-        ImageReader.Node resolved = node.resolveLink();\n-        assertSame(explodedImage.findNode(resolved.getName()), resolved);\n-        String moduleName = expectedLinkName.substring(expectedLinkName.lastIndexOf('\/') + 1);\n-        assertEquals(\"\/modules\/\" + moduleName, resolved.getName());\n-    }\n-\n-    @ParameterizedTest\n-    @ValueSource(strings = {\n-            \"\/packages\/java\",\n-            \"\/packages\/java.util\",\n-            \"\/packages\/java.util.zip\"})\n-    public void packageDirectories(String expectedDirectoryName) throws IOException {\n-        ImageReader.Node node = assertDirectoryNode(expectedDirectoryName);\n-        assertTrue(node.getChildNames().findFirst().isPresent(),\n-                \"Package directories should not be empty: \" + node);\n-    }\n-\n-    @ParameterizedTest\n-    @ValueSource(strings = {\n-            \"\",\n-            \".\",\n-            \"\/.\",\n-            \"modules\",\n-            \"packages\",\n-            \"\/modules\/\",\n-            \"\/modules\/xxxx\",\n-            \"\/modules\/java.base\/java\/lang\/Xxxx.class\",\n-            \"\/packages\/\",\n-            \"\/packages\/xxxx\",\n-            \"\/packages\/java.xxxx\",\n-            \"\/packages\/java.util.\",\n-            \/\/ Mismatched module.\n-            \"\/packages\/java.util.logging\/java.base\",\n-            \"\/packages\/java.util.zip\/java.logging\",\n-            \/\/ Links are not resolved as they are fetched (old\/broken behaviour).\n-            \"\/packages\/java.util\/java.base\/java\/util\/Vector.class\",\n-    })\n-    public void invalidNames(String invalidName) throws IOException {\n-        assertNull(explodedImage.findNode(invalidName), \"No node expected for: \" + invalidName);\n-    }\n-\n-    private ImageReader.Node assertResourceNode(String name) throws IOException {\n-        ImageReader.Node node = explodedImage.findNode(name);\n-        assertNotNull(node);\n-        assertEquals(name, node.getName(), \"expected node name: \" + name);\n-        assertTrue(node.isResource(), \"expected a resource: \" + node);\n-        assertFalse(node.isDirectory(), \"resources are not directories: \" + node);\n-        assertFalse(node.isLink(), \"resources are not links: \" + node);\n-        return node;\n-    }\n-\n-    private ImageReader.Node assertDirectoryNode(String name) throws IOException {\n-        ImageReader.Node node = explodedImage.findNode(name);\n-        assertNotNull(node);\n-        assertEquals(name, node.getName(), \"expected node name: \" + name);\n-        assertTrue(node.isDirectory(), \"expected a directory: \" + node);\n-        assertFalse(node.isResource(), \"directories are not resources: \" + node);\n-        assertFalse(node.isLink(), \"directories are not links: \" + node);\n-        return node;\n-    }\n-\n-    private ImageReader.Node assertLinkNode(String name) throws IOException {\n-        ImageReader.Node node = explodedImage.findNode(name);\n-        assertNotNull(node);\n-        assertEquals(name, node.getName(), \"expected node name: \" + name);\n-        assertTrue(node.isLink(), \"expected a link: \" + node);\n-        assertFalse(node.isResource(), \"links are not resources: \" + node);\n-        assertFalse(node.isDirectory(), \"links are not directories: \" + node);\n-        return node;\n-    }\n-\n-    private Path getRelativePath(String name) {\n-        return Path.of(name.substring(\"\/modules\/\".length()).replace(\"\/\", pathSeparator));\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/java.base\/jdk\/internal\/jrtfs\/ExplodedImageTest.java","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"}]}