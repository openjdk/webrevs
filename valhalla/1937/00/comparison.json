{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2028,0 +2028,425 @@\n+\n+    \/**\n+     * Exact arithmetic over 32-bit two's complement\n+     * integers. Operations that would overflow instead throw {@link\n+     * ArithmeticException}.\n+     *\n+     * @since Valhalla\n+     *\/\n+    @jdk.internal.ValueBased\n+    public final static class \/*value record*\/ ExactInt  {\n+        \/\/ NOTE: set of superinterfaces may be expanded in the future.\n+\n+        \/**\n+         * The bits of the exact value.\n+         *\/\n+        private int value;\n+\n+        \/**\n+         * Constructs a new exact int.\n+         *\/\n+        private ExactInt(int value) {\n+            this.value = value;\n+        }\n+\n+        \/**\n+         * {@return an exact integer with the value of the argument}\n+         *\n+         * @param x the argument\n+         *\/\n+        public static ExactInt valueOf(int x) {\n+            return new ExactInt(x);\n+        }\n+\n+        \/**\n+         * {@return the result of parsing the string as an integer}\n+         * Base 10 is used as the implicit radix.\n+         *\n+         * @implSpec\n+         * The same grammar of strings is recognized by this method as by\n+         * {@link Integer#parseInt(String)}.\n+         *\n+         * @param s the argument\n+         * @throws    NumberFormatException  if the string does not contain a\n+         *            parsable integer.\n+         * @see Integer#parseInt(String)\n+         *\/\n+        public static ExactInt valueOf(String s) throws NumberFormatException {\n+            return new ExactInt(Integer.parseInt(s));\n+        }\n+\n+        \/**\n+         * {@return the result of parsing the string as an integer in the\n+         * specified radix}\n+         *\n+         * @implSpec\n+         * The same grammar of strings is recognized by this method as by\n+         * {@link Integer#parseInt(String, int)}.\n+         *\n+         * @param      s   the string to be parsed.\n+         * @param      radix the radix to be used in interpreting {@code s}\n+         * @throws    NumberFormatException if the {@code String}\n+         *            does not contain a parsable exact integer.\n+         * @see Integer#parseInt(String, int)\n+         *\/\n+        public static ExactInt valueOf(String s, int radix) throws NumberFormatException {\n+            return new ExactInt(Integer.parseInt(s, radix));\n+        }\n+\n+        \/**\n+         * {@return a string representing the value}\n+         *\/\n+        @Override\n+            public String toString() {\n+            return toString(this);\n+        }\n+\n+        \/**\n+         * {@return a string representing the argument}\n+         *\n+         * @implSpec\n+         * The method behaves as if the argument were passed to {@link\n+         * Integer#toString(int)}.\n+         *\n+         * @param x the integer to be represented\n+         * @see Integer#toString(int)\n+         *\/\n+        public static String toString(ExactInt x) {\n+            return Integer.toString(x.value);\n+        }\n+\n+        \/**\n+         * {@return a string representing the argument in the\n+         * specified radix}\n+         *\n+         * @implSpec\n+         * The method behaves as if the arguments were passed to {@link\n+         * Integer#toString(int, int)}.\n+         *\n+         * @param x the integer to be represented\n+         * @param radix the radix to use in the string representation\n+         * @see Integer#toString(int, int)\n+         *\/\n+        public static String toString(ExactInt x, int radix) {\n+            return Integer.toString(x.value, radix);\n+        }\n+\n+        \/**\n+         * {@return the bits of this exact integer as an {@code int}}\n+         *\/\n+        public int intValue() {\n+            return this.value;\n+        }\n+\n+        \/\/ Arithmetic operators\n+\n+        \/\/ Note: could add implSpec tags to the add, subtract,\n+        \/\/ multiply, and divide methods.\n+\n+        \/**\n+         * Addition operation, binary \"{@code +}\".\n+         *\n+         * @param addend the first operand\n+         * @param augend the second operand\n+         * @return the sum of the operands\n+         * @throws ArithmeticException if the result overflows an {@code int}\n+         * @see Math#addExact(int, int)\n+         *\/\n+        public static ExactInt add(ExactInt addend, ExactInt augend) {\n+            return valueOf(Math.addExact(addend.value, augend.value));\n+        }\n+\n+        \/**\n+         * Subtraction operation, binary \"{@code -}\".\n+         *\n+         * @param minuend the first operand\n+         * @param subtrahend the second operand\n+         * @return the difference of the operands\n+         * @throws ArithmeticException if the result overflows an {@code int}\n+         * @see Math#subtractExact(int, int)\n+         *\/\n+        public static ExactInt subtract(ExactInt minuend, ExactInt subtrahend) {\n+            return valueOf(Math.subtractExact(minuend.value, subtrahend.value));\n+        }\n+\n+        \/**\n+         * Multiplication operation, \"{@code *}\".\n+         *\n+         * @param multiplier the first operand\n+         * @param multiplicand the second operand\n+         * @return the product of the operands\n+         * @throws ArithmeticException if the result overflows an {@code int}\n+         * @see Math#multiplyExact(int, int)\n+         *\/\n+        public static ExactInt multiply(ExactInt multiplier,\n+                                        ExactInt multiplicand) {\n+            return valueOf(Math.multiplyExact(multiplier.value, multiplicand.value));\n+        }\n+\n+        \/**\n+         * Division operation, \"{@code \/}\".\n+         *\n+         * @param dividend the value to be divided\n+         * @param divisor the value being divided by\n+         * @return the quotient of the first argument divided by\n+         * the second argument\n+         * @throws ArithmeticException if the divisor is zero or the\n+         * quotient overflows an int\n+         * @see Math#divideExact(int, int)\n+         *\/\n+        public static ExactInt divide(ExactInt dividend,\n+                                      ExactInt divisor) {\n+            return valueOf(Math.divideExact(dividend.value, divisor.value));\n+        }\n+\n+        \/**\n+         * Remainder operation, \"{@code %}\".\n+         *\n+         * @param dividend the value to be divided to compute the remainder\n+         * @param divisor the value being divided by\n+         * @return the exact remainder of the first argument divided by\n+         * the second argument\n+         * @throws ArithmeticException if the divisor is zero or the\n+         * quotient overflows an int\n+         *\/\n+        public static ExactInt remainder(ExactInt dividend,\n+                                         ExactInt divisor) {\n+            \/\/ TOOD: refactor\/improve\n+            ExactInt quotient = divide(dividend, divisor);\n+            \/\/ Trigger ArithmeticException for overflow\n+            return valueOf(dividend.value % divisor.value);\n+        }\n+\n+        \/\/ TODO: API decision, is this method needed?\n+\n+        \/**\n+         * Unary plus operation, \"{@code +}\".\n+         *\n+         * @param operand the operand\n+         * @return unary plus of the operand\n+         *\/\n+        public static ExactInt plus(ExactInt operand) {\n+            return operand;\n+        }\n+\n+        \/**\n+         * Negation operation, unary \"{@code -}\".\n+\n+         * @param operand the operand\n+         * @return the negation of the operand\n+         * @throws ArithmeticException if the result overflows an {@code int}\n+         * @see Math#negateExact(int)\n+         *\/\n+        public static ExactInt negate(ExactInt operand) {\n+            return valueOf(Math.negateExact(operand.value));\n+        }\n+\n+        \/**\n+         * Compares two exact int values numerically.\n+         *\n+         * @param x the first argument\n+         * @param y the second argument\n+         * @return the value {@code 0} if {@code x == y};\n+         *         a value less than {@code 0} if {@code x < y}; and\n+         *         a value greater than {@code 0} if {@code x > y}\n+         * @see Integer#compare(int, int)\n+         *\/\n+        public static int compare(ExactInt x, ExactInt y) {\n+            return Integer.compare(x.value, y.value);\n+        }\n+\n+        \/\/ Integral-specific operations\n+        \/\/ and, or, xor, complement, leftShift, rightShift, rightShift exact...\n+\n+        \/\/ OrderedComparison\n+        \/\/ min, max, lessThan, lessThanEqual, greaterThan, greaterThanEqual,\n+\n+        \/\/ Ordered comparison operators\n+\n+        \/**\n+         * {@return {@code true} if the first argument is less than the\n+         * second argument and {@code false} otherwise}\n+         *\n+         * The method corresponds to the less than operator, \"{@code <}\".\n+         *\n+         * @param x the first argument\n+         * @param y the second argument\n+         *\/\n+        public static boolean lessThan(ExactInt x, ExactInt y) {\n+            return x.value < y.value;\n+        }\n+\n+        \/**\n+         * {@return {@code true} if the first argument is less than or\n+         * equal to the second argument and {@code false} otherwise}\n+         *\n+         * The method corresponds to the less than or equal to operator,\n+         * \"{@code <=}\".\n+         *\n+         * @param x the first argument\n+         * @param y the second argument\n+         *\/\n+        public static boolean lessThanEqual(ExactInt x, ExactInt y) {\n+            return x.value <= y.value;\n+        }\n+\n+        \/**\n+         * {@return {@code true} if the first argument is greater than the\n+         * second argument and {@code false} otherwise}\n+         *\n+         * The method corresponds to the less than operator, \"{@code >}\".\n+         *\n+         * @param x the first argument\n+         * @param y the second argument\n+         *\/\n+        public static boolean greaterThan(ExactInt x, ExactInt y) {\n+            return x.value > y.value;\n+        }\n+\n+        \/**\n+         * {@return {@code true} if the first argument is greater than or\n+         * equal to the second argument and {@code false} otherwise}\n+         *\n+         * The method corresponds to the greater than or equal to operator,\n+         * \"{@code >=}\".\n+         *\n+         * @param x the first argument\n+         * @param y the second argument\n+         *\/\n+        public static boolean greaterThanEqual(ExactInt x, ExactInt y) {\n+            return x.value >= y.value;\n+        }\n+\n+        \/\/ Bit-wise operators\n+\n+        \/**\n+         * {@return the bit-wise AND of the arguments}\n+         *\n+         * The method corresponds to the AND operator, \"{@code &}\".\n+         *\n+         * @param x the first argument\n+         * @param y the second argument\n+         *\/\n+        public static ExactInt and(ExactInt x, ExactInt y) {\n+            return valueOf(x.value & y.value);\n+        }\n+\n+        \/**\n+         * {@return the bit-wise OR of the arguments}\n+         *\n+         * The method corresponds to the OR operator, \"{@code |}\".\n+         *\n+         * @param x the first argument\n+         * @param y the second argument\n+         *\/\n+        public static ExactInt or(ExactInt x, ExactInt y) {\n+            return valueOf(x.value | y.value);\n+        }\n+\n+        \/**\n+         * {@return the bit-wise XOR of the arguments}\n+         *\n+         * The method corresponds to the XOR operator, \"{@code ^}\".\n+         *\n+         * @param x the first argument\n+         * @param y the second argument\n+         *\/\n+        public static ExactInt xor(ExactInt x, ExactInt y) {\n+            return valueOf(x.value ^ y.value);\n+        }\n+\n+        \/**\n+         * {@return the bit-wise complement of the argument}\n+         *\n+         * The method corresponds to the complement operator, \"{@code ~}\".\n+         *\n+         * @param x the argument\n+         *\/\n+        public static ExactInt complement(ExactInt x) {\n+            return valueOf(~x.value);\n+        }\n+\n+        \/\/ Shift Operators\n+\n+        \/\/ Per the JLS, the shiftDistance is AND-ed with a 5 or 6 bit mask\n+        \/\/ (for int and long value being shifted, respectively) so the\n+        \/\/ distance always non-negative.\n+\n+        \/**\n+         * {@return the first operand left shifted by the distance\n+         * indicated by the second operand, operator \"{@code <<\"}}\n+         *\n+         * Only the value of the five low-order bits of the shift distance\n+         * argument are taken into account in determining the shift\n+         * distance.\n+         *\n+         * The method corresponds to the shift left operator, \"{@code <<}\".\n+         *\n+         * @param x the value to be shifted\n+         * @param shiftDistance number of bits to shift\n+         * @throws ArithmeticException if the result is not exact\n+         * @jls 15.19 Shift Operators\n+         *\/\n+        public static ExactInt shiftLeft(ExactInt x, int shiftDistance) {\n+            int xValue = x.value;\n+            int xShift = xValue << shiftDistance;\n+            sameBitCount(xValue, xShift);\n+            return valueOf(xShift);\n+        }\n+\n+        private static void sameBitCount(int x, int y) {\n+            if (bitCount(x) != bitCount(y)) {\n+                throw new ArithmeticException(\"inexact shift\");\n+            }\n+        }\n+\n+        \/**\n+         * {@return the first operand right shifted by the distance\n+         * indicated by the second operand}\n+         *\n+         * This method corresponds to the shift right operator, \"{@code >>}\".\n+         *\n+         * Note: since this the is exact, semantically a (signed) right\n+         * shift is equivalent to an <em>exact<\/em> right shift.\n+         *\n+         * <p>Only the value of the five low-order bits of the shift distance\n+         * argument are taken into account in determining the shift\n+         * distance.\n+         *\n+         * @param x the value to be shifted\n+         * @param shiftDistance number of bits to shift\n+         * @throws ArithmeticException if the result is not exact\n+         * @jls 15.19 Shift Operators\n+         *\/\n+        public static ExactInt shiftRight(ExactInt x, int shiftDistance) {\n+            int xValue = x.value;\n+            int xShift = xValue >> shiftDistance;\n+            \/\/ TOOD: Might need a more nuanced check here for negative\n+            \/\/ x values, such as the shift distance must be less than\n+            \/\/ the number of trailing zeros in the initial x value.\n+            sameBitCount(xValue, xShift);\n+            return valueOf(xShift);\n+        }\n+\n+        \/**\n+         * {@return the first operand right shifted by the distance\n+         * indicated by the second operand}\n+         *\n+         * This method corresponds to the shift right exact operator, \"{@code >>>}\".\n+         *\n+         * <p>Only the value of the five low-order bits of the shift distance\n+         * argument are taken into account in determining the shift\n+         * distance.\n+         *\n+         * @param x the value to be shifted\n+         * @param shiftDistance  number of bits to shift\n+         * @throws ArithmeticException if the result is not exact\n+         * @jls 15.19 Shift Operators\n+         *\/\n+        public static ExactInt shiftRightUnsigned(ExactInt x, int shiftDistance) {\n+            int xValue = x.value;\n+            int xShift = xValue >>> shiftDistance;\n+            sameBitCount(xValue, xShift);\n+            return valueOf(xShift);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":426,"deletions":1,"binary":false,"changes":427,"status":"modified"}]}