{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=valhalla\n@@ -7,6 +7,2 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists,copyright\n-warning=issuestitle,binary\n-\n-[repository]\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n-branches=.*\n+error=author,committer,executable,symlink,whitespace\n+warning=issuestitle\n@@ -22,7 +18,0 @@\n-[checks \"merge\"]\n-message=Merge\n-\n-[checks \"reviewers\"]\n-reviewers=1\n-ignore=duke\n-\n@@ -32,3 +21,0 @@\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n","filename":".jcheck\/conf","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=ea\n+DEFAULT_PROMOTED_VERSION_PRE=lworldea2\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -123,0 +125,1 @@\n+uint Runtime1::_new_null_free_array_slowcase_cnt = 0;\n@@ -125,0 +128,5 @@\n+uint Runtime1::_load_flat_array_slowcase_cnt = 0;\n+uint Runtime1::_store_flat_array_slowcase_cnt = 0;\n+uint Runtime1::_substitutability_check_slowcase_cnt = 0;\n+uint Runtime1::_buffer_inline_args_slowcase_cnt = 0;\n+uint Runtime1::_buffer_inline_args_no_receiver_slowcase_cnt = 0;\n@@ -134,0 +142,2 @@\n+uint Runtime1::_throw_illegal_monitor_state_exception_count = 0;\n+uint Runtime1::_throw_identity_exception_count = 0;\n@@ -376,2 +386,1 @@\n-\n-JRT_ENTRY(void, Runtime1::new_instance(JavaThread* current, Klass* klass))\n+static void allocate_instance(JavaThread* current, Klass* klass, TRAPS) {\n@@ -380,1 +389,1 @@\n-    _new_instance_slowcase_cnt++;\n+    Runtime1::_new_instance_slowcase_cnt++;\n@@ -394,0 +403,3 @@\n+JRT_ENTRY(void, Runtime1::new_instance(JavaThread* current, Klass* klass))\n+  allocate_instance(current, klass, CHECK);\n+JRT_END\n@@ -439,0 +451,24 @@\n+JRT_ENTRY(void, Runtime1::new_null_free_array(JavaThread* current, Klass* array_klass, jint length))\n+  NOT_PRODUCT(_new_null_free_array_slowcase_cnt++;)\n+  \/\/ TODO 8350865 This is dead code since 8325660 because null-free arrays can only be created via the factory methods that are not yet implemented in C1. Should probably be fixed by 8265122.\n+\n+  \/\/ Note: no handle for klass needed since they are not used\n+  \/\/       anymore after new_objArray() and no GC can happen before.\n+  \/\/       (This may have to change if this code changes!)\n+  assert(array_klass->is_klass(), \"not a class\");\n+  Handle holder(THREAD, array_klass->klass_holder()); \/\/ keep the klass alive\n+  Klass* elem_klass = ObjArrayKlass::cast(array_klass)->element_klass();\n+  assert(elem_klass->is_inline_klass(), \"must be\");\n+  InlineKlass* vk = InlineKlass::cast(elem_klass);\n+  \/\/ Logically creates elements, ensure klass init\n+  elem_klass->initialize(CHECK);\n+  arrayOop obj= oopFactory::new_objArray(elem_klass, length, ArrayKlass::ArrayProperties::NULL_RESTRICTED, CHECK);\n+  current->set_vm_result_oop(obj);\n+  \/\/ This is pretty rare but this runtime patch is stressful to deoptimization\n+  \/\/ if we deoptimize here so force a deopt to stress the path.\n+  if (DeoptimizeALot) {\n+    deopt_caller(current);\n+  }\n+JRT_END\n+\n+\n@@ -453,0 +489,96 @@\n+static void profile_flat_array(JavaThread* current, bool load, bool null_free) {\n+  ResourceMark rm(current);\n+  vframeStream vfst(current, true);\n+  assert(!vfst.at_end(), \"Java frame must exist\");\n+  \/\/ Check if array access profiling is enabled\n+  if (vfst.nm()->comp_level() != CompLevel_full_profile || !C1UpdateMethodData) {\n+    return;\n+  }\n+  int bci = vfst.bci();\n+  Method* method = vfst.method();\n+  MethodData* md = method->method_data();\n+  if (md != nullptr) {\n+    \/\/ Lock to access ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(md->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n+    ProfileData* data = md->bci_to_data(bci);\n+    assert(data != nullptr, \"incorrect profiling entry\");\n+    if (data->is_ArrayLoadData()) {\n+      assert(load, \"should be an array load\");\n+      ArrayLoadData* load_data = (ArrayLoadData*) data;\n+      load_data->set_flat_array();\n+      if (null_free) {\n+        load_data->set_null_free_array();\n+      }\n+    } else {\n+      assert(data->is_ArrayStoreData(), \"\");\n+      assert(!load, \"should be an array store\");\n+      ArrayStoreData* store_data = (ArrayStoreData*) data;\n+      store_data->set_flat_array();\n+      if (null_free) {\n+        store_data->set_null_free_array();\n+      }\n+    }\n+  }\n+}\n+\n+JRT_ENTRY(void, Runtime1::load_flat_array(JavaThread* current, flatArrayOopDesc* array, int index))\n+  assert(array->klass()->is_flatArray_klass(), \"should not be called\");\n+  profile_flat_array(current, true, array->is_null_free_array());\n+\n+  NOT_PRODUCT(_load_flat_array_slowcase_cnt++;)\n+  assert(array->length() > 0 && index < array->length(), \"already checked\");\n+  flatArrayHandle vah(current, array);\n+  oop obj = array->obj_at(index, CHECK);\n+  current->set_vm_result_oop(obj);\n+JRT_END\n+\n+JRT_ENTRY(void, Runtime1::store_flat_array(JavaThread* current, flatArrayOopDesc* array, int index, oopDesc* value))\n+  \/\/ TOOD 8350865 We can call here with a non-flat array because of LIR_Assembler::emit_opFlattenedArrayCheck\n+  if (array->klass()->is_flatArray_klass()) {\n+    profile_flat_array(current, false, array->is_null_free_array());\n+  }\n+\n+  NOT_PRODUCT(_store_flat_array_slowcase_cnt++;)\n+  if (value == nullptr && array->is_null_free_array()) {\n+    SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_NullPointerException());\n+  } else {\n+    assert(array->klass()->is_flatArray_klass(), \"should not be called\");\n+    array->obj_at_put(index, value, CHECK);\n+  }\n+JRT_END\n+\n+JRT_ENTRY(int, Runtime1::substitutability_check(JavaThread* current, oopDesc* left, oopDesc* right))\n+  NOT_PRODUCT(_substitutability_check_slowcase_cnt++;)\n+  JavaCallArguments args;\n+  args.push_oop(Handle(THREAD, left));\n+  args.push_oop(Handle(THREAD, right));\n+  JavaValue result(T_BOOLEAN);\n+  JavaCalls::call_static(&result,\n+                         vmClasses::ValueObjectMethods_klass(),\n+                         vmSymbols::isSubstitutable_name(),\n+                         vmSymbols::object_object_boolean_signature(),\n+                         &args, CHECK_0);\n+  return result.get_jboolean() ? 1 : 0;\n+JRT_END\n+\n+\n+extern \"C\" void ps();\n+\n+void Runtime1::buffer_inline_args_impl(JavaThread* current, Method* m, bool allocate_receiver) {\n+  JavaThread* THREAD = current;\n+  methodHandle method(current, m); \/\/ We are inside the verified_entry or verified_inline_ro_entry of this method.\n+  oop obj = SharedRuntime::allocate_inline_types_impl(current, method, allocate_receiver, CHECK);\n+  current->set_vm_result_oop(obj);\n+}\n+\n+JRT_ENTRY(void, Runtime1::buffer_inline_args(JavaThread* current, Method* method))\n+  NOT_PRODUCT(_buffer_inline_args_slowcase_cnt++;)\n+  buffer_inline_args_impl(current, method, true);\n+JRT_END\n+\n+JRT_ENTRY(void, Runtime1::buffer_inline_args_no_receiver(JavaThread* current, Method* method))\n+  NOT_PRODUCT(_buffer_inline_args_no_receiver_slowcase_cnt++;)\n+  buffer_inline_args_impl(current, method, false);\n+JRT_END\n+\n@@ -776,0 +908,13 @@\n+JRT_ENTRY(void, Runtime1::throw_illegal_monitor_state_exception(JavaThread* current))\n+  NOT_PRODUCT(_throw_illegal_monitor_state_exception_count++;)\n+  ResourceMark rm(current);\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_IllegalMonitorStateException());\n+JRT_END\n+\n+JRT_ENTRY(void, Runtime1::throw_identity_exception(JavaThread* current, oopDesc* object))\n+  NOT_PRODUCT(_throw_identity_exception_count++;)\n+  ResourceMark rm(current);\n+  char* message = SharedRuntime::generate_identity_exception_message(current, object->klass());\n+  SharedRuntime::throw_and_post_jvmti_exception(current, vmSymbols::java_lang_IdentityException(), message);\n+JRT_END\n+\n@@ -981,0 +1126,3 @@\n+  bool deoptimize_for_null_free = false;\n+  bool deoptimize_for_flat = false;\n+  bool deoptimize_for_strict_static = false;\n@@ -1024,0 +1172,13 @@\n+    \/\/ The field we are patching is null-free. Deoptimize and regenerate\n+    \/\/ the compiled code if we patch a putfield\/putstatic because it\n+    \/\/ does not contain the required null check.\n+    deoptimize_for_null_free = result.is_null_free_inline_type() && (field_access.is_putfield() || field_access.is_putstatic());\n+\n+    \/\/ The field we are patching is flat. Deoptimize and regenerate\n+    \/\/ the compiled code which can't handle the layout of the flat\n+    \/\/ field because it was unknown at compile time.\n+    deoptimize_for_flat = result.is_flat();\n+\n+    \/\/ Strict statics may require tracking if their class is not fully initialized.\n+    \/\/ For now we can bail out of the compiler and let the interpreter handle it.\n+    deoptimize_for_strict_static = result.is_strict_static_unset();\n@@ -1058,0 +1219,6 @@\n+          if (!k->is_typeArray_klass() && !k->is_refArray_klass() && !k->is_flatArray_klass()) {\n+            k = ObjArrayKlass::cast(k)->klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+          }\n+          if (k->is_flatArray_klass()) {\n+            deoptimize_for_flat = true;\n+          }\n@@ -1096,1 +1263,5 @@\n-  if (deoptimize_for_volatile || deoptimize_for_atomic) {\n+  if (deoptimize_for_volatile  ||\n+      deoptimize_for_atomic    ||\n+      deoptimize_for_null_free ||\n+      deoptimize_for_flat      ||\n+      deoptimize_for_strict_static) {\n@@ -1107,0 +1278,9 @@\n+      if (deoptimize_for_null_free) {\n+        tty->print_cr(\"Deoptimizing for patching null-free field reference\");\n+      }\n+      if (deoptimize_for_flat) {\n+        tty->print_cr(\"Deoptimizing for patching flat field or array reference\");\n+      }\n+      if (deoptimize_for_strict_static) {\n+        tty->print_cr(\"Deoptimizing for patching strict static field reference\");\n+      }\n@@ -1557,0 +1737,1 @@\n+  tty->print_cr(\" _new_null_free_array_slowcase_cnt: %u\", _new_null_free_array_slowcase_cnt);\n@@ -1559,0 +1740,6 @@\n+  tty->print_cr(\" _load_flat_array_slowcase_cnt:   %u\", _load_flat_array_slowcase_cnt);\n+  tty->print_cr(\" _store_flat_array_slowcase_cnt:  %u\", _store_flat_array_slowcase_cnt);\n+  tty->print_cr(\" _substitutability_check_slowcase_cnt: %u\", _substitutability_check_slowcase_cnt);\n+  tty->print_cr(\" _buffer_inline_args_slowcase_cnt:%u\", _buffer_inline_args_slowcase_cnt);\n+  tty->print_cr(\" _buffer_inline_args_no_receiver_slowcase_cnt:%u\", _buffer_inline_args_no_receiver_slowcase_cnt);\n+\n@@ -1569,0 +1756,2 @@\n+  tty->print_cr(\" _throw_illegal_monitor_state_exception_count:  %u:\", _throw_illegal_monitor_state_exception_count);\n+  tty->print_cr(\" _throw_identity_exception_count:               %u:\", _throw_identity_exception_count);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":193,"deletions":4,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -514,1 +515,1 @@\n-      \/\/ array\n+      \/\/ TODO 8350865 I think we need to handle null-free\/flat arrays here\n@@ -964,0 +965,1 @@\n+\n@@ -1010,27 +1012,79 @@\n-  \/\/ staticfield <klass> <name> <signature> <value>\n-  \/\/\n-  \/\/ Initialize a class and fill in the value for a static field.\n-  \/\/ This is useful when the compile was dependent on the value of\n-  \/\/ static fields but it's impossible to properly rerun the static\n-  \/\/ initializer.\n-  void process_staticfield(TRAPS) {\n-    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);\n-\n-    if (k == nullptr || ReplaySuppressInitializers == 0 ||\n-        (ReplaySuppressInitializers == 2 && k->class_loader() == nullptr)) {\n-      skip_remaining();\n-      return;\n-    }\n-\n-    assert(k->is_initialized(), \"must be\");\n-\n-    const char* field_name = parse_escaped_string();\n-    const char* field_signature = parse_string();\n-    fieldDescriptor fd;\n-    Symbol* name = SymbolTable::new_symbol(field_name);\n-    Symbol* sig = SymbolTable::new_symbol(field_signature);\n-    if (!k->find_local_field(name, sig, &fd) ||\n-        !fd.is_static() ||\n-        fd.has_initial_value()) {\n-      report_error(field_name);\n-      return;\n+  class InlineTypeFieldInitializer : public FieldClosure {\n+    oop _vt;\n+    CompileReplay* _replay;\n+  public:\n+    InlineTypeFieldInitializer(oop vt, CompileReplay* replay)\n+  : _vt(vt), _replay(replay) {}\n+\n+    void do_field(fieldDescriptor* fd) {\n+      BasicType bt = fd->field_type();\n+      const char* string_value = fd->is_null_free_inline_type() ? nullptr : _replay->parse_escaped_string();\n+      switch (bt) {\n+      case T_BYTE: {\n+        int value = atoi(string_value);\n+        _vt->byte_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_BOOLEAN: {\n+        int value = atoi(string_value);\n+        _vt->bool_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_SHORT: {\n+        int value = atoi(string_value);\n+        _vt->short_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_CHAR: {\n+        int value = atoi(string_value);\n+        _vt->char_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_INT: {\n+        int value = atoi(string_value);\n+        _vt->int_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_LONG: {\n+        jlong value;\n+        if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n+          fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n+          break;\n+        }\n+        _vt->long_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_FLOAT: {\n+        float value = atof(string_value);\n+        _vt->float_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        double value = atof(string_value);\n+        _vt->double_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_ARRAY:\n+      case T_OBJECT:\n+        if (!fd->is_null_free_inline_type()) {\n+          JavaThread* THREAD = JavaThread::current();\n+          bool res = _replay->process_staticfield_reference(string_value, _vt, fd, THREAD);\n+          assert(res, \"should succeed for arrays & objects\");\n+          break;\n+        } else {\n+          InlineKlass* vk = InlineKlass::cast(fd->field_holder()->get_inline_type_field_klass(fd->index()));\n+          if (fd->is_flat()) {\n+            int field_offset = fd->offset() - vk->payload_offset();\n+            oop obj = cast_to_oop(cast_from_oop<address>(_vt) + field_offset);\n+            InlineTypeFieldInitializer init_fields(obj, _replay);\n+            vk->do_nonstatic_fields(&init_fields);\n+          } else {\n+            oop value = vk->allocate_instance(JavaThread::current());\n+            _vt->obj_field_put(fd->offset(), value);\n+          }\n+          break;\n+        }\n+      default: {\n+        fatal(\"Unhandled type: %s\", type2name(bt));\n+      }\n+      }\n@@ -1038,0 +1092,1 @@\n+  };\n@@ -1039,1 +1094,1 @@\n-    oop java_mirror = k->java_mirror();\n+  bool process_staticfield_reference(const char* field_signature, oop java_mirror, fieldDescriptor* fd, TRAPS) {\n@@ -1047,4 +1102,2 @@\n-          ArrayKlass* kelem = (ArrayKlass *)parse_klass(CHECK);\n-          if (kelem == nullptr) {\n-            return;\n-          }\n+          Klass* k = resolve_klass(field_signature, CHECK_(true));\n+          ArrayKlass* kelem = (ArrayKlass *)k;\n@@ -1060,1 +1113,1 @@\n-          value = kelem->multi_allocate(rank, dims, CHECK);\n+          value = kelem->multi_allocate(rank, dims, CHECK_(true));\n@@ -1063,1 +1116,1 @@\n-            value = oopFactory::new_byteArray(length, CHECK);\n+            value = oopFactory::new_byteArray(length, CHECK_(true));\n@@ -1065,1 +1118,1 @@\n-            value = oopFactory::new_boolArray(length, CHECK);\n+            value = oopFactory::new_boolArray(length, CHECK_(true));\n@@ -1067,1 +1120,1 @@\n-            value = oopFactory::new_charArray(length, CHECK);\n+            value = oopFactory::new_charArray(length, CHECK_(true));\n@@ -1069,1 +1122,1 @@\n-            value = oopFactory::new_shortArray(length, CHECK);\n+            value = oopFactory::new_shortArray(length, CHECK_(true));\n@@ -1071,1 +1124,1 @@\n-            value = oopFactory::new_floatArray(length, CHECK);\n+            value = oopFactory::new_floatArray(length, CHECK_(true));\n@@ -1073,1 +1126,1 @@\n-            value = oopFactory::new_doubleArray(length, CHECK);\n+            value = oopFactory::new_doubleArray(length, CHECK_(true));\n@@ -1075,1 +1128,1 @@\n-            value = oopFactory::new_intArray(length, CHECK);\n+            value = oopFactory::new_intArray(length, CHECK_(true));\n@@ -1077,1 +1130,1 @@\n-            value = oopFactory::new_longArray(length, CHECK);\n+            value = oopFactory::new_longArray(length, CHECK_(true));\n@@ -1080,1 +1133,4 @@\n-            Klass* actual_array_klass = parse_klass(CHECK);\n+            Klass* actual_array_klass = parse_klass(CHECK_(true));\n+            \/\/ TODO 8350865 I think we need to handle null-free\/flat arrays here\n+            \/\/ This handling will change the array property argument passed to the\n+            \/\/ factory below\n@@ -1082,1 +1138,1 @@\n-            value = oopFactory::new_objArray(kelem, length, CHECK);\n+            value = oopFactory::new_objArray(kelem, length, CHECK_(true));\n@@ -1087,0 +1143,14 @@\n+        java_mirror->obj_field_put(fd->offset(), value);\n+        return true;\n+      }\n+    } else if (strcmp(field_signature, \"Ljava\/lang\/String;\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      Handle value = java_lang_String::create_from_str(string_value, CHECK_(true));\n+      java_mirror->obj_field_put(fd->offset(), value());\n+      return true;\n+    } else if (field_signature[0] == JVM_SIGNATURE_CLASS) {\n+      const char* instance = parse_escaped_string();\n+      oop value = nullptr;\n+      if (instance != nullptr) {\n+        Klass* k = resolve_klass(instance, CHECK_(true));\n+        value = InstanceKlass::cast(k)->allocate_instance(CHECK_(true));\n@@ -1088,0 +1158,76 @@\n+      java_mirror->obj_field_put(fd->offset(), value);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Initialize a class and fill in the value for a static field.\n+  \/\/ This is useful when the compile was dependent on the value of\n+  \/\/ static fields but it's impossible to properly rerun the static\n+  \/\/ initializer.\n+  void process_staticfield(TRAPS) {\n+    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);\n+\n+    if (k == nullptr || ReplaySuppressInitializers == 0 ||\n+        (ReplaySuppressInitializers == 2 && k->class_loader() == nullptr)) {\n+        skip_remaining();\n+      return;\n+    }\n+\n+    assert(k->is_initialized(), \"must be\");\n+\n+    const char* field_name = parse_escaped_string();\n+    const char* field_signature = parse_string();\n+    fieldDescriptor fd;\n+    Symbol* name = SymbolTable::new_symbol(field_name);\n+    Symbol* sig = SymbolTable::new_symbol(field_signature);\n+    if (!k->find_local_field(name, sig, &fd) ||\n+        !fd.is_static() ||\n+        fd.has_initial_value()) {\n+      report_error(field_name);\n+      return;\n+    }\n+\n+    oop java_mirror = k->java_mirror();\n+    if (strcmp(field_signature, \"I\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->int_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"B\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->byte_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"C\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->char_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"S\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->short_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"Z\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->bool_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"J\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      jlong value;\n+      if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n+        fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n+        return;\n+      }\n+      java_mirror->long_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"F\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      float value = atof(string_value);\n+      java_mirror->float_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"D\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      double value = atof(string_value);\n+      java_mirror->double_field_put(fd.offset(), value);\n+    } else if (fd.is_null_free_inline_type()) {\n+      Klass* kelem = resolve_klass(field_signature, CHECK);\n+      InlineKlass* vk = InlineKlass::cast(kelem);\n+      oop value = vk->allocate_instance(CHECK);\n+      InlineTypeFieldInitializer init_fields(value, this);\n+      vk->do_nonstatic_fields(&init_fields);\n@@ -1090,40 +1236,2 @@\n-      const char* string_value = parse_escaped_string();\n-      if (strcmp(field_signature, \"I\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->int_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"B\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->byte_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"C\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->char_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"S\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->short_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"Z\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->bool_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"J\") == 0) {\n-        jlong value;\n-        if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n-          fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n-          return;\n-        }\n-        java_mirror->long_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"F\") == 0) {\n-        float value = atof(string_value);\n-        java_mirror->float_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"D\") == 0) {\n-        double value = atof(string_value);\n-        java_mirror->double_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"Ljava\/lang\/String;\") == 0) {\n-        Handle value = java_lang_String::create_from_str(string_value, CHECK);\n-        java_mirror->obj_field_put(fd.offset(), value());\n-      } else if (field_signature[0] == JVM_SIGNATURE_CLASS) {\n-        oop value = nullptr;\n-        if (string_value != nullptr) {\n-          Klass* k = resolve_klass(string_value, CHECK);\n-          value = InstanceKlass::cast(k)->allocate_instance(CHECK);\n-        }\n-        java_mirror->obj_field_put(fd.offset(), value);\n-      } else {\n+      bool res = process_staticfield_reference(field_signature, java_mirror, &fd, CHECK);\n+      if (!res)  {\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":192,"deletions":84,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+\n+#include \"oops\/inlineKlass.hpp\"\n@@ -53,0 +55,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -87,0 +90,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -159,0 +163,2 @@\n+#define CONSTANT_CLASS_DESCRIPTORS        70\n+\n@@ -197,1 +203,1 @@\n-      case JVM_CONSTANT_Class : {\n+      case JVM_CONSTANT_Class: {\n@@ -501,0 +507,3 @@\n+\n+        Symbol* const name = cp->symbol_at(class_index);\n+        const unsigned int name_len = name->utf8_length();\n@@ -710,1 +719,1 @@\n-            } else if (!Signature::is_void_method(signature)) { \/\/ must have void signature.\n+            } else if (!Signature::is_void_method(signature)) {  \/\/ must have void signature.\n@@ -730,2 +739,3 @@\n-            if (ref_kind == JVM_REF_newInvokeSpecial) {\n-              if (name != vmSymbols::object_initializer_name()) {\n+\n+            if (name != vmSymbols::object_initializer_name()) { \/\/ !<init>\n+              if (ref_kind == JVM_REF_newInvokeSpecial) {\n@@ -737,2 +747,10 @@\n-            } else {\n-              if (name == vmSymbols::object_initializer_name()) {\n+            } else { \/\/ <init>\n+              \/\/ The allowed invocation mode of <init> depends on its signature.\n+              \/\/ This test corresponds to verify_invoke_instructions in the verifier.\n+              const int signature_ref_index =\n+                cp->signature_ref_index_at(name_and_type_ref_index);\n+              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n+              if (signature->is_void_method_signature()\n+                  && ref_kind == JVM_REF_newInvokeSpecial) {\n+                \/\/ OK, could be a constructor call\n+              } else {\n@@ -790,4 +808,13 @@\n-\/\/ Side-effects: populates the _local_interfaces field\n-void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,\n-                                       const int itfs_len,\n-                                       ConstantPool* const cp,\n+static void check_identity_and_value_modifiers(ClassFileParser* current, const InstanceKlass* super_type, TRAPS) {\n+  assert(super_type != nullptr,\"Method doesn't support null super type\");\n+  if (super_type->access_flags().is_identity_class() && !current->access_flags().is_identity_class()\n+      && super_type->name() != vmSymbols::java_lang_Object()) {\n+      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                err_msg(\"Value type %s has an identity type as supertype\",\n+                current->class_name()->as_klass_external_name()));\n+  }\n+}\n+\n+void ClassFileParser::parse_interfaces(const ClassFileStream* stream,\n+                                       int itfs_len,\n+                                       ConstantPool* cp,\n@@ -795,0 +822,6 @@\n+                                       \/\/ FIXME: lots of these functions\n+                                       \/\/ declare their parameters as const,\n+                                       \/\/ which adds only noise to the code.\n+                                       \/\/ Remove the spurious const modifiers.\n+                                       \/\/ Many are of the form \"const int x\"\n+                                       \/\/ or \"T* const x\".\n@@ -802,0 +835,1 @@\n+\n@@ -804,3 +838,2 @@\n-    _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, nullptr, CHECK);\n-\n-    int index;\n+    _local_interface_indexes = new GrowableArray<u2>(itfs_len);\n+    int index = 0;\n@@ -809,1 +842,0 @@\n-      Klass* interf;\n@@ -814,29 +846,1 @@\n-      if (cp->tag_at(interface_index).is_klass()) {\n-        interf = cp->resolved_klass_at(interface_index);\n-      } else {\n-        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n-\n-        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n-        \/\/ But need to make sure it's not an array type.\n-        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n-                           \"Bad interface name in class file %s\", CHECK);\n-\n-        \/\/ Call resolve on the interface class name with class circularity checking\n-        interf = SystemDictionary::resolve_super_or_fail(_class_name,\n-                                                         unresolved_klass,\n-                                                         Handle(THREAD, _loader_data->class_loader()),\n-                                                         false, CHECK);\n-      }\n-\n-      if (!interf->is_interface()) {\n-        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n-                          _class_name->as_klass_external_name(),\n-                          interf->external_name(),\n-                          interf->class_in_module_of_loader()));\n-      }\n-\n-      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n-        *has_nonstatic_concrete_methods = true;\n-      }\n-      _local_interfaces->at_put(index, InstanceKlass::cast(interf));\n+      _local_interface_indexes->at_put_grow(index, interface_index);\n@@ -854,2 +858,1 @@\n-      const InstanceKlass* const k = _local_interfaces->at(index);\n-      Symbol* interface_name = k->name();\n+      Symbol* interface_name = cp->klass_name_at(_local_interface_indexes->at(index));\n@@ -942,0 +945,2 @@\n+    _jdk_internal_LooselyConsistentValue,\n+    _jdk_internal_NullRestricted,\n@@ -1364,1 +1369,1 @@\n-                                   bool is_interface,\n+                                   AccessFlags class_access_flags,\n@@ -1377,0 +1382,1 @@\n+  bool is_inline_type = !class_access_flags.is_identity_class() && !class_access_flags.is_abstract();\n@@ -1384,1 +1390,5 @@\n-  const int total_fields = length + num_injected;\n+\n+  \/\/ two more slots are required for inline classes:\n+  \/\/ one for the static field with a reference to the pre-allocated default value\n+  \/\/ one for the field the JVM injects when detecting an empty inline class\n+  const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);\n@@ -1390,0 +1400,1 @@\n+  int instance_fields_count = 0;\n@@ -1395,0 +1406,7 @@\n+    jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;\n+    if (!supports_inline_types()) {\n+      recognized_modifiers &= ~JVM_ACC_STRICT;\n+    }\n+\n+    const jint flags = cfs->get_u2_fast() & recognized_modifiers;\n+    verify_legal_field_modifiers(flags, class_access_flags, CHECK);\n@@ -1396,2 +1414,0 @@\n-    const jint flags = cfs->get_u2_fast() & JVM_RECOGNIZED_FIELD_MODIFIERS;\n-    verify_legal_field_modifiers(flags, is_interface, CHECK);\n@@ -1414,0 +1430,1 @@\n+    if (!access_flags.is_static()) instance_fields_count++;\n@@ -1421,0 +1438,2 @@\n+    bool is_null_restricted = false;\n+\n@@ -1440,0 +1459,18 @@\n+        if (parsed_annotations.has_annotation(AnnotationCollector::_jdk_internal_NullRestricted)) {\n+          if (!Signature::has_envelope(sig)) {\n+            Exceptions::fthrow(\n+              THREAD_AND_LOCATION,\n+              vmSymbols::java_lang_ClassFormatError(),\n+              \"Illegal use of @jdk.internal.vm.annotation.NullRestricted annotation on field %s.%s with signature %s (primitive types can never be null)\",\n+              class_name()->as_C_string(), name->as_C_string(), sig->as_C_string());\n+          }\n+          const bool is_strict = (flags & JVM_ACC_STRICT) != 0;\n+          if (!is_strict) {\n+            Exceptions::fthrow(\n+              THREAD_AND_LOCATION,\n+              vmSymbols::java_lang_ClassFormatError(),\n+              \"Illegal use of @jdk.internal.vm.annotation.NullRestricted annotation on field %s.%s which doesn't have the @jdk.internal.vm.annotation.Strict annotation\",\n+              class_name()->as_C_string(), name->as_C_string());\n+          }\n+          is_null_restricted = true;\n+        }\n@@ -1462,0 +1499,4 @@\n+    if (is_null_restricted) {\n+      fieldFlags.update_null_free_inline_type(true);\n+    }\n+\n@@ -1478,0 +1519,3 @@\n+    if (access_flags.is_strict() && access_flags.is_static()) {\n+      _has_strict_static_fields = true;\n+    }\n@@ -1482,1 +1526,0 @@\n-  int index = length;\n@@ -1510,3 +1553,2 @@\n-      fi.set_index(index);\n-      _temp_field_info->append(fi);\n-      index++;\n+      int idx = _temp_field_info->append(fi);\n+      _temp_field_info->adr_at(idx)->set_index(idx);\n@@ -1516,1 +1558,17 @@\n-  assert(_temp_field_info->length() == index, \"Must be\");\n+  if (is_inline_type) {\n+    \/\/ Inject static \".null_reset\" field. This is an all-zero value with its null-channel set to zero.\n+    \/\/ IT should never be seen by user code, it is used when writing \"null\" to a nullable flat field\n+    \/\/ The all-zero value ensure that any embedded oop will be set to null, to avoid keeping dead objects\n+    \/\/ alive.\n+    FieldInfo::FieldFlags fflags2(0);\n+    fflags2.update_injected(true);\n+    AccessFlags aflags2(JVM_ACC_STATIC);\n+    FieldInfo fi2(aflags2,\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(null_reset_value_name)),\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)),\n+                 0,\n+                 fflags2);\n+    int idx2 = _temp_field_info->append(fi2);\n+    _temp_field_info->adr_at(idx2)->set_index(idx2);\n+    _static_oop_count++;\n+  }\n@@ -1896,0 +1954,8 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_LooselyConsistentValue_signature): {\n+      if (_location != _in_class)   break; \/\/ only allow for classes\n+      return _jdk_internal_LooselyConsistentValue;\n+    }\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_NullRestricted_signature): {\n+      if (_location != _in_field)   break; \/\/ only allow for fields\n+      return _jdk_internal_NullRestricted;\n+    }\n@@ -2119,0 +2185,2 @@\n+                                      bool is_value_class,\n+                                      bool is_abstract_class,\n@@ -2160,1 +2228,1 @@\n-    verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);\n+    verify_legal_method_modifiers(flags, access_flags() , name, CHECK_NULL);\n@@ -2168,0 +2236,9 @@\n+  if (EnableValhalla) {\n+    if (((flags & JVM_ACC_SYNCHRONIZED) == JVM_ACC_SYNCHRONIZED)\n+        && ((flags & JVM_ACC_STATIC) == 0 )\n+        && !_access_flags.is_identity_class()) {\n+      classfile_parse_error(\"Invalid synchronized method in non-identity class %s\", THREAD);\n+        return nullptr;\n+    }\n+  }\n+\n@@ -2695,0 +2772,2 @@\n+                                    bool is_value_class,\n+                                    bool is_abstract_type,\n@@ -2719,0 +2798,2 @@\n+                                    is_value_class,\n+                                    is_abstract_type,\n@@ -2984,2 +3065,2 @@\n-    \/\/ Access flags\n-    u2 flags;\n+\n+    u2 recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;\n@@ -2988,3 +3069,1 @@\n-      flags = cfs->get_u2_fast() & (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);\n-    } else {\n-      flags = cfs->get_u2_fast() & RECOGNIZED_INNER_CLASS_MODIFIERS;\n+      recognized_modifiers |= JVM_ACC_MODULE;\n@@ -2992,0 +3071,4 @@\n+\n+    \/\/ Access flags\n+    u2 flags = cfs->get_u2_fast() & recognized_modifiers;\n+\n@@ -2996,1 +3079,11 @@\n-    verify_legal_class_modifiers(flags, CHECK_0);\n+\n+    if (!supports_inline_types()) {\n+      const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+      const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+      if (!is_module && !is_interface) {\n+        flags |= JVM_ACC_IDENTITY;\n+      }\n+    }\n+\n+    const char* name = inner_name_index == 0 ? \"unnamed\" : cp->symbol_at(inner_name_index)->as_utf8();\n+    verify_legal_class_modifiers(flags, name, false, CHECK_0);\n@@ -3100,0 +3193,43 @@\n+u2 ClassFileParser::parse_classfile_loadable_descriptors_attribute(const ClassFileStream* const cfs,\n+                                                                   const u1* const loadable_descriptors_attribute_start,\n+                                                                   TRAPS) {\n+  const u1* const current_mark = cfs->current();\n+  u2 length = 0;\n+  if (loadable_descriptors_attribute_start != nullptr) {\n+    cfs->set_current(loadable_descriptors_attribute_start);\n+    cfs->guarantee_more(2, CHECK_0);  \/\/ length\n+    length = cfs->get_u2_fast();\n+  }\n+  const int size = length;\n+  Array<u2>* const loadable_descriptors = MetadataFactory::new_array<u2>(_loader_data, size, CHECK_0);\n+  _loadable_descriptors = loadable_descriptors;\n+  if (length > 0) {\n+    int index = 0;\n+    cfs->guarantee_more(2 * length, CHECK_0);\n+    for (int n = 0; n < length; n++) {\n+      const u2 descriptor_index = cfs->get_u2_fast();\n+      guarantee_property(\n+        valid_symbol_at(descriptor_index),\n+        \"LoadableDescriptors descriptor_index %u has bad constant type in class file %s\",\n+        descriptor_index, CHECK_0);\n+      Symbol* descriptor = _cp->symbol_at(descriptor_index);\n+      bool valid = legal_field_signature(descriptor, CHECK_0);\n+      if(!valid) {\n+        ResourceMark rm(THREAD);\n+        Exceptions::fthrow(THREAD_AND_LOCATION,\n+          vmSymbols::java_lang_ClassFormatError(),\n+          \"Descriptor from LoadableDescriptors attribute at index \\\"%d\\\" in class %s has illegal signature \\\"%s\\\"\",\n+          descriptor_index, _class_name->as_C_string(), descriptor->as_C_string());\n+        return 0;\n+      }\n+      loadable_descriptors->at_put(index++, descriptor_index);\n+    }\n+    assert(index == size, \"wrong size\");\n+  }\n+\n+  \/\/ Restore buffer's current position.\n+  cfs->set_current(current_mark);\n+\n+  return length;\n+}\n+\n@@ -3365,0 +3501,2 @@\n+  \/\/ Set _loadable_descriptors attribute to default sentinel\n+  _loadable_descriptors = Universe::the_empty_short_array();\n@@ -3371,0 +3509,1 @@\n+  bool parsed_loadable_descriptors_attribute = false;\n@@ -3392,0 +3531,2 @@\n+  const u1* loadable_descriptors_attribute_start = nullptr;\n+  u4  loadable_descriptors_attribute_length = 0;\n@@ -3607,0 +3748,9 @@\n+            if (EnableValhalla && tag == vmSymbols::tag_loadable_descriptors()) {\n+              if (parsed_loadable_descriptors_attribute) {\n+                classfile_parse_error(\"Multiple LoadableDescriptors attributes in class file %s\", CHECK);\n+                return;\n+              }\n+              parsed_loadable_descriptors_attribute = true;\n+              loadable_descriptors_attribute_start = cfs->current();\n+              loadable_descriptors_attribute_length = attribute_length;\n+            }\n@@ -3683,0 +3833,12 @@\n+  if (parsed_loadable_descriptors_attribute) {\n+    const u2 num_classes = parse_classfile_loadable_descriptors_attribute(\n+                            cfs,\n+                            loadable_descriptors_attribute_start,\n+                            CHECK);\n+    if (_need_verify) {\n+      guarantee_property(\n+        loadable_descriptors_attribute_length == sizeof(num_classes) + sizeof(u2) * num_classes,\n+        \"Wrong LoadableDescriptors attribute length in class file %s\", CHECK);\n+    }\n+  }\n+\n@@ -3748,0 +3910,1 @@\n+  this_klass->set_loadable_descriptors(_loadable_descriptors);\n@@ -3751,0 +3914,1 @@\n+  this_klass->set_inline_layout_info_array(_inline_layout_info_array);\n@@ -3788,3 +3952,2 @@\n-                       \"Invalid superclass index %u in class file %s\",\n-                       super_class_index,\n-                       CHECK_NULL);\n+                   \"Invalid superclass index 0 in class file %s\",\n+                   CHECK_NULL);\n@@ -3798,1 +3961,0 @@\n-    bool is_array = false;\n@@ -3801,4 +3963,0 @@\n-      if (need_verify)\n-        is_array = super_klass->is_array_klass();\n-    } else if (need_verify) {\n-      is_array = (cp->klass_name_at(super_class_index)->char_at(0) == JVM_SIGNATURE_ARRAY);\n@@ -3807,0 +3965,1 @@\n+      bool is_array = (cp->klass_name_at(super_class_index)->char_at(0) == JVM_SIGNATURE_ARRAY);\n@@ -3980,0 +4139,6 @@\n+bool ClassFileParser::supports_inline_types() const {\n+  \/\/ Inline types are only supported by class file version 70.65535 and later\n+  return _major_version > JAVA_26_VERSION ||\n+         (_major_version == JAVA_26_VERSION && _minor_version == JAVA_PREVIEW_MINOR_VERSION);\n+}\n+\n@@ -4023,3 +4188,4 @@\n-  } else if (max_transitive_size == local_size) {\n-    \/\/ only local interfaces added, share local interface array\n-    return local_ifs;\n+    \/\/ The three lines below are commented to work around bug JDK-8245487\n+\/\/  } else if (max_transitive_size == local_size) {\n+\/\/    \/\/ only local interfaces added, share local interface array\n+\/\/    return local_ifs;\n@@ -4046,0 +4212,1 @@\n+\n@@ -4078,0 +4245,10 @@\n+    \/\/ The JVMS says that super classes for value types must not have the ACC_IDENTITY\n+    \/\/ flag set. But, java.lang.Object must still be allowed to be a direct super class\n+    \/\/ for a value classes.  So, it is treated as a special case for now.\n+    if (!this_klass->access_flags().is_identity_class() &&\n+        super_ik->name() != vmSymbols::java_lang_Object() &&\n+        super_ik->is_identity_class()) {\n+      classfile_icce_error(\"value class %s cannot inherit from class %s\", super_ik, THREAD);\n+      return;\n+    }\n+\n@@ -4250,1 +4427,1 @@\n-void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {\n+void ClassFileParser::verify_legal_class_modifiers(jint flags, const char* name, bool is_Object, TRAPS) const {\n@@ -4252,0 +4429,1 @@\n+  const bool is_inner_class = name != nullptr;\n@@ -4269,1 +4447,1 @@\n-  const bool is_super      = (flags & JVM_ACC_SUPER)      != 0;\n+  const bool is_identity   = (flags & JVM_ACC_IDENTITY)   != 0;\n@@ -4273,0 +4451,2 @@\n+  const bool valid_value_class = is_identity || is_interface ||\n+                                 (supports_inline_types() && (!is_identity && (is_abstract || is_final)));\n@@ -4276,2 +4456,3 @@\n-      (is_interface && major_gte_1_5 && (is_super || is_enum)) ||\n-      (!is_interface && major_gte_1_5 && is_annotation)) {\n+      (is_interface && major_gte_1_5 && (is_identity || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n+      (!is_interface && major_gte_1_5 && is_annotation) ||\n+      (!valid_value_class)) {\n@@ -4279,8 +4460,22 @@\n-    \/\/ Names are all known to be < 64k so we know this formatted message is not excessively large.\n-    Exceptions::fthrow(\n-      THREAD_AND_LOCATION,\n-      vmSymbols::java_lang_ClassFormatError(),\n-      \"Illegal class modifiers in class %s: 0x%X\",\n-      _class_name->as_C_string(), flags\n-    );\n-    return;\n+    const char* class_note = \"\";\n+    if (!valid_value_class) {\n+      class_note = \" (a value class must be final or else abstract)\";\n+    }\n+    if (name == nullptr) { \/\/ Not an inner class\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Illegal class modifiers in class %s%s: 0x%X\",\n+        _class_name->as_C_string(), class_note, flags\n+      );\n+      return;\n+    } else {\n+      \/\/ Names are all known to be < 64k so we know this formatted message is not excessively large.\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Illegal class modifiers in declaration of inner class %s%s of class %s: 0x%X\",\n+        name, class_note, _class_name->as_C_string(), flags\n+      );\n+      return;\n+    }\n@@ -4354,2 +4549,2 @@\n-void ClassFileParser::verify_legal_field_modifiers(jint flags,\n-                                                   bool is_interface,\n+void ClassFileParser:: verify_legal_field_modifiers(jint flags,\n+                                                   AccessFlags class_access_flags,\n@@ -4367,0 +4562,1 @@\n+  const bool is_strict    = (flags & JVM_ACC_STRICT)    != 0;\n@@ -4369,1 +4565,2 @@\n-  bool is_illegal = false;\n+  const bool is_interface = class_access_flags.is_interface();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n@@ -4371,9 +4568,30 @@\n-  if (is_interface) {\n-    if (!is_public || !is_static || !is_final || is_private ||\n-        is_protected || is_volatile || is_transient ||\n-        (major_gte_1_5 && is_enum)) {\n-      is_illegal = true;\n-    }\n-  } else { \/\/ not interface\n-    if (has_illegal_visibility(flags) || (is_final && is_volatile)) {\n-      is_illegal = true;\n+  bool is_illegal = false;\n+  const char* error_msg = \"\";\n+\n+  \/\/ There is some overlap in the checks that apply, for example interface fields\n+  \/\/ must be static, static fields can't be strict, and therefore interfaces can't\n+  \/\/ have strict fields. So we don't have to check every possible invalid combination\n+  \/\/ individually as long as all are covered. Once we have found an illegal combination\n+  \/\/ we can stop checking.\n+\n+  if (!is_illegal) {\n+    if (is_interface) {\n+      if (!is_public || !is_static || !is_final || is_private ||\n+          is_protected || is_volatile || is_transient ||\n+          (major_gte_1_5 && is_enum)) {\n+        is_illegal = true;\n+        error_msg = \"interface fields must be public, static and final, and may be synthetic\";\n+      }\n+    } else { \/\/ not interface\n+      if (has_illegal_visibility(flags)) {\n+        is_illegal = true;\n+        error_msg = \"invalid visibility flags for class field\";\n+      } else if (is_final && is_volatile) {\n+        is_illegal = true;\n+        error_msg = \"fields cannot be final and volatile\";\n+      } else if (supports_inline_types()) {\n+        if (!is_identity_class && !is_static && (!is_strict || !is_final)) {\n+          is_illegal = true;\n+          error_msg = \"value class fields must be either non-static final and strict, or static\";\n+        }\n+      }\n@@ -4389,2 +4607,2 @@\n-      \"Illegal field modifiers in class %s: 0x%X\",\n-      _class_name->as_C_string(), flags);\n+      \"Illegal field modifiers (%s) in class %s: 0x%X\",\n+      error_msg, _class_name->as_C_string(), flags);\n@@ -4396,1 +4614,1 @@\n-                                                    bool is_interface,\n+                                                    AccessFlags class_access_flags,\n@@ -4415,0 +4633,4 @@\n+  \/\/ LW401 CR required: removal of value factories support\n+  const bool is_interface    = class_access_flags.is_interface();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n+  const bool is_abstract_class = class_access_flags.is_abstract();\n@@ -4418,0 +4640,1 @@\n+  const char* class_note = \"\";\n@@ -4457,4 +4680,9 @@\n-        if (is_abstract) {\n-          if ((is_final || is_native || is_private || is_static ||\n-              (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n-            is_illegal = true;\n+        if (!is_identity_class && is_synchronized && !is_static) {\n+          is_illegal = true;\n+          class_note = \" (not an identity class)\";\n+        } else {\n+          if (is_abstract) {\n+            if ((is_final || is_native || is_private || is_static ||\n+                (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n+              is_illegal = true;\n+            }\n@@ -4473,2 +4701,3 @@\n-      \"Method %s in class %s has illegal modifiers: 0x%X\",\n-      name->as_C_string(), _class_name->as_C_string(), flags);\n+      \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n+      name->as_C_string(), _class_name->as_C_string(),\n+      class_note, flags);\n@@ -4532,0 +4761,9 @@\n+bool ClassFileParser::is_class_in_loadable_descriptors_attribute(Symbol *klass) {\n+  if (_loadable_descriptors == nullptr) return false;\n+  for (int i = 0; i < _loadable_descriptors->length(); i++) {\n+        Symbol* class_name = _cp->symbol_at(_loadable_descriptors->at(i));\n+        if (class_name == klass) return true;\n+  }\n+  return false;\n+}\n+\n@@ -4633,1 +4871,2 @@\n-    case JVM_SIGNATURE_CLASS: {\n+    case JVM_SIGNATURE_CLASS:\n+    {\n@@ -4644,1 +4883,1 @@\n-        \/\/ Skip leading 'L' and ignore first appearance of ';'\n+        \/\/ Skip leading 'L' or 'Q' and ignore first appearance of ';'\n@@ -4700,0 +4939,4 @@\n+    } else if ((_major_version >= CONSTANT_CLASS_DESCRIPTORS || _class_name->starts_with(\"jdk\/internal\/reflect\/\"))\n+                   && bytes[length - 1] == ';' ) {\n+      \/\/ Support for L...; descriptors\n+      legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);\n@@ -4767,1 +5010,2 @@\n-      if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {\n+      if (name == vmSymbols::object_initializer_name() ||\n+          name == vmSymbols::class_initializer_name()) {\n@@ -4794,0 +5038,10 @@\n+bool ClassFileParser::legal_field_signature(const Symbol* signature, TRAPS) const {\n+  const char* const bytes = (const char*)signature->bytes();\n+  const unsigned int length = signature->utf8_length();\n+  const char* const p = skip_over_field_signature(bytes, false, length, CHECK_false);\n+\n+  if (p == nullptr || (p - bytes) != (int)length) {\n+    return false;\n+  }\n+  return true;\n+}\n@@ -4829,3 +5083,3 @@\n-      name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n-      sig_length > 0 &&\n-      signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n+    name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n+    sig_length > 0 &&\n+    signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n@@ -4882,2 +5136,2 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  return _field_info->_static_field_size;\n+  assert(_layout_info != nullptr, \"invariant\");\n+  return _layout_info->_static_field_size;\n@@ -4887,2 +5141,2 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  return _field_info->oop_map_blocks->_nonstatic_oop_map_count;\n+  assert(_layout_info != nullptr, \"invariant\");\n+  return _layout_info->oop_map_blocks->_nonstatic_oop_map_count;\n@@ -4892,2 +5146,2 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  return _field_info->_instance_size;\n+  assert(_layout_info != nullptr, \"invariant\");\n+  return _layout_info->_instance_size;\n@@ -5008,1 +5262,0 @@\n-\n@@ -5031,3 +5284,3 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  assert(ik->static_field_size() == _field_info->_static_field_size, \"sanity\");\n-  assert(ik->nonstatic_oop_map_count() == _field_info->oop_map_blocks->_nonstatic_oop_map_count,\n+  assert(_layout_info != nullptr, \"invariant\");\n+  assert(ik->static_field_size() == _layout_info->_static_field_size, \"sanity\");\n+  assert(ik->nonstatic_oop_map_count() == _layout_info->oop_map_blocks->_nonstatic_oop_map_count,\n@@ -5037,1 +5290,1 @@\n-  assert(ik->size_helper() == _field_info->_instance_size, \"sanity\");\n+  assert(ik->size_helper() == _layout_info->_instance_size, \"sanity\");\n@@ -5043,2 +5296,12 @@\n-  ik->set_nonstatic_field_size(_field_info->_nonstatic_field_size);\n-  ik->set_has_nonstatic_fields(_field_info->_has_nonstatic_fields);\n+  ik->set_nonstatic_field_size(_layout_info->_nonstatic_field_size);\n+  ik->set_has_nonstatic_fields(_layout_info->_has_nonstatic_fields);\n+  ik->set_has_strict_static_fields(_has_strict_static_fields);\n+\n+  if (_layout_info->_is_naturally_atomic) {\n+    ik->set_is_naturally_atomic();\n+  }\n+\n+  if (_layout_info->_must_be_atomic) {\n+    ik->set_must_be_atomic();\n+  }\n+\n@@ -5050,0 +5313,3 @@\n+  if (ik->is_inline_klass()) {\n+    InlineKlass::cast(ik)->init_fixed_block();\n+  }\n@@ -5063,0 +5329,1 @@\n+  assert(nullptr == _loadable_descriptors, \"invariant\");\n@@ -5066,0 +5333,1 @@\n+  assert(nullptr == _inline_layout_info_array, \"invariant\");\n@@ -5143,1 +5411,1 @@\n-  OopMapBlocksBuilder* oop_map_blocks = _field_info->oop_map_blocks;\n+  OopMapBlocksBuilder* oop_map_blocks = _layout_info->oop_map_blocks;\n@@ -5204,0 +5472,15 @@\n+  if (is_inline_type()) {\n+    InlineKlass* vk = InlineKlass::cast(ik);\n+    vk->set_payload_alignment(_layout_info->_payload_alignment);\n+    vk->set_payload_offset(_layout_info->_payload_offset);\n+    vk->set_payload_size_in_bytes(_layout_info->_payload_size_in_bytes);\n+    vk->set_non_atomic_size_in_bytes(_layout_info->_non_atomic_size_in_bytes);\n+    vk->set_non_atomic_alignment(_layout_info->_non_atomic_alignment);\n+    vk->set_atomic_size_in_bytes(_layout_info->_atomic_layout_size_in_bytes);\n+    vk->set_nullable_size_in_bytes(_layout_info->_nullable_layout_size_in_bytes);\n+    vk->set_null_marker_offset(_layout_info->_null_marker_offset);\n+    vk->set_null_reset_value_offset(_layout_info->_null_reset_value_offset);\n+    if (_layout_info->_is_empty_inline_klass) vk->set_is_empty_inline_type();\n+    vk->initialize_calling_convention(CHECK);\n+  }\n+\n@@ -5285,0 +5568,1 @@\n+  _loadable_descriptors(nullptr),\n@@ -5287,0 +5571,1 @@\n+  _local_interface_indexes(nullptr),\n@@ -5296,1 +5581,2 @@\n-  _field_info(nullptr),\n+  _layout_info(nullptr),\n+  _inline_layout_info_array(nullptr),\n@@ -5324,0 +5610,5 @@\n+  _has_strict_static_fields(false),\n+  _has_inline_type_fields(false),\n+  _is_naturally_atomic(false),\n+  _must_be_atomic(true),\n+  _has_loosely_consistent_annotation(false),\n@@ -5360,0 +5651,1 @@\n+  _loadable_descriptors = nullptr;\n@@ -5364,0 +5656,1 @@\n+  _inline_layout_info_array = nullptr;\n@@ -5382,0 +5675,4 @@\n+  if (_inline_layout_info_array != nullptr) {\n+    MetadataFactory::free_array<InlineLayoutInfo>(_loader_data, _inline_layout_info_array);\n+  }\n+\n@@ -5404,0 +5701,4 @@\n+  if (_loadable_descriptors != nullptr && _loadable_descriptors != Universe::the_empty_short_array()) {\n+    MetadataFactory::free_array<u2>(_loader_data, _loadable_descriptors);\n+  }\n+\n@@ -5488,2 +5789,1 @@\n-  \/\/ Access flags\n-  u2 flags;\n+  u2 recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;\n@@ -5492,3 +5792,1 @@\n-    flags = stream->get_u2_fast() & (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);\n-  } else {\n-    flags = stream->get_u2_fast() & JVM_RECOGNIZED_CLASS_MODIFIERS;\n+    recognized_modifiers |= JVM_ACC_MODULE;\n@@ -5497,0 +5795,3 @@\n+  \/\/ Access flags\n+  u2 flags = stream->get_u2_fast() & recognized_modifiers;\n+\n@@ -5502,8 +5803,7 @@\n-  verify_legal_class_modifiers(flags, CHECK);\n-\n-  short bad_constant = class_bad_constant_seen();\n-  if (bad_constant != 0) {\n-    \/\/ Do not throw CFE until after the access_flags are checked because if\n-    \/\/ ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.\n-    classfile_parse_error(\"Unknown constant tag %u in class file %s\", bad_constant, THREAD);\n-    return;\n+  \/\/ Fixing ACC_SUPER\/ACC_IDENTITY for old class files\n+  if (!supports_inline_types()) {\n+    const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+    const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+    if (!is_module && !is_interface) {\n+      flags |= JVM_ACC_IDENTITY;\n+    }\n@@ -5512,1 +5812,0 @@\n-  _access_flags.set_flags(flags);\n@@ -5525,0 +5824,14 @@\n+  bool is_java_lang_Object = class_name_in_cp == vmSymbols::java_lang_Object();\n+\n+  verify_legal_class_modifiers(flags, nullptr, is_java_lang_Object, CHECK);\n+\n+  _access_flags.set_flags(flags);\n+\n+  short bad_constant = class_bad_constant_seen();\n+  if (bad_constant != 0) {\n+    \/\/ Do not throw CFE until after the access_flags are checked because if\n+    \/\/ ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.\n+    classfile_parse_error(\"Unknown constant tag %u in class file %s\", bad_constant, THREAD);\n+    return;\n+  }\n+\n@@ -5605,2 +5918,0 @@\n-  assert(_local_interfaces != nullptr, \"invariant\");\n-\n@@ -5609,1 +5920,1 @@\n-               _access_flags.is_interface(),\n+               _access_flags,\n@@ -5619,1 +5930,3 @@\n-                _access_flags.is_interface(),\n+                is_interface(),\n+                !is_identity_class(),\n+                is_abstract_class(),\n@@ -5699,2 +6012,2 @@\n-                       \"java.lang.Object cannot implement an interface in class file %s\",\n-                       CHECK);\n+        \"java.lang.Object cannot implement an interface in class file %s\",\n+        CHECK);\n@@ -5705,1 +6018,1 @@\n-    if (_access_flags.is_interface()) {\n+    if (is_interface()) {\n@@ -5717,1 +6030,1 @@\n-                       SystemDictionary::resolve_super_or_fail(_class_name,\n+                       SystemDictionary::resolve_with_circularity_detection_or_fail(_class_name,\n@@ -5726,0 +6039,14 @@\n+    if (_super_klass->is_interface()) {\n+      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n+      return;\n+    }\n+\n+    if (_super_klass->is_final()) {\n+      classfile_icce_error(\"class %s cannot inherit from final class %s\", _super_klass, THREAD);\n+      return;\n+    }\n+\n+    if (EnableValhalla) {\n+      check_identity_and_value_modifiers(this, _super_klass, CHECK);\n+    }\n+\n@@ -5729,0 +6056,1 @@\n+  }\n@@ -5730,3 +6058,69 @@\n-    if (_super_klass->is_interface()) {\n-      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n-      return;\n+  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_LooselyConsistentValue) && _access_flags.is_identity_class()) {\n+    THROW_MSG(vmSymbols::java_lang_ClassFormatError(),\n+          err_msg(\"class %s cannot have annotation jdk.internal.vm.annotation.LooselyConsistentValue, because it is not a value class\",\n+                  _class_name->as_klass_external_name()));\n+  }\n+\n+  \/\/ Determining is the class allows tearing or not (default is not)\n+  if (EnableValhalla && !_access_flags.is_identity_class()) {\n+    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_LooselyConsistentValue)\n+        && (_super_klass == vmClasses::Object_klass() || !_super_klass->must_be_atomic())) {\n+      \/\/ Conditions above are not sufficient to determine atomicity requirements,\n+      \/\/ the presence of fields with atomic requirements could force the current class to have atomicy requirements too\n+      \/\/ Marking as not needing atomicity for now, can be updated when computing the fields layout\n+      \/\/ The InstanceKlass must be filled with the value from the FieldLayoutInfo returned by\n+      \/\/ the FieldLayoutBuilder, not with this _must_be_atomic field.\n+      _must_be_atomic = false;\n+    }\n+    \/\/ Apply VM options override\n+    if (*ForceNonTearable != '\\0') {\n+      \/\/ Allow a command line switch to force the same atomicity property:\n+      const char* class_name_str = _class_name->as_C_string();\n+      if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {\n+        _must_be_atomic = true;\n+      }\n+    }\n+  }\n+\n+  int itfs_len = _local_interface_indexes == nullptr ? 0 : _local_interface_indexes->length();\n+  _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, nullptr, CHECK);\n+  if (_local_interface_indexes != nullptr) {\n+    for (int i = 0; i < _local_interface_indexes->length(); i++) {\n+      u2 interface_index = _local_interface_indexes->at(i);\n+      Klass* interf;\n+      if (cp->tag_at(interface_index).is_klass()) {\n+        interf = cp->resolved_klass_at(interface_index);\n+      } else {\n+        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n+\n+        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n+        \/\/ But need to make sure it's not an array type.\n+        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n+                            \"Bad interface name in class file %s\", CHECK);\n+\n+        \/\/ Call resolve on the interface class name with class circularity checking\n+        interf = SystemDictionary::resolve_with_circularity_detection_or_fail(\n+                                                  _class_name,\n+                                                  unresolved_klass,\n+                                                  Handle(THREAD, _loader_data->class_loader()),\n+                                                  false,\n+                                                  CHECK);\n+      }\n+\n+      if (!interf->is_interface()) {\n+        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n+                          _class_name->as_klass_external_name(),\n+                          interf->external_name(),\n+                          interf->class_in_module_of_loader()));\n+      }\n+\n+      if (EnableValhalla) {\n+        \/\/ Check modifiers and set carries_identity_modifier\/carries_value_modifier flags\n+        check_identity_and_value_modifiers(this, InstanceKlass::cast(interf), CHECK);\n+      }\n+\n+      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n+        _has_nonstatic_concrete_methods = true;\n+      }\n+      _local_interfaces->at_put(i, InstanceKlass::cast(interf));\n@@ -5735,0 +6129,1 @@\n+  assert(_local_interfaces != nullptr, \"invariant\");\n@@ -5763,1 +6158,1 @@\n-  _itable_size = _access_flags.is_interface() ? 0 :\n+  _itable_size = is_interface() ? 0 :\n@@ -5768,3 +6163,92 @@\n-  _field_info = new FieldLayoutInfo();\n-  FieldLayoutBuilder lb(class_name(), super_klass(), _cp, \/*_fields*\/ _temp_field_info,\n-                        _parsed_annotations->is_contended(), _field_info);\n+  if (EnableValhalla) {\n+    _inline_layout_info_array = MetadataFactory::new_array<InlineLayoutInfo>(_loader_data,\n+                                                   java_fields_count(),\n+                                                   CHECK);\n+    for (GrowableArrayIterator<FieldInfo> it = _temp_field_info->begin(); it != _temp_field_info->end(); ++it) {\n+      FieldInfo fieldinfo = *it;\n+      if (fieldinfo.access_flags().is_static()) continue;  \/\/ Only non-static fields are processed at load time\n+      Symbol* sig = fieldinfo.signature(cp);\n+      if (fieldinfo.field_flags().is_null_free_inline_type()) {\n+        \/\/ Pre-load classes of null-free fields that are candidate for flattening\n+        TempNewSymbol s = Signature::strip_envelope(sig);\n+        if (s == _class_name) {\n+          THROW_MSG(vmSymbols::java_lang_ClassCircularityError(),\n+                    err_msg(\"Class %s cannot have a null-free non-static field of its own type\", _class_name->as_C_string()));\n+        }\n+        log_info(class, preload)(\"Preloading class %s during loading of class %s. \"\n+                                  \"Cause: a null-free non-static field is declared with this type\",\n+                                  s->as_C_string(), _class_name->as_C_string());\n+        InstanceKlass* klass = SystemDictionary::resolve_with_circularity_detection_or_fail(_class_name, s,\n+                                                                                            Handle(THREAD,\n+                                                                                            _loader_data->class_loader()),\n+                                                                                            false, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          log_warning(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                      \"(cause: null-free non-static field) failed: %s\",\n+                                      s->as_C_string(), _class_name->as_C_string(),\n+                                      PENDING_EXCEPTION->klass()->name()->as_C_string());\n+          return; \/\/ Exception is still pending\n+        }\n+        assert(klass != nullptr, \"Sanity check\");\n+        InstanceKlass::check_can_be_annotated_with_NullRestricted(klass, _class_name, CHECK);\n+        InlineKlass* vk = InlineKlass::cast(klass);\n+        _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(vk);\n+        log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                 \"(cause: null-free non-static field) succeeded\",\n+                                 s->as_C_string(), _class_name->as_C_string());\n+      } else if (Signature::has_envelope(sig)) {\n+        \/\/ Preloading classes for nullable fields that are listed in the LoadableDescriptors attribute\n+        \/\/ Those classes would be required later for the flattening of nullable inline type fields\n+        TempNewSymbol name = Signature::strip_envelope(sig);\n+        if (name != _class_name && is_class_in_loadable_descriptors_attribute(sig)) {\n+          log_info(class, preload)(\"Preloading class %s during loading of class %s. \"\n+                                   \"Cause: field type in LoadableDescriptors attribute\",\n+                                   name->as_C_string(), _class_name->as_C_string());\n+          oop loader = loader_data()->class_loader();\n+          Klass* klass = SystemDictionary::resolve_with_circularity_detection_or_fail(_class_name, name,\n+                                                                                      Handle(THREAD, loader),\n+                                                                                      false, THREAD);\n+          if (klass != nullptr) {\n+            if (klass->is_inline_klass()) {\n+              _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(InlineKlass::cast(klass));\n+              log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                       \"(cause: field type in LoadableDescriptors attribute) succeeded\",\n+                                       name->as_C_string(), _class_name->as_C_string());\n+            } else {\n+              \/\/ Non value class are allowed by the current spec, but it could be an indication of an issue so let's log a warning\n+              log_warning(class, preload)(\"Preloading class %s during loading of class %s \"\n+                                          \"(cause: field type in LoadableDescriptors attribute) but loaded class is not a value class\",\n+                                          name->as_C_string(), _class_name->as_C_string());\n+            }\n+          } else {\n+            log_warning(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                        \"(cause: field type in LoadableDescriptors attribute) failed : %s\",\n+                                        name->as_C_string(), _class_name->as_C_string(),\n+                                        PENDING_EXCEPTION->klass()->name()->as_C_string());\n+          }\n+          \/\/ Loads triggered by the LoadableDescriptors attribute are speculative, failures must not impact loading of current class\n+          if (HAS_PENDING_EXCEPTION) {\n+            CLEAR_PENDING_EXCEPTION;\n+          }\n+        } else {\n+          \/\/ Just poking the system dictionary to see if the class has already be loaded. Looking for migrated classes\n+          \/\/ used when --enable-preview when jdk isn't compiled with --enable-preview so doesn't include LoadableDescriptors.\n+          \/\/ This is temporary.\n+          oop loader = loader_data()->class_loader();\n+          InstanceKlass* klass = SystemDictionary::find_instance_klass(THREAD, name, Handle(THREAD, loader));\n+          if (klass != nullptr && klass->is_inline_klass()) {\n+            _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(InlineKlass::cast(klass));\n+            log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                     \"(cause: field type not in LoadableDescriptors attribute) succeeded\",\n+                                     name->as_C_string(), _class_name->as_C_string());\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  _layout_info = new FieldLayoutInfo();\n+  FieldLayoutBuilder lb(class_name(), loader_data(), super_klass(), _cp, \/*_fields*\/ _temp_field_info,\n+      _parsed_annotations->is_contended(), is_inline_type(),\n+      access_flags().is_abstract() && !access_flags().is_identity_class() && !access_flags().is_interface(),\n+      _must_be_atomic, _layout_info, _inline_layout_info_array);\n@@ -5772,0 +6256,1 @@\n+  _has_inline_type_fields = _layout_info->_has_inline_fields;\n@@ -5777,0 +6262,1 @@\n+\n@@ -5780,0 +6266,21 @@\n+\n+  \/\/ Strict static fields track initialization status from the beginning of time.\n+  \/\/ After this class runs <clinit>, they will be verified as being \"not unset\".\n+  \/\/ See Step 8 of InstanceKlass::initialize_impl.\n+  if (_has_strict_static_fields) {\n+    bool found_one = false;\n+    for (int i = 0; i < _temp_field_info->length(); i++) {\n+      FieldInfo& fi = *_temp_field_info->adr_at(i);\n+      if (fi.access_flags().is_strict() && fi.access_flags().is_static()) {\n+        found_one = true;\n+        if (fi.initializer_index() != 0) {\n+          \/\/ skip strict static fields with ConstantValue attributes\n+        } else {\n+          _fields_status->adr_at(fi.index())->update_strict_static_unset(true);\n+          _fields_status->adr_at(fi.index())->update_strict_static_unread(true);\n+        }\n+      }\n+    }\n+    assert(found_one == _has_strict_static_fields,\n+           \"correct prediction = %d\", (int)_has_strict_static_fields);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":662,"deletions":155,"binary":false,"changes":817,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,7 @@\n+struct NameAndSig {\n+  Symbol* _name;\n+  Symbol* _signature;\n+\n+  NameAndSig(Symbol* n, Symbol* s) : _name(n), _signature(s) {}\n+};\n+\n@@ -43,1 +50,3 @@\n-    DYNAMICCONSTANT_MAJOR_VERSION       = 55\n+    DYNAMICCONSTANT_MAJOR_VERSION       = 55,\n+    VALUE_TYPES_MAJOR_VERSION           = 70,\n+    JAVA_PREVIEW_MINOR_VERSION          = 65535,\n@@ -151,0 +160,1 @@\n+    BAD_STRICT_FIELDS,    \/\/ Strict instance fields must be initialized before super constructor\n@@ -153,0 +163,1 @@\n+    STRICT_FIELDS_MISMATCH, \/\/ Frames have incompatible uninitialized strict instance fields\n@@ -157,0 +168,1 @@\n+    WRONG_INLINE_TYPE,    \/\/ Mismatched inline type\n@@ -198,0 +210,3 @@\n+  static ErrorContext bad_strict_fields(int bci, StackMapFrame* cur) {\n+    return ErrorContext(bci, BAD_STRICT_FIELDS, TypeOrigin::frame(cur));\n+  }\n@@ -208,0 +223,5 @@\n+  static ErrorContext strict_fields_mismatch(\n+      int bci, StackMapFrame* frame0, StackMapFrame* frame1) {\n+        return ErrorContext(bci, STRICT_FIELDS_MISMATCH,\n+          TypeOrigin::frame(frame0), TypeOrigin::frame(frame1));\n+  }\n@@ -220,0 +240,3 @@\n+  static ErrorContext bad_inline_type(int bci, TypeOrigin type, TypeOrigin exp) {\n+    return ErrorContext(bci, WRONG_INLINE_TYPE, type, exp);\n+  }\n@@ -350,1 +373,1 @@\n-    bool in_try_block, bool* this_uninit, VerificationType return_type,\n+    bool in_try_block, bool* this_uninit,\n@@ -447,1 +470,2 @@\n-    return VerificationType::reference_type(cp->klass_name_at(index));\n+    Symbol* name = cp->klass_name_at(index);\n+    return VerificationType::reference_type(name);\n@@ -485,2 +509,1 @@\n-        *inference_type =\n-          VerificationType::reference_type(name_copy);\n+        *inference_type = VerificationType::reference_type(name_copy);\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -731,0 +731,11 @@\n+\n+      \/\/ If inline types are passed as fields, use the extended signature\n+      \/\/ which contains the types of all (oop) fields of the inline type.\n+      if (is_compiled_by_c2() && callee->has_scalarized_args()) {\n+        const GrowableArray<SigEntry>* sig = callee->adapter()->get_sig_cc();\n+        assert(sig != nullptr, \"sig should never be null\");\n+        TempNewSymbol tmp_sig = SigEntry::create_symbol(sig);\n+        has_receiver = false; \/\/ The extended signature contains the receiver type\n+        fr.oops_compiled_arguments_do(tmp_sig, has_receiver, has_appendix, reg_map, f);\n+        return;\n+      }\n@@ -1267,0 +1278,4 @@\n+  _inline_entry_point             = entry_point();\n+  _verified_inline_entry_point    = verified_entry_point();\n+  _verified_inline_ro_entry_point = verified_entry_point();\n+\n@@ -1306,1 +1321,1 @@\n-\n+    assert(!method->has_scalarized_args(), \"scalarized native wrappers not supported yet\");\n@@ -1510,0 +1525,4 @@\n+    _inline_entry_point             = code_begin() + offsets->value(CodeOffsets::Inline_Entry);\n+    _verified_inline_entry_point    = code_begin() + offsets->value(CodeOffsets::Verified_Inline_Entry);\n+    _verified_inline_ro_entry_point = code_begin() + offsets->value(CodeOffsets::Verified_Inline_Entry_RO);\n+\n@@ -3732,0 +3751,1 @@\n+  if (pos == inline_entry_point())                                      label = \"[Inline Entry Point]\";\n@@ -3733,0 +3753,2 @@\n+  if (pos == verified_inline_entry_point())                             label = \"[Verified Inline Entry Point]\";\n+  if (pos == verified_inline_ro_entry_point())                          label = \"[Verified Inline Entry Point (RO)]\";\n@@ -3742,0 +3764,10 @@\n+static int maybe_print_entry_label(outputStream* stream, address pos, address entry, const char* label) {\n+  if (pos == entry) {\n+    stream->bol();\n+    stream->print_cr(\"%s\", label);\n+    return 1;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n@@ -3744,33 +3776,12 @@\n-    const char* label = nmethod_section_label(block_begin);\n-    if (label != nullptr) {\n-      stream->bol();\n-      stream->print_cr(\"%s\", label);\n-    }\n-  }\n-\n-  if (block_begin == entry_point()) {\n-    Method* m = method();\n-    if (m != nullptr) {\n-      stream->print(\"  # \");\n-      m->print_value_on(stream);\n-      stream->cr();\n-    }\n-    if (m != nullptr && !is_osr_method()) {\n-      ResourceMark rm;\n-      int sizeargs = m->size_of_parameters();\n-      BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);\n-      VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);\n-      {\n-        int sig_index = 0;\n-        if (!m->is_static())\n-          sig_bt[sig_index++] = T_OBJECT; \/\/ 'this'\n-        for (SignatureStream ss(m->signature()); !ss.at_return_type(); ss.next()) {\n-          BasicType t = ss.type();\n-          sig_bt[sig_index++] = t;\n-          if (type2size[t] == 2) {\n-            sig_bt[sig_index++] = T_VOID;\n-          } else {\n-            assert(type2size[t] == 1, \"size is 1 or 2\");\n-          }\n-        }\n-        assert(sig_index == sizeargs, \"\");\n+    int n = 0;\n+    \/\/ Multiple entry points may be at the same position. Print them all.\n+    n += maybe_print_entry_label(stream, block_begin, entry_point(),                    \"[Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, inline_entry_point(),             \"[Inline Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_entry_point(),           \"[Verified Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_inline_entry_point(),    \"[Verified Inline Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_inline_ro_entry_point(), \"[Verified Inline Entry Point (RO)]\");\n+    if (n == 0) {\n+      const char* label = nmethod_section_label(block_begin);\n+      if (label != nullptr) {\n+        stream->bol();\n+        stream->print_cr(\"%s\", label);\n@@ -3778,54 +3789,73 @@\n-      const char* spname = \"sp\"; \/\/ make arch-specific?\n-      SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n-      int stack_slot_offset = this->frame_size() * wordSize;\n-      int tab1 = 14, tab2 = 24;\n-      int sig_index = 0;\n-      int arg_index = (m->is_static() ? 0 : -1);\n-      bool did_old_sp = false;\n-      for (SignatureStream ss(m->signature()); !ss.at_return_type(); ) {\n-        bool at_this = (arg_index == -1);\n-        bool at_old_sp = false;\n-        BasicType t = (at_this ? T_OBJECT : ss.type());\n-        assert(t == sig_bt[sig_index], \"sigs in sync\");\n-        if (at_this)\n-          stream->print(\"  # this: \");\n-        else\n-          stream->print(\"  # parm%d: \", arg_index);\n-        stream->move_to(tab1);\n-        VMReg fst = regs[sig_index].first();\n-        VMReg snd = regs[sig_index].second();\n-        if (fst->is_reg()) {\n-          stream->print(\"%s\", fst->name());\n-          if (snd->is_valid())  {\n-            stream->print(\":%s\", snd->name());\n-          }\n-        } else if (fst->is_stack()) {\n-          int offset = fst->reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;\n-          if (offset == stack_slot_offset)  at_old_sp = true;\n-          stream->print(\"[%s+0x%x]\", spname, offset);\n-        } else {\n-          stream->print(\"reg%d:%d??\", (int)(intptr_t)fst, (int)(intptr_t)snd);\n-        }\n-        stream->print(\" \");\n-        stream->move_to(tab2);\n-        stream->print(\"= \");\n-        if (at_this) {\n-          m->method_holder()->print_value_on(stream);\n-        } else {\n-          bool did_name = false;\n-          if (!at_this && ss.is_reference()) {\n-            Symbol* name = ss.as_symbol();\n-            name->print_value_on(stream);\n-            did_name = true;\n-          }\n-          if (!did_name)\n-            stream->print(\"%s\", type2name(t));\n-        }\n-        if (at_old_sp) {\n-          stream->print(\"  (%s of caller)\", spname);\n-          did_old_sp = true;\n-        }\n-        stream->cr();\n-        sig_index += type2size[t];\n-        arg_index += 1;\n-        if (!at_this)  ss.next();\n+    }\n+  }\n+\n+  Method* m = method();\n+  if (m == nullptr || is_osr_method()) {\n+    return;\n+  }\n+\n+  \/\/ Print the name of the method (only once)\n+  address low = MIN3(entry_point(),\n+                     verified_entry_point(),\n+                     inline_entry_point());\n+  \/\/ The verified inline entry point and verified inline RO entry point are not always\n+  \/\/ used. When they are unused. CodeOffsets::Verified_Inline_Entry(_RO) is -1. Hence,\n+  \/\/ the calculated entry point is smaller than the block they are offsetting into.\n+  if (verified_inline_entry_point() >= block_begin) {\n+    low = MIN2(low, verified_inline_entry_point());\n+  }\n+  if (verified_inline_ro_entry_point() >= block_begin) {\n+    low = MIN2(low, verified_inline_ro_entry_point());\n+  }\n+  assert(low != 0, \"sanity\");\n+  if (block_begin == low) {\n+    stream->print(\"  # \");\n+    m->print_value_on(stream);\n+    stream->cr();\n+  }\n+\n+  \/\/ Print the arguments for the 3 types of verified entry points\n+  CompiledEntrySignature ces(m);\n+  ces.compute_calling_conventions(false);\n+  const GrowableArray<SigEntry>* sig_cc;\n+  const VMRegPair* regs;\n+  if (block_begin == verified_entry_point()) {\n+    sig_cc = ces.sig_cc();\n+    regs = ces.regs_cc();\n+  } else if (block_begin == verified_inline_entry_point()) {\n+    sig_cc = ces.sig();\n+    regs = ces.regs();\n+  } else if (block_begin == verified_inline_ro_entry_point()) {\n+    sig_cc = ces.sig_cc_ro();\n+    regs = ces.regs_cc_ro();\n+  } else {\n+    return;\n+  }\n+\n+  bool has_this = !m->is_static();\n+  if (ces.has_inline_recv() && block_begin == verified_entry_point()) {\n+    \/\/ <this> argument is scalarized for verified_entry_point()\n+    has_this = false;\n+  }\n+  const char* spname = \"sp\"; \/\/ make arch-specific?\n+  int stack_slot_offset = this->frame_size() * wordSize;\n+  int tab1 = 14, tab2 = 24;\n+  int sig_index = 0;\n+  int arg_index = has_this ? -1 : 0;\n+  bool did_old_sp = false;\n+  for (ExtendedSignature sig = ExtendedSignature(sig_cc, SigEntryFilter()); !sig.at_end(); ++sig) {\n+    bool at_this = (arg_index == -1);\n+    bool at_old_sp = false;\n+    BasicType t = (*sig)._bt;\n+    if (at_this) {\n+      stream->print(\"  # this: \");\n+    } else {\n+      stream->print(\"  # parm%d: \", arg_index);\n+    }\n+    stream->move_to(tab1);\n+    VMReg fst = regs[sig_index].first();\n+    VMReg snd = regs[sig_index].second();\n+    if (fst->is_reg()) {\n+      stream->print(\"%s\", fst->name());\n+      if (snd->is_valid())  {\n+        stream->print(\":%s\", snd->name());\n@@ -3833,6 +3863,23 @@\n-      if (!did_old_sp) {\n-        stream->print(\"  # \");\n-        stream->move_to(tab1);\n-        stream->print(\"[%s+0x%x]\", spname, stack_slot_offset);\n-        stream->print(\"  (%s of caller)\", spname);\n-        stream->cr();\n+    } else if (fst->is_stack()) {\n+      int offset = fst->reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;\n+      if (offset == stack_slot_offset)  at_old_sp = true;\n+      stream->print(\"[%s+0x%x]\", spname, offset);\n+    } else {\n+      stream->print(\"reg%d:%d??\", (int)(intptr_t)fst, (int)(intptr_t)snd);\n+    }\n+    stream->print(\" \");\n+    stream->move_to(tab2);\n+    stream->print(\"= \");\n+    if (at_this) {\n+      m->method_holder()->print_value_on(stream);\n+    } else {\n+      bool did_name = false;\n+      if (is_reference_type(t)) {\n+        Symbol* name = (*sig)._name;\n+        name->print_value_on(stream);\n+        did_name = true;\n+      }\n+      if (!did_name)\n+        stream->print(\"%s\", type2name(t));\n+      if ((*sig)._null_marker) {\n+        stream->print(\" (null marker)\");\n@@ -3841,0 +3888,14 @@\n+    if (at_old_sp) {\n+      stream->print(\"  (%s of caller)\", spname);\n+      did_old_sp = true;\n+    }\n+    stream->cr();\n+    sig_index += type2size[t];\n+    arg_index += 1;\n+  }\n+  if (!did_old_sp) {\n+    stream->print(\"  # \");\n+    stream->move_to(tab1);\n+    stream->print(\"[%s+0x%x]\", spname, stack_slot_offset);\n+    stream->print(\"  (%s of caller)\", spname);\n+    stream->cr();\n@@ -3964,1 +4025,1 @@\n-      st->print(\" {reexecute=%d rethrow=%d return_oop=%d}\", sd->should_reexecute(), sd->rethrow_exception(), sd->return_oop());\n+      st->print(\" {reexecute=%d rethrow=%d return_oop=%d return_scalarized=%d}\", sd->should_reexecute(), sd->rethrow_exception(), sd->return_oop(), sd->return_scalarized());\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":156,"deletions":95,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"compiler\/compilerDefinitions.hpp\"\n@@ -216,0 +217,4 @@\n+  \/\/ TODO: can these be uint16_t, seem rely on -1 CodeOffset, can change later...\n+  address _inline_entry_point;              \/\/ inline type entry point (unpack all inline type args) with class check\n+  address _verified_inline_entry_point;     \/\/ inline type entry point (unpack all inline type args) without class check\n+  address _verified_inline_ro_entry_point;  \/\/ inline type entry point (unpack receiver only) without class check\n@@ -689,0 +694,3 @@\n+  address inline_entry_point() const              { return _inline_entry_point; }             \/\/ inline type entry point (unpack all inline type args)\n+  address verified_inline_entry_point() const     { return _verified_inline_entry_point; }    \/\/ inline type entry point (unpack all inline type args) without class check\n+  address verified_inline_ro_entry_point() const  { return _verified_inline_ro_entry_point; } \/\/ inline type entry point (only unpack receiver) without class check\n@@ -758,0 +766,10 @@\n+  bool  needs_stack_repair() const {\n+    if (is_compiled_by_c1()) {\n+      return method()->c1_needs_stack_repair();\n+    } else if (is_compiled_by_c2()) {\n+      return method()->c2_needs_stack_repair();\n+    } else {\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1617,1 +1617,1 @@\n-              Deoptimization::reassign_fields(vf->frame_pointer(), &reg_map, objects, realloc_failures, false);\n+              Deoptimization::reassign_fields(vf->frame_pointer(), &reg_map, objects, realloc_failures, false, CHECK_NULL);\n@@ -1868,1 +1868,1 @@\n-  Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);\n+  Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false, THREAD);\n@@ -2196,1 +2196,1 @@\n-    if (m->is_object_initializer()) {\n+    if (m->is_object_constructor()) {\n@@ -2223,1 +2223,1 @@\n-    if (!m->is_object_initializer() && !m->is_static_initializer() && !m->is_overpass()) {\n+    if (!(m->is_object_constructor() || m->is_class_initializer()) && !m->is_overpass()) {\n@@ -2962,1 +2962,5 @@\n-  if (m->is_object_initializer()) {\n+  if (m->is_class_initializer()) {\n+      JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n+          \"Cannot create java.lang.reflect.Method for class initializer\");\n+  }\n+  else if (m->is_object_constructor()) {\n@@ -2964,3 +2968,0 @@\n-  } else if (m->is_static_initializer()) {\n-    JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n-        \"Cannot create java.lang.reflect.Method for class initializer\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1466,2 +1466,1 @@\n-    Klass* byteArrayArrayKlass = TypeArrayKlass::cast(Universe::byteArrayKlass())->array_klass(CHECK_(JVMCIObject()));\n-    objArrayOop result = ObjArrayKlass::cast(byteArrayArrayKlass) ->allocate(length, CHECK_(JVMCIObject()));\n+    objArrayOop result = oopFactory::new_objArray(Universe::byteArrayKlass(), length, CHECK_(JVMCIObject()));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -76,0 +77,2 @@\n+#include \"oops\/inlineKlass.hpp\"\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -152,0 +155,5 @@\n+void InlineLayoutInfo::metaspace_pointers_do(MetaspaceClosure* it) {\n+  log_trace(cds)(\"Iter(InlineFieldInfo): %p\", this);\n+  it->push(&_klass);\n+}\n+\n@@ -173,0 +181,13 @@\n+bool InstanceKlass::field_is_null_free_inline_type(int index) const {\n+  return field(index).field_flags().is_null_free_inline_type();\n+}\n+\n+bool InstanceKlass::is_class_in_loadable_descriptors_attribute(Symbol* name) const {\n+  if (_loadable_descriptors == nullptr) return false;\n+  for (int i = 0; i < _loadable_descriptors->length(); i++) {\n+        Symbol* class_name = _constants->symbol_at(_loadable_descriptors->at(i));\n+        if (class_name == name) return true;\n+  }\n+  return false;\n+}\n+\n@@ -467,1 +488,2 @@\n-                                       parser.is_interface());\n+                                       parser.is_interface(),\n+                                       parser.is_inline_type());\n@@ -490,0 +512,3 @@\n+  } else if (parser.is_inline_type()) {\n+    \/\/ inline type\n+    ik = new (loader_data, size, use_class_space, THREAD) InlineKlass(parser);\n@@ -506,0 +531,6 @@\n+#ifdef ASSERT\n+  ik->bounds_check((address) ik->start_of_vtable(), false, size);\n+  ik->bounds_check((address) ik->start_of_itable(), false, size);\n+  ik->bounds_check((address) ik->end_of_itable(), true, size);\n+  ik->bounds_check((address) ik->end_of_nonstatic_oop_maps(), true, size);\n+#endif \/\/ASSERT\n@@ -509,0 +540,23 @@\n+#ifndef PRODUCT\n+bool InstanceKlass::bounds_check(address addr, bool edge_ok, intptr_t size_in_bytes) const {\n+  const char* bad = nullptr;\n+  address end = nullptr;\n+  if (addr < (address)this) {\n+    bad = \"before\";\n+  } else if (addr == (address)this) {\n+    if (edge_ok)  return true;\n+    bad = \"just before\";\n+  } else if (addr == (end = (address)this + sizeof(intptr_t) * (size_in_bytes < 0 ? size() : size_in_bytes))) {\n+    if (edge_ok)  return true;\n+    bad = \"just after\";\n+  } else if (addr > end) {\n+    bad = \"after\";\n+  } else {\n+    return true;\n+  }\n+  tty->print_cr(\"%s object bounds: \" INTPTR_FORMAT \" [\" INTPTR_FORMAT \"..\" INTPTR_FORMAT \"]\",\n+      bad, (intptr_t)addr, (intptr_t)this, (intptr_t)end);\n+  Verbose = WizardMode = true; this->print(); \/\/@@\n+  return false;\n+}\n+#endif \/\/PRODUCT\n@@ -536,2 +590,2 @@\n-InstanceKlass::InstanceKlass(const ClassFileParser& parser, KlassKind kind, ReferenceType reference_type) :\n-  Klass(kind),\n+InstanceKlass::InstanceKlass(const ClassFileParser& parser, KlassKind kind, markWord prototype_header, ReferenceType reference_type) :\n+  Klass(kind, prototype_header),\n@@ -548,1 +602,4 @@\n-  _init_thread(nullptr)\n+  _init_thread(nullptr),\n+  _inline_layout_info_array(nullptr),\n+  _loadable_descriptors(nullptr),\n+  _adr_inlineklass_fixed_block(nullptr)\n@@ -555,0 +612,3 @@\n+  if (parser.has_inline_fields()) {\n+    set_has_inline_type_fields();\n+  }\n@@ -694,0 +754,5 @@\n+  if (inline_layout_info_array() != nullptr) {\n+    MetadataFactory::free_array<InlineLayoutInfo>(loader_data, inline_layout_info_array());\n+  }\n+  set_inline_layout_info_array(nullptr);\n+\n@@ -728,0 +793,7 @@\n+  if (loadable_descriptors() != nullptr &&\n+      loadable_descriptors() != Universe::the_empty_short_array() &&\n+      !loadable_descriptors()->is_shared()) {\n+    MetadataFactory::free_array<jushort>(loader_data, loadable_descriptors());\n+  }\n+  set_loadable_descriptors(nullptr);\n+\n@@ -967,0 +1039,101 @@\n+\n+  \/\/ If a class declares a method that uses an inline class as an argument\n+  \/\/ type or return inline type, this inline class must be loaded during the\n+  \/\/ linking of this class because size and properties of the inline class\n+  \/\/ must be known in order to be able to perform inline type optimizations.\n+  \/\/ The implementation below is an approximation of this rule, the code\n+  \/\/ iterates over all methods of the current class (including overridden\n+  \/\/ methods), not only the methods declared by this class. This\n+  \/\/ approximation makes the code simpler, and doesn't change the semantic\n+  \/\/ because classes declaring methods overridden by the current class are\n+  \/\/ linked (and have performed their own pre-loading) before the linking\n+  \/\/ of the current class.\n+\n+\n+  \/\/ Note:\n+  \/\/ Inline class types are loaded during\n+  \/\/ the loading phase (see ClassFileParser::post_process_parsed_stream()).\n+  \/\/ Inline class types used as element types for array creation\n+  \/\/ are not pre-loaded. Their loading is triggered by either anewarray\n+  \/\/ or multianewarray bytecodes.\n+\n+  \/\/ Could it be possible to do the following processing only if the\n+  \/\/ class uses inline types?\n+  if (EnableValhalla) {\n+    ResourceMark rm(THREAD);\n+    for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+      if (fs.is_null_free_inline_type() && fs.access_flags().is_static()) {\n+        assert(fs.access_flags().is_strict(), \"null-free fields must be strict\");\n+        Symbol* sig = fs.signature();\n+        TempNewSymbol s = Signature::strip_envelope(sig);\n+        if (s != name()) {\n+          log_info(class, preload)(\"Preloading class %s during linking of class %s. Cause: a null-free static field is declared with this type\", s->as_C_string(), name()->as_C_string());\n+          Klass* klass = SystemDictionary::resolve_or_fail(s,\n+                                                          Handle(THREAD, class_loader()), true,\n+                                                          CHECK_false);\n+          if (HAS_PENDING_EXCEPTION) {\n+            log_warning(class, preload)(\"Preloading of class %s during linking of class %s (cause: null-free static field) failed: %s\",\n+                                      s->as_C_string(), name()->as_C_string(), PENDING_EXCEPTION->klass()->name()->as_C_string());\n+            return false; \/\/ Exception is still pending\n+          }\n+          log_info(class, preload)(\"Preloading of class %s during linking of class %s (cause: null-free static field) succeeded\",\n+                                   s->as_C_string(), name()->as_C_string());\n+          assert(klass != nullptr, \"Sanity check\");\n+          if (klass->is_abstract()) {\n+            THROW_MSG_(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                      err_msg(\"Class %s expects class %s to be concrete value class, but it is an abstract class\",\n+                      name()->as_C_string(),\n+                      InstanceKlass::cast(klass)->external_name()), false);\n+          }\n+          if (!klass->is_inline_klass()) {\n+            THROW_MSG_(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                       err_msg(\"class %s expects class %s to be a value class but it is an identity class\",\n+                       name()->as_C_string(), klass->external_name()), false);\n+          }\n+          InlineKlass* vk = InlineKlass::cast(klass);\n+          \/\/ the inline_type_field_klasses_array might have been loaded with CDS, so update only if not already set and check consistency\n+          InlineLayoutInfo* li = inline_layout_info_adr(fs.index());\n+          if (li->klass() == nullptr) {\n+            li->set_klass(InlineKlass::cast(vk));\n+            li->set_kind(LayoutKind::REFERENCE);\n+          }\n+          assert(get_inline_type_field_klass(fs.index()) == vk, \"Must match\");\n+        } else {\n+          InlineLayoutInfo* li = inline_layout_info_adr(fs.index());\n+          if (li->klass() == nullptr) {\n+            li->set_klass(InlineKlass::cast(this));\n+            li->set_kind(LayoutKind::REFERENCE);\n+          }\n+          assert(get_inline_type_field_klass(fs.index()) == this, \"Must match\");\n+        }\n+      }\n+    }\n+\n+    \/\/ Aggressively preloading all classes from the LoadableDescriptors attribute\n+    if (loadable_descriptors() != nullptr) {\n+      HandleMark hm(THREAD);\n+      for (int i = 0; i < loadable_descriptors()->length(); i++) {\n+        Symbol* sig = constants()->symbol_at(loadable_descriptors()->at(i));\n+        if (!Signature::has_envelope(sig)) continue;\n+        TempNewSymbol class_name = Signature::strip_envelope(sig);\n+        if (class_name == name()) continue;\n+        log_info(class, preload)(\"Preloading class %s during linking of class %s because of the class is listed in the LoadableDescriptors attribute\", sig->as_C_string(), name()->as_C_string());\n+        oop loader = class_loader();\n+        Klass* klass = SystemDictionary::resolve_or_null(class_name,\n+                                                         Handle(THREAD, loader), THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION;\n+        }\n+        if (klass != nullptr) {\n+          log_info(class, preload)(\"Preloading of class %s during linking of class %s (cause: LoadableDescriptors attribute) succeeded\", class_name->as_C_string(), name()->as_C_string());\n+          if (!klass->is_inline_klass()) {\n+            \/\/ Non value class are allowed by the current spec, but it could be an indication of an issue so let's log a warning\n+              log_warning(class, preload)(\"Preloading class %s during linking of class %s (cause: LoadableDescriptors attribute) but loaded class is not a value class\", class_name->as_C_string(), name()->as_C_string());\n+          }\n+        } else {\n+          log_warning(class, preload)(\"Preloading of class %s during linking of class %s (cause: LoadableDescriptors attribute) failed\", class_name->as_C_string(), name()->as_C_string());\n+        }\n+      }\n+    }\n+  }\n+\n@@ -1271,0 +1444,21 @@\n+  \/\/ Pre-allocating an all-zero value to be used to reset nullable flat storages\n+  if (is_inline_klass()) {\n+      InlineKlass* vk = InlineKlass::cast(this);\n+      if (vk->has_nullable_atomic_layout()) {\n+        oop val = vk->allocate_instance(THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+            Handle e(THREAD, PENDING_EXCEPTION);\n+            CLEAR_PENDING_EXCEPTION;\n+            {\n+                EXCEPTION_MARK;\n+                add_initialization_error(THREAD, e);\n+                \/\/ Locks object, set state, and notify all waiting threads\n+                set_initialization_state_and_notify(initialization_error, THREAD);\n+                CLEAR_PENDING_EXCEPTION;\n+            }\n+            THROW_OOP(e());\n+        }\n+        vk->set_null_reset_value(val);\n+      }\n+  }\n+\n@@ -1303,1 +1497,0 @@\n-\n@@ -1324,0 +1517,30 @@\n+\n+    if (has_strict_static_fields() && !HAS_PENDING_EXCEPTION) {\n+      \/\/ Step 9 also verifies that strict static fields have been initialized.\n+      \/\/ Status bits were set in ClassFileParser::post_process_parsed_stream.\n+      \/\/ After <clinit>, bits must all be clear, or else we must throw an error.\n+      \/\/ This is an extremely fast check, so we won't bother with a timer.\n+      assert(fields_status() != nullptr, \"\");\n+      Symbol* bad_strict_static = nullptr;\n+      for (int index = 0; index < fields_status()->length(); index++) {\n+        \/\/ Very fast loop over single byte array looking for a set bit.\n+        if (fields_status()->adr_at(index)->is_strict_static_unset()) {\n+          \/\/ This strict static field has not been set by the class initializer.\n+          \/\/ Note that in the common no-error case, we read no field metadata.\n+          \/\/ We only unpack it when we need to report an error.\n+          FieldInfo fi = field(index);\n+          bad_strict_static = fi.name(constants());\n+          if (debug_logging_enabled) {\n+            ResourceMark rm(jt);\n+            const char* msg = format_strict_static_message(bad_strict_static);\n+            log_debug(class, init)(\"%s\", msg);\n+          } else {\n+            \/\/ If we are not logging, do not bother to look for a second offense.\n+            break;\n+          }\n+        }\n+      }\n+      if (bad_strict_static != nullptr) {\n+        throw_strict_static_exception(bad_strict_static, \"is unset after initialization of\", THREAD);\n+      }\n+    }\n@@ -1377,0 +1600,68 @@\n+void InstanceKlass::notify_strict_static_access(int field_index, bool is_writing, TRAPS) {\n+  guarantee(field_index >= 0 && field_index < fields_status()->length(), \"valid field index\");\n+  DEBUG_ONLY(FieldInfo debugfi = field(field_index));\n+  assert(debugfi.access_flags().is_strict(), \"\");\n+  assert(debugfi.access_flags().is_static(), \"\");\n+  FieldStatus& fs = *fields_status()->adr_at(field_index);\n+  LogTarget(Trace, class, init) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm(THREAD);\n+    LogStream ls(lt);\n+    FieldInfo fi = field(field_index);\n+    ls.print(\"notify %s %s %s%s \",\n+             external_name(), is_writing? \"Write\" : \"Read\",\n+             fs.is_strict_static_unset() ? \"Unset\" : \"(set)\",\n+             fs.is_strict_static_unread() ? \"+Unread\" : \"\");\n+    fi.print(&ls, constants());\n+  }\n+  if (fs.is_strict_static_unset()) {\n+    assert(fs.is_strict_static_unread(), \"ClassFileParser resp.\");\n+    \/\/ If it is not set, there are only two reasonable things we can do here:\n+    \/\/ - mark it set if this is putstatic\n+    \/\/ - throw an error (Read-Before-Write) if this is getstatic\n+\n+    \/\/ The unset state is (or should be) transient, and observable only in one\n+    \/\/ thread during the execution of <clinit>.  Something is wrong here as this\n+    \/\/ should not be possible\n+    guarantee(is_reentrant_initialization(THREAD), \"unscoped access to strict static\");\n+    if (is_writing) {\n+      \/\/ clear the \"unset\" bit, since the field is actually going to be written\n+      fs.update_strict_static_unset(false);\n+    } else {\n+      \/\/ throw an IllegalStateException, since we are reading before writing\n+      \/\/ see also InstanceKlass::initialize_impl, Step 8 (at end)\n+      Symbol* bad_strict_static = field(field_index).name(constants());\n+      throw_strict_static_exception(bad_strict_static, \"is unset before first read in\", CHECK);\n+    }\n+  } else {\n+    \/\/ Ensure no write after read for final strict statics\n+    FieldInfo fi = field(field_index);\n+    bool is_final = fi.access_flags().is_final();\n+    if (is_final) {\n+      \/\/ no final write after read, so observing a constant freezes it, as if <clinit> ended early\n+      \/\/ (maybe we could trust the constant a little earlier, before <clinit> ends)\n+      if (is_writing && !fs.is_strict_static_unread()) {\n+        Symbol* bad_strict_static = fi.name(constants());\n+        throw_strict_static_exception(bad_strict_static, \"is set after read (as final) in\", CHECK);\n+      } else if (!is_writing && fs.is_strict_static_unread()) {\n+        fs.update_strict_static_unread(false);\n+      }\n+    }\n+  }\n+}\n+\n+void InstanceKlass::throw_strict_static_exception(Symbol* field_name, const char* when, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  const char* msg = format_strict_static_message(field_name, when);\n+  THROW_MSG(vmSymbols::java_lang_IllegalStateException(), msg);\n+}\n+\n+const char* InstanceKlass::format_strict_static_message(Symbol* field_name, const char* when) {\n+  stringStream ss;\n+  ss.print(\"Strict static \\\"%s\\\" %s %s\",\n+           field_name->as_C_string(),\n+           when == nullptr ? \"is unset in\" : when,\n+           external_name());\n+  return ss.as_string();\n+}\n+\n@@ -1560,7 +1851,3 @@\n-objArrayOop InstanceKlass::allocate_objArray(int n, int length, TRAPS) {\n-  check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);\n-  size_t size = objArrayOopDesc::object_size(length);\n-  ArrayKlass* ak = array_klass(n, CHECK_NULL);\n-  objArrayOop o = (objArrayOop)Universe::heap()->array_allocate(ak, size, length,\n-                                                                \/* do_zero *\/ true, CHECK_NULL);\n-  return o;\n+objArrayOop InstanceKlass::allocate_objArray(int length, ArrayKlass::ArrayProperties props, TRAPS) {\n+  ArrayKlass* ak = array_klass(CHECK_NULL);\n+  return ObjArrayKlass::cast(ak)->allocate_instance(length, props, CHECK_NULL);\n@@ -1636,1 +1923,1 @@\n-  ObjArrayKlass* ak = array_klasses();\n+  ArrayKlass* ak = array_klasses();\n@@ -1643,2 +1930,2 @@\n-  ObjArrayKlass* oak = array_klasses_acquire();\n-  if (oak == nullptr) {\n+  ArrayKlass* ak = array_klasses_acquire();\n+  if (ak == nullptr) {\n@@ -1647,1 +1934,1 @@\n-    return oak->array_klass_or_null(n);\n+    return ak->array_klass_or_null(n);\n@@ -1664,1 +1951,1 @@\n-  if (clinit != nullptr && clinit->has_valid_initializer_flags()) {\n+  if (clinit != nullptr && clinit->is_class_initializer()) {\n@@ -1773,4 +2060,0 @@\n-bool InstanceKlass::contains_field_offset(int offset) {\n-  fieldDescriptor fd;\n-  return find_field_from_offset(offset, false, &fd);\n-}\n@@ -1858,0 +2141,9 @@\n+bool InstanceKlass::contains_field_offset(int offset) {\n+  if (this->is_inline_klass()) {\n+    InlineKlass* vk = InlineKlass::cast(this);\n+    return offset >= vk->payload_offset() && offset < (vk->payload_offset() + vk->payload_size_in_bytes());\n+  } else {\n+    fieldDescriptor fd;\n+    return find_field_from_offset(offset, false, &fd);\n+  }\n+}\n@@ -2241,0 +2533,3 @@\n+    if (name == vmSymbols::object_initializer_name()) {\n+      break;  \/\/ <init> is never inherited\n+    }\n@@ -2639,0 +2934,1 @@\n+  it->push(&_loadable_descriptors);\n@@ -2640,0 +2936,1 @@\n+  it->push(&_inline_layout_info_array, MetaspaceClosure::_writable);\n@@ -2687,1 +2984,1 @@\n-  \/\/ These are not allocated from metaspace. They are safe to set to null.\n+  \/\/ These are not allocated from metaspace. They are safe to set to nullptr.\n@@ -2776,0 +3073,4 @@\n+  if (is_inline_klass()) {\n+    InlineKlass::cast(this)->initialize_calling_convention(CHECK);\n+  }\n+\n@@ -2809,1 +3110,1 @@\n-    assert(this == array_klasses()->bottom_klass(), \"sanity\");\n+    assert(this == ObjArrayKlass::cast(array_klasses())->bottom_klass(), \"sanity\");\n@@ -2812,0 +3113,6 @@\n+    if (class_loader_data() == nullptr) {\n+      ResourceMark rm(THREAD);\n+      log_debug(cds)(\"  loader_data %s \", loader_data == nullptr ? \"nullptr\" : \"non null\");\n+      log_debug(cds)(\"  this %s array_klasses %s \", this->name()->as_C_string(), array_klasses()->name()->as_C_string());\n+    }\n+    assert(!array_klasses()->is_refined_objArray_klass(), \"must be non-refined objarrayklass\");\n@@ -2963,0 +3270,4 @@\n+bool InstanceKlass::supports_inline_types() const {\n+  return major_version() >= Verifier::VALUE_TYPES_MAJOR_VERSION && minor_version() == Verifier::JAVA_PREVIEW_MINOR_VERSION;\n+}\n+\n@@ -2995,0 +3306,2 @@\n+  return signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n+}\n@@ -2996,0 +3309,1 @@\n+const char* InstanceKlass::signature_name_of_carrier(char c) const {\n@@ -3002,1 +3316,1 @@\n-  \/\/ Add L as type indicator\n+  \/\/ Add L or Q as type indicator\n@@ -3004,1 +3318,1 @@\n-  dest[dest_index++] = JVM_SIGNATURE_CLASS;\n+  dest[dest_index++] = c;\n@@ -3285,0 +3599,19 @@\n+void InstanceKlass::check_can_be_annotated_with_NullRestricted(InstanceKlass* type, Symbol* container_klass_name, TRAPS) {\n+  assert(type->is_instance_klass(), \"Sanity check\");\n+  if (type->is_identity_class()) {\n+    ResourceMark rm(THREAD);\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+              err_msg(\"Class %s expects class %s to be a value class, but it is an identity class\",\n+              container_klass_name->as_C_string(),\n+              type->external_name()));\n+  }\n+\n+  if (type->is_abstract()) {\n+    ResourceMark rm(THREAD);\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+              err_msg(\"Class %s expects class %s to be concrete value type, but it is an abstract class\",\n+              container_klass_name->as_C_string(),\n+              type->external_name()));\n+  }\n+}\n+\n@@ -3351,2 +3684,1 @@\n-  \/\/ Remember to strip ACC_SUPER bit\n-  return (access & (~JVM_ACC_SUPER));\n+  return access;\n@@ -3606,1 +3938,4 @@\n-static void print_vtable(intptr_t* start, int len, outputStream* st) {\n+static void print_vtable(address self, intptr_t* start, int len, outputStream* st) {\n+  ResourceMark rm;\n+  int* forward_refs = NEW_RESOURCE_ARRAY(int, len);\n+  for (int i = 0; i < len; i++)  forward_refs[i] = 0;\n@@ -3610,0 +3945,5 @@\n+    if (forward_refs[i] != 0) {\n+      int from = forward_refs[i];\n+      int off = (int) start[from];\n+      st->print(\" (offset %d <= [%d])\", off, from);\n+    }\n@@ -3613,0 +3953,6 @@\n+    } else if (self != nullptr && e > 0 && e < 0x10000) {\n+      address location = self + e;\n+      int index = (int)((intptr_t*)location - start);\n+      st->print(\" (offset %d => [%d])\", (int)e, index);\n+      if (index >= 0 && index < len)\n+        forward_refs[index] = i;\n@@ -3619,1 +3965,22 @@\n-  return print_vtable(reinterpret_cast<intptr_t*>(start), len, st);\n+  return print_vtable(nullptr, reinterpret_cast<intptr_t*>(start), len, st);\n+}\n+\n+template<typename T>\n+ static void print_array_on(outputStream* st, Array<T>* array) {\n+   if (array == nullptr) { st->print_cr(\"nullptr\"); return; }\n+   array->print_value_on(st); st->cr();\n+   if (Verbose || WizardMode) {\n+     for (int i = 0; i < array->length(); i++) {\n+       st->print(\"%d : \", i); array->at(i)->print_value_on(st); st->cr();\n+     }\n+   }\n+ }\n+\n+static void print_array_on(outputStream* st, Array<int>* array) {\n+  if (array == nullptr) { st->print_cr(\"nullptr\"); return; }\n+  array->print_value_on(st); st->cr();\n+  if (Verbose || WizardMode) {\n+    for (int i = 0; i < array->length(); i++) {\n+      st->print(\"%d : %d\", i, array->at(i)); st->cr();\n+    }\n+  }\n@@ -3660,8 +4027,2 @@\n-  st->print(BULLET\"methods:           \"); methods()->print_value_on(st);               st->cr();\n-  if (Verbose || WizardMode) {\n-    Array<Method*>* method_array = methods();\n-    for (int i = 0; i < method_array->length(); i++) {\n-      st->print(\"%d : \", i); method_array->at(i)->print_value(); st->cr();\n-    }\n-  }\n-  st->print(BULLET\"method ordering:   \"); method_ordering()->print_value_on(st);      st->cr();\n+  st->print(BULLET\"methods:           \"); print_array_on(st, methods());\n+  st->print(BULLET\"method ordering:   \"); print_array_on(st, method_ordering());\n@@ -3669,7 +4030,1 @@\n-    st->print(BULLET\"default_methods:   \"); default_methods()->print_value_on(st);    st->cr();\n-    if (Verbose) {\n-      Array<Method*>* method_array = default_methods();\n-      for (int i = 0; i < method_array->length(); i++) {\n-        st->print(\"%d : \", i); method_array->at(i)->print_value(); st->cr();\n-      }\n-    }\n+    st->print(BULLET\"default_methods:   \"); print_array_on(st, default_methods());\n@@ -3735,0 +4090,1 @@\n+  st->print(BULLET\"loadable descriptors:     \"); loadable_descriptors()->print_value_on(st); st->cr();\n@@ -3745,1 +4101,1 @@\n-  if (itable_length() > 0 && (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);\n+  if (itable_length() > 0 && (Verbose || WizardMode))  print_vtable(nullptr, start_of_itable(), itable_length(), st);\n@@ -3772,0 +4128,1 @@\n+  for (int i = 0; i < _indent; i++) _st->print(\"  \");\n@@ -3774,1 +4131,1 @@\n-     fd->print_on(_st);\n+     fd->print_on(_st, _base_offset);\n@@ -3777,2 +4134,2 @@\n-     fd->print_on_for(_st, _obj);\n-     _st->cr();\n+     fd->print_on_for(_st, _obj, _indent, _base_offset);\n+     if (!fd->field_flags().is_flat()) _st->cr();\n@@ -3783,1 +4140,1 @@\n-void InstanceKlass::oop_print_on(oop obj, outputStream* st) {\n+void InstanceKlass::oop_print_on(oop obj, outputStream* st, int indent, int base_offset) {\n@@ -3799,1 +4156,1 @@\n-  FieldPrinter print_field(st, obj);\n+  FieldPrinter print_field(st, obj, indent, base_offset);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":407,"deletions":50,"binary":false,"changes":457,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -124,1 +125,0 @@\n-\n@@ -163,0 +163,5 @@\n+address Method::get_c2i_inline_entry() {\n+  assert(adapter() != nullptr, \"must have\");\n+  return adapter()->get_c2i_inline_entry();\n+}\n+\n@@ -168,0 +173,5 @@\n+address Method::get_c2i_unverified_inline_entry() {\n+  assert(adapter() != nullptr, \"must have\");\n+  return adapter()->get_c2i_unverified_inline_entry();\n+}\n+\n@@ -393,1 +403,1 @@\n-  if (!method_holder()->is_rewritten()) {\n+  if (!method_holder()->is_rewritten() || CDSConfig::is_valhalla_preview()) {\n@@ -436,0 +446,2 @@\n+    _from_compiled_inline_entry = _adapter->get_c2i_inline_entry();\n+    _from_compiled_inline_ro_entry = _adapter->get_c2i_inline_ro_entry();\n@@ -725,0 +737,16 @@\n+\/\/ InlineKlass the method is declared to return. This must not\n+\/\/ safepoint as it is called with references live on the stack at\n+\/\/ locations the GC is unaware of.\n+InlineKlass* Method::returns_inline_type(Thread* thread) const {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  if (is_native()) {\n+    return nullptr;\n+  }\n+  NoSafepointVerifier nsv;\n+  SignatureStream ss(signature());\n+  while (!ss.at_return_type()) {\n+    ss.next();\n+  }\n+  return ss.as_inline_klass(method_holder());\n+}\n+\n@@ -873,0 +901,5 @@\n+  if (has_scalarized_return()) {\n+    \/\/ Don't treat this as (trivial) getter method because the\n+    \/\/ inline type should be returned in a scalarized form.\n+    return false;\n+  }\n@@ -894,0 +927,5 @@\n+  if (has_scalarized_args()) {\n+    \/\/ Don't treat this as (trivial) setter method because the\n+    \/\/ inline type argument should be passed in a scalarized form.\n+    return false;\n+  }\n@@ -904,1 +942,2 @@\n-          Bytecodes::is_return(java_code_at(last_index)));\n+          Bytecodes::is_return(java_code_at(last_index)) &&\n+          !has_scalarized_args());\n@@ -907,6 +946,1 @@\n-bool Method::has_valid_initializer_flags() const {\n-  return (is_static() ||\n-          method_holder()->major_version() < 51);\n-}\n-\n-bool Method::is_static_initializer() const {\n+bool Method::is_class_initializer() const {\n@@ -916,2 +950,3 @@\n-  return name() == vmSymbols::class_initializer_name() &&\n-         has_valid_initializer_flags();\n+  return (name() == vmSymbols::class_initializer_name() &&\n+          (is_static() ||\n+           method_holder()->major_version() < 51));\n@@ -920,2 +955,3 @@\n-bool Method::is_object_initializer() const {\n-   return name() == vmSymbols::object_initializer_name();\n+\/\/ A method named <init>, is a classic object constructor.\n+bool Method::is_object_constructor() const {\n+  return name() == vmSymbols::object_initializer_name();\n@@ -984,1 +1020,1 @@\n-  if( constants()->tag_at(klass_index).is_unresolved_klass() ) {\n+  if( constants()->tag_at(klass_index).is_unresolved_klass()) {\n@@ -999,1 +1035,3 @@\n-    if (constants()->tag_at(klass_index).is_unresolved_klass()) return false;\n+    if (constants()->tag_at(klass_index).is_unresolved_klass()) {\n+      return false;\n+    }\n@@ -1168,0 +1206,2 @@\n+    _from_compiled_inline_entry = nullptr;\n+    _from_compiled_inline_ro_entry = nullptr;\n@@ -1170,0 +1210,2 @@\n+    _from_compiled_inline_entry = adapter()->get_c2i_inline_entry();\n+    _from_compiled_inline_ro_entry = adapter()->get_c2i_inline_ro_entry();\n@@ -1203,0 +1245,2 @@\n+  _from_compiled_inline_entry = nullptr;\n+  _from_compiled_inline_ro_entry = nullptr;\n@@ -1234,0 +1278,2 @@\n+  set_has_scalarized_args(false);\n+  set_has_scalarized_return(false);\n@@ -1270,0 +1316,3 @@\n+  if (InlineTypeReturnedAsFields && returns_inline_type(THREAD) && !has_scalarized_return()) {\n+    set_has_scalarized_return();\n+  }\n@@ -1321,0 +1370,2 @@\n+  mh->_from_compiled_inline_entry = adapter->get_c2i_inline_entry();\n+  mh->_from_compiled_inline_ro_entry = adapter->get_c2i_inline_ro_entry();\n@@ -1337,0 +1388,12 @@\n+address Method::verified_inline_code_entry() {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(_from_compiled_inline_entry != nullptr, \"must be set\");\n+  return _from_compiled_inline_entry;\n+}\n+\n+address Method::verified_inline_ro_code_entry() {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(_from_compiled_inline_ro_entry != nullptr, \"must be set\");\n+  return _from_compiled_inline_ro_entry;\n+}\n+\n@@ -1368,0 +1431,2 @@\n+  mh->_from_compiled_inline_entry = code->verified_inline_entry_point();\n+  mh->_from_compiled_inline_ro_entry = code->verified_inline_ro_entry_point();\n@@ -1560,0 +1625,2 @@\n+    m->set_from_compiled_inline_entry(m->adapter()->get_c2i_inline_entry());\n+    m->set_from_compiled_inline_ro_entry(m->adapter()->get_c2i_inline_ro_entry());\n@@ -2326,0 +2393,25 @@\n+bool Method::is_scalarized_arg(int idx) const {\n+  if (!has_scalarized_args()) {\n+    return false;\n+  }\n+  \/\/ Search through signature and check if argument is wrapped in T_METADATA\/T_VOID\n+  int depth = 0;\n+  const GrowableArray<SigEntry>* sig = adapter()->get_sig_cc();\n+  for (int i = 0; i < sig->length(); i++) {\n+    BasicType bt = sig->at(i)._bt;\n+    if (bt == T_METADATA) {\n+      depth++;\n+    }\n+    if (idx == 0) {\n+      break; \/\/ Argument found\n+    }\n+    if (bt == T_VOID && (sig->at(i-1)._bt != T_LONG && sig->at(i-1)._bt != T_DOUBLE)) {\n+      depth--;\n+    }\n+    if (depth == 0 && bt != T_LONG && bt != T_DOUBLE) {\n+      idx--; \/\/ Advance to next argument\n+    }\n+  }\n+  return depth != 0;\n+}\n+\n@@ -2358,0 +2450,4 @@\n+#ifdef ASSERT\n+  if (valid_itable_index())\n+    st->print_cr(\" - itable index:      %d\",   itable_index());\n+#endif\n@@ -2365,1 +2461,3 @@\n-  st->print_cr(\" - compiled entry     \" PTR_FORMAT, p2i(from_compiled_entry()));\n+  st->print_cr(\" - compiled entry           \" PTR_FORMAT, p2i(from_compiled_entry()));\n+  st->print_cr(\" - compiled inline entry    \" PTR_FORMAT, p2i(from_compiled_inline_entry()));\n+  st->print_cr(\" - compiled inline ro entry \" PTR_FORMAT, p2i(from_compiled_inline_ro_entry()));\n@@ -2435,0 +2533,1 @@\n+  if (WizardMode) access_flags().print_on(st);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":115,"deletions":16,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n@@ -61,0 +62,1 @@\n+#include \"oops\/access.hpp\"\n@@ -63,0 +65,1 @@\n+#include \"oops\/compressedOops.inline.hpp\"\n@@ -70,0 +73,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -88,0 +92,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -1950,0 +1955,103 @@\n+WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))\n+  oop aoop = JNIHandles::resolve(thing);\n+  if (!aoop->is_instance()) {\n+    return nullptr;\n+  }\n+  instanceHandle ih(THREAD, (instanceOop) aoop);\n+  InstanceKlass* klass = InstanceKlass::cast(ih->klass());\n+  if (klass->nonstatic_oop_map_count() == 0) {\n+    return nullptr;\n+  }\n+  const OopMapBlock* map = klass->start_of_nonstatic_oop_maps();\n+  const OopMapBlock* const end = map + klass->nonstatic_oop_map_count();\n+  int oop_count = 0;\n+  while (map < end) {\n+    oop_count += map->count();\n+    map++;\n+  }\n+\n+  objArrayHandle result_array =\n+      oopFactory::new_objArray_handle(vmClasses::Object_klass(), oop_count, CHECK_NULL);\n+  map = klass->start_of_nonstatic_oop_maps();\n+  int index = 0;\n+  while (map < end) {\n+    int offset = map->offset();\n+    for (unsigned int j = 0; j < map->count(); j++) {\n+      result_array->obj_at_put(index++, ih->obj_field(offset));\n+      offset += heapOopSize;\n+    }\n+    map++;\n+  }\n+  return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+WB_END\n+\n+\/\/ Collect Object oops but not value objects...loaded from heap\n+class CollectObjectOops : public BasicOopIterateClosure {\n+  public:\n+  GrowableArray<Handle>* _array;\n+\n+  CollectObjectOops() {\n+      _array = new GrowableArray<Handle>(128);\n+  }\n+\n+  void add_oop(oop o) {\n+    Handle oh = Handle(Thread::current(), o);\n+    if (oh != nullptr && oh->is_inline_type()) {\n+      oh->oop_iterate(this);\n+    } else {\n+      _array->append(oh);\n+    }\n+  }\n+\n+  template <class T> inline void add_oop(T* p) { add_oop(HeapAccess<>::oop_load(p)); }\n+  void do_oop(oop* o) { add_oop(o); }\n+  void do_oop(narrowOop* v) { add_oop(v); }\n+\n+  jobjectArray create_jni_result(JNIEnv* env, TRAPS) {\n+    objArrayHandle result_array =\n+        oopFactory::new_objArray_handle(vmClasses::Object_klass(), _array->length(), CHECK_NULL);\n+    for (int i = 0 ; i < _array->length(); i++) {\n+      result_array->obj_at_put(i, _array->at(i)());\n+    }\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+  }\n+};\n+\n+\/\/ Collect Object oops but not value objects...loaded from frames\n+class CollectFrameObjectOops : public BasicOopIterateClosure {\n+ public:\n+  CollectObjectOops _collect;\n+\n+  template <class T> inline void add_oop(T* p) { _collect.add_oop(RawAccess<>::oop_load(p)); }\n+  void do_oop(oop* o) { add_oop(o); }\n+  void do_oop(narrowOop* v) { add_oop(v); }\n+\n+  jobjectArray create_jni_result(JNIEnv* env, TRAPS) {\n+    return _collect.create_jni_result(env, THREAD);\n+  }\n+};\n+\n+\/\/ Collect Object oops for the given oop, iterate through value objects\n+WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))\n+  ResourceMark rm(thread);\n+  Handle objh(thread, JNIHandles::resolve(thing));\n+  CollectObjectOops collectOops;\n+  objh->oop_iterate(&collectOops);\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n+\/\/ Collect Object oops for the given frame deep, iterate through value objects\n+WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))\n+  KeepStackGCProcessedMark ksgcpm(THREAD);\n+  ResourceMark rm(THREAD);\n+  CollectFrameObjectOops collectOops;\n+  StackFrameStream sfs(thread, true \/* update *\/, true \/* process_frames *\/);\n+  while (depth > 0) { \/\/ Skip the native WB API frame\n+    sfs.next();\n+    frame* f = sfs.current();\n+    f->oops_do(&collectOops, nullptr, sfs.register_map());\n+    depth--;\n+  }\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n@@ -2918,0 +3026,6 @@\n+  {CC\"getObjectsViaKlassOopMaps0\",\n+      CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",    (void*)&WB_getObjectsViaKlassOopMaps},\n+  {CC\"getObjectsViaOopIterator0\",\n+          CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",(void*)&WB_getObjectsViaOopIterator},\n+  {CC\"getObjectsViaFrameOopIterator\",\n+      CC\"(I)[Ljava\/lang\/Object;\",                     (void*)&WB_getObjectsViaFrameOopIterator},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.hpp\"\n@@ -58,0 +60,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -354,2 +357,13 @@\n-  bool save_oop_result = chunk->at(0)->scope()->return_oop() && !thread->popframe_forcing_deopt_reexecution() && (exec_mode == Deoptimization::Unpack_deopt);\n-  Handle return_value;\n+  ScopeDesc* scope = chunk->at(0)->scope();\n+  bool save_oop_result = scope->return_oop() && !thread->popframe_forcing_deopt_reexecution() && (exec_mode == Deoptimization::Unpack_deopt);\n+  \/\/ In case of the return of multiple values, we must take care\n+  \/\/ of all oop return values.\n+  GrowableArray<Handle> return_oops;\n+  InlineKlass* vk = nullptr;\n+  if (save_oop_result && scope->return_scalarized()) {\n+    vk = InlineKlass::returned_inline_klass(map);\n+    if (vk != nullptr) {\n+      vk->save_oop_fields(map, return_oops);\n+      save_oop_result = false;\n+    }\n+  }\n@@ -361,1 +375,1 @@\n-    return_value = Handle(thread, result);\n+    return_oops.push(Handle(thread, result));\n@@ -368,1 +382,1 @@\n-  if (objects != nullptr) {\n+  if (objects != nullptr || vk != nullptr) {\n@@ -373,1 +387,9 @@\n-      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, CHECK_AND_CLEAR_(true));\n+      if (vk != nullptr) {\n+        realloc_failures = Deoptimization::realloc_inline_type_result(vk, map, return_oops, CHECK_AND_CLEAR_(true));\n+      }\n+      if (objects != nullptr) {\n+        realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &deoptee, &map, objects, CHECK_AND_CLEAR_(true));\n+        guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n+        bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci, CHECK_AND_CLEAR_(true));\n+      }\n@@ -378,1 +400,9 @@\n-      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, THREAD);\n+      if (vk != nullptr) {\n+        realloc_failures = Deoptimization::realloc_inline_type_result(vk, map, return_oops, THREAD);\n+      }\n+      if (objects != nullptr) {\n+        realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &deoptee, &map, objects, THREAD);\n+        guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n+        bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci, THREAD);\n+      }\n@@ -381,4 +411,1 @@\n-    guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n-    bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n-    Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci);\n-    if (TraceDeoptimization) {\n+    if (TraceDeoptimization && objects != nullptr) {\n@@ -388,1 +415,1 @@\n-  if (save_oop_result) {\n+  if (save_oop_result || vk != nullptr) {\n@@ -390,1 +417,2 @@\n-    deoptee.set_saved_oop_result(&map, return_value());\n+    assert(return_oops.length() == 1, \"no inline type\");\n+    deoptee.set_saved_oop_result(&map, return_oops.pop()());\n@@ -725,1 +753,1 @@\n-  \/\/ If the sender is deoptimized the we must retrieve the address of the handler\n+  \/\/ If the sender is deoptimized we must retrieve the address of the handler\n@@ -1241,2 +1269,22 @@\n-\n-    oop obj = nullptr;\n+    \/\/ If it's an array, get the properties\n+    if (k->is_array_klass() && !k->is_typeArray_klass()) {\n+      assert(!k->is_refArray_klass() && !k->is_flatArray_klass(), \"Unexpected refined klass\");\n+      nmethod* nm = fr->cb()->as_nmethod_or_null();\n+      if (nm->is_compiled_by_c2()) {\n+        assert(sv->has_properties(), \"Property information is missing\");\n+        ArrayKlass::ArrayProperties props = static_cast<ArrayKlass::ArrayProperties>(StackValue::create_stack_value(fr, reg_map, sv->properties())->get_jint());\n+        k = ObjArrayKlass::cast(k)->klass_with_properties(props, THREAD);\n+      } else {\n+        \/\/ TODO Graal needs to be fixed. Just go with the default properties for now\n+        k = ObjArrayKlass::cast(k)->klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+      }\n+    }\n+\n+    \/\/ Check if the object may be null and has an additional null_marker input that needs\n+    \/\/ to be checked before using the field values. Skip re-allocation if it is null.\n+    if (k->is_inline_klass() && sv->has_properties()) {\n+      jint null_marker = StackValue::create_stack_value(fr, reg_map, sv->properties())->get_jint();\n+      if (null_marker == 0) {\n+        continue;\n+      }\n+    }\n@@ -1245,0 +1293,1 @@\n+    oop obj = nullptr;\n@@ -1272,0 +1321,4 @@\n+    } else if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* ak = FlatArrayKlass::cast(k);\n+      \/\/ Inline type array must be zeroed because not all memory is reassigned\n+      obj = ak->allocate_instance(sv->field_size(), ak->properties(), THREAD);\n@@ -1278,2 +1331,2 @@\n-    } else if (k->is_objArray_klass()) {\n-      ObjArrayKlass* ak = ObjArrayKlass::cast(k);\n+    } else if (k->is_refArray_klass()) {\n+      RefArrayKlass* ak = RefArrayKlass::cast(k);\n@@ -1281,1 +1334,1 @@\n-      obj = ak->allocate(sv->field_size(), THREAD);\n+      obj = ak->allocate_instance(sv->field_size(), ak->properties(), THREAD);\n@@ -1303,0 +1356,15 @@\n+\/\/ We're deoptimizing at the return of a call, inline type fields are\n+\/\/ in registers. When we go back to the interpreter, it will expect a\n+\/\/ reference to an inline type instance. Allocate and initialize it from\n+\/\/ the register values here.\n+bool Deoptimization::realloc_inline_type_result(InlineKlass* vk, const RegisterMap& map, GrowableArray<Handle>& return_oops, TRAPS) {\n+  oop new_vt = vk->realloc_result(map, return_oops, THREAD);\n+  if (new_vt == nullptr) {\n+    CLEAR_PENDING_EXCEPTION;\n+    THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), true);\n+  }\n+  return_oops.clear();\n+  return_oops.push(Handle(THREAD, new_vt));\n+  return false;\n+}\n+\n@@ -1468,0 +1536,3 @@\n+  InstanceKlass* _klass;\n+  bool _is_flat;\n+  bool _is_null_free;\n@@ -1469,4 +1540,1 @@\n-  ReassignedField() {\n-    _offset = 0;\n-    _type = T_ILLEGAL;\n-  }\n+  ReassignedField() : _offset(0), _type(T_ILLEGAL), _klass(nullptr), _is_flat(false), _is_null_free(false) { }\n@@ -1486,0 +1554,6 @@\n+      if (fs.is_flat()) {\n+        field._is_flat = true;\n+        field._is_null_free = fs.is_null_free_inline_type();\n+        \/\/ Resolve klass of flat inline type field\n+        field._klass = InlineKlass::cast(klass->get_inline_type_field_klass(fs.index()));\n+      }\n@@ -1492,2 +1566,3 @@\n-\/\/ Restore fields of an eliminated instance object employing the same field order used by the compiler.\n-static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci) {\n+\/\/ Restore fields of an eliminated instance object employing the same field order used by the\n+\/\/ compiler when it scalarizes an object at safepoints.\n+static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci, int base_offset, TRAPS) {\n@@ -1496,0 +1571,19 @@\n+    BasicType type = fields->at(i)._type;\n+    int offset = base_offset + fields->at(i)._offset;\n+    \/\/ Check for flat inline type field before accessing the ScopeValue because it might not have any fields\n+    if (fields->at(i)._is_flat) {\n+      \/\/ Recursively re-assign flat inline type fields\n+      InstanceKlass* vk = fields->at(i)._klass;\n+      assert(vk != nullptr, \"must be resolved\");\n+      offset -= InlineKlass::cast(vk)->payload_offset(); \/\/ Adjust offset to omit oop header\n+      svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, is_jvmci, offset, CHECK_0);\n+      if (!fields->at(i)._is_null_free) {\n+        ScopeValue* scope_field = sv->field_at(svIndex);\n+        StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);\n+        int nm_offset = offset + InlineKlass::cast(vk)->null_marker_offset();\n+        obj->bool_field_put(nm_offset, value->get_jint() & 1);\n+        svIndex++;\n+      }\n+      continue; \/\/ Continue because we don't need to increment svIndex\n+    }\n+\n@@ -1498,3 +1592,2 @@\n-    int offset = fields->at(i)._offset;\n-    BasicType type = fields->at(i)._type;\n-      case T_OBJECT: case T_ARRAY:\n+      case T_OBJECT:\n+      case T_ARRAY:\n@@ -1572,0 +1665,1 @@\n+\n@@ -1575,0 +1669,14 @@\n+\/\/ restore fields of an eliminated inline type array\n+void Deoptimization::reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, bool is_jvmci, TRAPS) {\n+  InlineKlass* vk = vak->element_klass();\n+  assert(vk->maybe_flat_in_array(), \"should only be used for flat inline type arrays\");\n+  \/\/ Adjust offset to omit oop header\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT) - InlineKlass::cast(vk)->payload_offset();\n+  \/\/ Initialize all elements of the flat inline type array\n+  for (int i = 0; i < sv->field_size(); i++) {\n+    ScopeValue* val = sv->field_at(i);\n+    int offset = base_offset + (i << Klass::layout_helper_log2_element_size(vak->layout_helper()));\n+    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, is_jvmci, offset, CHECK);\n+  }\n+}\n+\n@@ -1576,1 +1684,1 @@\n-void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool is_jvmci) {\n+void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool is_jvmci, TRAPS) {\n@@ -1581,0 +1689,14 @@\n+    \/\/ If it's an array, get the properties\n+    if (k->is_array_klass() && !k->is_typeArray_klass()) {\n+      assert(!k->is_refArray_klass() && !k->is_flatArray_klass(), \"Unexpected refined klass\");\n+      nmethod* nm = fr->cb()->as_nmethod_or_null();\n+      if (nm->is_compiled_by_c2()) {\n+        assert(sv->has_properties(), \"Property information is missing\");\n+        ArrayKlass::ArrayProperties props = static_cast<ArrayKlass::ArrayProperties>(StackValue::create_stack_value(fr, reg_map, sv->properties())->get_jint());\n+        k = ObjArrayKlass::cast(k)->klass_with_properties(props, THREAD);\n+      } else {\n+        \/\/ TODO Graal needs to be fixed. Just go with the default properties for now\n+        k = ObjArrayKlass::cast(k)->klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+      }\n+    }\n+\n@@ -1582,1 +1704,1 @@\n-    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n+    assert(obj.not_null() || realloc_failures || sv->has_properties(), \"reallocation was missed\");\n@@ -1620,1 +1742,4 @@\n-      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci);\n+      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci, 0, CHECK);\n+    } else if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+      reassign_flat_array_elements(fr, reg_map, sv, (flatArrayOop) obj(), vak, is_jvmci, CHECK);\n@@ -1624,1 +1749,1 @@\n-    } else if (k->is_objArray_klass()) {\n+    } else if (k->is_refArray_klass()) {\n@@ -1816,1 +1941,1 @@\n-  \/\/ Deoptimize only if the frame comes from compile code.\n+  \/\/ Deoptimize only if the frame comes from compiled code.\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":157,"deletions":32,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -808,0 +808,3 @@\n+    \/** The bit mask of {@link AccessFlag#IDENTITY} access and property modifier. *\/\n+    int ACC_IDENTITY = 0x0020;\n+\n@@ -841,0 +844,3 @@\n+    \/** The bit mask of {@link AccessFlag#STRICT_INIT} access and property modifier. *\/\n+    int ACC_STRICT_INIT = 0x0800;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.classfile.ClassFile;\n+\n@@ -386,1 +388,2 @@\n-    ; \/\/ Reduce code churn when appending new constants\n+\n+    \/\/ Reduce code churn when appending new constants\n@@ -391,0 +394,4 @@\n+    \/\/\/ The preview features of Valhalla.\n+    \/\/\/ @since 25\n+    CURRENT_PREVIEW_FEATURES(ClassFile.latestMajorVersion());\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -211,0 +211,13 @@\n+    public static boolean isSupported(Feature feature, int majorVersion) {\n+        Source source = null;\n+        for (Target target : Target.values()) {\n+            if (majorVersion == target.majorVersion) {\n+                source = lookup(target.name);\n+            }\n+        }\n+        if (source != null) {\n+            return feature.allowedInSource(source);\n+        }\n+        return false;\n+    }\n+\n@@ -275,0 +288,1 @@\n+        VALUE_CLASSES(JDK22, Fragments.FeatureValueClasses, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -226,0 +226,6 @@\n+    \/** Does the target VM support value classes\n+     *\/\n+    public boolean hasValueClasses() {\n+        return compareTo(JDK1_23) >= 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -503,6 +503,9 @@\n-                if (enclosingElement != null &&\n-                    enclosingElement.getKind().isInterface()) {\n-                    modifiers.remove(Modifier.PUBLIC);\n-                    modifiers.remove(Modifier.ABSTRACT); \/\/ only for methods\n-                    modifiers.remove(Modifier.STATIC);   \/\/ only for fields\n-                    modifiers.remove(Modifier.FINAL);    \/\/ only for fields\n+                if (enclosingElement != null) {\n+                    if (enclosingElement.getKind().isInterface()) {\n+                        modifiers.remove(Modifier.PUBLIC);\n+                        modifiers.remove(Modifier.ABSTRACT); \/\/ only for methods\n+                        modifiers.remove(Modifier.STATIC);   \/\/ only for fields\n+                        modifiers.remove(Modifier.FINAL);    \/\/ only for fields\n+                    } else if (enclosingElement.getKind() == RECORD) {\n+                        modifiers.remove(Modifier.STRICTFP);\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -84,0 +84,8 @@\n+compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/MemoryAccessProviderTest.java 8350208 generic-all\n+compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotResolvedJavaField.java 8350208 generic-all\n+\n+# Valhalla\n+compiler\/regalloc\/TestVerifyRegisterAllocator.java 8365895 windows-x64\n+compiler\/types\/TestArrayManyDimensions.java 8365895 windows-x64\n+compiler\/types\/correctness\/OffTest.java 8365895 windows-x64\n+\n@@ -103,0 +111,1 @@\n+runtime\/cds\/appcds\/redefineClass\/RedefineRunningMethods_Shared.java  8304168 generic-all\n@@ -122,0 +131,99 @@\n+\n+# Valhalla\n+runtime\/AccModule\/ConstModule.java 8294051 generic-all\n+runtime\/valhalla\/inlinetypes\/CircularityTest.java 8349037 generic-all\n+runtime\/valhalla\/inlinetypes\/verifier\/StrictInstanceFieldsTest.java CODETOOLS-7904031 generic-all\n+runtime\/valhalla\/inlinetypes\/verifier\/StrictStaticFieldsTest.java CODETOOLS-7904031 generic-all\n+\n+runtime\/cds\/TestDefaultArchiveLoading.java#coops_nocoh            8366774           generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#nocoops_nocoh          8366774           generic-all\n+\n+# Valhalla + COH\n+compiler\/c2\/autovectorization\/TestIndexOverflowIR.java                          8348568 generic-all\n+compiler\/c2\/irTests\/TestVectorConditionalMove.java                              8348568 generic-all\n+compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java                      8348568 generic-all\n+compiler\/c2\/irTests\/TestVectorizationNotRun.java                                8348568 generic-all\n+compiler\/c2\/TestCastX2NotProcessedIGVN.java                                     8348568 generic-all\n+compiler\/loopopts\/superword\/TestAlignVector.java                                8348568 generic-all\n+compiler\/loopopts\/superword\/TestAlignVector.java#NoAlignVector-COH              8348568 generic-all\n+compiler\/loopopts\/superword\/TestAlignVector.java#VerifyAlignVector-COH          8348568 generic-all\n+compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java       8348568 generic-all\n+compiler\/loopopts\/superword\/TestMulAddS2I.java                                  8348568 generic-all\n+compiler\/loopopts\/superword\/TestScheduleReordersScalarMemops.java               8348568 generic-all\n+compiler\/loopopts\/superword\/TestSplitPacks.java                                 8348568 generic-all\n+compiler\/loopopts\/superword\/TestUnorderedReductionPartialVectorization.java     8348568 generic-all\n+compiler\/vectorization\/TestFloatConversionsVector.java                          8348568 generic-all\n+compiler\/vectorization\/runner\/ArrayTypeConvertTest.java                         8348568 generic-all\n+compiler\/vectorization\/runner\/LoopCombinedOpTest.java                           8348568 generic-all\n+compiler\/vectorization\/runner\/VectorizationTestRunner.java                      8348568 generic-all\n+runtime\/FieldLayout\/TestOopMapSizeMinimal.java#no_coops_ccptr_coh               8348568 generic-all\n+\n+gc\/stress\/gcbasher\/TestGCBasherWithParallel.java                                8348568 generic-all\n+\n+gtest\/CompressedKlassGtest.java#use-zero-based-encoding-coh                     8348568 generic-all\n+gtest\/CompressedKlassGtest.java#use-zero-based-encoding-coh-large-class-space   8348568 generic-all\n+gtest\/MetaspaceGtests.java#UseCompactObjectHeaders                              8348568 generic-all\n+\n+runtime\/CompressedOops\/CompressedClassPointersEncodingScheme.java               8348568 generic-all\n+runtime\/FieldLayout\/BaseOffsets.java#no-coops-with-coh                          8348568 generic-all\n+runtime\/FieldLayout\/BaseOffsets.java#with-coop--with-coh                        8348568 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#coops_coh                            8348568 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#nocoops_coh                          8348568 generic-all\n+runtime\/cds\/appcds\/TestZGCWithCDS.java                                          8348568 generic-all\n+\n+# Valhalla + AOT\n+runtime\/cds\/appcds\/aotCache\/AOTCacheSupportForCustomLoaders.java                8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/AOTLoggingTag.java                                  8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/ClassPathLogging.java                               8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/ExcludedClasses.java                                8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/HelloAOTCache.java                                  8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/JavaAgent.java                                      8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/ManagementAgent.java                                8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/PackageInfoClass.java                               8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/SpecialCacheNames.java                              8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/VerifierFailOver.java                               8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/AOTCacheWithZGC.java                         8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/AOTLoaderConstraintsTest.java                8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/AddExports.java                              8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/AddOpens.java                                8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/AddReads.java                                8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java#aot                      8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/FakeCodeLocation.java                        8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/GeneratedInternedString.java                 8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/MethodHandleTest.java                        8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/NonFinalStaticWithInitVal.java               8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/StringConcatStress.java#aot                  8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/TestSetupAOTTest.java                        8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/TrainingRun.java                             8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/WeakReferenceTest.java                       8366701 generic-all\n+runtime\/cds\/appcds\/aotCode\/AOTCodeCompressedOopsTest.java                       8366701 generic-all\n+runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java                                    8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/AOTFlags.java                                       8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/FileNameSubstitution.java                           8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/JDK_AOT_VM_OPTIONS.java                             8366701 generic-all\n+runtime\/cds\/appcds\/aotProfile\/AOTProfileFlags.java                              8366701 generic-all\n+runtime\/cds\/appcds\/applications\/JavacBench.java#aot                             8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesAsCollectorTest.java#aot          8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesCastFailureTest.java#aot          8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesGeneralTest.java#aot              8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesInvokersTest.java#aot             8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesPermuteArgumentsTest.java#aot     8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesSpreadArgumentsTest.java#aot      8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/StringConcatStress.java#aot                  8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/TestSetupAOTTest.java                        8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/TrainingRun.java                             8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/WeakReferenceTest.java                       8366701 generic-all\n+runtime\/cds\/appcds\/aotCode\/AOTCodeCompressedOopsTest.java                       8366701 generic-all\n+runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java                                    8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/AOTFlags.java                                       8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/FileNameSubstitution.java                           8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/JDK_AOT_VM_OPTIONS.java                             8366701 generic-all\n+runtime\/cds\/appcds\/aotProfile\/AOTProfileFlags.java                              8366701 generic-all\n+runtime\/cds\/appcds\/applications\/JavacBench.java#aot                             8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesAsCollectorTest.java#aot          8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesCastFailureTest.java#aot          8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesGeneralTest.java#aot              8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesInvokersTest.java#aot             8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesPermuteArgumentsTest.java#aot     8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesSpreadArgumentsTest.java#aot      8366701 generic-all\n+\n@@ -150,0 +258,54 @@\n+# Valhalla TODO:\n+serviceability\/jvmti\/valhalla\/HeapDump\/HeapDump.java 8317416 generic-all\n+\n+serviceability\/sa\/ClhsdbCDSCore.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbCDSJstackPrintAll.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbFindPC.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbInspect.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbLongConstant.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbJdis.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbJstack.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintAll.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintAs.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintStatics.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbSource.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbSymbol.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbWhere.java 8190936 generic-all\n+serviceability\/sa\/JhsdbThreadInfoTest.java 8190936 generic-all\n+serviceability\/sa\/TestClassDump.java 8190936 generic-all\n+serviceability\/sa\/TestClhsdbJstackLock.java 8190936 generic-all\n+serviceability\/sa\/TestCpoolForInvokeDynamic.java 8190936 generic-all\n+serviceability\/sa\/TestHeapDumpForInvokeDynamic.java 8190936 generic-all\n+serviceability\/sa\/TestHeapDumpForLargeArray.java 8190936 generic-all\n+serviceability\/sa\/TestIntConstant.java 8190936 generic-all\n+serviceability\/sa\/TestJhsdbJstackLock.java 8190936 generic-all\n+serviceability\/sa\/TestJmapCore.java 8190936 generic-all\n+serviceability\/sa\/TestJmapCoreMetaspace.java 8190936 generic-all\n+serviceability\/sa\/TestPrintMdo.java 8190936 generic-all\n+serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbDumpclass.java 8190936 generic-all\n+\n+# Array Changes TODO\n+serviceability\/sa\/CDSJMapClstats.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbClasses.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/DisableRegistryTest.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbDumpheap.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/ClhsdbTestConnectArgument.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJhisto.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstack.java#id1 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstackWithConcurrentLock.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstackXcompStress.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbPstack.java#process 8365722 generic-all\n+serviceability\/sa\/ClhsdbPstack.java#core 8365722 generic-all\n+serviceability\/sa\/ClhsdbScanOops.java#id0 8365722 generic-all\n+serviceability\/sa\/ClhsdbScanOops.java#id1 8365722 generic-all\n+serviceability\/sa\/DeadlockDetectionTest.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstack.java#id0 8365722 generic-all\n+serviceability\/sa\/TestInstanceKlassSize.java 8365722 generic-all\n+serviceability\/sa\/TestSysProps.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/ClhsdbAttachToDebugServer.java 8365722 generic-all\n+resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8365722 generic-all\n+serviceability\/HeapDump\/DuplicateArrayClassesTest.java 8365722 generic-all\n+\n+\n@@ -189,0 +351,2 @@\n+vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/byteMutation\/Test.java 8317172 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":164,"deletions":0,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -0,0 +1,749 @@\n+\/*\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Generated from the following class files with PointN.x renamed and RectangleP.p1 made private\n+\/\/ java org.openjdk.asmtools.Main jdec NamedRectangleN.class NamedRectangleP.class PointN.class RectangleN.class RectangleP.class\n+\n+\/*\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+@LooselyConsistentValue\n+value class PointN {\n+    int x; \/\/ Removed\n+    int y;\n+\n+    PointN(int i, int j) {\n+        x = i;\n+        y = j;\n+    }\n+}\n+\n+@LooselyConsistentValue\n+value class RectangleN {\n+    @Strict\n+    @NullRestricted\n+    PointN p1 = new PointN(4, 7);\n+}\n+\n+class NamedRectangleN {\n+    @Strict\n+    @NullRestricted\n+    RectangleN rect = new RectangleN();\n+    String name = \"\";\n+\n+    static int getP1X(NamedRectangleN nr) {\n+        return nr.rect.p1.x;\n+    }\n+}\n+\n+@LooselyConsistentValue\n+value class RectangleP {\n+    @Strict\n+    @NullRestricted\n+    PointN p1 = new PointN(4, 7); \/\/ Made private\n+}\n+\n+class NamedRectangleP {\n+    @Strict\n+    @NullRestricted\n+    RectangleP rect = new RectangleP();\n+    String name = \"\";\n+\n+    static int getP1Y(NamedRectangleP nr) {\n+        return nr.rect.p1.y;\n+    }\n+}\n+\n+*\/\n+\n+class compiler\/valhalla\/inlinetypes\/NamedRectangleN {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleN\"; \/\/ #10\n+    Utf8 \"rect\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/RectangleN;\"; \/\/ #12\n+    String #14; \/\/ #13\n+    Utf8 \"\"; \/\/ #14\n+    Field #8 #16; \/\/ #15\n+    NameAndType #17 #18; \/\/ #16\n+    Utf8 \"name\"; \/\/ #17\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #18\n+    Method #20 #4; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Field #1 #23; \/\/ #22\n+    NameAndType #24 #25; \/\/ #23\n+    Utf8 \"p1\"; \/\/ #24\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #25\n+    Field #27 #28; \/\/ #26\n+    class #29; \/\/ #27\n+    NameAndType #30 #31; \/\/ #28\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #29\n+    Utf8 \"x\"; \/\/ #30\n+    Utf8 \"I\"; \/\/ #31\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #32\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #33\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #34\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #35\n+    Utf8 \"Code\"; \/\/ #36\n+    Utf8 \"LineNumberTable\"; \/\/ #37\n+    Utf8 \"getP1X\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleN;)I\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"PointN.java\"; \/\/ #41\n+    Utf8 \"LoadableDescriptors\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0800; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#32) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #33;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n+        ;\n+        Attr(#34) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #35;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#36) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB000159B70003;\n+            0xB500072A120DB500;\n+            0x0F2AB70013B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#37) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  26;\n+                11  29;\n+                17  25;\n+                21  29;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#36) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007B40016B4;\n+            0x001AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#37) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  32;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#42) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/NamedRectangleN\n+\n+class compiler\/valhalla\/inlinetypes\/NamedRectangleP {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/NamedRectangleP\"; \/\/ #10\n+    Utf8 \"rect\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/RectangleP;\"; \/\/ #12\n+    String #14; \/\/ #13\n+    Utf8 \"\"; \/\/ #14\n+    Field #8 #16; \/\/ #15\n+    NameAndType #17 #18; \/\/ #16\n+    Utf8 \"name\"; \/\/ #17\n+    Utf8 \"Ljava\/lang\/String;\"; \/\/ #18\n+    Method #20 #4; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"java\/lang\/Object\"; \/\/ #21\n+    Field #1 #23; \/\/ #22\n+    NameAndType #24 #25; \/\/ #23\n+    Utf8 \"p1\"; \/\/ #24\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #25\n+    Field #27 #28; \/\/ #26\n+    class #29; \/\/ #27\n+    NameAndType #30 #31; \/\/ #28\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #29\n+    Utf8 \"y\"; \/\/ #30\n+    Utf8 \"I\"; \/\/ #31\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #32\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #33\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #34\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #35\n+    Utf8 \"Code\"; \/\/ #36\n+    Utf8 \"LineNumberTable\"; \/\/ #37\n+    Utf8 \"getP1Y\"; \/\/ #38\n+    Utf8 \"(Lcompiler\/valhalla\/inlinetypes\/NamedRectangleP;)I\"; \/\/ #39\n+    Utf8 \"SourceFile\"; \/\/ #40\n+    Utf8 \"PointN.java\"; \/\/ #41\n+    Utf8 \"LoadableDescriptors\"; \/\/ #42\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #20;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0800; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#32) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #33;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n+        ;\n+        Attr(#34) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #35;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#36) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB000159B70003;\n+            0xB500072A120DB500;\n+            0x0F2AB70013B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#37) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  44;\n+                11  47;\n+                17  43;\n+                21  47;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #38; \/\/ name_index\n+      #39; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#36) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007B40016B4;\n+            0x001AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#37) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  50;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#40) { \/\/ SourceFile\n+      #41;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#42) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/NamedRectangleP\n+\n+class compiler\/valhalla\/inlinetypes\/PointN {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #4\n+    Utf8 \"x0\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Field #2 #8; \/\/ #7\n+    NameAndType #9 #6; \/\/ #8\n+    Utf8 \"y\"; \/\/ #9\n+    Method #11 #12; \/\/ #10\n+    class #13; \/\/ #11\n+    NameAndType #14 #15; \/\/ #12\n+    Utf8 \"java\/lang\/Object\"; \/\/ #13\n+    Utf8 \"<init>\"; \/\/ #14\n+    Utf8 \"()V\"; \/\/ #15\n+    Utf8 \"(II)V\"; \/\/ #16\n+    Utf8 \"Code\"; \/\/ #17\n+    Utf8 \"LineNumberTable\"; \/\/ #18\n+    Utf8 \"SourceFile\"; \/\/ #19\n+    Utf8 \"PointN.java\"; \/\/ #20\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #21\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #2;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #9; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #14; \/\/ name_index\n+      #16; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#17) { \/\/ Code\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[]{\n+            0x2A1BB500012A1CB5;\n+            0x00072AB7000AB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#18) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  13;\n+                5  14;\n+                10  12;\n+                14  15;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#19) { \/\/ SourceFile\n+      #20;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#21) { \/\/ RuntimeVisibleAnnotations\n+      [] { \/\/ annotations\n+        {  \/\/  annotation\n+          #22;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+      }\n+    } \/\/ end RuntimeVisibleAnnotations\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/PointN\n+\n+class compiler\/valhalla\/inlinetypes\/RectangleN {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"(II)V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleN\"; \/\/ #10\n+    Utf8 \"p1\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #12\n+    Method #14 #15; \/\/ #13\n+    class #16; \/\/ #14\n+    NameAndType #5 #17; \/\/ #15\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16\n+    Utf8 \"()V\"; \/\/ #17\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #18\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #19\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #20\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #21\n+    Utf8 \"Code\"; \/\/ #22\n+    Utf8 \"LineNumberTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"PointN.java\"; \/\/ #25\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #26\n+    Utf8 \"LoadableDescriptors\"; \/\/ #27\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #8;\/\/ this_cpx\n+  #14;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #19;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n+        ;\n+        Attr(#20) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #21;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#22) { \/\/ Code\n+          5; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB000159071007;\n+            0xB70003B500072AB7;\n+            0x000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#23) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  20;\n+                14  19;\n+                18  20;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#18) { \/\/ RuntimeVisibleAnnotations\n+      [] { \/\/ annotations\n+        {  \/\/  annotation\n+          #26;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+      }\n+    } \/\/ end RuntimeVisibleAnnotations\n+    ;\n+    Attr(#27) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/RectangleN\n+\n+class compiler\/valhalla\/inlinetypes\/RectangleP {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/PointN\"; \/\/ #2\n+    Method #1 #4; \/\/ #3\n+    NameAndType #5 #6; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"(II)V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"compiler\/valhalla\/inlinetypes\/RectangleP\"; \/\/ #10\n+    Utf8 \"p1\"; \/\/ #11\n+    Utf8 \"Lcompiler\/valhalla\/inlinetypes\/PointN;\"; \/\/ #12\n+    Method #14 #15; \/\/ #13\n+    class #16; \/\/ #14\n+    NameAndType #5 #17; \/\/ #15\n+    Utf8 \"java\/lang\/Object\"; \/\/ #16\n+    Utf8 \"()V\"; \/\/ #17\n+    Utf8 \"RuntimeVisibleAnnotations\"; \/\/ #18\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\"; \/\/ #19\n+    Utf8 \"RuntimeInvisibleAnnotations\"; \/\/ #20\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\"; \/\/ #21\n+    Utf8 \"Code\"; \/\/ #22\n+    Utf8 \"LineNumberTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"PointN.java\"; \/\/ #25\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\"; \/\/ #26\n+    Utf8 \"LoadableDescriptors\"; \/\/ #27\n+  } \/\/ Constant Pool\n+\n+  0x0010; \/\/ access\n+  #8;\/\/ this_cpx\n+  #14;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0812; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ RuntimeVisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #19;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeVisibleAnnotations\n+        ;\n+        Attr(#20) { \/\/ RuntimeInvisibleAnnotations\n+          [] { \/\/ annotations\n+            {  \/\/  annotation\n+              #21;\n+              [] { \/\/ element_value_pairs\n+              }  \/\/  element_value_pairs\n+            }  \/\/  annotation\n+          }\n+        } \/\/ end RuntimeInvisibleAnnotations\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#22) { \/\/ Code\n+          5; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB000159071007;\n+            0xB70003B500072AB7;\n+            0x000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#23) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  38;\n+                14  37;\n+                18  38;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#18) { \/\/ RuntimeVisibleAnnotations\n+      [] { \/\/ annotations\n+        {  \/\/  annotation\n+          #26;\n+          [] { \/\/ element_value_pairs\n+          }  \/\/  element_value_pairs\n+        }  \/\/  annotation\n+      }\n+    } \/\/ end RuntimeVisibleAnnotations\n+    ;\n+    Attr(#27) { \/\/ LoadableDescriptors\n+      0x0001000C;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class compiler\/valhalla\/inlinetypes\/RectangleP\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/GetfieldChains.jcod","additions":749,"deletions":0,"binary":false,"changes":749,"status":"added"},{"patch":"@@ -0,0 +1,3743 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ ##################################### WARNING ########################################\n+\/\/ Generated file, don't modify manually. See TestMismatchHandling.java for instructions.\n+\/\/ ##################################### WARNING ########################################\n+\n+class MyValue1 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue1\"; \/\/ #10\n+    Utf8 \"x\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #14\n+    String #16; \/\/ #15\n+    Utf8 \"Verification failed\"; \/\/ #16\n+    Method #13 #18; \/\/ #17\n+    NameAndType #5 #19; \/\/ #18\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #19\n+    Utf8 \"Code\"; \/\/ #20\n+    Utf8 \"LineNumberTable\"; \/\/ #21\n+    Utf8 \"verify\"; \/\/ #22\n+    Utf8 \"StackMapTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#20) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A102AB5;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#21) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  24;\n+                4  25;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #22; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#20) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007102A9F00;\n+            0x0DBB000D59120FB7;\n+            0x0011BFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#21) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  28;\n+                9  29;\n+                19  31;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue1\n+class MyValue2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue2\"; \/\/ #10\n+    Utf8 \"x\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #14\n+    String #16; \/\/ #15\n+    Utf8 \"Verification failed\"; \/\/ #16\n+    Method #13 #18; \/\/ #17\n+    NameAndType #5 #19; \/\/ #18\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #19\n+    Utf8 \"Code\"; \/\/ #20\n+    Utf8 \"LineNumberTable\"; \/\/ #21\n+    Utf8 \"verify\"; \/\/ #22\n+    Utf8 \"StackMapTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#20) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A102AB5;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#21) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  34;\n+                4  35;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #22; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#20) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007102A9F00;\n+            0x0DBB000D59120FB7;\n+            0x0011BFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#21) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  38;\n+                9  39;\n+                19  41;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue2\n+class MyValue3 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue3\"; \/\/ #10\n+    Utf8 \"x\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #14\n+    String #16; \/\/ #15\n+    Utf8 \"Verification failed\"; \/\/ #16\n+    Method #13 #18; \/\/ #17\n+    NameAndType #5 #19; \/\/ #18\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #19\n+    Utf8 \"Code\"; \/\/ #20\n+    Utf8 \"LineNumberTable\"; \/\/ #21\n+    Utf8 \"verify\"; \/\/ #22\n+    Utf8 \"StackMapTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#20) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A102AB5;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#21) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  44;\n+                4  45;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #22; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#20) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007102A9F00;\n+            0x0DBB000D59120FB7;\n+            0x0011BFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#21) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  48;\n+                9  49;\n+                19  51;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue3\n+class MyValue4 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue4\"; \/\/ #10\n+    Utf8 \"x\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #14\n+    String #16; \/\/ #15\n+    Utf8 \"Verification failed\"; \/\/ #16\n+    Method #13 #18; \/\/ #17\n+    NameAndType #5 #19; \/\/ #18\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #19\n+    Method #8 #3; \/\/ #20\n+    Utf8 \"Code\"; \/\/ #21\n+    Utf8 \"LineNumberTable\"; \/\/ #22\n+    Utf8 \"verify\"; \/\/ #23\n+    Utf8 \"StackMapTable\"; \/\/ #24\n+    Utf8 \"make\"; \/\/ #25\n+    Utf8 \"()LMyValue4;\"; \/\/ #26\n+    Utf8 \"SourceFile\"; \/\/ #27\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #28\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#21) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A102AB5;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#22) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  54;\n+                4  55;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #23; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#21) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007102A9F00;\n+            0x0DBB000D59120FB7;\n+            0x0011BFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#22) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  58;\n+                9  59;\n+                19  61;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#24) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #25; \/\/ name_index\n+      #26; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#21) { \/\/ Code\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xBB000859B70014B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#22) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  64;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#27) { \/\/ SourceFile\n+      #28;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue4\n+class MyValue5 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue5\"; \/\/ #10\n+    Utf8 \"x\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #14\n+    String #16; \/\/ #15\n+    Utf8 \"Verification failed\"; \/\/ #16\n+    Method #13 #18; \/\/ #17\n+    NameAndType #5 #19; \/\/ #18\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #19\n+    Method #8 #3; \/\/ #20\n+    class #22; \/\/ #21\n+    Utf8 \"Verifiable\"; \/\/ #22\n+    Utf8 \"Code\"; \/\/ #23\n+    Utf8 \"LineNumberTable\"; \/\/ #24\n+    Utf8 \"verify\"; \/\/ #25\n+    Utf8 \"StackMapTable\"; \/\/ #26\n+    Utf8 \"make\"; \/\/ #27\n+    Utf8 \"()LMyValue5;\"; \/\/ #28\n+    Utf8 \"SourceFile\"; \/\/ #29\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #30\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #21;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A102AB5;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  72;\n+                4  73;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #25; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007102A9F00;\n+            0x0DBB000D59120FB7;\n+            0x0011BFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  77;\n+                9  78;\n+                19  80;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#26) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #27; \/\/ name_index\n+      #28; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xBB000859B70014B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  83;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#29) { \/\/ SourceFile\n+      #30;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue5\n+class MyValue6 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue6\"; \/\/ #10\n+    Utf8 \"x\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #14\n+    String #16; \/\/ #15\n+    Utf8 \"Verification failed\"; \/\/ #16\n+    Method #13 #18; \/\/ #17\n+    NameAndType #5 #19; \/\/ #18\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #19\n+    Method #8 #3; \/\/ #20\n+    class #22; \/\/ #21\n+    Utf8 \"Verifiable\"; \/\/ #22\n+    Utf8 \"Code\"; \/\/ #23\n+    Utf8 \"LineNumberTable\"; \/\/ #24\n+    Utf8 \"verify\"; \/\/ #25\n+    Utf8 \"StackMapTable\"; \/\/ #26\n+    Utf8 \"make\"; \/\/ #27\n+    Utf8 \"()LMyValue6;\"; \/\/ #28\n+    Utf8 \"SourceFile\"; \/\/ #29\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #30\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #21;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A102AB5;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  87;\n+                4  88;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #25; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007102A9F00;\n+            0x0DBB000D59120FB7;\n+            0x0011BFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  92;\n+                9  93;\n+                19  95;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#26) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #27; \/\/ name_index\n+      #28; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#23) { \/\/ Code\n+          2; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0xBB000859B70014B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#24) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  98;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#29) { \/\/ SourceFile\n+      #30;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue6\n+class MyValue7 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue7\"; \/\/ #10\n+    Utf8 \"x\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #14\n+    String #16; \/\/ #15\n+    Utf8 \"Verification failed\"; \/\/ #16\n+    Method #13 #18; \/\/ #17\n+    NameAndType #5 #19; \/\/ #18\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #19\n+    Utf8 \"Code\"; \/\/ #20\n+    Utf8 \"LineNumberTable\"; \/\/ #21\n+    Utf8 \"verify\"; \/\/ #22\n+    Utf8 \"StackMapTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#20) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A102AB5;\n+            0x0007B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#21) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  102;\n+                4  103;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #22; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#20) { \/\/ Code\n+          3; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007102A9F00;\n+            0x0DBB000D59120FB7;\n+            0x0011BFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#21) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  106;\n+                9  107;\n+                19  109;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23) { \/\/ StackMapTable\n+              [] { \/\/ \n+                19b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class MyValue7\n+class Verifiable {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"Verifiable\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"verify\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class Verifiable\n+file \"B.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"A\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue1\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"B\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue1;)LMyValue1;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  119;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  122;\n+                4  123;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class B\n+class I3 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I3\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class I3\n+class I4 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I4\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    class #6; \/\/ #5\n+    Utf8 \"I3\"; \/\/ #6\n+    Utf8 \"method\"; \/\/ #7\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #5;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class I4\n+class E {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue2\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"E\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I4\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  160;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  163;\n+                4  164;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class E\n+class G {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue2\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"G\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I2\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"I4\"; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"method\"; \/\/ #20\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #21\n+    Utf8 \"SourceFile\"; \/\/ #22\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #23\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+    #16;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  177;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #20; \/\/ name_index\n+      #21; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  180;\n+                4  181;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#22) { \/\/ SourceFile\n+      #23;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class G\n+class J {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue3\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"J\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  197;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  199;\n+                4  200;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class J\n+class K {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"J\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue3\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"K\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  204;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  207;\n+                4  208;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class K\n+file \"L.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"K\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue3\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"L\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I5\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  212;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  215;\n+                4  216;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class L\n+class P {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue7\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"P\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I6\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  263;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  266;\n+                4  267;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class P\n+class Q {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue7\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"Q\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  271;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  273;\n+                4  274;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class Q\n+class R {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"Q\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue7\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"R\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  278;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  281;\n+                4  282;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class R\n+class S {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"R\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue7\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"S\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I6\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  286;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  289;\n+                4  290;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class S\n+class TestMismatchHandlingHelper {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"MyValue1\"; \/\/ #8\n+    Method #7 #3; \/\/ #9\n+    Method #11 #12; \/\/ #10\n+    class #13; \/\/ #11\n+    NameAndType #14 #15; \/\/ #12\n+    Utf8 \"A\"; \/\/ #13\n+    Utf8 \"method\"; \/\/ #14\n+    Utf8 \"(LMyValue1;)LMyValue1;\"; \/\/ #15\n+    Method #7 #17; \/\/ #16\n+    NameAndType #18 #6; \/\/ #17\n+    Utf8 \"verify\"; \/\/ #18\n+    Method #20 #12; \/\/ #19\n+    class #21; \/\/ #20\n+    Utf8 \"B\"; \/\/ #21\n+    Method #23 #12; \/\/ #22\n+    class #24; \/\/ #23\n+    Utf8 \"C\"; \/\/ #24\n+    class #26; \/\/ #25\n+    Utf8 \"MyValue2\"; \/\/ #26\n+    Method #25 #3; \/\/ #27\n+    InterfaceMethod #29 #30; \/\/ #28\n+    class #31; \/\/ #29\n+    NameAndType #14 #32; \/\/ #30\n+    Utf8 \"I1\"; \/\/ #31\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #32\n+    Method #25 #17; \/\/ #33\n+    InterfaceMethod #35 #30; \/\/ #34\n+    class #36; \/\/ #35\n+    Utf8 \"I2\"; \/\/ #36\n+    Method #38 #30; \/\/ #37\n+    class #39; \/\/ #38\n+    Utf8 \"D\"; \/\/ #39\n+    InterfaceMethod #41 #30; \/\/ #40\n+    class #42; \/\/ #41\n+    Utf8 \"I3\"; \/\/ #42\n+    InterfaceMethod #44 #30; \/\/ #43\n+    class #45; \/\/ #44\n+    Utf8 \"I4\"; \/\/ #45\n+    Method #47 #30; \/\/ #46\n+    class #48; \/\/ #47\n+    Utf8 \"E\"; \/\/ #48\n+    class #50; \/\/ #49\n+    Utf8 \"MyValue3\"; \/\/ #50\n+    Method #49 #3; \/\/ #51\n+    InterfaceMethod #53 #54; \/\/ #52\n+    class #55; \/\/ #53\n+    NameAndType #14 #56; \/\/ #54\n+    Utf8 \"I5\"; \/\/ #55\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #56\n+    Method #49 #17; \/\/ #57\n+    Method #59 #54; \/\/ #58\n+    class #60; \/\/ #59\n+    Utf8 \"H\"; \/\/ #60\n+    Method #62 #54; \/\/ #61\n+    class #63; \/\/ #62\n+    Utf8 \"J\"; \/\/ #63\n+    Method #65 #54; \/\/ #64\n+    class #66; \/\/ #65\n+    Utf8 \"K\"; \/\/ #66\n+    Method #68 #69; \/\/ #67\n+    class #70; \/\/ #68\n+    NameAndType #14 #71; \/\/ #69\n+    Utf8 \"M\"; \/\/ #70\n+    Utf8 \"(Z)LMyValue4;\"; \/\/ #71\n+    Field #73 #74; \/\/ #72\n+    class #75; \/\/ #73\n+    NameAndType #76 #77; \/\/ #74\n+    Utf8 \"MyValue4\"; \/\/ #75\n+    Utf8 \"x\"; \/\/ #76\n+    Utf8 \"I\"; \/\/ #77\n+    class #79; \/\/ #78\n+    Utf8 \"java\/lang\/RuntimeException\"; \/\/ #79\n+    String #81; \/\/ #80\n+    Utf8 \"Verification failed\"; \/\/ #81\n+    Method #78 #83; \/\/ #82\n+    NameAndType #5 #84; \/\/ #83\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #84\n+    Method #86 #87; \/\/ #85\n+    class #88; \/\/ #86\n+    NameAndType #14 #89; \/\/ #87\n+    Utf8 \"N\"; \/\/ #88\n+    Utf8 \"(Z)LMyValue5;\"; \/\/ #89\n+    InterfaceMethod #91 #17; \/\/ #90\n+    class #92; \/\/ #91\n+    Utf8 \"Verifiable\"; \/\/ #92\n+    Method #94 #30; \/\/ #93\n+    class #95; \/\/ #94\n+    Utf8 \"F\"; \/\/ #95\n+    Method #97 #30; \/\/ #96\n+    class #98; \/\/ #97\n+    Utf8 \"G\"; \/\/ #98\n+    Method #100 #54; \/\/ #99\n+    class #101; \/\/ #100\n+    Utf8 \"L\"; \/\/ #101\n+    Method #103 #104; \/\/ #102\n+    class #105; \/\/ #103\n+    NameAndType #14 #106; \/\/ #104\n+    Utf8 \"O\"; \/\/ #105\n+    Utf8 \"(Z)LMyValue6;\"; \/\/ #106\n+    Method #108 #17; \/\/ #107\n+    class #109; \/\/ #108\n+    Utf8 \"MyValue6\"; \/\/ #109\n+    class #111; \/\/ #110\n+    Utf8 \"MyValue7\"; \/\/ #111\n+    Method #110 #3; \/\/ #112\n+    InterfaceMethod #114 #115; \/\/ #113\n+    class #116; \/\/ #114\n+    NameAndType #14 #117; \/\/ #115\n+    Utf8 \"I6\"; \/\/ #116\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #117\n+    Method #110 #17; \/\/ #118\n+    Method #120 #115; \/\/ #119\n+    class #121; \/\/ #120\n+    Utf8 \"P\"; \/\/ #121\n+    Method #123 #115; \/\/ #122\n+    class #124; \/\/ #123\n+    Utf8 \"Q\"; \/\/ #124\n+    Method #126 #115; \/\/ #125\n+    class #127; \/\/ #126\n+    Utf8 \"R\"; \/\/ #127\n+    class #129; \/\/ #128\n+    Utf8 \"TestMismatchHandlingHelper\"; \/\/ #129\n+    Utf8 \"Code\"; \/\/ #130\n+    Utf8 \"LineNumberTable\"; \/\/ #131\n+    Utf8 \"test1\"; \/\/ #132\n+    Utf8 \"(LA;LA;LA;LA;LA;LB;LB;LC;)V\"; \/\/ #133\n+    Utf8 \"test2\"; \/\/ #134\n+    Utf8 \"(LI1;LI1;LI1;LI1;LI1;LI1;LI2;LI2;LI2;LI2;LI2;LI2;LI3;LI3;LI3;LI3;LI3;LI3;LI4;LI4;LI4;LI4;LI4;LI4;LD;LE;)V\"; \/\/ #135\n+    Utf8 \"test3\"; \/\/ #136\n+    Utf8 \"(LI5;LI5;LI5;LJ;LJ;LJ;LJ;LJ;LH;LK;)V\"; \/\/ #137\n+    Utf8 \"test4\"; \/\/ #138\n+    Utf8 \"(LM;Z)V\"; \/\/ #139\n+    Utf8 \"StackMapTable\"; \/\/ #140\n+    Utf8 \"test5\"; \/\/ #141\n+    Utf8 \"(LN;Z)V\"; \/\/ #142\n+    Utf8 \"test6\"; \/\/ #143\n+    Utf8 \"(LF;LG;LL;)V\"; \/\/ #144\n+    Utf8 \"test7\"; \/\/ #145\n+    Utf8 \"(LO;Z)LVerifiable;\"; \/\/ #146\n+    Utf8 \"test7TriggerCalleeCompilation\"; \/\/ #147\n+    Utf8 \"(LO;)V\"; \/\/ #148\n+    Utf8 \"test8\"; \/\/ #149\n+    Utf8 \"(LI6;LI6;LI6;LQ;LQ;LQ;LQ;LQ;LP;LR;)V\"; \/\/ #150\n+    Utf8 \"SourceFile\"; \/\/ #151\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #152\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #128;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  294;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #132; \/\/ name_index\n+      #133; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          8; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB000759B70009;\n+            0xB6000AB600102BBB;\n+            0x000759B70009B600;\n+            0x0AB600102CBB0007;\n+            0x59B70009B6000AB6;\n+            0x00102DBB000759B7;\n+            0x0009B6000AB60010;\n+            0x1904BB000759B700;\n+            0x09B6000AB6001019;\n+            0x05BB000759B70009;\n+            0xB60013B600101906;\n+            0xBB000759B70009B6;\n+            0x0013B600101907BB;\n+            0x000759B70009B600;\n+            0x16B60010B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  300;\n+                14  301;\n+                28  302;\n+                42  303;\n+                56  304;\n+                71  306;\n+                86  307;\n+                101  308;\n+                116  309;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #134; \/\/ name_index\n+      #135; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          26; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB001959B7001B;\n+            0xB9001C0200B60021;\n+            0x2BBB001959B7001B;\n+            0xB9001C0200B60021;\n+            0x2CBB001959B7001B;\n+            0xB9001C0200B60021;\n+            0x2DBB001959B7001B;\n+            0xB9001C0200B60021;\n+            0x1904BB001959B700;\n+            0x1BB9001C0200B600;\n+            0x211905BB001959B7;\n+            0x001BB9001C0200B6;\n+            0x00211906BB001959;\n+            0xB7001BB900220200;\n+            0xB600211907BB0019;\n+            0x59B7001BB9002202;\n+            0x00B600211908BB00;\n+            0x1959B7001BB90022;\n+            0x0200B600211909BB;\n+            0x001959B7001BB900;\n+            0x220200B60021190A;\n+            0xBB001959B7001BB9;\n+            0x00220200B6002119;\n+            0x0BBB001959B7001B;\n+            0xB900220200B60021;\n+            0x1918BB001959B700;\n+            0x1BB60025B6002119;\n+            0x0CBB001959B7001B;\n+            0xB900280200B60021;\n+            0x190DBB001959B700;\n+            0x1BB900280200B600;\n+            0x21190EBB001959B7;\n+            0x001BB900280200B6;\n+            0x0021190FBB001959;\n+            0xB7001BB900280200;\n+            0xB600211910BB0019;\n+            0x59B7001BB9002802;\n+            0x00B600211911BB00;\n+            0x1959B7001BB90028;\n+            0x0200B600211912BB;\n+            0x001959B7001BB900;\n+            0x2B0200B600211913;\n+            0xBB001959B7001BB9;\n+            0x002B0200B6002119;\n+            0x14BB001959B7001B;\n+            0xB9002B0200B60021;\n+            0x1915BB001959B700;\n+            0x1BB9002B0200B600;\n+            0x211916BB001959B7;\n+            0x001BB9002B0200B6;\n+            0x00211917BB001959;\n+            0xB7001BB9002B0200;\n+            0xB600211919BB0019;\n+            0x59B7001BB6002EB6;\n+            0x0021B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  318;\n+                16  319;\n+                32  320;\n+                48  321;\n+                64  322;\n+                81  323;\n+                98  324;\n+                115  325;\n+                132  326;\n+                149  327;\n+                166  328;\n+                183  329;\n+                200  330;\n+                215  332;\n+                232  333;\n+                249  334;\n+                266  335;\n+                283  336;\n+                300  337;\n+                317  338;\n+                334  339;\n+                351  340;\n+                368  341;\n+                385  342;\n+                402  343;\n+                419  344;\n+                434  345;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #136; \/\/ name_index\n+      #137; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          10; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB003159B70033;\n+            0xB900340200B60039;\n+            0x2BBB003159B70033;\n+            0xB900340200B60039;\n+            0x2CBB003159B70033;\n+            0xB900340200B60039;\n+            0x1908BB003159B700;\n+            0x33B6003AB600392D;\n+            0xBB003159B70033B6;\n+            0x003DB600391904BB;\n+            0x003159B70033B600;\n+            0x3DB600391905BB00;\n+            0x3159B70033B6003D;\n+            0xB600391906BB0031;\n+            0x59B70033B6003DB6;\n+            0x00391907BB003159;\n+            0xB70033B6003DB600;\n+            0x391909BB003159B7;\n+            0x0033B60040B60039;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  353;\n+                16  354;\n+                32  355;\n+                48  356;\n+                63  358;\n+                77  359;\n+                92  360;\n+                107  361;\n+                122  362;\n+                137  363;\n+                152  364;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #138; \/\/ name_index\n+      #139; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000C2A1BB600;\n+            0x4357A7001A2A1BB6;\n+            0x0043B40048102A9F;\n+            0x000DBB004E591250;\n+            0xB70052BFB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  369;\n+                4  370;\n+                13  372;\n+                26  373;\n+                36  376;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#140) { \/\/ StackMapTable\n+              [] { \/\/ \n+                13b; \/\/ same_frame\n+                22b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #141; \/\/ name_index\n+      #142; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[]{\n+            0x2A1BB600554D1B9A;\n+            0x00092CB9005A0100;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  381;\n+                6  382;\n+                10  383;\n+                16  385;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#140) { \/\/ StackMapTable\n+              [] { \/\/ \n+                252b, 16, []z{O,91}; \/\/ append_frame 1\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #143; \/\/ name_index\n+      #144; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB001959B7001B;\n+            0xB6005D572BBB0019;\n+            0x59B7001BB6006057;\n+            0x2CBB003159B70033;\n+            0xB6006357B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  389;\n+                12  390;\n+                24  391;\n+                36  392;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #145; \/\/ name_index\n+      #146; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2A1BB60066B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  397;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #147; \/\/ name_index\n+      #148; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A04B60066572A03;\n+            0xB60066B6006BB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  401;\n+                6  402;\n+                14  403;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #149; \/\/ name_index\n+      #150; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#130) { \/\/ Code\n+          3; \/\/ max_stack\n+          10; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABB006E59B70070;\n+            0xB900710200B60076;\n+            0x2BBB006E59B70070;\n+            0xB900710200B60076;\n+            0x2CBB006E59B70070;\n+            0xB900710200B60076;\n+            0x1908BB006E59B700;\n+            0x70B60077B600762D;\n+            0xBB006E59B70070B6;\n+            0x007AB600761904BB;\n+            0x006E59B70070B600;\n+            0x7AB600761905BB00;\n+            0x6E59B70070B6007A;\n+            0xB600761906BB006E;\n+            0x59B70070B6007AB6;\n+            0x00761907BB006E59;\n+            0xB70070B6007AB600;\n+            0x761909BB006E59B7;\n+            0x0070B6007DB60076;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#131) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  412;\n+                16  413;\n+                32  414;\n+                48  415;\n+                63  417;\n+                77  418;\n+                92  419;\n+                107  420;\n+                122  421;\n+                137  422;\n+                152  423;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#151) { \/\/ SourceFile\n+      #152;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class TestMismatchHandlingHelper\n+class A {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue1\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"A\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue1;)LMyValue1;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  112;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  114;\n+                4  115;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class A\n+class C {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"B\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue1\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"C\"; \/\/ #13\n+    Utf8 \"Code\"; \/\/ #14\n+    Utf8 \"LineNumberTable\"; \/\/ #15\n+    Utf8 \"method\"; \/\/ #16\n+    Utf8 \"(LMyValue1;)LMyValue1;\"; \/\/ #17\n+    Utf8 \"SourceFile\"; \/\/ #18\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #19\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  127;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #16; \/\/ name_index\n+      #17; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#15) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  130;\n+                4  131;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#18) { \/\/ SourceFile\n+      #19;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class C\n+class I1 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I1\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class I1\n+class I2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I2\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    class #6; \/\/ #5\n+    Utf8 \"I1\"; \/\/ #6\n+    Utf8 \"method\"; \/\/ #7\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #5;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class I2\n+file \"D.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue2\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"D\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I2\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  152;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  155;\n+                4  156;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class D\n+file \"F.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue2\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"F\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I2\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"I4\"; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"method\"; \/\/ #20\n+    Utf8 \"(LMyValue2;)LMyValue2;\"; \/\/ #21\n+    Utf8 \"SourceFile\"; \/\/ #22\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #23\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+    #16;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  169;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #20; \/\/ name_index\n+      #21; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  172;\n+                4  173;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#22) { \/\/ SourceFile\n+      #23;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class F\n+class H {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue3\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"H\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I5\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  189;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  192;\n+                4  193;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class H\n+class I5 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I5\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(LMyValue3;)LMyValue3;\"; \/\/ #6\n+    Utf8 \"SourceFile\"; \/\/ #7\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #8\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0401; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#7) { \/\/ SourceFile\n+      #8;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class I5\n+class M {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"M\"; \/\/ #10\n+    Utf8 \"val\"; \/\/ #11\n+    Utf8 \"I\"; \/\/ #12\n+    Method #14 #15; \/\/ #13\n+    class #16; \/\/ #14\n+    NameAndType #17 #18; \/\/ #15\n+    Utf8 \"MyValue4\"; \/\/ #16\n+    Utf8 \"make\"; \/\/ #17\n+    Utf8 \"()LMyValue4;\"; \/\/ #18\n+    Utf8 \"Code\"; \/\/ #19\n+    Utf8 \"LineNumberTable\"; \/\/ #20\n+    Utf8 \"method\"; \/\/ #21\n+    Utf8 \"(Z)LMyValue4;\"; \/\/ #22\n+    Utf8 \"StackMapTable\"; \/\/ #23\n+    Utf8 \"SourceFile\"; \/\/ #24\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #25\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A03B500;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  220;\n+                4  221;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #21; \/\/ name_index\n+      #22; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#19) { \/\/ Code\n+          3; \/\/ max_stack\n+          4; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000501B0B800;\n+            0x0D4D033E1D100AA2;\n+            0x00132A59B4000704;\n+            0x60B50007840301A7;\n+            0xFFED2CB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#20) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  224;\n+                4  225;\n+                6  227;\n+                10  229;\n+                18  230;\n+                28  229;\n+                34  232;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#23) { \/\/ StackMapTable\n+              [] { \/\/ \n+                6b; \/\/ same_frame\n+                253b, 5, []z{O,14; I}; \/\/ append_frame 2\n+                250b, 21; \/\/ chop_frame 1\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#24) { \/\/ SourceFile\n+      #25;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class M\n+file \"N.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue5\"; \/\/ #10\n+    Utf8 \"make\"; \/\/ #11\n+    Utf8 \"()LMyValue5;\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"N\"; \/\/ #14\n+    Utf8 \"Code\"; \/\/ #15\n+    Utf8 \"LineNumberTable\"; \/\/ #16\n+    Utf8 \"method\"; \/\/ #17\n+    Utf8 \"(Z)LMyValue5;\"; \/\/ #18\n+    Utf8 \"StackMapTable\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  237;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000501B0B800;\n+            0x07B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  239;\n+                4  240;\n+                6  242;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#19) { \/\/ StackMapTable\n+              [] { \/\/ \n+                6b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class N\n+file \"O.class\" {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"MyValue6\"; \/\/ #10\n+    Utf8 \"make\"; \/\/ #11\n+    Utf8 \"()LMyValue6;\"; \/\/ #12\n+    class #14; \/\/ #13\n+    Utf8 \"O\"; \/\/ #14\n+    Utf8 \"Code\"; \/\/ #15\n+    Utf8 \"LineNumberTable\"; \/\/ #16\n+    Utf8 \"method\"; \/\/ #17\n+    Utf8 \"(Z)LMyValue6;\"; \/\/ #18\n+    Utf8 \"StackMapTable\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #13;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  247;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #17; \/\/ name_index\n+      #18; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#15) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x1B99000501B0B800;\n+            0x07B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#16) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  249;\n+                4  250;\n+                6  252;\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#19) { \/\/ StackMapTable\n+              [] { \/\/ \n+                6b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class O\n+class I6 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"I6\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"method\"; \/\/ #5\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #10\n+  } \/\/ Constant Pool\n+\n+  0x0600; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x01B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  259;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class I6\n+class P {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #6; \/\/ #9\n+    Utf8 \"MyValue7\"; \/\/ #10\n+    Utf8 \"verify\"; \/\/ #11\n+    class #13; \/\/ #12\n+    Utf8 \"P\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"I6\"; \/\/ #15\n+    Utf8 \"Code\"; \/\/ #16\n+    Utf8 \"LineNumberTable\"; \/\/ #17\n+    Utf8 \"method\"; \/\/ #18\n+    Utf8 \"(LMyValue7;)LMyValue7;\"; \/\/ #19\n+    Utf8 \"SourceFile\"; \/\/ #20\n+    Utf8 \"TestMismatchHandlingGenerator.java\"; \/\/ #21\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #12;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #14;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  263;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #18; \/\/ name_index\n+      #19; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ Code\n+          1; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2BB600072BB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#17) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  266;\n+                4  267;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#20) { \/\/ SourceFile\n+      #21;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class P\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestMismatchHandling.jcod","additions":3743,"deletions":0,"binary":false,"changes":3743,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test DirectMethodTest\n+ * @summary Test arguments to JVM_InvokeMethod not flattened into an args array.\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 26 DirectMethodTest.java\n+ * @run main\/othervm -Djdk.reflect.useNativeAccessorOnly=true -XX:+UseArrayFlattening -XX:+UseFieldFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening DirectMethodTest\n+ * @run main\/othervm -Djdk.reflect.useNativeAccessorOnly=true -XX:-UseArrayFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening DirectMethodTest\n+\n+ *\/\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import jdk.internal.value.ValueClass;\n+\n+public class DirectMethodTest {\n+\n+    public int method1(int i, int j, int k) {\n+        System.out.println(\"i = \" + i + \" j = \" + j + \" k = \" + k);\n+        return i + j * k;\n+    }\n+\n+    public static void printFlat(Object[] array) {\n+        if (!ValueClass.isFlatArray(array)) {\n+            System.out.println(\"not flat \" + array);\n+        } else {\n+            System.out.println(\"yay flat \" + array);\n+        }\n+    }\n+\n+    static value class SmallValue {\n+        byte b;\n+        short s;\n+\n+        SmallValue(short i) { b = 0; s = i; }\n+    }\n+\n+    public int method2(SmallValue i, SmallValue j, SmallValue k) {\n+        System.out.println(\"i = \" + i + \" j = \" + j + \" k = \" + k);\n+        return i.s + j.s * k.s;\n+    }\n+\n+    static final int ARRAY_SIZE = 3;\n+\n+    public static void main(java.lang.String[] unused) throws Exception {\n+        DirectMethodTest d = new DirectMethodTest();\n+\n+        Method m = DirectMethodTest.class.getMethod(\"method1\", int.class, int.class, int.class);\n+        Integer[] intarray = new Integer[]{1, 2, 3};  \/\/ is this flattened?\n+        printFlat(intarray);\n+        Object[] array = (Object[])Array.newInstance(Integer.class, 3);\n+        printFlat(array);\n+        array = ValueClass.newNullableAtomicArray(Integer.class, ARRAY_SIZE);\n+        printFlat(array);\n+        System.out.println(\"value is \" + m.invoke(d, 1, 2, 3));\n+\n+        Method m2 = DirectMethodTest.class.getMethod(\"method2\", SmallValue.class, SmallValue.class, SmallValue.class);\n+        Object[] smallValueArray = (Object[])Array.newInstance(SmallValue.class, ARRAY_SIZE);\n+        printFlat(smallValueArray);\n+        smallValueArray = ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+        printFlat(smallValueArray);\n+        System.out.println(\"value is \" + m2.invoke(d, new SmallValue((short)1), new SmallValue((short)2), new SmallValue((short)3)));\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/DirectMethodTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,556 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.RuntimeMXBean;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test FlatArraysTest\n+ * @summary Plain array test for Inline Types\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 26 FlatArraysTest.java\n+ * @run main\/othervm -XX:+UseArrayFlattening -XX:+UseFieldFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.FlatArraysTest\n+ * @run main\/othervm -XX:-UseArrayFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.FlatArraysTest\n+ *\/\n+\n+public class FlatArraysTest {\n+  static final int ARRAY_SIZE = 100;\n+  static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+  @LooselyConsistentValue\n+  static value class SmallValue {\n+      byte b;\n+      short s;\n+\n+      SmallValue() { b = 0 ;  s = 0; }\n+      SmallValue(byte b0, short s0) { b = b0; s = s0; }\n+\n+      public static Object getTestValue() { return new SmallValue(Byte.MIN_VALUE, Short.MIN_VALUE); }\n+\n+      public static boolean expectingFlatNullRestrictedArray() { return true; }\n+      public static boolean expectingFlatNullRestrictedAtomicArray() { return true; }\n+      public static boolean expectingFlatNullableAtomicArray() { return true; }\n+  }\n+\n+  @LooselyConsistentValue\n+  static value class MediumValue {\n+      int x;\n+      int y;\n+\n+      MediumValue() {\n+         x = 0;\n+         y = 0;\n+      }\n+      MediumValue(int x0, int y0) {\n+        x = x0;\n+        y = y0;\n+      }\n+\n+      public static Object getTestValue() {\n+        return new MediumValue(Integer.MIN_VALUE, Integer.MIN_VALUE);\n+      }\n+\n+      public static boolean expectingFlatNullRestrictedArray() { return true; }\n+      public static boolean expectingFlatNullRestrictedAtomicArray() { return true; }\n+      public static boolean expectingFlatNullableAtomicArray() { return false; }\n+  }\n+\n+  @LooselyConsistentValue\n+  static value class BigValue {\n+      long x;\n+      long y;\n+      long z;\n+\n+      BigValue() {\n+        x = 0;\n+        y = 0;\n+        z = 0;\n+      }\n+      BigValue(long x0, long y0, long z0) {\n+        x = x0;\n+        y = y0;\n+        z = z0;\n+      }\n+\n+      public static Object getTestValue() {\n+        return new BigValue(Long.MIN_VALUE, Long.MIN_VALUE, Long.MIN_VALUE);\n+      }\n+\n+      public static boolean expectingFlatNullRestrictedArray() { return true; }\n+      public static boolean expectingFlatNullRestrictedAtomicArray() { return false; }\n+      public static boolean expectingFlatNullableAtomicArray() { return false; }\n+  }\n+\n+  static void testNullFreeArray(Object[] array, Object value) {\n+    testErrorCases(array);\n+    assertNotNull(value, \"Test needs a not null value\");\n+    \/\/   Test 1 : check initial element value is not null\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertNotNull(array[i], \"Initial value must not be null\");\n+    }\n+    \/\/   Test 2 : try to write null\n+    for (int i = 0 ; i < array.length; i++) {\n+      try {\n+        array[i] = null;\n+        throw new RuntimeException(\"Missing NullPointerException\");\n+      } catch (NullPointerException e) { }\n+    }\n+    \/\/   Test 3 : overwrite initial value with new value\n+    for (int i = 0 ; i < array.length; i++) {\n+      array[i] = value;\n+    }\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertEquals(array[i], value);\n+    }\n+  }\n+\n+  static void testNullableArray(Object[] array, Object value) {\n+    testErrorCases(array);\n+    assertNotNull(value, \"Test needs a not null value\");\n+    \/\/   Test 1 : check that initial element value is null\n+    System.gc();\n+    System.out.println(\"Test 1\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertNull(array[i], \"Initial value should be null\");\n+    }\n+    \/\/   Test 2 : write new value to all elements\n+    System.gc();\n+    System.out.println(\"Test 2a\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      array[i] = value;\n+      assertEquals(array[i], value, \"Value mismatch\");\n+    }\n+    System.gc();\n+    System.out.println(\"Test 2b\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertEquals(array[i], value, \"Value mismatch\");\n+    }\n+    \/\/   Test 3 : write null to all elements\n+    System.gc();\n+    System.out.println(\"Test 3a\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      array[i] = null;\n+    }\n+    System.gc();\n+    System.out.println(\"Test 3b\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertNull(array[i], \"Value mismatch\");\n+    }\n+    \/\/   Test 4 : write alternate null \/ not null values\n+    System.gc();\n+    System.out.println(\"Test 4a\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      if (i%2 == 0) {\n+        array[i] = null;\n+      } else {\n+        array[i] = value;\n+      }\n+    }\n+    System.gc();\n+    System.out.println(\"Test 4b\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      if (i%2 == 0) {\n+        assertNull(array[i], \"Value mismatch\");\n+      } else {\n+        assertEquals(array[i], value, \"Value mismatch\");\n+      }\n+    }\n+  }\n+\n+  static void testErrorCases(Object[] array) {\n+    try {\n+      Object o = array[-1];\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+\n+    try {\n+      Object o = array[array.length];\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+\n+    assertTrue(array.getClass().getComponentType() != String.class, \"Must be for the test\");\n+    assertTrue(array.length > 0, \"Must be for the test\");\n+    try {\n+      array[0] = new String(\"Bad\");\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+  }\n+\n+  static void testArrayCopy() {\n+\n+    Object[] objArray = new Object[ARRAY_SIZE];\n+    for (int i = 0; i < ARRAY_SIZE; i++) {\n+      objArray[i] = SmallValue.getTestValue();\n+    }\n+    SmallValue[] nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    SmallValue[] atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    SmallValue[] nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    \/\/ obj -> non-atomic\n+    testArrayCopyInternal(objArray, nonAtomicArray);\n+\n+    \/\/ obj -> atomic\n+    testArrayCopyInternal(objArray, atomicArray);\n+\n+    \/\/ obj -> nullable\n+    testArrayCopyInternal(objArray, nullableArray);\n+\n+    objArray[45] = null;\n+    \/\/ obj with null -> non-atomic   => NPE\n+    try {\n+      testArrayCopyInternal(objArray, nonAtomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ obj with null -> atomic       => NPE\n+    try {\n+      testArrayCopyInternal(objArray, atomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ obj with null -> nullable\n+    try {\n+      testArrayCopyInternal(objArray, nullableArray);\n+    } catch (NullPointerException e) {\n+      throw new RuntimeException(\"Unexpected NullPointerException\");\n+    }\n+\n+    objArray[45] = new String(\"bad\");\n+    \/\/ obj with wrong type value -> non-atomic   => ASE\n+    try {\n+      testArrayCopyInternal(objArray, nonAtomicArray);\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+\n+    \/\/ obj with wrong type value -> atomic       => ASE\n+    try {\n+      testArrayCopyInternal(objArray, atomicArray);\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+\n+    \/\/ obj with wrong type value -> nullable     => ASE\n+    try {\n+      testArrayCopyInternal(objArray, nullableArray);\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+\n+    \/\/ Reset all arrays\n+    objArray = new Object[ARRAY_SIZE];\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    \/\/ non-atomic -> obj\n+    testArrayCopyInternal(nonAtomicArray, objArray);\n+\n+    \/\/ non-atomic -> non-atomic\n+    SmallValue[] nonAtomicArray2 = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    testArrayCopyInternal(nonAtomicArray, nonAtomicArray2);\n+\n+    \/\/ non-atomic -> non-atomic same array\n+    testArrayCopyInternal(nonAtomicArray, nonAtomicArray);\n+\n+    \/\/ non-atomic -> atomic\n+    testArrayCopyInternal(nonAtomicArray, atomicArray);\n+\n+    \/\/ non-atomic -> nullable\n+    testArrayCopyInternal(nonAtomicArray, nullableArray);\n+\n+    \/\/ Reset all arrays\n+    objArray = new Object[ARRAY_SIZE];\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    for (int i = 0 ; i < ARRAY_SIZE; i++) {\n+      atomicArray[i] = (SmallValue)SmallValue.getTestValue();\n+    }\n+\n+    \/\/ atomic -> obj\n+    testArrayCopyInternal(atomicArray, objArray);\n+\n+    \/\/ atomic -> non-atomic\n+    testArrayCopyInternal(atomicArray, nonAtomicArray);\n+\n+    \/\/ atomic -> atomic\n+    SmallValue[] atomicArray2 = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    testArrayCopyInternal(atomicArray, atomicArray2);\n+\n+    \/\/ atomic -> atomic same array\n+    testArrayCopyInternal(atomicArray, atomicArray);\n+\n+    \/\/ atomic -> nullable\n+    testArrayCopyInternal(atomicArray, nullableArray);\n+\n+    \/\/ Reset all arrays\n+    objArray = new Object[ARRAY_SIZE];\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE, new SmallValue());\n+    nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    for (int i = 0 ; i < ARRAY_SIZE; i++) {\n+      nullableArray[i] = (SmallValue)SmallValue.getTestValue();\n+    }\n+\n+    \/\/ nullable -> obj\n+    testArrayCopyInternal(nullableArray, objArray);\n+\n+    \/\/ nullable -> non-atomic\n+    testArrayCopyInternal(nullableArray, nonAtomicArray);\n+\n+    \/\/ nullable -> atomic\n+    testArrayCopyInternal(nullableArray, atomicArray);\n+\n+    \/\/ nullable -> nullable\n+    SmallValue[] nullableArray2 = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    testArrayCopyInternal(nullableArray, nullableArray2);\n+\n+    \/\/ nullable -> nullable same array\n+    testArrayCopyInternal(nullableArray, nullableArray);\n+\n+    nullableArray[45] = null;\n+\n+    \/\/ nullable with null -> obj\n+    testArrayCopyInternal(nullableArray, objArray);\n+\n+    \/\/ nullable with null -> non-atomic  => NPE\n+    try {\n+      testArrayCopyInternal(nullableArray, nonAtomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ nullable with null -> atomic      => NPE\n+    try {\n+      testArrayCopyInternal(nullableArray, atomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ nullable with null -> nullable\n+    nullableArray2 = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    testArrayCopyInternal(nullableArray, nullableArray2);\n+\n+    \/\/ nullable with null -> nullable same array\n+    testArrayCopyInternal(nullableArray, nullableArray);\n+  }\n+\n+  static void testArrayCopyInternal(Object[] src, Object[] dst) {\n+    \/\/ When using this method for cases that should trigger a NPE or an ASE,\n+    \/\/ it is recommended to put the faulty value at index 45 in the src array\n+    assertTrue(src.length >= ARRAY_SIZE, \"Must be for the test\");\n+    assertTrue(dst.length >= ARRAY_SIZE, \"Must be for the test\");\n+    \/\/ Test 1 : good copy without indexes overlap\n+    System.arraycopy(src, 3, dst, 51, 40);\n+    for (int i = 0; i < 40; i++) {\n+      assertEquals(src[3+i], dst[51+i], \"Mismatch after copying\");\n+    }\n+    \/\/ Test 2 : good copy with indexes overlap\n+    System.arraycopy(src, 42, dst, 53, 45);\n+    if (src != dst) {  \/\/ Verification doesn't make sense if src and dst are the same\n+      for (int i = 0; i < 45; i++) {\n+        assertEquals(src[42+i], dst[53+i], \"Mismatch after copying\");\n+      }\n+    }\n+    \/\/ Test 3 : IOOB errors\n+    try {\n+      System.arraycopy(src, -1, dst, 3, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+    try {\n+      System.arraycopy(src, src.length - 5, dst, 3, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+    try {\n+      System.arraycopy(src, 10, dst, -1, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+    try {\n+      System.arraycopy(src, 10, dst, dst.length - 5, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+  }\n+\n+  static void testArrayAccesses() throws NoSuchMethodException, InstantiationException,\n+  IllegalAccessException, InvocationTargetException {\n+    RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();\n+    List<String> arguments = runtimeMxBean.getInputArguments();\n+    boolean UseArrayFlattening = !arguments.contains(\"-XX:-UseArrayFlattening\");\n+    System.out.println(\"UseArrayFlattening: \" + UseArrayFlattening);\n+    Class[] valueClasses = {SmallValue.class, MediumValue.class, BigValue.class};\n+    for (Class c: valueClasses) {\n+      System.out.println(\"Testing class \" + c.getName());\n+      Method gtv = c.getMethod(\"getTestValue\", null);\n+      Object o = gtv.invoke(null, null);\n+      assertNotNull(o);\n+\n+      System.out.println(\"Regular reference array\");\n+      Object[] array = (Object[])Array.newInstance(c, ARRAY_SIZE);\n+      Method ef = c.getMethod(\"expectingFlatNullableAtomicArray\", null);\n+      boolean expectFlat = (Boolean) ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (UseArrayFlattening && expectFlat));\n+      testNullableArray(array, o);\n+\n+      System.out.println(\"NonAtomic NullRestricted array\");\n+      array = ValueClass.newNullRestrictedNonAtomicArray(c, ARRAY_SIZE, c.newInstance());\n+      ef = c.getMethod(\"expectingFlatNullRestrictedArray\", null);\n+      expectFlat = (Boolean)ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (UseArrayFlattening && expectFlat));\n+      testNullFreeArray(array, o);\n+\n+      System.out.println(\"NullRestricted Atomic array\");\n+      array = ValueClass.newNullRestrictedAtomicArray(c, ARRAY_SIZE, c.newInstance());\n+      ef = c.getMethod(\"expectingFlatNullRestrictedAtomicArray\", null);\n+      expectFlat = (Boolean)ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (UseArrayFlattening && expectFlat));\n+      testNullFreeArray(array, o);\n+\n+      System.out.println(\"Nullable Atomic array\");\n+      array = ValueClass.newNullableAtomicArray(c, ARRAY_SIZE);\n+      ef = c.getMethod(\"expectingFlatNullableAtomicArray\", null);\n+      expectFlat = (Boolean)ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (UseArrayFlattening && expectFlat));\n+      testNullableArray(array, o);\n+    }\n+  }\n+\n+  static value class AtomicValue {\n+    int i = 0;\n+  }\n+\n+  static value class FieldsHolder {\n+    @NullRestricted\n+    SmallValue sv = new SmallValue();\n+\n+    @NullRestricted\n+    AtomicValue av = new AtomicValue();\n+\n+    AtomicValue nav = new AtomicValue();\n+  }\n+\n+  static void testSpecialArrayLayoutFromArray(Object[] array, boolean expectException) {\n+    int lk = UNSAFE.arrayLayout(array);\n+    boolean exception = false;\n+    try {\n+      Object[] newArray = UNSAFE.newSpecialArray(array.getClass().getComponentType(), 10, lk);\n+      int newLk = UNSAFE.arrayLayout(newArray);\n+      assertEquals(newLk, lk);\n+    } catch(IllegalArgumentException e) {\n+      e.printStackTrace();\n+      exception = true;\n+    }\n+    assertEquals(exception, expectException, \"Exception not matching expectations\");\n+  }\n+\n+  static void testSpecialArrayFromFieldLayout(Class c, int layout, boolean expectException) {\n+    boolean exception = false;\n+    try {\n+      Object[] array = UNSAFE.newSpecialArray(c, 10, layout);\n+      int lk = UNSAFE.arrayLayout(array);\n+      assertEquals(lk, layout);\n+    } catch (IllegalArgumentException e) {\n+      e.printStackTrace();\n+      throw new RuntimeException(e);\n+    } catch (UnsupportedOperationException e) {\n+      e.printStackTrace();\n+      exception = true;\n+    }\n+    assertEquals(exception, expectException, \"Exception not matching expectations\");\n+  }\n+\n+  static void testSpecialArrayCreation() {\n+    RuntimeMXBean runtimeMXBean = ManagementFactory.getRuntimeMXBean();\n+    List<String> jvmArgs = runtimeMXBean.getInputArguments();\n+    boolean arrayFlatteningEnabled = true;\n+    for (String s : jvmArgs) {\n+      if (s.compareTo(\"-XX:-UseArrayFlattening\") == 0) arrayFlatteningEnabled = false;\n+    }\n+\n+    \/\/ Test array creation from another array\n+    Object[] array0 = new SmallValue[10];\n+    testSpecialArrayLayoutFromArray(array0, !arrayFlatteningEnabled);\n+    if (arrayFlatteningEnabled) {\n+      Object[] array1 = ValueClass.newNullRestrictedNonAtomicArray(SmallValue.class, 10, new SmallValue());\n+      testSpecialArrayLayoutFromArray(array1, false);\n+      Object[] array2 = ValueClass.newNullRestrictedAtomicArray(SmallValue.class, 10, new SmallValue());\n+      testSpecialArrayLayoutFromArray(array2, false);\n+      Object[] array3 = ValueClass.newNullableAtomicArray(SmallValue.class, 10);\n+      testSpecialArrayLayoutFromArray(array3, false);\n+    }\n+\n+    \/\/ Test array creation from a field layout\n+    try {\n+      Class c = FieldsHolder.class;\n+      Field f0 = c.getDeclaredField(\"sv\");\n+      int layout0 = UNSAFE.fieldLayout(f0);\n+      testSpecialArrayFromFieldLayout(f0.getType(), layout0, !arrayFlatteningEnabled);\n+      Field f1 = c.getDeclaredField(\"av\");\n+      int layout1 = UNSAFE.fieldLayout(f1);\n+      testSpecialArrayFromFieldLayout(f1.getType(), layout1, !arrayFlatteningEnabled);\n+      Field f2 = c.getDeclaredField(\"nav\");\n+      int layout2 = UNSAFE.fieldLayout(f2);\n+      testSpecialArrayFromFieldLayout(f2.getType(), layout2, !arrayFlatteningEnabled);\n+    } catch(NoSuchFieldException e) {\n+      e.printStackTrace();\n+    }\n+\n+    \/\/ Testing an invalid layout value\n+    boolean exception = false;\n+    try {\n+      UNSAFE.newSpecialArray(SmallValue.class, 10, 100);\n+    } catch(IllegalArgumentException e) {\n+      e.printStackTrace();\n+      exception = true;\n+    }\n+    assertEquals(exception, true, \"Exception not received\");\n+  }\n+\n+  public static void main(String[] args) throws NoSuchMethodException, InstantiationException,\n+                                                IllegalAccessException, InvocationTargetException {\n+    testArrayAccesses();\n+    testArrayCopy();\n+    testSpecialArrayCreation();\n+  }\n+\n+ }\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlatArraysTest.java","additions":556,"deletions":0,"binary":false,"changes":556,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package runtime.valhalla.inlinetypes;\n+\n+import java.lang.ref.*;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+\n+\n+\/*\n+ * @test Ifacmp\n+ * @requires vm.gc == null\n+ * @summary if_acmpeq\/ne bytecode test\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile --source 26 Ifacmp.java\n+ * @run main\/othervm -Xms16m -Xmx16m -XX:+UseSerialGC runtime.valhalla.inlinetypes.Ifacmp\n+ *\/\n+public class Ifacmp {\n+\n+    @LooselyConsistentValue\n+    static value class MyValue {\n+        int value;\n+        public MyValue(int v) { this.value = v; }\n+    };\n+\n+    @LooselyConsistentValue\n+    static value class MyValue2 {\n+        int value;\n+        public MyValue2(int v) { this.value = v; }\n+    };\n+\n+    boolean acmpModeInlineAlwaysFalse = false;\n+\n+    Object aNull = null;\n+    Object bNull = null;\n+\n+    Object aObject = new String(\"Hi\");\n+    Object bObject = new String(\"Hi\");\n+\n+    Object aValue = new MyValue(1);\n+    Object bValue = new MyValue(1);\n+    Object cValue = new MyValue(0);\n+    Object aValue2 = new MyValue2(4711);\n+\n+    Object[][] equalUseCases = {\n+        { aNull, bNull },\n+        { aObject, aObject },\n+        { aValue, bValue },\n+        { cValue, cValue },\n+        { aValue2, aValue2 }\n+    };\n+\n+    int objectEqualsUseCases = 2; \/\/ Nof object equals use cases\n+\n+    \/\/ Would just generate these fail case from the \"equal set\" above,\n+    \/\/ but to do so needs ==, so write out by hand it is...\n+    Object[][] notEqualUseCases = {\n+        { aNull, aObject },\n+        { aNull, bObject },\n+        { aNull, aValue },\n+        { aNull, bValue },\n+        { aNull, cValue },\n+        { aNull, aValue2 },\n+        { aObject, bObject },\n+        { aObject, aValue },\n+        { aObject, bValue },\n+        { aObject, cValue },\n+        { aObject, aValue2 },\n+        { bObject, cValue },\n+        { bObject, aValue2 },\n+        { aValue, cValue },\n+        { aValue, aValue2 },\n+    };\n+\n+    public Ifacmp() { this(false); }\n+    public Ifacmp(boolean acmpModeInlineAlwaysFalse) {\n+        this.acmpModeInlineAlwaysFalse = acmpModeInlineAlwaysFalse;\n+        if (acmpModeInlineAlwaysFalse) {\n+            System.out.println(\"ifacmp always false for inline types\");\n+        } else {\n+            System.out.println(\"ifacmp substitutability inline types\");\n+        }\n+    }\n+\n+    public void test() {\n+        testAllUseCases();\n+    }\n+\n+    public void testUntilGc(int nofGc) {\n+        for (int i = 0; i < nofGc; i++) {\n+            System.out.println(\"GC num \" + (i + 1));\n+            testUntilGc();\n+        }\n+    }\n+\n+    public void testUntilGc() {\n+        Reference ref = new WeakReference<Object>(new Object(), new ReferenceQueue<>());\n+        do {\n+            test();\n+        } while (ref.get() != null);\n+    }\n+\n+    public void testAllUseCases() {\n+        int useCase = 0;\n+        for (Object[] pair : equalUseCases) {\n+            useCase++;\n+            boolean equal = acmpModeInlineAlwaysFalse ? (useCase <= objectEqualsUseCases) : true;\n+            checkEqual(pair[0], pair[1], equal);\n+        }\n+        for (Object[] pair : notEqualUseCases) {\n+            checkEqual(pair[0], pair[1], false);\n+        }\n+        testLocalValues();\n+        testAlot();\n+    }\n+\n+    public void testValues() {\n+        checkEqual(aValue, bValue, true);\n+\n+        checkEqual(aValue, cValue, false);\n+        checkEqual(aValue, aValue2, false);\n+        checkEqual(aValue2, bValue, false);\n+        checkEqual(aValue2, cValue, false);\n+        testLocalValues();\n+    }\n+\n+    public void testLocalValues() {\n+        \/\/ \"aload + ifacmp\" should be same as \"aaload + ifamcp\"\n+        \/\/ but let's be paranoid...\n+        MyValue a = new MyValue(11);\n+        MyValue b = new MyValue(11);\n+        MyValue c = a;\n+        MyValue a1 = new MyValue(7);\n+        MyValue2 a2 = new MyValue2(13);\n+\n+        if (acmpModeInlineAlwaysFalse) {\n+            if (a == b) throw new RuntimeException(\"Always false fail \" + a + \" == \" + b);\n+            if (a == c) throw new RuntimeException(\"Always false fail \" + a + \" == \" + c);\n+        } else {\n+            if (a != b) throw new RuntimeException(\"Substitutability test failed\" + a + \" != \" + b);\n+            if (a != c) throw new RuntimeException(\"Substitutability test failed\");\n+        }\n+        if (a == a1) throw new RuntimeException();\n+        checkEqual(a, a2, false);\n+    }\n+\n+    public void testAlot() {\n+        MyValue a = new MyValue(4711);\n+        Reference ref = new WeakReference<Object>(new Object(), new ReferenceQueue<>());\n+        do {\n+            for (int i = 0; i < 1000; i++) {\n+                MyValue b = new MyValue(4711);\n+                if (acmpModeInlineAlwaysFalse) {\n+                    if (a == b) throw new RuntimeException(\"Always false fail \" + a + \" == \" + b);\n+                } else {\n+                    if (a != b) throw new RuntimeException(\"Substitutability test failed\" + a + \" != \" + b);\n+                }\n+            }\n+            System.gc();\n+        } while (ref.get() != null);\n+    }\n+\n+    boolean shouldEqualSelf(Object a) {\n+        return acmpModeInlineAlwaysFalse ? (!(a != null && a.getClass().isValue())) : true;\n+    }\n+\n+    void checkEqual(Object a, Object b, boolean isEqual) {\n+        testEquals(a, a, shouldEqualSelf(a));\n+        testEquals(b, b, shouldEqualSelf(b));\n+        testEquals(a, b, isEqual);\n+        testNotEquals(a, b, !isEqual);\n+    }\n+\n+    public static void testEquals(Object a, Object b, boolean expected) {\n+        boolean isEqual = (a == b);\n+        if (isEqual != expected) {\n+            throw new RuntimeException(\"Expected \" + expected + \" : \"\n+                                       + a + \" == \" + b);\n+        }\n+    }\n+\n+    public static void testNotEquals(Object a, Object b, boolean expected) {\n+        boolean isNotEqual = (a != b);\n+        if (isNotEqual != expected) {\n+            throw new RuntimeException(\"Expected \" + expected + \" : \"\n+                                       + a + \" != \" + b);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        boolean inlineTypesAlwaysFalse = (args.length > 0) && args[0].equals(\"alwaysFalse\");\n+        new Ifacmp(inlineTypesAlwaysFalse).test();\n+        new Ifacmp(inlineTypesAlwaysFalse).testUntilGc(3);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/Ifacmp.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,869 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test InlineTypeArray\n+ * @summary Plain array test for Inline Types\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 26 InlineTypeArray.java Point.java Long8Inline.java Person.java\n+ * @run main\/othervm -XX:+UseArrayFlattening -XX:+UseFieldFlattening runtime.valhalla.inlinetypes.InlineTypeArray\n+ * @run main\/othervm -XX:-UseArrayFlattening runtime.valhalla.inlinetypes.InlineTypeArray\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:ForceNonTearable=* runtime.valhalla.inlinetypes.InlineTypeArray\n+ * @run main\/othervm -XX:+UseArrayFlattening -XX:+UseFieldFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.InlineTypeArray\n+ *\/\n+public class InlineTypeArray {\n+    public static void main(String[] args) {\n+        InlineTypeArray inlineTypeArray = new InlineTypeArray();\n+        inlineTypeArray.run();\n+    }\n+\n+    public void run() {\n+        testClassForName();\n+        testSimplePointArray();\n+        testLong8Array();\n+        testMixedPersonArray();\n+        testMultiDimPointArray();\n+        testComposition();\n+\n+        testSanityCheckcasts();\n+        testObjectArrayOfInlines();\n+\n+        testReflectArray();\n+        testUtilArraysOnNullRestrictedNonAtomicArrays();\n+        testUtilArraysOnNullRestrictedAtomicArrays();\n+        testUtilArraysOnNullableAtomicArrays();\n+\n+        testInlineArrayOom();\n+    }\n+\n+    void testClassForName() {\n+        String arrayClsName = \"[Lruntime.valhalla.inlinetypes.Point;\";\n+        try {\n+            Class<?> arrayCls = Class.forName(arrayClsName);\n+            assertTrue(arrayCls.isArray(), \"Expected an array class\");\n+\n+            arrayClsName = \"[\" + arrayClsName;\n+            Class<?> mulArrayCls = Class.forName(arrayClsName);\n+            assertTrue(mulArrayCls.isArray());\n+            assertTrue(mulArrayCls.getComponentType() == arrayCls);\n+        }\n+        catch (ClassNotFoundException cnfe) {\n+            fail(\"Class.forName(\" + arrayClsName + \") failed\", cnfe);\n+        }\n+    }\n+\n+    void testSimplePointArray() {\n+        Point[] defaultPoint = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, 1, new Point(0, 0));\n+        Point p = defaultPoint[0];\n+        assertEquals(p.x, 0, \"invalid default loaded from array\");\n+        assertEquals(p.y, 0, \"invalid default loaded from array\");\n+        boolean gotNpe = false;\n+        try {\n+            defaultPoint[0] = (Point) getNull();\n+        } catch (NullPointerException npe) {\n+            gotNpe = true;\n+        }\n+        assertTrue(gotNpe, \"Expected NullPointerException\");\n+\n+        Point[] points = createSimplePointArray();\n+        System.gc(); \/\/ check that VTs survive GC\n+        checkSimplePointArray(points);\n+        assertTrue(points instanceof Point[], \"Instance of\");\n+\n+        testSimplePointArrayCopy();\n+\n+        \/\/ Locked\/unlocked flat array type checks\n+        points = createSimplePointArray();\n+        Point[] pointsCopy = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, points.length, new Point(0, 0));\n+        synchronized (points) {\n+            assertTrue(points instanceof Point[], \"Instance of\");\n+            checkSimplePointArray(points);\n+            System.arraycopy(points, 0, pointsCopy, 0, points.length);\n+            synchronized (pointsCopy) {\n+                assertTrue(pointsCopy instanceof Point[], \"Instance of\");\n+                checkSimplePointArray(pointsCopy);\n+                System.gc();\n+            }\n+            System.gc();\n+        }\n+        assertTrue(pointsCopy instanceof Point[], \"Instance of\");\n+        checkSimplePointArray(pointsCopy);\n+    }\n+\n+    void testSimplePointArrayCopy() {\n+        Point[] points = createSimplePointArray();\n+        Point[] pointsCopy = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, points.length, new Point(0, 0));\n+        System.arraycopy(points, 0, pointsCopy, 0, points.length);\n+        checkSimplePointArray(pointsCopy);\n+\n+        \/\/ Conjoint, overlap...left\n+        System.arraycopy(points, 0, points, 1, 2);\n+        checkArrayElementsEqual(points, new Point[] { pointsCopy[0], pointsCopy[0], pointsCopy[1], pointsCopy[3] });\n+\n+        \/\/ Conjoint, overlap...right\n+        points = createSimplePointArray();\n+        System.arraycopy(points, 2, points, 1, 2);\n+        checkArrayElementsEqual(points, new Point[] { pointsCopy[0], pointsCopy[2], pointsCopy[3], pointsCopy[3] });\n+    }\n+\n+    static Point[] createSimplePointArray() {\n+        Point[] ps = (Point[])ValueClass.newNullRestrictedNonAtomicArray(Point.class, 4, new Point(0, 0));\n+        assertEquals(ps.length, 4, \"Length\");\n+        ps.toString();\n+        ps[0] = new Point(1, 2);\n+        ps[1] = new Point(3, 4);\n+        ps[2] = new Point(5, 6);\n+        ps[3] = new Point(7, 8);\n+        boolean sawOob = false;\n+        try {\n+            ps[ps.length] = new Point(0, 0);\n+        } catch (ArrayIndexOutOfBoundsException aioobe) { sawOob = true; }\n+        assertTrue(sawOob, \"Didn't see AIOOBE\");\n+        return ps;\n+    }\n+\n+    static void checkSimplePointArray(Point[] points) {\n+        assertEquals(points[0].x, 1, \"invalid 0 point x value\");\n+        assertEquals(points[0].y, 2, \"invalid 0 point y value\");\n+        assertEquals(points[1].x, 3, \"invalid 1 point x value\");\n+        assertEquals(points[1].y, 4, \"invalid 1 point y value\");\n+        assertEquals(points[2].x, 5, \"invalid 2 point x value\");\n+        assertEquals(points[2].y, 6, \"invalid 2 point y value\");\n+        assertEquals(points[3].x, 7, \"invalid 3 point x value\");\n+        assertEquals(points[3].y, 8, \"invalid 3 point y value\");\n+    }\n+\n+    void testLong8Array() {\n+        Long8Inline[] values = (Long8Inline[])ValueClass.newNullRestrictedNonAtomicArray(Long8Inline.class, 3, new Long8Inline());\n+        assertEquals(values.length, 3, \"length\");\n+        values.toString();\n+        Long8Inline value = values[1];\n+        long zl = 0;\n+        Long8Inline.check(value, zl, zl, zl, zl, zl, zl, zl, zl);\n+        values[1] = new Long8Inline(1, 2, 3, 4, 5, 6, 7, 8);\n+        value = values[1];\n+        Long8Inline.check(value, 1, 2, 3, 4, 5, 6, 7, 8);\n+\n+        Long8Inline[] copy = (Long8Inline[])ValueClass.newNullRestrictedNonAtomicArray(Long8Inline.class, values.length, new Long8Inline());\n+        System.arraycopy(values, 0, copy, 0, values.length);\n+        value = copy[1];\n+        Long8Inline.check(value, 1, 2, 3, 4, 5, 6, 7, 8);\n+    }\n+\n+    void testMixedPersonArray() {\n+        Person[] people = (Person[])ValueClass.newNullRestrictedNonAtomicArray(Person.class, 3, new Person(0, null, null));\n+\n+        people[0] = new Person(1, \"First\", \"Last\");\n+        assertEquals(people[0].getId(), 1, \"Invalid Id person\");\n+        assertEquals(people[0].getFirstName(), \"First\", \"Invalid First Name\");\n+        assertEquals(people[0].getLastName(), \"Last\", \"Invalid Last Name\");\n+\n+        people[1] = new Person(2, \"Jane\", \"Wayne\");\n+        people[2] = new Person(3, \"Bob\", \"Dobalina\");\n+\n+        Person[] peopleCopy = (Person[])ValueClass.newNullRestrictedNonAtomicArray(Person.class, people.length, new Person(0, null, null));\n+        System.arraycopy(people, 0, peopleCopy, 0, people.length);\n+        assertEquals(peopleCopy[2].getId(), 3, \"Invalid Id\");\n+        assertEquals(peopleCopy[2].getFirstName(), \"Bob\", \"Invalid First Name\");\n+        assertEquals(peopleCopy[2].getLastName(), \"Dobalina\", \"Invalid Last Name\");\n+    }\n+\n+    void testMultiDimPointArray() {\n+        \/*\n+        Point[][][] multiPoints = new Point[2][3][4];\n+        assertEquals(multiPoints.length, 2, \"1st dim length\");\n+        assertEquals(multiPoints[0].length, 3, \"2st dim length\");\n+        assertEquals(multiPoints[0][0].length, 4, \"3rd dim length\");\n+\n+        Point defaultPoint = multiPoints[1][2][3];\n+        assertEquals(defaultPoint.x, 0, \"invalid point x value\");\n+        assertEquals(defaultPoint.y, 0, \"invalid point x value\");\n+        *\/\n+    }\n+\n+    void testReflectArray() {\n+        \/\/ Check the java.lang.reflect.Array.newInstance methods...\n+        Class<?> cls = (Class<?>) Point[].class;\n+        Point[][] array = (Point[][]) Array.newInstance(cls, 1);\n+        assertEquals(array.length, 1, \"Incorrect length\");\n+        assertTrue(array[0] == null, \"Expected NULL\");\n+\n+        Point[][][] array3 = (Point[][][]) Array.newInstance(cls, 1, 2);\n+        assertEquals(array3.length, 1, \"Incorrect length\");\n+        assertEquals(array3[0].length, 2, \"Incorrect length\");\n+        assertTrue(array3[0][0] == null, \"Expected NULL\");\n+\n+        \/\/ Now create ObjArrays of InlineArray...\n+        Point[][] barray = (Point[][]) Array.newInstance(Point.class, 1, 2);\n+        assertEquals(barray.length, 1, \"Incorrect length\");\n+        assertEquals(barray[0].length, 2, \"Incorrect length\");\n+        barray[0][1] = new Point(1, 2);\n+        Point pb = barray[0][1];\n+        int x = pb.getX();\n+        assertEquals(x, 1, \"Bad Point Value\");\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyInt implements Comparable<MyInt> {\n+        int value;\n+\n+        private MyInt() { this(0); }\n+        private MyInt(int v) { value = v; }\n+        public int getValue() { return value; }\n+        public String toString() { return \"MyInt: \" + getValue(); }\n+        public int compareTo(MyInt that) { return Integer.compare(this.getValue(), that.getValue()); }\n+        public boolean equals(Object o) {\n+            if (o instanceof MyInt) {\n+                return this.getValue() == ((MyInt) o).getValue();\n+            }\n+            return false;\n+        }\n+\n+        public static MyInt create(int v) {\n+            return new MyInt(v);\n+        }\n+\n+        public static final MyInt MIN = MyInt.create(Integer.MIN_VALUE);\n+        public static final MyInt ZERO = MyInt.create(0);\n+        public static final MyInt MAX = MyInt.create(Integer.MAX_VALUE);\n+    }\n+\n+    static MyInt staticMyInt;\n+    static MyInt[] staticMyIntArray;\n+    static MyInt[][] staticMyIntArrayArray;\n+\n+    static {\n+        staticMyInt = MyInt.create(-1);\n+        staticMyIntArray = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 1, new MyInt());\n+        staticMyIntArray[0] = staticMyInt;\n+        staticMyIntArrayArray = new MyInt[][] { staticMyIntArray, staticMyIntArray };\n+    }\n+\n+    static value class MyShorts implements Comparable<MyShorts> {\n+        short s0, s1;\n+\n+        private MyShorts() { this((short)0, (short)0); }\n+        private MyShorts(short sa, short sb) { s0 = sa; s1 = sb; }\n+        public short getS0() { return s0; }\n+        public short getS1() { return s1; }\n+        public String toString() { return \"MyShorts: \" + getS0() + \" \" + getS1(); }\n+        public int compareTo(MyShorts that) {\n+            int r = Short.compare(this.getS0(), that.getS0());\n+            return r != 0 ? r : Short.compare(this.getS1(), that.getS1());\n+        }\n+        public boolean equals(Object o) {\n+            if (o instanceof MyShorts) {\n+                return this.getS0() == ((MyShorts) o).getS0() && this.getS1() == ((MyShorts) o).getS1();\n+            }\n+            return false;\n+        }\n+\n+        public static MyShorts create(short s0, short s1) {\n+            return new MyShorts(s0, s1);\n+        }\n+\n+        public static final MyShorts MIN = MyShorts.create(Short.MIN_VALUE, Short.MIN_VALUE);\n+        public static final MyShorts ZERO = MyShorts.create((short)0, (short)0);\n+        public static final MyShorts MAX = MyShorts.create(Short.MAX_VALUE, Short.MAX_VALUE);\n+    }\n+\n+    static interface SomeSecondaryType {\n+        default String hi() { return \"Hi\"; }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyOtherInt implements SomeSecondaryType {\n+        final int value;\n+        private MyOtherInt() { value = 0; }\n+    }\n+\n+    void testSanityCheckcasts() {\n+        MyInt[] myInts = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 1, new MyInt());\n+        assertTrue(myInts instanceof Object[]);\n+        assertTrue(myInts instanceof Comparable[]);\n+        assertTrue(myInts instanceof MyInt[]);\n+\n+        Class<?> cls = MyInt.class;\n+        assertTrue(cls.isValue());\n+        Object arrObj = Array.newInstance(cls, 1);\n+        assertTrue(arrObj instanceof Object[], \"Not Object array\");\n+        assertTrue(arrObj instanceof Comparable[], \"Not Comparable array\");\n+        assertTrue(arrObj instanceof MyInt[], \"Not MyInt array\");\n+\n+        Object[] arr = (Object[]) arrObj;\n+        assertTrue(arr instanceof Comparable[], \"Not Comparable array\");\n+        assertTrue(arr instanceof MyInt[], \"Not MyInt array\");\n+        Comparable[] comparables = (Comparable[])arr;\n+        MyInt[] myIntArr = (MyInt[]) arr;\n+\n+        \/\/ multi-dim, check secondary array types are setup...\n+        MyOtherInt[][] matrix = new MyOtherInt[1][1];\n+        assertTrue(matrix[0] instanceof MyOtherInt[]);\n+        assertTrue(matrix[0] instanceof SomeSecondaryType[]);\n+        assertTrue(matrix[0] instanceof MyOtherInt[]);\n+\n+        \/\/ Box types vs Inline...\n+        MyInt[] myValueRefs = new MyInt[1];\n+        assertTrue(myValueRefs instanceof MyInt[]);\n+        assertTrue(myValueRefs instanceof Object[]);\n+        assertTrue(myValueRefs instanceof Comparable[]);\n+\n+        MyInt[][] myMdValueRefs = new MyInt[1][1];\n+        assertTrue(myMdValueRefs[0] instanceof MyInt[]);\n+        assertTrue(myMdValueRefs[0] instanceof Object[]);\n+        assertTrue(myMdValueRefs[0] instanceof Comparable[]);\n+\n+        \/\/ Did we break checkcast...\n+        MyInt[]     va1 = (MyInt[])null;\n+        MyInt[]     va2 = null;\n+        MyInt[][]   va3 = (MyInt[][])null;\n+        MyInt[][][] va4 = (MyInt[][][])null;\n+    }\n+\n+\n+    void testUtilArraysOnNullRestrictedNonAtomicArrays() {\n+        \/\/ Sanity check j.u.Arrays\n+\n+        \/\/ Testing Arrays.copyOf()\n+        MyInt[] myInts = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n+        myInts[0] = MyInt.MAX;\n+        myInts[1] = MyInt.MIN;\n+        myInts[2] = MyInt.ZERO;\n+\n+        \/\/ Copy of same length, must work\n+        MyInt[] copyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length);\n+        MyInt[] expected = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n+        expected[0] = myInts[0];\n+        expected[1] = myInts[1];\n+        expected[2] = myInts[2];\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        \/\/ Copy of shorter length, must work\n+        MyInt[] smallCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length - 1);\n+        MyInt[] expected2 = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 2, new MyInt());\n+        expected2[0] = myInts[0];\n+        expected2[1] = myInts[1];\n+        checkArrayElementsEqual(smallCopyMyInts, expected2);\n+\n+                \/\/ Copy of zero length on a zero-length array, must work\n+        IllegalArgumentException iae = null;\n+        MyShorts[] zeroCopyMyShorts = (MyShorts[])ValueClass.newNullRestrictedNonAtomicArray(MyShorts.class, 0, new MyShorts());\n+        try {\n+          MyShorts[] res = (MyShorts[]) Arrays.copyOf(zeroCopyMyShorts, 0);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae == null, \"Unexpected exception\");\n+\n+        \/\/ Copy of bigger length, must fail for null-restricted arrays\n+        try {\n+            MyInt[] bigCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Testing Arrays.copyOfRange()\n+        MyInt[] fullRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, myInts.length);\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        MyInt[] beginningRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, 2);\n+        checkArrayElementsEqual(beginningRangeCopy, expected2);\n+\n+\n+        MyInt[] endingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length);\n+        MyInt[] expected3 = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 2, new MyInt());\n+        expected3[0] = myInts[1];\n+        expected3[1] = myInts[2];\n+        checkArrayElementsEqual(endingRangeCopy, expected3);\n+\n+        \/\/ Range exceeding initial array's length, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyInt[] exceedingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Range starting after the end of the original array, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyInt[] farRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, myInts.length, myInts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        Arrays.sort(copyMyInts);\n+        expected = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n+        expected[0] = (MyInt) MyInt.MIN;\n+        expected[1] = (MyInt) MyInt.ZERO;\n+        expected[2] = (MyInt) MyInt.MAX;\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        List myIntList = Arrays.asList(copyMyInts);\n+\n+        MyInt[] dest = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, copyMyInts.length, new MyInt());\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray(dest));\n+        \/\/ This next line needs testMixedLayoutArrays to work\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray());\n+\n+        \/\/ Sanity check j.u.ArrayList\n+        ArrayList<MyInt> aList = new ArrayList<MyInt>(Arrays.asList(copyMyInts));\n+        assertTrue(aList.indexOf(MyInt.MIN) == 0, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyInt.ZERO) == 1, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyInt.MAX) == 2, \"Bad Index\");\n+\n+        aList.remove(2);\n+        aList.add(MyInt.create(5));\n+    }\n+\n+    void testUtilArraysOnNullRestrictedAtomicArrays() {\n+        \/\/ Sanity check j.u.Arrays\n+\n+        \/\/ Testing Arrays.copyOf()\n+        MyShorts[] myShorts = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 3, new MyShorts());\n+        myShorts[0] = MyShorts.MAX;\n+        myShorts[1] = MyShorts.MIN;\n+        myShorts[2] = MyShorts.ZERO;\n+\n+        \/\/ Copy of same length, must work\n+        MyShorts[] copyMyInts = (MyShorts[]) Arrays.copyOf(myShorts, myShorts.length);\n+        MyShorts[] expected = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 3, new MyShorts());\n+        expected[0] = myShorts[0];\n+        expected[1] = myShorts[1];\n+        expected[2] = myShorts[2];\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        \/\/ Copy of shorter length, must work\n+        MyShorts[] smallCopyMyInts = (MyShorts[]) Arrays.copyOf(myShorts, myShorts.length - 1);\n+        MyShorts[] expected2 = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 2, new MyShorts());\n+        expected2[0] = myShorts[0];\n+        expected2[1] = myShorts[1];\n+        checkArrayElementsEqual(smallCopyMyInts, expected2);\n+\n+        \/\/ Copy of zero length on a zero-length array, must work\n+        IllegalArgumentException iae = null;\n+        MyShorts[] zeroCopyMyShorts = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 0, new MyShorts());\n+        try {\n+          MyShorts[] res = (MyShorts[]) Arrays.copyOf(zeroCopyMyShorts, 0);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae == null, \"Unexpected exception\");\n+\n+        \/\/ Copy of bigger length, must fail for null-restricted arrays\n+        try {\n+            MyShorts[] bigCopyMyInts = (MyShorts[]) Arrays.copyOf(myShorts, myShorts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Testing Arrays.copyOfRange()\n+        MyShorts[] fullRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 0, myShorts.length);\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        MyShorts[] beginningRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 0, 2);\n+        checkArrayElementsEqual(beginningRangeCopy, expected2);\n+\n+\n+        MyShorts[] endingRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 1, myShorts.length);\n+        MyShorts[] expected3 = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 2, new MyShorts());\n+        expected3[0] = myShorts[1];\n+        expected3[1] = myShorts[2];\n+        checkArrayElementsEqual(endingRangeCopy, expected3);\n+\n+        \/\/ Range exceeding initial array's length, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyShorts[] exceedingRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, 1, myShorts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        \/\/ Range starting after the end of the original array, must fail for null-restricted arrays\n+        iae = null;\n+        try {\n+            MyShorts[] farRangeCopy = (MyShorts[]) Arrays.copyOfRange(myShorts, myShorts.length, myShorts.length + 1);\n+        } catch (IllegalArgumentException e) {\n+            iae = e;\n+        }\n+        assertTrue(iae != null, \"Exception not received\");\n+\n+        Arrays.sort(copyMyInts);\n+        expected = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, 3, new MyShorts());\n+        expected[0] = (MyShorts) MyShorts.MIN;\n+        expected[1] = (MyShorts) MyShorts.ZERO;\n+        expected[2] = (MyShorts) MyShorts.MAX;\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        List myIntList = Arrays.asList(copyMyInts);\n+\n+        MyShorts[] dest = (MyShorts[])ValueClass.newNullRestrictedAtomicArray(MyShorts.class, copyMyInts.length, new MyShorts());\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray(dest));\n+        \/\/ This next line needs testMixedLayoutArrays to work\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray());\n+\n+        \/\/ Sanity check j.u.ArrayList\n+        ArrayList<MyShorts> aList = new ArrayList<MyShorts>(Arrays.asList(copyMyInts));\n+        assertTrue(aList.indexOf(MyShorts.MIN) == 0, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyShorts.ZERO) == 1, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyShorts.MAX) == 2, \"Bad Index\");\n+\n+        aList.remove(2);\n+        aList.add(MyShorts.create((short)5, (short)7));\n+    }\n+\n+    void testUtilArraysOnNullableAtomicArrays() {\n+        \/\/ Sanity check j.u.Arrays\n+\n+        \/\/ Testing Arrays.copyOf()\n+        MyInt[] myInts = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        myInts[0] = MyInt.MAX;\n+        myInts[1] = MyInt.MIN;\n+        myInts[2] = MyInt.ZERO;\n+\n+        \/\/ Copy of same length, must work\n+        MyInt[] copyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length);\n+        MyInt[] expected = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        expected[0] = myInts[0];\n+        expected[1] = myInts[1];\n+        expected[2] = myInts[2];\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        \/\/ Copy of shorter length, must work\n+        MyInt[] smallCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length - 1);\n+        MyInt[] expected2 = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 2);\n+        expected2[0] = myInts[0];\n+        expected2[1] = myInts[1];\n+        checkArrayElementsEqual(smallCopyMyInts, expected2);\n+\n+        \/\/ Copy of bigger length, must work for nullable arrays\n+        MyInt[] bigCopyMyInts = (MyInt[]) Arrays.copyOf(myInts, myInts.length + 1);\n+        MyInt[] expected2b = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 4);\n+        expected2b[0] = myInts[0];\n+        expected2b[1] = myInts[1];\n+        expected2b[2] = myInts[2];\n+        expected2b[3] = null;\n+        checkArrayElementsEqual(bigCopyMyInts, expected2b);\n+\n+        \/\/ Testing Arrays.copyOfRange()\n+        MyInt[] fullRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, myInts.length);\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        MyInt[] beginningRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 0, 2);\n+        checkArrayElementsEqual(beginningRangeCopy, expected2);\n+\n+        MyInt[] endingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length);\n+        MyInt[] expected3 = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 2);\n+        expected3[0] = myInts[1];\n+        expected3[1] = myInts[2];\n+        checkArrayElementsEqual(endingRangeCopy, expected3);\n+\n+        \/\/ Range exceeding initial array's length, must succeed for nullable arrays\n+        MyInt[] exceedingRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, 1, myInts.length + 1);\n+        MyInt[] expected3b = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        expected3b[0] = myInts[1];\n+        expected3b[1] = myInts[2];\n+        expected3b[2] = null;\n+        checkArrayElementsEqual(exceedingRangeCopy, expected3b);\n+\n+        \/\/ Range starting after the end of the original array, must suceed for nullable arrays\n+        MyInt[] farRangeCopy = (MyInt[]) Arrays.copyOfRange(myInts, myInts.length, myInts.length + 1);\n+        MyInt[] expected3c = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 1);\n+        expected3c[0] = null;\n+        checkArrayElementsEqual(farRangeCopy, expected3c);\n+\n+        Arrays.sort(copyMyInts);\n+        expected = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, 3);\n+        expected[0] = (MyInt) MyInt.MIN;\n+        expected[1] = (MyInt) MyInt.ZERO;\n+        expected[2] = (MyInt) MyInt.MAX;\n+        checkArrayElementsEqual(copyMyInts, expected);\n+\n+        List myIntList = Arrays.asList(copyMyInts);\n+\n+        MyInt[] dest = (MyInt[])ValueClass.newNullableAtomicArray(MyInt.class, copyMyInts.length);\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray(dest));\n+        \/\/ This next line needs testMixedLayoutArrays to work\n+        checkArrayElementsEqual(copyMyInts, myIntList.toArray());\n+\n+        \/\/ Sanity check j.u.ArrayList\n+        ArrayList<MyInt> aList = new ArrayList<MyInt>(Arrays.asList(copyMyInts));\n+        assertTrue(aList.indexOf(MyInt.MIN) == 0, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyInt.ZERO) == 1, \"Bad Index\");\n+        assertTrue(aList.indexOf(MyInt.MAX) == 2, \"Bad Index\");\n+\n+        aList.remove(2);\n+        aList.add(MyInt.create(5));\n+    }\n+\n+    void testObjectArrayOfInlines() {\n+        testSanityObjectArrays();\n+        testMixedLayoutArrays();\n+    }\n+\n+    void testSanityObjectArrays() {\n+        Object[] objects = new Object[2];\n+        assertTrue(objects[0] == null && objects[1] == null, \"Not null ?\");\n+\n+        objects[0] = MyInt.create(1);\n+        objects[1] = Integer.valueOf(2);\n+        assertTrue(objects[0].equals(MyInt.create(1)), \"Bad Value\");\n+        assertTrue(objects[1].equals(Integer.valueOf(2)), \"Bad Object\");\n+\n+        Comparable[] copyComparables = new Comparable[objects.length];\n+        System.arraycopy(objects, 0, copyComparables, 0, objects.length);\n+        checkArrayElementsEqual(objects, copyComparables);\n+\n+        objects[0] = null;\n+        objects[1] = null;\n+        assertTrue(objects[0] == null && objects[1] == null, \"Not null ?\");\n+\n+        Comparable[] comparables = new Comparable[2];\n+        assertTrue(comparables[0] == null && comparables[1] == null, \"Not null ?\");\n+        comparables[0] = MyInt.create(3);\n+        comparables[1] = Integer.valueOf(4);\n+        assertTrue(comparables[0].equals(MyInt.create(3)), \"Bad Value\");\n+        assertTrue(comparables[1].equals(Integer.valueOf(4)), \"Bad Object\");\n+\n+        Object[] copyObjects = new Object[2];\n+        System.arraycopy(comparables, 0, copyObjects, 0, comparables.length);\n+        checkArrayElementsEqual(comparables, copyObjects);\n+\n+        comparables[0] = null;\n+        comparables[1] = null;\n+        assertTrue(comparables[0] == null && comparables[1] == null, \"Not null ?\");\n+\n+        MyInt[] myIntRefArray = new MyInt[1];\n+        assertTrue(myIntRefArray[0] == null, \"Got: \" + myIntRefArray[0]);\n+        myIntRefArray[0] = null;\n+\n+        MyInt[] srcNulls = new MyInt[2];\n+        MyInt[] dstNulls = new MyInt[2];\n+        System.arraycopy(srcNulls, 0, dstNulls, 0, 2);\n+        checkArrayElementsEqual(srcNulls, dstNulls);\n+        srcNulls[1] = MyInt.create(1);\n+        System.arraycopy(srcNulls, 0, dstNulls, 0, 2);\n+        checkArrayElementsEqual(srcNulls, dstNulls);\n+\n+\n+        \/\/ Locked\/unlocked flat array type checks\n+        synchronized (srcNulls) {\n+            System.arraycopy(srcNulls, 0, dstNulls, 0, 2);\n+            checkArrayElementsEqual(srcNulls, dstNulls);\n+            System.gc();\n+        }\n+        System.gc();\n+        checkArrayElementsEqual(srcNulls, dstNulls);\n+    }\n+\n+    void testMixedLayoutArrays() {\n+        Object[] objArray = new Object[3];\n+        Comparable[] compArray = new Comparable[3];\n+        MyInt[] valArray = new MyInt[] { (MyInt) MyInt.MIN, (MyInt) MyInt.ZERO, (MyInt) MyInt.MAX };\n+\n+        arrayCopy(valArray, 0, objArray, 0, 3);\n+        checkArrayElementsEqual(valArray, objArray);\n+        arrayCopy(valArray, 0, objArray, 0, 3);\n+\n+        objArray = new Object[3];\n+        System.arraycopy(valArray, 0, objArray, 0, 3);\n+        checkArrayElementsEqual(valArray, objArray);\n+\n+        System.arraycopy(valArray, 0, compArray, 0, 3);\n+        checkArrayElementsEqual(valArray, compArray);\n+\n+        valArray = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n+        valArray[0] = (MyInt) MyInt.ZERO;\n+        valArray[1] = (MyInt) MyInt.ZERO;\n+        valArray[2] = (MyInt) MyInt.ZERO;\n+        System.arraycopy(compArray, 0, valArray, 0, 3);\n+        checkArrayElementsEqual(valArray, compArray);\n+\n+        valArray = (MyInt[])ValueClass.newNullRestrictedNonAtomicArray(MyInt.class, 3, new MyInt());\n+        valArray[0] = (MyInt) MyInt.ZERO;\n+        valArray[1] = (MyInt) MyInt.ZERO;\n+        valArray[2] = (MyInt) MyInt.ZERO;\n+        System.arraycopy(objArray, 0, valArray, 0, 3);\n+        checkArrayElementsEqual(valArray, objArray);\n+\n+        \/\/ Sanity check dst == src\n+        System.arraycopy(valArray, 0, valArray, 0, 3);\n+        checkArrayElementsEqual(valArray, objArray);\n+\n+        objArray[0] = \"Not an inline object\";\n+        try {\n+            System.arraycopy(objArray, 0, valArray, 0, 3);\n+            throw new RuntimeException(\"Expected ArrayStoreException\");\n+        } catch (ArrayStoreException ase) {}\n+\n+        MyInt[] myIntRefArray = new MyInt[3];\n+        System.arraycopy(valArray, 0, myIntRefArray, 0, 3);\n+        checkArrayElementsEqual(valArray, myIntRefArray);\n+\n+        myIntRefArray[0] = null;\n+        try {\n+            System.arraycopy(myIntRefArray, 0, valArray, 0, 3);\n+            throw new RuntimeException(\"Expected NullPointerException\");\n+        } catch (NullPointerException npe) {}\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyPoint {\n+        @Strict\n+        @NullRestricted\n+        MyInt x;\n+        @Strict\n+        @NullRestricted\n+        MyInt y;\n+\n+        private MyPoint() { this(0, 0); }\n+        private MyPoint(int x, int y) {\n+            this.x = new MyInt(x);\n+            this.y = new MyInt(y);\n+        }\n+        public boolean equals(Object that) {\n+            if (that instanceof MyPoint) {\n+                MyPoint thatPoint = (MyPoint) that;\n+                return x.equals(thatPoint.x) && java.util.Objects.equals(y, thatPoint.y);\n+            }\n+            return false;\n+        }\n+        static MyPoint create(int x) {\n+            return new MyPoint(x, x);\n+        }\n+        static MyPoint create(int x, int y) {\n+            return new MyPoint(x, y);\n+        }\n+        @Strict\n+        @NullRestricted\n+        static final MyPoint ORIGIN = create(0);\n+    }\n+\n+    void testComposition() {\n+        \/\/ Test array operations with compostion of inline types, check element payload is correct...\n+        MyPoint a = MyPoint.create(1, 2);\n+        MyPoint b = MyPoint.create(7, 21);\n+        MyPoint c = MyPoint.create(Integer.MAX_VALUE, Integer.MIN_VALUE);\n+\n+        MyPoint[] pts = (MyPoint[])ValueClass.newNullRestrictedNonAtomicArray(MyPoint.class, 3, new MyPoint());\n+        if (!pts[0].equals(MyPoint.ORIGIN)) {\n+            throw new RuntimeException(\"Equals failed: \" + pts[0] + \" vs \" + MyPoint.ORIGIN);\n+        }\n+        pts = (MyPoint[])ValueClass.newNullRestrictedNonAtomicArray(MyPoint.class, 3, new MyPoint());\n+        pts[0] = a;\n+        pts[1] = b;\n+        pts[2] = c;\n+        checkArrayElementsEqual(pts, new Object[] { a, b, c});\n+        Object[] oarr = new Object[3];\n+\n+        arrayCopy(pts, 0, oarr, 0, 3);\n+        checkArrayElementsEqual(pts, oarr);\n+\n+        oarr = new Object[3];\n+        System.arraycopy(pts, 0, oarr, 0, 3);\n+        checkArrayElementsEqual(pts, oarr);\n+\n+        System.arraycopy(oarr, 0, pts, 0, 3);\n+        checkArrayElementsEqual(pts, oarr);\n+\n+        oarr = new Object[3];\n+        try {\n+            System.arraycopy(oarr, 0, pts, 0, 3);\n+            throw new RuntimeException(\"Expected NPE\");\n+        }\n+        catch (NullPointerException npe) {}\n+\n+        oarr = new Object[3];\n+        oarr[0] = new Object();\n+        try {\n+            System.arraycopy(oarr, 0, pts, 0, 3);\n+            throw new RuntimeException(\"Expected ASE\");\n+        }\n+        catch (ArrayStoreException ase) {}\n+    }\n+\n+    void checkArrayElementsEqual(MyInt[] arr1, Object[] arr2) {\n+        assertTrue(arr1.length == arr2.length, \"Bad length\");\n+        for (int i = 0; i < arr1.length; i++) {\n+            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), \"Element \" + i + \" not equal\");\n+        }\n+    }\n+\n+    void checkArrayElementsEqual(MyPoint[] arr1, Object[] arr2) {\n+        assertTrue(arr1.length == arr2.length, \"Bad length\");\n+        for (int i = 0; i < arr1.length; i++) {\n+            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), \"Element \" + i + \" not equal\");\n+        }\n+    }\n+\n+    void checkArrayElementsEqual(Object[] arr1, Object[] arr2) {\n+        assertTrue(arr1.length == arr2.length, \"Bad length\");\n+        for (int i = 0; i < arr1.length; i++) {\n+            assertTrue(java.util.Objects.equals(arr1[i], arr2[i]), \"Element \" + i + \" not equal\");\n+        }\n+    }\n+\n+    void arrayCopy(MyInt[] src, int srcPos, Object[] dst, int dstPos, int length) {\n+        for (int i = 0; i < length ; i++) {\n+            dst[dstPos++] = src[srcPos++];\n+        }\n+    }\n+    void arrayCopy(MyPoint[] src, int srcPos, Object[] dst, int dstPos, int length) {\n+        for (int i = 0; i < length ; i++) {\n+            dst[dstPos++] = src[srcPos++];\n+        }\n+    }\n+\n+    Object getNull() { return null; }\n+\n+\n+    void testInlineArrayOom() {\n+        int size = Integer.MAX_VALUE;\n+        try {\n+            MyPoint[] pts = new MyPoint[size];\n+            throw new RuntimeException(\"Excepted OOM\");\n+        } catch (OutOfMemoryError oom) {}\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeArray.java","additions":869,"deletions":0,"binary":false,"changes":869,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ The test class is based in the Java source code below, but the constant\n+\/\/ pool entry #33 (used by the Preload attribute) has been modified to\n+\/\/ contain the name of a non-existing class.\n+\/\/\n+\/\/ public class ValuePreloadClient1 {\n+\/\/     PreloadValue0 value;\n+\/\/\n+\/\/     public static void main(String[] args) {\n+\/\/         System.out.print(\"Success\");\n+\/\/     }\n+\/\/ }\n+\n+ class ValuePreloadClient1 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/System\"; \/\/ #10\n+    Utf8 \"out\"; \/\/ #11\n+    Utf8 \"Ljava\/io\/PrintStream;\"; \/\/ #12\n+    String #14; \/\/ #13\n+    Utf8 \"Success\"; \/\/ #14\n+    Method #16 #17; \/\/ #15\n+    class #18; \/\/ #16\n+    NameAndType #19 #20; \/\/ #17\n+    Utf8 \"java\/io\/PrintStream\"; \/\/ #18\n+    Utf8 \"print\"; \/\/ #19\n+    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #20\n+    class #22; \/\/ #21\n+    Utf8 \"ValuePreloadClient1\"; \/\/ #22\n+    Utf8 \"value\"; \/\/ #23\n+    Utf8 \"LPreloadValue0;\"; \/\/ #24\n+    Utf8 \"Code\"; \/\/ #25\n+    Utf8 \"LineNumberTable\"; \/\/ #26\n+    Utf8 \"main\"; \/\/ #27\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #28\n+    Utf8 \"SourceFile\"; \/\/ #29\n+    Utf8 \"ValuePreloadClient1.java\"; \/\/ #30\n+    Utf8 \"LoadableDescriptors\"; \/\/ #31\n+    Utf8 \"LPreloadValue1;\"; \/\/ #32\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #21;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #23; \/\/ name_index\n+      #24; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #27; \/\/ name_index\n+      #28; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xB20007120DB6000F;\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#26) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  5;\n+                8  6;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#29) { \/\/ SourceFile\n+      #30;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#31) { \/\/ LoadableDescriptors\n+      0x00010020;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class ValuePreloadClient1\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ValuePreloadClient1.jcod","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,1258 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ Simple class generated from the following source:\n+\/\/ public class SimpleClass { }\n+\/\/ The jcod version has been altered to create a class without any of ACC_IDENTITY, ACC_ABSTRACT or ACC_FINAL flags,\n+\/\/ which is illegal according to JVMS 4.1.\n+\n+class InvalidClassFlags {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"InvalidClassFlags\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"InvalidClassFlags.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0001; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class InvalidClassFlags\n+\n+\/\/ Valid class with access flags ACC_PUBLIC, ACC_ABSTRACT and no ACC_IDENTITY\n+class AbstractValue {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractValue\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractValue.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractValue\n+\n+\/\/ Valid class with access flags ACC_PUBLIC, ACC_FINAL and no ACC_IDENTITY\n+class FinalValue {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"FinalValue\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"FinalValue.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class FinalValue\n+\n+\/\/ Abstract class with ACC_IDENTITY flag added to its access flags\n+class AbstractClass {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractClass\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractClass.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0421; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractClass\n+\n+\/\/ Value class extending the abstract (with identity) class define above\n+class ValueClass {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"AbstractClass\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"ValueClass\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"ValueClass.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass\n+\n+\/\/ Concrete identity class from old class file without ACC_IDENTITY extending the abstract (with identity) class define above\n+class IdentityClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"AbstractClass\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"IdentityClass\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"IdentityClass.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass\n+\n+\/\/ Concrete value class extending a final value class\n+class ValueClass2 {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"FinalValue\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"ValueClass2\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"ValueClass2.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass2\n+\n+\/\/ Abstract value class extending an abstract (with identity) class\n+class AbstractValueClass2 {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"AbstractClass\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractValueClass2\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractValueClass2.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractValueClass2\n+\n+\/\/ Abstract identity class from older class file without ACC_IDENTITY, extending an abstract (with identity) class\n+class AbstractIdentityClass2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"AbstractClass\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractIdentityClass2\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractIdentityClass2.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractValueClass2\n+\n+\/\/ Abstract value class extending a final value class\n+class AbstractValueClass3 {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"FinalValue\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"AbstractValueClass3\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"AbstractValueClass3.java\"; \/\/ #12\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class AbstractValueClass3\n+\n+\/\/ A concrete class without ACC_IDENTITY but with an older class file version, declaring a field without ACC_STATIC nor ACC_STRICT\n+\/\/\n+class NotStaticNotStrictInOldClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"NotStaticNotStrictInOldClass\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"NotStaticNotStrictInOldClass.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class NotStaticNotStrictInOldClass\n+\n+\/\/ Valid concrete value class with a synchronized static method\n+class StaticSynchMethod {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"StaticSynchMethod\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"m\"; \/\/ #11\n+    Utf8 \"()I\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"StaticSynchMethod.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0029; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x102AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class StaticSynchMethod\n+\n+\/\/ Invalid concrete value class with synchronized non-static method\n+class SynchMethod {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"SynchMethod\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"m\"; \/\/ #11\n+    Utf8 \"()I\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"SynchMethod.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0021; \/\/ access               \/\/ Modified to make it synchronized\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x102AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class SynchMethod\n+\n+\/\/ Valid abstract value class with synchronized static method\n+class StaticSynchMethodInAbstractValue {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"StaticSynchMethodInAbstractValue\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"m\"; \/\/ #11\n+    Utf8 \"()I\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"StaticSynchMethodInAbstractValue.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0029; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x102AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class StaticSynchMethodInAbstractValue\n+\n+\/\/ Invalid abstract value class with a synchronized non-static method\n+class SynchMethodInAbstractValue {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"SynchMethodInAbstractValue\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"m\"; \/\/ #11\n+    Utf8 \"()I\"; \/\/ #12\n+    Utf8 \"SourceFile\"; \/\/ #13\n+    Utf8 \"SynchMethodInAbstractValue.java\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0021; \/\/ access                \/\/ modified to make it synchronized\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x102AAC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#13) { \/\/ SourceFile\n+      #14;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class SynchMethodInAbstractValue\n+\n+\/\/ Class to test invalid entries in LoadableDescriptors Attributes\n+\/\/ Class generated from this source:\n+\/\/ public class PrimitiveInLoadableDescriptors {\n+\/\/ int i;\n+\/\/ void foo(Integer i) { }\n+\/\/ }\n+\n+class PrimitiveInLoadableDescriptors {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"PrimitiveInLoadableDescriptors\"; \/\/ #8\n+    Utf8 \"i\"; \/\/ #9\n+    Utf8 \"I\"; \/\/ #10\n+    Utf8 \"Code\"; \/\/ #11\n+    Utf8 \"LineNumberTable\"; \/\/ #12\n+    Utf8 \"foo\"; \/\/ #13\n+    Utf8 \"(Ljava\/lang\/Integer;)V\"; \/\/ #14\n+    Utf8 \"SourceFile\"; \/\/ #15\n+    Utf8 \"PrimitiveInLoadableDescriptors.java\"; \/\/ #16\n+    Utf8 \"LoadableDescriptors\"; \/\/ #17\n+    Utf8 \"I\"; \/\/ #18                            \/\/ Modified from \"Ljava\/lang\/Integer;\" to \"I\"\n+  } \/\/ Constant Pool\n+\n+  0x0021; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0000; \/\/ access\n+      #9; \/\/ name_index\n+      #10; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #13; \/\/ name_index\n+      #14; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#11) { \/\/ Code\n+          0; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0xB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#12) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#15) { \/\/ SourceFile\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#17) { \/\/ LoadableDescriptors\n+      0x00010012;\n+    } \/\/ end LoadableDescriptors\n+  } \/\/ Attributes\n+} \/\/ end class PrimitiveInLoadableDescriptors\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/cfpValueClassValidation.jcod","additions":1258,"deletions":0,"binary":false,"changes":1258,"status":"added"},{"patch":"@@ -0,0 +1,637 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+ \/\/ This file contains multiple illegal inline type classes that should cause\n+\/\/ ClassFormatError exceptions when attempted to be loaded.\n+\/\/\n+\/\/ Many of these test were originally generated from this Java file and then\n+\/\/ field modifiers are changed to cause a ClassFormatError exceptions.\n+\/\/\n+\/\/ public value class Value {\n+\/\/    static int si = 0;\n+\/\/    int i = 0;\n+\/\/}\n+\n+\n+\/\/ A field has both ACC_FINAL and ACC_VOLATILE set\n+\/\/\n+class FinalAndVolatile {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"FinalAndVolatile\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"FinalAndVolatile.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0850; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class FinalAndVolatile\n+\n+\n+\/\/ A field has both ACC_STRICT and ACC_STATIC set\n+\/\/\n+class StrictAndStatic {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"StrictAndStatic\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"StrictAndStatic.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0808; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0810; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class StrictAndStatic\n+\n+\n+\/\/ A field has ACC_STRICT set without ACC_FINAL being set\n+\/\/\n+class StrictNotFinal {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"StrictNotFinal\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"StrictNotFinal.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0800; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class StrictNotFinal\n+\n+\/\/ A concrete value class declaring a field without ACC_STATIC nor ACC_STRICT\n+\/\/\n+class NotStaticNotStrict {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"NotStaticNotStrict\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"NotStaticNotStrict.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0011; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class NotStaticNotStrict\n+\n+\/\/ An abstract value class declaring a field without ACC_STATIC nor ACC_STRICT\n+\/\/\n+class NotStaticNotStrictInAbstract {\n+  0xCAFEBABE;\n+  65535; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Field #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"NotStaticNotStrictInAbstract\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Method #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"java\/lang\/Object\"; \/\/ #10\n+    Utf8 \"<init>\"; \/\/ #11\n+    Utf8 \"()V\"; \/\/ #12\n+    Field #2 #14; \/\/ #13\n+    NameAndType #15 #6; \/\/ #14\n+    Utf8 \"si\"; \/\/ #15\n+    Utf8 \"ConstantValue\"; \/\/ #16\n+    int 0x00000000; \/\/ #17\n+    Utf8 \"Code\"; \/\/ #18\n+    Utf8 \"LineNumberTable\"; \/\/ #19\n+    Utf8 \"<clinit>\"; \/\/ #20\n+    Utf8 \"SourceFile\"; \/\/ #21\n+    Utf8 \"NotStaticNotStrictInAbstract.java\"; \/\/ #22\n+  } \/\/ Constant Pool\n+\n+  0x0401; \/\/ access\n+  #2;\/\/ this_cpx\n+  #8;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#16) { \/\/ ConstantValue\n+          #17;\n+        } \/\/ end ConstantValue\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2A03B500012AB700;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                5  1;\n+                9  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0008; \/\/ access\n+      #20; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#18) { \/\/ Code\n+          1; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+            0x03B3000DB1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#19) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#21) { \/\/ SourceFile\n+      #22;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class NotStaticNotStrictInAbstract\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/classfileparser\/fieldModifiersTest.jcod","additions":637,"deletions":0,"binary":false,"changes":637,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class BadChild extends Parent {\n+  @Strict int x;\n+  @Strict int y;\n+\n+  BadChild() {\n+    y = 1;\n+    super(); \/\/ FAIL: Strict field x must be set before this call\n+    x = 1;\n+  }\n+}\n+*\/\n+\n+identity class BadChild extends Parent version 70:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field x:I;\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field y:I;\n+\n+  Method       \"<init>\":\"()V\"\n+    stack 4  locals 1\n+  {\n+         aload_0;\n+         aload_0;\n+         iconst_1;\n+         dup_x1;\n+         putfield          Field y:\"I\";\n+         aload_0;\n+         invokespecial     Method Parent.\"<init>\":\"()V\"; \/\/ FAIL: Strict field x must be set before this call\n+         putfield          Field x:\"I\";\n+         return;\n+  }\n+\n+  Method       get_x:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field x:\"I\";\n+         ireturn;\n+  }\n+\n+  Method       get_y:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field y:\"I\";\n+         ireturn;\n+  }\n+} \/\/ end Class BadChild\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/BadChild.jasm","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class BadChild extends Parent {\n+  @Strict int x;\n+  @Strict int y;\n+\n+  BadChild() {\n+    x = 1;\n+    super(); \/\/ FAIL: Strict field y must be set before this call\n+    y = 1;\n+  }\n+}\n+*\/\n+\n+identity class BadChild1 extends Parent version 70:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field x:I;\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field y:I;\n+\n+  Method       \"<init>\":\"()V\"\n+    stack 4  locals 1\n+  {\n+         aload_0;\n+         aload_0;\n+         iconst_1;\n+         dup_x1;\n+         putfield          Field x:\"I\";\n+         aload_0;\n+         invokespecial     Method Parent.\"<init>\":\"()V\"; \/\/ FAIL: Strict field y must be set before this call\n+         putfield          Field y:\"I\";\n+         return;\n+  }\n+\n+  Method       get_x:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field x:\"I\";\n+         ireturn;\n+  }\n+\n+  Method       get_y:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field y:\"I\";\n+         ireturn;\n+  }\n+} \/\/ end Class BadChild1\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/BadChild1.jasm","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Bnoinit_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {} \/\/ Strict statics not initialized\n+}\n+*\/\n+\n+identity class Bnoinit_BAD version 70:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  public Method \"<init>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 0  locals 0\n+  {\n+         return;\n+  }\n+\n+} \/\/ end Class Bnoinit_BAD\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Bnoinit_BAD.jasm","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Brbefore_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        int x = F2__STRICT; \/\/ Read before write\n+        F1__STRICT = \"hello\";\n+        F2__STRICT = 42;\n+    }\n+}\n+*\/\n+\n+identity class Brbefore_BAD version 70:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  public Method \"<init>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         getstatic         Field F2__STRICT:\"I\";\n+         istore_0;\n+         ldc               String \"hello\";\n+         putstatic         Field F1__STRICT:\"Ljava\/lang\/String;\";\n+         bipush            42;\n+         putstatic         Field F2__STRICT:\"I\";\n+         return;\n+  }\n+} \/\/ end Class Brbefore_BAD\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Brbefore_BAD.jasm","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class ControlFlowChild extends Parent {\n+    @Strict int x;\n+    @Strict int y;\n+\n+    ControlFlowChild(boolean a, boolean b) {\n+        if (a) {      \/\/ FAIL: Strict field x never set on this path\n+            if (b) {\n+                y = 1;\n+            } else {\n+                y = 2;\n+            }\n+        } else {\n+            x = y = 3;\n+        }\n+        super(); \/\/\n+    }\n+}\n+*\/\n+\n+identity class ControlFlowChildBad extends Parent version 70:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field x:I;\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field y:I;\n+\n+  Method       \"<init>\":\"(ZZ)V\"\n+    stack 4  locals 3\n+  {\n+         iload_1;\n+         ifeq              L29;\n+         aload_0;\n+         iconst_1;\n+         putfield          Field y:\"I\";\n+         iload_2;\n+         ifeq              L21;\n+         aload_0;\n+         iconst_1;\n+         putfield          Field y:\"I\";\n+         goto              L39;\n+  L21:   stack_frame_type  early_larval;\n+           unset_fields    y:\"I\";\n+           frame_type      same;\n+         aload_0;\n+         iconst_2;\n+         putfield          Field y:\"I\";\n+         goto              L39;          \/\/ FAIL: Strict field x never set on this path\n+  L29:   stack_frame_type  early_larval;\n+           unset_fields    x:\"I\",\n+                           y:\"I\";\n+           frame_type      same;\n+         aload_0;\n+         aload_0;\n+         iconst_3;\n+         dup_x1;\n+         putfield          Field y:\"I\";\n+         putfield          Field x:\"I\";\n+  L39:   stack_frame_type  early_larval;\n+           unset_fields;\n+           frame_type      same;\n+         aload_0;\n+         invokespecial     Method Parent.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  Method       get_x:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field x:\"I\";\n+         ireturn;\n+  }\n+\n+  Method       get_y:\"()I\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         getfield          Field y:\"I\";\n+         ireturn;\n+  }\n+} \/\/ end Class ControlFlowChildBad\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/ControlFlowChildBad.jasm","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Creflbefore_BAD {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        Field FIELD_F1 = findField(Creflbefore_BAD.class, \"F1__STRICT\");\n+        Field FIELD_F2 = findField(Creflbefore_BAD.class, \"F2__STRICT\");\n+\n+        int x = (int) getstaticReflective(FIELD_F2);  \/\/ Read before write\n+        System.out.println(\"Early read of F2=\" + x);\n+\n+        putstaticReflective(FIELD_F1, \"hello\");\n+        putstaticReflective(FIELD_F2, 42);\n+    }\n+}\n+*\/\n+identity class Creflbefore_BAD version 70:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  Method       \"<init>\":\"(LStrictStaticFieldsTest;)V\"\n+    stack 2  locals 2\n+     0:  #{ #0 final mandated }\n+  {\n+         aload_1;\n+         dup;\n+         invokestatic      Method java\/util\/Objects.requireNonNull:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\";\n+         pop;\n+         pop;\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 2  locals 3\n+  {\n+         ldc               class Creflbefore_BAD;\n+         ldc               String \"F1__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_0;\n+         ldc               class Creflbefore_BAD;\n+         ldc               String \"F2__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_1;\n+         aload_1;\n+         invokestatic      Method StrictStaticFieldsTest.getstaticReflective:\"(Ljava\/lang\/reflect\/Field;)Ljava\/lang\/Object;\";\n+         checkcast         class java\/lang\/Integer;\n+         invokevirtual     Method java\/lang\/Integer.intValue:\"()I\";\n+         istore_2;\n+         getstatic         Field java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+         iload_2;\n+         invokedynamic     InvokeDynamic REF_invokeStatic:Method java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\n+                           \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\":\n+                           makeConcatWithConstants:\"(I)Ljava\/lang\/String;\" {\n+                             String \"Early read of F2=\\u0001\"\n+                           };\n+         invokevirtual     Method java\/io\/PrintStream.println:\"(Ljava\/lang\/String;)V\";\n+         aload_0;\n+         ldc               String \"hello\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         aload_1;\n+         bipush            42;\n+         invokestatic      Method java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         return;\n+  }\n+\n+  BootstrapMethod          REF_invokeStatic:java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\n+                           \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";\n+                           {\n+                             String \"(early read of F2=\\u0001)\"\n+                           }\n+} \/\/ end Class Creflbefore_BAD\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Creflbefore_BAD.jasm","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class Cwreflective_OK {\n+    @Strict static String F1__STRICT;\n+    @Strict static int    F2__STRICT;\n+    static {\n+        Field FIELD_F1 = findField(Cwreflective_OK.class, \"F1__STRICT\");\n+        Field FIELD_F2 = findField(Cwreflective_OK.class, \"F2__STRICT\");\n+\n+        putstaticReflective(FIELD_F1, \"hello\");\n+        putstaticReflective(FIELD_F2, 42);\n+    }\n+}\n+*\/\n+\n+identity class Cwreflective_OK version 70:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static Field F2__STRICT:I;\n+\n+  Method       \"<init>\":\"(LStrictStaticFieldsTest;)V\"\n+    stack 2  locals 2\n+     0:  #{ #0 final mandated }\n+  {\n+         aload_1;\n+         dup;\n+         invokestatic      Method java\/util\/Objects.requireNonNull:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\";\n+         pop;\n+         pop;\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 2  locals 2\n+  {\n+         ldc               class Cwreflective_OK;\n+         ldc               String \"F1__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_0;\n+         ldc               class Cwreflective_OK;\n+         ldc               String \"F2__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_1;\n+         aload_0;\n+         ldc               String \"hello\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         aload_1;\n+         bipush            42;\n+         invokestatic      Method java\/lang\/Integer.valueOf:\"(I)Ljava\/lang\/Integer;\";\n+         invokestatic      Method StrictStaticFieldsTest.putstaticReflective:\"(Ljava\/lang\/reflect\/Field;Ljava\/lang\/Object;)V\";\n+         return;\n+  }\n+} \/\/ end Class Cwreflective_OK\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/Cwreflective_OK.jasm","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,295 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class EndsInEarlyLarval extends Parent {\n+    @Strict\n+    int x;\n+    @Strict\n+    int y;\n+\n+    EndsInEarlyLarval(boolean a, boolean b) {\n+        if (a) {\n+            x = 1;\n+            if (b) {\n+                y = 1;\n+            } else {\n+                y = 2;\n+            }\n+        } else {\n+            x = y = 3;\n+        }\n+        super();\n+    }\n+}\n+*\/\n+\n+class EndsInEarlyLarval {\n+  0xCAFEBABE;\n+  65535;                                   \/\/ minor version\n+  70;                                      \/\/ version\n+  [] {                                     \/\/ Constant Pool\n+    ;                                      \/\/ first element is empty\n+    Field #2 #3;                           \/\/ #1\n+    Class #4;                              \/\/ #2\n+    NameAndType #5 #6;                     \/\/ #3\n+    Utf8 \"EndsInEarlyLarval\";               \/\/ #4\n+    Utf8 \"x\";                              \/\/ #5\n+    Utf8 \"I\";                              \/\/ #6\n+    Field #2 #8;                           \/\/ #7\n+    NameAndType #9 #6;                     \/\/ #8\n+    Utf8 \"y\";                              \/\/ #9\n+    Method #11 #12;                        \/\/ #10\n+    Class #13;                             \/\/ #11\n+    NameAndType #14 #15;                   \/\/ #12\n+    Utf8 \"Parent\";                         \/\/ #13\n+    Utf8 \"<init>\";                         \/\/ #14\n+    Utf8 \"()V\";                            \/\/ #15\n+    Method #2 #17;                         \/\/ #16\n+    NameAndType #18 #19;                   \/\/ #17\n+    Utf8 \"get_x\";                          \/\/ #18\n+    Utf8 \"()I\";                            \/\/ #19\n+    Method #2 #21;                         \/\/ #20\n+    NameAndType #22 #19;                   \/\/ #21\n+    Utf8 \"get_y\";                          \/\/ #22\n+    Method #11 #24;                        \/\/ #23\n+    NameAndType #25 #26;                   \/\/ #24\n+    Utf8 \"toString\";                       \/\/ #25\n+    Utf8 \"()Ljava\/lang\/String;\";           \/\/ #26\n+    InvokeDynamic 0s #28;                  \/\/ #27\n+    NameAndType #29 #30;                   \/\/ #28\n+    Utf8 \"makeConcatWithConstants\";        \/\/ #29\n+    Utf8 \"(IILjava\/lang\/String;)Ljava\/lang\/String;\";  \/\/ #30\n+    Utf8 \"RuntimeInvisibleAnnotations\";    \/\/ #31\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\";  \/\/ #32\n+    Utf8 \"(ZZ)V\";                          \/\/ #33\n+    Utf8 \"Code\";                           \/\/ #34\n+    Utf8 \"LineNumberTable\";                \/\/ #35\n+    Utf8 \"StackMapTable\";                  \/\/ #36\n+    Utf8 \"SourceFile\";                     \/\/ #37\n+    Utf8 \"StrictInstanceFieldsTest.java\";  \/\/ #38\n+    Utf8 \"BootstrapMethods\";               \/\/ #39\n+    String #41;                            \/\/ #40\n+    Utf8 \"x: \\u0001\\ny: \\u0001\\n\\u0001\";   \/\/ #41\n+    MethodHandle 6b #43;                   \/\/ #42\n+    Method #44 #45;                        \/\/ #43\n+    Class #46;                             \/\/ #44\n+    NameAndType #29 #47;                   \/\/ #45\n+    Utf8 \"java\/lang\/invoke\/StringConcatFactory\";  \/\/ #46\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";  \/\/ #47\n+    Utf8 \"InnerClasses\";                   \/\/ #48\n+    Class #50;                             \/\/ #49\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\";  \/\/ #50\n+    Class #52;                             \/\/ #51\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\";  \/\/ #52\n+    Utf8 \"Lookup\";                         \/\/ #53\n+  }\n+\n+  0x0020;                                  \/\/ access\n+  #2;                                      \/\/ this_cpx\n+  #11;                                     \/\/ super_cpx\n+\n+  [] {                                     \/\/ Interfaces\n+  }                                        \/\/ end of Interfaces\n+\n+  [] {                                     \/\/ Fields\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #5;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #9;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Fields\n+\n+  [] {                                     \/\/ Methods\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #14;                                 \/\/ name_index\n+      #33;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          4;                               \/\/ max_stack\n+          3;                               \/\/ max_locals\n+          Bytes[]{\n+            0x1B 0x99 0x00 0x1C 0x2A 0x04 0xB5 0x00 0x01 0x1C 0x99 0x00;\n+            0x0B 0x2A 0x04 0xB5 0x00 0x07 0xA7 0x00 0x15 0x2A 0x05 0xB5;\n+            0x00 0x07 0xA7 0x00 0x0D 0x2A 0x2A 0x06 0x5A 0xB5 0x00 0x07;\n+            0xB5 0x00 0x01 0x2A 0xB7 0x00 0x0A 0xB1;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  121;\n+                   4  122;\n+                   9  123;\n+                  13  124;\n+                  21  126;\n+                  29  129;\n+                  39  131;\n+                  43  132;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+            ;\n+            Attr(#36) {                    \/\/ StackMapTable\n+              [] {                         \/\/\n+                246b, []{#8}, {            \/\/ early_larval_frame\n+                  21b;                     \/\/ same\n+                };\n+                246b, []{#3; #8}, {        \/\/ early_larval_frame\n+                  7b;                      \/\/ same_frame\n+                };\n+                246b, []{}, {              \/\/ FAIL: early_larval_frame with no base frame\n+                };\n+              }\n+            }                              \/\/ end of StackMapTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #18;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x01 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  134;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #22;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x07 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  135;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0001;                              \/\/ access\n+      #25;                                 \/\/ name_index\n+      #26;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          3;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB6 0x00 0x10 0x2A 0xB6 0x00 0x14 0x2A 0xB7 0x00 0x17;\n+            0xBA 0x00 0x1B 0x00 0x00 0xB0;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  139;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Methods\n+\n+  [] {                                     \/\/ Attributes\n+    Attr(#37) {                            \/\/ SourceFile\n+      #38;\n+    }                                      \/\/ end of SourceFile\n+    ;\n+    Attr(#39) {                            \/\/ BootstrapMethods\n+      [] {                                 \/\/ bootstrap_methods\n+        {                                  \/\/ bootstrap_method\n+          #42;                             \/\/ bootstrap_method_ref\n+          [] {                             \/\/ bootstrap_arguments\n+            #40;\n+          }                                \/\/ bootstrap_arguments\n+        }                                  \/\/ bootstrap_method\n+      }\n+    }                                      \/\/ end of BootstrapMethods\n+    ;\n+    Attr(#48) {                            \/\/ InnerClasses\n+      [] {                                 \/\/ classes\n+          #49   #51   #53  57;\n+      }\n+    }                                      \/\/ end of InnerClasses\n+  }                                        \/\/ end of Attributes\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/EndsInEarlyLarval.jcod","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class InvalidIndexInEarlyLarval extends Parent {\n+    @Strict\n+    int x;\n+    @Strict\n+    int y;\n+\n+    InvalidIndexInEarlyLarval(boolean a, boolean b) {\n+        if (a) {\n+            x = 1;\n+            if (b) {\n+                y = 1;\n+            } else {\n+                y = 2;\n+            }\n+        } else {\n+            x = y = 3;\n+        }\n+        super();\n+    }\n+}\n+*\/\n+\n+class InvalidIndexInEarlyLarval {\n+  0xCAFEBABE;\n+  65535;                                   \/\/ minor version\n+  70;                                      \/\/ version\n+  [] {                                     \/\/ Constant Pool\n+    ;                                      \/\/ first element is empty\n+    Field #2 #3;                           \/\/ #1\n+    Class #4;                              \/\/ #2\n+    NameAndType #5 #6;                     \/\/ #3\n+    Utf8 \"InvalidIndexInEarlyLarval\";      \/\/ #4\n+    Utf8 \"x\";                              \/\/ #5\n+    Utf8 \"I\";                              \/\/ #6\n+    Field #2 #8;                           \/\/ #7\n+    NameAndType #9 #6;                     \/\/ #8\n+    Utf8 \"y\";                              \/\/ #9\n+    Method #11 #12;                        \/\/ #10\n+    Class #13;                             \/\/ #11\n+    NameAndType #14 #15;                   \/\/ #12\n+    Utf8 \"Parent\";                         \/\/ #13\n+    Utf8 \"<init>\";                         \/\/ #14\n+    Utf8 \"()V\";                            \/\/ #15\n+    Method #2 #17;                         \/\/ #16\n+    NameAndType #18 #19;                   \/\/ #17\n+    Utf8 \"get_x\";                          \/\/ #18\n+    Utf8 \"()I\";                            \/\/ #19\n+    Method #2 #21;                         \/\/ #20\n+    NameAndType #22 #19;                   \/\/ #21\n+    Utf8 \"get_y\";                          \/\/ #22\n+    Method #11 #24;                        \/\/ #23\n+    NameAndType #25 #26;                   \/\/ #24\n+    Utf8 \"toString\";                       \/\/ #25\n+    Utf8 \"()Ljava\/lang\/String;\";           \/\/ #26\n+    InvokeDynamic 0s #28;                  \/\/ #27\n+    NameAndType #29 #30;                   \/\/ #28\n+    Utf8 \"makeConcatWithConstants\";        \/\/ #29\n+    Utf8 \"(IILjava\/lang\/String;)Ljava\/lang\/String;\";  \/\/ #30\n+    Utf8 \"RuntimeInvisibleAnnotations\";    \/\/ #31\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\";  \/\/ #32\n+    Utf8 \"(ZZ)V\";                          \/\/ #33\n+    Utf8 \"Code\";                           \/\/ #34\n+    Utf8 \"LineNumberTable\";                \/\/ #35\n+    Utf8 \"StackMapTable\";                  \/\/ #36\n+    Utf8 \"SourceFile\";                     \/\/ #37\n+    Utf8 \"StrictInstanceFieldsTest.java\";  \/\/ #38\n+    Utf8 \"BootstrapMethods\";               \/\/ #39\n+    String #41;                            \/\/ #40\n+    Utf8 \"x: \\u0001\\ny: \\u0001\\n\\u0001\";   \/\/ #41\n+    MethodHandle 6b #43;                   \/\/ #42\n+    Method #44 #45;                        \/\/ #43\n+    Class #46;                             \/\/ #44\n+    NameAndType #29 #47;                   \/\/ #45\n+    Utf8 \"java\/lang\/invoke\/StringConcatFactory\";  \/\/ #46\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";  \/\/ #47\n+    Utf8 \"InnerClasses\";                   \/\/ #48\n+    Class #50;                             \/\/ #49\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\";  \/\/ #50\n+    Class #52;                             \/\/ #51\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\";  \/\/ #52\n+    Utf8 \"Lookup\";                         \/\/ #53\n+  }\n+\n+  0x0020;                                  \/\/ access\n+  #2;                                      \/\/ this_cpx\n+  #11;                                     \/\/ super_cpx\n+\n+  [] {                                     \/\/ Interfaces\n+  }                                        \/\/ end of Interfaces\n+\n+  [] {                                     \/\/ Fields\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #5;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #9;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Fields\n+\n+  [] {                                     \/\/ Methods\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #14;                                 \/\/ name_index\n+      #33;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          4;                               \/\/ max_stack\n+          3;                               \/\/ max_locals\n+          Bytes[]{\n+            0x1B 0x99 0x00 0x1C 0x2A 0x04 0xB5 0x00 0x01 0x1C 0x99 0x00;\n+            0x0B 0x2A 0x04 0xB5 0x00 0x07 0xA7 0x00 0x15 0x2A 0x05 0xB5;\n+            0x00 0x07 0xA7 0x00 0x0D 0x2A 0x2A 0x06 0x5A 0xB5 0x00 0x07;\n+            0xB5 0x00 0x01 0x2A 0xB7 0x00 0x0A 0xB1;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  121;\n+                   4  122;\n+                   9  123;\n+                  13  124;\n+                  21  126;\n+                  29  129;\n+                  39  131;\n+                  43  132;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+            ;\n+            Attr(#36) {                    \/\/ StackMapTable\n+              [] {                         \/\/\n+                246b, []{#8; #5}, {       \/\/ FAIL: early_larval_frame contains cp index that isn't NameAndType\n+                  21b;                     \/\/ same\n+                };\n+                246b, []{#3; #8}, {        \/\/ early_larval_frame\n+                  7b;                      \/\/ same_frame\n+                };\n+                246b, []{}, {              \/\/ early_larval_frame\n+                  9b;                      \/\/ same_frame\n+                };\n+              }\n+            }                              \/\/ end of StackMapTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #18;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x01 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  134;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #22;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x07 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  135;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0001;                              \/\/ access\n+      #25;                                 \/\/ name_index\n+      #26;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          3;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB6 0x00 0x10 0x2A 0xB6 0x00 0x14 0x2A 0xB7 0x00 0x17;\n+            0xBA 0x00 0x1B 0x00 0x00 0xB0;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  139;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Methods\n+\n+  [] {                                     \/\/ Attributes\n+    Attr(#37) {                            \/\/ SourceFile\n+      #38;\n+    }                                      \/\/ end of SourceFile\n+    ;\n+    Attr(#39) {                            \/\/ BootstrapMethods\n+      [] {                                 \/\/ bootstrap_methods\n+        {                                  \/\/ bootstrap_method\n+          #42;                             \/\/ bootstrap_method_ref\n+          [] {                             \/\/ bootstrap_arguments\n+            #40;\n+          }                                \/\/ bootstrap_arguments\n+        }                                  \/\/ bootstrap_method\n+      }\n+    }                                      \/\/ end of BootstrapMethods\n+    ;\n+    Attr(#48) {                            \/\/ InnerClasses\n+      [] {                                 \/\/ classes\n+          #49   #51   #53  57;\n+      }\n+    }                                      \/\/ end of InnerClasses\n+  }                                        \/\/ end of Attributes\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/InvalidIndexInEarlyLarval.jcod","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class NestedEarlyLarval {\n+  0xCAFEBABE;\n+  65535;                                   \/\/ minor version\n+  70;                                      \/\/ version\n+  [] {                                     \/\/ Constant Pool\n+    ;                                      \/\/ first element is empty\n+    Field #2 #3;                           \/\/ #1\n+    Class #4;                              \/\/ #2\n+    NameAndType #5 #6;                     \/\/ #3\n+    Utf8 \"NestedEarlyLarval\";               \/\/ #4\n+    Utf8 \"x\";                              \/\/ #5\n+    Utf8 \"I\";                              \/\/ #6\n+    Field #2 #8;                           \/\/ #7\n+    NameAndType #9 #6;                     \/\/ #8\n+    Utf8 \"y\";                              \/\/ #9\n+    Method #11 #12;                        \/\/ #10\n+    Class #13;                             \/\/ #11\n+    NameAndType #14 #15;                   \/\/ #12\n+    Utf8 \"Parent\";                         \/\/ #13\n+    Utf8 \"<init>\";                         \/\/ #14\n+    Utf8 \"()V\";                            \/\/ #15\n+    Method #2 #17;                         \/\/ #16\n+    NameAndType #18 #19;                   \/\/ #17\n+    Utf8 \"get_x\";                          \/\/ #18\n+    Utf8 \"()I\";                            \/\/ #19\n+    Method #2 #21;                         \/\/ #20\n+    NameAndType #22 #19;                   \/\/ #21\n+    Utf8 \"get_y\";                          \/\/ #22\n+    Method #11 #24;                        \/\/ #23\n+    NameAndType #25 #26;                   \/\/ #24\n+    Utf8 \"toString\";                       \/\/ #25\n+    Utf8 \"()Ljava\/lang\/String;\";           \/\/ #26\n+    InvokeDynamic 0s #28;                  \/\/ #27\n+    NameAndType #29 #30;                   \/\/ #28\n+    Utf8 \"makeConcatWithConstants\";        \/\/ #29\n+    Utf8 \"(IILjava\/lang\/String;)Ljava\/lang\/String;\";  \/\/ #30\n+    Utf8 \"RuntimeInvisibleAnnotations\";    \/\/ #31\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\";  \/\/ #32\n+    Utf8 \"(ZZ)V\";                          \/\/ #33\n+    Utf8 \"Code\";                           \/\/ #34\n+    Utf8 \"LineNumberTable\";                \/\/ #35\n+    Utf8 \"StackMapTable\";                  \/\/ #36\n+    Utf8 \"SourceFile\";                     \/\/ #37\n+    Utf8 \"StrictInstanceFieldsTest.java\";  \/\/ #38\n+    Utf8 \"BootstrapMethods\";               \/\/ #39\n+    String #41;                            \/\/ #40\n+    Utf8 \"x: \\u0001\\ny: \\u0001\\n\\u0001\";   \/\/ #41\n+    MethodHandle 6b #43;                   \/\/ #42\n+    Method #44 #45;                        \/\/ #43\n+    Class #46;                             \/\/ #44\n+    NameAndType #29 #47;                   \/\/ #45\n+    Utf8 \"java\/lang\/invoke\/StringConcatFactory\";  \/\/ #46\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";  \/\/ #47\n+    Utf8 \"InnerClasses\";                   \/\/ #48\n+    Class #50;                             \/\/ #49\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\";  \/\/ #50\n+    Class #52;                             \/\/ #51\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\";  \/\/ #52\n+    Utf8 \"Lookup\";                         \/\/ #53\n+  }\n+\n+  0x0020;                                  \/\/ access\n+  #2;                                      \/\/ this_cpx\n+  #11;                                     \/\/ super_cpx\n+\n+  [] {                                     \/\/ Interfaces\n+  }                                        \/\/ end of Interfaces\n+\n+  [] {                                     \/\/ Fields\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #5;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #9;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Fields\n+\n+  [] {                                     \/\/ Methods\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #14;                                 \/\/ name_index\n+      #33;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          4;                               \/\/ max_stack\n+          3;                               \/\/ max_locals\n+          Bytes[]{\n+            0x1B 0x99 0x00 0x1C 0x2A 0x04 0xB5 0x00 0x01 0x1C 0x99 0x00;\n+            0x0B 0x2A 0x04 0xB5 0x00 0x07 0xA7 0x00 0x15 0x2A 0x05 0xB5;\n+            0x00 0x07 0xA7 0x00 0x0D 0x2A 0x2A 0x06 0x5A 0xB5 0x00 0x07;\n+            0xB5 0x00 0x01 0x2A 0xB7 0x00 0x0A 0xB1;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  121;\n+                   4  122;\n+                   9  123;\n+                  13  124;\n+                  21  126;\n+                  29  129;\n+                  39  131;\n+                  43  132;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+            ;\n+            Attr(#36) {                    \/\/ StackMapTable\n+              [] {                         \/\/\n+                246b, []{#8}, {            \/\/ early_larval_frame\n+                  246b;                    \/\/ early_larval_frame, illegal\n+                };\n+                246b, []{#3; #8}, {        \/\/ early_larval_frame\n+                  7b;                      \/\/ same_frame\n+                };\n+                246b, []{}, {              \/\/ early_larval_frame\n+                  9b;                      \/\/ same_frame\n+                };\n+              }\n+            }                              \/\/ end of StackMapTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #18;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x01 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  134;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #22;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x07 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  135;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0001;                              \/\/ access\n+      #25;                                 \/\/ name_index\n+      #26;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          3;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB6 0x00 0x10 0x2A 0xB6 0x00 0x14 0x2A 0xB7 0x00 0x17;\n+            0xBA 0x00 0x1B 0x00 0x00 0xB0;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  139;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Methods\n+\n+  [] {                                     \/\/ Attributes\n+    Attr(#37) {                            \/\/ SourceFile\n+      #38;\n+    }                                      \/\/ end of SourceFile\n+    ;\n+    Attr(#39) {                            \/\/ BootstrapMethods\n+      [] {                                 \/\/ bootstrap_methods\n+        {                                  \/\/ bootstrap_method\n+          #42;                             \/\/ bootstrap_method_ref\n+          [] {                             \/\/ bootstrap_arguments\n+            #40;\n+          }                                \/\/ bootstrap_arguments\n+        }                                  \/\/ bootstrap_method\n+      }\n+    }                                      \/\/ end of BootstrapMethods\n+    ;\n+    Attr(#48) {                            \/\/ InnerClasses\n+      [] {                                 \/\/ classes\n+          #49   #51   #53  57;\n+      }\n+    }                                      \/\/ end of InnerClasses\n+  }                                        \/\/ end of Attributes\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/NestedEarlyLarval.jcod","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class StrictFieldsNotSubset extends Parent {\n+    @Strict\n+    int x;\n+    @Strict\n+    int y;\n+\n+    StrictFieldsNotSubset(boolean a, boolean b) {\n+        if (a) {\n+            x = 1;\n+            if (b) {\n+                y = 1;\n+            } else {\n+                y = 2;\n+            }\n+        } else {\n+            x = y = 3;\n+        }\n+        super();\n+    }\n+}\n+*\/\n+\n+class StrictFieldsNotSubset {\n+  0xCAFEBABE;\n+  65535;                                   \/\/ minor version\n+  70;                                      \/\/ version\n+  [] {                                     \/\/ Constant Pool\n+    ;                                      \/\/ first element is empty\n+    Field #2 #3;                           \/\/ #1\n+    Class #4;                              \/\/ #2\n+    NameAndType #5 #6;                     \/\/ #3\n+    Utf8 \"StrictFieldsNotSubset\";          \/\/ #4\n+    Utf8 \"x\";                              \/\/ #5\n+    Utf8 \"I\";                              \/\/ #6\n+    Field #2 #8;                           \/\/ #7\n+    NameAndType #9 #6;                     \/\/ #8\n+    Utf8 \"y\";                              \/\/ #9\n+    Method #11 #12;                        \/\/ #10\n+    Class #13;                             \/\/ #11\n+    NameAndType #14 #15;                   \/\/ #12\n+    Utf8 \"Parent\";                         \/\/ #13\n+    Utf8 \"<init>\";                         \/\/ #14\n+    Utf8 \"()V\";                            \/\/ #15\n+    Method #2 #17;                         \/\/ #16\n+    NameAndType #18 #19;                   \/\/ #17\n+    Utf8 \"get_x\";                          \/\/ #18\n+    Utf8 \"()I\";                            \/\/ #19\n+    Method #2 #21;                         \/\/ #20\n+    NameAndType #22 #19;                   \/\/ #21\n+    Utf8 \"get_y\";                          \/\/ #22\n+    Method #11 #24;                        \/\/ #23\n+    NameAndType #25 #26;                   \/\/ #24\n+    Utf8 \"toString\";                       \/\/ #25\n+    Utf8 \"()Ljava\/lang\/String;\";           \/\/ #26\n+    InvokeDynamic 0s #28;                  \/\/ #27\n+    NameAndType #29 #30;                   \/\/ #28\n+    Utf8 \"makeConcatWithConstants\";        \/\/ #29\n+    Utf8 \"(IILjava\/lang\/String;)Ljava\/lang\/String;\";  \/\/ #30\n+    Utf8 \"RuntimeInvisibleAnnotations\";    \/\/ #31\n+    Utf8 \"Ljdk\/internal\/vm\/annotation\/Strict;\";  \/\/ #32\n+    Utf8 \"(ZZ)V\";                          \/\/ #33\n+    Utf8 \"Code\";                           \/\/ #34\n+    Utf8 \"LineNumberTable\";                \/\/ #35\n+    Utf8 \"StackMapTable\";                  \/\/ #36\n+    Utf8 \"SourceFile\";                     \/\/ #37\n+    Utf8 \"StrictInstanceFieldsTest.java\";  \/\/ #38\n+    Utf8 \"BootstrapMethods\";               \/\/ #39\n+    String #41;                            \/\/ #40\n+    Utf8 \"x: \\u0001\\ny: \\u0001\\n\\u0001\";   \/\/ #41\n+    MethodHandle 6b #43;                   \/\/ #42\n+    Method #44 #45;                        \/\/ #43\n+    Class #46;                             \/\/ #44\n+    NameAndType #29 #47;                   \/\/ #45\n+    Utf8 \"java\/lang\/invoke\/StringConcatFactory\";  \/\/ #46\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\";  \/\/ #47\n+    Utf8 \"InnerClasses\";                   \/\/ #48\n+    Class #50;                             \/\/ #49\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\";  \/\/ #50\n+    Class #52;                             \/\/ #51\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\";  \/\/ #52\n+    Utf8 \"Lookup\";                         \/\/ #53\n+  }\n+\n+  0x0020;                                  \/\/ access\n+  #2;                                      \/\/ this_cpx\n+  #11;                                     \/\/ super_cpx\n+\n+  [] {                                     \/\/ Interfaces\n+  }                                        \/\/ end of Interfaces\n+\n+  [] {                                     \/\/ Fields\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #5;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ field\n+      0x0800;                              \/\/ access\n+      #9;                                  \/\/ name_index\n+      #6;                                  \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#31) {                        \/\/ RuntimeInvisibleAnnotations\n+          [] {                             \/\/ annotations\n+            {                              \/\/ annotation\n+              #32;\n+              [] {                         \/\/ element_value_pairs\n+              }                            \/\/ element_value_pairs\n+            }                              \/\/ annotation\n+          }\n+        }                                  \/\/ end of RuntimeInvisibleAnnotations\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Fields\n+\n+  [] {                                     \/\/ Methods\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #14;                                 \/\/ name_index\n+      #33;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          4;                               \/\/ max_stack\n+          3;                               \/\/ max_locals\n+          Bytes[]{\n+            0x1B 0x99 0x00 0x1C 0x2A 0x04 0xB5 0x00 0x01 0x1C 0x99 0x00;\n+            0x0B 0x2A 0x04 0xB5 0x00 0x07 0xA7 0x00 0x15 0x2A 0x05 0xB5;\n+            0x00 0x07 0xA7 0x00 0x0D 0x2A 0x2A 0x06 0x5A 0xB5 0x00 0x07;\n+            0xB5 0x00 0x01 0x2A 0xB7 0x00 0x0A 0xB1;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  121;\n+                   4  122;\n+                   9  123;\n+                  13  124;\n+                  21  126;\n+                  29  129;\n+                  39  131;\n+                  43  132;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+            ;\n+            Attr(#36) {                    \/\/ StackMapTable\n+              [] {                         \/\/\n+                246b, []{#8; #12}, {       \/\/ FAIL: early_larval_frame contains NameAndType not present in original list of strict fields\n+                  21b;                     \/\/ same\n+                };\n+                246b, []{#3; #8}, {        \/\/ early_larval_frame\n+                  7b;                      \/\/ same_frame\n+                };\n+                246b, []{}, {              \/\/ early_larval_frame\n+                  9b;                      \/\/ same_frame\n+                };\n+              }\n+            }                              \/\/ end of StackMapTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #18;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x01 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  134;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0000;                              \/\/ access\n+      #22;                                 \/\/ name_index\n+      #19;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          1;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB4 0x00 0x07 0xAC;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  135;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+    ;\n+    {                                      \/\/ method\n+      0x0001;                              \/\/ access\n+      #25;                                 \/\/ name_index\n+      #26;                                 \/\/ descriptor_index\n+      [] {                                 \/\/ Attributes\n+        Attr(#34) {                        \/\/ Code\n+          3;                               \/\/ max_stack\n+          1;                               \/\/ max_locals\n+          Bytes[]{\n+            0x2A 0xB6 0x00 0x10 0x2A 0xB6 0x00 0x14 0x2A 0xB7 0x00 0x17;\n+            0xBA 0x00 0x1B 0x00 0x00 0xB0;\n+          }\n+          [] {                             \/\/ Traps\n+          }                                \/\/ end of Traps\n+          [] {                             \/\/ Attributes\n+            Attr(#35) {                    \/\/ LineNumberTable\n+              [] {                         \/\/ line_number_table\n+                   0  139;\n+              }\n+            }                              \/\/ end of LineNumberTable\n+          }                                \/\/ end of Attributes\n+        }                                  \/\/ end of Code\n+      }                                    \/\/ end of Attributes\n+    }\n+  }                                        \/\/ end of Methods\n+\n+  [] {                                     \/\/ Attributes\n+    Attr(#37) {                            \/\/ SourceFile\n+      #38;\n+    }                                      \/\/ end of SourceFile\n+    ;\n+    Attr(#39) {                            \/\/ BootstrapMethods\n+      [] {                                 \/\/ bootstrap_methods\n+        {                                  \/\/ bootstrap_method\n+          #42;                             \/\/ bootstrap_method_ref\n+          [] {                             \/\/ bootstrap_arguments\n+            #40;\n+          }                                \/\/ bootstrap_arguments\n+        }                                  \/\/ bootstrap_method\n+      }\n+    }                                      \/\/ end of BootstrapMethods\n+    ;\n+    Attr(#48) {                            \/\/ InnerClasses\n+      [] {                                 \/\/ classes\n+          #49   #51   #53  57;\n+      }\n+    }                                      \/\/ end of InnerClasses\n+  }                                        \/\/ end of Attributes\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFieldsNotSubset.jcod","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class TryCatchChild extends Parent {\n+    @Strict int x;\n+    @Strict int y;\n+\n+    TryCatchChild() {\n+        try {\n+            x = 0;\n+            int[] a = new int[1];\n+            System.out.println(a[2]);\n+        } catch (java.lang.ArrayIndexOutOfBoundsException e) {\n+            y = 0;\n+        }\n+        super();\n+    }\n+}\n+*\/\n+\n+identity class TryCatchChildBad extends Parent version 70:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field x:I;\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict Field y:I;\n+\n+  Method       \"<init>\":\"()V\"\n+    stack 4  locals 2\n+  {\n+         try               T0, T1;\n+         aload_0;\n+         iconst_0;\n+         putfield          Field x:\"I\";\n+         iconst_1;\n+         newarray          int;\n+         astore_1;\n+         getstatic         Field java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+         aload_1;\n+         iconst_2;\n+         iaload;\n+         invokevirtual     Method java\/io\/PrintStream.println:\"(I)V\";\n+         endtry            T0,T1;\n+         goto              L63;\n+         catch             T0 java\/lang\/ArrayIndexOutOfBoundsException;\n+         try               T2;\n+         stack_frame_type  stack1;\n+           stack_map       class java\/lang\/ArrayIndexOutOfBoundsException;\n+         astore_1;\n+         aload_0;\n+         iconst_0;\n+         putfield          Field y:\"I\";\n+         endtry            T2;\n+         goto              L63;\n+         catch             T1 #0;\n+         catch             T2 #0;\n+         stack_frame_type  stack1;\n+           stack_map       class java\/lang\/Throwable;\n+         astore_2;\n+         aload_2;\n+         athrow;\n+  L63:   stack_frame_type  early_larval;\n+           unset_fields;\n+           frame_type      same;\n+         aload_0;\n+         invokespecial     Method Parent.\"<init>\":\"()V\";\n+         return;\n+  }\n+} \/\/ end Class TryCatchChildBad\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/TryCatchChildBad.jasm","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+class WriteAfterReadRefl {\n+        @Strict static final String F1__STRICT;\n+        @Strict static final int    F2__STRICT;\n+        static {\n+            \/\/ Bytecode write\n+            F1__STRICT = \"foo\";\n+            F2__STRICT = 42;\n+\n+\n+            \/\/ Reflective read\n+            Field FIELD_F2 = findField(WriteAfterReadRefl.class, \"F2__STRICT\");\n+            int x = (int) getstaticReflective(FIELD_F2);\n+\n+            \/\/ Bytecode write after read (FAIL)\n+            F2__STRICT = 43;\n+        }\n+    }\n+*\/\n+\n+super class WriteAfterReadRefl version 70:65535\n+{\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static final  Field F1__STRICT:\"Ljava\/lang\/String;\";\n+  @-jdk\/internal\/vm\/annotation\/Strict { }\n+  strict static final Field F2__STRICT:I;\n+\n+  Method       \"<init>\":\"(LStrictStaticFieldsTest;)V\"\n+    stack 2  locals 2\n+     0:  #{ #0 final mandated }\n+  {\n+         aload_1;\n+         dup;\n+         invokestatic      Method java\/util\/Objects.requireNonNull:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\";\n+         pop;\n+         pop;\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  static Method \"<clinit>\":\"()V\"\n+    stack 2  locals 2\n+  {\n+         ldc               String \"foo\";\n+         putstatic         Field F1__STRICT:\"Ljava\/lang\/String;\";\n+         bipush            42;\n+         putstatic         Field F2__STRICT:\"I\";\n+         ldc               class WriteAfterReadRefl;\n+         ldc               String \"F2__STRICT\";\n+         invokestatic      Method StrictStaticFieldsTest.findField:\"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/reflect\/Field;\";\n+         astore_0;\n+         aload_0;\n+         invokestatic      Method StrictStaticFieldsTest.getstaticReflective:\"(Ljava\/lang\/reflect\/Field;)Ljava\/lang\/Object;\";\n+         checkcast         class java\/lang\/Integer;\n+         invokevirtual     Method java\/lang\/Integer.intValue:\"()I\";\n+         istore_1;\n+         bipush            43;\n+         putstatic         Field F2__STRICT:\"I\";\n+         return;\n+  }\n+} \/\/ end Class WriteAfterReadRefl\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/WriteAfterReadRefl.jasm","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Defines the classes used by StrictFields.java to check verification\n+\/\/ of strict fields.\n+\n+\/\/ StrictIgnore is an earlier classfile version for which strict must be ignored\n+\/\/ so we can write to it multiple times in the constructor.\n+public class StrictIgnore version 66:0 {\n+  final strict Field x:I;\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      aload_0;\n+      invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      return;\n+   }\n+}\n+\n+\/\/ StrictBase is a well formed value class with a strict field, that can\n+\/\/ be used for subclassing.\n+public abstract class StrictBase version 70:65535 {\n+  protected final strict Field x:I;\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      aload_0;\n+      invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+      return;\n+   }\n+}\n+\n+\/\/ PostInitStrict is a bad value class that writes to a strict field after the\n+\/\/ super constructor call.\n+public final class PostInitStrict version 70:65535 {\n+  final strict Field y:I;\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+      aload_0;\n+      iconst_1;\n+      putfield y:I;\n+      return;\n+   }\n+}\n+\n+\/\/ BadStrictSubPreInit is a bad value class that tries to write to an inherited\n+\/\/ strict field while acting on UninitializedThis.\n+public final class BadStrictSubPreInit extends StrictBase version 70:65535 {\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      aload_0;\n+      invokespecial Method StrictBase.\"<init>\":\"()V\";\n+      return;\n+   }\n+}\n+\n+\/\/ BadStrictSubPostInit is a bad value class that tries to write to an inherited\n+\/\/ strict field in \"regular\" code.\n+public final class BadStrictSubPostInit extends StrictBase version 70:65535 {\n+\n+  public Method \"<init>\":\"()V\" stack 2 {\n+      aload_0;\n+      invokespecial Method StrictBase.\"<init>\":\"()V\";\n+      aload_0;\n+      iconst_1;\n+      putfield x:I;\n+      return;\n+   }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/strictFields.jasm","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,1608 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ Many of the jcod classes in this file were derived from this Java inline type:\n+\/\/\n+\/\/ final inline class Value {\n+\/\/     static final Value VT = makeValue(0x01234567);\n+\/\/     final int int_v;\n+\/\/     Value() {\n+\/\/         int_v = 1;\n+\/\/     }\n+\/\/     static Value makeValue(int x) {\n+\/\/         Value v = Value.default;\n+\/\/         v = __WithField(v.int_v, x);\n+\/\/         return v;\n+\/\/     }\n+\/\/ }\n+\/\/\n+\/\/ The changes for each test were made to the bytecodes for method makeValue(int x).\n+\/\/ Its bytecodes are:\n+\/\/\n+\/\/  static Value makeValue(int); descriptor: (I)LValue; flags: (0x0008) ACC_STATIC\n+\/\/    Code:\n+\/\/      stack=2, locals=2, args_size=1\n+\/\/         0: aconst_init   #3                  \/\/ class Value\n+\/\/         3: astore_1\n+\/\/         4: aload_1\n+\/\/         5: iload_0\n+\/\/         6: withfield     #2                  \/\/ Field int_v:I\n+\/\/         9: astore_1\n+\/\/        10: aload_1\n+\/\/        11: areturn\n+\n+\n+\/\/ The constant pool index of the aconst_init opcode (0xCB) in the Code\n+\/\/ attribute was changed to 0x93.  Since this index is outside the range of\n+\/\/ the constant pool, a VerifyError exception should get thrown.\n+\/\/\n+class defValBadCP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValBadCP;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValBadCP;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValBadCP.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValBadCP\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00934C2B1ACC00; \/\/ Changed CP index from 3 to 0x93 for opcode 0xCB (aconst_init)\n+            0x024C2BB0;         \/\/ so that the index is outside of the range of the constant pool.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValBadCP\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The class's major version was changed to 54.  Since this class has a\n+\/\/ aconst_init opcode (0xCB), this should cause a ClassFormatError\n+\/\/ exception to get thrown.\n+\/\/\n+class defValBadMajorVersion {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  54; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValBadMajorVersion;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValBadMajorVersion;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValBadMajorVersion.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValBadMajorVersion\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00;\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValBadMajorVersion\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of a aconst_init opcode (0xCB) in the Code\n+\/\/ attribute was changed to 2.  Since this index now points to a Field\n+\/\/ entry instead of a Class entry, a VerifyError exception should get thrown.\n+\/\/\n+class defValWrongCPType {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LdefValWrongCPType;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LdefValWrongCPType;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"defValWrongCPType.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"defValWrongCPType\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00024C2B1ACC00; \/\/ Changed CP index from 3 to 2 for opcode 0xCB (aconst_init)\n+            0x024C2BB0;         \/\/ so that the cp index no longer points to a cp Class entry.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class defValWrongCPType\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of the withfield opcode (0xCC) in the Code\n+\/\/ attribute was changed to 0x82.  Since this index is outside the range of\n+\/\/ the constant pool, a VerifyError exception should get thrown.\n+\/\/\n+class wthFldBadCP {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadCP\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadCP\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadCP;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadCP.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00; \/\/ Changed CP index from 2 to 0x82 for opcode 0xCC (withfield)\n+            0x824C2BB0;         \/\/ so that the index is outside of the range of the constant pool.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadCP\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The opcode at bytecode position 5 in the Code array was changed to aload_1\n+\/\/ (0x2B).  This should cause a VerifyError because now the first operand on the\n+\/\/ stack for the withfield opcode (0xCC at bytecode position 6) does not match\n+\/\/ the type (int) of the field being assigned to.\n+\/\/\n+class wthFldBadFldVal {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadFldVal\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadFldVal\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadFldVal;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadFldVal.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B2BCC00; \/\/ Changed opcode at bytecode 5 from iload_0 to aload_1\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadFldVal\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The opcode at bytecode position 4 in the Code array was changed to iload_1\n+\/\/ (0x1A).  This should cause a VerifyError because the second operand on the stack\n+\/\/ for the withfield opcode (0xCC at bytecode position 6) must be a reference.\n+\/\/\n+class wthFldBadFldRef {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldBadFldRef\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldBadFldRef\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldBadFldRef;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldBadFldRef.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C1A1ACC00; \/\/ Changed opcode at bytecode 4 from aload_1 to iload_0\n+            0x024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadFldRef\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The class's major version was changed to 54 and the first opcode in the Code\n+\/\/ attribute was changed to a withfield (0xCC)..  Since withfield opcodes are not\n+\/\/ allowed in classes with major version 54, this should cause a ClassFormatError\n+\/\/ exception to get thrown.\n+\/\/\n+class wthFldBadMajorVersion {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  54; \/\/ version\n+  [27] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #7 #21; \/\/ #1     at 0x0A\n+    Field #3 #22; \/\/ #2     at 0x0F\n+    class #23; \/\/ #3     at 0x14\n+    int 0x01234567; \/\/ #4     at 0x17\n+    Method #3 #24; \/\/ #5     at 0x1C\n+    Field #3 #25; \/\/ #6     at 0x21\n+    class #26; \/\/ #7     at 0x26\n+    Utf8 \"VT\"; \/\/ #8     at 0x29\n+    Utf8 \"LwthFldBadMajorVersion;\"; \/\/ #9     at 0x2E\n+    Utf8 \"int_v\"; \/\/ #10     at 0x38\n+    Utf8 \"I\"; \/\/ #11     at 0x40\n+    Utf8 \"<init>\"; \/\/ #12     at 0x44\n+    Utf8 \"()V\"; \/\/ #13     at 0x4D\n+    Utf8 \"Code\"; \/\/ #14     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #15     at 0x5A\n+    Utf8 \"makeValue\"; \/\/ #16     at 0x6C\n+    Utf8 \"(I)LwthFldBadMajorVersion;\"; \/\/ #17     at 0x78\n+    Utf8 \"<clinit>\"; \/\/ #18     at 0x85\n+    Utf8 \"SourceFile\"; \/\/ #19     at 0x90\n+    Utf8 \"wthFldBadMajorVersion.java\"; \/\/ #20     at 0x9D\n+    NameAndType #12 #13; \/\/ #21     at 0xAA\n+    NameAndType #10 #11; \/\/ #22     at 0xAF\n+    Utf8 \"wthFldBadMajorVersion\"; \/\/ #23     at 0xB4\n+    NameAndType #16 #17; \/\/ #24     at 0xBC\n+    NameAndType #8 #9; \/\/ #25     at 0xC1\n+    Utf8 \"java\/lang\/Object\"; \/\/ #26     at 0xC6\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #7;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0xE3\n+      0x0018; \/\/ access\n+      #8; \/\/ name_cpx\n+      #9; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xEB\n+      0x0010; \/\/ access\n+      #10; \/\/ name_cpx\n+      #11; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x012D\n+      0x0008; \/\/ access\n+      #16; \/\/ name_cpx\n+      #17; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#14, 44) { \/\/ Code at 0x0135\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCC00034C2B1ACC00; \/\/ Changed the first opcode to 0xCC (withfield) in order to\n+            0x024C2BB0;         \/\/ test withfield opcode with an illegal major version.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#15, 14) { \/\/ LineNumberTable at 0x0153\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x015F\n+                4  9; \/\/  at 0x0163\n+                10  10; \/\/  at 0x0167\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [1] { \/\/ Attributes\n+    Attr(#19, 2) { \/\/ SourceFile at 0x0198\n+      #20;\n+    } \/\/ end SourceFile\n+  } \/\/ Attributes\n+} \/\/ end class wthFldBadMajorVersion\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The constant pool index of a withfield opcode (0xCC) in the Code\n+\/\/ attribute was changed to 1.  Since this index now points to a Method\n+\/\/ entry instead of a Field entry, a VerifyError exception should get thrown.\n+\/\/\n+class wthFldWrongCPType {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #4 #17; \/\/ #1     at 0x0A\n+    Field #3 #18; \/\/ #2     at 0x0F\n+    class #12; \/\/ #3     at 0x14\n+    class #19; \/\/ #4     at 0x17\n+    Utf8 \"int_v\"; \/\/ #5     at 0x1A\n+    Utf8 \"I\"; \/\/ #6     at 0x22\n+    Utf8 \"<vnew>\"; \/\/ #7     at 0x26\n+    Utf8 \"()V\"; \/\/ #8     at 0x2F\n+    Utf8 \"Code\"; \/\/ #9     at 0x35\n+    Utf8 \"LineNumberTable\"; \/\/ #10     at 0x3C\n+    Utf8 \"makewthFldWrongCPType\"; \/\/ #11     at 0x4E\n+    Utf8 \"wthFldWrongCPType\"; \/\/ #12     at 0x60\n+    Utf8 \"ValueTypes\"; \/\/ #13     at 0x6E\n+    Utf8 \"(I)LwthFldWrongCPType;\"; \/\/ #14     at 0x7B\n+    Utf8 \"SourceFile\"; \/\/ #15     at 0x8E\n+    Utf8 \"wthFldWrongCPType.java\"; \/\/ #16     at 0x9B\n+    NameAndType #7 #8; \/\/ #17     at 0xAE\n+    NameAndType #5 #6; \/\/ #18     at 0xB3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #19     at 0xB8\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #3;\/\/ this_cpx\n+  #4;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0xD5\n+      0x0010; \/\/ access\n+      #5; \/\/ name_cpx\n+      #6; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [1] { \/\/ methods\n+    { \/\/ Member at 0x0117\n+      0x0008; \/\/ access\n+      #11; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#9, 44) { \/\/ Code at 0x011F\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[12]{\n+            0xCB00034C2B1ACC00; \/\/ Changed CP index from 2 to 1 for opcode 0xCC (withfield)\n+            0x014C2BB0;         \/\/ so that the cp index no longer points to a cp Field entry.\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#10, 14) { \/\/ LineNumberTable at 0x013D\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x0149\n+                4  9; \/\/  at 0x014D\n+                10  10; \/\/  at 0x0151\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#15, 2) { \/\/ SourceFile at 0x0153\n+      #16;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13, 4) { \/\/ ValueTypes at 0x015B\n+      0x00010003;\n+    } \/\/ end ValueTypes\n+  } \/\/ Attributes\n+} \/\/ end class wthFldWrongCPType\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ The cp entry for the aconst_init opcode was changed to a reference that\n+\/\/ is not an inline type.\n+\/\/ This should cause a VerifyError because the cp entry for opcode aconst_init\n+\/\/ must be an inline type.\n+\/\/\n+class defValueObj {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [46] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #23; \/\/ #1     at 0x0A\n+    Field #1 #24; \/\/ #2     at 0x0D\n+    InvokeDynamic 0s #27; \/\/ #3     at 0x12\n+    InvokeDynamic 0s #28; \/\/ #4     at 0x17\n+    InvokeDynamic 0s #29; \/\/ #5     at 0x1C\n+    class #30; \/\/ #6     at 0x21\n+    Utf8 \"int_v\"; \/\/ #7     at 0x24\n+    Utf8 \"I\"; \/\/ #8     at 0x2C\n+    Utf8 \"makedefValueObj\"; \/\/ #9     at 0x30\n+    Utf8 \"(I)QdefValueObj;\"; \/\/ #10     at 0x41\n+    Utf8 \"Code\"; \/\/ #11     at 0x53\n+    Utf8 \"LineNumberTable\"; \/\/ #12     at 0x5A\n+    Utf8 \"hashCode\"; \/\/ #13     at 0x6C\n+    Utf8 \"()I\"; \/\/ #14     at 0x77\n+    Utf8 \"equals\"; \/\/ #15     at 0x7D\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #16     at 0x86\n+    Utf8 \"toString\"; \/\/ #17     at 0x9E\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #18     at 0xA9\n+    Utf8 \"<vnew>\"; \/\/ #19     at 0xC0\n+    Utf8 \"()QdefValueObj;\"; \/\/ #20     at 0xC9\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xDA\n+    Utf8 \"defValueObj.java\"; \/\/ #22     at 0xE7\n+    Utf8 \"defValueObj\"; \/\/ #23     at 0xF9\n+    NameAndType #7 #8; \/\/ #24     at 0x0106\n+    Utf8 \"BootstrapMethods\"; \/\/ #25     at 0x010B\n+    MethodHandle 6b #31; \/\/ #26     at 0x011E\n+    NameAndType #13 #32; \/\/ #27     at 0x0122\n+    NameAndType #15 #33; \/\/ #28     at 0x0127\n+    NameAndType #17 #34; \/\/ #29     at 0x012C\n+    Utf8 \"java\/lang\/Object\"; \/\/ #30     at 0x0131\n+    Method #35 #36; \/\/ #31     at 0x0144\n+    Utf8 \"(QdefValueObj;)I\"; \/\/ #32     at 0x0149\n+    Utf8 \"(QdefValueObj;Ljava\/lang\/Object;)Z\"; \/\/ #33     at 0x015B\n+    Utf8 \"(QdefValueObj;)Ljava\/lang\/String;\"; \/\/ #34     at 0x017F\n+    class #37; \/\/ #35     at 0x01A2\n+    NameAndType #38 #42; \/\/ #36     at 0x01A5\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #37     at 0x01AA\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #38     at 0x01D3\n+    class #44; \/\/ #39     at 0x01E9\n+    Utf8 \"Lookup\"; \/\/ #40     at 0x01EC\n+    Utf8 \"InnerClasses\"; \/\/ #41     at 0x01F5\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #42     at 0x0204\n+    class #45; \/\/ #43     at 0x027A\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #44     at 0x027D\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #45     at 0x02A5\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #6;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ fields\n+    { \/\/ Member at 0x02D0\n+      0x0010; \/\/ access\n+      #7; \/\/ name_cpx\n+      #8; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [5] { \/\/ methods\n+    { \/\/ Member at 0x02DA\n+      0x0008; \/\/ access\n+      #9; \/\/ name_cpx\n+      #10; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x02E2\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00044C1A2B5FCC; \/\/ Changed aconst_init's cp index at byte 3 from 3 to 4.\n+            0x00024C2BB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x0301\n+              [3] { \/\/ LineNumberTable\n+                0  8; \/\/  at 0x030D\n+                4  9; \/\/  at 0x0311\n+                11  10; \/\/  at 0x0315\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0315\n+      0x0011; \/\/ access\n+      #13; \/\/ name_cpx\n+      #14; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x031D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00030000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0336\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0342\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0342\n+      0x0011; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 32) { \/\/ Code at 0x034A\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[8]{\n+            0x2A2BBA00040000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0364\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0370\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0370\n+      0x0011; \/\/ access\n+      #17; \/\/ name_cpx\n+      #18; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 31) { \/\/ Code at 0x0378\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00050000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 6) { \/\/ LineNumberTable at 0x0391\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x039D\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x039D\n+      0x0008; \/\/ access\n+      #19; \/\/ name_cpx\n+      #20; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#11, 45) { \/\/ Code at 0x03A5\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[13]{\n+            0xCB00014B042A5FCC;\n+            0x00024B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#12, 14) { \/\/ LineNumberTable at 0x03C4\n+              [3] { \/\/ LineNumberTable\n+                0  4; \/\/  at 0x03D0\n+                4  5; \/\/  at 0x03D4\n+                11  6; \/\/  at 0x03D8\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x03DA\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#41, 10) { \/\/ InnerClasses at 0x03E2\n+      [1] { \/\/ InnerClasses\n+        #39 #43 #40 25; \/\/  at 0x03F2\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#25, 6) { \/\/ BootstrapMethods at 0x03F2\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #26; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class defValueObj\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ This class has a withfield opcode with a non-Q type operand.\n+class withfieldL {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [28] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"withfieldL\"; \/\/ #2     at 0x0D\n+    class #2; \/\/ #3     at 0x17\n+    Field #1 #5; \/\/ #4     at 0x1A\n+    NameAndType #6 #7; \/\/ #5     at 0x1F\n+    Utf8 \"x\"; \/\/ #6     at 0x24\n+    Utf8 \"I\"; \/\/ #7     at 0x28\n+    Field #1 #9; \/\/ #8     at 0x2C\n+    NameAndType #10 #7; \/\/ #9     at 0x31\n+    Utf8 \"y\"; \/\/ #10     at 0x36\n+    class #12; \/\/ #11     at 0x3A\n+    Utf8 \"QwithfieldL;\"; \/\/ #12     at 0x3D\n+    class #14; \/\/ #13     at 0x49\n+    Utf8 \"java\/lang\/Object\"; \/\/ #14     at 0x4C\n+    Utf8 \"makePoint\"; \/\/ #15     at 0x5F\n+    Utf8 \"(II)QwithfieldL;\"; \/\/ #16     at 0x6B\n+    Utf8 \"Code\"; \/\/ #17     at 0x7B\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x82\n+    Utf8 \"<vnew>\"; \/\/ #19     at 0x94\n+    Utf8 \"()QwithfieldL;\"; \/\/ #20     at 0x9D\n+    Utf8 \"SourceFile\"; \/\/ #21     at 0xAB\n+    Utf8 \"X.java\"; \/\/ #22     at 0xB8\n+    Utf8 \"NestHost\"; \/\/ #23     at 0xC1\n+    class #25; \/\/ #24     at 0xCC\n+    Utf8 \"X\"; \/\/ #25     at 0xCF\n+    Utf8 \"InnerClasses\"; \/\/ #26     at 0xD3\n+    Utf8 \"Point\"; \/\/ #27     at 0xE2\n+  } \/\/ Constant Pool\n+\n+  0x0850; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #13;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ Fields\n+    {  \/\/ field at 0xF4\n+      0x0010; \/\/ access\n+      #6; \/\/ name_index       : x\n+      #7; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ field at 0xFC\n+      0x0010; \/\/ access\n+      #10; \/\/ name_index       : y\n+      #7; \/\/ descriptor_index : I\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0106\n+      0x0008; \/\/ access\n+      #15; \/\/ name_index       : makePoint\n+      #16; \/\/ descriptor_index : (II)QwithfieldL;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 62) { \/\/ Code at 0x010E\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[26]{\n+            0xCB0001C000034D1A;\n+            0x2C5FCC00044D1B2C;\n+            0x5FCC00084D2CC000;\n+            0x0BB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x013A\n+              [4] { \/\/ line_number_table\n+                0  4; \/\/  at 0x0146\n+                7  5; \/\/  at 0x014A\n+                14  6; \/\/  at 0x014E\n+                21  7; \/\/  at 0x0152\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x0152\n+      0x000A; \/\/ access\n+      #19; \/\/ name_index       : <vnew>\n+      #20; \/\/ descriptor_index : ()QwithfieldL;\n+      [1] { \/\/ Attributes\n+        Attr(#17, 55) { \/\/ Code at 0x015A\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[23]{\n+            0xCB00014B032A5FCC;\n+            0x0008594BB400082A;\n+            0x5FCC00044B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0183\n+              [3] { \/\/ line_number_table\n+                0  9; \/\/  at 0x018F\n+                4  10; \/\/  at 0x0193\n+                21  11; \/\/  at 0x0197\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#21, 2) { \/\/ SourceFile at 0x0199\n+      #22;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#23, 2) { \/\/ NestHost at 0x01A1\n+      #24; \/\/ X at 0x01A9\n+    } \/\/ end NestHost\n+    ;\n+    Attr(#26, 10) { \/\/ InnerClasses at 0x01A9\n+      [1] { \/\/ classes\n+        #1 #24 #27 280; \/\/  at 0x01B9\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class withfieldL\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test that a VerifyError exception is thrown when trying to pass a null\n+\/\/ when the formal parameter is an inline type.\n+\/\/\n+\/\/ \/\/ Java program emulating the jcod contents.\n+\/\/ public inline final class NoNullVT {\n+\/\/     final int x;\n+\/\/     final int y;\n+\/\/\n+\/\/     private NoNullVT() {\n+\/\/         x = 0;\n+\/\/         y = 0;\n+\/\/     }\n+\/\/\n+\/\/     public int getX() { return x; }\n+\/\/     public int getY() { return y; }\n+\/\/\n+\/\/     public boolean isSameNoNullVT(NoNullVT that) {\n+\/\/         return this.getX() == that.getX() && this.getY() == that.getY();\n+\/\/     }\n+\/\/\n+\/\/     public boolean equals(Object o) {\n+\/\/         if(o instanceof NoNullVT) {\n+\/\/             return ((NoNullVT)o).x == x &&  ((NoNullVT)o).y == y;\n+\/\/         } else {\n+\/\/             return false;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     public static NoNullVT createNoNullVT(int x, int y) {\n+\/\/         NoNullVT p = NoNullVT.default;\n+\/\/         p = __WithField(p.x, x);\n+\/\/         p = __WithField(p.y, y);\n+\/\/         return p;\n+\/\/     }\n+\/\/\n+\/\/     public static void main(String[] args) {\n+\/\/         String str = null;\n+\/\/         NoNullVT a = createNoNullVT(3, 4);\n+\/\/         NoNullVT b = createNoNullVT(2, 4);\n+\/\/         boolean res = a.isSameNoNullVT(null); \/\/ Should throw VerifyError\n+\/\/     }\n+\/\/ }\n+\n+class NoNullVT {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [63] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #36; \/\/ #1     at 0x0A\n+    Field #1 #37; \/\/ #2     at 0x0D\n+    Field #1 #38; \/\/ #3     at 0x12\n+    Method #1 #39; \/\/ #4     at 0x17\n+    Method #1 #40; \/\/ #5     at 0x1C\n+    class #41; \/\/ #6     at 0x21\n+    Method #1 #42; \/\/ #7     at 0x24\n+    Method #1 #43; \/\/ #8     at 0x29\n+    InvokeDynamic 0s #46; \/\/ #9     at 0x2E\n+    InvokeDynamic 0s #47; \/\/ #10     at 0x33\n+    class #48; \/\/ #11     at 0x38\n+    Utf8 \"x\"; \/\/ #12     at 0x3B\n+    Utf8 \"I\"; \/\/ #13     at 0x3F\n+    Utf8 \"y\"; \/\/ #14     at 0x43\n+    Utf8 \"getX\"; \/\/ #15     at 0x47\n+    Utf8 \"()I\"; \/\/ #16     at 0x4E\n+    Utf8 \"Code\"; \/\/ #17     at 0x54\n+    Utf8 \"LineNumberTable\"; \/\/ #18     at 0x5B\n+    Utf8 \"getY\"; \/\/ #19     at 0x6D\n+    Utf8 \"isSameNoNullVT\"; \/\/ #20     at 0x74\n+    Utf8 \"(QNoNullVT;)Z\"; \/\/ #21     at 0x85\n+    Utf8 \"StackMapTable\"; \/\/ #22     at 0x95\n+    Utf8 \"equals\"; \/\/ #23     at 0xA5\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #24     at 0xAE\n+    Utf8 \"createNoNullVT\"; \/\/ #25     at 0xC6\n+    Utf8 \"(II)QNoNullVT;\"; \/\/ #26     at 0xD7\n+    Utf8 \"main\"; \/\/ #27     at 0xE8\n+    Utf8 \"([Ljava\/lang\/String;)V\"; \/\/ #28     at 0xEF\n+    Utf8 \"hashCode\"; \/\/ #29     at 0x0108\n+    Utf8 \"toString\"; \/\/ #30     at 0x0113\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #31     at 0x011E\n+    Utf8 \"<vnew>\"; \/\/ #32     at 0x0135\n+    Utf8 \"()QNoNullVT;\"; \/\/ #33     at 0x013E\n+    Utf8 \"SourceFile\"; \/\/ #34     at 0x014D\n+    Utf8 \"NoNullVT.java\"; \/\/ #35     at 0x015A\n+    Utf8 \"NoNullVT\"; \/\/ #36     at 0x016A\n+    NameAndType #12 #13; \/\/ #37     at 0x0175\n+    NameAndType #14 #13; \/\/ #38     at 0x017A\n+    NameAndType #15 #16; \/\/ #39     at 0x017F\n+    NameAndType #19 #16; \/\/ #40     at 0x0184\n+    Utf8 \"QNoNullVT;\"; \/\/ #41     at 0x0189\n+    NameAndType #25 #26; \/\/ #42     at 0x0196\n+    NameAndType #20 #21; \/\/ #43     at 0x019B\n+    Utf8 \"BootstrapMethods\"; \/\/ #44     at 0x01A0\n+    MethodHandle 6b #49; \/\/ #45     at 0x01B3\n+    NameAndType #29 #50; \/\/ #46     at 0x01B7\n+    NameAndType #30 #51; \/\/ #47     at 0x01BC\n+    Utf8 \"java\/lang\/Object\"; \/\/ #48     at 0x01C1\n+    Method #52 #53; \/\/ #49     at 0x01D4\n+    Utf8 \"(QNoNullVT;)I\"; \/\/ #50     at 0x01D9\n+    Utf8 \"(QNoNullVT;)Ljava\/lang\/String;\"; \/\/ #51     at 0x01E9\n+    class #54; \/\/ #52     at 0x020A\n+    NameAndType #55 #59; \/\/ #53     at 0x020D\n+    Utf8 \"java\/lang\/invoke\/ValueBootstrapMethods\"; \/\/ #54     at 0x0212\n+    Utf8 \"makeBootstrapMethod\"; \/\/ #55     at 0x023B\n+    class #61; \/\/ #56     at 0x0251\n+    Utf8 \"Lookup\"; \/\/ #57     at 0x0254\n+    Utf8 \"InnerClasses\"; \/\/ #58     at 0x025D\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\"; \/\/ #59     at 0x026C\n+    class #62; \/\/ #60     at 0x02E2\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #61     at 0x02E5\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #62     at 0x030D\n+  } \/\/ Constant Pool\n+\n+  0x0851; \/\/ access [ ACC_VALUE ACC_PRIMITIVE ACC_PUBLIC ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #11;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [2] { \/\/ fields\n+    { \/\/ Member at 0x0338\n+      0x0010; \/\/ access\n+      #12; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0340\n+      0x0010; \/\/ access\n+      #14; \/\/ name_cpx\n+      #13; \/\/ sig_cpx\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [9] { \/\/ methods\n+    { \/\/ Member at 0x034A\n+      0x0001; \/\/ access\n+      #15; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x0352\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40002AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0369\n+              [1] { \/\/ LineNumberTable\n+                0  10; \/\/  at 0x0375\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0375\n+      0x0001; \/\/ access\n+      #19; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 29) { \/\/ Code at 0x037D\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5]{\n+            0x2AB40003AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0394\n+              [1] { \/\/ LineNumberTable\n+                0  11; \/\/  at 0x03A0\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03A0\n+      0x0001; \/\/ access\n+      #20; \/\/ name_cpx\n+      #21; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 63) { \/\/ Code at 0x03A8\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[28]{\n+            0x2AB600042BB60004;\n+            0xA000122AB600052B;\n+            0xB60005A0000704A7;\n+            0x000403AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x03D6\n+              [1] { \/\/ LineNumberTable\n+                0  14; \/\/  at 0x03E2\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#22, 5) { \/\/ StackMapTable at 0x03E2\n+              [2] { \/\/\n+                26b; \/\/ same_frame\n+                64b, [1]z{1b}; \/\/ same_locals_1_stack_item_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x03ED\n+      0x0001; \/\/ access\n+      #23; \/\/ name_cpx\n+      #24; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 87) { \/\/ Code at 0x03F5\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[43]{\n+            0x2BC100019900252B;\n+            0xC00006B400022AB4;\n+            0x0002A000152BC000;\n+            0x06B400032AB40003;\n+            0xA0000704A7000403;\n+            0xAC03AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [2] { \/\/ Attributes\n+            Attr(#18, 14) { \/\/ LineNumberTable at 0x0432\n+              [3] { \/\/ LineNumberTable\n+                0  18; \/\/  at 0x043E\n+                7  19; \/\/  at 0x0442\n+                41  21; \/\/  at 0x0446\n+              }\n+            } \/\/ end LineNumberTable\n+            ;\n+            Attr(#22, 6) { \/\/ StackMapTable at 0x0446\n+              [3] { \/\/\n+                39b; \/\/ same_frame\n+                64b, [1]z{1b}; \/\/ same_locals_1_stack_item_frame\n+                0b; \/\/ same_frame\n+              }\n+            } \/\/ end StackMapTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0452\n+      0x0009; \/\/ access\n+      #25; \/\/ name_cpx\n+      #26; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 56) { \/\/ Code at 0x045A\n+          2; \/\/ max_stack\n+          3; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014D1A2C5FCC;\n+            0x00024D1B2C5FCC00;\n+            0x034D2CB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x0480\n+              [4] { \/\/ LineNumberTable\n+                0  26; \/\/  at 0x048C\n+                4  27; \/\/  at 0x0490\n+                11  28; \/\/  at 0x0494\n+                18  29; \/\/  at 0x0498\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0498\n+      0x0009; \/\/ access\n+      #27; \/\/ name_cpx\n+      #28; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 62) { \/\/ Code at 0x04A0\n+          2; \/\/ max_stack\n+          5; \/\/ max_locals\n+          Bytes[22]{\n+            0x014C0607B800074D;\n+            0x0507B800074E2C2B; \/\/ Change last nibble from C to B to load null\n+            0xB600083604B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 22) { \/\/ LineNumberTable at 0x04C8\n+              [5] { \/\/ LineNumberTable\n+                0  33; \/\/  at 0x04D4\n+                2  34; \/\/  at 0x04D8\n+                8  35; \/\/  at 0x04DC\n+                14  36; \/\/  at 0x04E0\n+                21  37; \/\/  at 0x04E4\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x04E4\n+      0x0011; \/\/ access\n+      #29; \/\/ name_cpx\n+      #16; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 31) { \/\/ Code at 0x04EC\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA00090000AC;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0505\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x0511\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x0511\n+      0x0011; \/\/ access\n+      #30; \/\/ name_cpx\n+      #31; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 31) { \/\/ Code at 0x0519\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[7]{\n+            0x2ABA000A0000B0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 6) { \/\/ LineNumberTable at 0x0532\n+              [1] { \/\/ LineNumberTable\n+                0  1; \/\/  at 0x053E\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0x053E\n+      0x000A; \/\/ access\n+      #32; \/\/ name_cpx\n+      #33; \/\/ sig_cpx\n+      [1] { \/\/ Attributes\n+        Attr(#17, 56) { \/\/ Code at 0x0546\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[20]{\n+            0xCB00014B032A5FCC;\n+            0x00024B032A5FCC00;\n+            0x034B2AB0;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#18, 18) { \/\/ LineNumberTable at 0x056C\n+              [4] { \/\/ LineNumberTable\n+                0  5; \/\/  at 0x0578\n+                4  6; \/\/  at 0x057C\n+                11  7; \/\/  at 0x0580\n+                18  8; \/\/  at 0x0584\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#34, 2) { \/\/ SourceFile at 0x0586\n+      #35;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#58, 10) { \/\/ InnerClasses at 0x058E\n+      [1] { \/\/ InnerClasses\n+        #56 #60 #57 25; \/\/  at 0x059E\n+      }\n+    } \/\/ end InnerClasses\n+    ;\n+    Attr(#44, 6) { \/\/ BootstrapMethods at 0x059E\n+      [1] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #45; \/\/ bootstrap_method_ref\n+          [0] { \/\/ bootstrap_arguments\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+  } \/\/ Attributes\n+} \/\/ end class NoNullVT\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/verifierTests.jcod","additions":1608,"deletions":0,"binary":false,"changes":1608,"status":"added"},{"patch":"@@ -340,0 +340,1 @@\n+    int ACC_IDENTITY = 0x0020; \/\/ class\n","filename":"test\/hotspot\/jtreg\/testlibrary\/asm\/org\/objectweb\/asm\/Opcodes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -538,0 +538,5 @@\n+java\/lang\/ModuleLayer\/LayerControllerTest.java                  8337048 generic-all\n+java\/lang\/ModuleLayer\/BasicLayerTest.java                       8337048 generic-all\n+\n+java\/lang\/Thread\/virtual\/stress\/Skynet.java#default             8342977 generic-all\n+\n@@ -555,0 +560,1 @@\n+com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreadsWithEliminatedLock.java 8360599 generic-all\n@@ -580,0 +586,2 @@\n+java\/net\/CookieHandler\/B6644726.java                            8365811 generic-all\n+\n@@ -737,0 +745,4 @@\n+com\/sun\/jdi\/cds\/CDSBreakpointTest.java                          8304168 generic-all\n+com\/sun\/jdi\/cds\/CDSDeleteAllBkptsTest.java                      8304168 generic-all\n+com\/sun\/jdi\/cds\/CDSFieldWatchpoints.java                        8304168 generic-all\n+\n@@ -838,0 +850,1 @@\n+\n@@ -843,0 +856,6 @@\n+\n+############################################################################\n+\n+# valhalla\n+jdk\/classfile\/AccessFlagsTest.java 8366270 generic-all\n+jdk\/jfr\/event\/runtime\/TestSyncOnValueBasedClassEvent.java 8328777 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -101,2 +101,3 @@\n-                Optional<Module> m = layer.findModule(moduleName);\n-                if (!m.isPresent())\n+                \/\/ removing dependency on java.util.Optional, valhalla only, to avoid VM warnings\n+                Module m = layer.findModule(moduleName).get();\n+                if (m == null)\n@@ -104,1 +105,1 @@\n-                m.get().addExports(packageName, getClass().getModule());\n+                m.addExports(packageName, getClass().getModule());\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}