{"files":[{"patch":"@@ -32,1 +32,1 @@\n-import jdk.internal.constant.ClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -65,1 +65,1 @@\n-                ClassDescImpl {\n+                ReferenceClassDescImpl {\n@@ -169,1 +169,1 @@\n-               : ClassDescImpl.of(descriptor);\n+               : ReferenceClassDescImpl.of(descriptor);\n@@ -193,1 +193,1 @@\n-        return ClassDescImpl.ofValidated(newDesc);\n+        return ReferenceClassDescImpl.ofValidated(newDesc);\n@@ -223,1 +223,1 @@\n-        return ClassDescImpl.ofValidated(newDesc);\n+        return ReferenceClassDescImpl.ofValidated(newDesc);\n@@ -250,1 +250,1 @@\n-        return ClassDescImpl.ofValidated(sb.toString());\n+        return ReferenceClassDescImpl.ofValidated(sb.toString());\n@@ -319,1 +319,1 @@\n-                return ClassDescImpl.ofValidated(desc.substring(1));\n+                return ReferenceClassDescImpl.ofValidated(desc.substring(1));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.internal.constant.ClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -71,1 +71,1 @@\n-    public static final ClassDesc CD_Object = ClassDescImpl.ofValidated(\"Ljava\/lang\/Object;\");\n+    public static final ClassDesc CD_Object = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Object;\");\n@@ -74,1 +74,1 @@\n-    public static final ClassDesc CD_String = ClassDescImpl.ofValidated(\"Ljava\/lang\/String;\");\n+    public static final ClassDesc CD_String = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/String;\");\n@@ -77,1 +77,1 @@\n-    public static final ClassDesc CD_Class = ClassDescImpl.ofValidated(\"Ljava\/lang\/Class;\");\n+    public static final ClassDesc CD_Class = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Class;\");\n@@ -80,1 +80,1 @@\n-    public static final ClassDesc CD_Number = ClassDescImpl.ofValidated(\"Ljava\/lang\/Number;\");\n+    public static final ClassDesc CD_Number = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Number;\");\n@@ -83,1 +83,1 @@\n-    public static final ClassDesc CD_Integer = ClassDescImpl.ofValidated(\"Ljava\/lang\/Integer;\");\n+    public static final ClassDesc CD_Integer = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Integer;\");\n@@ -86,1 +86,1 @@\n-    public static final ClassDesc CD_Long = ClassDescImpl.ofValidated(\"Ljava\/lang\/Long;\");\n+    public static final ClassDesc CD_Long = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Long;\");\n@@ -89,1 +89,1 @@\n-    public static final ClassDesc CD_Float = ClassDescImpl.ofValidated(\"Ljava\/lang\/Float;\");\n+    public static final ClassDesc CD_Float = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Float;\");\n@@ -92,1 +92,1 @@\n-    public static final ClassDesc CD_Double = ClassDescImpl.ofValidated(\"Ljava\/lang\/Double;\");\n+    public static final ClassDesc CD_Double = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Double;\");\n@@ -95,1 +95,1 @@\n-    public static final ClassDesc CD_Short = ClassDescImpl.ofValidated(\"Ljava\/lang\/Short;\");\n+    public static final ClassDesc CD_Short = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Short;\");\n@@ -98,1 +98,1 @@\n-    public static final ClassDesc CD_Byte = ClassDescImpl.ofValidated(\"Ljava\/lang\/Byte;\");\n+    public static final ClassDesc CD_Byte = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Byte;\");\n@@ -101,1 +101,1 @@\n-    public static final ClassDesc CD_Character = ClassDescImpl.ofValidated(\"Ljava\/lang\/Character;\");\n+    public static final ClassDesc CD_Character = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Character;\");\n@@ -104,1 +104,1 @@\n-    public static final ClassDesc CD_Boolean = ClassDescImpl.ofValidated(\"Ljava\/lang\/Boolean;\");\n+    public static final ClassDesc CD_Boolean = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Boolean;\");\n@@ -107,1 +107,1 @@\n-    public static final ClassDesc CD_Void = ClassDescImpl.ofValidated(\"Ljava\/lang\/Void;\");\n+    public static final ClassDesc CD_Void = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Void;\");\n@@ -110,1 +110,1 @@\n-    public static final ClassDesc CD_Throwable = ClassDescImpl.ofValidated(\"Ljava\/lang\/Throwable;\");\n+    public static final ClassDesc CD_Throwable = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Throwable;\");\n@@ -113,1 +113,1 @@\n-    public static final ClassDesc CD_Exception = ClassDescImpl.ofValidated(\"Ljava\/lang\/Exception;\");\n+    public static final ClassDesc CD_Exception = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Exception;\");\n@@ -116,1 +116,1 @@\n-    public static final ClassDesc CD_Enum = ClassDescImpl.ofValidated(\"Ljava\/lang\/Enum;\");\n+    public static final ClassDesc CD_Enum = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Enum;\");\n@@ -119,1 +119,1 @@\n-    public static final ClassDesc CD_VarHandle = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle;\");\n+    public static final ClassDesc CD_VarHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle;\");\n@@ -122,1 +122,1 @@\n-    public static final ClassDesc CD_MethodHandles = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles;\");\n+    public static final ClassDesc CD_MethodHandles = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles;\");\n@@ -125,1 +125,1 @@\n-    public static final ClassDesc CD_MethodHandles_Lookup = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles$Lookup;\");\n+    public static final ClassDesc CD_MethodHandles_Lookup = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles$Lookup;\");\n@@ -128,1 +128,1 @@\n-    public static final ClassDesc CD_MethodHandle = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandle;\");\n+    public static final ClassDesc CD_MethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandle;\");\n@@ -131,1 +131,1 @@\n-    public static final ClassDesc CD_MethodType = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodType;\");\n+    public static final ClassDesc CD_MethodType = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodType;\");\n@@ -134,1 +134,1 @@\n-    public static final ClassDesc CD_CallSite = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/CallSite;\");\n+    public static final ClassDesc CD_CallSite = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/CallSite;\");\n@@ -137,1 +137,1 @@\n-    public static final ClassDesc CD_Collection = ClassDescImpl.ofValidated(\"Ljava\/util\/Collection;\");\n+    public static final ClassDesc CD_Collection = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Collection;\");\n@@ -140,1 +140,1 @@\n-    public static final ClassDesc CD_List = ClassDescImpl.ofValidated(\"Ljava\/util\/List;\");\n+    public static final ClassDesc CD_List = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/List;\");\n@@ -143,1 +143,1 @@\n-    public static final ClassDesc CD_Set = ClassDescImpl.ofValidated(\"Ljava\/util\/Set;\");\n+    public static final ClassDesc CD_Set = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Set;\");\n@@ -146,1 +146,1 @@\n-    public static final ClassDesc CD_Map = ClassDescImpl.ofValidated(\"Ljava\/util\/Map;\");\n+    public static final ClassDesc CD_Map = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Map;\");\n@@ -149,1 +149,1 @@\n-    public static final ClassDesc CD_ConstantDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ConstantDesc;\");\n+    public static final ClassDesc CD_ConstantDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ConstantDesc;\");\n@@ -152,1 +152,1 @@\n-    public static final ClassDesc CD_ClassDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ClassDesc;\");\n+    public static final ClassDesc CD_ClassDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ClassDesc;\");\n@@ -155,1 +155,1 @@\n-    public static final ClassDesc CD_EnumDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/Enum$EnumDesc;\");\n+    public static final ClassDesc CD_EnumDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Enum$EnumDesc;\");\n@@ -158,1 +158,1 @@\n-    public static final ClassDesc CD_MethodTypeDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodTypeDesc;\");\n+    public static final ClassDesc CD_MethodTypeDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodTypeDesc;\");\n@@ -161,1 +161,1 @@\n-    public static final ClassDesc CD_MethodHandleDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodHandleDesc;\");\n+    public static final ClassDesc CD_MethodHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodHandleDesc;\");\n@@ -164,1 +164,1 @@\n-    public static final ClassDesc CD_DirectMethodHandleDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc;\");\n+    public static final ClassDesc CD_DirectMethodHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc;\");\n@@ -167,1 +167,1 @@\n-    public static final ClassDesc CD_VarHandleDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle$VarHandleDesc;\");\n+    public static final ClassDesc CD_VarHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle$VarHandleDesc;\");\n@@ -170,1 +170,1 @@\n-    public static final ClassDesc CD_MethodHandleDesc_Kind = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc$Kind;\");\n+    public static final ClassDesc CD_MethodHandleDesc_Kind = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc$Kind;\");\n@@ -173,1 +173,1 @@\n-    public static final ClassDesc CD_DynamicConstantDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicConstantDesc;\");\n+    public static final ClassDesc CD_DynamicConstantDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicConstantDesc;\");\n@@ -176,1 +176,1 @@\n-    public static final ClassDesc CD_DynamicCallSiteDesc = ClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicCallSiteDesc;\");\n+    public static final ClassDesc CD_DynamicCallSiteDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicCallSiteDesc;\");\n@@ -179,1 +179,1 @@\n-    public static final ClassDesc CD_ConstantBootstraps = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/ConstantBootstraps;\");\n+    public static final ClassDesc CD_ConstantBootstraps = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/ConstantBootstraps;\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import jdk.internal.constant.ClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -69,2 +69,2 @@\n-    private static final ClassDesc CD_LambdaForm = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n-    private static final ClassDesc CD_BoundMethodHandle = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/BoundMethodHandle;\");\n+    private static final ClassDesc CD_LambdaForm = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n+    private static final ClassDesc CD_BoundMethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/BoundMethodHandle;\");\n@@ -980,1 +980,1 @@\n-             : ClassDescImpl.ofValidated(cls.descriptorString());\n+             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-import jdk.internal.constant.ClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -436,3 +436,3 @@\n-        private static final ClassDesc CD_SerializedLambda = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n-        private static final ClassDesc CD_ObjectOutputStream = ClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n-        private static final ClassDesc CD_ObjectInputStream = ClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n+        private static final ClassDesc CD_SerializedLambda = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n+        private static final ClassDesc CD_ObjectOutputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n+        private static final ClassDesc CD_ObjectInputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n@@ -447,1 +447,1 @@\n-        static final ClassDesc CD_NotSerializableException = ClassDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n+        static final ClassDesc CD_NotSerializableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n@@ -450,1 +450,1 @@\n-                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"));\n+                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"));\n@@ -653,1 +653,1 @@\n-        return cls.isHidden() ? null : ClassDescImpl.ofValidated(cls.descriptorString());\n+        return cls.isHidden() ? null : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n@@ -658,1 +658,1 @@\n-                                 : ClassDescImpl.ofValidated(cls.descriptorString());\n+                                 : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import jdk.internal.constant.ClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -68,9 +68,9 @@\n-    private static final ClassDesc CD_CasesHolder = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$CasesHolder;\");\n-    private static final ClassDesc CD_DirectMethodHandle = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/DirectMethodHandle;\");\n-    private static final ClassDesc CD_MethodHandleImpl = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl;\");\n-    private static final ClassDesc CD_LambdaForm = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n-    private static final ClassDesc CD_LambdaForm_Name = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Name;\");\n-    private static final ClassDesc CD_LoopClauses = ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$LoopClauses;\");\n-    private static final ClassDesc CD_Object_array  = ClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n-    private static final ClassDesc CD_MethodHandle_array = ClassDescImpl.ofValidated(\"[Ljava\/lang\/invoke\/MethodHandle;\");\n-    private static final ClassDesc CD_MethodHandle_array2 = ClassDescImpl.ofValidated(\"[[Ljava\/lang\/invoke\/MethodHandle;\");\n+    private static final ClassDesc CD_CasesHolder = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$CasesHolder;\");\n+    private static final ClassDesc CD_DirectMethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/DirectMethodHandle;\");\n+    private static final ClassDesc CD_MethodHandleImpl = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl;\");\n+    private static final ClassDesc CD_LambdaForm = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n+    private static final ClassDesc CD_LambdaForm_Name = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Name;\");\n+    private static final ClassDesc CD_LoopClauses = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$LoopClauses;\");\n+    private static final ClassDesc CD_Object_array  = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n+    private static final ClassDesc CD_MethodHandle_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/invoke\/MethodHandle;\");\n+    private static final ClassDesc CD_MethodHandle_array2 = ReferenceClassDescImpl.ofValidated(\"[[Ljava\/lang\/invoke\/MethodHandle;\");\n@@ -545,5 +545,5 @@\n-    static final Annotation DONTINLINE      = Annotation.of(ClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/DontInline;\"));\n-    static final Annotation FORCEINLINE     = Annotation.of(ClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\"));\n-    static final Annotation HIDDEN          = Annotation.of(ClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/Hidden;\"));\n-    static final Annotation INJECTEDPROFILE = Annotation.of(ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/InjectedProfile;\"));\n-    static final Annotation LF_COMPILED     = Annotation.of(ClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\"));\n+    static final Annotation DONTINLINE      = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/DontInline;\"));\n+    static final Annotation FORCEINLINE     = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\"));\n+    static final Annotation HIDDEN          = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/Hidden;\"));\n+    static final Annotation INJECTEDPROFILE = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/InjectedProfile;\"));\n+    static final Annotation LF_COMPILED     = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\"));\n@@ -1691,1 +1691,1 @@\n-             : ClassDescImpl.ofValidated(cls.descriptorString());\n+             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.internal.constant.ClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -1043,1 +1043,1 @@\n-        private static final ClassDesc CD_Object_array = ClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n+        private static final ClassDesc CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n@@ -1272,1 +1272,1 @@\n-            return ClassFile.of().build(ClassDescImpl.ofValidated(\"LInjectedInvoker;\"), clb -> clb\n+            return ClassFile.of().build(ReferenceClassDescImpl.ofValidated(\"LInjectedInvoker;\"), clb -> clb\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.internal.constant.ClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -205,1 +205,1 @@\n-             : ClassDescImpl.ofValidated(cls.descriptorString());\n+             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/TypeConvertingMethodAdapter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import jdk.internal.constant.ClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -67,12 +67,12 @@\n-            CD_ClassLoader = ClassDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n-            CD_Class_array = ClassDescImpl.ofValidated(\"[Ljava\/lang\/Class;\"),\n-            CD_ClassNotFoundException = ClassDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n-            CD_NoClassDefFoundError = ClassDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n-            CD_IllegalAccessException = ClassDescImpl.ofValidated(\"Ljava\/lang\/IllegalAccessException;\"),\n-            CD_InvocationHandler = ClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/InvocationHandler;\"),\n-            CD_Method = ClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Method;\"),\n-            CD_NoSuchMethodError = ClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodError;\"),\n-            CD_NoSuchMethodException = ClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodException;\"),\n-            CD_Object_array = ClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"),\n-            CD_Proxy = ClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Proxy;\"),\n-            CD_UndeclaredThrowableException = ClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/UndeclaredThrowableException;\");\n+            CD_ClassLoader = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n+            CD_Class_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Class;\"),\n+            CD_ClassNotFoundException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n+            CD_NoClassDefFoundError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n+            CD_IllegalAccessException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/IllegalAccessException;\"),\n+            CD_InvocationHandler = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/InvocationHandler;\"),\n+            CD_Method = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Method;\"),\n+            CD_NoSuchMethodError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodError;\"),\n+            CD_NoSuchMethodException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodException;\"),\n+            CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"),\n+            CD_Proxy = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Proxy;\"),\n+            CD_UndeclaredThrowableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/UndeclaredThrowableException;\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import jdk.internal.constant.ClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -95,1 +95,1 @@\n-    private static final ClassDesc CD_Objects = ClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import jdk.internal.constant.ClassDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -1251,8 +1251,8 @@\n-            INT_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[I\")),\n-            BOOLEAN_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[Z\")),\n-            BYTE_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[B\")),\n-            CHAR_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[C\")),\n-            SHORT_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[S\")),\n-            LONG_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[J\")),\n-            DOUBLE_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[D\")),\n-            FLOAT_ARRAY_TYPE = referenceType(ClassDescImpl.ofValidated(\"[F\")),\n+            INT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[I\")),\n+            BOOLEAN_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[Z\")),\n+            BYTE_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[B\")),\n+            CHAR_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[C\")),\n+            SHORT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[S\")),\n+            LONG_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[J\")),\n+            DOUBLE_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[D\")),\n+            FLOAT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[F\")),\n@@ -1323,2 +1323,2 @@\n-        private static final ClassDesc CD_Cloneable = ClassDescImpl.ofValidated(\"Ljava\/lang\/Cloneable;\");\n-        private static final ClassDesc CD_Serializable = ClassDescImpl.ofValidated(\"Ljava\/io\/Serializable;\");\n+        private static final ClassDesc CD_Cloneable = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Cloneable;\");\n+        private static final ClassDesc CD_Serializable = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/Serializable;\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,135 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.constant;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.invoke.MethodHandles;\n-\n-import static jdk.internal.constant.ConstantUtils.*;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a class,\n- * interface, or array type.  A {@linkplain ClassDescImpl} corresponds to a\n- * {@code Constant_Class_info} entry in the constant pool of a classfile.\n- *\/\n-public final class ClassDescImpl implements ClassDesc {\n-    private final String descriptor;\n-\n-    private ClassDescImpl(String descriptor) {\n-        this.descriptor = descriptor;\n-    }\n-\n-    \/**\n-     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n-     * interface type or an array type.\n-     *\n-     * @param descriptor a field descriptor string for a class or interface type\n-     * @throws IllegalArgumentException if the descriptor string is not a valid\n-     * field descriptor string, or does not describe a class or interface type\n-     * @jvms 4.3.2 Field Descriptors\n-     *\/\n-    public static ClassDescImpl of(String descriptor) {\n-        int dLen = descriptor.length();\n-        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen, false);\n-        if (len <= 1 || len != dLen)\n-            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n-        return new ClassDescImpl(descriptor);\n-    }\n-\n-    \/**\n-     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n-     * for a class or interface type or an array type.\n-     *\n-     * @param descriptor a field descriptor string for a class or interface type\n-     * @jvms 4.3.2 Field Descriptors\n-     *\/\n-    public static ClassDescImpl ofValidated(String descriptor) {\n-        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length(), false)\n-                == descriptor.length() : descriptor;\n-        return new ClassDescImpl(descriptor);\n-    }\n-\n-    @Override\n-    public String descriptorString() {\n-        return descriptor;\n-    }\n-\n-    @Override\n-    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n-            throws ReflectiveOperationException {\n-        if (isArray()) {\n-            if (isPrimitiveArray()) {\n-                return lookup.findClass(descriptor);\n-            }\n-            \/\/ Class.forName is slow on class or interface arrays\n-            int depth = ConstantUtils.arrayDepth(descriptor);\n-            Class<?> clazz = lookup.findClass(internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n-            for (int i = 0; i < depth; i++)\n-                clazz = clazz.arrayType();\n-            return clazz;\n-        }\n-        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n-    }\n-\n-    \/**\n-     * Whether the descriptor is one of a primitive array, given this is\n-     * already a valid reference type descriptor.\n-     *\/\n-    private boolean isPrimitiveArray() {\n-        \/\/ All L-type descriptors must end with a semicolon; same for reference\n-        \/\/ arrays, leaving primitive arrays the only ones without a final semicolon\n-        return descriptor.charAt(descriptor.length() - 1) != ';';\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this {@linkplain ClassDescImpl} is\n-     * equal to another {@linkplain ClassDescImpl}.  Equality is\n-     * determined by the two class descriptors having equal class descriptor\n-     * strings.\n-     *\n-     * @param o the {@code ClassDesc} to compare to this\n-     *       {@code ClassDesc}\n-     * @return {@code true} if the specified {@code ClassDesc}\n-     *      is equal to this {@code ClassDesc}.\n-     *\/\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o instanceof ClassDescImpl constant) {\n-            return descriptor.equals(constant.descriptor);\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return descriptor.hashCode();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"ClassDesc[%s]\", displayName());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ClassDescImpl.java","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"},{"patch":"@@ -67,1 +67,1 @@\n-        return ClassDescImpl.ofValidated(\"L\" + binaryToInternal(binaryName) + \";\");\n+        return ReferenceClassDescImpl.ofValidated(\"L\" + binaryToInternal(binaryName) + \";\");\n@@ -88,1 +88,1 @@\n-        return ClassDescImpl.ofValidated(type.descriptorString());\n+        return ReferenceClassDescImpl.ofValidated(type.descriptorString());\n@@ -312,1 +312,1 @@\n-        return ClassDescImpl.ofValidated(descriptor.substring(start, start + len));\n+        return ReferenceClassDescImpl.ofValidated(descriptor.substring(start, start + len));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+\n+import static jdk.internal.constant.ConstantUtils.*;\n+\n+\/**\n+ * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a class,\n+ * interface, or array type.  A {@linkplain ReferenceClassDescImpl} corresponds to a\n+ * {@code Constant_Class_info} entry in the constant pool of a classfile.\n+ *\/\n+public final class ReferenceClassDescImpl implements ClassDesc {\n+    private final String descriptor;\n+\n+    private ReferenceClassDescImpl(String descriptor) {\n+        this.descriptor = descriptor;\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n+     * interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @throws IllegalArgumentException if the descriptor string is not a valid\n+     * field descriptor string, or does not describe a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ReferenceClassDescImpl of(String descriptor) {\n+        int dLen = descriptor.length();\n+        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen, false);\n+        if (len <= 1 || len != dLen)\n+            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n+        return new ReferenceClassDescImpl(descriptor);\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n+     * for a class or interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ReferenceClassDescImpl ofValidated(String descriptor) {\n+        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length(), false)\n+                == descriptor.length() : descriptor;\n+        return new ReferenceClassDescImpl(descriptor);\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        return descriptor;\n+    }\n+\n+    @Override\n+    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n+            throws ReflectiveOperationException {\n+        if (isArray()) {\n+            if (isPrimitiveArray()) {\n+                return lookup.findClass(descriptor);\n+            }\n+            \/\/ Class.forName is slow on class or interface arrays\n+            int depth = ConstantUtils.arrayDepth(descriptor);\n+            Class<?> clazz = lookup.findClass(internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n+            for (int i = 0; i < depth; i++)\n+                clazz = clazz.arrayType();\n+            return clazz;\n+        }\n+        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n+    }\n+\n+    \/**\n+     * Whether the descriptor is one of a primitive array, given this is\n+     * already a valid reference type descriptor.\n+     *\/\n+    private boolean isPrimitiveArray() {\n+        \/\/ All L-type descriptors must end with a semicolon; same for reference\n+        \/\/ arrays, leaving primitive arrays the only ones without a final semicolon\n+        return descriptor.charAt(descriptor.length() - 1) != ';';\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this {@linkplain ReferenceClassDescImpl} is\n+     * equal to another {@linkplain ReferenceClassDescImpl}.  Equality is\n+     * determined by the two class descriptors having equal class descriptor\n+     * strings.\n+     *\n+     * @param o the {@code ClassDesc} to compare to this\n+     *       {@code ClassDesc}\n+     * @return {@code true} if the specified {@code ClassDesc}\n+     *      is equal to this {@code ClassDesc}.\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o instanceof ReferenceClassDescImpl constant) {\n+            return descriptor.equals(constant.descriptor);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return descriptor.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ClassDesc[%s]\", displayName());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"}]}