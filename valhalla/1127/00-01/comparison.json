{"files":[{"patch":"@@ -439,2 +439,3 @@\n-\/\/ and null-freeness. This avoids runtime checks and leads to a much simpler graph shape. We emit traps if the profiling\n-\/\/ information turns out to be wrong at runtime.\n+\/\/ and null-freeness. We can either prepare the speculative type for later uses or emit explicit speculative checks with\n+\/\/ traps now. In the latter case, the speculative type guarantees can avoid additional runtime checks later (e.g.\n+\/\/ non-null-free implies non-flat which allows us to remove flatness checks). This makes the graph simpler.\n@@ -444,2 +445,2 @@\n-    \/\/ For array accesses, it can be useful to speculate on flatness such that we can fix the data layout. We only want\n-    \/\/ to do that when we know nothing about flatness since it requires a trap when profiling turns out to be wrong.\n+    \/\/ For arrays that might be flat, speculate that the array has the exact type reported in the profile data such that\n+    \/\/ we can rely on a fixed memory layout (i.e. either a flat layout or not).\n@@ -453,1 +454,1 @@\n-  \/\/ Even though the type does not tell us whether we have an inline type or not, we can still check the profile data\n+  \/\/ Even though the type does not tell us whether we have an inline type array or not, we can still check the profile data\n@@ -555,1 +556,1 @@\n-\/\/ CheckCastPP to use the non-flat type..\n+\/\/ CheckCastPP to use the non-flat type.\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-            \/\/ This crashes when iFld = -1 becauase we then access an out-of-bounds element.\n+            \/\/ This crashes when iFld = -1 because we then access an out-of-bounds element.\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestSpeculateArrayAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}