{"files":[{"patch":"@@ -501,0 +501,1 @@\n+  bool needs_range_check(const TypeInt* size_type, const Node* index) const;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -105,2 +105,8 @@\n-      Node* ld = access_load_at(ary, adr, adr_type, elemptr, bt,\n-                                IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD);\n+      DecoratorSet decorator_set = IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD;\n+      if (needs_range_check(ary_t->size(), idx)) {\n+        \/\/ We've emitted a RangeCheck but now insert an additional check between the range check and the actual load.\n+        \/\/ We cannot pin the load to two separate nodes. Instead, we pin it conservatively here such that it cannot\n+        \/\/ possibly float above the range check at any point.\n+        decorator_set |= C2_UNKNOWN_CONTROL_LOAD;\n+      }\n+      Node* ld = access_load_at(ary, adr, adr_type, elemptr, bt, decorator_set);\n@@ -354,11 +360,0 @@\n-  \/\/ Check for big class initializers with all constant offsets\n-  \/\/ feeding into a known-size array.\n-  const TypeInt* idxtype = _gvn.type(idx)->is_int();\n-  \/\/ See if the highest idx value is less than the lowest array bound,\n-  \/\/ and if the idx value cannot be negative:\n-  bool need_range_check = true;\n-  if (idxtype->_hi < sizetype->_lo && idxtype->_lo >= 0) {\n-    need_range_check = false;\n-    if (C->log() != nullptr)   C->log()->elem(\"observe that='!need_range_check'\");\n-  }\n-\n@@ -378,1 +373,1 @@\n-  if (need_range_check) {\n+  if (needs_range_check(sizetype, idx)) {\n@@ -380,0 +375,2 @@\n+  } else if (C->log() != nullptr) {\n+    C->log()->elem(\"observe that='!need_range_check'\");\n@@ -393,0 +390,7 @@\n+\/\/ Check if we need a range check for an array access. This is the case if the index is either negative or if it could\n+\/\/ be greater or equal the smallest possible array size (i.e. out-of-bounds).\n+bool Parse::needs_range_check(const TypeInt* size_type, const Node* index) const {\n+  const TypeInt* index_type = _gvn.type(index)->is_int();\n+  return index_type->_hi >= size_type->_lo || index_type->_lo < 0;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"}]}