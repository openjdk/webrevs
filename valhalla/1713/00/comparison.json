{"files":[{"patch":"@@ -216,0 +216,1 @@\n+  static inline bool is_instance_without_asserts(oop obj);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -129,0 +129,7 @@\n+\/\/ We need to be able to check if this is a string even when we are in an\n+\/\/ erroneous state where the klass is corrupted\/can't be read safely.\n+\/\/ This happens when printing an oop during GC error reporting.\n+bool java_lang_String::is_instance_without_asserts(oop obj) {\n+  return obj != nullptr && obj->klass_without_asserts() == vmClasses::String_klass();\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -162,1 +162,2 @@\n-  if (HasDecorator<decorators, IS_DEST_UNINITIALIZED>::value || (!md->contains_oops())) {\n+  if (!md->contains_oops()) {\n+    \/\/ If we do not have oops in the flat array, we can just do a raw copy.\n@@ -173,0 +174,1 @@\n+    bool is_uninitialized = HasDecorator<decorators, IS_DEST_UNINITIALIZED>::value;\n@@ -175,1 +177,4 @@\n-      bs->write_ref_array_pre((OopType*) doop_address, map->count(), false);\n+      \/\/ The pre-barrier only impacts G1, which will emit a barrier if the destination is\n+      \/\/ initialized. Note that we should not emit a barrier if the destination is uninitialized,\n+      \/\/ as doing so will fill the SATB queue with garbage data.\n+      bs->write_ref_array_pre((OopType*) doop_address, map->count(), is_uninitialized);\n@@ -185,0 +190,1 @@\n+      \/\/ The post-barrier needs to be called for initialized and uninitialized destinations.\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  if (java_lang_String::is_instance(obj)) {\n+  if (java_lang_String::is_instance_without_asserts(obj)) {\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=serial\n+ * @summary Ensures that value arrays can get arraycopied properly with Serial.\n+ *          This test will likely crash if that is not the case.\n+ * @bug 8370479\n+ * @enablePreview\n+ * @requires vm.flagless\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.value\n+            java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -Xint -XX:+UseSerialGC -XX:+UseCompressedOops -Xlog:gc*=info\n+                                  -XX:+UseCompressedClassPointers\n+                                  -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+                                  runtime.valhalla.inlinetypes.FlatArrayCopyingTest\n+ *\/\n+\n+\/*\n+ * @test id=parallel\n+ * @summary Ensures that value arrays can get arraycopied properly with Parallel.\n+ *          This test will likely crash if that is not the case.\n+ * @bug 8370479\n+ * @enablePreview\n+ * @requires vm.flagless\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.value\n+            java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -Xint -XX:+UseParallelGC -XX:+UseCompressedOops -Xlog:gc*=info\n+                                  -XX:ParallelGCThreads=1 -XX:-UseDynamicNumberOfGCThreads\n+                                  -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+                                  runtime.valhalla.inlinetypes.FlatArrayCopyingTest\n+ *\/\n+\n+\/*\n+ * @test id=g1\n+ * @summary Ensures that value arrays can get arraycopied properly with G1.\n+ *          This test will likely crash if that is not the case.\n+ * @bug 8370479\n+ * @enablePreview\n+ * @requires vm.flagless\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.value\n+            java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run junit\/othervm\/timeout=480 -Xint -XX:+UseG1GC -XX:+UseCompressedOops -Xlog:gc*=info\n+                                  -XX:ParallelGCThreads=1 -XX:ConcGCThreads=1 -XX:-UseDynamicNumberOfGCThreads\n+                                  -XX:-G1UseConcRefinement -XX:+UseCompressedClassPointers\n+                                  -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+                                  runtime.valhalla.inlinetypes.FlatArrayCopyingTest\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import java.util.Arrays;\n+import jdk.internal.value.ValueClass;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public final class FlatArrayCopyingTest {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static value record Element(Identity underlying) {}\n+    public static class Identity {}\n+\n+    @Test\n+    public void testCopyingOften() {\n+        Object[] array = ValueClass.newNullableAtomicArray(Element.class, 16);\n+        for (int i = 0; i < 1_000_000; i++) {\n+            if (i == array.length) {\n+                array = Arrays.copyOf(array, array.length << 1);\n+            }\n+            \/\/ Do a very \"random\" full GC.\n+            if (i == 5123123) {\n+                WB.fullGC();\n+            }\n+            array[i] = new Element(new Identity());\n+        }\n+        \/\/ Smallest power of 2 that fits 1 million elements.\n+        assertEquals(1_048_576, array.length);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlatArrayCopyingTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}