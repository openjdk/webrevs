{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zAddress.hpp\"\n@@ -482,0 +483,10 @@\n+static inline void copy_primitive_payload(const void* src, const void* dst, const size_t payload_size_bytes, size_t& copied_bytes) {\n+  if (payload_size_bytes == 0) {\n+    return;\n+  }\n+  void* src_payload = (void*)(address(src) + copied_bytes);\n+  void* dst_payload = (void*)(address(dst) + copied_bytes);\n+  Copy::copy_value_content(src_payload, dst_payload, payload_size_bytes);\n+  copied_bytes += payload_size_bytes;\n+}\n+\n@@ -485,2 +496,4 @@\n-    \/\/ src\/dst aren't oops, need offset to adjust oop map offset\n-    const address src_oop_addr_offset = ((address) src) - md->first_field_offset();\n+    \/\/ Iterate over each oop map, performing:\n+    \/\/   1) possibly raw copy for any primitive payload before each map\n+    \/\/   2) load and store barrier for each oop\n+    \/\/   3) possibly raw copy for any primitive payload trailer\n@@ -488,0 +501,6 @@\n+    assert(lk == NON_ATOMIC_FLAT || (!md->must_be_atomic()) ||\n+           (md->layout_size_in_bytes(lk) == sizeof(zpointer) && md->nonstatic_oop_count() == 1), \/\/ If atomic with oops, only a single oop suppported\n+           \"Cannot support layout other than NON_ATOMIC_FLAT or single oop\");\n+\n+    \/\/ src\/dst may not be oops, need offset to adjust oop map offset\n+    const address src_oop_addr_offset = ((address) src) - md->first_field_offset();\n@@ -490,0 +509,2 @@\n+    size_t size_in_bytes = md->layout_size_in_bytes(lk);\n+    size_t copied_bytes = 0;\n@@ -491,4 +512,12 @@\n-      const address soop_address = src_oop_addr_offset + map->offset();\n-      zpointer *p = (zpointer*) soop_address;\n-      for (const zpointer* const end = p + map->count(); p < end; p++) {\n-        ZBarrier::load_barrier_on_oop_field(p);\n+      zpointer *src_p = (zpointer*)(src_oop_addr_offset + map->offset());\n+      const uintptr_t oop_offset = uintptr_t(src_p) - uintptr_t(src);\n+      zpointer *dst_p = (zpointer*)(uintptr_t(dst) + oop_offset);\n+\n+      \/\/ Copy any leading primitive payload before every cluster of oops\n+      assert(copied_bytes < oop_offset || copied_bytes == oop_offset, \"Negative sized leading payload segment\");\n+      copy_primitive_payload(src, dst, oop_offset - copied_bytes, copied_bytes);\n+\n+      \/\/ Copy a cluster of oops\n+      for (const zpointer* const src_end = src_p + map->count(); src_p < src_end; src_p++, dst_p++) {\n+        oop_copy_one(dst_p, src_p);\n+        copied_bytes += sizeof(zpointer);\n@@ -498,0 +527,6 @@\n+\n+    \/\/ Copy trailing primitive payload after potential oops\n+    assert(copied_bytes < size_in_bytes || copied_bytes == size_in_bytes, \"Negative sized trailing payload segment\");\n+    copy_primitive_payload(src, dst, size_in_bytes - copied_bytes, copied_bytes);\n+  } else {\n+    Raw::value_copy_in_heap(src, dst, md, lk);\n@@ -499,1 +534,0 @@\n-  Raw::value_copy_in_heap(src, dst, md, lk);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":41,"deletions":7,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -121,4 +121,1 @@\n-compiler\/valhalla\/inlinetypes\/TestArrayCopyWithOops.java      8341844   generic-all\n-compiler\/valhalla\/inlinetypes\/TestCallingConvention.java      8341844   generic-all\n-compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java    8341844   generic-all\n-runtime\/valhalla\/inlinetypes\/InlineTypesTest.java             8341844   generic-all\n+compiler\/valhalla\/inlinetypes\/TestArrayCopyWithOops.java      8346466   generic-all\n@@ -126,1 +123,0 @@\n-compiler\/valhalla\/inlinetypes\/TestStressReturnBuffering.java  8341846   generic-all\n@@ -128,0 +124,2 @@\n+# Once jdk-24+22 are merged (remove singlegen zgc) together with 8341844, many of these issues are resolved...\n+compiler\/valhalla\/inlinetypes\/TestStressReturnBuffering.java  8341846   generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-generational-zgc.txt","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -109,0 +109,17 @@\n+\/**\n+ * @test id=ZXint\n+ * @requires vm.gc.Z\n+ * @summary Test embedding oops into Inline types (sanity check with interpreter only the most complex GC)\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common\n+ * @enablePreview\n+ * @compile Person.java InlineOops.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *                   jdk.test.whitebox.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xint -XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx128m\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+ZVerifyViews -XX:InlineFieldMaxFlatSize=160\n+ *                   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   runtime.valhalla.inlinetypes.InlineOops\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineOops.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}