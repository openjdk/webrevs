{"files":[{"patch":"@@ -482,0 +482,10 @@\n+static inline void copy_primitive_payload(const void* src, const void* dst, const size_t payload_size_bytes, size_t& copied_bytes) {\n+  if (payload_size_bytes == 0) {\n+    return;\n+  }\n+  void* src_payload = (void*)(address(src) + copied_bytes);\n+  void* dst_payload = (void*)(address(dst) + copied_bytes);\n+  Copy::copy_value_content(src_payload, dst_payload, payload_size_bytes);\n+  copied_bytes += payload_size_bytes;\n+}\n+\n@@ -485,2 +495,5 @@\n-    \/\/ src\/dst aren't oops, need offset to adjust oop map offset\n-    const address src_oop_addr_offset = ((address) src) - md->first_field_offset();\n+    \/\/ Iterate over each oop map, performing:\n+    \/\/   1) possibly raw copy for any primitive payload before each map\n+    \/\/   2) load and store barrier for each oop\n+    \/\/   3) possibly raw copy for any primitive payload trailer\n+    assert(lk == NON_ATOMIC_FLAT || lk == PAYLOAD, \"Cannot support layout other than NON_ATOMIC_FLAT\"); \/\/ Note: PAYLOAD is incorrect, resolve when transistioned to new flattening\n@@ -488,0 +501,2 @@\n+    \/\/ src\/dst may not be oops, need offset to adjust oop map offset\n+    const address src_oop_addr_offset = ((address) src) - md->first_field_offset();\n@@ -490,0 +505,2 @@\n+    size_t size_in_bytes = md->layout_size_in_bytes(lk);\n+    size_t copied_bytes = 0;\n@@ -491,4 +508,12 @@\n-      const address soop_address = src_oop_addr_offset + map->offset();\n-      zpointer *p = (zpointer*) soop_address;\n-      for (const zpointer* const end = p + map->count(); p < end; p++) {\n-        ZBarrier::load_barrier_on_oop_field(p);\n+      zpointer *src_p = (zpointer*)(src_oop_addr_offset + map->offset());\n+      const uintptr_t oop_offset = uintptr_t(src_p) - uintptr_t(src);\n+      zpointer *dst_p = (zpointer*)(uintptr_t(dst) + oop_offset);\n+\n+      \/\/ Copy any leading primitive payload before every cluster of oops\n+      assert(copied_bytes < oop_offset || copied_bytes == oop_offset, \"Negative sized leading payload segment\");\n+      copy_primitive_payload(src, dst, oop_offset - copied_bytes, copied_bytes);\n+\n+      \/\/ Copy a cluster of oops\n+      for (const zpointer* const src_end = src_p + map->count(); src_p < src_end; src_p++, dst_p++) {\n+        oop_copy_one(dst_p, src_p);\n+        copied_bytes += sizeof(zpointer);\n@@ -498,0 +523,6 @@\n+\n+    \/\/ Copy trailing primitive payload after potential oops\n+    assert(copied_bytes < size_in_bytes || copied_bytes == size_in_bytes, \"Negative sized trailing payload segment\");\n+    copy_primitive_payload(src, dst, size_in_bytes - copied_bytes, copied_bytes);\n+  } else {\n+    Raw::value_copy_in_heap(src, dst, md, lk);\n@@ -499,1 +530,0 @@\n-  Raw::value_copy_in_heap(src, dst, md, lk);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":37,"deletions":7,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -121,4 +121,1 @@\n-compiler\/valhalla\/inlinetypes\/TestArrayCopyWithOops.java      8341844   generic-all\n-compiler\/valhalla\/inlinetypes\/TestCallingConvention.java      8341844   generic-all\n-compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java    8341844   generic-all\n-runtime\/valhalla\/inlinetypes\/InlineTypesTest.java             8341844   generic-all\n+compiler\/valhalla\/inlinetypes\/TestArrayCopyWithOops.java      8346466   generic-all\n@@ -126,1 +123,0 @@\n-compiler\/valhalla\/inlinetypes\/TestStressReturnBuffering.java  8341846   generic-all\n@@ -128,0 +124,2 @@\n+# Once jdk-24+22 are merged (remove singlegen zgc) together with 8341844, many of these issues are resolved...\n+compiler\/valhalla\/inlinetypes\/TestStressReturnBuffering.java  8341846   generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-generational-zgc.txt","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"}]}