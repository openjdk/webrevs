{"files":[{"patch":"@@ -225,42 +225,2 @@\n-void InterpreterMacroAssembler::read_flat_field(Register entry,\n-                                                Register field_index, Register field_offset,\n-                                                Register temp, Register obj) {\n-  Label failed_alloc, slow_path, done;\n-  const Register src = field_offset;\n-  const Register alloc_temp = r10;\n-  const Register dst_temp   = field_index;\n-  const Register layout_info = temp;\n-  assert_different_registers(obj, entry, field_index, field_offset, temp, alloc_temp, rscratch1);\n-\n-  load_unsigned_byte(temp, Address(entry, in_bytes(ResolvedFieldEntry::flags_offset())));\n-  \/\/ If the field is nullable, jump to slow path\n-  tbz(temp, ResolvedFieldEntry::is_null_free_inline_type_shift, slow_path);\n-\n-  \/\/ Grab the inline field klass\n-  ldr(rscratch1, Address(entry, in_bytes(ResolvedFieldEntry::field_holder_offset())));\n-  inline_layout_info(rscratch1, field_index, layout_info);\n-\n-  const Register field_klass = dst_temp;\n-  ldr(field_klass, Address(layout_info, in_bytes(InlineLayoutInfo::klass_offset())));\n-\n-  \/\/ allocate buffer\n-  push(obj); \/\/ save holder\n-  allocate_instance(field_klass, obj, alloc_temp, rscratch2, false, failed_alloc);\n-\n-  \/\/ Have an oop instance buffer, copy into it\n-  payload_address(obj, dst_temp, field_klass);  \/\/ danger, uses rscratch1\n-  pop(alloc_temp);             \/\/ restore holder\n-  lea(src, Address(alloc_temp, field_offset));\n-  \/\/ call_VM_leaf, clobbers a few regs, save restore new obj\n-  push(obj);\n-  flat_field_copy(IS_DEST_UNINITIALIZED, src, dst_temp, layout_info);\n-  pop(obj);\n-  b(done);\n-\n-  bind(failed_alloc);\n-  pop(obj);\n-  bind(slow_path);\n-  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flat_field),\n-          obj, entry);\n-\n-  bind(done);\n+void InterpreterMacroAssembler::read_flat_field(Register entry, Register obj) {\n+  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::read_flat_field), obj, entry);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":42,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -170,4 +170,1 @@\n-  \/\/   - assumes holder_klass and valueKlass field klass have both been resolved\n-  void read_flat_field(Register entry,\n-                       Register field_index, Register field_offset,\n-                       Register temp, Register obj);\n+  void read_flat_field(Register entry, Register obj);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2712,3 +2712,0 @@\n-  const Register klass     = r5;\n-  const Register inline_klass = r7;\n-  const Register field_index = r23;\n@@ -2724,4 +2721,0 @@\n-  \/\/ Valhalla extras\n-  __ load_unsigned_short(field_index, Address(cache, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-  __ ldr(klass, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n-\n@@ -2810,1 +2803,1 @@\n-      __ read_flat_field(cache, field_index, off, inline_klass \/* temp *\/, r0);\n+      __ read_flat_field(cache, r0);\n@@ -3413,1 +3406,0 @@\n-      Register index = r4, tmp = r7;\n@@ -3415,2 +3407,1 @@\n-      __ load_unsigned_short(index, Address(r2, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-      __ read_flat_field(r2, index, r1, tmp \/* temp *\/, r0);\n+      __ read_flat_field(r2, r0);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1155,40 +1155,1 @@\n-void InterpreterMacroAssembler::read_flat_field(Register entry, Register tmp1, Register tmp2, Register obj) {\n-  Label alloc_failed, slow_path, done;\n-  const Register alloc_temp = LP64_ONLY(rscratch1) NOT_LP64(rsi);\n-  const Register dst_temp   = LP64_ONLY(rscratch2) NOT_LP64(rdi);\n-  assert_different_registers(obj, entry, tmp1, tmp2, dst_temp, r8, r9);\n-\n-  \/\/ If the field is nullable, jump to slow path\n-  load_unsigned_byte(tmp1, Address(entry, in_bytes(ResolvedFieldEntry::flags_offset())));\n-  testl(tmp1, 1 << ResolvedFieldEntry::is_null_free_inline_type_shift);\n-  jcc(Assembler::equal, slow_path);\n-\n-  \/\/ Grap the inline field klass\n-  const Register field_klass = tmp1;\n-  load_unsigned_short(tmp2, Address(entry, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-\n-  movptr(tmp1, Address(entry, ResolvedFieldEntry::field_holder_offset()));\n-  get_inline_type_field_klass(tmp1, tmp2, field_klass);\n-\n-  \/\/ allocate buffer\n-  push(obj);  \/\/ push object being read from\n-  allocate_instance(field_klass, obj, alloc_temp, dst_temp, false, alloc_failed);\n-\n-  \/\/ Have an oop instance buffer, copy into it\n-  load_unsigned_short(r9, Address(entry, in_bytes(ResolvedFieldEntry::field_index_offset())));\n-  movptr(r8, Address(entry, in_bytes(ResolvedFieldEntry::field_holder_offset())));\n-  inline_layout_info(r8, r9, r8); \/\/ holder, index, info => InlineLayoutInfo into r8\n-\n-  payload_addr(obj, dst_temp, field_klass);\n-  pop(alloc_temp);             \/\/ restore object being read from\n-  load_sized_value(tmp2, Address(entry, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n-  lea(tmp2, Address(alloc_temp, tmp2));\n-  \/\/ call_VM_leaf, clobbers a few regs, save restore new obj\n-  push(obj);\n-  flat_field_copy(IS_DEST_UNINITIALIZED, tmp2, dst_temp, r8);\n-  pop(obj);\n-  jmp(done);\n-\n-  bind(alloc_failed);\n-  pop(obj);\n-  bind(slow_path);\n+void InterpreterMacroAssembler::read_flat_field(Register entry, Register obj) {\n@@ -1198,1 +1159,0 @@\n-  bind(done);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -227,4 +227,1 @@\n-  \/\/   - assumes holder_klass and valueKlass field klass have both been resolved\n-  void read_flat_field(Register entry,\n-                       Register tmp1, Register tmp2,\n-                       Register obj = rax);\n+  void read_flat_field(Register entry, Register obj);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2640,1 +2640,1 @@\n-  const Register bc    = c_rarg3; \/\/ uses same reg as obj, so don't mix them\n+  const Register bc    = c_rarg3;\n@@ -2698,1 +2698,1 @@\n-      Label is_flat, rewrite_inline;\n+      Label is_flat;\n@@ -2710,1 +2710,1 @@\n-      __ read_flat_field(rcx, rdx, rbx, rax);\n+      __ read_flat_field(rcx, rax);\n@@ -2713,1 +2713,0 @@\n-      __ bind(rewrite_inline);\n@@ -3309,1 +3308,1 @@\n-    __ read_flat_field(rcx, rdx, rbx, rax);\n+    __ read_flat_field(rcx, rax);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-JRT_ENTRY(void, InterpreterRuntime::read_flat_field(JavaThread* current, oopDesc* obj, ResolvedFieldEntry* entry))\n+JRT_BLOCK_ENTRY(void, InterpreterRuntime::read_flat_field(JavaThread* current, oopDesc* obj, ResolvedFieldEntry* entry))\n@@ -235,1 +235,0 @@\n-  Handle obj_h(THREAD, obj);\n@@ -241,1 +240,10 @@\n-  InlineKlass* field_vklass = layout_info->klass();\n+  InlineKlass* field_klass = layout_info->klass();\n+  const LayoutKind lk = layout_info->kind();\n+  const int offset = entry->field_offset();\n+\n+  \/\/ If the field is nullable and is marked null, return early.\n+  if (LayoutKindHelper::is_nullable_flat(lk) &&\n+      field_klass->is_payload_marked_as_null(cast_from_oop<address>(obj) + offset)) {\n+    current->set_vm_result_oop(nullptr);\n+    return;\n+  }\n@@ -245,1 +253,1 @@\n-  bool found = holder->find_field_from_offset(entry->field_offset(), false, &fd);\n+  bool found = holder->find_field_from_offset(offset, false, &fd);\n@@ -250,2 +258,4 @@\n-  oop res = field_vklass->read_payload_from_addr(obj_h(), entry->field_offset(), layout_info->kind(), CHECK);\n-  current->set_vm_result_oop(res);\n+  JRT_BLOCK\n+    oop res = field_klass->read_payload_from_addr(obj, (size_t)offset, lk, CHECK);\n+    current->set_vm_result_oop(res);\n+  JRT_BLOCK_END\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"}]}