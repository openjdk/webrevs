{"files":[{"patch":"@@ -57,0 +57,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -1866,1 +1867,0 @@\n-        assert(_gvn.type(arg)->is_zero_type() && !t->inline_klass()->is_null_free(), \"Unexpected argument type\");\n@@ -1959,0 +1959,9 @@\n+      Node* receiver = !call->method()->is_static() ? call->in(TypeFunc::Parms) : nullptr;\n+      if (ret->is_InlineType() &&\n+          receiver && receiver->bottom_type()->isa_instptr() &&\n+          receiver->bottom_type()->is_instptr()->instance_klass()->name()->get_symbol() == vmSymbols::jdk_internal_misc_Unsafe() &&\n+          call->method()->name()->get_symbol() == vmSymbols::makePrivateBuffer_name()) {\n+        \/\/ Re-buffer scalarized InlineTypeNodes returned from makePrivateBuffer\n+        \/\/ and transition the allocation into larval state.\n+        ret = ret->as_InlineType()->make_larval(this);\n+      }\n@@ -3419,1 +3428,1 @@\n-        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType(), \"should have been scalarized\");\n+        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType() || obj->bottom_type()->is_inlinetypeptr(), \"should have been scalarized\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -800,1 +800,1 @@\n-        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable && !alloc->_larval) {\n@@ -1012,1 +1012,1 @@\n-InlineTypeNode* InlineTypeNode::make_larval(GraphKit* kit, bool allocate) const {\n+Node* InlineTypeNode::make_larval(GraphKit* kit) const {\n@@ -1014,4 +1014,0 @@\n-  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n-  for (uint i = 1; i < req(); ++i) {\n-    res->set_req(i, in(i));\n-  }\n@@ -1019,8 +1015,7 @@\n-  if (allocate) {\n-    \/\/ Re-execute if buffering triggers deoptimization\n-    PreserveReexecuteState preexecs(kit);\n-    kit->jvms()->set_should_reexecute(true);\n-    Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n-    Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n-    alloc->_larval = true;\n+  \/\/ Re-execute if buffering triggers deoptimization\n+  PreserveReexecuteState preexecs(kit);\n+  kit->jvms()->set_should_reexecute(true);\n+  Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n+  Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n+  alloc->_larval = true;\n@@ -1028,8 +1023,2 @@\n-    store(kit, alloc_oop, alloc_oop, vk);\n-    res->set_oop(alloc_oop);\n-  }\n-  \/\/ TODO 8239003\n-  \/\/res->set_type(TypeInlineType::make(vk, true));\n-  res = kit->gvn().transform(res)->as_InlineType();\n-  assert(!allocate || res->is_allocated(&kit->gvn()), \"must be allocated\");\n-  return res;\n+  store(kit, alloc_oop, alloc_oop, vk);\n+  return alloc_oop;\n@@ -1038,2 +1027,1 @@\n-InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit) const {\n-  Node* obj = get_oop();\n+InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit, Node* obj, const TypeInstPtr* vk) {\n@@ -1051,9 +1039,1 @@\n-  ciInlineKlass* vk = inline_klass();\n-  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n-  for (uint i = 1; i < req(); ++i) {\n-    res->set_req(i, in(i));\n-  }\n-  \/\/ TODO 8239003\n-  \/\/res->set_type(TypeInlineType::make(vk, false));\n-  res = kit->gvn().transform(res)->as_InlineType();\n-  return res;\n+  return InlineTypeNode::make_from_oop(kit, obj, vk->inline_klass(), !vk->maybe_null());\n@@ -1284,1 +1264,1 @@\n-    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable && !alloc->_larval) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":14,"deletions":34,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -167,2 +167,2 @@\n-  InlineTypeNode* make_larval(GraphKit* kit, bool allocate) const;\n-  InlineTypeNode* finish_larval(GraphKit* kit) const;\n+  Node* make_larval(GraphKit* kit) const;\n+  static InlineTypeNode* finish_larval(GraphKit* kit, Node* obj, const TypeInstPtr* vk);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2332,0 +2332,11 @@\n+  if (_gvn.type(base)->is_inlinetypeptr() && is_store) {\n+    \/\/ FIXME: Larval bit check is needed to preserve the semantics of value\n+    \/\/ objects which can be mutated only if its _larval bit is set. Since\n+    \/\/ the oop is not always an AllocateNode, we have to find an utility way\n+    \/\/ to check the larval state for all kind of oops.\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(base);\n+    if (alloc != nullptr) {\n+      assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n+    }\n+  }\n+\n@@ -2352,8 +2363,0 @@\n-      \/\/ FIXME: Larval bit check is needed to preserve the semantics of value\n-      \/\/ objects which can be mutated only if its _larval bit is set. Since\n-      \/\/ the oop is not always an AllocateNode, we have to find an utility way\n-      \/\/ to check the larval state for all kind of oops.\n-      AllocateNode* alloc = AllocateNode::Ideal_allocation(base);\n-      if (alloc != nullptr) {\n-        assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n-      }\n@@ -2630,5 +2633,0 @@\n-  if (argument(1)->is_InlineType() && is_store) {\n-    InlineTypeNode* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(argument(1))->inline_klass());\n-    value = value->make_larval(this, false);\n-    replace_in_map(argument(1), value);\n-  }\n@@ -2651,1 +2649,1 @@\n-  set_result(value->as_InlineType()->make_larval(this, true));\n+  set_result(value->as_InlineType()->make_larval(this));\n@@ -2658,1 +2656,13 @@\n-  if (!buffer->is_InlineType()) {\n+  \/\/ Incoming value should be a buffer and not InlineTypeNode.\n+  if (buffer->is_InlineType()) {\n+     return false;\n+  }\n+  \/\/ Incoming value should be inline type.\n+  if (!buffer->bottom_type()->is_inlinetypeptr()) {\n+     return false;\n+  }\n+  \/\/ Allocation node must exist to generate IR for transitioning allocation out\n+  \/\/ of larval state. Disable the intrinsic and take unsafe slow path if allocation\n+  \/\/ is not reachable,  oop returned by Unsafe_finishPrivateBuffer native method\n+  \/\/ will automatically rematerialize InlineTypeNode.\n+  if (AllocateNode::Ideal_allocation(buffer) == nullptr) {\n@@ -2661,9 +2671,0 @@\n-  InlineTypeNode* vt = buffer->as_InlineType();\n-  if (!vt->is_allocated(&_gvn) || VectorSupport::is_vector_payload_mf(vt->inline_klass()->get_InlineKlass())) {\n-    return false;\n-  }\n-  \/\/ TODO 8239003 Why is this needed?\n-  if (AllocateNode::Ideal_allocation(vt->get_oop()) == nullptr) {\n-    return false;\n-  }\n-\n@@ -2674,2 +2675,2 @@\n-\n-  set_result(vt->finish_larval(this));\n+  const TypeInstPtr* ptr = buffer->bottom_type()->isa_instptr();\n+  set_result(InlineTypeNode::finish_larval(this, buffer, ptr));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":27,"deletions":26,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -961,1 +961,4 @@\n-\n+  \/\/ Bufferes in larval state should not be scalarized.\n+  if (alloc->_larval) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1780,3 +1780,6 @@\n-          \/\/ Scalarize null in src block to be able to merge it with inline type in target block\n-          assert(gvn().type(n)->is_zero_type(), \"Should have been scalarized\");\n-          map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n+          AllocateNode* alloc = AllocateNode::Ideal_allocation(n);\n+          if (alloc == nullptr || !alloc->_larval) {\n+            \/\/ Scalarize null in src block to be able to merge it with inline type in target block\n+            assert(gvn().type(n)->is_zero_type(), \"Should have been scalarized\");\n+            map()->set_req(j, InlineTypeNode::make_null(gvn(), t->inline_klass()));\n+          }\n@@ -1887,1 +1890,1 @@\n-      } else if (m->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n+      } else if (m->is_InlineType() && n->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n@@ -1926,1 +1929,1 @@\n-      if (phi != nullptr && phi->bottom_type()->is_inlinetypeptr()) {\n+      if (phi != nullptr && phi->bottom_type()->is_inlinetypeptr() && m->is_InlineType() && n->is_InlineType()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+    public static final Unsafe U =  Unsafe.getUnsafe();\n+\n@@ -47,1 +49,1 @@\n-        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        res = U.makePrivateBuffer(res);\n@@ -50,2 +52,2 @@\n-            boolean b = Unsafe.getUnsafe().getBoolean(payload, mOffset + i + offset);\n-            Unsafe.getUnsafe().putBoolean(res, mOffset + i, b);\n+            boolean b = U.getBoolean(payload, mOffset + i + offset);\n+            U.putBoolean(res, mOffset + i, b);\n@@ -53,1 +55,1 @@\n-        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        res = U.finishPrivateBuffer(res);\n@@ -60,1 +62,1 @@\n-        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        res = U.makePrivateBuffer(res);\n@@ -63,1 +65,1 @@\n-            Unsafe.getUnsafe().putBoolean(res, mOffset + i, val);\n+            U.putBoolean(res, mOffset + i, val);\n@@ -65,1 +67,1 @@\n-        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        res = U.finishPrivateBuffer(res);\n@@ -80,1 +82,1 @@\n-        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        res = U.makePrivateBuffer(res);\n@@ -83,2 +85,2 @@\n-            boolean b = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n-            Unsafe.getUnsafe().putBoolean(res, mOffset + i, f.apply(i, b));\n+            boolean b = U.getBoolean(bits, mOffset + i);\n+            U.putBoolean(res, mOffset + i, f.apply(i, b));\n@@ -86,1 +88,1 @@\n-        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        res = U.finishPrivateBuffer(res);\n@@ -102,1 +104,1 @@\n-        res = Unsafe.getUnsafe().makePrivateBuffer(res);\n+        res = U.makePrivateBuffer(res);\n@@ -105,3 +107,3 @@\n-            boolean b = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n-            boolean mb = Unsafe.getUnsafe().getBoolean(mbits, mOffset + i);\n-            Unsafe.getUnsafe().putBoolean(res, mOffset + i, f.apply(i, b, mb));\n+            boolean b = U.getBoolean(bits, mOffset + i);\n+            boolean mb = U.getBoolean(mbits, mOffset + i);\n+            U.putBoolean(res, mOffset + i, f.apply(i, b, mb));\n@@ -109,1 +111,1 @@\n-        res = Unsafe.getUnsafe().finishPrivateBuffer(res);\n+        res = U.finishPrivateBuffer(res);\n@@ -119,1 +121,1 @@\n-            arr[idx++] = Unsafe.getUnsafe().getBoolean(bits, mOffset + i);\n+            arr[idx++] = U.getBoolean(bits, mOffset + i);\n@@ -219,1 +221,1 @@\n-        return Unsafe.getUnsafe().getBoolean(bits, bits.multiFieldOffset() + idx);\n+        return U.getBoolean(bits, bits.multiFieldOffset() + idx);\n@@ -228,1 +230,1 @@\n-            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return true;\n+            if (U.getBoolean(bits, mOffset + i)) return true;\n@@ -239,1 +241,1 @@\n-            if (!Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return false;\n+            if (!U.getBoolean(bits, mOffset + i)) return false;\n@@ -250,1 +252,1 @@\n-            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) c++;\n+            if (U.getBoolean(bits, mOffset + i)) c++;\n@@ -260,1 +262,1 @@\n-            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return i;\n+            if (U.getBoolean(bits, mOffset + i)) return i;\n@@ -270,1 +272,1 @@\n-            if (Unsafe.getUnsafe().getBoolean(bits, mOffset + i)) return i;\n+            if (U.getBoolean(bits, mOffset + i)) return i;\n@@ -282,1 +284,1 @@\n-            res = Unsafe.getUnsafe().getBoolean(bits, mOffset + i) ? res | set : res;\n+            res = U.getBoolean(bits, mOffset + i) ? res | set : res;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":26,"deletions":24,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+    public static final Unsafe U = Unsafe.getUnsafe();\n+\n@@ -46,1 +48,1 @@\n-        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        payload = U.makePrivateBuffer(payload);\n@@ -51,1 +53,1 @@\n-            Unsafe.getUnsafe().putByte(payload, mf_offset + i * Byte.BYTES, (byte) si);\n+            U.putByte(payload, mf_offset + i * Byte.BYTES, (byte) si);\n@@ -53,1 +55,1 @@\n-        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        payload = U.finishPrivateBuffer(payload);\n@@ -61,1 +63,1 @@\n-        payload = Unsafe.getUnsafe().makePrivateBuffer(payload);\n+        payload = U.makePrivateBuffer(payload);\n@@ -66,1 +68,1 @@\n-            Unsafe.getUnsafe().putByte(payload, offset + i * Byte.BYTES, (byte) si);\n+            U.putByte(payload, offset + i * Byte.BYTES, (byte) si);\n@@ -68,1 +70,1 @@\n-        payload = Unsafe.getUnsafe().finishPrivateBuffer(payload);\n+        payload = U.finishPrivateBuffer(payload);\n@@ -88,1 +90,1 @@\n-            int sourceIndex = Unsafe.getUnsafe().getByte(indices, mf_offset + i * Byte.BYTES);\n+            int sourceIndex = U.getByte(indices, mf_offset + i * Byte.BYTES);\n@@ -126,1 +128,1 @@\n-            throw checkIndexFailed(Unsafe.getUnsafe().getByte(indices, offset + vecmask.firstTrue() * Byte.BYTES), length());\n+            throw checkIndexFailed(U.getByte(indices, offset + vecmask.firstTrue() * Byte.BYTES), length());\n@@ -149,1 +151,1 @@\n-        indices = Unsafe.getUnsafe().makePrivateBuffer(indices);\n+        indices = U.makePrivateBuffer(indices);\n@@ -151,1 +153,1 @@\n-            int si = Unsafe.getUnsafe().getByte(oldIndices, offset + i * Byte.BYTES);\n+            int si = U.getByte(oldIndices, offset + i * Byte.BYTES);\n@@ -160,1 +162,1 @@\n-            Unsafe.getUnsafe().putByte(indices, offset + i * Byte.BYTES, (byte) si);\n+            U.putByte(indices, offset + i * Byte.BYTES, (byte) si);\n@@ -162,1 +164,1 @@\n-        indices = Unsafe.getUnsafe().finishPrivateBuffer(indices);\n+        indices = U.finishPrivateBuffer(indices);\n@@ -228,1 +230,1 @@\n-            byte si = Unsafe.getUnsafe().getByte(indices, offset + i * Byte.BYTES);\n+            byte si = U.getByte(indices, offset + i * Byte.BYTES);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -83,0 +84,2 @@\n+    static final Unsafe U = Unsafe.getUnsafe();\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,2 +60,0 @@\n-    static final Unsafe U = Unsafe.getUnsafe();\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,2 +60,0 @@\n-    static final Unsafe U = Unsafe.getUnsafe();\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,2 +60,0 @@\n-    static final Unsafe U = Unsafe.getUnsafe();\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,2 +60,0 @@\n-    static final Unsafe U = Unsafe.getUnsafe();\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,2 +60,0 @@\n-    static final Unsafe U = Unsafe.getUnsafe();\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,2 +60,0 @@\n-    static final Unsafe U = Unsafe.getUnsafe();\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,2 +64,0 @@\n-    static final Unsafe U = Unsafe.getUnsafe();\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+compiler\/vectorapi\/reshape\/TestVectorReinterpret.java\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -408,1 +408,1 @@\n-    @IR(failOn = {CALL_UNSAFE, ALLOC})\n+    @IR(failOn = {CALL_UNSAFE})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}