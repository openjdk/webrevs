{"files":[{"patch":"@@ -57,0 +57,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -1866,1 +1867,0 @@\n-        assert(_gvn.type(arg)->is_zero_type() && !t->inline_klass()->is_null_free(), \"Unexpected argument type\");\n@@ -1959,0 +1959,9 @@\n+      Node* receiver = !call->method()->is_static() ? call->in(TypeFunc::Parms) : nullptr;\n+      if (ret->is_InlineType() &&\n+          receiver && receiver->bottom_type()->isa_instptr() &&\n+          receiver->bottom_type()->is_instptr()->instance_klass()->name()->get_symbol() == vmSymbols::jdk_internal_misc_Unsafe() &&\n+          call->method()->name()->get_symbol() == vmSymbols::makePrivateBuffer_name()) {\n+        \/\/ Re-buffer scalarized InlineTypeNodes returned from makePrivateBuffer\n+        \/\/ and transition the allocation into larval state.\n+        ret = ret->as_InlineType()->make_larval(this);\n+      }\n@@ -3419,1 +3428,1 @@\n-        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType(), \"should have been scalarized\");\n+        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType() || obj->bottom_type()->is_inlinetypeptr(), \"should have been scalarized\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -800,1 +800,1 @@\n-        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+        if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable && !alloc->_larval) {\n@@ -1012,1 +1012,1 @@\n-InlineTypeNode* InlineTypeNode::make_larval(GraphKit* kit, bool allocate) const {\n+Node* InlineTypeNode::make_larval(GraphKit* kit) const {\n@@ -1014,4 +1014,0 @@\n-  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n-  for (uint i = 1; i < req(); ++i) {\n-    res->set_req(i, in(i));\n-  }\n@@ -1019,8 +1015,7 @@\n-  if (allocate) {\n-    \/\/ Re-execute if buffering triggers deoptimization\n-    PreserveReexecuteState preexecs(kit);\n-    kit->jvms()->set_should_reexecute(true);\n-    Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n-    Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n-    AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n-    alloc->_larval = true;\n+  \/\/ Re-execute if buffering triggers deoptimization\n+  PreserveReexecuteState preexecs(kit);\n+  kit->jvms()->set_should_reexecute(true);\n+  Node* klass_node = kit->makecon(TypeKlassPtr::make(vk));\n+  Node* alloc_oop  = kit->new_instance(klass_node, nullptr, nullptr, true);\n+  AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_oop);\n+  alloc->_larval = true;\n@@ -1028,8 +1023,2 @@\n-    store(kit, alloc_oop, alloc_oop, vk);\n-    res->set_oop(alloc_oop);\n-  }\n-  \/\/ TODO 8239003\n-  \/\/res->set_type(TypeInlineType::make(vk, true));\n-  res = kit->gvn().transform(res)->as_InlineType();\n-  assert(!allocate || res->is_allocated(&kit->gvn()), \"must be allocated\");\n-  return res;\n+  store(kit, alloc_oop, alloc_oop, vk);\n+  return alloc_oop;\n@@ -1038,2 +1027,1 @@\n-InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit) const {\n-  Node* obj = get_oop();\n+InlineTypeNode* InlineTypeNode::finish_larval(GraphKit* kit, Node* obj, const TypeInstPtr* vk) {\n@@ -1051,9 +1039,1 @@\n-  ciInlineKlass* vk = inline_klass();\n-  InlineTypeNode* res = make_uninitialized(kit->gvn(), vk);\n-  for (uint i = 1; i < req(); ++i) {\n-    res->set_req(i, in(i));\n-  }\n-  \/\/ TODO 8239003\n-  \/\/res->set_type(TypeInlineType::make(vk, false));\n-  res = kit->gvn().transform(res)->as_InlineType();\n-  return res;\n+  return InlineTypeNode::make_from_oop(kit, obj, vk->inline_klass(), !vk->maybe_null());\n@@ -1284,1 +1264,1 @@\n-    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable) {\n+    if (alloc != nullptr && alloc->in(AllocateNode::InlineType) == this && !alloc->_is_scalar_replaceable && !alloc->_larval) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":14,"deletions":34,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -167,2 +167,2 @@\n-  InlineTypeNode* make_larval(GraphKit* kit, bool allocate) const;\n-  InlineTypeNode* finish_larval(GraphKit* kit) const;\n+  Node* make_larval(GraphKit* kit) const;\n+  static InlineTypeNode* finish_larval(GraphKit* kit, Node* obj, const TypeInstPtr* vk);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2630,4 +2630,5 @@\n-  if (argument(1)->is_InlineType() && is_store) {\n-    InlineTypeNode* value = InlineTypeNode::make_from_oop(this, base, _gvn.type(argument(1))->inline_klass());\n-    value = value->make_larval(this, false);\n-    replace_in_map(argument(1), value);\n+  if (_gvn.type(base)->is_inlinetypeptr() && is_store) {\n+    AllocateNode* alloc = AllocateNode::Ideal_allocation(base);\n+    if (alloc != nullptr) {\n+      assert(alloc->_larval, \"InlineType instance must be in _larval state for unsafe put operation.\\n\");\n+    }\n@@ -2651,1 +2652,1 @@\n-  set_result(value->as_InlineType()->make_larval(this, true));\n+  set_result(value->as_InlineType()->make_larval(this));\n@@ -2658,2 +2659,3 @@\n-  if (!buffer->is_InlineType()) {\n-    return false;\n+  \/\/ Incoming value should be a buffer and not InlineTypeNode.\n+  if (buffer->is_InlineType()) {\n+     return false;\n@@ -2661,3 +2663,3 @@\n-  InlineTypeNode* vt = buffer->as_InlineType();\n-  if (!vt->is_allocated(&_gvn) || VectorSupport::is_vector_payload_mf(vt->inline_klass()->get_InlineKlass())) {\n-    return false;\n+  \/\/ Incoming value should be inline type.\n+  if (!buffer->bottom_type()->is_inlinetypeptr()) {\n+     return false;\n@@ -2665,2 +2667,7 @@\n-  \/\/ TODO 8239003 Why is this needed?\n-  if (AllocateNode::Ideal_allocation(vt->get_oop()) == nullptr) {\n+  const TypeInstPtr* ptr = buffer->bottom_type()->isa_instptr();\n+\n+  \/\/ Allocation node must exist to generate IR for transitioning allocation out\n+  \/\/ of larval state. Disable the intrinsic and take unsafe slow path if allocation\n+  \/\/ is not reachable,  oop returned by Unsafe_finishPrivateBuffer native method\n+  \/\/ will automatically rematerialize InlineTypeNode.\n+  if (AllocateNode::Ideal_allocation(buffer) == nullptr) {\n@@ -2669,1 +2676,0 @@\n-\n@@ -2674,2 +2680,1 @@\n-\n-  set_result(vt->finish_larval(this));\n+  set_result(InlineTypeNode::finish_larval(this, buffer, ptr));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -961,1 +961,4 @@\n-\n+  \/\/ Bufferes in larval state should not be scalarized.\n+  if (alloc->_larval) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1887,1 +1887,1 @@\n-      } else if (m->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n+      } else if (m->is_InlineType() && n->is_InlineType() && m->as_InlineType()->has_phi_inputs(r)) {\n@@ -1926,1 +1926,1 @@\n-      if (phi != nullptr && phi->bottom_type()->is_inlinetypeptr()) {\n+      if (phi != nullptr && phi->bottom_type()->is_inlinetypeptr() && m->is_InlineType() && n->is_InlineType()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+compiler\/vectorapi\/reshape\/TestVectorReinterpret.java\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}