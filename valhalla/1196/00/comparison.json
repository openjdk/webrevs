{"files":[{"patch":"@@ -7399,1 +7399,41 @@\n-void Assembler::evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+void Assembler::evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5C, (0xC0 | encode));\n+}\n+\n+void Assembler::evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5D, (0xC0 | encode));\n+}\n+\n+void Assembler::evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5F, (0xC0 | encode));\n+}\n+\n+void Assembler::evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5E, (0xC0 | encode));\n+}\n+\n+void Assembler::eaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n@@ -7407,0 +7447,40 @@\n+void Assembler::esubsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5C, (0xC0 | encode));\n+}\n+\n+void Assembler::edivsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5E, (0xC0 | encode));\n+}\n+\n+void Assembler::emulsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x59, (0xC0 | encode));\n+}\n+\n+void Assembler::emaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5F, (0xC0 | encode));\n+}\n+\n+void Assembler::eminsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x5D, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2408,1 +2408,6 @@\n-  void evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void eaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void esubsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void emulsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void edivsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void emaxsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void eminsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n@@ -2410,0 +2415,5 @@\n+  void evsubph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evdivph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmulph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evminph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evmaxph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6304,0 +6304,24 @@\n+\n+void C2_MacroAssembler::efp16sh(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2) {\n+  switch(opcode) {\n+    case Op_AddHF: eaddsh(dst, src1, src2); break;\n+    case Op_SubHF: esubsh(dst, src1, src2); break;\n+    case Op_MulHF: emulsh(dst, src1, src2); break;\n+    case Op_DivHF: edivsh(dst, src1, src2); break;\n+    case Op_MaxHF: eminsh(dst, src1, src2); break;\n+    case Op_MinHF: emaxsh(dst, src1, src2); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n+\n+void C2_MacroAssembler::evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc) {\n+  switch(opcode) {\n+    case Op_AddVHF: evaddph(dst, src1, src2, vlen_enc); break;\n+    case Op_SubVHF: evsubph(dst, src1, src2, vlen_enc); break;\n+    case Op_MulVHF: evmulph(dst, src1, src2, vlen_enc); break;\n+    case Op_DivVHF: evdivph(dst, src1, src2, vlen_enc); break;\n+    case Op_MaxVHF: evminph(dst, src1, src2, vlen_enc); break;\n+    case Op_MinVHF: evmaxph(dst, src1, src2, vlen_enc); break;\n+    default: assert(false, \"%s\", NodeClassNames[opcode]); break;\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -500,0 +500,4 @@\n+  void efp16sh(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2);\n+\n+  void evfp16ph(int opcode, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1467,0 +1467,5 @@\n+    case Op_SubHF:\n+    case Op_MulHF:\n+    case Op_DivHF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n@@ -1738,0 +1743,5 @@\n+    case Op_SubVHF:\n+    case Op_MulVHF:\n+    case Op_DivVHF:\n+    case Op_MaxVHF:\n+    case Op_MinVHF:\n@@ -10228,1 +10238,1 @@\n-instruct addFP16_scalar (regF dst, regF src1, regF src2)\n+instruct fp16_scalar_ops (regF dst, regF src1, regF src2)\n@@ -10231,1 +10241,6 @@\n-  format %{ \"vaddsh $dst, $src1, $src2\" %}\n+  match(Set dst (SubHF src1 src2));\n+  match(Set dst (MulHF src1 src2));\n+  match(Set dst (DivHF src1 src2));\n+  match(Set dst (MinHF src1 src2));\n+  match(Set dst (MaxHF src1 src2));\n+  format %{ \"efp16sh $dst, $src1, $src2\" %}\n@@ -10233,1 +10248,2 @@\n-    __ evaddsh($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister);\n+    int opcode = this->ideal_Opcode();\n+    __ efp16sh(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister);\n@@ -10238,1 +10254,1 @@\n-instruct vaddVHF (vec dst, vec src1, vec src2)\n+instruct fp16_vector_ops (vec dst, vec src1, vec src2)\n@@ -10241,1 +10257,6 @@\n-  format %{ \"vaddph $dst, $src1, $src2\" %}\n+  match(Set dst (SubVHF src1 src2));\n+  match(Set dst (MulVHF src1 src2));\n+  match(Set dst (DivVHF src1 src2));\n+  match(Set dst (MaxVHF src1 src2));\n+  match(Set dst (MinVHF src1 src2));\n+  format %{ \"evfp16ph $dst, $src1, $src2\" %}\n@@ -10244,1 +10265,2 @@\n-    __ evaddph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+    int opcode = this->ideal_Opcode();\n+    __ evfp16ph(opcode, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+    @IR(counts = {IRNode.SUB_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n@@ -96,0 +98,2 @@\n+    @IR(counts = {IRNode.MUL_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n@@ -107,0 +111,2 @@\n+    @IR(counts = {IRNode.DIV_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n@@ -118,0 +124,2 @@\n+    @IR(counts = {IRNode.MAX_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n@@ -129,0 +137,2 @@\n+    @IR(counts = {IRNode.MIN_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestFP16ScalarOps.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n@@ -83,0 +85,2 @@\n+    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n@@ -105,0 +109,2 @@\n+    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n@@ -127,0 +133,2 @@\n+    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n@@ -149,0 +157,2 @@\n+    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n@@ -171,0 +181,2 @@\n+    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOps.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}