{"files":[{"patch":"@@ -146,2 +146,117 @@\n-Node *MemNode::optimize_simple_memory_chain(Node *mchain, const TypeOopPtr *t_oop, Node *load, PhaseGVN *phase) {\n-  assert((t_oop != nullptr), \"sanity\");\n+\/\/ If call is a constructor call on receiver, returns the class which declares the target method,\n+\/\/ else returns nullptr. This information can then be used to deduce if call modifies a field of\n+\/\/ receiver. Specifically, if the field is declared in a class that is a subclass of the one\n+\/\/ declaring the constructor, then the field is set inside the constructor, else the field must be\n+\/\/ set before the constructor invocation. E.g. A field Super.x will be set during the execution of\n+\/\/ Sub::<init>, while a field Sub.y must be set before Super::<init> is invoked.\n+static ciInstanceKlass* find_constructor_call_method_holder(Node* call, Node* receiver) {\n+  if (!call->is_CallJava()) {\n+    return nullptr;\n+  }\n+\n+  ciMethod* target = call->as_CallJava()->method();\n+  if (target == nullptr || !target->is_object_constructor()) {\n+    return nullptr;\n+  }\n+\n+  assert(call->req() > TypeFunc::Parms, \"constructor must have at least 1 argument\");\n+  Node* parm = call->in(TypeFunc::Parms)->uncast();\n+  receiver = receiver->uncast();\n+  if (parm == receiver || (parm->is_InlineType() && parm->as_InlineType()->get_oop()->uncast() == receiver)) {\n+    return target->holder();\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Find the memory output corresponding to the fall-through path of a call\n+static Node* find_call_fallthrough_mem_output(CallNode* call) {\n+  ResourceMark rm;\n+  CallProjections* projs = call->extract_projections(false, false);\n+  Node* res = projs->fallthrough_memproj;\n+  assert(res != nullptr, \"must have a fallthrough mem output\");\n+  return res;\n+}\n+\n+\/\/ Try to find a better memory input for a load from a strict final field of an object that is\n+\/\/ allocated in the current compilation unit, or is the first parameter when we are in a\n+\/\/ constructor\n+static Node* optimize_strict_final_load_memory_from_local_object(ciField* field, ProjNode* base_uncasted) {\n+  if (!EnableValhalla) {\n+    \/\/ In this method we depends on the fact that strict fields are set before the invocation of\n+    \/\/ super(), I'm not sure if this is true without Valhalla\n+    return nullptr;\n+  }\n+\n+  \/\/ The node that can be passed into a constructor\n+  Node* base = base_uncasted;\n+  if (!base_uncasted->is_Parm()) {\n+    assert(base_uncasted->_con == AllocateNode::RawAddress && base_uncasted->in(0)->is_Allocate(), \"must be the RawAddress of an AllocateNode\");\n+    base = base_uncasted->in(0)->as_Allocate()->result_cast();\n+    assert(base != nullptr && base->in(1) == base_uncasted, \"must find a valid base\");\n+  }\n+\n+  \/\/ Try to see if there is a constructor call on the base\n+  for (DUIterator_Fast imax, i = base->fast_outs(imax); i < imax; i++) {\n+    Node* out = base->fast_out(i);\n+    ciInstanceKlass* target_holder = find_constructor_call_method_holder(out, base);\n+    if (target_holder == nullptr) {\n+      continue;\n+    } else if (target_holder->is_subclass_of(field->holder())) {\n+      return find_call_fallthrough_mem_output(out->as_CallJava());\n+    } else {\n+      Node* res = out->in(TypeFunc::Memory);\n+      assert(res != nullptr, \"should have a memory input\");\n+      return res;\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Try to find a better memory input for a load from a strict final field\n+static Node* try_optimize_strict_final_load_memory(PhaseGVN* phase, ciField* field, Node* adr, ProjNode*& base_local) {\n+  intptr_t offset = 0;\n+  Node* base = AddPNode::Ideal_base_and_offset(adr, phase, offset);\n+  if (base == nullptr) {\n+    return nullptr;\n+  }\n+\n+  Node* base_uncasted = base->uncast();\n+  if (base_uncasted->is_Proj()) {\n+    MultiNode* multi = base_uncasted->in(0)->as_Multi();\n+    if (multi->is_Allocate()) {\n+      \/\/ The result of an AllocateNode, try to find the constructor call\n+      base_local = base_uncasted->as_Proj();\n+      return optimize_strict_final_load_memory_from_local_object(field, base_uncasted->as_Proj());\n+    } else if (multi->is_Call()) {\n+      \/\/ The oop is returned from a call, the memory can be the fallthrough output of the call\n+      return find_call_fallthrough_mem_output(multi->as_Call());\n+    } else if (multi->is_Start()) {\n+      \/\/ The oop is a parameter\n+      if (phase->C->method()->is_object_constructor() && base_uncasted->as_Proj()->_con == TypeFunc::Parms) {\n+        \/\/ The receiver of a constructor is similar to the result of an AllocateNode\n+        base_local = base_uncasted->as_Proj();\n+        return optimize_strict_final_load_memory_from_local_object(field, base_uncasted->as_Proj());\n+      } else {\n+        \/\/ Use the start memory otherwise\n+        return multi->proj_out(TypeFunc::Memory);\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/\/ Whether a call can modify a strict final field of base_local, given that base_local is allocated\n+\/\/ inside the current compilation unit, or is the first parameter when the compilation root is a\n+\/\/ constructor. This is equivalent to asking whether base_local is the receiver of the constructor\n+\/\/ invocation call and the class declaring the target method is a subclass of the class declaring\n+\/\/ field.\n+static bool call_can_modify_local_object(ciField* field, CallNode* call, Node* base_local) {\n+  ciInstanceKlass* target_holder = find_constructor_call_method_holder(call, base_local);\n+  return target_holder != nullptr && target_holder->is_subclass_of(field->holder());\n+}\n+\n+Node* MemNode::optimize_simple_memory_chain(Node* mchain, const TypeOopPtr* t_oop, Node* load, PhaseGVN* phase) {\n+  assert(t_oop != nullptr, \"sanity\");\n@@ -149,5 +264,38 @@\n-  bool is_boxed_value_load = t_oop->is_ptr_to_boxed_value() &&\n-                             (load != nullptr) && load->is_Load() &&\n-                             (phase->is_IterGVN() != nullptr);\n-  if (!(is_instance || is_boxed_value_load))\n-    return mchain;  \/\/ don't try to optimize non-instance types\n+\n+  ciField* field = phase->C->alias_type(t_oop)->field();\n+  bool is_strict_final_load = false;\n+\n+  \/\/ After macro expansion, an allocation may become a call, changing the memory input to the\n+  \/\/ memory output of that call would be illegal. As a result, disallow this transformation after\n+  \/\/ macro expansion.\n+  if (phase->is_IterGVN() && phase->C->allow_macro_nodes() && load != nullptr && load->is_Load() && !load->as_Load()->is_mismatched_access()) {\n+    if (EnableValhalla) {\n+      if (field != nullptr && (field->holder()->is_inlinetype() || field->holder()->is_abstract_value_klass())) {\n+        is_strict_final_load = true;\n+      }\n+#ifdef ASSERT\n+      if (t_oop->is_inlinetypeptr() && t_oop->inline_klass()->contains_field_offset(t_oop->offset())) {\n+        assert(is_strict_final_load, \"sanity check for basic cases\");\n+      }\n+#endif\n+    } else {\n+      is_strict_final_load = field != nullptr && t_oop->is_ptr_to_boxed_value();\n+    }\n+  }\n+\n+  if (!is_instance && !is_strict_final_load) {\n+    return mchain;\n+  }\n+\n+  Node* result = mchain;\n+  ProjNode* base_local = nullptr;\n+\n+  if (is_strict_final_load) {\n+    Node* adr = load->in(MemNode::Address);\n+    assert(phase->type(adr) == t_oop, \"inconsistent type\");\n+    Node* tmp = try_optimize_strict_final_load_memory(phase, field, adr, base_local);\n+    if (tmp != nullptr) {\n+      result = tmp;\n+    }\n+  }\n+\n@@ -155,3 +303,2 @@\n-  Node *start_mem = phase->C->start()->proj_out_or_null(TypeFunc::Memory);\n-  Node *prev = nullptr;\n-  Node *result = mchain;\n+  Node* start_mem = phase->C->start()->proj_out_or_null(TypeFunc::Memory);\n+  Node* prev = nullptr;\n@@ -160,2 +307,5 @@\n-    if (result == start_mem)\n-      break;  \/\/ hit one of our sentinels\n+    if (result == start_mem) {\n+      \/\/ start_mem is the earliest memory possible\n+      break;\n+    }\n+\n@@ -164,1 +314,1 @@\n-      Node *proj_in = result->in(0);\n+      Node* proj_in = result->in(0);\n@@ -166,1 +316,2 @@\n-        break;  \/\/ hit one of our sentinels\n+        \/\/ This is the allocation that creates the object from which we are loading from\n+        break;\n@@ -169,2 +320,4 @@\n-        CallNode *call = proj_in->as_Call();\n-        if (!call->may_modify(t_oop, phase)) { \/\/ returns false for instances\n+        CallNode* call = proj_in->as_Call();\n+        if (!call->may_modify(t_oop, phase)) {\n+          result = call->in(TypeFunc::Memory);\n+        } else if (is_strict_final_load && base_local != nullptr && !call_can_modify_local_object(field, call, base_local)) {\n@@ -182,1 +335,1 @@\n-        } else if (is_boxed_value_load) {\n+        } else if (is_strict_final_load) {\n@@ -186,1 +339,5 @@\n-            result = proj_in->in(TypeFunc::Memory); \/\/ not related allocation\n+            \/\/ Allocation of another type, must be another object\n+            result = proj_in->in(TypeFunc::Memory);\n+          } else if (base_local != nullptr && (base_local->is_Parm() || base_local->in(0) != alloc)) {\n+            \/\/ Allocation of another object\n+            result = proj_in->in(TypeFunc::Memory);\n@@ -1997,1 +2154,8 @@\n-  return progress ? this : nullptr;\n+  if (progress) {\n+    return this;\n+  }\n+\n+  if (!can_reshape) {\n+    phase->record_for_igvn(this);\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":183,"deletions":19,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+    @DontInline\n+    static void call() {}\n+\n@@ -1068,0 +1071,56 @@\n+\n+    static value class MyValue42 {\n+        int x;\n+\n+        @ForceInline\n+        MyValue42(int x) {\n+            this.x = x;\n+            call();\n+            super();\n+        }\n+\n+        @ForceInline\n+        static Object make(int x) {\n+            return new MyValue42(x);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {LOAD})\n+    public MyValue42 test43(int x) {\n+        return (MyValue42) MyValue42.make(x);\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier() {\n+        MyValue42 v = test43(rI);\n+        Asserts.assertEQ(rI, v.x);\n+    }\n+\n+    static value class MyValue43 {\n+        int x;\n+\n+        @ForceInline\n+        MyValue43(int x) {\n+            this.x = x;\n+            super();\n+            call();\n+        }\n+\n+        @ForceInline\n+        static Object make(int x) {\n+            return new MyValue43(x);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {LOAD})\n+    public MyValue43 test44(int x) {\n+        return (MyValue43) MyValue43.make(x);\n+    }\n+\n+    @Run(test = \"test44\")\n+    public void test44_verifier() {\n+        MyValue43 v = test44(rI);\n+        Asserts.assertEQ(rI, v.x);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"}]}