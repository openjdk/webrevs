{"files":[{"patch":"@@ -146,0 +146,26 @@\n+\/\/ If n is a constructor call on receiver, returns the class which declares the target method, else\n+\/\/ returns nullptr. This information can then be used to deduce if n modifies a field of receiver.\n+\/\/ Specifically, if the field is declared in a class that is a subclass of the one declaring the\n+\/\/ constructor, then the field is set inside the constructor, else the field must be set before the\n+\/\/ constructor invocation. E.g. A field Super.x will be set during the execution of Sub::<init>,\n+\/\/ while a field Sub.y must be set before Super::<init> is invoked.\n+static ciInstanceKlass* find_constructor_call_method_holder(Node* n, Node* receiver) {\n+  if (!n->is_CallJava()) {\n+    return nullptr;\n+  }\n+\n+  ciMethod* target = n->as_CallJava()->method();\n+  if (target == nullptr || !target->is_object_constructor()) {\n+    return nullptr;\n+  }\n+\n+  assert(n->req() > TypeFunc::Parms, \"constructor must have at least 1 argument\");\n+  Node* parm = n->in(TypeFunc::Parms)->uncast();\n+  receiver = receiver->uncast();\n+  if (parm == receiver || (parm->is_InlineType() && parm->as_InlineType()->get_oop()->uncast() == receiver)) {\n+    return target->holder();\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -159,0 +185,6 @@\n+  if (!EnableValhalla) {\n+    \/\/ In this method we depends on the fact that strict fields are set before the invocation of\n+    \/\/ super(), I'm not sure if this is true without Valhalla\n+    return nullptr;\n+  }\n+\n@@ -170,1 +202,2 @@\n-    if (!out->is_CallJava() || out->req() <= TypeFunc::Parms) {\n+    ciInstanceKlass* target_holder = find_constructor_call_method_holder(out, base);\n+    if (target_holder == nullptr) {\n@@ -172,22 +205,6 @@\n-    }\n-\n-    Node* parm = out->in(TypeFunc::Parms);\n-\n-    if (parm == base || (parm->is_InlineType() && parm->as_InlineType()->get_oop() == base)) {\n-      CallJavaNode* call = out->as_CallJava();\n-      ciMethod* target = call->method();\n-      if (!target->is_object_constructor()) {\n-        continue;\n-      }\n-\n-      \/\/ If the field is declared in a class that is a subclass of the one declaring the\n-      \/\/ constructor, then the field is set inside the constructor, else the field must be set\n-      \/\/ before the constructor invocation. E.g. A field Super.x will be set during the execution\n-      \/\/ of Sub::<init>, while a field Sub.y must be set before Super::<init> is invoked.\n-      if (target->holder()->is_subclass_of(field->holder())) {\n-        return find_call_fallthrough_mem_output(call);\n-      } else {\n-        Node* res = call->in(TypeFunc::Memory);\n-        assert(res != nullptr, \"should have a memory input\");\n-        return res;\n-      }\n+    } else if (target_holder->is_subclass_of(field->holder())) {\n+      return find_call_fallthrough_mem_output(out->as_CallJava());\n+    } else {\n+      Node* res = out->in(TypeFunc::Memory);\n+      assert(res != nullptr, \"should have a memory input\");\n+      return res;\n@@ -201,1 +218,1 @@\n-static Node* optimize_strict_final_load_memory(PhaseGVN* phase, ciField* field, Node* adr, Node*& base_local) {\n+static Node* try_optimize_strict_final_load_memory(PhaseGVN* phase, ciField* field, Node* adr, ProjNode*& base_local) {\n@@ -213,1 +230,1 @@\n-      base_local = base_uncasted;\n+      base_local = base_uncasted->as_Proj();\n@@ -222,1 +239,1 @@\n-        base_local = base_uncasted;\n+        base_local = base_uncasted->as_Proj();\n@@ -234,2 +251,5 @@\n-\/\/ Whether a call can modify a strict final field of base, given that base is allocated inside the\n-\/\/ current compilation unit, or is the first parameter when we are in a constructor\n+\/\/ Whether a call can modify a strict final field of base_local, given that base_local is allocated\n+\/\/ inside the current compilation unit, or is the first parameter when the compilation root is a\n+\/\/ constructor. This is equivalent to asking whether base_local is the receiver of the constructor\n+\/\/ invocation call and the class declaring the target method is a subclass of the class declaring\n+\/\/ field.\n@@ -237,15 +257,2 @@\n-  \/\/ The fields can only be modified in this method or in a constructor\n-  if (!call->is_CallJava() || call->req() <= TypeFunc::Parms) {\n-    return false;\n-  }\n-\n-  ciMethod* target = call->as_CallJava()->method();\n-  if (!target->is_object_constructor()) {\n-    return false;\n-  }\n-\n-  Node* parm = call->in(TypeFunc::Parms);\n-  if (parm->uncast() == base_local || (parm->is_InlineType() && parm->as_InlineType()->get_oop()->uncast() == base_local)) {\n-    return target->holder()->is_subclass_of(field->holder());\n-  }\n-  return false;\n+  ciInstanceKlass* target_holder = find_constructor_call_method_holder(call, base_local);\n+  return target_holder != nullptr && target_holder->is_subclass_of(field->holder());\n@@ -265,6 +272,15 @@\n-    if (field != nullptr && (field->holder()->is_inlinetype() || field->holder()->is_abstract_value_klass())) {\n-      is_strict_final_load = true;\n-    }\n-#ifdef ASSERT\n-    if (t_oop->is_inlinetypeptr() && t_oop->inline_klass()->contains_field_offset(t_oop->offset())) {\n-      assert(is_strict_final_load, \"sanity check for basic cases\");\n+    if (EnableValhalla) {\n+      if (field != nullptr && (field->holder()->is_inlinetype() || field->holder()->is_abstract_value_klass())) {\n+        is_strict_final_load = true;\n+      }\n+  #ifdef ASSERT\n+      if (t_oop->is_inlinetypeptr() && t_oop->inline_klass()->contains_field_offset(t_oop->offset())) {\n+        assert(is_strict_final_load, \"sanity check for basic cases\");\n+      }\n+      if (t_oop->is_ptr_to_boxed_value()) {\n+        assert(is_strict_final_load, \"sanity check for basic cases\");\n+      }\n+  #endif\n+    } else {\n+      assert(field != nullptr, \"must find the corresponding field\");\n+      is_strict_final_load = t_oop->is_ptr_to_boxed_value();\n@@ -272,1 +288,0 @@\n-#endif\n@@ -280,1 +295,1 @@\n-  Node* base_local = nullptr;\n+  ProjNode* base_local = nullptr;\n@@ -285,1 +300,1 @@\n-    Node* tmp = optimize_strict_final_load_memory(phase, field, adr, base_local);\n+    Node* tmp = try_optimize_strict_final_load_memory(phase, field, adr, base_local);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":67,"deletions":52,"binary":false,"changes":119,"status":"modified"}]}