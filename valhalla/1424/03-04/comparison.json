{"files":[{"patch":"@@ -146,8 +146,8 @@\n-\/\/ If n is a constructor call on receiver, returns the class which declares the target method, else\n-\/\/ returns nullptr. This information can then be used to deduce if n modifies a field of receiver.\n-\/\/ Specifically, if the field is declared in a class that is a subclass of the one declaring the\n-\/\/ constructor, then the field is set inside the constructor, else the field must be set before the\n-\/\/ constructor invocation. E.g. A field Super.x will be set during the execution of Sub::<init>,\n-\/\/ while a field Sub.y must be set before Super::<init> is invoked.\n-static ciInstanceKlass* find_constructor_call_method_holder(Node* n, Node* receiver) {\n-  if (!n->is_CallJava()) {\n+\/\/ If call is a constructor call on receiver, returns the class which declares the target method,\n+\/\/ else returns nullptr. This information can then be used to deduce if call modifies a field of\n+\/\/ receiver. Specifically, if the field is declared in a class that is a subclass of the one\n+\/\/ declaring the constructor, then the field is set inside the constructor, else the field must be\n+\/\/ set before the constructor invocation. E.g. A field Super.x will be set during the execution of\n+\/\/ Sub::<init>, while a field Sub.y must be set before Super::<init> is invoked.\n+static ciInstanceKlass* find_constructor_call_method_holder(Node* call, Node* receiver) {\n+  if (!call->is_CallJava()) {\n@@ -157,1 +157,1 @@\n-  ciMethod* target = n->as_CallJava()->method();\n+  ciMethod* target = call->as_CallJava()->method();\n@@ -162,2 +162,2 @@\n-  assert(n->req() > TypeFunc::Parms, \"constructor must have at least 1 argument\");\n-  Node* parm = n->in(TypeFunc::Parms)->uncast();\n+  assert(call->req() > TypeFunc::Parms, \"constructor must have at least 1 argument\");\n+  Node* parm = call->in(TypeFunc::Parms)->uncast();\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"}]}