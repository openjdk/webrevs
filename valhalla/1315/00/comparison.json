{"files":[{"patch":"@@ -141,13 +141,0 @@\n-void BarrierSetAssembler::value_copy(MacroAssembler* masm, DecoratorSet decorators,\n-                                     Register src, Register dst, Register value_klass) {\n-  \/\/ value_copy implementation is fairly complex, and there are not any\n-  \/\/ \"short-cuts\" to be made from asm. What there is, appears to have the same\n-  \/\/ cost in C++, so just \"call_VM_leaf\" for now rather than maintain hundreds\n-  \/\/ of hand-rolled instructions...\n-  if (decorators & IS_DEST_UNINITIALIZED) {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy_is_dest_uninitialized), src, dst, value_klass);\n-  } else {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy), src, dst, value_klass);\n-  }\n-}\n-\n@@ -161,1 +148,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy_is_dest_uninitialized2), src, dst, inline_layout_info);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy_is_dest_uninitialized), src, dst, inline_layout_info);\n@@ -163,1 +150,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy2), src, dst, inline_layout_info);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy), src, dst, inline_layout_info);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -103,2 +103,0 @@\n-  virtual void value_copy(MacroAssembler* masm, DecoratorSet decorators,\n-                          Register src, Register dst, Register value_klass);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5413,6 +5413,0 @@\n-void MacroAssembler::access_value_copy(DecoratorSet decorators, Register src, Register dst,\n-                                       Register inline_klass) {\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->value_copy(this, decorators, src, dst, inline_klass);\n-}\n-\n@@ -5456,1 +5450,1 @@\n-  add(data, data, arrayOopDesc::base_offset_in_bytes(T_PRIMITIVE_OBJECT));\n+  add(data, data, arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -929,1 +929,0 @@\n-  void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register inline_klass);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -831,1 +831,1 @@\n-    __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::value_array_load), r0, r1);\n+    __ call_VM(r0, CAST_FROM_FN_PTR(address, InterpreterRuntime::flat_array_load), r0, r1);\n@@ -1185,1 +1185,5 @@\n-    \/\/ No way to store null in flat null-free array\n+    if (UseFlatArray) {\n+      __ test_flat_array_oop(r3, r8, is_flat_array);\n+    }\n+\n+    \/\/ No way to store null in a null-free array\n@@ -1203,34 +1207,4 @@\n-    \/\/ Simplistic type check...\n-    \/\/ r0 - value, r2 - index, r3 - array.\n-\n-    \/\/ Profile the not-null value's klass.\n-    \/\/ Load value class\n-     __ load_klass(r1, r0);\n-\n-    \/\/ Move element klass into r7\n-     __ ldr(r7, Address(r5, ArrayKlass::element_klass_offset()));\n-\n-    \/\/ flat value array needs exact type match\n-    \/\/ is \"r1 == r7\" (value subclass == array element superclass)\n-\n-     __ cmp(r7, r1);\n-     __ br(Assembler::EQ, is_type_ok);\n-\n-     __ b(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));\n-\n-     __ bind(is_type_ok);\n-    \/\/ r1: value's klass\n-    \/\/ r3: array\n-    \/\/ r5: array klass\n-    __ test_klass_is_empty_inline_type(r1, r7, done);\n-\n-    \/\/ calc dst for copy\n-    __ ldrw(r7, at_tos_p1()); \/\/ index\n-    __ data_for_value_array_index(r3, r5, r7, r7);\n-\n-    \/\/ ...and src for copy\n-    __ ldr(r6, at_tos());  \/\/ value\n-    __ data_for_oop(r6, r6, r1);\n-\n-    __ mov(r4, r1);  \/\/ Shuffle arguments to avoid conflict with c_rarg1\n-    __ access_value_copy(IN_HEAP, r6, r7, r4);\n+    __ ldr(r0, at_tos());    \/\/ value\n+    __ ldr(r3, at_tos_p1()); \/\/ index\n+    __ ldr(r2, at_tos_p2()); \/\/ array\n+    __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::flat_array_store), r0, r2, r3);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":10,"deletions":36,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -203,13 +203,0 @@\n-void BarrierSetAssembler::value_copy(MacroAssembler* masm, DecoratorSet decorators,\n-                                     Register src, Register dst, Register value_klass) {\n-  \/\/ value_copy implementation is fairly complex, and there are not any\n-  \/\/ \"short-cuts\" to be made from asm. What there is, appears to have the same\n-  \/\/ cost in C++, so just \"call_VM_leaf\" for now rather than maintain hundreds\n-  \/\/ of hand-rolled instructions...\n-  if (decorators & IS_DEST_UNINITIALIZED) {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy_is_dest_uninitialized), src, dst, value_klass);\n-  } else {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy), src, dst, value_klass);\n-  }\n-}\n-\n@@ -223,1 +210,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy_is_dest_uninitialized2), src, dst, inline_layout_info);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy_is_dest_uninitialized), src, dst, inline_layout_info);\n@@ -225,1 +212,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy2), src, dst, inline_layout_info);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetRuntime::value_copy), src, dst, inline_layout_info);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-  virtual void value_copy(MacroAssembler* masm, DecoratorSet decorators,\n-                          Register src, Register dst, Register value_klass);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1250,47 +1250,0 @@\n-void InterpreterMacroAssembler::read_flat_element(Register array, Register index,\n-                                                  Register t1, Register t2,\n-                                                  Register obj) {\n-  assert_different_registers(array, index, t1, t2);\n-  Label alloc_failed, empty_value, done;\n-  const Register array_klass = t2;\n-  const Register elem_klass = t1;\n-  const Register alloc_temp = LP64_ONLY(rscratch1) NOT_LP64(rsi);\n-  const Register dst_temp   = LP64_ONLY(rscratch2) NOT_LP64(rdi);\n-\n-  \/\/ load in array->klass()->element_klass()\n-  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n-  load_klass(array_klass, array, tmp_load_klass);\n-  movptr(elem_klass, Address(array_klass, ArrayKlass::element_klass_offset()));\n-\n-  \/\/check for empty value klass\n-  test_klass_is_empty_inline_type(elem_klass, dst_temp, empty_value);\n-\n-  \/\/ calc source into \"array_klass\" and free up some regs\n-  const Register src = array_klass;\n-  push(index); \/\/ preserve index reg in case alloc_failed\n-  data_for_value_array_index(array, array_klass, index, src);\n-\n-  allocate_instance(elem_klass, obj, alloc_temp, dst_temp, false, alloc_failed);\n-  \/\/ Have an oop instance buffer, copy into it\n-  store_ptr(0, obj); \/\/ preserve obj (overwrite index, no longer needed)\n-  data_for_oop(obj, dst_temp, elem_klass);\n-  access_value_copy(IS_DEST_UNINITIALIZED, src, dst_temp, elem_klass);\n-  pop(obj);\n-  jmp(done);\n-\n-  bind(empty_value);\n-  get_empty_inline_type_oop(elem_klass, dst_temp, obj);\n-  jmp(done);\n-\n-  bind(alloc_failed);\n-  pop(index);\n-  if (array == c_rarg2) {\n-    mov(elem_klass, array);\n-    array = elem_klass;\n-  }\n-  call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::value_array_load), array, index);\n-\n-  bind(done);\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -229,9 +229,0 @@\n-  \/\/ Allocate value buffer in \"obj\" and read in flat element at the given index\n-  \/\/ NOTES:\n-  \/\/   - Return via \"obj\" must be rax\n-  \/\/   - kills all given regs\n-  \/\/   - 32 bits: kills rdi and rsi\n-  void read_flat_element(Register array, Register index,\n-                         Register t1, Register t2,\n-                         Register obj = rax);\n-\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -6070,6 +6070,0 @@\n-void MacroAssembler::access_value_copy(DecoratorSet decorators, Register src, Register dst,\n-                                       Register inline_klass) {\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->value_copy(this, decorators, src, dst, inline_klass);\n-}\n-\n@@ -6113,1 +6107,1 @@\n-  lea(data, Address(array, index, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_PRIMITIVE_OBJECT)));\n+  lea(data, Address(array, index, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT)));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -408,1 +408,0 @@\n-  void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register inline_klass);\n@@ -410,2 +409,0 @@\n-  \/\/ We probably need the following for arrays:    TODO FIXME\n-  \/\/ void flat_element_copy(DecoratorSet decorators, Register src, Register dst, Register array);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -851,1 +851,2 @@\n-    __ read_flat_element(array, index, rbx, rcx, rax);\n+    __ movptr(rbx, array);\n+    call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::flat_array_load), rbx, index);\n@@ -1203,0 +1204,7 @@\n+      \/\/ Move array class to rdi\n+    __ load_klass(rdi, rdx, rscratch1);\n+    if (UseFlatArray) {\n+      __ movl(rbx, Address(rdi, Klass::layout_helper_offset()));\n+      __ test_flat_array_layout(rbx, is_flat_array);\n+    }\n+\n@@ -1220,26 +1228,3 @@\n-    \/\/ Simplistic type check...\n-\n-    \/\/ Profile the not-null value's klass.\n-    __ load_klass(rbx, rax, rscratch1);\n-    \/\/ Move element klass into rax\n-    __ movptr(rax, Address(rdi, ArrayKlass::element_klass_offset()));\n-    \/\/ flat value array needs exact type match\n-    \/\/ is \"rax == rbx\" (value subclass == array element superclass)\n-    __ cmpptr(rax, rbx);\n-    __ jccb(Assembler::equal, is_type_ok);\n-\n-    __ jump(RuntimeAddress(Interpreter::_throw_ArrayStoreException_entry));\n-\n-    __ bind(is_type_ok);\n-    \/\/ rbx: value's klass\n-    \/\/ rdx: array\n-    \/\/ rdi: array klass\n-    __ test_klass_is_empty_inline_type(rbx, rax, done);\n-\n-    \/\/ calc dst for copy\n-    __ movl(rax, at_tos_p1()); \/\/ index\n-    __ data_for_value_array_index(rdx, rdi, rax, rax);\n-\n-    \/\/ ...and src for copy\n-    __ movptr(rcx, at_tos());  \/\/ value\n-    __ data_for_oop(rcx, rcx, rbx);\n+    __ movptr(rax, at_tos());\n+    __ movl(rcx, at_tos_p1()); \/\/ index\n+    __ movptr(rdx, at_tos_p2()); \/\/ array\n@@ -1247,1 +1232,1 @@\n-    __ access_value_copy(IN_HEAP, rcx, rax, rbx);\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::flat_array_store), rax, rdx, rcx);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":13,"deletions":28,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -449,0 +449,1 @@\n+  InlineKlass* vk = InlineKlass::cast(elem_klass);\n@@ -451,1 +452,7 @@\n-  arrayOop obj = oopFactory::new_valueArray(elem_klass, length, CHECK);\n+  arrayOop obj= nullptr;\n+  \/\/  Limitation here, only non-atomic layouts are supported\n+  if (UseFlatArray && vk->has_non_atomic_layout()) {\n+    obj = oopFactory::new_flatArray(elem_klass, length, LayoutKind::NON_ATOMIC_FLAT, CHECK);\n+  } else {\n+    obj = oopFactory::new_null_free_objArray(elem_klass, length, CHECK);\n+  }\n@@ -512,1 +519,1 @@\n-  oop obj = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);\n+  oop obj = array->read_value_from_flat_array(index, CHECK);\n@@ -528,1 +535,1 @@\n-    array->value_copy_to_index(value, index, LayoutKind::PAYLOAD); \/\/ Non atomic is currently the only layout supported by flat arrays\n+    array->write_value_to_flat_array(value, index, CHECK);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-  int max_elem_count = ((MIN_GC_REGION_ALIGNMENT - arrayOopDesc::header_size_in_bytes()) \/ heapOopSize);\n+  int max_elem_count = ((MIN_GC_REGION_ALIGNMENT - arrayOopDesc::header_size_in_bytes(T_INT)) \/ heapOopSize);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,8 @@\n-        Klass* ak = InlineKlass::cast(klass->get_Klass())->value_array_klass(THREAD);\n+        Klass* ak = nullptr;\n+        InlineKlass* vk = InlineKlass::cast(klass->get_Klass());\n+        if (UseFlatArray && vk->has_non_atomic_layout()) {\n+          \/\/ Current limitation: returns only non-atomic flat arrays, atomic layout not supported here\n+          ak = vk->flat_array_klass(LayoutKind::NON_ATOMIC_FLAT, THREAD);\n+        } else {\n+          ak = vk->null_free_reference_array(THREAD);\n+        }\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1156,1 +1156,1 @@\n-            value = oopFactory::new_valueArray(kelem, length, CHECK_(true));\n+            value = oopFactory::new_flatArray(kelem, length, LayoutKind::NON_ATOMIC_FLAT, CHECK_(true)); \/\/ TODO FIXME fix the hard coded layout kind\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    if (NullableFieldFlattening && vk->has_nullable_layout()) {\n+    if (NullableFieldFlattening && vk->has_nullable_atomic_layout()) {\n@@ -83,1 +83,1 @@\n-      *size = vk->nullable_size_in_bytes();\n+      *size = vk->nullable_atomic_size_in_bytes();\n@@ -1195,1 +1195,1 @@\n-    if (has_nullable_layout() && _payload_alignment < nullable_layout_size_in_bytes()) {\n+    if (has_nullable_atomic_layout() && _payload_alignment < nullable_layout_size_in_bytes()) {\n@@ -1204,1 +1204,1 @@\n-        if (has_nullable_layout()) {\n+        if (has_nullable_atomic_layout()) {\n@@ -1211,1 +1211,1 @@\n-        if (has_nullable_layout() && !_is_empty_inline_class) {  \/\/ empty values don't have a dedicated NULL_MARKER block\n+        if (has_nullable_atomic_layout() && !_is_empty_inline_class) {  \/\/ empty values don't have a dedicated NULL_MARKER block\n@@ -1224,1 +1224,1 @@\n-    if (has_nullable_layout() && payload_layout_size_in_bytes() < nullable_layout_size_in_bytes()) {\n+    if (has_nullable_atomic_layout() && payload_layout_size_in_bytes() < nullable_layout_size_in_bytes()) {\n@@ -1388,1 +1388,1 @@\n-      if (has_nullable_layout()) {\n+      if (has_nullable_atomic_layout()) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-  bool has_nullable_layout() const             { return _nullable_layout_size_in_bytes != -1; }\n+  bool has_nullable_atomic_layout() const      { return _nullable_layout_size_in_bytes != -1; }\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,7 +31,1 @@\n-\n-JRT_LEAF(void, BarrierSetRuntime::value_copy(void* src, void* dst, InlineKlass* md))\n-  assert(md->is_inline_klass(), \"invariant\");\n-  HeapAccess<>::value_copy(src, dst, md, LayoutKind::PAYLOAD);  \/\/ FIXME Hard coded value for the transition\n-JRT_END\n-\n-JRT_LEAF(void, BarrierSetRuntime::value_copy2(void* src, void* dst, InlineLayoutInfo* li))\n+JRT_LEAF(void, BarrierSetRuntime::value_copy(void* src, void* dst, InlineLayoutInfo* li))\n@@ -41,6 +35,1 @@\n-JRT_LEAF(void, BarrierSetRuntime::value_copy_is_dest_uninitialized(void* src, void* dst, InlineKlass* md))\n-  assert(md->is_inline_klass(), \"invariant\");\n-  HeapAccess<IS_DEST_UNINITIALIZED>::value_copy(src, dst, md, LayoutKind::PAYLOAD); \/\/ FIXME Hard coded value for the transition\n-JRT_END\n-\n-JRT_LEAF(void, BarrierSetRuntime::value_copy_is_dest_uninitialized2(void* src, void* dst, InlineLayoutInfo* li))\n+JRT_LEAF(void, BarrierSetRuntime::value_copy_is_dest_uninitialized(void* src, void* dst, InlineLayoutInfo* li))\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetRuntime.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,4 +40,2 @@\n-  static void value_copy(void* src, void* dst, InlineKlass* md);\n-  static void value_copy2(void* src, void* dst, InlineLayoutInfo* layout_info);\n-  static void value_copy_is_dest_uninitialized(void* src, void* dst, InlineKlass* md);\n-  static void value_copy_is_dest_uninitialized2(void* src, void* dst, InlineLayoutInfo* layout_info);\n+  static void value_copy(void* src, void* dst, InlineLayoutInfo* layout_info);\n+  static void value_copy_is_dest_uninitialized(void* src, void* dst, InlineLayoutInfo* layout_info);\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetRuntime.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -408,1 +408,1 @@\n-  size_t typesize_in_bytes = arrayOopDesc::header_size_in_bytes();\n+  size_t typesize_in_bytes = arrayOopDesc::header_size_in_bytes(T_INT);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-  const size_t header_size_in_bytes = arrayOopDesc::header_size_in_bytes();\n+  const size_t header_size_in_bytes = arrayOopDesc::header_size_in_bytes(element_type);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1128,0 +1128,9 @@\n+JNIEXPORT jarray JNICALL\n+JVM_NewNullRestrictedAtomicArray(JNIEnv *env, jclass elmClass, jint len);\n+\n+JNIEXPORT jarray JNICALL\n+JVM_NewNullableAtomicArray(JNIEnv *env, jclass elmClass, jint len);\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_IsFlatArray(JNIEnv *env, jobject obj);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -305,1 +305,8 @@\n-  oop res = field_vklass->read_flat_field(obj_h(), entry->field_offset(), layout_info->kind(), CHECK);\n+#ifdef ASSERT\n+  fieldDescriptor fd;\n+  bool found = holder->find_field_from_offset(entry->field_offset(), false, &fd);\n+  assert(found, \"Field not found\");\n+  assert(fd.is_flat(), \"Field must be flat\");\n+#endif \/\/ ASSERT\n+\n+  oop res = field_vklass->read_payload_from_addr(obj_h(), entry->field_offset(), layout_info->kind(), CHECK);\n@@ -318,8 +325,11 @@\n-  int nm_offset = li->null_marker_offset();\n-  if (obj_h()->byte_field_acquire(nm_offset) == 0) {\n-    current->set_vm_result(nullptr);\n-  } else {\n-    InlineKlass* field_vklass = InlineKlass::cast(li->klass());\n-    oop res = field_vklass->read_flat_field(obj_h(), entry->field_offset(), LayoutKind::NULLABLE_ATOMIC_FLAT, CHECK);\n-    current->set_vm_result(res);\n-  }\n+#ifdef ASSERT\n+  fieldDescriptor fd;\n+  bool found = holder->find_field_from_offset(entry->field_offset(), false, &fd);\n+  assert(found, \"Field not found\");\n+  assert(fd.is_flat(), \"Field must be flat\");\n+#endif \/\/ ASSERT\n+\n+  InlineKlass* field_vklass = InlineKlass::cast(li->klass());\n+  oop res = field_vklass->read_payload_from_addr(obj_h(), entry->field_offset(), li->kind(), CHECK);\n+  current->set_vm_result(res);\n+\n@@ -337,23 +347,1 @@\n-  assert(li->kind() == LayoutKind::NULLABLE_ATOMIC_FLAT, \"Must be\");\n-  int nm_offset = li->null_marker_offset();\n-\n-  if (val_h() == nullptr) {\n-    if(li->klass()->nonstatic_oop_count() == 0) {\n-      \/\/ No embedded oops, just reset the null marker\n-      obj_h()->byte_field_put(nm_offset, (jbyte)0);\n-    } else {\n-      \/\/ Has embedded oops, using the reset value to rewrite all fields to null\/zeros\n-      assert(li->klass()->null_reset_value()->byte_field(vk->null_marker_offset()) == 0, \"reset value must always have a null marker set to 0\");\n-      vk->inline_copy_oop_to_payload(vk->null_reset_value(), ((char*)(oopDesc*)obj_h()) + entry->field_offset(), li->kind());\n-    }\n-    return;\n-  }\n-\n-  assert(val_h()->klass() == vk, \"Must match because flat fields are monomorphic\");\n-  \/\/ The interpreter copies values with a bulk operation\n-  \/\/ To avoid accidentally setting the null marker to \"null\" during\n-  \/\/ the copying, the null marker is set to non zero in the source object\n-  if (val_h()->byte_field(vk->null_marker_offset()) == 0) {\n-    val_h()->byte_field_put(vk->null_marker_offset(), (jbyte)1);\n-  }\n-  vk->inline_copy_oop_to_payload(val_h(), ((char*)(oopDesc*)obj_h()) + entry->field_offset(), li->kind());\n+  vk->write_value_to_addr(val_h(), ((char*)(oopDesc*)obj_h()) + entry->field_offset(), li->kind(), true, CHECK);\n@@ -374,4 +362,5 @@\n-JRT_ENTRY(void, InterpreterRuntime::value_array_load(JavaThread* current, arrayOopDesc* array, int index))\n-  flatArrayHandle vah(current, (flatArrayOop)array);\n-  oop value_holder = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);\n-  current->set_vm_result(value_holder);\n+JRT_ENTRY(void, InterpreterRuntime::flat_array_load(JavaThread* current, arrayOopDesc* array, int index))\n+  assert(array->is_flatArray(), \"Must be\");\n+  flatArrayOop farray = (flatArrayOop)array;\n+  oop res = farray->read_value_from_flat_array(index, CHECK);\n+  current->set_vm_result(res);\n@@ -380,3 +369,4 @@\n-JRT_ENTRY(void, InterpreterRuntime::value_array_store(JavaThread* current, void* val, arrayOopDesc* array, int index))\n-  assert(val != nullptr, \"can't store null into flat array\");\n-  ((flatArrayOop)array)->value_copy_to_index(cast_to_oop(val), index, LayoutKind::PAYLOAD); \/\/ Non atomic is the only layout currently supported by flat arrays\n+JRT_ENTRY(void, InterpreterRuntime::flat_array_store(JavaThread* current, oopDesc* val, arrayOopDesc* array, int index))\n+  assert(array->is_flatArray(), \"Must be\");\n+  flatArrayOop farray = (flatArrayOop)array;\n+  farray->write_value_to_flat_array(val, index, CHECK);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":29,"deletions":39,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-  static void value_array_load(JavaThread* current, arrayOopDesc* array, int index);\n-  static void value_array_store(JavaThread* current, void* val, arrayOopDesc* array, int index);\n+  static void flat_array_load(JavaThread* current, arrayOopDesc* array, int index);\n+  static void flat_array_store(JavaThread* current, oopDesc* val, arrayOopDesc* array, int index);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-arrayOop oopFactory::new_valueArray(Klass* k, int length, TRAPS) {\n+objArrayOop oopFactory::new_null_free_objArray(Klass* k, int length, TRAPS) {\n@@ -125,14 +125,23 @@\n-  \/\/ Request a flat array, but we might not actually get it...either way \"null-free\" are the aaload\/aastore semantics\n-  Klass* array_klass = klass->value_array_klass(CHECK_NULL);\n-  assert(array_klass->is_null_free_array_klass(), \"Expect a null-free array class here\");\n-\n-  arrayOop oop;\n-  if (array_klass->is_flatArray_klass()) {\n-    oop = (arrayOop) FlatArrayKlass::cast(array_klass)->allocate(length, CHECK_NULL);\n-    assert(oop == nullptr || oop->is_flatArray(), \"sanity\");\n-    assert(oop == nullptr || oop->klass()->is_flatArray_klass(), \"sanity\");\n-  } else {\n-    oop = (arrayOop) ObjArrayKlass::cast(array_klass)->allocate(length, CHECK_NULL);\n-  }\n-  assert(oop == nullptr || oop->klass()->is_null_free_array_klass(), \"sanity\");\n-  assert(oop == nullptr || oop->is_null_free_array(), \"sanity\");\n+  ObjArrayKlass* array_klass = klass->null_free_reference_array(CHECK_NULL);\n+\n+  assert(array_klass->is_objArray_klass(), \"Must be\");\n+  assert(array_klass->is_null_free_array_klass(), \"Must be\");\n+\n+  objArrayOop oop = array_klass->allocate(length, CHECK_NULL);\n+\n+  assert(oop == nullptr || oop->is_objArray(), \"Sanity\");\n+  assert(oop == nullptr || oop->klass()->is_null_free_array_klass(), \"Sanity\");\n+\n+  return oop;\n+}\n+\n+flatArrayOop oopFactory::new_flatArray(Klass* k, int length, LayoutKind lk, TRAPS) {\n+  InlineKlass* klass = InlineKlass::cast(k);\n+  Klass* array_klass = klass->flat_array_klass(lk, CHECK_NULL);\n+\n+  assert(array_klass->is_flatArray_klass(), \"Must be\");\n+\n+  flatArrayOop oop = FlatArrayKlass::cast(array_klass)->allocate(length, lk, CHECK_NULL);\n+  assert(oop == nullptr || oop->is_flatArray(), \"sanity\");\n+  assert(oop == nullptr || oop->klass()->is_flatArray_klass(), \"sanity\");\n+\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-  static arrayOop        new_valueArray(Klass* klass, int length, TRAPS);\n+  static flatArrayOop        new_flatArray(Klass* klass, int length, LayoutKind lk, TRAPS);\n+  static objArrayOop         new_null_free_objArray(Klass* klass, int length, TRAPS);\n","filename":"src\/hotspot\/share\/memory\/oopFactory.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n-    if (EnableValhalla && type == T_PRIMITIVE_OBJECT) {\n-      return true; \/\/CMH: tighten the alignment when removing T_PRIMITIVE_OBJECT\n+    if (EnableValhalla && type == T_FLAT_ELEMENT) {\n+      return true; \/\/CMH: tighten the alignment when removing T_FLAT_ELEMENT\n@@ -74,1 +74,1 @@\n-  static int header_size_in_bytes() {\n+  static int header_size_in_bytes(BasicType etype) {\n@@ -80,1 +80,1 @@\n-    assert(arrayoopdesc_hs == hs, \"header size can't change\");\n+    \/\/ assert(arrayoopdesc_hs == hs, \"header size can't change\");\n@@ -95,1 +95,1 @@\n-    int hs = header_size_in_bytes();\n+    int hs = header_size_in_bytes(type);\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/layoutKind.hpp\"\n@@ -37,9 +38,0 @@\n-enum LayoutKind {\n-  REFERENCE            = 0,    \/\/ indirection to a heap allocated instance\n-  PAYLOAD              = 1,    \/\/ layout used in heap allocated standalone instances, probably temporary for the transition\n-  NON_ATOMIC_FLAT      = 2,    \/\/ flat, no guarantee of atomic updates, no null marker\n-  ATOMIC_FLAT          = 3,    \/\/ flat, size compatible with atomic updates, alignment requirement is equal to the size\n-  NULLABLE_ATOMIC_FLAT = 4,    \/\/ flat, include a null marker, plus same properties as ATOMIC layout\n-  UNKNOWN              = 5     \/\/ used for uninitialized fields of type LayoutKind\n-};\n-\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-FlatArrayKlass::FlatArrayKlass(Klass* element_klass, Symbol* name) : ArrayKlass(name, Kind) {\n+FlatArrayKlass::FlatArrayKlass(Klass* element_klass, Symbol* name, LayoutKind lk) : ArrayKlass(name, Kind) {\n@@ -60,0 +60,1 @@\n+  assert(lk == NON_ATOMIC_FLAT || lk == ATOMIC_FLAT || lk == NULLABLE_ATOMIC_FLAT, \"Must be a flat layout\");\n@@ -63,0 +64,1 @@\n+  set_layout_kind(lk);\n@@ -64,1 +66,1 @@\n-  set_layout_helper(array_layout_helper(InlineKlass::cast(element_klass)));\n+  set_layout_helper(array_layout_helper(InlineKlass::cast(element_klass), lk));\n@@ -70,1 +72,1 @@\n-  set_prototype_header(markWord::flat_array_prototype());\n+  set_prototype_header(markWord::flat_array_prototype(lk));\n@@ -73,0 +75,1 @@\n+  fatal(\"Not supported yet\");\n@@ -76,0 +79,15 @@\n+#ifdef ASSERT\n+  switch(lk) {\n+    case NON_ATOMIC_FLAT:\n+      assert(layout_helper_is_null_free(layout_helper()), \"Must be\");\n+      assert(layout_helper_is_array(layout_helper()), \"Must be\");\n+      assert(layout_helper_is_flatArray(layout_helper()), \"Must be\");\n+      assert(layout_helper_element_type(layout_helper()) == T_FLAT_ELEMENT, \"Must be\");\n+      assert(prototype_header().is_null_free_array(), \"Must be\");\n+      assert(prototype_header().is_flat_array(), \"Must be\");\n+    break;\n+    default:\n+    break;\n+  }\n+#endif \/\/ ASSERT\n+\n@@ -83,9 +101,1 @@\n-InlineKlass* FlatArrayKlass::element_klass() const {\n-  return InlineKlass::cast(_element_klass);\n-}\n-\n-void FlatArrayKlass::set_element_klass(Klass* k) {\n-  _element_klass = k;\n-}\n-\n-FlatArrayKlass* FlatArrayKlass::allocate_klass(Klass* eklass, TRAPS) {\n+FlatArrayKlass* FlatArrayKlass::allocate_klass(Klass* eklass, LayoutKind lk, TRAPS) {\n@@ -99,6 +109,0 @@\n-  \/*\n-   *  MVT->LWorld, now need to allocate secondaries array types, just like objArrayKlass...\n-   *  ...so now we are trying out covariant array types, just copy objArrayKlass\n-   *  TODO refactor any remaining commonality\n-   *\n-   *\/\n@@ -124,1 +128,1 @@\n-  FlatArrayKlass* vak = new (loader_data, size, THREAD) FlatArrayKlass(element_klass, name);\n+  FlatArrayKlass* vak = new (loader_data, size, THREAD) FlatArrayKlass(element_klass, name, lk);\n@@ -145,1 +149,1 @@\n-flatArrayOop FlatArrayKlass::allocate(int length, TRAPS) {\n+flatArrayOop FlatArrayKlass::allocate(int length, LayoutKind lk, TRAPS) {\n@@ -148,1 +152,2 @@\n-  return (flatArrayOop) Universe::heap()->array_allocate(this, size, length, true, THREAD);\n+  flatArrayOop array = (flatArrayOop) Universe::heap()->array_allocate(this, size, length, true, CHECK_NULL);\n+  return array;\n@@ -151,1 +156,0 @@\n-\n@@ -153,4 +157,2 @@\n-  \/\/ For flatArrays this is only called for the last dimension\n-  assert(rank == 1, \"just checking\");\n-  int length = *last_size;\n-  return allocate(length, THREAD);\n+  \/\/ FlatArrays only have one dimension\n+  ShouldNotReachHere();\n@@ -159,3 +161,3 @@\n-jint FlatArrayKlass::array_layout_helper(InlineKlass* vk) {\n-  BasicType etype = T_PRIMITIVE_OBJECT;\n-  int esize = log2i_exact(round_up_power_of_2(vk->payload_size_in_bytes()));\n+jint FlatArrayKlass::array_layout_helper(InlineKlass* vk, LayoutKind lk) {\n+  BasicType etype = T_FLAT_ELEMENT;\n+  int esize = log2i_exact(round_up_power_of_2(vk->layout_size_in_bytes(lk)));\n@@ -192,1 +194,1 @@\n-  max_size -= (arrayOopDesc::base_offset_in_bytes(T_PRIMITIVE_OBJECT) >> LogHeapWordSize);\n+  max_size -= (arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT) >> LogHeapWordSize);\n@@ -219,11 +221,11 @@\n-   \/\/ Check destination\n-   if ((!d->is_flatArray()) && (!d->is_objArray())) {\n-     THROW(vmSymbols::java_lang_ArrayStoreException());\n-   }\n-\n-   \/\/ Check if all offsets and lengths are non negative\n-   if (src_pos < 0 || dst_pos < 0 || length < 0) {\n-     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());\n-   }\n-   \/\/ Check if the ranges are valid\n-   if  ( (((unsigned int) length + (unsigned int) src_pos) > (unsigned int) s->length())\n+  \/\/ Check destination\n+  if ((!d->is_flatArray()) && (!d->is_objArray())) {\n+    THROW(vmSymbols::java_lang_ArrayStoreException());\n+  }\n+\n+  \/\/ Check if all offsets and lengths are non negative\n+  if (src_pos < 0 || dst_pos < 0 || length < 0) {\n+    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());\n+  }\n+  \/\/ Check if the ranges are valid\n+  if  ( (((unsigned int) length + (unsigned int) src_pos) > (unsigned int) s->length())\n@@ -231,94 +233,108 @@\n-     THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());\n-   }\n-   \/\/ Check zero copy\n-   if (length == 0)\n-     return;\n-\n-   ArrayKlass* sk = ArrayKlass::cast(s->klass());\n-   ArrayKlass* dk = ArrayKlass::cast(d->klass());\n-   Klass* d_elem_klass = dk->element_klass();\n-   Klass* s_elem_klass = sk->element_klass();\n-   \/**** CMH: compare and contrast impl, re-factor once we find edge cases... ****\/\n-\n-   if (sk->is_flatArray_klass()) {\n-     assert(sk == this, \"Unexpected call to copy_array\");\n-     \/\/ Check subtype, all src homogeneous, so just once\n-     if (!s_elem_klass->is_subtype_of(d_elem_klass)) {\n-       THROW(vmSymbols::java_lang_ArrayStoreException());\n-     }\n-\n-     flatArrayOop sa = flatArrayOop(s);\n-     InlineKlass* s_elem_vklass = element_klass();\n-\n-     \/\/ flatArray-to-flatArray\n-     if (dk->is_flatArray_klass()) {\n-       \/\/ element types MUST be exact, subtype check would be dangerous\n-       if (dk != this) {\n-         THROW(vmSymbols::java_lang_ArrayStoreException());\n-       }\n-\n-       flatArrayOop da = flatArrayOop(d);\n-       address dst = (address) da->value_at_addr(dst_pos, layout_helper());\n-       address src = (address) sa->value_at_addr(src_pos, layout_helper());\n-       if (contains_oops()) {\n-         int elem_incr = 1 << log2_element_size();\n-         address src_end = src + (length << log2_element_size());\n-         if (needs_backwards_copy(s, src_pos, d, dst_pos, length)) {\n-           swap(src, src_end);\n-           dst = dst + (length << log2_element_size());\n-           do {\n-             src -= elem_incr;\n-             dst -= elem_incr;\n-             HeapAccess<>::value_copy(src, dst, s_elem_vklass, LayoutKind::PAYLOAD); \/\/ Temporary hack for the transition\n-           } while (src > src_end);\n-         } else {\n-           address src_end = src + (length << log2_element_size());\n-           while (src < src_end) {\n-             HeapAccess<>::value_copy(src, dst, s_elem_vklass, LayoutKind::PAYLOAD); \/\/ Temporary hack for the transition\n-             src += elem_incr;\n-             dst += elem_incr;\n-           }\n-         }\n-       } else {\n-         \/\/ we are basically a type array...don't bother limiting element copy\n-         \/\/ it would have to be a lot wasted space to be worth value_store() calls, need a setting here ?\n-         Copy::conjoint_memory_atomic(src, dst, (size_t)length << log2_element_size());\n-       }\n-     }\n-     else { \/\/ flatArray-to-objArray\n-       assert(dk->is_objArray_klass(), \"Expected objArray here\");\n-       \/\/ Need to allocate each new src elem payload -> dst oop\n-       objArrayHandle dh(THREAD, (objArrayOop)d);\n-       flatArrayHandle sh(THREAD, sa);\n-       int dst_end = dst_pos + length;\n-       while (dst_pos < dst_end) {\n-         oop o = flatArrayOopDesc::value_alloc_copy_from_index(sh, src_pos, CHECK);\n-         dh->obj_at_put(dst_pos, o);\n-         dst_pos++;\n-         src_pos++;\n-       }\n-     }\n-   } else {\n-     assert(s->is_objArray(), \"Expected objArray\");\n-     objArrayOop sa = objArrayOop(s);\n-     assert(d->is_flatArray(), \"Excepted flatArray\");  \/\/ objArray-to-flatArray\n-     InlineKlass* d_elem_vklass = InlineKlass::cast(d_elem_klass);\n-     flatArrayOop da = flatArrayOop(d);\n-\n-     int src_end = src_pos + length;\n-     int delem_incr = 1 << dk->log2_element_size();\n-     address dst = (address) da->value_at_addr(dst_pos, layout_helper());\n-     while (src_pos < src_end) {\n-       oop se = sa->obj_at(src_pos);\n-       if (se == nullptr) {\n-         THROW(vmSymbols::java_lang_NullPointerException());\n-       }\n-       \/\/ Check exact type per element\n-       if (se->klass() != d_elem_klass) {\n-         THROW(vmSymbols::java_lang_ArrayStoreException());\n-       }\n-       d_elem_vklass->inline_copy_oop_to_payload(se, dst, LayoutKind::PAYLOAD); \/\/ Temporary hack for the transition\n-       dst += delem_incr;\n-       src_pos++;\n-     }\n-   }\n+    THROW(vmSymbols::java_lang_ArrayIndexOutOfBoundsException());\n+  }\n+  \/\/ Check zero copy\n+  if (length == 0)\n+    return;\n+\n+  ArrayKlass* sk = ArrayKlass::cast(s->klass());\n+  ArrayKlass* dk = ArrayKlass::cast(d->klass());\n+  Klass* d_elem_klass = dk->element_klass();\n+  Klass* s_elem_klass = sk->element_klass();\n+  \/**** CMH: compare and contrast impl, re-factor once we find edge cases... ****\/\n+\n+  if (sk->is_flatArray_klass()) {\n+    assert(sk == this, \"Unexpected call to copy_array\");\n+    FlatArrayKlass* fsk = FlatArrayKlass::cast(sk);\n+    \/\/ Check subtype, all src homogeneous, so just once\n+    if (!s_elem_klass->is_subtype_of(d_elem_klass)) {\n+      THROW(vmSymbols::java_lang_ArrayStoreException());\n+    }\n+\n+    flatArrayOop sa = flatArrayOop(s);\n+    InlineKlass* s_elem_vklass = element_klass();\n+\n+    \/\/ flatArray-to-flatArray\n+    if (dk->is_flatArray_klass()) {\n+      \/\/ element types MUST be exact, subtype check would be dangerous\n+      if (d_elem_klass != this->element_klass()) {\n+        THROW(vmSymbols::java_lang_ArrayStoreException());\n+      }\n+\n+      FlatArrayKlass* fdk = FlatArrayKlass::cast(dk);\n+      InlineKlass* vk = InlineKlass::cast(s_elem_klass);\n+      flatArrayOop da = flatArrayOop(d);\n+      int src_incr = fsk->element_byte_size();\n+      int dst_incr = fdk->element_byte_size();\n+\n+      if (fsk->layout_kind() == fdk->layout_kind()) {\n+        assert(src_incr == dst_incr, \"Must be\");\n+        if (needs_backwards_copy(sa, src_pos, da, dst_pos, length)) {\n+          address dst = (address) da->value_at_addr(dst_pos + length - 1, fdk->layout_helper());\n+          address src = (address) sa->value_at_addr(src_pos + length - 1, fsk->layout_helper());\n+          for (int i = 0; i < length; i++) {\n+            \/\/ because source and destination have the same layout, bypassing the InlineKlass copy methods\n+            \/\/ and call AccessAPI directly\n+            HeapAccess<>::value_copy(src, dst, vk, fsk->layout_kind());\n+            dst -= dst_incr;\n+            src -= src_incr;\n+          }\n+        } else {\n+          \/\/ source and destination share same layout, direct copy from array to array is possible\n+          address dst = (address) da->value_at_addr(dst_pos, fdk->layout_helper());\n+          address src = (address) sa->value_at_addr(src_pos, fsk->layout_helper());\n+          for (int i = 0; i < length; i++) {\n+            \/\/ because source and destination have the same layout, bypassing the InlineKlass copy methods\n+            \/\/ and call AccessAPI directly\n+            HeapAccess<>::value_copy(src, dst, vk, fsk->layout_kind());\n+            dst += dst_incr;\n+            src += src_incr;\n+          }\n+        }\n+      } else {\n+        flatArrayHandle hd(THREAD, da);\n+        flatArrayHandle hs(THREAD, sa);\n+        \/\/ source and destination layouts mismatch, simpler solution is to copy through an intermediate buffer (heap instance)\n+        bool need_null_check = fsk->layout_kind() == NULLABLE_ATOMIC_FLAT && fdk->layout_kind() != NULLABLE_ATOMIC_FLAT;\n+        oop buffer = vk->allocate_instance(CHECK);\n+        address dst = (address) hd->value_at_addr(dst_pos, fdk->layout_helper());\n+        address src = (address) hs->value_at_addr(src_pos, fsk->layout_helper());\n+        for (int i = 0; i < length; i++) {\n+          if (need_null_check) {\n+            if ( *(jboolean*)(src + vk->null_marker_offset_in_payload()) == 0) {\n+              THROW(vmSymbols::java_lang_NullPointerException());\n+            }\n+          }\n+          vk->copy_payload_to_addr(src, vk->data_for_oop(buffer), fsk->layout_kind(), true);\n+          if (vk->has_nullable_atomic_layout()) {\n+            \/\/ Setting null marker to not zero for non-nullable source layouts\n+            vk->mark_payload_as_non_null(vk->data_for_oop(buffer));\n+          }\n+          vk->copy_payload_to_addr(vk->data_for_oop(buffer), dst, fdk->layout_kind(), true);\n+          dst += dst_incr;\n+          src += src_incr;\n+        }\n+      }\n+    } else { \/\/ flatArray-to-objArray\n+      assert(dk->is_objArray_klass(), \"Expected objArray here\");\n+      \/\/ Need to allocate each new src elem payload -> dst oop\n+      objArrayHandle dh(THREAD, (objArrayOop)d);\n+      flatArrayHandle sh(THREAD, sa);\n+      InlineKlass* vk = InlineKlass::cast(s_elem_klass);\n+      for (int i = 0; i < length; i++) {\n+        oop o = sh->read_value_from_flat_array(src_pos + i, CHECK);\n+        dh->obj_at_put(dst_pos + i, o);\n+      }\n+    }\n+  } else {\n+    assert(s->is_objArray(), \"Expected objArray\");\n+    objArrayOop sa = objArrayOop(s);\n+    assert(d->is_flatArray(), \"Expected flatArray\");  \/\/ objArray-to-flatArray\n+    InlineKlass* d_elem_vklass = InlineKlass::cast(d_elem_klass);\n+    flatArrayOop da = flatArrayOop(d);\n+    FlatArrayKlass* fdk = FlatArrayKlass::cast(da->klass());\n+    InlineKlass* vk = InlineKlass::cast(d_elem_klass);\n+\n+    for (int i = 0; i < length; i++) {\n+      da->write_value_to_flat_array(sa->obj_at(src_pos + i), dst_pos + i, CHECK);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":151,"deletions":135,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -44,1 +44,3 @@\n-  FlatArrayKlass(Klass* element_klass, Symbol* name);\n+  FlatArrayKlass(Klass* element_klass, Symbol* name, LayoutKind lk);\n+\n+  LayoutKind _layout_kind;\n@@ -48,1 +50,4 @@\n-  FlatArrayKlass() {}\n+  FlatArrayKlass() {} \/\/ Why?\n+\n+  InlineKlass* element_klass() const { return InlineKlass::cast(_element_klass); }\n+  void set_element_klass(Klass* k) { _element_klass = k; }\n@@ -50,2 +55,2 @@\n-  virtual InlineKlass* element_klass() const;\n-  virtual void set_element_klass(Klass* k);\n+  LayoutKind layout_kind() const  { return _layout_kind; }\n+  void set_layout_kind(LayoutKind lk) { _layout_kind = lk; }\n@@ -60,1 +65,1 @@\n-  static FlatArrayKlass* allocate_klass(Klass* element_klass, TRAPS);\n+  static FlatArrayKlass* allocate_klass(Klass* element_klass, LayoutKind lk, TRAPS);\n@@ -88,1 +93,1 @@\n-  static jint array_layout_helper(InlineKlass* vklass); \/\/ layout helper for values\n+  static jint array_layout_helper(InlineKlass* vklass, LayoutKind lk); \/\/ layout helper for values\n@@ -99,1 +104,1 @@\n-  flatArrayOop allocate(int length, TRAPS);\n+  flatArrayOop allocate(int length, LayoutKind lk, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.hpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -42,4 +42,2 @@\n-  \/\/ Return a buffered element from index\n-  static oop value_alloc_copy_from_index(flatArrayHandle vah, int index, TRAPS);\n-  void value_copy_from_index(int index, oop dst, LayoutKind lk) const;\n-  void value_copy_to_index(oop src, int index, LayoutKind lk) const;\n+  inline oop read_value_from_flat_array( int index, TRAPS);\n+  inline void write_value_to_flat_array(oop value, int index, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -34,1 +35,1 @@\n-inline void* flatArrayOopDesc::base() const { return arrayOopDesc::base(T_PRIMITIVE_OBJECT); }\n+inline void* flatArrayOopDesc::base() const { return arrayOopDesc::base(T_FLAT_ELEMENT); }\n@@ -48,19 +49,7 @@\n-inline oop flatArrayOopDesc::value_alloc_copy_from_index(flatArrayHandle vah, int index, TRAPS) {\n-  FlatArrayKlass* vaklass = FlatArrayKlass::cast(vah->klass());\n-  InlineKlass* vklass = vaklass->element_klass();\n-  assert(vklass->is_initialized(), \"Should be\");\n-  if (vklass->is_empty_inline_type()) {\n-    return vklass->default_value();\n-  } else {\n-    oop buf = vklass->allocate_instance_buffer(CHECK_NULL);\n-    vklass->inline_copy_payload_to_new_oop(vah->value_at_addr(index, vaklass->layout_helper()),\n-                                           buf, LayoutKind::PAYLOAD); \/\/ temporary hack for the transition\n-    return buf;\n-  }\n-}\n-\n-inline void flatArrayOopDesc::value_copy_from_index(int index, oop dst, LayoutKind lk) const {\n-  FlatArrayKlass* vaklass = FlatArrayKlass::cast(klass());\n-  InlineKlass* vklass = vaklass->element_klass();\n-  void* src = value_at_addr(index, vaklass->layout_helper());\n-  return vklass->inline_copy_payload_to_new_oop(src, dst, lk);\n+inline oop flatArrayOopDesc::read_value_from_flat_array(int index, TRAPS) {\n+  \/\/ This method assumes that the validity of the index has already been checked\n+  FlatArrayKlass* faklass = FlatArrayKlass::cast(klass());\n+  InlineKlass* vk = InlineKlass::cast(faklass->element_klass());\n+  int offset = ((char*)value_at_addr(index, faklass->layout_helper())) - ((char*)(oopDesc*)this);\n+  oop res = vk->read_payload_from_addr(this, offset, faklass->layout_kind(), CHECK_NULL);\n+  return res;\n@@ -69,5 +58,8 @@\n-inline void flatArrayOopDesc::value_copy_to_index(oop src, int index, LayoutKind lk) const {\n-  FlatArrayKlass* vaklass = FlatArrayKlass::cast(klass());\n-  InlineKlass* vklass = vaklass->element_klass();\n-  if (vklass->is_empty_inline_type()) {\n-    return;\n+inline void flatArrayOopDesc::write_value_to_flat_array(oop value, int index, TRAPS) {\n+  \/\/ This method assumes that the validity of the index has already been checked\n+  FlatArrayKlass* faklass = FlatArrayKlass::cast(klass());\n+  InlineKlass* vk = InlineKlass::cast(faklass->element_klass());\n+  if (value != nullptr) {\n+    if (value->klass() != vk) {\n+      THROW(vmSymbols::java_lang_ArrayStoreException());\n+    }\n@@ -75,2 +67,1 @@\n-  void* dst = value_at_addr(index, vaklass->layout_helper());\n-  vklass->inline_copy_oop_to_payload(src, dst, lk);\n+  vk->write_value_to_addr(value, value_at_addr(index, faklass->layout_helper()), faklass->layout_kind(), true, CHECK);\n@@ -79,2 +70,0 @@\n-\n-\n","filename":"src\/hotspot\/share\/oops\/flatArrayOop.inline.hpp","additions":18,"deletions":29,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -75,1 +75,4 @@\n-  *((address*)adr_value_array_klasses()) = nullptr;\n+  *((address*)adr_non_atomic_flat_array_klass()) = nullptr;\n+  *((address*)adr_atomic_flat_array_klass()) = nullptr;\n+  *((address*)adr_nullable_atomic_flat_array_klass()) = nullptr;\n+  *((address*)adr_null_free_reference_array_klass()) = nullptr;\n@@ -143,2 +146,2 @@\n-      assert(has_nullable_layout(), \"Layout not available\");\n-      return nullable_size_in_bytes();\n+      assert(has_nullable_atomic_layout(), \"Layout not available\");\n+      return nullable_atomic_size_in_bytes();\n@@ -165,2 +168,2 @@\n-      assert(has_nullable_layout(), \"Layout not available\");\n-      return nullable_size_in_bytes();\n+      assert(has_nullable_atomic_layout(), \"Layout not available\");\n+      return nullable_atomic_size_in_bytes();\n@@ -176,1 +179,18 @@\n-oop InlineKlass::read_flat_field(oop obj, int offset, LayoutKind lk, TRAPS) {\n+bool InlineKlass::is_layout_supported(LayoutKind lk) {\n+  switch(lk) {\n+    case LayoutKind::NON_ATOMIC_FLAT:\n+      return has_non_atomic_layout();\n+      break;\n+    case LayoutKind::ATOMIC_FLAT:\n+      return has_atomic_layout();\n+      break;\n+    case LayoutKind::NULLABLE_ATOMIC_FLAT:\n+      return has_nullable_atomic_layout();\n+      break;\n+    case LayoutKind::PAYLOAD:\n+      return true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n@@ -178,6 +198,25 @@\n-  if (lk == LayoutKind::NULLABLE_ATOMIC_FLAT) {\n-    InstanceKlass* recv = InstanceKlass::cast(obj->klass());\n-    int nm_offset = offset + (null_marker_offset() - first_field_offset());\n-    jbyte nm = obj->byte_field(nm_offset);\n-    if (nm == 0) {\n-      return nullptr;\n+void InlineKlass::copy_payload_to_addr(void* src, void* dst, LayoutKind lk, bool dest_is_initialized) {\n+  assert(is_layout_supported(lk), \"Unsupported layout\");\n+  assert(lk != LayoutKind::REFERENCE && lk != LayoutKind::UNKNOWN, \"Sanity check\");\n+  switch(lk) {\n+    case NULLABLE_ATOMIC_FLAT: {\n+    if (is_payload_marked_as_null((address)src)) {\n+        if (!contains_oops()) {\n+          mark_payload_as_null((address)dst);\n+          return;\n+        }\n+        \/\/ copy null_reset value to dest\n+        if (dest_is_initialized) {\n+          HeapAccess<>::value_copy(data_for_oop(null_reset_value()), dst, this, lk);\n+        } else {\n+          HeapAccess<IS_DEST_UNINITIALIZED>::value_copy(data_for_oop(null_reset_value()), dst, this, lk);\n+        }\n+      } else {\n+        \/\/ Copy has to be performed, even if this is an empty value, because of the null marker\n+        mark_payload_as_non_null((address)src);\n+        if (dest_is_initialized) {\n+          HeapAccess<>::value_copy(src, dst, this, lk);\n+        } else {\n+          HeapAccess<IS_DEST_UNINITIALIZED>::value_copy(src, dst, this, lk);\n+        }\n+      }\n@@ -185,0 +224,14 @@\n+    break;\n+    case PAYLOAD:\n+    case ATOMIC_FLAT:\n+    case NON_ATOMIC_FLAT: {\n+      if (is_empty_inline_type()) return; \/\/ nothing to do\n+      if (dest_is_initialized) {\n+        HeapAccess<>::value_copy(src, dst, this, lk);\n+      } else {\n+        HeapAccess<IS_DEST_UNINITIALIZED>::value_copy(src, dst, this, lk);\n+      }\n+    }\n+    break;\n+    default:\n+      ShouldNotReachHere();\n@@ -186,9 +239,30 @@\n-  oop res = nullptr;\n-  assert(is_initialized() || is_being_initialized()|| is_in_error_state(),\n-        \"Must be initialized, initializing or in a corner case of an escaped instance of a class that failed its initialization\");\n-  if (is_empty_inline_type()) {\n-    res = (instanceOop)default_value();\n-  } else {\n-    Handle obj_h(THREAD, obj);\n-    res = allocate_instance_buffer(CHECK_NULL);\n-    inline_copy_payload_to_new_oop(((char*)(oopDesc*)obj_h()) + offset, res, lk);\n+}\n+\n+oop InlineKlass::read_payload_from_addr(oop src, int offset, LayoutKind lk, TRAPS) {\n+  assert(src != nullptr, \"Must be\");\n+  assert(is_layout_supported(lk), \"Unsupported layout\");\n+  switch(lk) {\n+    case NULLABLE_ATOMIC_FLAT: {\n+      if (is_payload_marked_as_null((address)((char*)(oopDesc*)src + offset))) {\n+        return nullptr;\n+      }\n+    } \/\/ Fallthrough\n+    case PAYLOAD:\n+    case ATOMIC_FLAT:\n+    case NON_ATOMIC_FLAT: {\n+      if (is_empty_inline_type()) {\n+        return default_value();\n+      }\n+      Handle obj_h(THREAD, src);\n+      oop res = allocate_instance_buffer(CHECK_NULL);\n+      copy_payload_to_addr((void*)((char*)(oopDesc*)obj_h() + offset), data_for_oop(res), lk, false);\n+      if (lk == NULLABLE_ATOMIC_FLAT) {\n+        if(is_payload_marked_as_null(data_for_oop(res))) {\n+          return nullptr;\n+        }\n+      }\n+      return res;\n+    }\n+    break;\n+    default:\n+      ShouldNotReachHere();\n@@ -196,2 +270,0 @@\n-  assert(res != nullptr, \"Must be set in one of two paths above\");\n-  return res;\n@@ -200,3 +272,12 @@\n-void InlineKlass::write_flat_field(oop obj, int offset, oop value, bool is_null_free, LayoutKind lk, TRAPS) {\n-  if (is_null_free && value == nullptr) {\n-    THROW(vmSymbols::java_lang_NullPointerException());\n+void InlineKlass::write_value_to_addr(oop src, void* dst, LayoutKind lk, bool dest_is_initialized, TRAPS) {\n+  void* src_addr = nullptr;\n+  if (src == nullptr) {\n+    if (lk != NULLABLE_ATOMIC_FLAT) {\n+      THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Value is null\");\n+    }\n+    src_addr = data_for_oop(null_reset_value());\n+  } else {\n+    src_addr = data_for_oop(src);\n+    if (lk == NULLABLE_ATOMIC_FLAT) {\n+      mark_payload_as_non_null((address)src_addr);\n+    }\n@@ -204,2 +285,1 @@\n-  assert(!is_null_free || (lk == LayoutKind::ATOMIC_FLAT || lk == LayoutKind::NON_ATOMIC_FLAT || lk == LayoutKind::REFERENCE || lk == LayoutKind::PAYLOAD), \"Consistency check\");\n-  inline_copy_oop_to_payload(value, ((char*)(oopDesc*)obj) + offset, lk);\n+  copy_payload_to_addr(src_addr, dst, lk, dest_is_initialized);\n@@ -234,2 +314,2 @@\n-Klass* InlineKlass::value_array_klass(int n, TRAPS) {\n-  if (Atomic::load_acquire(adr_value_array_klasses()) == nullptr) {\n+ObjArrayKlass* InlineKlass::null_free_reference_array(TRAPS) {\n+  if (Atomic::load_acquire(adr_null_free_reference_array_klass()) == nullptr) {\n@@ -240,6 +320,2 @@\n-    if (value_array_klasses() == nullptr) {\n-      ArrayKlass* k;\n-      if (flat_array()) {\n-        k = FlatArrayKlass::allocate_klass(this, CHECK_NULL);\n-      } else {\n-        k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, CHECK_NULL);\n+    if (null_free_reference_array_klass() == nullptr) {\n+      ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, true, CHECK_NULL);\n@@ -247,1 +323,0 @@\n-      }\n@@ -249,1 +324,1 @@\n-      Atomic::release_store(adr_value_array_klasses(), k);\n+      Atomic::release_store(adr_null_free_reference_array_klass(), k);\n@@ -252,2 +327,1 @@\n-  ArrayKlass* ak = value_array_klasses();\n-  return ak->array_klass(n, THREAD);\n+  return null_free_reference_array_klass();\n@@ -256,7 +330,19 @@\n-Klass* InlineKlass::value_array_klass_or_null(int n) {\n-  \/\/ Need load-acquire for lock-free read\n-  ArrayKlass* ak = Atomic::load_acquire(adr_value_array_klasses());\n-  if (ak == nullptr) {\n-    return nullptr;\n-  } else {\n-    return ak->array_klass_or_null(n);\n+\n+\/\/ There's no reason for this method to have a TRAP argument\n+FlatArrayKlass* InlineKlass::flat_array_klass(LayoutKind lk, TRAPS) {\n+  FlatArrayKlass* volatile* adr_flat_array_klass = nullptr;\n+  switch(lk) {\n+    case NON_ATOMIC_FLAT:\n+      assert(has_non_atomic_layout(), \"Must be\");\n+      adr_flat_array_klass = adr_non_atomic_flat_array_klass();\n+      break;\n+    case ATOMIC_FLAT:\n+    assert(has_atomic_layout(), \"Must be\");\n+      adr_flat_array_klass = adr_atomic_flat_array_klass();\n+      break;\n+    case NULLABLE_ATOMIC_FLAT:\n+      assert(has_nullable_atomic_layout(), \"Must be\");\n+      adr_flat_array_klass = adr_nullable_atomic_flat_array_klass();\n+      break;\n+    default:\n+      ShouldNotReachHere();\n@@ -264,1 +350,0 @@\n-}\n@@ -266,2 +351,10 @@\n-Klass* InlineKlass::value_array_klass(TRAPS) {\n-  return value_array_klass(1, THREAD);\n+  if (Atomic::load_acquire(adr_flat_array_klass) == nullptr) {\n+    \/\/ Atomic creation of array_klasses\n+    RecursiveLocker rl(MultiArray_lock, THREAD);\n+\n+    if (*adr_flat_array_klass == nullptr) {\n+      FlatArrayKlass* k = FlatArrayKlass::allocate_klass(this, lk, CHECK_NULL);\n+      Atomic::release_store(adr_flat_array_klass, k);\n+    }\n+  }\n+  return *adr_flat_array_klass;\n@@ -270,2 +363,22 @@\n-Klass* InlineKlass::value_array_klass_or_null() {\n-  return value_array_klass_or_null(1);\n+FlatArrayKlass* InlineKlass::flat_array_klass_or_null(LayoutKind lk) {\n+    FlatArrayKlass* volatile* adr_flat_array_klass = nullptr;\n+  switch(lk) {\n+    case NON_ATOMIC_FLAT:\n+      assert(has_non_atomic_layout(), \"Must be\");\n+      adr_flat_array_klass = adr_non_atomic_flat_array_klass();\n+      break;\n+    case ATOMIC_FLAT:\n+    assert(has_atomic_layout(), \"Must be\");\n+      adr_flat_array_klass = adr_atomic_flat_array_klass();\n+      break;\n+    case NULLABLE_ATOMIC_FLAT:\n+      assert(has_nullable_atomic_layout(), \"Must be\");\n+      adr_flat_array_klass = adr_nullable_atomic_flat_array_klass();\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  \/\/ Need load-acquire for lock-free read\n+  FlatArrayKlass* k = Atomic::load_acquire(adr_flat_array_klass);\n+  return k;\n@@ -570,1 +683,4 @@\n-  it->push((Klass**)adr_value_array_klasses());\n+  it->push((Klass**)adr_non_atomic_flat_array_klass());\n+  it->push((Klass**)adr_atomic_flat_array_klass());\n+  it->push((Klass**)adr_nullable_atomic_flat_array_klass());\n+  it->push((Klass**)adr_null_free_reference_array_klass());\n@@ -586,2 +702,11 @@\n-  if (value_array_klasses() != nullptr) {\n-    value_array_klasses()->remove_unshareable_info();\n+  if (non_atomic_flat_array_klass() != nullptr) {\n+    non_atomic_flat_array_klass()->remove_unshareable_info();\n+  }\n+  if (atomic_flat_array_klass() != nullptr) {\n+    atomic_flat_array_klass()->remove_unshareable_info();\n+  }\n+  if (nullable_atomic_flat_array_klass() != nullptr) {\n+    nullable_atomic_flat_array_klass()->remove_unshareable_info();\n+  }\n+  if (null_free_reference_array_klass() != nullptr) {\n+    null_free_reference_array_klass()->remove_unshareable_info();\n@@ -593,2 +718,11 @@\n-  if (value_array_klasses() != nullptr) {\n-    value_array_klasses()->remove_java_mirror();\n+  if (non_atomic_flat_array_klass() != nullptr) {\n+    non_atomic_flat_array_klass()->remove_java_mirror();\n+  }\n+  if (atomic_flat_array_klass() != nullptr) {\n+    atomic_flat_array_klass()->remove_java_mirror();\n+  }\n+  if (nullable_atomic_flat_array_klass() != nullptr) {\n+    nullable_atomic_flat_array_klass()->remove_java_mirror();\n+  }\n+  if (null_free_reference_array_klass() != nullptr) {\n+    null_free_reference_array_klass()->remove_java_mirror();\n@@ -600,2 +734,11 @@\n-  if (value_array_klasses() != nullptr) {\n-    value_array_klasses()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);\n+  if (non_atomic_flat_array_klass() != nullptr) {\n+    non_atomic_flat_array_klass()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);\n+  }\n+  if (atomic_flat_array_klass() != nullptr) {\n+    atomic_flat_array_klass()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);\n+  }\n+  if (nullable_atomic_flat_array_klass() != nullptr) {\n+    nullable_atomic_flat_array_klass()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);\n+  }\n+  if (null_free_reference_array_klass() != nullptr) {\n+    null_free_reference_array_klass()->restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":202,"deletions":59,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  ArrayKlass* volatile* adr_value_array_klasses() const {\n+  FlatArrayKlass* volatile* adr_non_atomic_flat_array_klass() const {\n@@ -90,1 +90,1 @@\n-    return (ArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _null_free_inline_array_klasses));\n+    return (FlatArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _non_atomic_flat_array_klass));\n@@ -93,2 +93,29 @@\n-  ArrayKlass* value_array_klasses() const {\n-    return *adr_value_array_klasses();\n+  FlatArrayKlass* non_atomic_flat_array_klass() const {\n+    return *adr_non_atomic_flat_array_klass();\n+  }\n+\n+  FlatArrayKlass* volatile* adr_atomic_flat_array_klass() const {\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n+    return (FlatArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _atomic_flat_array_klass));\n+  }\n+\n+  FlatArrayKlass* atomic_flat_array_klass() const {\n+    return *adr_atomic_flat_array_klass();\n+  }\n+\n+  FlatArrayKlass* volatile* adr_nullable_atomic_flat_array_klass() const {\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n+    return (FlatArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _nullable_atomic_flat_array_klass));\n+  }\n+\n+  FlatArrayKlass* nullable_atomic_flat_array_klass() const {\n+    return *adr_nullable_atomic_flat_array_klass();\n+  }\n+\n+  ObjArrayKlass* volatile* adr_null_free_reference_array_klass() const {\n+    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n+    return (ObjArrayKlass* volatile*) ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _null_free_reference_array_klass));\n+  }\n+\n+  ObjArrayKlass* null_free_reference_array_klass() const {\n+    return *adr_null_free_reference_array_klass();\n@@ -127,1 +154,1 @@\n-  address adr_nullable_size_in_bytes() const {\n+  address adr_nullable_atomic_size_in_bytes() const {\n@@ -166,3 +193,3 @@\n-  bool has_nullable_layout() const { return nullable_size_in_bytes() != -1; }\n-  int nullable_size_in_bytes() const { return *(int*)adr_nullable_size_in_bytes(); }\n-  void set_nullable_size_in_bytes(int size) { *(int*)adr_nullable_size_in_bytes() = size; }\n+  bool has_nullable_atomic_layout() const { return nullable_atomic_size_in_bytes() != -1; }\n+  int nullable_atomic_size_in_bytes() const { return *(int*)adr_nullable_atomic_size_in_bytes(); }\n+  void set_nullable_size_in_bytes(int size) { *(int*)adr_nullable_atomic_size_in_bytes() = size; }\n@@ -170,0 +197,1 @@\n+  int null_marker_offset_in_payload() const { return null_marker_offset() - first_field_offset(); }\n@@ -172,0 +200,17 @@\n+  bool is_payload_marked_as_null(address payload) {\n+    assert(has_nullable_atomic_layout(), \" Must have\");\n+    return *((jbyte*)payload + null_marker_offset_in_payload()) == 0;\n+  }\n+\n+  void mark_payload_as_non_null(address payload) {\n+    assert(has_nullable_atomic_layout(), \" Must have\");\n+    *((jbyte*)payload + null_marker_offset_in_payload()) = 1;\n+  }\n+\n+  void mark_payload_as_null(address payload) {\n+    assert(has_nullable_atomic_layout(), \" Must have\");\n+    *((jbyte*)payload + null_marker_offset_in_payload()) = 0;\n+  }\n+\n+  bool is_layout_supported(LayoutKind lk);\n+\n@@ -225,16 +270,3 @@\n-  \/\/ null free inline array klass, akin to InstanceKlass::array_klass()\n-  \/\/ Returns the array class for the n'th dimension\n-  Klass* value_array_klass(int n, TRAPS);\n-  Klass* value_array_klass_or_null(int n);\n-\n-  \/\/ Returns the array class with this class as element type\n-  Klass* value_array_klass(TRAPS);\n-  Klass* value_array_klass_or_null();\n-\n-\n-  \/\/ General store methods\n-  \/\/\n-  \/\/ Normally loads and store methods would be found in *Oops classes, but since values can be\n-  \/\/ \"in-lined\" (flat layout) into containing oops, these methods reside here in InlineKlass.\n-  \/\/\n-  \/\/ \"inline_copy_*_to_new_*\" assume new memory (i.e. IS_DEST_UNINITIALIZED for write barriers)\n+  FlatArrayKlass* flat_array_klass(LayoutKind lk, TRAPS);\n+  FlatArrayKlass* flat_array_klass_or_null(LayoutKind lk);\n+  ObjArrayKlass* null_free_reference_array(TRAPS);\n@@ -242,4 +274,5 @@\n-  void inline_copy_payload_to_new_oop(void* src, oop dst, LayoutKind lk);\n-  void inline_copy_oop_to_new_oop(oop src, oop dst, LayoutKind lk);\n-  void inline_copy_oop_to_new_payload(oop src, void* dst, LayoutKind lk);\n-  void inline_copy_oop_to_payload(oop src, void* dst, LayoutKind lk);\n+  \/\/ Methods to copy payload between containers\n+  \/\/ Methods taking a LayoutKind argument expect that both the source and the destination\n+  \/\/ layouts are compatible with the one specified in argument (alignment, size, presence\n+  \/\/ of a null marker). Reminder: the PAYLOAD layout, used in values buffered in heap,\n+  \/\/ is compatible with all the other layouts.\n@@ -247,2 +280,3 @@\n-  oop read_flat_field(oop obj, int offset, LayoutKind lk, TRAPS);\n-  void write_flat_field(oop obj, int offset, oop value, bool is_null_free, LayoutKind lk, TRAPS);\n+  void write_value_to_addr(oop src, void* dst, LayoutKind lk, bool dest_is_initialized, TRAPS);\n+  oop read_payload_from_addr(oop src, int offset, LayoutKind lk, TRAPS);\n+  void copy_payload_to_addr(void* src, void* dst, LayoutKind lk, bool dest_is_initialized);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":64,"deletions":30,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -58,17 +58,0 @@\n-inline void InlineKlass::inline_copy_payload_to_new_oop(void* src, oop dst, LayoutKind lk) {\n-  HeapAccess<IS_DEST_UNINITIALIZED>::value_copy(src, data_for_oop(dst), this, lk);\n-}\n-\n-inline void InlineKlass::inline_copy_oop_to_new_oop(oop src, oop dst, LayoutKind lk) {\n-  HeapAccess<IS_DEST_UNINITIALIZED>::value_copy(data_for_oop(src), data_for_oop(dst), this, lk);\n-}\n-\n-inline void InlineKlass::inline_copy_oop_to_new_payload(oop src, void* dst, LayoutKind lk) {\n-  HeapAccess<IS_DEST_UNINITIALIZED>::value_copy(data_for_oop(src), dst, this, lk);\n-}\n-\n-inline void InlineKlass::inline_copy_oop_to_payload(oop src, void* dst, LayoutKind lk) {\n-  HeapAccess<>::value_copy(data_for_oop(src), dst, this, lk);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.inline.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1360,1 +1360,1 @@\n-      if (vk->has_nullable_layout()) {\n+      if (vk->has_nullable_atomic_layout()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,1 +149,4 @@\n-  ArrayKlass** _null_free_inline_array_klasses;\n+  FlatArrayKlass* _non_atomic_flat_array_klass;\n+  FlatArrayKlass* _atomic_flat_array_klass;\n+  FlatArrayKlass* _nullable_atomic_flat_array_klass;\n+  ObjArrayKlass* _null_free_reference_array_klass;\n@@ -157,1 +160,2 @@\n-  int _null_marker_offset;\n+  int _null_marker_offset;      \/\/ expressed as an offset from the beginning of the object for a heap buffered value\n+                                \/\/ first_field_offset must be subtracted to get the offset from the beginning of the payload\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -502,1 +502,1 @@\n-    assert((btvalue >= T_BOOLEAN && btvalue <= T_OBJECT) || btvalue == T_PRIMITIVE_OBJECT, \"sanity\");\n+    assert((btvalue >= T_BOOLEAN && btvalue <= T_OBJECT) || btvalue == T_FLAT_ELEMENT, \"sanity\");\n@@ -523,1 +523,1 @@\n-    assert(layout_helper_element_type(lh) == T_PRIMITIVE_OBJECT || l2esz <= LogBytesPerLong,\n+    assert(layout_helper_element_type(lh) == T_FLAT_ELEMENT || l2esz <= LogBytesPerLong,\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_LAYOUTKIND_HPP\n+#define SHARE_OOPS_LAYOUTKIND_HPP\n+\n+enum LayoutKind {\n+  REFERENCE            = 0,    \/\/ indirection to a heap allocated instance\n+  PAYLOAD              = 1,    \/\/ layout used in heap allocated standalone instances, probably temporary for the transition\n+  NON_ATOMIC_FLAT      = 2,    \/\/ flat, no guarantee of atomic updates, no null marker\n+  ATOMIC_FLAT          = 3,    \/\/ flat, size compatible with atomic updates, alignment requirement is equal to the size\n+  NULLABLE_ATOMIC_FLAT = 4,    \/\/ flat, include a null marker, plus same properties as ATOMIC layout\n+  UNKNOWN              = 5     \/\/ used for uninitialized fields of type LayoutKind\n+};\n+\n+#endif \/\/ SHARE_OOPS_LAYOUTKIND_HPP\n","filename":"src\/hotspot\/share\/oops\/layoutKind.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -97,0 +97,14 @@\n+\n+markWord markWord::flat_array_prototype(LayoutKind lk) {\n+  switch(lk) {\n+    case ATOMIC_FLAT:\n+    case NON_ATOMIC_FLAT:\n+      return markWord(null_free_flat_array_pattern);\n+      break;\n+    case NULLABLE_ATOMIC_FLAT:\n+      return markWord(nullable_flat_array_pattern);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"layoutKind.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"utilities\/vmEnums.hpp\"\n@@ -221,1 +223,3 @@\n-  static const uintptr_t flat_array_pattern       = flat_array_bit_in_place | null_free_array_pattern;\n+  static const uintptr_t null_free_flat_array_pattern = flat_array_bit_in_place | null_free_array_pattern;\n+  static const uintptr_t nullable_flat_array_pattern = flat_array_bit_in_place;\n+\n@@ -385,1 +389,2 @@\n-    return (mask_bits(value(), flat_array_mask_in_place) == flat_array_pattern);\n+    return (mask_bits(value(), flat_array_mask_in_place) == null_free_flat_array_pattern)\n+           || (mask_bits(value(), flat_array_mask_in_place) == nullable_flat_array_pattern);\n@@ -412,3 +417,1 @@\n-  static markWord flat_array_prototype() {\n-    return markWord(flat_array_pattern);\n-  }\n+  static markWord flat_array_prototype(LayoutKind lk);\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-    assert(!InlineKlass::cast(element_klass())->flat_array(), \"Expected flatArrayOop allocation\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -308,5 +308,15 @@\n-          make_runtime_call(RC_LEAF,\n-                            OptoRuntime::store_unknown_inline_Type(),\n-                            CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_inline_C),\n-                            \"store_unknown_inline\", TypeRawPtr::BOTTOM,\n-                            val, casted_ary, idx);\n+          Node* call = nullptr;\n+          {\n+            \/\/ Re-execute flat array store if runtime call triggers deoptimization\n+            PreserveReexecuteState preexecs(this);\n+            jvms()->set_bci(_bci);\n+            jvms()->set_should_reexecute(true);\n+            inc_sp(3);\n+            kill_dead_locals();\n+            call = make_runtime_call(RC_NO_LEAF,\n+                              OptoRuntime::store_unknown_inline_Type(),\n+                              OptoRuntime::store_unknown_inline_Java(),\n+                              \"store_unknown_inline\", TypeRawPtr::BOTTOM,\n+                              val, casted_ary, idx);\n+          }\n+          make_slow_call_ex(call, env()->Throwable_klass(), false);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -302,2 +302,4 @@\n-    Klass* elem_type = FlatArrayKlass::cast(array_type)->element_klass();\n-    result = oopFactory::new_valueArray(elem_type, len, THREAD);\n+    Handle holder(current, array_type->klass_holder()); \/\/ keep the array klass alive\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(array_type);\n+    Klass* elem_type = fak->element_klass();\n+    result = oopFactory::new_flatArray(elem_type, len, fak->layout_kind(), THREAD);\n@@ -2042,2 +2044,1 @@\n-  flatArrayHandle vah(current, array);\n-  oop buffer = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, THREAD);\n+  oop buffer = array->read_value_from_flat_array(index, THREAD);\n@@ -2066,2 +2067,2 @@\n-JRT_LEAF(void, OptoRuntime::store_unknown_inline_C(instanceOopDesc* buffer, flatArrayOopDesc* array, int index))\n-{\n+JRT_BLOCK_ENTRY(void, OptoRuntime::store_unknown_inline_C(instanceOopDesc* buffer, flatArrayOopDesc* array, int index, JavaThread* current))\n+  JRT_BLOCK;\n@@ -2069,2 +2070,5 @@\n-  array->value_copy_to_index(buffer, index, LayoutKind::PAYLOAD); \/\/ Temporary hack for the transition\n-}\n+  array->write_value_to_flat_array(buffer, index, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+      fatal(\"This entry must be changed to be a non-leaf entry because writing to a flat array can now throw an exception\");\n+  }\n+  JRT_BLOCK_END;\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-  static void store_unknown_inline_C(instanceOopDesc* buffer, flatArrayOopDesc* array, int index);\n+  static void store_unknown_inline_C(instanceOopDesc* buffer, flatArrayOopDesc* array, int index, JavaThread* current);\n@@ -229,0 +229,1 @@\n+  static address store_unknown_inline_Java()             { return _store_unknown_inline_Java; }\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -662,1 +662,1 @@\n-  TypeAryPtr::_array_body_type[T_PRIMITIVE_OBJECT] = TypeAryPtr::OOPS;\n+  TypeAryPtr::_array_body_type[T_FLAT_ELEMENT] = TypeAryPtr::OOPS;\n@@ -713,1 +713,1 @@\n-  _const_basic_type[T_PRIMITIVE_OBJECT] = TypeInstPtr::BOTTOM;\n+  _const_basic_type[T_FLAT_ELEMENT] = TypeInstPtr::BOTTOM;\n@@ -730,1 +730,1 @@\n-  _zero_type[T_PRIMITIVE_OBJECT] = TypePtr::NULL_PTR;\n+  _zero_type[T_FLAT_ELEMENT] = TypePtr::NULL_PTR;\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -851,1 +851,1 @@\n-    case T_PRIMITIVE_OBJECT: push_object((_ap++)->l); break;\n+    case T_FLAT_ELEMENT: push_object((_ap++)->l); break;\n@@ -1838,1 +1838,2 @@\n-    ik->find_field_from_offset(offset, false, &fd);  \/\/ performance bottleneck\n+    bool found = ik->find_field_from_offset(offset, false, &fd);  \/\/ performance bottleneck\n+    assert(found, \"Field not found\");\n@@ -1840,0 +1841,1 @@\n+    assert(holder->field_is_flat(fd.index()), \"Must be\");\n@@ -1842,1 +1844,1 @@\n-    res = field_vklass->read_flat_field(o, ik->field_offset(fd.index()), li->kind(), CHECK_NULL);\n+    res = field_vklass->read_payload_from_addr(o, ik->field_offset(fd.index()), li->kind(), CHECK_NULL);\n@@ -1849,2 +1851,0 @@\n-\n-\n@@ -1947,1 +1947,1 @@\n-    vklass->write_flat_field(o, offset, v, fd.is_null_free_inline_type(), li->kind(), CHECK);\n+    vklass->write_value_to_addr(v, ((char*)(oopDesc*)obj) + offset, li->kind(), true, CHECK);\n@@ -2378,2 +2378,1 @@\n-      flatArrayHandle vah(thread, a);\n-      res = flatArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);\n+      res = a->read_value_from_flat_array(index, CHECK_NULL);\n@@ -2414,1 +2413,1 @@\n-         a->value_copy_to_index(v, index, LayoutKind::PAYLOAD);  \/\/ Temporary hack for the transition\n+         a->write_value_to_flat_array(v, index, CHECK);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-JVM_ENTRY(jarray, JVM_NewNullRestrictedArray(JNIEnv *env, jclass elmClass, jint len))\n+static void validate_array_arguments(Klass* elmClass, jint len, TRAPS) {\n@@ -433,1 +433,5 @@\n-    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Array length is negative\");\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"Array length is negative\");\n+  }\n+  elmClass->initialize(CHECK);\n+  if (elmClass->is_identity_class()) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not a value class\");\n@@ -435,0 +439,6 @@\n+  if (elmClass->is_abstract()) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is abstract\");\n+  }\n+}\n+\n+JVM_ENTRY(jarray, JVM_NewNullRestrictedArray(JNIEnv *env, jclass elmClass, jint len))\n@@ -438,2 +448,4 @@\n-  if (klass->is_identity_class()) {\n-    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not a value class\");\n+  validate_array_arguments(klass, len, CHECK_NULL);\n+  InlineKlass* vk = InlineKlass::cast(klass);\n+  if (!vk->is_implicitly_constructible()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n@@ -441,2 +453,5 @@\n-  if (klass->is_abstract()) {\n-    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is abstract\");\n+  oop array = nullptr;\n+  if (UseFlatArray && vk->has_non_atomic_layout()) {\n+    array = oopFactory::new_flatArray(vk, len, LayoutKind::NON_ATOMIC_FLAT, CHECK_NULL);\n+  } else {\n+    array = oopFactory::new_null_free_objArray(vk, len, CHECK_NULL);\n@@ -444,0 +459,8 @@\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+JVM_END\n+\n+JVM_ENTRY(jarray, JVM_NewNullRestrictedAtomicArray(JNIEnv *env, jclass elmClass, jint len))\n+  oop mirror = JNIHandles::resolve_non_null(elmClass);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  klass->initialize(CHECK_NULL);\n+  validate_array_arguments(klass, len, CHECK_NULL);\n@@ -448,1 +471,26 @@\n-  oop array = oopFactory::new_valueArray(vk, len, CHECK_NULL);\n+  oop array = nullptr;\n+  if (UseFlatArray && vk->has_atomic_layout()) {\n+    array = oopFactory::new_flatArray(vk, len, LayoutKind::ATOMIC_FLAT, CHECK_NULL);\n+  } else if (UseFlatArray && vk->is_naturally_atomic()) {\n+    array = oopFactory::new_flatArray(vk, len, LayoutKind::NON_ATOMIC_FLAT, CHECK_NULL);\n+  } else {\n+    array = oopFactory::new_null_free_objArray(vk, len, CHECK_NULL);\n+  }\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+JVM_END\n+\n+JVM_ENTRY(jarray, JVM_NewNullableAtomicArray(JNIEnv *env, jclass elmClass, jint len))\n+  oop mirror = JNIHandles::resolve_non_null(elmClass);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  klass->initialize(CHECK_NULL);\n+  validate_array_arguments(klass, len, CHECK_NULL);\n+  InlineKlass* vk = InlineKlass::cast(klass);\n+  if (!vk->is_implicitly_constructible()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not implicitly constructible\");\n+  }\n+  oop array = nullptr;\n+  if (UseFlatArray && vk->has_nullable_atomic_layout()) {\n+    array = oopFactory::new_flatArray(vk, len, LayoutKind::NULLABLE_ATOMIC_FLAT, CHECK_NULL);\n+  } else {\n+    array = oopFactory::new_objArray(vk, len, CHECK_NULL);\n+  }\n@@ -452,0 +500,4 @@\n+JVM_ENTRY(jboolean, JVM_IsFlatArray(JNIEnv *env, jobject obj))\n+  arrayOop oop = arrayOop(JNIHandles::resolve_non_null(obj));\n+  return oop->is_flatArray();\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":59,"deletions":7,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -376,0 +376,1 @@\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n@@ -397,1 +398,1 @@\n-  oop v = vk->read_flat_field(base_h(), offset, LayoutKind::PAYLOAD, CHECK_NULL);  \/\/ TODO FIXME Hard coded layout kind to make the code compile, Unsafe must be upgraded to handle correct layout kind\n+  oop v = vk->read_payload_from_addr(base_h(), offset, LayoutKind::PAYLOAD, CHECK_NULL);\/\/ TODO FIXME Hard coded layout kind to make the code compile, Unsafe must be upgraded to handle correct layout kind\n@@ -408,1 +409,2 @@\n-  vk->write_flat_field(base, offset, v, true \/*null free*\/, LayoutKind::PAYLOAD, CHECK);  \/\/ TODO FIXME Hard coded layout kind to make the code compile, Unsafe must be upgraded to handle correct layout kind\n+  \/\/ TODO FIXME: problem below, with new APIs, null checking depends on LayoutKind, but Unsafe APIs are not able to communicate the right layout kind yet\n+  vk->write_value_to_addr(v, ((char*)(oopDesc*)base) + offset, LayoutKind::PAYLOAD, true, CHECK);\/\/ TODO FIXME Hard coded layout kind to make the code compile, Unsafe must be upgraded to handle correct layout kind\n@@ -417,1 +419,1 @@\n-  vk->inline_copy_oop_to_new_oop(vh(), new_value, LayoutKind::PAYLOAD);  \/\/ FIXME temporary hack for the transition\n+  vk->copy_payload_to_addr(vk->data_for_oop(vh()), vk->data_for_oop(new_value), LayoutKind::PAYLOAD, false);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1290,1 +1290,1 @@\n-      obj = ak->allocate(sv->field_size(), THREAD);\n+      obj = ak->allocate(sv->field_size(), ak->layout_kind(), THREAD);\n@@ -1633,1 +1633,1 @@\n-  int base_offset = arrayOopDesc::base_offset_in_bytes(T_PRIMITIVE_OBJECT) - InlineKlass::cast(vk)->first_field_offset();\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT) - InlineKlass::cast(vk)->first_field_offset();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall through\n+    case T_FLAT_ELEMENT: \/\/ fall through\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+  do_stub(store_unknown_inline, 0, true, false)                        \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1508,1 +1508,1 @@\n-  assert((type >= T_BOOLEAN && type <= T_OBJECT) || type == T_PRIMITIVE_OBJECT, \"invalid array element type\");\n+  assert((type >= T_BOOLEAN && type <= T_OBJECT) || type == T_FLAT_ELEMENT, \"invalid array element type\");\n@@ -1512,1 +1512,1 @@\n-  } else if (type == T_PRIMITIVE_OBJECT) {\n+  } else if (type == T_FLAT_ELEMENT) {\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-  _type2aelembytes[T_PRIMITIVE_OBJECT]  = heapOopSize;\n+  _type2aelembytes[T_FLAT_ELEMENT]  = heapOopSize;\n@@ -213,1 +213,1 @@\n-  JVM_SIGNATURE_PRIMITIVE_OBJECT, JVM_SIGNATURE_VOID,\n+  JVM_SIGNATURE_FLAT_ELEMENT, JVM_SIGNATURE_VOID,\n@@ -328,1 +328,1 @@\n-  T_PRIMITIVE_OBJECT_aelem_bytes, \/\/ T_PRIMITIVE_OBJECT = 14,\n+  T_FLAT_ELEMENT_aelem_bytes, \/\/ T_PRIMITIVE_OBJECT = 14,\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -727,1 +727,1 @@\n-  T_PRIMITIVE_OBJECT = 14, \/\/ Not a true BasicType, only use in headers of flat arrays\n+  T_FLAT_ELEMENT = 14, \/\/ Not a true BasicType, only use in headers of flat arrays\n@@ -748,1 +748,1 @@\n-    F(JVM_SIGNATURE_PRIMITIVE_OBJECT, T_PRIMITIVE_OBJECT, N) \\\n+    F(JVM_SIGNATURE_FLAT_ELEMENT, T_FLAT_ELEMENT, N) \\\n@@ -778,1 +778,1 @@\n-  return (t == T_OBJECT || t == T_ARRAY || t == T_PRIMITIVE_OBJECT || (include_narrow_oop && t == T_NARROWOOP));\n+  return (t == T_OBJECT || t == T_ARRAY || t == T_FLAT_ELEMENT || (include_narrow_oop && t == T_NARROWOOP));\n@@ -837,1 +837,1 @@\n-  T_PRIMITIVE_OBJECT_size = 1\n+  T_FLAT_ELEMENT_size = 1\n@@ -867,1 +867,1 @@\n-  T_PRIMITIVE_OBJECT_aelem_bytes = 8,\n+  T_FLAT_ELEMENT_aelem_bytes = 8,\n@@ -871,1 +871,1 @@\n-  T_PRIMITIVE_OBJECT_aelem_bytes = 4,\n+  T_FLAT_ELEMENT_aelem_bytes = 4,\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -122,0 +122,8 @@\n+    public static native Object[] newNullRestrictedAtomicArray(Class<?> componentType,\n+                                                         int length);\n+\n+    public static native Object[] newNullableAtomicArray(Class<?> componentType,\n+                                                         int length);\n+\n+    public static native boolean isFlatArray(Object array);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/ValueClass.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    JVM_SIGNATURE_PRIMITIVE_OBJECT = 'Q',\n+    JVM_SIGNATURE_FLAT_ELEMENT  = 'Q',\n","filename":"src\/java.base\/share\/native\/include\/classfile_constants.h.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,18 @@\n+JNIEXPORT jarray JNICALL\n+Java_jdk_internal_value_ValueClass_newNullRestrictedAtomicArray(JNIEnv *env, jclass cls, jclass elmClass, jint len)\n+{\n+    return JVM_NewNullRestrictedAtomicArray(env, elmClass, len);\n+}\n+\n+JNIEXPORT jarray JNICALL\n+Java_jdk_internal_value_ValueClass_newNullableAtomicArray(JNIEnv *env, jclass cls, jclass elmClass, jint len)\n+{\n+    return JVM_NewNullableAtomicArray(env, elmClass, len);\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_value_ValueClass_isFlatArray(JNIEnv *env, jclass cls, jobject obj)\n+{\n+    return JVM_IsFlatArray(env, obj);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libjava\/ValueClass.c","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -204,2 +204,17 @@\n-TEST_VM(markWord, flat_array_prototype) {\n-  markWord mark = markWord::flat_array_prototype();\n+TEST_VM(markWord, null_free_flat_array_prototype) {\n+  markWord mark = markWord::flat_array_prototype(LayoutKind::NON_ATOMIC_FLAT);\n+  assert_unlocked_state(mark);\n+  EXPECT_TRUE(mark.is_neutral());\n+\n+  assert_flat_array_type(mark);\n+\n+  EXPECT_TRUE(mark.has_no_hash());\n+  EXPECT_FALSE(mark.is_marked());\n+  EXPECT_TRUE(mark.decode_pointer() == NULL);\n+\n+  assert_copy_set_hash(mark);\n+  assert_flat_array_type(mark);\n+}\n+\n+TEST_VM(markWord, nullable_flat_array_prototype) {\n+  markWord mark = markWord::flat_array_prototype(LayoutKind::NULLABLE_ATOMIC_FLAT);\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,459 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package runtime.valhalla.inlinetypes;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.RuntimeMXBean;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test FlatArraysTest\n+ * @summary Plain array test for Inline Types\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib\n+ * @enablePreview\n+ * @compile --source 24 FlatArraysTest.java\n+ * @run main\/othervm -XX:FlatArrayElementMaxSize=-1 -XX:InlineFieldMaxFlatSize=-1 -XX:+AtomicFieldFlattening -XX:+NullableFieldFlattening runtime.valhalla.inlinetypes.FlatArraysTest\n+ * @run main\/othervm -XX:FlatArrayElementMaxSize=0 -XX:+AtomicFieldFlattening -XX:+NullableFieldFlattening runtime.valhalla.inlinetypes.FlatArraysTest\n+ *\/\n+public class FlatArraysTest {\n+  static final int ARRAY_SIZE = 100;\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class SmallValue {\n+      byte b;\n+      short s;\n+\n+      SmallValue() { b = 0 ;  s = 0; }\n+      SmallValue(byte b0, short s0) { b = b0; s = s0; }\n+\n+      public static Object getTestValue() { return new SmallValue(Byte.MIN_VALUE, Short.MIN_VALUE); }\n+\n+      public static boolean expectingFlatNullRestrictedArray() { return true; }\n+      public static boolean expectingFlatNullRestrictedAtomicArray() { return true; }\n+      public static boolean expectingFlatNullableAtomicArray() { return true; }\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class MediumValue {\n+      int x;\n+      int y;\n+\n+      MediumValue() {\n+         x = 0;\n+         y = 0;\n+      }\n+      MediumValue(int x0, int y0) {\n+        x = x0;\n+        y = y0;\n+      }\n+\n+      public static Object getTestValue() {\n+        return new MediumValue(Integer.MIN_VALUE, Integer.MIN_VALUE);\n+      }\n+\n+      public static boolean expectingFlatNullRestrictedArray() { return true; }\n+      public static boolean expectingFlatNullRestrictedAtomicArray() { return true; }\n+      public static boolean expectingFlatNullableAtomicArray() { return false; }\n+  }\n+\n+  @ImplicitlyConstructible\n+  @LooselyConsistentValue\n+  static value class BigValue {\n+      long x;\n+      long y;\n+      long z;\n+\n+      BigValue() {\n+        x = 0;\n+        y = 0;\n+        z = 0;\n+      }\n+      BigValue(long x0, long y0, long z0) {\n+        x = x0;\n+        y = y0;\n+        z = z0;\n+      }\n+\n+      public static Object getTestValue() {\n+        return new BigValue(Long.MIN_VALUE, Long.MIN_VALUE, Long.MIN_VALUE);\n+      }\n+\n+      public static boolean expectingFlatNullRestrictedArray() { return true; }\n+      public static boolean expectingFlatNullRestrictedAtomicArray() { return false; }\n+      public static boolean expectingFlatNullableAtomicArray() { return false; }\n+  }\n+\n+  static void testNullFreeArray(Object[] array, Object value) {\n+    testErrorCases(array);\n+    assertNotNull(value, \"Test needs a not null value\");\n+    \/\/   Test 1 : check initial element value is not null\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertNotNull(array[i], \"Initial value must not be null\");\n+    }\n+    \/\/   Test 2 : try to write null\n+    for (int i = 0 ; i < array.length; i++) {\n+      try {\n+        array[i] = null;\n+        throw new RuntimeException(\"Missing NullPointerException\");\n+      } catch (NullPointerException e) { }\n+    }\n+    \/\/   Test 3 : overwrite initial value with new value\n+    for (int i = 0 ; i < array.length; i++) {\n+      array[i] = value;\n+    }\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertEquals(array[i], value);\n+    }\n+  }\n+\n+  static void testNullableArray(Object[] array, Object value) {\n+    testErrorCases(array);\n+    assertNotNull(value, \"Test needs a not null value\");\n+    \/\/   Test 1 : check that initial element value is null\n+    System.gc();\n+    System.out.println(\"Test 1\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertNull(array[i], \"Initial value should be null\");\n+    }\n+    \/\/   Test 2 : write new value to all elements\n+    System.gc();\n+    System.out.println(\"Test 2a\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      array[i] = value;\n+      assertEquals(array[i], value, \"Value mismatch\");\n+    }\n+    System.gc();\n+    System.out.println(\"Test 2b\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertEquals(array[i], value, \"Value mismatch\");\n+    }\n+    \/\/   Test 3 : write null to all elements\n+    System.gc();\n+    System.out.println(\"Test 3a\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      array[i] = null;\n+    }\n+    System.gc();\n+    System.out.println(\"Test 3b\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      assertNull(array[i], \"Value mismatch\");\n+    }\n+    \/\/   Test 4 : write alternate null \/ not null values\n+    System.gc();\n+    System.out.println(\"Test 4a\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      if (i%2 == 0) {\n+        array[i] = null;\n+      } else {\n+        array[i] = value;\n+      }\n+    }\n+    System.gc();\n+    System.out.println(\"Test 4b\");\n+    for (int i = 0 ; i < array.length; i++) {\n+      if (i%2 == 0) {\n+        assertNull(array[i], \"Value mismatch\");\n+      } else {\n+        assertEquals(array[i], value, \"Value mismatch\");\n+      }\n+    }\n+  }\n+\n+  static void testErrorCases(Object[] array) {\n+    try {\n+      Object o = array[-1];\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+\n+    try {\n+      Object o = array[array.length];\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+\n+    assertTrue(array.getClass().getComponentType() != String.class, \"Must be for the test\");\n+    assertTrue(array.length > 0, \"Must be for the test\");\n+    try {\n+      array[0] = new String(\"Bad\");\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+  }\n+\n+  static void testArrayCopy() {\n+\n+    Object[] objArray = new Object[ARRAY_SIZE];\n+    for (int i = 0; i < ARRAY_SIZE; i++) {\n+      objArray[i] = SmallValue.getTestValue();\n+    }\n+    SmallValue[] nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedArray(SmallValue.class, ARRAY_SIZE);\n+    SmallValue[] atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    SmallValue[] nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    \/\/ obj -> non-atomic\n+    testArrayCopyInternal(objArray, nonAtomicArray);\n+\n+    \/\/ obj -> atomic\n+    testArrayCopyInternal(objArray, atomicArray);\n+\n+    \/\/ obj -> nullable\n+    testArrayCopyInternal(objArray, nullableArray);\n+\n+    objArray[45] = null;\n+    \/\/ obj with null -> non-atomic   => NPE\n+    try {\n+      testArrayCopyInternal(objArray, nonAtomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ obj with null -> atomic       => NPE\n+    try {\n+      testArrayCopyInternal(objArray, atomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ obj with null -> nullable\n+    try {\n+      testArrayCopyInternal(objArray, nullableArray);\n+    } catch (NullPointerException e) {\n+      throw new RuntimeException(\"Unexpected NullPointerException\");\n+    }\n+\n+    objArray[45] = new String(\"bad\");\n+    \/\/ obj with wrong type value -> non-atomic   => ASE\n+    try {\n+      testArrayCopyInternal(objArray, nonAtomicArray);\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+\n+    \/\/ obj with wrong type value -> atomic       => ASE\n+    try {\n+      testArrayCopyInternal(objArray, atomicArray);\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+\n+    \/\/ obj with wrong type value -> nullable     => ASE\n+    try {\n+      testArrayCopyInternal(objArray, nullableArray);\n+      throw new RuntimeException(\"Missing ArrayStoreException\");\n+    } catch (ArrayStoreException e) { }\n+\n+    \/\/ Reset all arrays\n+    objArray = new Object[ARRAY_SIZE];\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedArray(SmallValue.class, ARRAY_SIZE);\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    \/\/ non-atomic -> obj\n+    testArrayCopyInternal(nonAtomicArray, objArray);\n+\n+    \/\/ non-atomic -> non-atomic\n+    SmallValue[] nonAtomicArray2 = (SmallValue[])ValueClass.newNullRestrictedArray(SmallValue.class, ARRAY_SIZE);\n+    testArrayCopyInternal(nonAtomicArray, nonAtomicArray2);\n+\n+    \/\/ non-atomic -> non-atomic same array\n+    testArrayCopyInternal(nonAtomicArray, nonAtomicArray);\n+\n+    \/\/ non-atomic -> atomic\n+    testArrayCopyInternal(nonAtomicArray, atomicArray);\n+\n+    \/\/ non-atomic -> nullable\n+    testArrayCopyInternal(nonAtomicArray, nullableArray);\n+\n+    \/\/ Reset all arrays\n+    objArray = new Object[ARRAY_SIZE];\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedArray(SmallValue.class, ARRAY_SIZE);\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    for (int i = 0 ; i < ARRAY_SIZE; i++) {\n+      atomicArray[i] = (SmallValue)SmallValue.getTestValue();\n+    }\n+\n+    \/\/ atomic -> obj\n+    testArrayCopyInternal(atomicArray, objArray);\n+\n+    \/\/ atomic -> non-atomic\n+    testArrayCopyInternal(atomicArray, nonAtomicArray);\n+\n+    \/\/ atomic -> atomic\n+    SmallValue[] atomicArray2 = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    testArrayCopyInternal(atomicArray, atomicArray2);\n+\n+    \/\/ atomic -> atomic same array\n+    testArrayCopyInternal(atomicArray, atomicArray);\n+\n+    \/\/ atomic -> nullable\n+    testArrayCopyInternal(atomicArray, nullableArray);\n+\n+    \/\/ Reset all arrays\n+    objArray = new Object[ARRAY_SIZE];\n+    nonAtomicArray = (SmallValue[])ValueClass.newNullRestrictedArray(SmallValue.class, ARRAY_SIZE);\n+    atomicArray = (SmallValue[])ValueClass.newNullRestrictedAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    nullableArray = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+\n+    for (int i = 0 ; i < ARRAY_SIZE; i++) {\n+      nullableArray[i] = (SmallValue)SmallValue.getTestValue();\n+    }\n+\n+    \/\/ nullable -> obj\n+    testArrayCopyInternal(nullableArray, objArray);\n+\n+    \/\/ nullable -> non-atomic\n+    testArrayCopyInternal(nullableArray, nonAtomicArray);\n+\n+    \/\/ nullable -> atomic\n+    testArrayCopyInternal(nullableArray, atomicArray);\n+\n+    \/\/ nullable -> nullable\n+    SmallValue[] nullableArray2 = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    testArrayCopyInternal(nullableArray, nullableArray2);\n+\n+    \/\/ nullable -> nullable same array\n+    testArrayCopyInternal(nullableArray, nullableArray);\n+\n+    nullableArray[45] = null;\n+\n+    \/\/ nullable with null -> obj\n+    testArrayCopyInternal(nullableArray, objArray);\n+\n+    \/\/ nullable with null -> non-atomic  => NPE\n+    try {\n+      testArrayCopyInternal(nullableArray, nonAtomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ nullable with null -> atomic      => NPE\n+    try {\n+      testArrayCopyInternal(nullableArray, atomicArray);\n+      throw new RuntimeException(\"Missing NullPointerException\");\n+    } catch (NullPointerException e) { }\n+\n+    \/\/ nullable with null -> nullable\n+    nullableArray2 = (SmallValue[])ValueClass.newNullableAtomicArray(SmallValue.class, ARRAY_SIZE);\n+    testArrayCopyInternal(nullableArray, nullableArray2);\n+\n+    \/\/ nullable with null -> nullable same array\n+    testArrayCopyInternal(nullableArray, nullableArray);\n+  }\n+\n+  static void testArrayCopyInternal(Object[] src, Object[] dst) {\n+    \/\/ When using this method for cases that should trigger a NPE or an ASE,\n+    \/\/ it is recommended to put the faulty value at index 45 in the src array\n+    assertTrue(src.length >= ARRAY_SIZE, \"Must be for the test\");\n+    assertTrue(dst.length >= ARRAY_SIZE, \"Must be for the test\");\n+    \/\/ Test 1 : good copy without indexes overlap\n+    System.arraycopy(src, 3, dst, 51, 40);\n+    for (int i = 0; i < 40; i++) {\n+      assertEquals(src[3+i], dst[51+i], \"Mismatch after copying\");\n+    }\n+    \/\/ Test 2 : good copy with indexes overlap\n+    System.arraycopy(src, 42, dst, 53, 45);\n+    if (src != dst) {  \/\/ Verification doesn't make sense if src and dst are the same\n+      for (int i = 0; i < 45; i++) {\n+        assertEquals(src[42+i], dst[53+i], \"Mismatch after copying\");\n+      }\n+    }\n+    \/\/ Test 3 : IOOB errors\n+    try {\n+      System.arraycopy(src, -1, dst, 3, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+    try {\n+      System.arraycopy(src, src.length - 5, dst, 3, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+    try {\n+      System.arraycopy(src, 10, dst, -1, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+    try {\n+      System.arraycopy(src, 10, dst, dst.length - 5, 10);\n+      throw new RuntimeException(\"Missing IndexOutOfBoundsException\");\n+    } catch(IndexOutOfBoundsException e) { }\n+  }\n+\n+  static void testArrayAccesses() throws NoSuchMethodException, InstantiationException,\n+  IllegalAccessException, InvocationTargetException {\n+    RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();\n+    List<String> arguments = runtimeMxBean.getInputArguments();\n+    boolean useFlatArray = !arguments.contains(\"-XX:FlatArrayElementMaxSize=0\");\n+    System.out.println(\"UseFlatArray: \" + useFlatArray);\n+    Class[] valueClasses = {SmallValue.class, MediumValue.class, BigValue.class};\n+    for (Class c: valueClasses) {\n+      System.out.println(\"Testing class \" + c.getName());\n+      Method gtv = c.getMethod(\"getTestValue\", null);\n+      Object o = gtv.invoke(null, null);\n+      assertNotNull(o);\n+\n+      System.out.println(\"Regular reference array\");\n+      Object[] array = (Object[])Array.newInstance(c, ARRAY_SIZE);\n+      assertFalse(ValueClass.isFlatArray(array));\n+      testNullableArray(array, o);\n+\n+      System.out.println(\"NonAtomic NullRestricted array\");\n+      array = ValueClass.newNullRestrictedArray(c, ARRAY_SIZE);\n+      Method ef = c.getMethod(\"expectingFlatNullRestrictedArray\", null);\n+      boolean expectFlat = (Boolean)ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (useFlatArray && expectFlat));\n+      testNullFreeArray(array, o);\n+\n+      System.out.println(\"NullRestricted Atomic array\");\n+      array = ValueClass.newNullRestrictedAtomicArray(c, ARRAY_SIZE);\n+      ef = c.getMethod(\"expectingFlatNullRestrictedAtomicArray\", null);\n+      expectFlat = (Boolean)ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (useFlatArray && expectFlat));\n+      testNullFreeArray(array, o);\n+\n+      System.out.println(\"Nullable Atomic array\");\n+      array = ValueClass.newNullableAtomicArray(c, ARRAY_SIZE);\n+      ef = c.getMethod(\"expectingFlatNullableAtomicArray\", null);\n+      expectFlat = (Boolean)ef.invoke(null, null);\n+      assertTrue(ValueClass.isFlatArray(array) == (useFlatArray && expectFlat));\n+      testNullableArray(array, o);\n+    }\n+  }\n+\n+  public static void main(String[] args) throws NoSuchMethodException, InstantiationException,\n+                                                IllegalAccessException, InvocationTargetException {\n+    testArrayAccesses();\n+    testArrayCopy();\n+  }\n+\n+ }\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlatArraysTest.java","additions":459,"deletions":0,"binary":false,"changes":459,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-\n@@ -46,1 +45,1 @@\n- * @run main\/othervm -XX:FlatArrayElementMaxSize=-1 runtime.valhalla.inlinetypes.InlineTypeArray\n+ * @run main\/othervm -XX:FlatArrayElementMaxSize=-1 -XX:InlineFieldMaxFlatSize=-1 runtime.valhalla.inlinetypes.InlineTypeArray\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/InlineTypeArray.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}