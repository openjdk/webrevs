{"files":[{"patch":"@@ -74,0 +74,61 @@\n+\n+\/\/ Helper class to store objects to visit.\n+class JvmtiHeapwalkVisitStack {\n+private:\n+  enum {\n+    initial_visit_stack_size = 4000\n+  };\n+\n+  GrowableArray<JvmtiHeapwalkObject>* _visit_stack;\n+  JVMTIBitSet _bitset;\n+\n+  static GrowableArray<JvmtiHeapwalkObject>* create_visit_stack() {\n+    return new (mtServiceability) GrowableArray<JvmtiHeapwalkObject>(initial_visit_stack_size, mtServiceability);\n+  }\n+\n+public:\n+  JvmtiHeapwalkVisitStack(): _visit_stack(create_visit_stack()) {\n+  }\n+  ~JvmtiHeapwalkVisitStack() {\n+    if (_visit_stack != nullptr) {\n+      delete _visit_stack;\n+    }\n+  }\n+\n+  bool is_empty() const {\n+    return _visit_stack->is_empty();\n+  }\n+\n+  void push(const JvmtiHeapwalkObject& obj) {\n+    _visit_stack->push(obj);\n+  }\n+\n+  \/\/ If the object hasn't been visited then push it onto the visit stack\n+  \/\/ so that it will be visited later.\n+  void check_for_visit(const JvmtiHeapwalkObject& obj) {\n+    if (!is_visited(obj)) {\n+      _visit_stack->push(obj);\n+    }\n+  }\n+\n+  JvmtiHeapwalkObject pop() {\n+    return _visit_stack->pop();\n+  }\n+\n+  bool is_visited(const JvmtiHeapwalkObject& obj) \/*const*\/ { \/\/ TODO: _bitset.is_marked() should be const\n+    \/\/ The method is called only for objects from visit_stack to ensure an object is not visited twice.\n+    \/\/ Flat objects can be added to visit_stack only when we visit their holder object, so we cannot get duplicate reference to it.\n+    if (obj.is_flat()) {\n+      return false;\n+    }\n+    return _bitset.is_marked(obj.obj());\n+  }\n+\n+  void mark_visited(const JvmtiHeapwalkObject& obj) {\n+    if (!obj.is_flat()) {\n+      _bitset.mark_obj(obj.obj());\n+    }\n+  }\n+};\n+\n+\n@@ -81,1 +142,2 @@\n-  _posting_events(false) {\n+  _posting_events(false),\n+  _converting_flat_object(false) {\n@@ -87,0 +149,1 @@\n+  _flat_hashmap = new JvmtiFlatTagMapTable();\n@@ -102,0 +165,1 @@\n+  delete _flat_hashmap;\n@@ -110,0 +174,1 @@\n+  _flat_hashmap->clear();\n@@ -128,5 +193,0 @@\n-\/\/ iterate over all entries in the tag map.\n-void JvmtiTagMap::entry_iterate(JvmtiTagMapKeyClosure* closure) {\n-  hashmap()->entry_iterate(closure);\n-}\n-\n@@ -134,1 +194,1 @@\n-bool JvmtiTagMap::is_empty() {\n+bool JvmtiTagMap::is_empty() const {\n@@ -136,1 +196,1 @@\n-  return hashmap()->is_empty();\n+  return _hashmap->is_empty() && _flat_hashmap->is_empty();\n@@ -170,5 +230,150 @@\n-\/\/ Return the tag value for an object, or 0 if the object is\n-\/\/ not tagged\n-\/\/\n-static inline jlong tag_for(JvmtiTagMap* tag_map, oop o) {\n-  return tag_map->hashmap()->find(o);\n+\/\/ Converts entries from JvmtiFlatTagMapTable to JvmtiTagMapTable in batches.\n+\/\/   1. (JvmtiTagMap is locked)\n+\/\/      reads entries from JvmtiFlatTagMapTable (describe flat value objects);\n+\/\/   2. (JvmtiTagMap is unlocked)\n+\/\/      creates heap-allocated copies of the flat object;\n+\/\/   3. (JvmtiTagMap is locked)\n+\/\/      ensures source entry still exists, removes it from JvmtiFlatTagMapTable, adds new entry to JvmtiTagMapTable.\n+\/\/ If some error occurs in step 2 (OOM?), the process stops.\n+class JvmtiTagMapFlatEntryConverter: public StackObj {\n+private:\n+  struct Entry {\n+    \/\/ source flat value object\n+    Handle holder;\n+    int offset;\n+    InlineKlass* inline_klass;\n+    LayoutKind layout_kind;\n+    \/\/ converted heap-allocated object\n+    Handle dst;\n+\n+    Entry(): holder(), offset(0), inline_klass(nullptr), dst() {}\n+    Entry(Handle holder, int offset, InlineKlass* inline_klass, LayoutKind lk)\n+      : holder(holder), offset(offset), inline_klass(inline_klass), layout_kind(lk), dst() {}\n+  };\n+\n+  int _batch_size;\n+  GrowableArray<Entry> _entries;\n+  bool _has_error;\n+\n+public:\n+  JvmtiTagMapFlatEntryConverter(int batch_size): _batch_size(batch_size), _entries(batch_size, mtServiceability), _has_error(false) { }\n+  ~JvmtiTagMapFlatEntryConverter() {}\n+\n+  \/\/ returns false if there is nothing to convert\n+  bool import_entries(JvmtiFlatTagMapTable* table) {\n+    if (_has_error) {\n+      \/\/ stop the process to avoid infinite loop\n+      return false;\n+    }\n+\n+    class Importer: public JvmtiFlatTagMapKeyClosure {\n+    private:\n+      GrowableArray<Entry>& _entries;\n+      int _batch_size;\n+    public:\n+      Importer(GrowableArray<Entry>& entries, int batch_size): _entries(entries), _batch_size(batch_size) {}\n+\n+      bool do_entry(JvmtiFlatTagMapKey& key, jlong& tag) {\n+        Entry entry(Handle(Thread::current(), key.holder()), key.offset(), key.inline_klass(), key.layout_kind());\n+        _entries.append(entry);\n+\n+        return _entries.length() < _batch_size;\n+      }\n+    } importer(_entries, _batch_size);\n+    table->entry_iterate(&importer);\n+\n+    return !_entries.is_empty();\n+  }\n+\n+  void convert() {\n+    for (int i = 0; i < _entries.length(); i++) {\n+      EXCEPTION_MARK;\n+      Entry& entry = _entries.at(i);\n+      oop obj = entry.inline_klass->read_payload_from_addr(entry.holder(), entry.offset, entry.layout_kind, JavaThread::current());\n+\n+      if (HAS_PENDING_EXCEPTION) {\n+        tty->print_cr(\"Exception in JvmtiTagMapFlatEntryConverter: \");\n+        java_lang_Throwable::print(PENDING_EXCEPTION, tty);\n+        tty->cr();\n+        CLEAR_PENDING_EXCEPTION;\n+        \/\/ stop the conversion\n+        _has_error = true;\n+      } else {\n+        entry.dst = Handle(Thread::current(), obj);\n+      }\n+    }\n+  }\n+\n+  \/\/ returns number of converted entries\n+  int move(JvmtiFlatTagMapTable* src_table, JvmtiTagMapTable* dst_table) {\n+    int count = 0;\n+    for (int i = 0; i < _entries.length(); i++) {\n+      Entry& entry = _entries.at(i);\n+      if (entry.dst() == nullptr) {\n+        \/\/ some error during conversion, skip the entry\n+        continue;\n+      }\n+      JvmtiHeapwalkObject obj(entry.holder(), entry.offset, entry.inline_klass, entry.layout_kind);\n+      jlong tag = src_table->remove(obj);\n+\n+      if (tag != 0) { \/\/ ensure the entry is still in the src_table\n+        dst_table->add(entry.dst(), tag);\n+        count++;\n+      } else {\n+\n+      }\n+    }\n+    \/\/ and clean the array\n+    _entries.clear();\n+    return count;\n+  }\n+};\n+\n+\n+void JvmtiTagMap::convert_flat_object_entries() {\n+  Thread* current = Thread::current();\n+  assert(current->is_Java_thread(), \"must be executed on JavaThread\");\n+\n+  log_debug(jvmti, table)(\"convert_flat_object_entries, main table size = %d, flat table size = %d\",\n+                          _hashmap->number_of_entries(), _flat_hashmap->number_of_entries());\n+\n+  {\n+    MonitorLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+    \/\/ If another thread is converting, let it finish.\n+    while (_converting_flat_object) {\n+      ml.wait();\n+    }\n+    if (_flat_hashmap->is_empty()) {\n+      \/\/ nothing to convert\n+      return;\n+    }\n+    _converting_flat_object = true;\n+  }\n+\n+  const int BATCH_SIZE = 1024;\n+  JvmtiTagMapFlatEntryConverter converter(BATCH_SIZE);\n+\n+  int count = 0;\n+  while (true) {\n+    HandleMark hm(current);\n+    {\n+      MonitorLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+      if (!converter.import_entries(_flat_hashmap)) {\n+        break;\n+      }\n+    }\n+    \/\/ Convert flat objects to heap-allocated without table lock (so agent callbacks can get\/set tags).\n+    converter.convert();\n+    {\n+      MonitorLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+      count += converter.move(_flat_hashmap, _hashmap);\n+    }\n+  }\n+\n+  log_info(jvmti, table)(\"%d flat value objects are converted, flat table size = %d\",\n+                         count, _flat_hashmap->number_of_entries());\n+  {\n+    MonitorLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+    _converting_flat_object = false;\n+    ml.notify_all();\n+  }\n@@ -177,0 +382,29 @@\n+jlong JvmtiTagMap::find(const JvmtiHeapwalkObject& obj) const {\n+  jlong tag = _hashmap->find(obj);\n+  if (tag == 0 && obj.is_value()) {\n+    tag = _flat_hashmap->find(obj);\n+  }\n+  return tag;\n+}\n+\n+void JvmtiTagMap::add(const JvmtiHeapwalkObject& obj, jlong tag) {\n+  if (obj.is_flat()) {\n+    \/\/ we may have tag for equal (non-flat) object in _hashmap, try to update it 1st\n+    if (!_hashmap->update(obj, tag)) {\n+      \/\/ no entry in _hashmap, add to _flat_hashmap\n+      _flat_hashmap->add(obj, tag);\n+    }\n+  } else {\n+    _hashmap->add(obj, tag);\n+  }\n+}\n+\n+void JvmtiTagMap::remove(const JvmtiHeapwalkObject& obj) {\n+  if (!_hashmap->remove(obj)) {\n+    if (obj.is_value()) {\n+      _flat_hashmap->remove(obj);\n+    }\n+  }\n+}\n+\n+\n@@ -195,2 +429,1 @@\n-  JvmtiTagMapTable* _hashmap;\n-  oop _o;\n+  const JvmtiHeapwalkObject& _o;\n@@ -205,2 +438,2 @@\n-  void inline post_callback_tag_update(oop o, JvmtiTagMapTable* hashmap,\n-                                       jlong obj_tag);\n+  void inline post_callback_tag_update(const JvmtiHeapwalkObject& o, JvmtiTagMap* tag_map, jlong obj_tag);\n+\n@@ -208,1 +441,3 @@\n-  CallbackWrapper(JvmtiTagMap* tag_map, oop o) {\n+  CallbackWrapper(JvmtiTagMap* tag_map, const JvmtiHeapwalkObject& o)\n+    : _tag_map(tag_map), _o(o)\n+  {\n@@ -212,3 +447,0 @@\n-    \/\/ object to tag\n-    _o = o;\n-\n@@ -216,5 +448,8 @@\n-    _obj_size = (jlong)_o->size() * wordSize;\n-\n-    \/\/ record the context\n-    _tag_map = tag_map;\n-    _hashmap = tag_map->hashmap();\n+    if (!o.is_flat()) {\n+      \/\/ common case: we have oop\n+      _obj_size = (jlong)o.obj()->size() * wordSize;\n+    } else {\n+      \/\/ flat value object, we know its InstanceKlass\n+      assert(_o.inline_klass() != nullptr, \"must be\");\n+      _obj_size = _o.inline_klass()->size() * wordSize;;\n+    }\n@@ -223,1 +458,1 @@\n-    _obj_tag = _hashmap->find(_o);\n+    _obj_tag = _tag_map->find(_o);\n@@ -228,1 +463,1 @@\n-    _klass_tag = tag_for(tag_map, _o->klass()->java_mirror());\n+    _klass_tag = _tag_map->find(_o.klass()->java_mirror());\n@@ -232,1 +467,1 @@\n-    post_callback_tag_update(_o, _hashmap, _obj_tag);\n+    post_callback_tag_update(_o, _tag_map, _obj_tag);\n@@ -242,2 +477,2 @@\n-void inline CallbackWrapper::post_callback_tag_update(oop o,\n-                                                      JvmtiTagMapTable* hashmap,\n+void inline CallbackWrapper::post_callback_tag_update(const JvmtiHeapwalkObject& o,\n+                                                      JvmtiTagMap* tag_map,\n@@ -247,1 +482,1 @@\n-    hashmap->remove(o);\n+    tag_map->remove(o);\n@@ -252,1 +487,1 @@\n-    hashmap->add(o, obj_tag);\n+    tag_map->add(o, obj_tag);\n@@ -274,0 +509,1 @@\n+  const JvmtiHeapwalkObject& _referrer;\n@@ -275,2 +511,0 @@\n-  JvmtiTagMapTable* _referrer_hashmap;\n-  oop _referrer;\n@@ -284,2 +518,2 @@\n-  TwoOopCallbackWrapper(JvmtiTagMap* tag_map, oop referrer, oop o) :\n-    CallbackWrapper(tag_map, o)\n+  TwoOopCallbackWrapper(JvmtiTagMap* tag_map, const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& o) :\n+    CallbackWrapper(tag_map, o), _referrer(referrer)\n@@ -294,4 +528,0 @@\n-      _referrer = referrer;\n-      \/\/ record the context\n-      _referrer_hashmap = tag_map->hashmap();\n-\n@@ -299,1 +529,1 @@\n-      _referrer_obj_tag = _referrer_hashmap->find(_referrer);\n+      _referrer_obj_tag = tag_map->find(_referrer);\n@@ -304,1 +534,1 @@\n-      _referrer_klass_tag = tag_for(tag_map, _referrer->klass()->java_mirror());\n+      _referrer_klass_tag = tag_map->find(_referrer.klass()->java_mirror());\n@@ -311,1 +541,1 @@\n-                               _referrer_hashmap,\n+                               tag_map(),\n@@ -339,1 +569,0 @@\n-\n@@ -341,2 +570,1 @@\n-  JvmtiTagMapTable* hashmap = _hashmap;\n-\n+  JvmtiHeapwalkObject obj(o);\n@@ -345,1 +573,1 @@\n-    hashmap->remove(o);\n+    _hashmap->remove(obj);\n@@ -349,1 +577,1 @@\n-    hashmap->add(o, tag);\n+    add(obj, tag);\n@@ -365,1 +593,1 @@\n-  return tag_for(this, o);\n+  return find(o);\n@@ -378,0 +606,2 @@\n+  InlineKlass* _inline_klass; \/\/ nullptr for heap object\n+  LayoutKind _layout_kind;\n@@ -379,2 +609,12 @@\n-  ClassFieldDescriptor(int index, char type, int offset) :\n-    _field_index(index), _field_offset(offset), _field_type(type) {\n+  ClassFieldDescriptor(int index, const FieldStreamBase& fld) :\n+      _field_index(index), _field_offset(fld.offset()), _field_type(fld.signature()->char_at(0)) {\n+    if (fld.is_flat()) {\n+      const fieldDescriptor& fd = fld.field_descriptor();\n+      InstanceKlass* holder_klass = fd.field_holder();\n+      InlineLayoutInfo* layout_info = holder_klass->inline_layout_info_adr(fd.index());\n+      _inline_klass = layout_info->klass();\n+      _layout_kind = layout_info->kind();\n+    } else {\n+      _inline_klass = nullptr;\n+      _layout_kind = LayoutKind::REFERENCE;\n+    }\n@@ -385,0 +625,3 @@\n+  bool is_flat()     const  { return _inline_klass != nullptr; }\n+  InlineKlass* inline_klass() const { return _inline_klass; }\n+  LayoutKind layout_kind() const { return _layout_kind; }\n@@ -403,1 +646,1 @@\n-  void add(int index, char type, int offset);\n+  void add(int index, const FieldStreamBase& fld);\n@@ -414,1 +657,1 @@\n-  static ClassFieldMap* create_map_of_instance_fields(oop obj);\n+  static ClassFieldMap* create_map_of_instance_fields(Klass* k);\n@@ -439,2 +682,2 @@\n-void ClassFieldMap::add(int index, char type, int offset) {\n-  ClassFieldDescriptor* field = new ClassFieldDescriptor(index, type, offset);\n+void ClassFieldMap::add(int index, const FieldStreamBase& fld) {\n+  ClassFieldDescriptor* field = new ClassFieldDescriptor(index, fld);\n@@ -465,1 +708,1 @@\n-    field_map->add(index, fld.signature()->char_at(0), fld.offset());\n+    field_map->add(index, fld);\n@@ -474,2 +717,2 @@\n-ClassFieldMap* ClassFieldMap::create_map_of_instance_fields(oop obj) {\n-  InstanceKlass* ik = InstanceKlass::cast(obj->klass());\n+ClassFieldMap* ClassFieldMap::create_map_of_instance_fields(Klass* k) {\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n@@ -495,1 +738,1 @@\n-      field_map->add(start_index + index, fld.signature()->char_at(0), fld.offset());\n+      field_map->add(start_index + index, fld);\n@@ -525,1 +768,1 @@\n-  \/\/ returns the field map for a given object (returning map cached\n+  \/\/ returns the field map for a given klass (returning map cached\n@@ -527,1 +770,1 @@\n-  static ClassFieldMap* get_map_of_instance_fields(oop obj);\n+  static ClassFieldMap* get_map_of_instance_fields(Klass* k);\n@@ -579,1 +822,1 @@\n-\/\/ returns the instance field map for the given object\n+\/\/ returns the instance field map for the given klass\n@@ -581,1 +824,1 @@\n-ClassFieldMap* JvmtiCachedClassFieldMap::get_map_of_instance_fields(oop obj) {\n+ClassFieldMap* JvmtiCachedClassFieldMap::get_map_of_instance_fields(Klass *k) {\n@@ -585,1 +828,0 @@\n-  Klass* k = obj->klass();\n@@ -594,1 +836,1 @@\n-    ClassFieldMap* field_map = ClassFieldMap::create_map_of_instance_fields(obj);\n+    ClassFieldMap* field_map = ClassFieldMap::create_map_of_instance_fields(k);\n@@ -646,1 +888,1 @@\n-static inline bool is_filtered_by_klass_filter(oop obj, Klass* klass_filter) {\n+static inline bool is_filtered_by_klass_filter(const JvmtiHeapwalkObject& obj, Klass* klass_filter) {\n@@ -648,1 +890,1 @@\n-    if (obj->klass() != klass_filter) {\n+    if (obj.klass() != klass_filter) {\n@@ -679,1 +921,1 @@\n-                                         oop str,\n+                                         const JvmtiHeapwalkObject& obj,\n@@ -682,0 +924,2 @@\n+  assert(!obj.is_flat(), \"cannot be flat\");\n+  oop str = obj.obj();\n@@ -730,1 +974,1 @@\n-                                                  oop obj,\n+                                                  const JvmtiHeapwalkObject& obj,\n@@ -733,1 +977,2 @@\n-  assert(obj->is_typeArray(), \"not a primitive array\");\n+  assert(!obj.is_flat(), \"cannot be flat\");\n+  assert(obj.obj()->is_typeArray(), \"not a primitive array\");\n@@ -736,1 +981,1 @@\n-  typeArrayOop array = typeArrayOop(obj);\n+  typeArrayOop array = typeArrayOop(obj.obj());\n@@ -826,1 +1071,1 @@\n-  oop obj,\n+  const JvmtiHeapwalkObject& obj,\n@@ -834,1 +1079,1 @@\n-  ClassFieldMap* fields = JvmtiCachedClassFieldMap::get_map_of_instance_fields(obj);\n+  ClassFieldMap* fields = JvmtiCachedClassFieldMap::get_map_of_instance_fields(obj.klass());\n@@ -848,3 +1093,2 @@\n-    \/\/ get offset and field value\n-    int offset = field->field_offset();\n-    address addr = cast_from_oop<address>(obj) + offset;\n+    \/\/ get field value\n+    address addr = cast_from_oop<address>(obj.obj()) + obj.offset() + field->field_offset();\n@@ -963,1 +1207,2 @@\n-  CallbackWrapper wrapper(tag_map(), o);\n+  JvmtiHeapwalkObject wrapper_obj(o);\n+  CallbackWrapper wrapper(tag_map(), wrapper_obj);\n@@ -1038,3 +1283,0 @@\n-  \/\/ apply class filter\n-  if (is_filtered_by_klass_filter(obj, klass())) return;\n-\n@@ -1048,0 +1290,5 @@\n+  JvmtiHeapwalkObject wrapper_obj(obj);\n+\n+  \/\/ apply class filter\n+  if (is_filtered_by_klass_filter(wrapper_obj, klass())) return;\n+\n@@ -1049,1 +1296,1 @@\n-  CallbackWrapper wrapper(tag_map(), obj);\n+  CallbackWrapper wrapper(tag_map(), wrapper_obj);\n@@ -1082,1 +1329,1 @@\n-                                                                      obj,\n+                                                                      wrapper_obj,\n@@ -1138,0 +1385,2 @@\n+  convert_flat_object_entries();\n+\n@@ -1165,0 +1414,2 @@\n+  convert_flat_object_entries();\n+\n@@ -1178,1 +1429,1 @@\n-    hashmap()->remove_dead_entries(objects);\n+    _hashmap->remove_dead_entries(objects);\n@@ -1331,0 +1582,3 @@\n+  \/\/ ensure flat object conversion is completed\n+  convert_flat_object_entries();\n+\n@@ -1339,1 +1593,1 @@\n-    entry_iterate(&collector);\n+    _hashmap->entry_iterate(&collector);\n@@ -1379,1 +1633,1 @@\n-  oop _last_referrer;\n+  JvmtiHeapwalkObject _last_referrer;\n@@ -1392,1 +1646,1 @@\n-    _last_referrer(nullptr),\n+    _last_referrer(),\n@@ -1401,2 +1655,2 @@\n-  oop last_referrer() const               { return _last_referrer; }\n-  void set_last_referrer(oop referrer)    { _last_referrer = referrer; }\n+  JvmtiHeapwalkObject last_referrer() const    { return _last_referrer; }\n+  void set_last_referrer(const JvmtiHeapwalkObject& referrer) { _last_referrer = referrer; }\n@@ -1475,2 +1729,1 @@\n-  static GrowableArray<oop>* _visit_stack;\n-  static JVMTIBitSet* _bitset;\n+  static JvmtiHeapwalkVisitStack* _visit_stack;\n@@ -1481,1 +1734,1 @@\n-  static GrowableArray<oop>* visit_stack()             { return _visit_stack; }\n+  static JvmtiHeapwalkVisitStack* visit_stack()        { return _visit_stack; }\n@@ -1485,2 +1738,2 @@\n-  static inline bool check_for_visit(oop obj) {\n-    if (!_bitset->is_marked(obj)) visit_stack()->push(obj);\n+  static inline bool check_for_visit(const JvmtiHeapwalkObject&obj) {\n+    visit_stack()->check_for_visit(obj);\n@@ -1490,0 +1743,10 @@\n+  \/\/ return element count if the obj is array, -1 otherwise\n+  static jint get_array_length(const JvmtiHeapwalkObject& obj) {\n+    if (!obj.klass()->is_array_klass()) {\n+      return -1;\n+    }\n+    assert(!obj.is_flat(), \"array cannot be flat\");\n+    return (jint)arrayOop(obj.obj())->length();\n+  }\n+\n+\n@@ -1492,1 +1755,1 @@\n-    (jvmtiHeapRootKind root_kind, oop obj);\n+    (jvmtiHeapRootKind root_kind, const JvmtiHeapwalkObject& obj);\n@@ -1495,1 +1758,1 @@\n-     int slot, oop obj);\n+     int slot, const JvmtiHeapwalkObject& obj);\n@@ -1497,1 +1760,1 @@\n-    (jvmtiObjectReferenceKind ref_kind, oop referrer, oop referree, jint index);\n+    (jvmtiObjectReferenceKind ref_kind, const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index);\n@@ -1501,1 +1764,1 @@\n-    (jvmtiHeapReferenceKind ref_kind, oop obj);\n+    (jvmtiHeapReferenceKind ref_kind, const JvmtiHeapwalkObject& obj);\n@@ -1504,1 +1767,1 @@\n-     jmethodID method, jlocation bci, jint slot, oop obj);\n+     jmethodID method, jlocation bci, jint slot, const JvmtiHeapwalkObject& obj);\n@@ -1506,1 +1769,1 @@\n-    (jvmtiHeapReferenceKind ref_kind, oop referrer, oop referree, jint index);\n+    (jvmtiHeapReferenceKind ref_kind, const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index);\n@@ -1510,1 +1773,1 @@\n-    (jvmtiHeapReferenceKind ref_kind, oop obj, jint index, address addr, char type);\n+    (jvmtiHeapReferenceKind ref_kind, const JvmtiHeapwalkObject& obj, jint index, address addr, char type);\n@@ -1515,1 +1778,0 @@\n-                                             GrowableArray<oop>* visit_stack,\n@@ -1518,1 +1780,1 @@\n-                                             JVMTIBitSet* bitset);\n+                                             JvmtiHeapwalkVisitStack* visit_stack);\n@@ -1522,1 +1784,0 @@\n-                                                GrowableArray<oop>* visit_stack,\n@@ -1525,1 +1786,1 @@\n-                                                JVMTIBitSet* bitset);\n+                                                JvmtiHeapwalkVisitStack* visit_stack);\n@@ -1528,1 +1789,1 @@\n-  static inline bool report_simple_root(jvmtiHeapReferenceKind kind, oop o);\n+  static inline bool report_simple_root(jvmtiHeapReferenceKind kind, const JvmtiHeapwalkObject& o);\n@@ -1530,1 +1791,1 @@\n-    jmethodID m, oop o);\n+    jmethodID m, const JvmtiHeapwalkObject& o);\n@@ -1532,1 +1793,1 @@\n-    jmethodID method, jlocation bci, jint slot, oop o);\n+    jmethodID method, jlocation bci, jint slot, const JvmtiHeapwalkObject& o);\n@@ -1535,14 +1796,14 @@\n-  static inline bool report_array_element_reference(oop referrer, oop referree, jint index);\n-  static inline bool report_class_reference(oop referrer, oop referree);\n-  static inline bool report_class_loader_reference(oop referrer, oop referree);\n-  static inline bool report_signers_reference(oop referrer, oop referree);\n-  static inline bool report_protection_domain_reference(oop referrer, oop referree);\n-  static inline bool report_superclass_reference(oop referrer, oop referree);\n-  static inline bool report_interface_reference(oop referrer, oop referree);\n-  static inline bool report_static_field_reference(oop referrer, oop referree, jint slot);\n-  static inline bool report_field_reference(oop referrer, oop referree, jint slot);\n-  static inline bool report_constant_pool_reference(oop referrer, oop referree, jint index);\n-  static inline bool report_primitive_array_values(oop array);\n-  static inline bool report_string_value(oop str);\n-  static inline bool report_primitive_instance_field(oop o, jint index, address value, char type);\n-  static inline bool report_primitive_static_field(oop o, jint index, address value, char type);\n+  static inline bool report_array_element_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index);\n+  static inline bool report_class_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_class_loader_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_signers_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_protection_domain_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_superclass_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_interface_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_static_field_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint slot);\n+  static inline bool report_field_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint slot);\n+  static inline bool report_constant_pool_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index);\n+  static inline bool report_primitive_array_values(const JvmtiHeapwalkObject& array);\n+  static inline bool report_string_value(const JvmtiHeapwalkObject& str);\n+  static inline bool report_primitive_instance_field(const JvmtiHeapwalkObject& o, jint index, address value, char type);\n+  static inline bool report_primitive_static_field(const JvmtiHeapwalkObject& o, jint index, address value, char type);\n@@ -1557,2 +1818,1 @@\n-GrowableArray<oop>* CallbackInvoker::_visit_stack;\n-JVMTIBitSet* CallbackInvoker::_bitset;\n+JvmtiHeapwalkVisitStack* CallbackInvoker::_visit_stack;\n@@ -1562,1 +1822,0 @@\n-                                                     GrowableArray<oop>* visit_stack,\n@@ -1565,1 +1824,1 @@\n-                                                     JVMTIBitSet* bitset) {\n+                                                     JvmtiHeapwalkVisitStack* visit_stack) {\n@@ -1567,1 +1826,0 @@\n-  _visit_stack = visit_stack;\n@@ -1572,1 +1830,1 @@\n-  _bitset = bitset;\n+  _visit_stack = visit_stack;\n@@ -1577,1 +1835,0 @@\n-                                                        GrowableArray<oop>* visit_stack,\n@@ -1580,1 +1837,1 @@\n-                                                        JVMTIBitSet* bitset) {\n+                                                        JvmtiHeapwalkVisitStack* visit_stack) {\n@@ -1582,1 +1839,0 @@\n-  _visit_stack = visit_stack;\n@@ -1587,1 +1843,1 @@\n-  _bitset = bitset;\n+  _visit_stack = visit_stack;\n@@ -1592,1 +1848,1 @@\n-inline bool CallbackInvoker::invoke_basic_heap_root_callback(jvmtiHeapRootKind root_kind, oop obj) {\n+inline bool CallbackInvoker::invoke_basic_heap_root_callback(jvmtiHeapRootKind root_kind, const JvmtiHeapwalkObject& obj) {\n@@ -1619,1 +1875,1 @@\n-                                                             oop obj) {\n+                                                             const JvmtiHeapwalkObject& obj) {\n@@ -1646,2 +1902,2 @@\n-                                                                    oop referrer,\n-                                                                    oop referree,\n+                                                                    const JvmtiHeapwalkObject& referrer,\n+                                                                    const JvmtiHeapwalkObject& referree,\n@@ -1658,1 +1914,1 @@\n-    referrer_tag = tag_for(tag_map(), referrer);\n+    referrer_tag = tag_map()->find(referrer);\n@@ -1690,1 +1946,1 @@\n-                                                                oop obj) {\n+                                                                const JvmtiHeapwalkObject& obj) {\n@@ -1715,1 +1971,1 @@\n-  jint len = (jint)(obj->is_array() ? arrayOop(obj)->length() : -1);\n+  jint len = get_array_length(obj);\n@@ -1744,1 +2000,1 @@\n-                                                                oop obj) {\n+                                                                const JvmtiHeapwalkObject& obj) {\n@@ -1778,1 +2034,1 @@\n-  jint len = (jint)(obj->is_array() ? arrayOop(obj)->length() : -1);\n+  jint len = get_array_length(obj);\n@@ -1811,2 +2067,2 @@\n-                                                                       oop referrer,\n-                                                                       oop obj,\n+                                                                       const JvmtiHeapwalkObject& referrer,\n+                                                                       const JvmtiHeapwalkObject& obj,\n@@ -1845,1 +2101,1 @@\n-  jint len = (jint)(obj->is_array() ? arrayOop(obj)->length() : -1);\n+  jint len = get_array_length(obj);\n@@ -1868,1 +2124,1 @@\n-inline bool CallbackInvoker::report_simple_root(jvmtiHeapReferenceKind kind, oop obj) {\n+inline bool CallbackInvoker::report_simple_root(jvmtiHeapReferenceKind kind, const JvmtiHeapwalkObject& obj) {\n@@ -1884,2 +2140,2 @@\n-inline bool CallbackInvoker::report_primitive_array_values(oop obj) {\n-  assert(obj->is_typeArray(), \"not a primitive array\");\n+inline bool CallbackInvoker::report_primitive_array_values(const JvmtiHeapwalkObject& obj) {\n+  assert(obj.klass()->is_typeArray_klass(), \"not a primitive array\");\n@@ -1913,2 +2169,2 @@\n-inline bool CallbackInvoker::report_string_value(oop str) {\n-  assert(str->klass() == vmClasses::String_klass(), \"not a string\");\n+inline bool CallbackInvoker::report_string_value(const JvmtiHeapwalkObject& str) {\n+  assert(str.klass() == vmClasses::String_klass(), \"not a string\");\n@@ -1943,1 +2199,1 @@\n-                                                    oop obj,\n+                                                    const JvmtiHeapwalkObject& obj,\n@@ -1991,1 +2247,1 @@\n-inline bool CallbackInvoker::report_primitive_instance_field(oop obj,\n+inline bool CallbackInvoker::report_primitive_instance_field(const JvmtiHeapwalkObject& obj,\n@@ -2003,1 +2259,1 @@\n-inline bool CallbackInvoker::report_primitive_static_field(oop obj,\n+inline bool CallbackInvoker::report_primitive_static_field(const JvmtiHeapwalkObject& obj,\n@@ -2015,1 +2271,1 @@\n-inline bool CallbackInvoker::report_jni_local_root(jlong thread_tag, jlong tid, jint depth, jmethodID m, oop obj) {\n+inline bool CallbackInvoker::report_jni_local_root(jlong thread_tag, jlong tid, jint depth, jmethodID m, const JvmtiHeapwalkObject& obj) {\n@@ -2042,1 +2298,1 @@\n-                                                   oop obj) {\n+                                                   const JvmtiHeapwalkObject& obj) {\n@@ -2063,1 +2319,1 @@\n-inline bool CallbackInvoker::report_class_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_class_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2072,1 +2328,1 @@\n-inline bool CallbackInvoker::report_class_loader_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_class_loader_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2081,1 +2337,1 @@\n-inline bool CallbackInvoker::report_signers_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_signers_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2090,1 +2346,1 @@\n-inline bool CallbackInvoker::report_protection_domain_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_protection_domain_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2099,1 +2355,1 @@\n-inline bool CallbackInvoker::report_superclass_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_superclass_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2109,1 +2365,1 @@\n-inline bool CallbackInvoker::report_interface_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_interface_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2118,1 +2374,1 @@\n-inline bool CallbackInvoker::report_static_field_reference(oop referrer, oop referree, jint slot) {\n+inline bool CallbackInvoker::report_static_field_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint slot) {\n@@ -2127,1 +2383,1 @@\n-inline bool CallbackInvoker::report_array_element_reference(oop referrer, oop referree, jint index) {\n+inline bool CallbackInvoker::report_array_element_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index) {\n@@ -2136,1 +2392,1 @@\n-inline bool CallbackInvoker::report_field_reference(oop referrer, oop referree, jint slot) {\n+inline bool CallbackInvoker::report_field_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint slot) {\n@@ -2145,1 +2401,1 @@\n-inline bool CallbackInvoker::report_constant_pool_reference(oop referrer, oop referree, jint index) {\n+inline bool CallbackInvoker::report_constant_pool_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index) {\n@@ -2272,1 +2528,1 @@\n-  _thread_tag = tag_for(_tag_map, _threadObj);\n+  _thread_tag = _tag_map->find(_threadObj);\n@@ -2405,4 +2661,0 @@\n-  enum {\n-    initial_visit_stack_size = 4000\n-  };\n-\n@@ -2412,3 +2664,1 @@\n-  GrowableArray<oop>* _visit_stack;                 \/\/ the visit stack\n-\n-  JVMTIBitSet _bitset;\n+  JvmtiHeapwalkVisitStack _visit_stack;\n@@ -2425,4 +2675,0 @@\n-  GrowableArray<oop>* create_visit_stack() {\n-    return new (mtServiceability) GrowableArray<oop>(initial_visit_stack_size, mtServiceability);\n-  }\n-\n@@ -2440,1 +2686,1 @@\n-  GrowableArray<oop>* visit_stack() const          { return _visit_stack; }\n+  JvmtiHeapwalkVisitStack* visit_stack()           { return &_visit_stack; }\n@@ -2443,4 +2689,5 @@\n-  inline bool iterate_over_array(oop o);\n-  inline bool iterate_over_type_array(oop o);\n-  inline bool iterate_over_class(oop o);\n-  inline bool iterate_over_object(oop o);\n+  inline bool iterate_over_array(const JvmtiHeapwalkObject& o);\n+  inline bool iterate_over_flat_array(const JvmtiHeapwalkObject& o);\n+  inline bool iterate_over_type_array(const JvmtiHeapwalkObject& o);\n+  inline bool iterate_over_class(const JvmtiHeapwalkObject& o);\n+  inline bool iterate_over_object(const JvmtiHeapwalkObject& o);\n@@ -2455,1 +2702,1 @@\n-  inline bool visit(oop o);\n+  inline bool visit(const JvmtiHeapwalkObject& o);\n@@ -2489,1 +2736,0 @@\n-  _visit_stack = create_visit_stack();\n@@ -2491,2 +2737,1 @@\n-\n-  CallbackInvoker::initialize_for_basic_heap_walk(tag_map, _visit_stack, user_data, callbacks, &_bitset);\n+  CallbackInvoker::initialize_for_basic_heap_walk(tag_map, user_data, callbacks, &_visit_stack);\n@@ -2507,1 +2752,0 @@\n-  _visit_stack = create_visit_stack();\n@@ -2509,1 +2753,1 @@\n-  CallbackInvoker::initialize_for_advanced_heap_walk(tag_map, _visit_stack, user_data, callbacks, &_bitset);\n+  CallbackInvoker::initialize_for_advanced_heap_walk(tag_map, user_data, callbacks, &_visit_stack);\n@@ -2513,5 +2757,0 @@\n-  if (_following_object_refs) {\n-    assert(_visit_stack != nullptr, \"checking\");\n-    delete _visit_stack;\n-    _visit_stack = nullptr;\n-  }\n@@ -2522,2 +2761,3 @@\n-inline bool VM_HeapWalkOperation::iterate_over_array(oop o) {\n-  objArrayOop array = objArrayOop(o);\n+inline bool VM_HeapWalkOperation::iterate_over_array(const JvmtiHeapwalkObject& o) {\n+  assert(!o.is_flat(), \"Array object cannot be flattened\");\n+  objArrayOop array = objArrayOop(o.obj());\n@@ -2547,0 +2787,38 @@\n+\/\/ similar to iterate_over_array(), but itrates over flat array\n+inline bool VM_HeapWalkOperation::iterate_over_flat_array(const JvmtiHeapwalkObject& o) {\n+  assert(!o.is_flat(), \"Array object cannot be flattened\");\n+  flatArrayOop array = flatArrayOop(o.obj());\n+  FlatArrayKlass* faklass = FlatArrayKlass::cast(array->klass());\n+  InlineKlass* vk = InlineKlass::cast(faklass->element_klass());\n+  bool need_null_check = faklass->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT;\n+\n+  \/\/ array reference to its class\n+  oop mirror = faklass->java_mirror();\n+  if (!CallbackInvoker::report_class_reference(o, mirror)) {\n+    return false;\n+  }\n+\n+  \/\/ iterate over the array and report each reference to a\n+  \/\/ non-null element\n+  for (int index = 0; index < array->length(); index++) {\n+    address addr = (address)array->value_at_addr(index, faklass->layout_helper());\n+\n+    \/\/ check for null\n+    if (need_null_check) {\n+      if (vk->is_payload_marked_as_null(addr)) {\n+        continue;\n+      }\n+    }\n+\n+    \/\/ offset in the array oop\n+    int offset = (int)(addr - cast_from_oop<address>(array));\n+    JvmtiHeapwalkObject elem(o.obj(), offset, vk, faklass->layout_kind());\n+\n+    \/\/ report the array reference\n+    if (!CallbackInvoker::report_array_element_reference(o, elem, index)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2548,2 +2826,3 @@\n-inline bool VM_HeapWalkOperation::iterate_over_type_array(oop o) {\n-  Klass* k = o->klass();\n+inline bool VM_HeapWalkOperation::iterate_over_type_array(const JvmtiHeapwalkObject& o) {\n+  assert(!o.is_flat(), \"Array object cannot be flattened\");\n+  Klass* k = o.klass();\n@@ -2583,1 +2862,3 @@\n-inline bool VM_HeapWalkOperation::iterate_over_class(oop java_class) {\n+inline bool VM_HeapWalkOperation::iterate_over_class(const JvmtiHeapwalkObject& o) {\n+  assert(!o.is_flat(), \"Klass object cannot be flattened\");\n+  Klass* klass = java_lang_Class::as_Klass(o.obj());\n@@ -2585,1 +2866,0 @@\n-  Klass* klass = java_lang_Class::as_Klass(java_class);\n@@ -2596,1 +2876,2 @@\n-    oop mirror = klass->java_mirror();\n+    oop mirror_oop = klass->java_mirror();\n+    JvmtiHeapwalkObject mirror(mirror_oop);\n@@ -2685,2 +2966,2 @@\n-        oop fld_o = mirror->obj_field(field->field_offset());\n-        assert(verify_static_oop(ik, mirror, field->field_offset()), \"sanity check\");\n+        oop fld_o = mirror_oop->obj_field(field->field_offset());\n+        assert(verify_static_oop(ik, mirror_oop, field->field_offset()), \"sanity check\");\n@@ -2696,1 +2977,1 @@\n-           address addr = cast_from_oop<address>(mirror) + field->field_offset();\n+           address addr = cast_from_oop<address>(mirror_oop) + field->field_offset();\n@@ -2716,1 +2997,1 @@\n-inline bool VM_HeapWalkOperation::iterate_over_object(oop o) {\n+inline bool VM_HeapWalkOperation::iterate_over_object(const JvmtiHeapwalkObject& o) {\n@@ -2718,1 +2999,1 @@\n-  if (!CallbackInvoker::report_class_reference(o, o->klass()->java_mirror())) {\n+  if (!CallbackInvoker::report_class_reference(o, o.klass()->java_mirror())) {\n@@ -2723,1 +3004,1 @@\n-  ClassFieldMap* field_map = JvmtiCachedClassFieldMap::get_map_of_instance_fields(o);\n+  ClassFieldMap* field_map = JvmtiCachedClassFieldMap::get_map_of_instance_fields(o.klass());\n@@ -2727,0 +3008,6 @@\n+    int slot = field->field_index();\n+    int field_offset = field->field_offset();\n+    if (o.is_flat()) {\n+      \/\/ the object is inlined, its fields are stored without the header\n+      field_offset += o.offset() - o.inline_klass()->payload_offset();\n+    }\n@@ -2728,7 +3015,11 @@\n-      oop fld_o = o->obj_field_access<AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF>(field->field_offset());\n-      \/\/ ignore any objects that aren't visible to profiler\n-      if (fld_o != nullptr) {\n-        assert(Universe::heap()->is_in(fld_o), \"unsafe code should not \"\n-               \"have references to Klass* anymore\");\n-        int slot = field->field_index();\n-        if (!CallbackInvoker::report_field_reference(o, fld_o, slot)) {\n+      if (field->is_flat()) {\n+        \/\/ check for possible nulls\n+        bool can_be_null = field->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT;\n+        if (can_be_null) {\n+          address payload = cast_from_oop<address>(o.obj()) + field_offset;\n+          if (field->inline_klass()->is_payload_marked_as_null(payload)) {\n+            continue;\n+          }\n+        }\n+        JvmtiHeapwalkObject field_obj(o.obj(), field_offset, field->inline_klass(), field->layout_kind());\n+        if (!CallbackInvoker::report_field_reference(o, field_obj, slot)) {\n@@ -2737,0 +3028,9 @@\n+      } else {\n+        oop fld_o = o.obj()->obj_field_access<AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF>(field_offset);\n+        \/\/ ignore any objects that aren't visible to profiler\n+        if (fld_o != nullptr) {\n+          assert(Universe::heap()->is_in(fld_o), \"unsafe code should not have references to Klass* anymore\");\n+          if (!CallbackInvoker::report_field_reference(o, fld_o, slot)) {\n+            return false;\n+          }\n+        }\n@@ -2741,2 +3041,1 @@\n-        address addr = cast_from_oop<address>(o) + field->field_offset();\n-        int slot = field->field_index();\n+        address addr = cast_from_oop<address>(o.obj()) + field_offset;\n@@ -2752,1 +3051,1 @@\n-      o->klass() == vmClasses::String_klass()) {\n+      o.klass() == vmClasses::String_klass()) {\n@@ -2821,1 +3120,1 @@\n-    blk->set_context(tag_for(_tag_map, threadObj), java_lang_Thread::thread_id(threadObj), 0, (jmethodID)nullptr);\n+    blk->set_context(_tag_map->find(threadObj), java_lang_Thread::thread_id(threadObj), 0, (jmethodID)nullptr);\n@@ -2921,1 +3220,1 @@\n-bool VM_HeapWalkOperation::visit(oop o) {\n+bool VM_HeapWalkOperation::visit(const JvmtiHeapwalkObject& o) {\n@@ -2923,2 +3222,2 @@\n-  assert(!_bitset.is_marked(o), \"can't visit same object more than once\");\n-  _bitset.mark_obj(o);\n+  assert(!visit_stack()->is_visited(o), \"can't visit same object more than once\");\n+  visit_stack()->mark_visited(o);\n@@ -2926,0 +3225,1 @@\n+  Klass* klass = o.klass();\n@@ -2927,3 +3227,4 @@\n-  if (o->is_instance()) {\n-    if (o->klass() == vmClasses::Class_klass()) {\n-      if (!java_lang_Class::is_primitive(o)) {\n+  if (klass->is_instance_klass()) {\n+    if (klass == vmClasses::Class_klass()) {\n+      assert(!o.is_flat(), \"Class object cannot be flattened\");\n+      if (!java_lang_Class::is_primitive(o.obj())) {\n@@ -2936,2 +3237,3 @@\n-      if (initial_object().is_null() && java_lang_VirtualThread::is_subclass(o->klass())) {\n-        if (!collect_vthread_stack_refs(o)) {\n+      if (initial_object().is_null() && java_lang_VirtualThread::is_subclass(klass)) {\n+        assert(!o.is_flat(), \"VirtualThread object cannot be flattened\");\n+        if (!collect_vthread_stack_refs(o.obj())) {\n@@ -2945,0 +3247,5 @@\n+  \/\/ flat object array\n+  if (klass->is_flatArray_klass()) {\n+      return iterate_over_flat_array(o);\n+  }\n+\n@@ -2946,1 +3253,1 @@\n-  if (o->is_objArray()) {\n+  if (klass->is_objArray_klass()) {\n@@ -2951,1 +3258,1 @@\n-  if (o->is_typeArray()) {\n+  if (klass->is_typeArray_klass()) {\n@@ -2983,2 +3290,2 @@\n-      oop o = visit_stack()->pop();\n-      if (!_bitset.is_marked(o)) {\n+      const JvmtiHeapwalkObject o = visit_stack()->pop();\n+      if (!visit_stack()->is_visited(o)) {\n@@ -3013,0 +3320,2 @@\n+  convert_flat_object_entries();\n+\n@@ -3035,0 +3344,2 @@\n+  convert_flat_object_entries();\n+\n@@ -3067,0 +3378,2 @@\n+  convert_flat_object_entries();\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":541,"deletions":228,"binary":false,"changes":769,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class JvmtiFlatTagMapTable;\n@@ -36,0 +37,1 @@\n+class JvmtiHeapwalkObject;\n@@ -43,0 +45,2 @@\n+  JvmtiFlatTagMapTable* _flat_hashmap;\n+\n@@ -48,0 +52,2 @@\n+  bool                  _converting_flat_object;\n+\n@@ -56,1 +62,8 @@\n-  void entry_iterate(JvmtiTagMapKeyClosure* closure);\n+  \/\/ moves entries from _flat_hashmap to _hashmap\n+  void convert_flat_object_entries();\n+\n+ public:\n+  \/\/ for inernal use\n+  jlong find(const JvmtiHeapwalkObject& obj) const;\n+  void add(const JvmtiHeapwalkObject& obj, jlong tag);\n+  void remove(const JvmtiHeapwalkObject& obj);\n@@ -60,1 +73,2 @@\n-  bool is_locked()                          { return lock()->is_locked(); }\n+  bool is_locked() const                    { return lock()->is_locked(); }\n+  inline const Monitor* lock() const        { return &_lock; }\n@@ -63,2 +77,0 @@\n-  JvmtiTagMapTable* hashmap() { return _hashmap; }\n-\n@@ -66,1 +78,1 @@\n-  bool is_empty();\n+  bool is_empty() const;\n@@ -68,1 +80,1 @@\n-  \/\/ return tag for the given environment\n+  \/\/ return tag map for the given environment\n@@ -121,1 +133,1 @@\n-  void clear();  \/\/ Clear tagmap table after the env is disposed.\n+  void clear();  \/\/ Clear hash tables after the env is disposed.\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -34,26 +35,5 @@\n-JvmtiTagMapKey::JvmtiTagMapKey(oop obj) : _obj(obj) {}\n-\n-JvmtiTagMapKey::JvmtiTagMapKey(const JvmtiTagMapKey& src) : _h() {\n-  \/\/ move object into Handle when copying into the table\n-  if (src._obj != nullptr) {\n-    _is_weak = !src._obj->klass()->is_inline_klass();\n-\n-    \/\/ obj was read with AS_NO_KEEPALIVE, or equivalent, like during\n-    \/\/ a heap walk.  The object needs to be kept alive when it is published.\n-    Universe::heap()->keep_alive(src._obj);\n-\n-    if (_is_weak) {\n-      _wh = WeakHandle(JvmtiExport::weak_tag_storage(), src._obj);\n-    } else {\n-      _h = OopHandle(JvmtiExport::jvmti_oop_storage(), src._obj);\n-    }\n-  } else {\n-    \/\/ resizing needs to create a copy.\n-    if (_is_weak) {\n-      _wh = src._wh;\n-    } else {\n-      _h = src._h;\n-    }\n-  }\n-  \/\/ obj is always null after a copy.\n-  _obj = nullptr;\n+static unsigned get_value_object_hash(oop holder, int offset, Klass* klass) {\n+  assert(klass->is_inline_klass(), \"Must be InlineKlass\");\n+  \/\/ For inline types, use the klass as a hash code and let the equals match the obj.\n+  \/\/ It might have a long bucket but TBD to improve this if a customer situation arises.\n+  return (unsigned)((int64_t)klass >> 3);\n@@ -62,28 +42,3 @@\n-void JvmtiTagMapKey::release_handle() {\n-  if (_is_weak) {\n-    _wh.release(JvmtiExport::weak_tag_storage());\n-  } else {\n-    _h.release(JvmtiExport::jvmti_oop_storage());\n-  }\n-}\n-\n-oop JvmtiTagMapKey::object() const {\n-  assert(_obj == nullptr, \"Must have a handle and not object\");\n-  return _is_weak ? _wh.resolve() : _h.resolve();\n-}\n-\n-oop JvmtiTagMapKey::object_no_keepalive() const {\n-  assert(_obj == nullptr, \"Must have a handle and not object\");\n-  return _is_weak ? _wh.peek() : _h.peek();\n-}\n-\n-unsigned JvmtiTagMapKey::get_hash(const JvmtiTagMapKey& entry) {\n-  oop obj = entry._obj;\n-  assert(obj != nullptr, \"must lookup obj to hash\");\n-  if (obj->is_inline_type()) {\n-    \/\/ For inline types, use the klass as a hash code and let the equals match the obj.\n-    \/\/ It might have a long bucket but TBD to improve this if a customer situation arises.\n-    return (unsigned)((int64_t)obj->klass() >> 3);\n-  } else {\n-    return (unsigned)obj->identity_hash();\n-  }\n+static unsigned get_value_object_hash(const JvmtiHeapwalkObject & obj) {\n+  assert(obj.is_value(), \"Must be value class\");\n+  return get_value_object_hash(obj.obj(), obj.offset(), obj.inline_klass());\n@@ -94,1 +49,1 @@\n-static bool equal_fields(char type, oop obj1, oop obj2, int offset) {\n+static bool equal_fields(char type, oop obj1, int offset1, oop obj2, int offset2) {\n@@ -97,1 +52,1 @@\n-    return obj1->bool_field(offset) == obj2->bool_field(offset);\n+    return obj1->bool_field(offset1) == obj2->bool_field(offset2);\n@@ -99,1 +54,1 @@\n-    return obj1->char_field(offset) == obj2->char_field(offset);\n+    return obj1->char_field(offset1) == obj2->char_field(offset2);\n@@ -101,1 +56,1 @@\n-    return obj1->float_field(offset) == obj2->float_field(offset);\n+    return obj1->float_field(offset1) == obj2->float_field(offset2);\n@@ -103,1 +58,1 @@\n-    return obj1->double_field(offset) == obj2->double_field(offset);\n+    return obj1->double_field(offset1) == obj2->double_field(offset2);\n@@ -105,1 +60,1 @@\n-    return obj1->byte_field(offset) == obj2->byte_field(offset);\n+    return obj1->byte_field(offset1) == obj2->byte_field(offset2);\n@@ -107,1 +62,1 @@\n-    return obj1->short_field(offset) == obj2->short_field(offset);\n+    return obj1->short_field(offset1) == obj2->short_field(offset2);\n@@ -109,1 +64,1 @@\n-    return obj1->int_field(offset) == obj2->int_field(offset);\n+    return obj1->int_field(offset1) == obj2->int_field(offset2);\n@@ -111,1 +66,1 @@\n-    return obj1->long_field(offset) == obj2->long_field(offset);\n+    return obj1->long_field(offset1) == obj2->long_field(offset2);\n@@ -114,1 +69,1 @@\n-    return equal_oops(obj1->obj_field(offset), obj2->obj_field(offset));\n+    return equal_oops(obj1->obj_field(offset1), obj2->obj_field(offset2));\n@@ -119,0 +74,4 @@\n+static bool is_null_flat_field(oop obj, int offset, InlineKlass* klass) {\n+  return klass->is_payload_marked_as_null(cast_from_oop<address>(obj) + offset);\n+}\n+\n@@ -121,1 +80,2 @@\n-static bool equal_value_objects(oop obj1, oop obj2, InlineKlass* klass, int offset) {\n+\/\/ The object must be prechecked for non-null values.\n+static bool equal_value_objects(oop obj1, int offset1, oop obj2, int offset2, InlineKlass* klass) {\n@@ -127,1 +87,2 @@\n-    int field_offset = offset + fld.offset() - (offset > 0 ? klass->payload_offset() : 0);\n+    int field_offset1 = offset1 + fld.offset() - (offset1 > 0 ? klass->payload_offset() : 0);\n+    int field_offset2 = offset2 + fld.offset() - (offset2 > 0 ? klass->payload_offset() : 0);\n@@ -131,1 +92,12 @@\n-      if (!equal_value_objects(obj1, obj2, field_klass, field_offset)) {\n+      if (!fld.is_null_free_inline_type()) {\n+        bool field1_is_null = is_null_flat_field(obj1, field_offset1, field_klass);\n+        bool field2_is_null = is_null_flat_field(obj2, field_offset2, field_klass);\n+        if (field1_is_null != field2_is_null) {\n+          return false;\n+        }\n+        if (field1_is_null) { \/\/ if both fields are null, go to next field\n+          continue;\n+        }\n+      }\n+\n+      if (!equal_value_objects(obj1, field_offset1, obj2, field_offset2, field_klass)) {\n@@ -135,1 +107,1 @@\n-      if (!equal_fields(fld.signature()->char_at(0), obj1, obj2, field_offset)) {\n+      if (!equal_fields(fld.signature()->char_at(0), obj1, field_offset1, obj2, field_offset2)) {\n@@ -143,0 +115,1 @@\n+\/\/ handles null oops\n@@ -148,5 +121,3 @@\n-  if (EnableValhalla) {\n-    if (obj1 != nullptr && obj2 != nullptr && obj1->klass() == obj2->klass() && obj1->is_inline_type()) {\n-      InlineKlass* vk = InlineKlass::cast(obj1->klass());\n-      return equal_value_objects(obj1, obj2, vk, 0);\n-    }\n+  if (obj1 != nullptr && obj2 != nullptr && obj1->klass() == obj2->klass() && obj1->is_inline_type()) {\n+    InlineKlass* vk = InlineKlass::cast(obj1->klass());\n+    return equal_value_objects(obj1, 0, obj2, 0, vk);\n@@ -157,4 +128,11 @@\n-bool JvmtiTagMapKey::equals(const JvmtiTagMapKey& lhs, const JvmtiTagMapKey& rhs) {\n-  oop lhs_obj = lhs._obj != nullptr ? lhs._obj : lhs.object_no_keepalive();\n-  oop rhs_obj = rhs._obj != nullptr ? rhs._obj : rhs.object_no_keepalive();\n-  return equal_oops(lhs_obj, rhs_obj);\n+\n+bool JvmtiHeapwalkObject::equals(const JvmtiHeapwalkObject& obj1, const JvmtiHeapwalkObject& obj2) {\n+  if (obj1 == obj2) { \/\/ the same oop\/offset\/inline_klass\n+    return true;\n+  }\n+\n+  if (obj1.is_value() && obj1.inline_klass() == obj2.inline_klass()) {\n+    \/\/ instances of the same value class\n+    return equal_value_objects(obj1.obj(), obj1.offset(), obj2.obj(), obj2.offset(), obj1.inline_klass());\n+  }\n+  return false;\n@@ -163,3 +141,69 @@\n-\/\/ Inline types don't use hash for this table.\n-static inline bool fast_no_hash_check(oop obj) {\n-  return (obj->fast_no_hash_check() && !obj->is_inline_type());\n+\n+JvmtiTagMapKey::JvmtiTagMapKey(const JvmtiHeapwalkObject* obj) : _obj(obj) {\n+}\n+\n+JvmtiTagMapKey::JvmtiTagMapKey(const JvmtiTagMapKey& src): _h() {\n+  if (src._obj != nullptr) {\n+    \/\/ move object into Handle when copying into the table\n+    assert(!src._obj->is_flat(), \"cannot put flat object to JvmtiTagMapKey\");\n+    _is_weak = !src._obj->is_value();\n+\n+    \/\/ obj was read with AS_NO_KEEPALIVE, or equivalent, like during\n+    \/\/ a heap walk.  The object needs to be kept alive when it is published.\n+    Universe::heap()->keep_alive(src._obj->obj());\n+\n+    if (_is_weak) {\n+      _wh = WeakHandle(JvmtiExport::weak_tag_storage(), src._obj->obj());\n+    } else {\n+      _h = OopHandle(JvmtiExport::jvmti_oop_storage(), src._obj->obj());\n+    }\n+  } else {\n+    \/\/ resizing needs to create a copy.\n+    _is_weak = src._is_weak;\n+    if (_is_weak) {\n+      _wh = src._wh;\n+    } else {\n+      _h = src._h;\n+    }\n+  }\n+  \/\/ obj is always null after a copy.\n+  _obj = nullptr;\n+}\n+\n+void JvmtiTagMapKey::release_handle() {\n+  if (_is_weak) {\n+    _wh.release(JvmtiExport::weak_tag_storage());\n+  } else {\n+    _h.release(JvmtiExport::jvmti_oop_storage());\n+  }\n+}\n+\n+JvmtiHeapwalkObject JvmtiTagMapKey::heapwalk_object() const {\n+  return _obj != nullptr ? JvmtiHeapwalkObject(_obj->obj(), _obj->offset(), _obj->inline_klass(), _obj->layout_kind())\n+                         : JvmtiHeapwalkObject(object_no_keepalive());\n+}\n+\n+oop JvmtiTagMapKey::object() const {\n+  assert(_obj == nullptr, \"Must have a handle and not object\");\n+  return _is_weak ? _wh.resolve() : _h.resolve();\n+}\n+\n+oop JvmtiTagMapKey::object_no_keepalive() const {\n+  assert(_obj == nullptr, \"Must have a handle and not object\");\n+  return _is_weak ? _wh.peek() : _h.peek();\n+}\n+\n+unsigned JvmtiTagMapKey::get_hash(const JvmtiTagMapKey& entry) {\n+  const JvmtiHeapwalkObject* obj = entry._obj;\n+  assert(obj != nullptr, \"must lookup obj to hash\");\n+  if (obj->is_value()) {\n+    return get_value_object_hash(*obj);\n+  } else {\n+    return (unsigned)obj->obj()->identity_hash();\n+  }\n+}\n+\n+bool JvmtiTagMapKey::equals(const JvmtiTagMapKey& lhs, const JvmtiTagMapKey& rhs) {\n+  JvmtiHeapwalkObject lhs_obj = lhs.heapwalk_object();\n+  JvmtiHeapwalkObject rhs_obj = rhs.heapwalk_object();\n+  return JvmtiHeapwalkObject::equals(lhs_obj, rhs_obj);\n@@ -193,1 +237,1 @@\n-jlong JvmtiTagMapTable::find(oop obj) {\n+jlong* JvmtiTagMapTable::lookup(const JvmtiHeapwalkObject& obj) const {\n@@ -198,3 +242,5 @@\n-  if (fast_no_hash_check(obj)) {\n-    \/\/ Objects in the table all have a hashcode, unless inlined types.\n-    return 0;\n+  if (!obj.is_value()) {\n+    if (obj.obj()->fast_no_hash_check()) {\n+      \/\/ Objects in the table all have a hashcode, unless inlined types.\n+      return nullptr;\n+    }\n@@ -202,0 +248,5 @@\n+  JvmtiTagMapKey entry(&obj);\n+  jlong* found = _table.get(entry);\n+  return found;\n+}\n+\n@@ -203,2 +254,2 @@\n-  JvmtiTagMapKey jtme(obj);\n-  jlong* found = _table.get(jtme);\n+jlong JvmtiTagMapTable::find(const JvmtiHeapwalkObject& obj) const {\n+  jlong* found = lookup(obj);\n@@ -208,2 +259,3 @@\n-void JvmtiTagMapTable::add(oop obj, jlong tag) {\n-  JvmtiTagMapKey new_entry(obj);\n+void JvmtiTagMapTable::add(const JvmtiHeapwalkObject& obj, jlong tag) {\n+  assert(!obj.is_flat(), \"Cannot add flat object to JvmtiTagMapTable\");\n+  JvmtiTagMapKey new_entry(&obj);\n@@ -211,1 +263,1 @@\n-  if (fast_no_hash_check(obj)) {\n+  if (!obj.is_value() && obj.obj()->fast_no_hash_check()) {\n@@ -227,3 +279,12 @@\n-void JvmtiTagMapTable::remove(oop obj) {\n-  JvmtiTagMapKey jtme(obj);\n-  auto clean = [] (JvmtiTagMapKey& entry, jlong tag) {\n+bool JvmtiTagMapTable::update(const JvmtiHeapwalkObject& obj, jlong tag) {\n+  jlong* found = lookup(obj);\n+  if (found == nullptr) {\n+    return false;\n+  }\n+  *found = tag;\n+  return true;\n+}\n+\n+bool JvmtiTagMapTable::remove(const JvmtiHeapwalkObject& obj) {\n+  JvmtiTagMapKey entry(&obj);\n+  auto clean = [](JvmtiTagMapKey & entry, jlong tag) {\n@@ -232,1 +293,1 @@\n-  _table.remove(jtme, clean);\n+  return _table.remove(entry, clean);\n@@ -256,0 +317,117 @@\n+\n+\n+JvmtiFlatTagMapKey::JvmtiFlatTagMapKey(const JvmtiHeapwalkObject& obj)\n+  : _holder(obj.obj()), _offset(obj.offset()), _inline_klass(obj.inline_klass()), _layout_kind(obj.layout_kind()) {\n+}\n+\n+JvmtiFlatTagMapKey::JvmtiFlatTagMapKey(const JvmtiFlatTagMapKey& src) : _h() {\n+  \/\/ move object into Handle when copying into the table\n+  if (src._holder != nullptr) {\n+    \/\/ Holder object was read with AS_NO_KEEPALIVE. Needs to be kept alive when it is published.\n+    Universe::heap()->keep_alive(src._holder);\n+    _h = OopHandle(JvmtiExport::jvmti_oop_storage(), src._holder);\n+  } else {\n+    \/\/ resizing needs to create a copy.\n+    _h = src._h;\n+  }\n+  \/\/ holder object is always null after a copy.\n+  _holder = nullptr;\n+  _offset = src._offset;\n+  _inline_klass = src._inline_klass;\n+  _layout_kind = src._layout_kind;\n+}\n+\n+JvmtiHeapwalkObject JvmtiFlatTagMapKey::heapwalk_object() const {\n+  return JvmtiHeapwalkObject(_holder != nullptr ? _holder : holder_no_keepalive(), _offset, _inline_klass, _layout_kind);\n+}\n+\n+oop JvmtiFlatTagMapKey::holder() const {\n+  assert(_holder == nullptr, \"Must have a handle and not object\");\n+  return _h.resolve();\n+}\n+\n+oop JvmtiFlatTagMapKey::holder_no_keepalive() const {\n+  assert(_holder == nullptr, \"Must have a handle and not object\");\n+  return _h.peek();\n+\n+}\n+\n+void JvmtiFlatTagMapKey::release_handle() {\n+  _h.release(JvmtiExport::jvmti_oop_storage());\n+}\n+\n+unsigned JvmtiFlatTagMapKey::get_hash(const JvmtiFlatTagMapKey& entry) {\n+  return get_value_object_hash(entry._holder, entry._offset, entry._inline_klass);\n+}\n+\n+bool JvmtiFlatTagMapKey::equals(const JvmtiFlatTagMapKey& lhs, const JvmtiFlatTagMapKey& rhs) {\n+  if (lhs._inline_klass == rhs._inline_klass) {\n+    oop lhs_obj = lhs._holder != nullptr ? lhs._holder : lhs._h.peek();\n+    oop rhs_obj = rhs._holder != nullptr ? rhs._holder : rhs._h.peek();\n+    return equal_value_objects(lhs_obj, lhs._offset, rhs_obj, rhs._offset, lhs._inline_klass);\n+  }\n+  return false;\n+}\n+\n+\n+JvmtiFlatTagMapTable::JvmtiFlatTagMapTable(): _table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {}\n+\n+JvmtiFlatTagMapTable::~JvmtiFlatTagMapTable() {\n+  clear();\n+}\n+\n+jlong JvmtiFlatTagMapTable::find(const JvmtiHeapwalkObject& obj) const {\n+  if (is_empty()) {\n+    return 0;\n+  }\n+\n+  JvmtiFlatTagMapKey entry(obj);\n+  jlong* found = _table.get(entry);\n+  return found == nullptr ? 0 : *found;\n+}\n+\n+void JvmtiFlatTagMapTable::add(const JvmtiHeapwalkObject& obj, jlong tag) {\n+  assert(obj.is_value() && obj.is_flat(), \"Must be flattened value object\");\n+  JvmtiFlatTagMapKey entry(obj);\n+  bool is_added;\n+  jlong* value = _table.put_if_absent(entry, tag, &is_added);\n+  *value = tag; \/\/ assign the new tag\n+  if (is_added) {\n+    if (_table.maybe_grow(5, true \/* use_large_table_sizes *\/)) {\n+      int max_bucket_size = DEBUG_ONLY(_table.verify()) NOT_DEBUG(0);\n+      log_info(jvmti, table) (\"JvmtiFlatTagMapTable table resized to %d for %d entries max bucket %d\",\n+        _table.table_size(), _table.number_of_entries(), max_bucket_size);\n+    }\n+  }\n+}\n+\n+jlong JvmtiFlatTagMapTable::remove(const JvmtiHeapwalkObject& obj) {\n+  JvmtiFlatTagMapKey entry(obj);\n+  jlong ret = 0;\n+  auto clean = [&](JvmtiFlatTagMapKey& entry, jlong tag) {\n+    ret = tag;\n+    entry.release_handle();\n+  };\n+  _table.remove(entry, clean);\n+  return ret;\n+}\n+\n+void JvmtiFlatTagMapTable::entry_iterate(JvmtiFlatTagMapKeyClosure* closure) {\n+  _table.iterate(closure);\n+}\n+\n+void JvmtiFlatTagMapTable::clear() {\n+  struct RemoveAll {\n+    bool do_entry(JvmtiFlatTagMapKey& entry, const jlong& tag) {\n+      entry.release_handle();\n+      return true;\n+    }\n+  } remove_all;\n+  \/\/ The unlink method of ResourceHashTable gets a pointer to a type whose 'do_entry(K,V)' method is callled\n+  \/\/ while iterating over all the elements of the table. If the do_entry() method returns true the element\n+  \/\/ will be removed.\n+  \/\/ In this case, we always return true from do_entry to clear all the elements.\n+  _table.unlink(&remove_all);\n+\n+  assert(_table.number_of_entries() == 0, \"should have removed all entries\");\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":271,"deletions":93,"binary":false,"changes":364,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/layoutKind.hpp\"\n@@ -34,1 +35,42 @@\n-class JvmtiTagMapKeyClosure;\n+\n+\/\/ Describes an object which can be tagged during heap walk operation.\n+\/\/ - generic heap object: _obj: oop, offset == 0, _inline_klass == nullptr;\n+\/\/ - value heap object: _obj: oop, offset == 0, _inline_klass == _obj.klass();\n+\/\/ - flat value object: _obj: holder object, offset == offset in the holder, _inline_klass == klass of the flattened object;\n+class JvmtiHeapwalkObject {\n+  oop _obj;                   \/\/ for flattened value object this is holder object\n+  int _offset;                \/\/ == 0 for heap objects\n+  InlineKlass* _inline_klass; \/\/ for value object, nullptr otherwise\n+  LayoutKind _layout_kind;    \/\/ layout kind in holder object, used only for flat->heap conversion\n+\n+  static InlineKlass* inline_klass_or_null(oop obj) {\n+    Klass* k = obj->klass();\n+    return k->is_inline_klass() ? InlineKlass::cast(k) : nullptr;\n+  }\n+public:\n+  JvmtiHeapwalkObject(): _obj(nullptr), _offset(0), _inline_klass(nullptr), _layout_kind(LayoutKind::UNKNOWN) {}\n+  JvmtiHeapwalkObject(oop obj): _obj(obj), _offset(0), _inline_klass(inline_klass_or_null(obj)), _layout_kind(LayoutKind::REFERENCE) {}\n+  JvmtiHeapwalkObject(oop obj, int offset, InlineKlass* ik, LayoutKind lk): _obj(obj), _offset(offset), _inline_klass(ik), _layout_kind(lk) {}\n+\n+  inline bool is_empty() const { return _obj == nullptr; }\n+  inline bool is_value() const { return _inline_klass != nullptr; }\n+  inline bool is_flat() const { return _offset != 0; }\n+\n+  inline oop obj() const { return _obj; }\n+  inline int offset() const { return _offset; }\n+  inline InlineKlass* inline_klass() const { return _inline_klass; }\n+  inline LayoutKind layout_kind() const { return _layout_kind; }\n+\n+  inline Klass* klass() const { return is_value() ? _inline_klass : obj()->klass(); }\n+\n+  static bool equals(const JvmtiHeapwalkObject& obj1, const JvmtiHeapwalkObject& obj2);\n+\n+  bool operator==(const JvmtiHeapwalkObject& other) const {\n+    \/\/ need to compare inline_klass too to handle the case when flat object has flat field at offset 0\n+    return _obj == other._obj && _offset == other._offset && _inline_klass == other._inline_klass;\n+  }\n+  bool operator!=(const JvmtiHeapwalkObject& other) const {\n+    return !(*this == other);\n+  }\n+};\n+\n@@ -44,1 +86,1 @@\n-\/\/ Valhalla: Keep just one tag for all equal value objects including heap allocated value objects.\n+\/\/ Value objects: keep just one tag for all equal value objects including heap allocated value objects.\n@@ -46,0 +88,5 @@\n+\/\/ During heap walking flattened value object tags stored in separate JvmtiFlatTagMapTable,\n+\/\/ converted to standard strong entries in JvmtiTagMapTable outside of sefepoint.\n+\/\/ All equal value objects should have the same tag.\n+\/\/ Keep value objects alive (1 copy for each \"value\") until their tags are removed.\n+\n@@ -47,2 +94,0 @@\n-  \/\/ All equal value objects should have the same tag.\n-  \/\/ Keep value objects alive (1 copy for each \"value\") until their tags are removed.\n@@ -54,1 +99,3 @@\n-  oop _obj; \/\/ temporarily hold obj while searching\n+  \/\/ temporarily hold obj while searching\n+  const JvmtiHeapwalkObject* _obj;\n+\n@@ -56,1 +103,2 @@\n-  JvmtiTagMapKey(oop obj);\n+  JvmtiTagMapKey(const JvmtiHeapwalkObject* obj);\n+  \/\/ Copy ctor is called when we put entry to the hash table.\n@@ -58,0 +106,1 @@\n+\n@@ -60,0 +109,2 @@\n+  JvmtiHeapwalkObject heapwalk_object() const;\n+\n@@ -70,3 +121,9 @@\n-                              AnyObj::C_HEAP, mtServiceability,\n-                              JvmtiTagMapKey::get_hash,\n-                              JvmtiTagMapKey::equals> ResizableResourceHT;\n+                             AnyObj::C_HEAP, mtServiceability,\n+                             JvmtiTagMapKey::get_hash,\n+                             JvmtiTagMapKey::equals> ResizableResourceHT;\n+\n+\/\/ A supporting class for iterating over all entries in Hashmap\n+class JvmtiTagMapKeyClosure {\n+public:\n+  virtual bool do_entry(JvmtiTagMapKey& key, jlong& value) = 0;\n+};\n@@ -78,0 +135,2 @@\n+  jlong* lookup(const JvmtiHeapwalkObject& obj) const;\n+\n@@ -82,2 +141,7 @@\n-  jlong find(oop obj);\n-  void add(oop obj, jlong tag);\n+  int number_of_entries() const { return _table.number_of_entries(); }\n+\n+  jlong find(const JvmtiHeapwalkObject& obj) const;\n+  \/\/ obj cannot be flat\n+  void add(const JvmtiHeapwalkObject& obj, jlong tag);\n+  \/\/ update the tag if the entry exists, returns false otherwise\n+  bool update(const JvmtiHeapwalkObject& obj, jlong tag);\n@@ -85,1 +149,1 @@\n-  void remove(oop obj);\n+  bool remove(const JvmtiHeapwalkObject& obj);\n@@ -97,4 +161,68 @@\n-\/\/ A supporting class for iterating over all entries in Hashmap\n-class JvmtiTagMapKeyClosure {\n- public:\n-  virtual bool do_entry(JvmtiTagMapKey& key, jlong& value) = 0;\n+\n+\/\/ This class is the Key type for hash table to keep flattened value objects during heap walk operations.\n+\/\/ The objects needs to be moved to JvmtiTagMapTable outside of safepoint.\n+class JvmtiFlatTagMapKey: public CHeapObj<mtServiceability> {\n+private:\n+  \/\/ holder object\n+  OopHandle _h;\n+  \/\/ temporarily holds holder object while searching\n+  oop _holder;\n+  int _offset;\n+  InlineKlass* _inline_klass;\n+  LayoutKind _layout_kind;\n+public:\n+  JvmtiFlatTagMapKey(const JvmtiHeapwalkObject& obj);\n+  \/\/ Copy ctor is called when we put entry to the hash table.\n+  JvmtiFlatTagMapKey(const JvmtiFlatTagMapKey& src);\n+\n+  JvmtiFlatTagMapKey& operator=(const JvmtiFlatTagMapKey&) = delete;\n+\n+  JvmtiHeapwalkObject heapwalk_object() const;\n+\n+  oop holder() const;\n+  oop holder_no_keepalive() const;\n+  int offset() const { return _offset; }\n+  InlineKlass* inline_klass() const { return _inline_klass; }\n+  LayoutKind layout_kind() const { return _layout_kind; }\n+\n+  void release_handle();\n+\n+  static unsigned get_hash(const JvmtiFlatTagMapKey& entry);\n+  static bool equals(const JvmtiFlatTagMapKey& lhs, const JvmtiFlatTagMapKey& rhs);\n+};\n+\n+typedef\n+ResizeableResourceHashtable <JvmtiFlatTagMapKey, jlong,\n+                             AnyObj::C_HEAP, mtServiceability,\n+                             JvmtiFlatTagMapKey::get_hash,\n+                             JvmtiFlatTagMapKey::equals> FlatObjectHashtable;\n+\n+\/\/ A supporting class for iterating over all entries in JvmtiFlatTagMapTable.\n+class JvmtiFlatTagMapKeyClosure {\n+public:\n+  virtual bool do_entry(JvmtiFlatTagMapKey& key, jlong& value) = 0;\n+};\n+\n+class JvmtiFlatTagMapTable: public CHeapObj<mtServiceability> {\n+private:\n+  FlatObjectHashtable _table;\n+\n+public:\n+  JvmtiFlatTagMapTable();\n+  ~JvmtiFlatTagMapTable();\n+\n+  int number_of_entries() const { return _table.number_of_entries(); }\n+\n+  jlong find(const JvmtiHeapwalkObject& obj) const;\n+  \/\/ obj must be flat\n+  void add(const JvmtiHeapwalkObject& obj, jlong tag);\n+\n+  \/\/ returns tag for the entry, 0 is not found\n+  jlong remove(const JvmtiHeapwalkObject& obj);\n+\n+  \/\/ iterate over entries in the hashmap\n+  void entry_iterate(JvmtiFlatTagMapKeyClosure* closure);\n+\n+  bool is_empty() const { return _table.number_of_entries() == 0; }\n+\n+  void clear();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":144,"deletions":16,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -0,0 +1,351 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests heapwalking API (FollowReferences, IterateThroughHeap, GetObjectsWithTags) for value objects.\n+ * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.vm.annotation java.base\/jdk.internal.value\n+ * @enablePreview\n+ * @run main\/othervm\/native -agentlib:ValueHeapwalkingTest\n+ *                          -XX:+UnlockDiagnosticVMOptions\n+ *                          -XX:+UseArrayFlattening\n+ *                          -XX:+UseFieldFlattening\n+ *                          -XX:+UseAtomicValueFlattening\n+ *                          -XX:+UseNullableValueFlattening\n+ *                          -XX:+PrintInlineLayout\n+ *                          -XX:+PrintFlatArrayLayout\n+ *                          -Xlog:jvmti+table\n+ *                          ValueHeapwalkingTest\n+ *\/\n+\n+import java.lang.ref.Reference;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+import java.lang.reflect.Field;\n+\n+public class ValueHeapwalkingTest {\n+\n+    static value class Value {\n+        int v;\n+        Value() {\n+            this(0);\n+        }\n+        Value(int v) {\n+            this.v = v;\n+        }\n+    }\n+\n+    \/\/ flat object has flat field (address of the field is the same as address of the object)\n+    static value class Value2 {\n+        @Strict\n+        @NullRestricted\n+        public Value v1;\n+        @Strict\n+        @NullRestricted\n+        public Value v2;\n+        Value2() {\n+            this(0);\n+        }\n+        Value2(int i) {\n+            this.v1 = new Value(i);\n+            this.v2 = new Value(i+1);\n+            super();\n+        }\n+    }\n+\n+    static value class ValueHolder {\n+        public Value v1;\n+        @Strict\n+        @NullRestricted\n+        public Value v2;\n+        public Value v_null;\n+\n+        public Value2 v2_1;\n+        @Strict\n+        @NullRestricted\n+        public Value2 v2_2;\n+\n+        public Value[] v_arr;\n+        public Value2[] v2_arr;\n+\n+        public ValueHolder(int seed) throws Exception {\n+            v1 = new Value(seed);\n+            v2 = new Value(seed + 1);\n+            v_null = null;\n+\n+            v2_1 = new Value2(seed + 6);\n+            v2_2 = new Value2(seed + 8);\n+\n+            v_arr = createValueArray(seed);\n+            v2_arr = createValue2Array(seed);\n+        }\n+    }\n+\n+    static Value[] createValueArray(int seed) throws Exception {\n+        Value[] arr = (Value[])ValueClass.newNullableAtomicArray(Value.class, 5);\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = i == 2 ? null : new Value(seed + 10 + i);\n+        }\n+        return arr;\n+    }\n+\n+    static Value2[] createValue2Array(int seed) throws Exception {\n+        Value2[] arr = (Value2[])ValueClass.newNullRestrictedNonAtomicArray(Value2.class, 5, Value2.class.newInstance());\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = new Value2(seed + 20 + i * 2);\n+        }\n+        return arr;\n+    }\n+\n+    static final int TAG_VALUE_CLASS = 1;\n+    static final int TAG_VALUE2_CLASS = 2;\n+    static final int TAG_HOLDER_CLASS = 3;\n+    static final int TAG_VALUE_ARRAY = 4;\n+    static final int TAG_VALUE2_ARRAY = 5;\n+\n+    static final int TAG_MIN = TAG_VALUE_CLASS;\n+    static final int TAG_MAX = TAG_VALUE2_ARRAY;\n+\n+    static String tagStr(int tag) {\n+        String suffix = \" (tag \" + tag + \")\";\n+        switch (tag) {\n+        case TAG_VALUE_CLASS: return \"Value class\" + suffix;\n+        case TAG_VALUE2_CLASS: return \"Value2 class\" + suffix;\n+        case TAG_HOLDER_CLASS: return \"ValueHolder class\" + suffix;\n+        case TAG_VALUE_ARRAY: return \"Value[] object\" + suffix;\n+        case TAG_VALUE2_ARRAY: return \"Value2[] object\" + suffix;\n+        }\n+        return \"Unknown\" + suffix;\n+    }\n+\n+    static native void setTag(Object object, long tag);\n+    static native long getTag(Object object);\n+\n+    static native void reset();\n+\n+    static native void followReferences();\n+\n+    static native void iterateThroughHeap();\n+\n+    static native int count(int classTag);\n+    static native int refCount(int fromTag, int toTag);\n+    static native int primitiveFieldCount(int tag);\n+\n+    static native long getMaxTag();\n+\n+    static native int getObjectWithTags(long minTag, long maxTag, Object[] objects, long[] tags);\n+\n+\n+    \/\/ counts non-null elements in the array\n+    static <T> int nonNullCount(T[] array) {\n+        return (int)Arrays.stream(array).filter(e -> e != null).count();\n+    }\n+\n+    static void verifyMinCount(int classTag, int minCount) {\n+        int count = count(classTag);\n+        String msg = tagStr(classTag) + \" count: \" + count + \", min expected: \" + minCount;\n+        if (count < minCount) {\n+            throw new RuntimeException(msg);\n+        }\n+        System.out.println(msg);\n+    }\n+\n+    static void verifyRefCount(int tagFrom, int tagTo, int expectedCount) {\n+        int count = refCount(tagFrom, tagTo);\n+        String msg = \"Ref.count from \" + tagStr(tagFrom) + \" to \" + tagStr(tagTo) + \": \"\n+                   + count + \", expected: \" + expectedCount;\n+        if (count !=  expectedCount) {\n+            throw new RuntimeException(msg);\n+        }\n+        System.out.println(msg);\n+    }\n+\n+    static void verifyPrimitiveFieldCount(int classTag, int expectedCount) {\n+        int count = primitiveFieldCount(classTag);\n+        String msg = \"Primitive field count from \" + tagStr(classTag) + \": \"\n+                   + count + \", expected: \" + expectedCount;\n+        if (count !=  expectedCount) {\n+            throw new RuntimeException(msg);\n+        }\n+        System.out.println(msg);\n+    }\n+\n+\n+    static void printObject(Object obj) {\n+        printObject(\"\", obj);\n+    }\n+\n+    static void printObject(String prefix, Object obj) {\n+        if (obj == null) {\n+            System.out.println(prefix + \"null\");\n+            return;\n+          }\n+\n+        Class<?> clazz = obj.getClass();\n+        System.out.println(prefix + \"Object (class \" + clazz.getName() + \", tag = \" + getTag(obj) + \", class tag = \" + getTag(clazz));\n+\n+        if (clazz.isArray()) {\n+            Class<?> elementType = clazz.getComponentType();\n+            int length = java.lang.reflect.Array.getLength(obj);\n+            System.out.println(prefix + \"Array of \" + elementType + \", length = \" + length + \" [\");\n+            for (int i = 0; i < length; i++) {\n+                Object element = java.lang.reflect.Array.get(obj, i);\n+                if (elementType.isPrimitive()) {\n+                    if (i == 0) {\n+                        System.out.print(prefix + \"  \");\n+                    } else {\n+                        System.out.print(\", \");\n+                    }\n+                    System.out.print(prefix + \"(\" + i + \"):\" + element);\n+                } else {\n+                    System.out.println(prefix + \"(\" + i + \"):\" + \"NOT primitive\");\n+                    printObject(prefix + \"  \", element);\n+                }\n+            }\n+            System.out.println(prefix + \"]\");\n+        } else {\n+            while (clazz != null && clazz != Object.class) {\n+                Field[] fields = clazz.getDeclaredFields();\n+                for (Field field : fields) {\n+                    try {\n+                        field.setAccessible(true);\n+                        Object value = field.get(obj);\n+                        Class<?> fieldType = field.getType();\n+                        System.out.println(prefix + \"- \" + field.getName() + \" (\" + fieldType + \") = \" + value);\n+\n+                        if (!fieldType.isPrimitive()) {\n+                            printObject(prefix + \"  \", value);\n+                        }\n+                    } catch (IllegalAccessException | java.lang.reflect.InaccessibleObjectException e) {\n+                        System.err.println(\"  Error accessing field \" + field.getName() + \": \" + e.getMessage());\n+                    }\n+                }\n+                clazz = clazz.getSuperclass();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.loadLibrary(\"ValueHeapwalkingTest\");\n+        ValueHolder holder = new ValueHolder(10);\n+\n+        setTag(Value.class, TAG_VALUE_CLASS);\n+        setTag(Value2.class, TAG_VALUE2_CLASS);\n+        setTag(ValueHolder.class, TAG_HOLDER_CLASS);\n+        setTag(holder.v_arr, TAG_VALUE_ARRAY);\n+        setTag(holder.v2_arr, TAG_VALUE2_ARRAY);\n+\n+        reset();\n+        System.out.println(\">>iterateThroughHeap\");\n+        iterateThroughHeap();\n+        System.out.println(\"<<iterateThroughHeap\");\n+\n+        \/\/ IterateThroughHeap reports reachable and unreachable objects,\n+        \/\/ so verify only minimum count.\n+        for (int i = TAG_MIN; i <= TAG_MAX; i++) {\n+            System.out.println(tagStr(i) + \" count: \" + count(i));\n+        }\n+        int reachableValueHolderCount = 1;\n+        \/\/ v2_1, v2_2, v2_arr\n+        int reachableValue2Count = reachableValueHolderCount * (2 + nonNullCount(holder.v2_arr));\n+        \/\/ ValueHolder: v1, v2, v_arr\n+        \/\/ Value2: v1, v2\n+        int reachableValueCount = reachableValueHolderCount * (2 + nonNullCount(holder.v_arr))\n+                                + reachableValue2Count * 2;\n+        verifyMinCount(TAG_VALUE_CLASS, reachableValueCount);\n+        verifyMinCount(TAG_VALUE2_CLASS, reachableValue2Count);\n+        verifyMinCount(TAG_HOLDER_CLASS, reachableValueHolderCount);\n+        \/\/ For each Value object 1 primitive field must be reported.\n+        verifyPrimitiveFieldCount(TAG_VALUE_CLASS, count(TAG_VALUE_CLASS));\n+\n+        reset();  \/\/ to reset primitiveFieldCount\n+        System.out.println(\">>followReferences\");\n+        followReferences();\n+        System.out.println(\"<<followReferences\");\n+\n+        long maxTag = getMaxTag();\n+\n+        for (int i = TAG_MIN; i <= TAG_MAX; i++) {\n+            for (int j = TAG_MIN; j <= TAG_MAX; j++) {\n+                System.out.println(\"Reference from \" + tagStr(i) + \" to \" + tagStr(j) + \": \" + refCount(i, j));\n+            }\n+        }\n+\n+        printObject(holder);\n+\n+        \/\/ ValueHolder: v1, v2\n+        verifyRefCount(TAG_HOLDER_CLASS, TAG_VALUE_CLASS, 2);\n+        \/\/ ValueHolder: v2_1, v2_2\n+        verifyRefCount(TAG_HOLDER_CLASS, TAG_VALUE_CLASS, 2);\n+        \/\/ ValueHolder: v_arr\n+        verifyRefCount(TAG_HOLDER_CLASS, TAG_VALUE_ARRAY, 1);\n+        \/\/ ValueHolder: v2_arr\n+        verifyRefCount(TAG_HOLDER_CLASS, TAG_VALUE2_ARRAY, 1);\n+\n+        \/\/ References from arrays to their elements\n+        verifyRefCount(TAG_VALUE_ARRAY, TAG_VALUE_CLASS, nonNullCount(holder.v_arr));\n+        verifyRefCount(TAG_VALUE2_ARRAY, TAG_VALUE2_CLASS, nonNullCount(holder.v2_arr));\n+\n+        \/\/ Each Value2 object must have 2 references to Value object (v1, v2).\n+        verifyRefCount(TAG_VALUE2_CLASS, TAG_VALUE_CLASS, reachableValue2Count * 2);\n+\n+        \/\/ For each Value object 1 primitive field must be reported.\n+        verifyPrimitiveFieldCount(TAG_VALUE_CLASS, reachableValueCount);\n+\n+        System.out.println(\">>followReferences (2)\");\n+        followReferences();\n+        System.out.println(\"<<followReferences (2)\");\n+\n+        long maxTag2 = getMaxTag();\n+        \/\/ no new objects are expected to be tagged\n+        if (maxTag != maxTag2) {\n+            throw new RuntimeException(\"maxTag (\" + maxTag + \") not equal to maxTag2(\" + maxTag2 + \")\");\n+        }\n+\n+        Object[] objects = new Object[1024];\n+        long tags[] = new long[1024];\n+        System.out.println(\">>getObjectWithTags, maxTag = \" + maxTag);\n+        int count = getObjectWithTags(1, maxTag, objects, tags);\n+        System.out.println(\"getObjectWithTags returned \" + count);\n+        for (int i = 0; i < count; i++) {\n+            System.out.println(\"  [\" + i + \"] \" + objects[i] + \", tag = \" + tags[i]);\n+            if (objects[i] == null || tags[i] == 0) {\n+                throw new RuntimeException(\"unexpected object\");\n+            }\n+        }\n+        int expectedTaggedCount = 5 \/\/ TAG_VALUE_CLASS\/TAG_VALUE2_CLASS\/TAG_HOLDER_CLASS\/TAG_VALUE_ARRAY\/TAG_VALUE2_ARRAY\n+                + reachableValue2Count + reachableValueCount;\n+        if (count !=  expectedTaggedCount) {\n+            throw new RuntimeException(\"unexpected getObjectWithTags result: \" + count\n+                                     + \", expected \" + expectedTaggedCount);\n+        }\n+\n+        Reference.reachabilityFence(holder);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/Heapwalking\/ValueHeapwalkingTest.java","additions":351,"deletions":0,"binary":false,"changes":351,"status":"added"},{"patch":"@@ -0,0 +1,321 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jvmti.h>\n+#include \"jvmti_common.hpp\"\n+\n+static jvmtiEnv *jvmti = nullptr;\n+\n+extern \"C\" JNIEXPORT void JNICALL\n+Java_ValueHeapwalkingTest_setTag(JNIEnv* jni_env, jclass clazz, jobject object, jlong tag) {\n+  jvmtiError err = jvmti->SetTag(object, tag);\n+  check_jvmti_error(err, \"could not set tag\");\n+}\n+\n+extern \"C\" JNIEXPORT jlong JNICALL\n+Java_ValueHeapwalkingTest_getTag(JNIEnv* jni_env, jclass clazz, jobject object) {\n+  jlong tag;\n+  check_jvmti_error(jvmti->GetTag(object, &tag), \"could not get tag\");\n+  return tag;\n+}\n+\n+const int TAG_VALUE_CLASS = 1;\n+const int TAG_VALUE2_CLASS = 2;\n+const int TAG_HOLDER_CLASS = 3;\n+const int TAG_VALUE_ARRAY = 4;\n+const int TAG_VALUE3_ARRAY = 5;\n+const int MAX_TAG = 5;\n+const int START_TAG = 10; \/\/ start value for tagging objects\n+\n+static const char* tag_str(jlong tag) {\n+  switch (tag) {\n+  case 0: return \"None\";\n+  case TAG_VALUE_CLASS: return \"Value class\";\n+  case TAG_VALUE2_CLASS: return \"Value2 class\";\n+  case TAG_HOLDER_CLASS: return \"ValueHolder class\";\n+  case TAG_VALUE_ARRAY: return \"Value[] object\";\n+  case TAG_VALUE3_ARRAY: return \"Value2[] object\";\n+  }\n+  return \"Unknown\";\n+}\n+\n+struct Callback_Data  {\n+  \/\/ Updated by heap_iteration_callback.\n+  jint counters[MAX_TAG + 1];\n+  \/\/ Updated by heap_reference_callback.\n+  jint ref_counters[MAX_TAG + 1][MAX_TAG + 1];\n+  \/\/ Updated by primitive_field_callback.\n+  jint primitive_counters[MAX_TAG + 1];\n+  jlong tag_counter;\n+};\n+\n+static Callback_Data callbackData;\n+\n+extern \"C\" JNIEXPORT void JNICALL\n+Java_ValueHeapwalkingTest_reset(JNIEnv* jni_env, jclass clazz) {\n+  memset(&callbackData, 0, sizeof(callbackData));\n+  callbackData.tag_counter = START_TAG;\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL\n+Java_ValueHeapwalkingTest_count(JNIEnv* jni_env, jclass clazz, jint tag) {\n+  return callbackData.counters[tag];\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL\n+Java_ValueHeapwalkingTest_refCount(JNIEnv* jni_env, jclass clazz, jint fromTag, jint toTag) {\n+  return callbackData.ref_counters[fromTag][toTag];\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL\n+Java_ValueHeapwalkingTest_primitiveFieldCount(JNIEnv* jni_env, jclass clazz, jint tag) {\n+  return callbackData.primitive_counters[tag];\n+}\n+\n+extern \"C\" JNIEXPORT jlong JNICALL\n+Java_ValueHeapwalkingTest_getMaxTag(JNIEnv* jni_env, jclass clazz) {\n+  return callbackData.tag_counter;\n+}\n+\n+static jlong safe_deref(jlong* ref) {\n+    return ref == nullptr ? 0 : *ref;\n+}\n+\n+static jint JNICALL\n+heap_iteration_callback(jlong class_tag,\n+                        jlong size,\n+                        jlong* tag_ptr,\n+                        jint length,\n+                        void* user_data) {\n+  Callback_Data* data = (Callback_Data*)user_data;\n+\n+  if (class_tag != 0 && class_tag <= MAX_TAG) {\n+    data->counters[class_tag]++;\n+    printf(\"heap_iteration_callback: class_tag = %d (%s), tag = %d (%s), length = %d\\n\",\n+           (int)class_tag, tag_str(class_tag), (int)*tag_ptr, tag_str(*tag_ptr), length);\n+    fflush(nullptr);\n+  }\n+  return 0;\n+}\n+\n+static jint JNICALL\n+heap_reference_callback(jvmtiHeapReferenceKind reference_kind,\n+                        const jvmtiHeapReferenceInfo* reference_info,\n+                        jlong class_tag,\n+                        jlong referrer_class_tag,\n+                        jlong size,\n+                        jlong* tag_ptr,\n+                        jlong* referrer_tag_ptr,\n+                        jint length,\n+                        void* user_data) {\n+  Callback_Data* data = (Callback_Data*)user_data;\n+\n+  jlong tag = class_tag;\n+  if (tag == 0 && *tag_ptr != 0 && *tag_ptr <= MAX_TAG) {\n+    tag = *tag_ptr;\n+  }\n+  jlong referrer_tag = referrer_class_tag;\n+  if (referrer_tag == 0 && safe_deref(referrer_tag_ptr) != 0 && safe_deref(referrer_tag_ptr) <= MAX_TAG) {\n+    referrer_tag = *referrer_tag_ptr;\n+  }\n+\n+  if (tag != 0 && referrer_tag != 0) {\n+    \/\/ For testing we count only JVMTI_HEAP_REFERENCE_FIELD and JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT references.\n+    if (reference_kind == JVMTI_HEAP_REFERENCE_FIELD || reference_kind == JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT) {\n+      data->ref_counters[referrer_tag][tag]++;\n+    }\n+\n+    jlong cur_tag = *tag_ptr;\n+    char new_tag_str[64] = {};\n+    if (*tag_ptr == 0) { \/\/ i.e. class_tag != 0, but the object is untagged\n+      *tag_ptr = ++data->tag_counter;\n+      snprintf(new_tag_str, sizeof(new_tag_str), \", set tag to %d\", (int)*tag_ptr);\n+    }\n+    printf(\"heap_reference_callback: kind = %d, class_tag = %d (%s), tag = %d (%s), referrer_tag = %d (%s) %s\\n\",\n+           (int)reference_kind, (int)class_tag, tag_str(class_tag), (int)cur_tag, tag_str(*tag_ptr),\n+           (int)referrer_tag, tag_str(referrer_tag), new_tag_str);\n+    fflush(nullptr);\n+  }\n+\n+  return JVMTI_VISIT_OBJECTS;\n+}\n+\n+static jint JNICALL\n+primitive_field_callback(jvmtiHeapReferenceKind kind,\n+                         const jvmtiHeapReferenceInfo* info,\n+                         jlong object_class_tag,\n+                         jlong* object_tag_ptr,\n+                         jvalue value,\n+                         jvmtiPrimitiveType value_type,\n+                         void* user_data) {\n+  Callback_Data* data = (Callback_Data*)user_data;\n+  if (object_class_tag != 0) {\n+    char value_str[64] = {};\n+    switch (value_type) {\n+    case JVMTI_PRIMITIVE_TYPE_BOOLEAN: snprintf(value_str, sizeof(value_str), \"(boolean) %s\", value.z ? \"true\" : \"false\"); break;\n+    case JVMTI_PRIMITIVE_TYPE_BYTE:    snprintf(value_str, sizeof(value_str), \"(byte) %d\", value.b); break;\n+    case JVMTI_PRIMITIVE_TYPE_CHAR:    snprintf(value_str, sizeof(value_str), \"(char) %c\", value.c); break;\n+    case JVMTI_PRIMITIVE_TYPE_SHORT:   snprintf(value_str, sizeof(value_str), \"(short): %d\", value.s); break;\n+    case JVMTI_PRIMITIVE_TYPE_INT:     snprintf(value_str, sizeof(value_str), \"(int): %d\", value.i); break;\n+    case JVMTI_PRIMITIVE_TYPE_LONG:    snprintf(value_str, sizeof(value_str), \"(long): %lld\", (long long)value.j); break;\n+    case JVMTI_PRIMITIVE_TYPE_FLOAT:   snprintf(value_str, sizeof(value_str), \"(float): %f\", value.f); break;\n+    case JVMTI_PRIMITIVE_TYPE_DOUBLE:  snprintf(value_str, sizeof(value_str), \"(double): %f\", value.d);  break;\n+    default: snprintf(value_str, sizeof(value_str), \"invalid_type %d (%c)\", (int)value_type, (char)value_type);\n+    }\n+\n+    if (object_class_tag != 0 && object_class_tag <= MAX_TAG) {\n+      data->primitive_counters[object_class_tag]++;\n+      if (*object_tag_ptr != 0) {\n+        *object_tag_ptr = *object_tag_ptr;\n+      }\n+    }\n+\n+    printf(\"primitive_field_callback: kind = %d, class_tag = %d (%s), tag = %d (%s), value = %s\\n\",\n+           (int)kind, (int)object_class_tag, tag_str(object_class_tag),\n+           (int)*object_tag_ptr, tag_str(*object_tag_ptr), value_str);\n+    fflush(nullptr);\n+  }\n+  return 0;\n+}\n+\n+static jint JNICALL\n+array_primitive_value_callback(jlong class_tag,\n+                               jlong size,\n+                               jlong* tag_ptr,\n+                               jint element_count,\n+                               jvmtiPrimitiveType element_type,\n+                               const void* elements,\n+                               void* user_data) {\n+  Callback_Data* data = (Callback_Data*)user_data;\n+  if (class_tag != 0 || *tag_ptr != 0) {\n+    printf(\"array_primitive_value_callback: class_tag = %d (%s), tag = %d (%s), element_count = %d, element_type = %c\\n\",\n+           (int)class_tag, tag_str(class_tag), (int)*tag_ptr, tag_str(*tag_ptr), element_count, (char)element_type);\n+    fflush(nullptr);\n+  }\n+  return 0;\n+}\n+\n+static jint JNICALL\n+string_primitive_value_callback(jlong class_tag,\n+                                jlong size,\n+                                jlong* tag_ptr,\n+                                const jchar* value,\n+                                jint value_length,\n+                                void* user_data) {\n+  Callback_Data* data = (Callback_Data*)user_data;\n+  if (class_tag != 0 || *tag_ptr != 0) {\n+    jchar value_copy[1024] = {}; \/\/ fills with 0\n+    if (value_length > 1023) {\n+      value_length = 1023;\n+    }\n+    memcpy(value_copy, value, value_length * sizeof(jchar));\n+    printf(\"string_primitive_value_callback: class_tag = %d (%s), tag = %d (%s), value=\\\"%ls\\\"\\n\",\n+           (int)class_tag, tag_str(class_tag), (int)*tag_ptr, tag_str(*tag_ptr), (wchar_t*)value_copy);\n+    fflush(nullptr);\n+  }\n+  return 0;\n+}\n+\n+extern \"C\" JNIEXPORT void JNICALL\n+Java_ValueHeapwalkingTest_followReferences(JNIEnv* jni_env, jclass clazz) {\n+  jvmtiHeapCallbacks callbacks = {};\n+  callbacks.heap_iteration_callback = heap_iteration_callback;\n+  callbacks.heap_reference_callback = heap_reference_callback;\n+  callbacks.primitive_field_callback = primitive_field_callback;\n+  callbacks.array_primitive_value_callback = array_primitive_value_callback;\n+  callbacks.string_primitive_value_callback = string_primitive_value_callback;\n+\n+  jvmtiError err = jvmti->FollowReferences(0 \/* filter nothing *\/,\n+                                           nullptr \/* no class filter *\/,\n+                                           nullptr \/* no initial object, follow roots *\/,\n+                                           &callbacks,\n+                                           &callbackData);\n+  check_jvmti_error(err, \"FollowReferences failed\");\n+}\n+\n+extern \"C\" JNIEXPORT void JNICALL\n+Java_ValueHeapwalkingTest_iterateThroughHeap(JNIEnv* jni_env, jclass clazz) {\n+  jvmtiHeapCallbacks callbacks = {};\n+  callbacks.heap_iteration_callback = heap_iteration_callback;\n+  callbacks.heap_reference_callback = heap_reference_callback;\n+  callbacks.primitive_field_callback = primitive_field_callback;\n+  callbacks.array_primitive_value_callback = array_primitive_value_callback;\n+  callbacks.string_primitive_value_callback = string_primitive_value_callback;\n+\n+  jvmtiError err = jvmti->IterateThroughHeap(0 \/* filter nothing *\/,\n+                                             nullptr \/* no class filter *\/,\n+                                             &callbacks,\n+                                             &callbackData);\n+  check_jvmti_error(err, \"IterateThroughHeap failed\");\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL\n+Java_ValueHeapwalkingTest_getObjectWithTags(JNIEnv* jni_env, jclass clazz, jlong minTag, jlong maxTag, jobjectArray objects, jlongArray tags) {\n+  jsize len = jni_env->GetArrayLength(objects);\n+\n+  jint tag_count = (jint)(maxTag - minTag + 1);\n+  jlong* scan_tags = nullptr;\n+  check_jvmti_error(jvmti->Allocate(tag_count * sizeof(jlong), (unsigned char**)&scan_tags),\n+                    \"Allocate failed\");\n+\n+  for (jlong i = 0; i < tag_count; i++) {\n+      scan_tags[i] = i + minTag;\n+  }\n+\n+  jint count = 0;\n+  jobject* object_result = nullptr;\n+  jlong* tag_result = nullptr;\n+\n+  check_jvmti_error(jvmti->GetObjectsWithTags(tag_count, scan_tags, &count, &object_result, &tag_result),\n+                    \"GetObjectsWithTags failed\");\n+\n+  if (count > len) {\n+    printf(\"GetObjectsWithTags returned too many entries: %d (object length is %d)\\n\", count, (int)len);\n+    fflush(nullptr);\n+    abort();\n+  }\n+\n+  for (jint i = 0; i < count; i++) {\n+    jni_env->SetObjectArrayElement(objects, i, object_result[i]);\n+  }\n+  jni_env->SetLongArrayRegion(tags, 0, count, tag_result);\n+\n+  jvmti->Deallocate((unsigned char*)scan_tags);\n+  jvmti->Deallocate((unsigned char*)object_result);\n+  jvmti->Deallocate((unsigned char*)tag_result);\n+\n+  return count;\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  if (vm->GetEnv(reinterpret_cast<void **>(&jvmti), JVMTI_VERSION) != JNI_OK || !jvmti) {\n+    LOG(\"Could not initialize JVMTI\\n\");\n+    abort();\n+  }\n+  jvmtiCapabilities capabilities;\n+  memset(&capabilities, 0, sizeof(capabilities));\n+  capabilities.can_tag_objects = 1;\n+  check_jvmti_error(jvmti->AddCapabilities(&capabilities), \"adding capabilities\");\n+  return JVMTI_ERROR_NONE;\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/valhalla\/Heapwalking\/libValueHeapwalkingTest.cpp","additions":321,"deletions":0,"binary":false,"changes":321,"status":"added"}]}