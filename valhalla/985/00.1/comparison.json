{"files":[{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -170,1 +169,1 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -189,1 +188,1 @@\n-    \/** Switch: allow primitive classes ?\n+    \/** Switch: allow value classes ?\n@@ -191,1 +190,1 @@\n-    boolean allowPrimitiveClasses;\n+    boolean allowValueClasses;\n@@ -281,1 +280,1 @@\n-            ((names.isInitOrVNew(owner.name) ||    \/\/ i.e. we are in a constructor\n+            ((owner.name == names.init ||    \/\/ i.e. we are in a constructor\n@@ -808,1 +807,1 @@\n-                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));\n+                List<Type> bounds = List.of(attribType(tvar.bounds.head, env));\n@@ -810,1 +809,1 @@\n-                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));\n+                    bounds = bounds.prepend(attribType(bound, env));\n@@ -946,0 +945,2 @@\n+        boolean ctorProloguePrev = env.info.ctorPrologue;\n+        env.info.ctorPrologue = false;\n@@ -968,3 +969,2 @@\n-                \/\/ If this class appears as an anonymous class\n-                \/\/ in a superclass constructor call\n-                \/\/ disable implicit outer instance from being passed.\n+                \/\/ If this class appears as an anonymous class in a constructor\n+                \/\/ prologue, disable implicit outer instance from being passed.\n@@ -972,2 +972,1 @@\n-                if (env.info.isSelfCall &&\n-                        env.tree.hasTag(NEWCLASS)) {\n+                if (ctorProloguePrev && env.tree.hasTag(NEWCLASS)) {\n@@ -981,0 +980,1 @@\n+            env.info.ctorPrologue = ctorProloguePrev;\n@@ -990,0 +990,2 @@\n+        boolean ctorProloguePrev = env.info.ctorPrologue;\n+        env.info.ctorPrologue = false;\n@@ -1053,0 +1055,3 @@\n+            \/\/ Is this method a constructor?\n+            boolean isConstructor = TreeInfo.isConstructor(tree);\n+\n@@ -1080,1 +1085,1 @@\n-                if (names.isInitOrVNew(tree.name)) {\n+                if (isConstructor) {\n@@ -1083,5 +1088,2 @@\n-                        JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);\n-                        if (app == null ||\n-                                TreeInfo.name(app.meth) != names._this ||\n-                                !checkFirstConstructorStat(app, tree, false)) {\n-                            log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor(env.enclClass.sym));\n+                        if (!TreeInfo.hasConstructorCall(tree, names._this)) {\n+                            log.error(tree, Errors.NonCanonicalConstructorInvokeAnotherConstructor(env.enclClass.sym));\n@@ -1113,5 +1115,1 @@\n-                            JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);\n-                            if (app != null &&\n-                                    (TreeInfo.name(app.meth) == names._this ||\n-                                            TreeInfo.name(app.meth) == names._super) &&\n-                                    checkFirstConstructorStat(app, tree, false)) {\n+                            if (TreeInfo.hasAnyConstructorCall(tree)) {\n@@ -1195,5 +1193,3 @@\n-                if (names.isInitOrVNew(tree.name) && owner.type != syms.objectType) {\n-                    JCBlock body = tree.body;\n-                    if (body.stats.isEmpty() ||\n-                            TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {\n-                        JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),\n+                if (isConstructor && owner.type != syms.objectType) {\n+                    if (!TreeInfo.hasAnyConstructorCall(tree)) {\n+                        JCStatement supCall = make.at(tree.body.pos).Exec(make.Apply(List.nil(),\n@@ -1201,1 +1197,1 @@\n-                        body.stats = body.stats.prepend(supCall);\n+                        tree.body.stats = tree.body.stats.prepend(supCall);\n@@ -1204,1 +1200,1 @@\n-                            TreeInfo.isSuperCall(body.stats.head)) {\n+                            TreeInfo.hasConstructorCall(tree, names._super)) {\n@@ -1211,6 +1207,0 @@\n-                    } else if ((env.enclClass.sym.flags() & VALUE_CLASS) != 0 &&\n-                        (tree.mods.flags & GENERATEDCONSTR) == 0 &&\n-                        TreeInfo.isSuperCall(body.stats.head)) {\n-                        \/\/ value constructors are not allowed to call super directly,\n-                        \/\/ but tolerate compiler generated ones, these are ignored during code generation\n-                        log.error(tree.body.stats.head.pos(), Errors.CallToSuperNotAllowedInValueCtor);\n@@ -1240,0 +1230,3 @@\n+                \/\/ Start of constructor prologue\n+                localEnv.info.ctorPrologue = isConstructor;\n+\n@@ -1249,0 +1242,1 @@\n+            env.info.ctorPrologue = ctorProloguePrev;\n@@ -1304,4 +1298,1 @@\n-            \/* Don't want constant propagation\/folding for instance fields of primitive classes,\n-               as these can undergo updates via copy on write.\n-            *\/\n-                if ((v.flags_field & FINAL) == 0 || ((v.flags_field & STATIC) == 0 && v.owner.isValueClass()) ||\n+                if ((v.flags_field & FINAL) == 0 ||\n@@ -1566,1 +1557,1 @@\n-                Type base = types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym);\n+                Type base = types.asSuper(exprType, syms.iterableType.tsym);\n@@ -1582,1 +1573,1 @@\n-                    if (types.asSuper(iterSymbol.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym) == null) {\n+                    if (types.asSuper(iterSymbol.type.getReturnType(), syms.iteratorType.tsym) == null) {\n@@ -2019,1 +2010,1 @@\n-            types.asSuper(resource.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null &&\n+            types.asSuper(resource, syms.autoCloseableType.tsym) != null &&\n@@ -2208,2 +2199,1 @@\n-            \/\/ Those were all the cases that could result in a primitive. See if primitive boxing and primitive\n-            \/\/ value conversions bring about a convergence.\n+            \/\/ Those were all the cases that could result in a primitive\n@@ -2211,2 +2201,1 @@\n-                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type\n-                                         : t.isReferenceProjection() ? t.valueProjection() : t)\n+                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type : t)\n@@ -2223,1 +2212,1 @@\n-                                 .map(t -> chk.checkNonVoid(posIt.next(), allowPrimitiveClasses && t.isPrimitiveClass() ? t.referenceProjection() : t))\n+                                 .map(t -> chk.checkNonVoid(posIt.next(), t))\n@@ -2226,1 +2215,1 @@\n-            \/\/ both are known to be reference types (or projections).  The result is\n+            \/\/ both are known to be reference types.  The result is\n@@ -2539,7 +2528,0 @@\n-            \/\/ We are seeing a ...this(...) or ...super(...) call.\n-            \/\/ Check that this is the first statement in a constructor.\n-            checkFirstConstructorStat(tree, env.enclMethod, true);\n-\n-            \/\/ Record the fact\n-            \/\/ that this is a constructor call (using isSelfCall).\n-            localEnv.info.isSelfCall = true;\n@@ -2548,2 +2530,0 @@\n-            localEnv.info.constructorArgs = true;\n-            localEnv.info.constructorArgs = false;\n@@ -2554,0 +2534,3 @@\n+            \/\/ Done with this()\/super() parameters. End of constructor prologue.\n+            env.info.ctorPrologue = false;\n+\n@@ -2664,5 +2647,1 @@\n-                \/\/ Special treatment for primitive classes: Given an expression v of type V where\n-                \/\/ V is a primitive class, v.getClass() is typed to be Class<? extends |V.ref|>\n-                Type wcb = types.erasure(allowPrimitiveClasses && qualifierType.isPrimitiveClass() ?\n-                                         qualifierType.referenceProjection() : qualifierType.baseType());\n-                        List.of(new WildcardType(wcb,\n+                        List.of(new WildcardType(types.erasure(qualifierType.baseType()),\n@@ -2673,2 +2652,1 @@\n-                        restype.getMetadata(),\n-                        restype.getFlavor());\n+                        restype.getMetadata());\n@@ -2687,20 +2665,0 @@\n-        \/** Check that given application node appears as first statement\n-         *  in a constructor call.\n-         *  @param tree          The application node\n-         *  @param enclMethod    The enclosing method of the application.\n-         *  @param error         Should an error be issued?\n-         *\/\n-        boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {\n-            if (enclMethod != null && names.isInitOrVNew(enclMethod.name)) {\n-                JCBlock body = enclMethod.body;\n-                if (body.stats.head.hasTag(EXEC) &&\n-                    ((JCExpressionStatement) body.stats.head).expr == tree)\n-                    return true;\n-            }\n-            if (error) {\n-                log.error(tree.pos(),\n-                        Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));\n-            }\n-            return false;\n-        }\n-\n@@ -2843,10 +2801,0 @@\n-            \/\/ Check that it is an instantiation of a class and not a projection type\n-            if (allowPrimitiveClasses) {\n-                if (clazz.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n-                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n-                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                        log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);\n-                    }\n-                }\n-            }\n@@ -2877,2 +2825,1 @@\n-                                               clazztype.getMetadata(),\n-                                               clazztype.getFlavor());\n+                                               clazztype.getMetadata());\n@@ -3032,3 +2979,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n-                    }\n@@ -3107,3 +3051,0 @@\n-        \/\/ Likewise arg can't be null if it is a primitive class instance.\n-        if (allowPrimitiveClasses && arg.type.isPrimitiveClass())\n-            return arg;\n@@ -3599,2 +3540,1 @@\n-                    Name constructorName = owner.isConcreteValueClass() ? names.vnew : names.init;\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(constructorName)) {\n+                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n@@ -3663,5 +3603,0 @@\n-            Symbol lhsSym = TreeInfo.symbol(that.expr);\n-                \/\/ TODO - a bit hacky but...\n-                if (lhsSym != null && lhsSym.isConcreteValueClass() && that.name == names.init) {\n-                    that.name = names.vnew;\n-                }\n@@ -3674,0 +3609,1 @@\n+                Symbol lhsSym = TreeInfo.symbol(that.expr);\n@@ -3757,1 +3693,1 @@\n-            that.sym = refSym.isInitOrVNew() ? refSym.baseSymbol() : refSym;\n+            that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;\n@@ -4401,10 +4337,0 @@\n-        \/\/ In a constructor body,\n-        \/\/ if symbol is a field or instance method, check that it is\n-        \/\/ not accessed before the supertype constructor is called.\n-        if (symEnv.info.isSelfCall &&\n-            sym.kind.matches(KindSelector.VAL_MTH) &&\n-            sym.owner.kind == TYP &&\n-            (sym.flags() & STATIC) == 0) {\n-            chk.earlyRefError(tree.pos(), sym.kind == VAR ?\n-                                          sym : thisSym(tree.pos(), env));\n-        }\n@@ -4447,9 +4373,0 @@\n-        if (allowPrimitiveClasses && tree.name == names._class && site.isPrimitiveClass()) {\n-            \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n-             * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n-             * always matching the behavior of Object::getClass\n-             *\/\n-             if (!tree.selected.hasTag(SELECT) || ((JCFieldAccess) tree.selected).name != names.val) {\n-                 tree.selected.setType(site = site.referenceProjection());\n-             }\n-        }\n@@ -4468,1 +4385,1 @@\n-                return;\n+                return ;\n@@ -4532,12 +4449,1 @@\n-            if (sym.name == names._this || sym.name == names._super) {\n-                \/\/ If `C' is the currently compiled class, check that\n-                \/\/ `C.this' does not appear in an explicit call to a constructor\n-                \/\/ also make sure that `super` is not used in constructor invocations\n-                if (env.info.isSelfCall &&\n-                        ((sym.name == names._this &&\n-                        site.tsym == env.enclClass.sym) ||\n-                        sym.name == names._super && env.info.constructorArgs &&\n-                        (sitesym.isInterface() || site.tsym == env.enclClass.sym))) {\n-                    chk.earlyRefError(tree.pos(), sym);\n-                }\n-            } else {\n+            if (sym.name != names._this && sym.name != names._super) {\n@@ -4572,1 +4478,1 @@\n-                Type site1 = types.asSuper(env.enclClass.sym.type.referenceProjectionOrSelf(), site.tsym);\n+                Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);\n@@ -4615,2 +4521,0 @@\n-                } else if (allowPrimitiveClasses && site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n-                    return site.tsym;\n@@ -4720,1 +4624,1 @@\n-                \/\/ except for three situations:\n+                \/\/ except for two situations:\n@@ -4723,3 +4627,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        Assert.check(owntype.getFlavor() != Flavor.X_Typeof_X);\n-                    }\n@@ -4729,8 +4630,1 @@\n-                    \/\/ (a) If symbol is a primitive class and its reference projection\n-                    \/\/ is requested via the .ref notation, then adjust the computed type to\n-                    \/\/ reflect this.\n-                    if (allowPrimitiveClasses && owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n-                        owntype = new ClassType(owntype.getEnclosingType(), owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n-                    }\n-\n-                    \/\/ (b) If the symbol's type is parameterized, erase it\n+                    \/\/ (a) If the symbol's type is parameterized, erase it\n@@ -4743,1 +4637,1 @@\n-                    \/\/ (c) If the symbol's type is an inner class, then\n+                    \/\/ (b) If the symbol's type is an inner class, then\n@@ -4763,1 +4657,1 @@\n-                                owntype.getMetadata(), owntype.getFlavor());\n+                                owntype.getMetadata());\n@@ -4827,1 +4721,1 @@\n-            if (!names.isInitOrVNew(sym.name) || tree.hasTag(REFERENCE)) {\n+            if (sym.name != names.init || tree.hasTag(REFERENCE)) {\n@@ -5081,31 +4975,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        if (!allowPrimitiveClasses) {\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                    Feature.PRIMITIVE_CLASSES.error(sourceName));\n-        }\n-\n-        \/\/ Attribute the qualifier expression, and determine its symbol (if any).\n-        Type site = attribTree(tree.clazz, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n-        if (!pkind().contains(KindSelector.TYP_PCK))\n-            site = capture(site); \/\/ Capture field access\n-        if (!allowPrimitiveClasses) {\n-            result = types.createErrorType(names._default, site.tsym, site);\n-        } else {\n-            Symbol sym = switch (site.getTag()) {\n-                case WILDCARD -> throw new AssertionError(tree);\n-                case PACKAGE -> {\n-                    log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n-                            Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n-                    yield syms.errSymbol;\n-                }\n-                case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n-                default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n-            };\n-\n-            if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n-                site = types.skipTypeVars(site, true);\n-            }\n-            result = checkId(tree, site, sym, env, resultInfo);\n-        }\n-    }\n-\n@@ -5140,1 +5003,0 @@\n-\n@@ -5199,1 +5061,1 @@\n-                                        clazztype.getMetadata(), clazztype.getFlavor());\n+                                        clazztype.getMetadata());\n@@ -5326,1 +5188,1 @@\n-                make.Modifiers(PUBLIC | ABSTRACT | (extending != null && TreeInfo.symbol(extending).isPrimitiveClass() ? PRIMITIVE_CLASS : 0)),\n+                make.Modifiers(PUBLIC | ABSTRACT),\n@@ -5349,1 +5211,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),\n@@ -5467,5 +5329,0 @@\n-            if (allowPrimitiveClasses && c.type.isPrimitiveClass()) {\n-                final Env<AttrContext> env = typeEnvs.get(c);\n-                if (env != null && env.tree != null && env.tree.hasTag(CLASSDEF))\n-                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n-            }\n@@ -5649,1 +5506,1 @@\n-                    chk.checkConstraintsOfValueClass(env.tree.pos(), c);\n+                    chk.checkConstraintsOfValueClass((JCClassDecl) env.tree, c);\n@@ -5780,0 +5637,3 @@\n+        \/\/ Check for proper placement of super()\/this() calls.\n+        chk.checkSuperInitCalls(tree);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":62,"deletions":202,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-    public final boolean allowValueClasses;\n@@ -115,1 +114,0 @@\n-    final boolean allowPrimitiveClasses;\n@@ -153,2 +151,0 @@\n-        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -224,1 +220,1 @@\n-        if (names.isInitOrVNew(bestSoFar.name) &&\n+        if (bestSoFar.name == names.init &&\n@@ -297,1 +293,1 @@\n-        return owner.isInitOrVNew() ||\n+        return owner.isConstructor() ||\n@@ -409,1 +405,1 @@\n-        if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) return false;\n+        if (sym.name == names.init && sym.owner != site.tsym) return false;\n@@ -423,14 +419,0 @@\n-        if (allowPrimitiveClasses) {\n-            if (sym.kind == MTH || sym.kind == VAR) {\n-                \/* If any primitive class types are involved, ask the same question in the reference universe,\n-                   where the hierarchy is navigable\n-                *\/\n-                if (site.isPrimitiveClass())\n-                    site = site.referenceProjection();\n-            } else if (sym.kind == TYP) {\n-                \/\/ A type is accessible in a reference projection if it was\n-                \/\/ accessible in the value projection.\n-                if (site.isReferenceProjection())\n-                    site = site.valueProjection();\n-            }\n-        }\n@@ -488,1 +470,1 @@\n-        if (sym.kind != MTH || sym.isInitOrVNew() || sym.isStatic())\n+        if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())\n@@ -490,6 +472,4 @@\n-\n-        \/* If any primitive class types are involved, ask the same question in the reference universe,\n-           where the hierarchy is navigable\n-        *\/\n-        if (allowPrimitiveClasses && site.isPrimitiveClass()) {\n-            site = site.referenceProjection();\n+        else {\n+            Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);\n+            return (s2 == null || s2 == sym || sym.owner == s2.owner || (sym.owner.isInterface() && s2.owner == syms.objectType.tsym) ||\n+                    !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));\n@@ -497,4 +477,0 @@\n-\n-        Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);\n-        return (s2 == null || s2 == sym || sym.owner == s2.owner || (sym.owner.isInterface() && s2.owner == syms.objectType.tsym) ||\n-                !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));\n@@ -1535,2 +1511,1 @@\n-                if (staticOnly &&\n-                        sym.kind == VAR &&\n+                if (sym.kind == VAR &&\n@@ -1538,4 +1513,7 @@\n-                        (sym.flags() & STATIC) == 0)\n-                    return new StaticError(sym);\n-                else\n-                    return sym;\n+                        (sym.flags() & STATIC) == 0) {\n+                    if (staticOnly)\n+                        return new StaticError(sym);\n+                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0)\n+                        return new RefBeforeCtorCalledError(sym);\n+                }\n+                return sym;\n@@ -1720,1 +1698,1 @@\n-                    if (types.asSuper(m1Owner.type.referenceProjectionOrSelf(), m2Owner) != null &&\n+                    if (types.asSuper(m1Owner.type, m2Owner) != null &&\n@@ -1725,1 +1703,1 @@\n-                    if (types.asSuper(m2Owner.type.referenceProjectionOrSelf(), m1Owner) != null &&\n+                    if (types.asSuper(m2Owner.type, m1Owner) != null &&\n@@ -1892,1 +1870,1 @@\n-            if (names.isInitOrVNew(name)) return bestSoFar;\n+            if (name == names.init) return bestSoFar;\n@@ -2038,5 +2016,9 @@\n-                    if (staticOnly &&\n-                        sym.kind == MTH &&\n-                        sym.owner.kind == TYP &&\n-                        (sym.flags() & STATIC) == 0) return new StaticError(sym);\n-                    else return sym;\n+                    if (sym.kind == MTH &&\n+                            sym.owner.kind == TYP &&\n+                            (sym.flags() & STATIC) == 0) {\n+                        if (staticOnly)\n+                            return new StaticError(sym);\n+                        if (env1.info.ctorPrologue && env1 == env)\n+                            return new RefBeforeCtorCalledError(sym);\n+                    }\n+                    return sym;\n@@ -2327,16 +2309,0 @@\n-        return findMemberTypeInternal(env,site, name, c);\n-    }\n-\n-    \/** Find qualified member type.\n-     *  @param env       The current environment.\n-     *  @param site      The original type from where the selection takes\n-     *                   place.\n-     *  @param name      The type's name.\n-     *  @param c         The class to search for the member type. This is\n-     *                   always a superclass or implemented interface of\n-     *                   site's class.\n-     *\/\n-    Symbol findMemberTypeInternal(Env<AttrContext> env,\n-                          Type site,\n-                          Name name,\n-                          TypeSymbol c) {\n@@ -2391,8 +2357,0 @@\n-        return findTypeInternal(env, name);\n-    }\n-\n-    \/** Find an unqualified type symbol.\n-     *  @param env       The current environment.\n-     *  @param name      The type's name.\n-     *\/\n-    Symbol findTypeInternal(Env<AttrContext> env, Name name) {\n@@ -2936,2 +2894,1 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n-        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n+        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n@@ -2971,2 +2928,1 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n-                                    constructorName, argtypes,\n+                                    names.init, argtypes,\n@@ -2996,2 +2952,1 @@\n-        Name constructorName = allowValueClasses && site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n-                new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n+                new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n@@ -3013,1 +2968,1 @@\n-                                sym = accessMethod(sym, pos, site, constructorName, true, argtypes, typeargtypes);\n+                                sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);\n@@ -3060,2 +3015,1 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n-        for (final Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n+        for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n@@ -3070,1 +3024,1 @@\n-                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), constructorName, constrType, site.tsym) {\n+                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {\n@@ -3112,1 +3066,1 @@\n-        if (!names.isInitOrVNew(name)) {\n+        if (!name.equals(names.init)) {\n@@ -3627,1 +3581,1 @@\n-                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head.referenceProjectionOrSelf()), originalSite))) {\n+                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {\n@@ -3692,1 +3646,1 @@\n-                Type asSuperSite = types.asSuper(argtypes.head.referenceProjectionOrSelf(), site.tsym);\n+                Type asSuperSite = types.asSuper(argtypes.head, site.tsym);\n@@ -3717,2 +3671,1 @@\n-            \/\/ TODO - array constructor will be <init>\n-            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -3750,1 +3703,1 @@\n-            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -3754,1 +3707,1 @@\n-                            site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata(), site.getFlavor());\n+                                site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata());\n@@ -3828,1 +3781,4 @@\n-                    if (staticOnly) sym = new StaticError(sym);\n+                    if (staticOnly)\n+                        sym = new StaticError(sym);\n+                    else if (env1.info.ctorPrologue)\n+                        sym = new RefBeforeCtorCalledError(sym);\n@@ -3842,0 +3798,2 @@\n+                    if (env.info.ctorPrologue)\n+                        log.error(pos, Errors.CantRefBeforeCtorCalled(name));\n@@ -3844,1 +3802,1 @@\n-                            types.asSuper(env.enclClass.type.referenceProjectionOrSelf(), c), env.enclClass.sym);\n+                            types.asSuper(env.enclClass.type, c), env.enclClass.sym);\n@@ -3943,2 +3901,2 @@\n-        if (env.info.isSelfCall && thisType.tsym == env.enclClass.sym) {\n-            log.error(pos, Errors.CantRefBeforeCtorCalled(\"this\"));\n+        if (env.info.ctorPrologue && thisType.tsym == env.enclClass.sym) {\n+            log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n@@ -4157,1 +4115,1 @@\n-            boolean isConstructor = names.isInitOrVNew(name);\n+            boolean isConstructor = name == names.init;\n@@ -4256,1 +4214,1 @@\n-                              names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n+                              ws.name == names.init ? ws.owner.name : ws.name,\n@@ -4273,1 +4231,1 @@\n-                              names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n+                              ws.name == names.init ? ws.owner.name : ws.name,\n@@ -4330,1 +4288,0 @@\n-                boolean isConstructor = names.isInitOrVNew(name);\n@@ -4339,2 +4296,2 @@\n-                        isConstructor ? KindName.CONSTRUCTOR : kind.absentKind(),\n-                        isConstructor ? site.tsym.name : name,\n+                        name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),\n+                        name == names.init ? site.tsym.name : name,\n@@ -4500,1 +4457,1 @@\n-            if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) {\n+            if (sym.name == names.init && sym.owner != site.tsym) {\n@@ -4649,1 +4606,5 @@\n-            super(STATICERR, sym, \"static error\");\n+            this(sym, \"static error\");\n+        }\n+\n+        StaticError(Symbol sym, String debugName) {\n+            super(STATICERR, sym, debugName);\n@@ -4668,0 +4629,26 @@\n+    \/**\n+     * Specialization of {@link InvalidSymbolError} for illegal\n+     * early accesses within a constructor prologue.\n+     *\/\n+    class RefBeforeCtorCalledError extends StaticError {\n+\n+        RefBeforeCtorCalledError(Symbol sym) {\n+            super(sym, \"prologue error\");\n+        }\n+\n+        @Override\n+        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,\n+                DiagnosticPosition pos,\n+                Symbol location,\n+                Type site,\n+                Name name,\n+                List<Type> argtypes,\n+                List<Type> typeargtypes) {\n+            Symbol errSym = ((sym.kind == TYP && sym.type.hasTag(CLASS))\n+                ? types.erasure(sym.type).tsym\n+                : sym);\n+            return diags.create(dkind, log.currentSource(), pos,\n+                    \"cant.ref.before.ctor.called\", errSym);\n+        }\n+    }\n+\n@@ -4713,1 +4700,1 @@\n-            if (names.isInitOrVNew(sname)) sname = s1.owner.name;\n+            if (sname == names.init) sname = s1.owner.name;\n@@ -4781,1 +4768,1 @@\n-            super(sym);\n+            super(sym, \"bad method ref error\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":88,"deletions":101,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import java.util.function.Function;\n@@ -84,12 +85,1 @@\n-            return name == name.table.names.init || name == name.table.names.vnew;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/** Is tree a value factory declaration?\n-     *\/\n-    public static boolean isValueFactory(JCTree tree) {\n-        if (tree.hasTag(METHODDEF)) {\n-            Name name = ((JCMethodDecl) tree).name;\n-            return name == name.table.names.vnew;\n+            return name == name.table.names.init;\n@@ -123,1 +113,1 @@\n-            if (isConstructor(l.head) || isValueFactory(l.head)) return true;\n+            if (isConstructor(l.head)) return true;\n@@ -127,22 +117,0 @@\n-    \/** Is there a constructor invocation in the given list of trees?\n-     *  Optionally, check only for no-arg ctor invocation\n-     *\/\n-    public static Name getConstructorInvocationName(List<? extends JCTree> trees, Names names, boolean argsAllowed) {\n-        for (JCTree tree : trees) {\n-            if (tree.hasTag(EXEC)) {\n-                JCExpressionStatement stat = (JCExpressionStatement)tree;\n-                if (stat.expr.hasTag(APPLY)) {\n-                    JCMethodInvocation apply = (JCMethodInvocation)stat.expr;\n-                    if (argsAllowed || apply.args.size() == 0) {\n-                        Name methName = TreeInfo.name(apply.meth);\n-                        if (methName == names._this ||\n-                                methName == names._super) {\n-                            return methName;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return names.empty;\n-    }\n-\n@@ -187,12 +155,0 @@\n-    \/** Is this a call to this or super?\n-     *\/\n-    public static boolean isSelfCall(JCTree tree) {\n-        Name name = calledMethodName(tree);\n-        if (name != null) {\n-            Names names = name.table.names;\n-            return name==names._this || name==names._super;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n@@ -255,2 +211,15 @@\n-    \/** Is this a constructor whose first (non-synthetic) statement is not\n-     *  of the form this(...)?\n+    \/** Is the given method a constructor containing a super() or this() call?\n+      *\/\n+    public static boolean hasAnyConstructorCall(JCMethodDecl tree) {\n+        return hasConstructorCall(tree, null);\n+    }\n+\n+    \/** Is the given method a constructor containing a super() and\/or this() call?\n+      * The \"target\" is either names._this, names._super, or null for either\/both.\n+      *\/\n+    public static boolean hasConstructorCall(JCMethodDecl tree, Name target) {\n+        JCMethodInvocation app = findConstructorCall(tree);\n+        return app != null && (target == null || target == name(app.meth));\n+    }\n+\n+    \/** Find the first super() or init() call in the given constructor.\n@@ -258,22 +227,81 @@\n-    public static boolean isInitialConstructor(JCTree tree) {\n-        JCMethodInvocation app = firstConstructorCall(tree);\n-        if (app == null) return false;\n-        Name meth = name(app.meth);\n-        return meth == null || meth != meth.table.names._this;\n-    }\n-\n-    \/** Return the first call in a constructor definition. *\/\n-    public static JCMethodInvocation firstConstructorCall(JCTree tree) {\n-        if (!tree.hasTag(METHODDEF)) return null;\n-        JCMethodDecl md = (JCMethodDecl) tree;\n-        if (!md.isInitOrVNew()) return null;\n-        if (md.body == null) return null;\n-        List<JCStatement> stats = md.body.stats;\n-        \/\/ Synthetic initializations can appear before the super call.\n-        while (stats.nonEmpty() && isSyntheticInit(stats.head))\n-            stats = stats.tail;\n-        if (stats.isEmpty()) return null;\n-        if (!stats.head.hasTag(EXEC)) return null;\n-        JCExpressionStatement exec = (JCExpressionStatement) stats.head;\n-        if (!exec.expr.hasTag(APPLY)) return null;\n-        return (JCMethodInvocation)exec.expr;\n+    public static JCMethodInvocation findConstructorCall(JCMethodDecl md) {\n+        if (!TreeInfo.isConstructor(md) || md.body == null)\n+            return null;\n+        return new ConstructorCallFinder(md.name.table.names).find(md).head;\n+    }\n+\n+    \/** Finds all calls to this() and\/or super() in a given constructor.\n+     *  We can't assume they will be \"top level\" statements, because\n+     *  some synthetic calls to super() are added inside { } blocks.\n+     *  So we must recurse through the method's entire syntax tree.\n+     *\/\n+    private static class ConstructorCallFinder extends TreeScanner {\n+\n+        final ListBuffer<JCMethodInvocation> calls = new ListBuffer<>();\n+        final Names names;\n+\n+        ConstructorCallFinder(Names names) {\n+            this.names = names;\n+        }\n+\n+        List<JCMethodInvocation> find(JCMethodDecl meth) {\n+            scan(meth);\n+            return calls.toList();\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation invoke) {\n+            Name name = TreeInfo.name(invoke.meth);\n+            if ((name == names._this || name == names._super))\n+                calls.append(invoke);\n+            super.visitApply(invoke);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            \/\/ don't descend any further\n+        }\n+    }\n+\n+    \/** Finds super() invocations and translates them using the given mapping.\n+     *\/\n+    public static void mapSuperCalls(JCBlock block, Function<? super JCExpressionStatement, ? extends JCStatement> mapper) {\n+        block.stats = block.stats.map(new TreeInfo.SuperCallTranslator(mapper)::translate);\n+    }\n+\n+    \/** Finds all super() invocations and translates them somehow.\n+     *\/\n+    private static class SuperCallTranslator extends TreeTranslator {\n+\n+        final Function<? super JCExpressionStatement, ? extends JCStatement> translator;\n+\n+        \/** Constructor.\n+         *\n+         * @param translator translates super() invocations, returning replacement statement or null for no change\n+         *\/\n+        SuperCallTranslator(Function<? super JCExpressionStatement, ? extends JCStatement> translator) {\n+            this.translator = translator;\n+        }\n+\n+        \/\/ Because it returns void, anywhere super() can legally appear must be a location where a JCStatement\n+        \/\/ could also appear, so it's OK that we are replacing a JCExpressionStatement with a JCStatement here.\n+        @Override\n+        public void visitExec(JCExpressionStatement stat) {\n+            if (!TreeInfo.isSuperCall(stat) || (result = this.translator.apply(stat)) == null)\n+                super.visitExec(stat);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            \/\/ don't descend any further\n+        }\n@@ -505,2 +533,0 @@\n-            case DEFAULT_VALUE:\n-                return getStartPos(((JCDefaultValue) tree).clazz);\n@@ -662,2 +688,0 @@\n-            case WITHFIELD:\n-                return getEndPos(((JCWithField) tree).value, endPosTable);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":99,"deletions":75,"binary":false,"changes":174,"status":"modified"}]}