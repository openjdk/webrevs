{"files":[{"patch":"@@ -5367,31 +5367,31 @@\n-            if (c.isSealed() &&\n-                    !c.isEnum() &&\n-                    !c.isPermittedExplicit &&\n-                    c.permitted.isEmpty()) {\n-                log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);\n-            }\n-\n-            if (c.isSealed()) {\n-                Set<Symbol> permittedTypes = new HashSet<>();\n-                boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;\n-                for (Symbol subTypeSym : c.permitted) {\n-                    boolean isTypeVar = false;\n-                    if (subTypeSym.type.getTag() == TYPEVAR) {\n-                        isTypeVar = true; \/\/error recovery\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n-                    }\n-                    if (subTypeSym.isAnonymous() && !c.isEnum()) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n-                    }\n-                    if (permittedTypes.contains(subTypeSym)) {\n-                        DiagnosticPosition pos =\n-                                env.enclClass.permitting.stream()\n-                                        .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n-                                        .limit(2).collect(List.collector()).get(1);\n-                        log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n-                    } else {\n-                        permittedTypes.add(subTypeSym);\n-                    }\n-                    if (sealedInUnnamed) {\n-                        if (subTypeSym.packge() != c.packge()) {\n+            \/\/ The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,\n+            \/\/ because the annotations were not available at the time the env was created. Therefore,\n+            \/\/ we look up the environment chain for the first enclosing environment for which the\n+            \/\/ lint value is set. Typically, this is the parent env, but might be further if there\n+            \/\/ are any envs created as a result of TypeParameter nodes.\n+            Env<AttrContext> lintEnv = env;\n+            while (lintEnv.info.lint == null)\n+                lintEnv = lintEnv.next;\n+\n+            \/\/ Having found the enclosing lint value, we can initialize the lint value for this class\n+            env.info.lint = lintEnv.info.lint.augment(c);\n+\n+            Lint prevLint = chk.setLint(env.info.lint);\n+            JavaFileObject prev = log.useSource(c.sourcefile);\n+            ResultInfo prevReturnRes = env.info.returnResult;\n+\n+            try {\n+                if (c.isSealed() &&\n+                        !c.isEnum() &&\n+                        !c.isPermittedExplicit &&\n+                        c.permitted.isEmpty()) {\n+                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.SealedClassMustHaveSubclasses);\n+                }\n+\n+                if (c.isSealed()) {\n+                    Set<Symbol> permittedTypes = new HashSet<>();\n+                    boolean sealedInUnnamed = c.packge().modle == syms.unnamedModule || c.packge().modle == syms.noModule;\n+                    for (Symbol subTypeSym : c.permitted) {\n+                        boolean isTypeVar = false;\n+                        if (subTypeSym.type.getTag() == TYPEVAR) {\n+                            isTypeVar = true; \/\/error recovery\n@@ -5399,2 +5399,1 @@\n-                                    Errors.ClassInUnnamedModuleCantExtendSealedInDiffPackage(c)\n-                            );\n+                                    Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n@@ -5402,18 +5401,19 @@\n-                    } else if (subTypeSym.packge().modle != c.packge().modle) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                Errors.ClassInModuleCantExtendSealedInDiffModule(c, c.packge().modle)\n-                        );\n-                    }\n-                    if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n-                                Errors.InvalidPermitsClause(\n-                                        subTypeSym == c.type.tsym ?\n-                                                Fragments.MustNotBeSameClass :\n-                                                Fragments.MustNotBeSupertype(subTypeSym.type)\n-                                )\n-                        );\n-                    } else if (!isTypeVar) {\n-                        boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n-                                                    .stream()\n-                                                    .anyMatch(d -> d.tsym == c);\n-                        if (!thisIsASuper) {\n+                        if (subTypeSym.isAnonymous() && !c.isEnum()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n+                        }\n+                        if (permittedTypes.contains(subTypeSym)) {\n+                            DiagnosticPosition pos =\n+                                    env.enclClass.permitting.stream()\n+                                            .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n+                                            .limit(2).collect(List.collector()).get(1);\n+                            log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n+                        } else {\n+                            permittedTypes.add(subTypeSym);\n+                        }\n+                        if (sealedInUnnamed) {\n+                            if (subTypeSym.packge() != c.packge()) {\n+                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                        Errors.ClassInUnnamedModuleCantExtendSealedInDiffPackage(c)\n+                                );\n+                            }\n+                        } else if (subTypeSym.packge().modle != c.packge().modle) {\n@@ -5421,1 +5421,19 @@\n-                                    Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                                    Errors.ClassInModuleCantExtendSealedInDiffModule(c, c.packge().modle)\n+                            );\n+                        }\n+                        if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n+                                    Errors.InvalidPermitsClause(\n+                                            subTypeSym == c.type.tsym ?\n+                                                    Fragments.MustNotBeSameClass :\n+                                                    Fragments.MustNotBeSupertype(subTypeSym.type)\n+                                    )\n+                            );\n+                        } else if (!isTypeVar) {\n+                            boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n+                                                        .stream()\n+                                                        .anyMatch(d -> d.tsym == c);\n+                            if (!thisIsASuper) {\n+                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                                        Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                            }\n@@ -5425,6 +5443,5 @@\n-            }\n-            List<ClassSymbol> sealedSupers = types.directSupertypes(c.type)\n-                                                  .stream()\n-                                                  .filter(s -> s.tsym.isSealed())\n-                                                  .map(s -> (ClassSymbol) s.tsym)\n-                                                  .collect(List.collector());\n+                List<ClassSymbol> sealedSupers = types.directSupertypes(c.type)\n+                                                      .stream()\n+                                                      .filter(s -> s.tsym.isSealed())\n+                                                      .map(s -> (ClassSymbol) s.tsym)\n+                                                      .collect(List.collector());\n@@ -5433,3 +5450,3 @@\n-            if (sealedSupers.isEmpty()) {\n-                if ((c.flags_field & Flags.NON_SEALED) != 0) {\n-                    boolean hasErrorSuper = false;\n+                if (sealedSupers.isEmpty()) {\n+                    if ((c.flags_field & Flags.NON_SEALED) != 0) {\n+                        boolean hasErrorSuper = false;\n@@ -5437,3 +5454,3 @@\n-                    hasErrorSuper |= types.directSupertypes(c.type)\n-                                          .stream()\n-                                          .anyMatch(s -> s.tsym.kind == Kind.ERR);\n+                        hasErrorSuper |= types.directSupertypes(c.type)\n+                                              .stream()\n+                                              .anyMatch(s -> s.tsym.kind == Kind.ERR);\n@@ -5441,1 +5458,1 @@\n-                    ClassType ct = (ClassType) c.type;\n+                        ClassType ct = (ClassType) c.type;\n@@ -5443,1 +5460,1 @@\n-                    hasErrorSuper |= !ct.isCompound() && ct.interfaces_field != ct.all_interfaces_field;\n+                        hasErrorSuper |= !ct.isCompound() && ct.interfaces_field != ct.all_interfaces_field;\n@@ -5445,2 +5462,7 @@\n-                    if (!hasErrorSuper) {\n-                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));\n+                        if (!hasErrorSuper) {\n+                            log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype(c));\n+                        }\n+                    }\n+                } else if ((c.flags_field & Flags.COMPOUND) == 0) {\n+                    if (c.isDirectlyOrIndirectlyLocal() && !c.isEnum()) {\n+                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed(c.isAnonymous() ? Fragments.Anonymous : Fragments.Local));\n@@ -5448,9 +5470,11 @@\n-                }\n-            } else if ((c.flags_field & Flags.COMPOUND) == 0) {\n-                if (c.isDirectlyOrIndirectlyLocal() && !c.isEnum()) {\n-                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed(c.isAnonymous() ? Fragments.Anonymous : Fragments.Local));\n-                }\n-                if (!c.type.isCompound()) {\n-                    for (ClassSymbol supertypeSym : sealedSupers) {\n-                        if (!supertypeSym.permitted.contains(c.type.tsym)) {\n-                            log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));\n+                    if (!c.type.isCompound()) {\n+                        for (ClassSymbol supertypeSym : sealedSupers) {\n+                            if (!supertypeSym.permitted.contains(c.type.tsym)) {\n+                                log.error(TreeInfo.diagnosticPositionFor(c.type.tsym, env.tree), Errors.CantInheritFromSealed(supertypeSym));\n+                            }\n+                        }\n+                        if (!c.isNonSealed() && !c.isFinal() && !c.isSealed()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(c, env.tree),\n+                                    c.isInterface() ?\n+                                            Errors.NonSealedOrSealedExpected :\n+                                            Errors.NonSealedSealedOrFinalExpected);\n@@ -5459,6 +5483,0 @@\n-                    }\n-                    if (!c.isNonSealed() && !c.isFinal() && !c.isSealed()) {\n-                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree),\n-                                c.isInterface() ?\n-                                        Errors.NonSealedOrSealedExpected :\n-                                        Errors.NonSealedSealedOrFinalExpected);\n@@ -5467,18 +5485,0 @@\n-            }\n-\n-            \/\/ The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,\n-            \/\/ because the annotations were not available at the time the env was created. Therefore,\n-            \/\/ we look up the environment chain for the first enclosing environment for which the\n-            \/\/ lint value is set. Typically, this is the parent env, but might be further if there\n-            \/\/ are any envs created as a result of TypeParameter nodes.\n-            Env<AttrContext> lintEnv = env;\n-            while (lintEnv.info.lint == null)\n-                lintEnv = lintEnv.next;\n-            \/\/ Having found the enclosing lint value, we can initialize the lint value for this class\n-            env.info.lint = lintEnv.info.lint.augment(c);\n-\n-            Lint prevLint = chk.setLint(env.info.lint);\n-            JavaFileObject prev = log.useSource(c.sourcefile);\n-            ResultInfo prevReturnRes = env.info.returnResult;\n-\n-            try {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":101,"deletions":101,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -3619,0 +3619,12 @@\n+\n+        @Override\n+        Symbol access(Env<AttrContext> env, DiagnosticPosition pos, Symbol location, Symbol sym) {\n+            if (originalSite.hasTag(TYPEVAR) && sym.kind == MTH) {\n+                sym = (sym.flags() & Flags.PRIVATE) != 0 ?\n+                        new AccessError(env, site, sym) :\n+                        sym;\n+                return accessBase(sym, pos, location, originalSite, name, true);\n+            } else {\n+                return super.access(env, pos, location, sym);\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1365,9 +1365,0 @@\n-    public static JCModuleDecl getModule(JCCompilationUnit t) {\n-        if (t.defs.nonEmpty()) {\n-            JCTree def = t.defs.head;\n-            if (def.hasTag(MODULEDEF))\n-                return (JCModuleDecl) def;\n-        }\n-        return null;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"}]}