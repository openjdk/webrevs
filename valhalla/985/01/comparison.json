{"files":[{"patch":"@@ -94,6 +94,0 @@\n-    \/**\n-     * The modifier {@code identity}\n-     * @since 18\n-     *\/\n-    IDENTITY,\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.source.tree;\n-\n-\/**\n- * A tree node for a {@code default} instance initializion expression.\n- *\n- * For example:\n- * <pre>{@code\n- *   Optional<String>.default\n- * }<\/pre>\n- *\n- * @jls todo\n- *\n- * @since valhalla\n- *\/\n-public interface DefaultValueTree extends ExpressionTree {\n-\n-    \/**\n-     * Returns the name of the class of the instance being initialized.\n-     * @return the name\n-     *\/\n-    ExpressionTree getType();\n-\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/DefaultValueTree.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -300,7 +300,0 @@\n-        \/**\n-         * Used for instances of {@link DefaultValueTree}.\n-         *\n-         * @since valhalla\n-         *\/\n-        DEFAULT_VALUE(DefaultValueTree.class),\n-\n@@ -357,5 +350,0 @@\n-        \/**\n-         * Used for instances of {@link WithFieldTree}.\n-         *\/\n-        WITH_FIELD(WithFieldTree.class),\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -174,8 +174,0 @@\n-    \/**\n-     * Visits a {@code DefaultValue} node.\n-     * @param node the node being visited\n-     * @param p a parameter value\n-     * @return a result value\n-     *\/\n-    R visitDefaultValue(DefaultValueTree node, P p);\n-\n@@ -561,9 +553,0 @@\n-     * Visits a {@code WithFieldTree} node.\n-     * @param node the node being visited\n-     * @param p a parameter value\n-     * @return a result value\n-     *\/\n-    R visitWithField(WithFieldTree node, P p);\n-\n-    \/**\n-     * Visits a WildcardTypeTree node.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.source.tree;\n-\n-\/**\n- * A tree node for a {@code withfield} expression.\n- *\n- * For example:\n- * <pre>\n- *   x = __WithField(x.x, val)\n- * <\/pre>\n- *\n- * @since 1.11\n- *\/\n-public interface WithFieldTree extends ExpressionTree {\n-    \/**\n-     * Returns the field being updated.\n-     * @return the field\n-     *\/\n-    ExpressionTree getField();\n-\n-    \/**\n-     * Returns the value to which the field is updated.\n-     * @return the value\n-     *\/\n-    ExpressionTree getValue();\n-}\n\\ No newline at end of file\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/WithFieldTree.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -239,14 +239,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation calls {@code defaultAction}.\n-     *\n-     * @param node {@inheritDoc}\n-     * @param p {@inheritDoc}\n-     * @return  the result of {@code defaultAction}\n-     *\/\n-    @Override\n-    public R visitWithField(WithFieldTree node, P p) {\n-        return defaultAction(node, p);\n-    }\n-\n@@ -345,12 +331,0 @@\n-    public R visitDefaultValue(DefaultValueTree node, P p) {\n-        return defaultAction(node, p);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} This implementation calls {@code defaultAction}.\n-     *\n-     * @param node {@inheritDoc}\n-     * @param p {@inheritDoc}\n-     * @return  the result of {@code defaultAction}\n-     *\/\n-    @Override\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -307,16 +307,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation scans the children in left to right order.\n-     *\n-     * @param node  {@inheritDoc}\n-     * @param p  {@inheritDoc}\n-     * @return the result of scanning\n-     *\/\n-    @Override\n-    public R visitWithField(WithFieldTree node, P p) {\n-        R r = scan(node.getField(), p);\n-        r = scanAndReduce(node.getValue(), p, r);\n-        return r;\n-    }\n-\n@@ -432,12 +416,0 @@\n-    public R visitDefaultValue(DefaultValueTree node, P p) {\n-        return scan(node.getType(), p);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} This implementation scans the children in left to right order.\n-     *\n-     * @param node  {@inheritDoc}\n-     * @param p  {@inheritDoc}\n-     * @return the result of scanning\n-     *\/\n-    @Override\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -604,2 +604,1 @@\n-        Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n-        for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n+        for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n@@ -625,1 +624,1 @@\n-        if (names.isInitOrVNew(methodName))\n+        if (methodName == names.init)\n@@ -1141,1 +1140,1 @@\n-                                  classType.tsym, classType.getMetadata(), classType.getFlavor()) {\n+                            classType.tsym, classType.getMetadata()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -102,7 +102,0 @@\n-    \/** Marks a type as a primitive class. We can't reuse the class file encoding (ACC_PRIMITIVE)\n-     * since the latter shares its value (0x800) with ACC_STRICT (javac speak: STRICT_FP) and while\n-     * STRICT_FP is not a valid flag for a class in the class file level, javac's ASTs flag a class\n-     * as being STRICT_FP so as to propagate the FP strictness to methods of the class thereby causing\n-     * a clash *\/\n-    public static final int PRIMITIVE_CLASS  = 1<<16;\n-\n@@ -116,1 +109,0 @@\n-    public static final int ACC_VALUE    = 0x0040;\n@@ -119,1 +111,0 @@\n-    public static final int ACC_PRIMITIVE = 0x0800;\n@@ -135,13 +126,0 @@\n-    \/** Flag is set for a class symbol if it defines one or more non-empty\n-     *  instance initializer block(s). This is relevenat only for class symbols\n-     *  that originate from source types. For binary types the instance initializer\n-     *  blocks are \"normalized\" into the constructors.\n-     *\/\n-    public static final int HASINITBLOCK         = 1<<18;\n-\n-    \/** Flag is set for a method symbol if it is an empty no-arg ctor.\n-     *  i.e. one that simply returns (jlO) or merely chains to a super's\n-     *  no-arg ctor\n-     *\/\n-    public static final int EMPTYNOARGCONSTR         = 1<<18;\n-\n@@ -149,4 +127,3 @@\n-     * i.e. class\/interface declarations that are expressly declared with\n-     * the modifier `identity' or (b) any concrete class not declared with the\n-     * modifier `value' (c) abstract class not declared `value' but meets various\n-     * stipulations (d) older class files with ACC_SUPER bit set\n+     * i.e. any concrete class not declared with the modifier `value'\n+     * (a) abstract class not declared `value'\n+     * (b) older class files with ACC_SUPER bit set\n@@ -462,2 +439,1 @@\n-                                            SYNCHRONIZED | FINAL | STRICTFP,\n-        AdjustedClassFlags                = ClassFlags | ACC_PRIMITIVE | ACC_VALUE;\n+                                            SYNCHRONIZED | FINAL | STRICTFP;\n@@ -465,7 +441,7 @@\n-        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedLocalClassFlags           = (long) LocalClassFlags | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ExtendedStaticLocalClassFlags     = (long) StaticLocalClassFlags | PRIMITIVE_CLASS | VALUE_CLASS,\n-        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS,\n+        ExtendedStandardFlags             = (long)StandardFlags | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedMemberClassFlags          = (long)MemberClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedMemberStaticClassFlags    = (long) MemberStaticClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedClassFlags                = (long)ClassFlags | SEALED | NON_SEALED | VALUE_CLASS,\n+        ExtendedLocalClassFlags           = (long) LocalClassFlags | VALUE_CLASS,\n+        ExtendedStaticLocalClassFlags     = (long) StaticLocalClassFlags | VALUE_CLASS,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n@@ -497,1 +473,0 @@\n-            if (0 != (flags & PRIMITIVE_CLASS))     modifiers.add(Modifier.PRIMITIVE);\n@@ -520,1 +495,0 @@\n-\n@@ -540,2 +514,0 @@\n-        HASINITBLOCK(Flags.HASINITBLOCK),\n-        EMPTYNOARGCONSTR(Flags.EMPTYNOARGCONSTR),\n@@ -548,0 +520,1 @@\n+        VALUE(Flags.VALUE_CLASS),\n@@ -553,2 +526,0 @@\n-        PRIMITIVE(Flags.PRIMITIVE_CLASS),\n-        VALUE(Flags.VALUE_CLASS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":12,"deletions":41,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -215,0 +215,1 @@\n+            case SUPER_INIT -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -237,10 +237,0 @@\n-        boolean isReferenceProjection;\n-        try {\n-            isReferenceProjection = t.isReferenceProjection();\n-        } catch (CompletionFailure cf) {\n-            isReferenceProjection = false; \/\/ handle missing types gracefully.\n-        }\n-        if (isReferenceProjection) {\n-            buf.append('.');\n-            buf.append(t.tsym.name.table.names.ref);\n-        }\n@@ -384,1 +374,3 @@\n-            String ms = s.isInitOrVNew() ? s.owner.name.toString() : s.name.toString();\n+            String ms = (s.name == s.name.table.names.init)\n+                    ? s.owner.name.toString()\n+                    : s.name.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -248,1 +248,0 @@\n-        PRIMITIVE_CLASSES(JDK21, Fragments.FeaturePrimitiveClasses, DiagKind.PLURAL),\n@@ -253,0 +252,1 @@\n+        SUPER_INIT(JDK22, Fragments.FeatureSuperInit, DiagKind.NORMAL),\n@@ -308,3 +308,0 @@\n-            if (this == PRIMITIVE_CLASSES) {\n-                return Errors.PrimitiveClassesNotSupported(minLevel.name);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.HashMap;\n@@ -55,1 +54,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -360,1 +358,1 @@\n-        if (isInitOrVNew() && owner.hasOuterInstance()) {\n+        if (name == name.table.names.init && owner.hasOuterInstance()) {\n@@ -408,1 +406,1 @@\n-        return (flags() & INTERFACE) != 0;\n+        return (flags_field & INTERFACE) != 0;\n@@ -419,4 +417,0 @@\n-    public boolean isPrimitiveClass() {\n-        return (flags() & PRIMITIVE_CLASS) != 0;\n-    }\n-\n@@ -424,5 +418,1 @@\n-        return !isInterface() && (flags() & VALUE_CLASS) != 0;\n-    }\n-\n-    public boolean isConcreteValueClass() {\n-        return isValueClass() && !isAbstract();\n+        return (flags_field & VALUE_CLASS) != 0;\n@@ -432,9 +422,1 @@\n-        return !isInterface() && (flags() & IDENTITY_TYPE) != 0;\n-    }\n-\n-    public boolean isValueInterface() {\n-        return isInterface() && (flags() & VALUE_CLASS) != 0;\n-    }\n-\n-    public boolean isIdentityInterface() {\n-        return isInterface() && (flags() & IDENTITY_TYPE) != 0;\n+        return !isInterface() && (flags_field & IDENTITY_TYPE) != 0;\n@@ -484,13 +466,1 @@\n-        return name == name.table.names.init && (flags() & STATIC) == 0;\n-    }\n-\n-    \/** Is this symbol a value object factory?\n-     *\/\n-    public boolean isValueObjectFactory() {\n-        return name == name.table.names.vnew && this.type.getReturnType().tsym == this.owner;\n-    }\n-\n-    \/** Is this symbol a constructor or value factory?\n-     *\/\n-    public boolean isInitOrVNew() {\n-        return name.table.names.isInitOrVNew(name);\n+        return name == name.table.names.init;\n@@ -1359,1 +1329,1 @@\n-                new ClassType(Type.noType, null, null, List.nil(), Flavor.X_Typeof_X),\n+                new ClassType(Type.noType, null, null, List.nil()),\n@@ -1396,2 +1366,1 @@\n-                                              type.getMetadata(),\n-                                              type.getFlavor());\n+                                              type.getMetadata());\n@@ -1463,8 +1432,0 @@\n-            } finally {\n-                if (this.type != null && this.type.hasTag(CLASS)) {\n-                    ClassType ct = (ClassType) this.type;\n-                    ct.flavor = ct.flavor.metamorphose((this.flags_field & PRIMITIVE_CLASS) != 0);\n-                    if (!this.type.isIntersection() && this.erasure_field != null && this.erasure_field.hasTag(CLASS)) {\n-                        ((ClassType) this.erasure_field).flavor = ct.flavor;\n-                    }\n-                }\n@@ -1658,1 +1619,0 @@\n-                classType.flavor = Flavor.X_Typeof_X;\n@@ -2022,1 +1982,1 @@\n-                String s = isInitOrVNew()\n+                String s = (name == name.table.names.init)\n@@ -2084,1 +2044,1 @@\n-            if (isInitOrVNew() || _other.kind != MTH) return false;\n+            if (isConstructor() || _other.kind != MTH) return false;\n@@ -2091,1 +2051,1 @@\n-                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null &&\n+                types.asSuper(owner.type, other.owner) != null &&\n@@ -2153,1 +2113,1 @@\n-            if (isInitOrVNew() || _other.kind != MTH) return false;\n+            if (isConstructor() || _other.kind != MTH) return false;\n@@ -2160,1 +2120,1 @@\n-                types.asSuper(owner.type.referenceProjectionOrSelf(), other.owner) != null) {\n+                types.asSuper(owner.type, other.owner) != null) {\n@@ -2277,1 +2237,1 @@\n-            if (isInitOrVNew())\n+            if (name == name.table.names.init)\n@@ -2450,1 +2410,1 @@\n-                if (refSym.isInitOrVNew()) {\n+                if (refSym.isConstructor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":14,"deletions":54,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Type.WildcardType;\n@@ -69,1 +68,0 @@\n-import com.sun.tools.javac.util.Options;\n@@ -98,2 +96,0 @@\n-    private final boolean allowPrimitiveClasses;\n-\n@@ -295,11 +291,2 @@\n-                if (type.getTag() == ARRAY || type.getTag() == CLASS) {\n-                    \/* Temporary treatment for primitive class: Given a primitive class V that implements\n-                       I1, I2, ... In, V.class is typed to be Class<? extends Object & I1 & I2 .. & In>\n-                    *\/\n-                    if (allowPrimitiveClasses && type.isPrimitiveClass()) {\n-                        List<Type> bounds = List.of(objectType).appendList(((ClassSymbol) type.tsym).getInterfaces());\n-                        arg = new WildcardType(bounds.size() > 1 ? types.makeIntersectionType(bounds) : objectType, BoundKind.EXTENDS, boundClass);\n-                    } else {\n-                        arg = types.erasure(type);\n-                    }\n-                }\n+                if (type.getTag() == ARRAY || type.getTag() == CLASS)\n+                    arg = types.erasure(type);\n@@ -695,2 +682,1 @@\n-        Options options = Options.instance(context);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -235,4 +234,0 @@\n-    public boolean isPrimitiveClass() {\n-        return false;\n-    }\n-\n@@ -243,4 +238,0 @@\n-    public boolean isValueInterface() {\n-        return false;\n-    }\n-\n@@ -251,4 +242,0 @@\n-    public boolean isIdentityInterface() {\n-        return false;\n-    }\n-\n@@ -259,43 +246,1 @@\n-        if (this.isReferenceProjection())\n-            return true;\n-        return this.isValueClass() && !this.isPrimitiveClass();\n-    }\n-\n-    \/**\n-     * Return the `flavor' associated with a ClassType.\n-     * @see ClassType.Flavor\n-     *\/\n-    public Flavor getFlavor() {\n-        throw new AssertionError(\"Unexpected call to getFlavor() on a Type that is not a ClassType: \" + this);\n-    }\n-\n-    \/**\n-     * @return true IFF the receiver is a reference projection of a primitive class type and false\n-     * for primitives or plain references\n-     *\/\n-    public boolean isReferenceProjection() {\n-        return false;\n-    }\n-\n-    \/**\n-     * @return the value projection type IFF the receiver is a reference projection of a primitive class type\n-     * and null otherwise\n-     *\/\n-    public Type valueProjection() {\n-        return null;\n-    }\n-\n-    \/**\n-     * @return the reference projection type IFF the receiver is a primitive class type\n-     * and null otherwise\n-     *\/\n-    public Type referenceProjection() {\n-        return null;\n-    }\n-\n-    \/**\n-     * @return the reference projection type IFF the receiver is a primitive class type or self otherwise.\n-     *\/\n-    public Type referenceProjectionOrSelf() {\n-        Type projection = referenceProjection();\n-        return projection != null ? projection : this;\n+        return this.isValueClass();\n@@ -318,1 +263,1 @@\n-            else return new ClassType(outer1, typarams1, t.tsym, t.metadata, t.getFlavor()) {\n+            else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {\n@@ -1056,34 +1001,0 @@\n-    public static class ConstantPoolQType implements PoolConstant {\n-\n-        public final Type type;\n-        final Types types;\n-\n-        public ConstantPoolQType(Type type, Types types) {\n-            this.type = type;\n-            this.types = types;\n-        }\n-\n-        @Override\n-        public Object poolKey(Types types) {\n-            return this;\n-        }\n-\n-        @Override\n-        public int poolTag() {\n-            return ClassFile.CONSTANT_Class;\n-        }\n-\n-        public int hashCode() {\n-            return types.hashCode(type);\n-        }\n-\n-        public boolean equals(Object obj) {\n-            return (obj instanceof ConstantPoolQType) &&\n-                    types.isSameType(type, ((ConstantPoolQType)obj).type);\n-        }\n-\n-        public String toString() {\n-            return type.toString();\n-        }\n-    }\n-\n@@ -1093,78 +1004,0 @@\n-        \/**\n-         * The 'flavor' of a ClassType indicates its reference\/primitive projectionness\n-         * viewed against the default nature of the associated class.\n-         *\/\n-        public enum Flavor {\n-\n-            \/**\n-             * Classic reference type. Also reference projection type of a reference-favoring aka\n-             * reference-default primitive class type\n-             *\/\n-            L_TypeOf_L,\n-\n-            \/**\n-             * Reference projection type of a primitive-favoring aka primitive-default\n-             * plain vanilla primitive class type,\n-             *\/\n-            L_TypeOf_Q,\n-\n-            \/**\n-             * Value projection type of a primitive-favoring aka primitive-default\n-             * plain vanilla primitive class type,\n-             *\/\n-            Q_TypeOf_Q,\n-\n-            \/**\n-             * Value projection type of a reference-favoring aka\n-             * reference-default primitive class type\n-             *\/\n-            Q_TypeOf_L,\n-\n-            \/**\n-             * Reference projection type of a class type of an as yet unknown default provenance, 'X' will be\n-             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n-             *\/\n-            L_TypeOf_X,\n-\n-            \/**\n-             * Value projection type of a class type of an as yet unknown default provenance, 'X' will be\n-             * discovered to be 'L' or 'Q' in \"due course\" and mutated suitably.\n-             *\/\n-            Q_TypeOf_X,\n-\n-            \/**\n-             *  As yet unknown projection type of an as yet unknown default provenance class.\n-             *\/\n-            X_Typeof_X,\n-\n-            \/**\n-             *  An error type - we don't care to discriminate them any further.\n-             *\/\n-             E_Typeof_X;\n-\n-            \/\/ We don't seem to need X_Typeof_L or X_Typeof_Q so far.\n-\n-            \/\/ Transform a larval form into a more evolved form\n-            public Flavor metamorphose(boolean isPrimtiveClass) {\n-\n-                switch (this) {\n-\n-                    case E_Typeof_X:  \/\/ stunted form\n-                    case L_TypeOf_L:\n-                    case L_TypeOf_Q:\n-                    case Q_TypeOf_L:\n-                    case Q_TypeOf_Q:\n-                            \/\/ These are fully evolved sealed forms or stunted - no futher transformation\n-                            return this;\n-                    case L_TypeOf_X:\n-                            return isPrimtiveClass ? L_TypeOf_Q : L_TypeOf_L;\n-                    case Q_TypeOf_X:\n-                            return isPrimtiveClass ? Q_TypeOf_Q : Q_TypeOf_L;\n-                    case X_Typeof_X:\n-                            return isPrimtiveClass ? Q_TypeOf_Q : L_TypeOf_L;\n-                    default:\n-                            throw new AssertionError(\"Unexpected class type flavor\");\n-                }\n-            }\n-        }\n-\n@@ -1199,13 +1032,0 @@\n-        \/** The 'other' projection: If 'this' is type of a primitive class, then 'projection' is the\n-         *  reference projection type and vice versa. Lazily initialized, not to be accessed directly.\n-        *\/\n-        public ClassType projection;\n-\n-        \/** Is this L of default {L, Q, X} or Q of default {L, Q, X} ?\n-         *\/\n-        public Flavor flavor;\n-\n-        \/*\n-         * Use of this constructor is kinda sorta deprecated, use the other constructor\n-         * that forces the call site to consider and include the class type flavor.\n-         *\/\n@@ -1213,5 +1033,1 @@\n-            this(outer, typarams, tsym, List.nil(), Flavor.L_TypeOf_L);\n-        }\n-\n-        public ClassType(Type outer, List<Type> typarams, TypeSymbol tsym, Flavor flavor) {\n-            this(outer, typarams, tsym, List.nil(), flavor);\n+            this(outer, typarams, tsym, List.nil());\n@@ -1221,1 +1037,1 @@\n-                         List<TypeMetadata> metadata, Flavor flavor) {\n+                         List<TypeMetadata> metadata) {\n@@ -1228,1 +1044,0 @@\n-            this.flavor = flavor;\n@@ -1237,1 +1052,1 @@\n-            return new ClassType(outer_field, typarams_field, tsym, md, flavor) {\n+            return new ClassType(outer_field, typarams_field, tsym, md) {\n@@ -1288,11 +1103,0 @@\n-            boolean isReferenceProjection;\n-            try {\n-                isReferenceProjection = isReferenceProjection();\n-            } catch (CompletionFailure cf) {\n-                isReferenceProjection = false; \/\/ handle missing types gracefully.\n-            }\n-            if (isReferenceProjection) {\n-                buf.append('.');\n-                buf.append(tsym.name.table.names.ref);\n-            }\n-\n@@ -1337,4 +1141,0 @@\n-        public Flavor getFlavor() {\n-            return flavor;\n-        }\n-\n@@ -1357,3 +1157,0 @@\n-            if (outer_field != null && outer_field.isReferenceProjection()) {\n-                outer_field = outer_field.valueProjection();\n-            }\n@@ -1391,5 +1188,0 @@\n-        @Override\n-        public boolean isPrimitiveClass() {\n-            return !isReferenceProjection() && tsym != null && tsym.isPrimitiveClass();\n-        }\n-\n@@ -1398,6 +1190,1 @@\n-            return !isReferenceProjection() && tsym != null && tsym.isValueClass();\n-        }\n-\n-        @Override\n-        public boolean isValueInterface() {\n-            return tsym != null && tsym.isValueInterface();\n+            return tsym != null && tsym.isValueClass();\n@@ -1408,55 +1195,1 @@\n-            return !isReferenceProjection() && tsym != null && tsym.isIdentityClass();\n-        }\n-\n-        @Override\n-        public boolean isIdentityInterface() {\n-            return isInterface() && tsym.isIdentityInterface();\n-        }\n-\n-        @Override\n-        public boolean isReferenceProjection() {\n-            \/\/ gaurd against over-eager and\/or inopportune completion\n-            if (tsym != null) {\n-                if (flavor == Flavor.L_TypeOf_X || tsym.isCompleted()) {\n-                    flavor = flavor.metamorphose(tsym.isPrimitiveClass());\n-                }\n-            }\n-            return flavor == Flavor.L_TypeOf_Q;\n-        }\n-\n-        @Override\n-        public Type valueProjection() {\n-            if (!isReferenceProjection())\n-                return null;\n-\n-            if (projection !=  null)\n-                return projection;\n-\n-            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.Q_TypeOf_Q);\n-            projection.allparams_field = allparams_field;\n-            projection.supertype_field = supertype_field;\n-\n-            projection.interfaces_field = interfaces_field;\n-            projection.all_interfaces_field = all_interfaces_field;\n-            projection.projection = this;\n-            return projection;\n-        }\n-\n-        \/\/ return the reference projection type preserving parameterizations\n-        @Override\n-        public ClassType referenceProjection() {\n-\n-            if (!isPrimitiveClass())\n-                return null;\n-\n-            if (projection != null)\n-                return projection;\n-\n-            projection = new ClassType(outer_field, typarams_field, tsym, getMetadata(), Flavor.L_TypeOf_Q);\n-            projection.allparams_field = allparams_field;\n-            projection.supertype_field = supertype_field;\n-\n-            projection.interfaces_field = interfaces_field;\n-            projection.all_interfaces_field = all_interfaces_field;\n-            projection.projection = this;\n-            return projection;\n+            return tsym != null && tsym.isIdentityClass();\n@@ -1513,1 +1246,1 @@\n-            super(outer, List.nil(), tsym, metadata, tsym.type.getFlavor());\n+            super(outer, List.nil(), tsym, metadata);\n@@ -2624,1 +2357,1 @@\n-            super(noType, List.nil(), tsym, List.nil(), Flavor.E_Typeof_X);\n+            super(noType, List.nil(), tsym, List.nil());\n@@ -2629,2 +2362,2 @@\n-                          List<TypeMetadata> metadata, Flavor flavor) {\n-            super(noType, List.nil(), null, metadata, flavor);\n+                          List<TypeMetadata> metadata) {\n+            super(noType, List.nil(), null, metadata);\n@@ -2637,1 +2370,1 @@\n-            return new ErrorType(originalType, tsym, md, getFlavor()) {\n+            return new ErrorType(originalType, tsym, md) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":12,"deletions":279,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-                    !s.isInitOrVNew())\n+                    !s.isConstructor())\n@@ -245,1 +245,1 @@\n-                    (s.kind == MTH && !s.isInitOrVNew() &&\n+                    (s.kind == MTH && !s.isConstructor() &&\n@@ -247,1 +247,1 @@\n-                    (s.kind == MTH && s.isInitOrVNew()))\n+                    (s.kind == MTH && s.isConstructor()))\n@@ -607,1 +607,1 @@\n-                                                      t.getMetadata(), t.getFlavor());\n+                                                      t.getMetadata());\n@@ -1025,1 +1025,1 @@\n-                    } else if (exsym.isInitOrVNew()) {\n+                    } else if (exsym.isConstructor()) {\n@@ -1132,1 +1132,1 @@\n-                    if (tree.sym.isInitOrVNew()) {\n+                    if (tree.sym.isConstructor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.BiFunction;\n@@ -94,1 +95,0 @@\n-    final boolean allowPrimitiveClasses;\n@@ -122,3 +122,6 @@\n-        noWarnings = new Warner(null);\n-        Options options = Options.instance(context);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        noWarnings = new Warner(null) {\n+            @Override\n+            public String toString() {\n+                return \"NO_WARNINGS\";\n+            }\n+        };\n@@ -273,1 +276,1 @@\n-                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata(), t.getFlavor()) {\n+                else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {\n@@ -604,11 +607,0 @@\n-\n-        if (allowPrimitiveClasses) {\n-            boolean tValue = t.isPrimitiveClass();\n-            boolean sValue = s.isPrimitiveClass();\n-            if (tValue != sValue) {\n-                return tValue ?\n-                        isSubtype(t.referenceProjection(), s) :\n-                        !t.hasTag(BOT) && isSubtype(t, s.referenceProjection());\n-            }\n-        }\n-\n@@ -777,4 +769,2 @@\n-            }\n-            FunctionDescriptor descRes;\n-            if (abstracts.size() == 1) {\n-                descRes = new FunctionDescriptor(abstracts.first());\n+            } else if (abstracts.size() == 1) {\n+                return new FunctionDescriptor(abstracts.first());\n@@ -782,1 +772,1 @@\n-                descRes = mergeDescriptors(origin, abstracts.toList());\n+                FunctionDescriptor descRes = mergeDescriptors(origin, abstracts.toList());\n@@ -801,0 +791,1 @@\n+                return descRes;\n@@ -802,11 +793,0 @@\n-            \/\/ an interface must be neither an identity interface nor a value interface to be functional.\n-            List<Type> allInterfaces = closure(origin.type);\n-            for (Type iface : allInterfaces) {\n-                if (iface.isValueInterface()) {\n-                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.ValueInterfaceNonfunctional));\n-                }\n-                if (iface.isIdentityInterface()) {\n-                    throw failure(\"not.a.functional.intf.1\", origin, diags.fragment(Fragments.IdentityInterfaceNonfunctional));\n-                }\n-            }\n-            return descRes;\n@@ -981,1 +961,1 @@\n-                        !names.isInitOrVNew(t.name) &&\n+                        t.name != names.init &&\n@@ -1052,13 +1032,1 @@\n-                    \/\/ if T.ref <: S, then T[] <: S[]\n-                    Type es = elemtype(s);\n-                    Type et = elemtype(t);\n-                    if (allowPrimitiveClasses) {\n-                        if (et.isPrimitiveClass()) {\n-                            et = et.referenceProjection();\n-                            if (es.isPrimitiveClass())\n-                                es = es.referenceProjection();  \/\/ V <: V, surely\n-                        }\n-                    }\n-                    if (!isSubtypeUncheckedInternal(et, es, false, warn))\n-                        return false;\n-                    return true;\n+                    return isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n@@ -1161,1 +1129,1 @@\n-                         s.hasTag(BOT) || (s.hasTag(CLASS) && (!allowPrimitiveClasses || !s.isPrimitiveClass())) ||\n+                         s.hasTag(BOT) || s.hasTag(CLASS) ||\n@@ -1228,1 +1196,0 @@\n-                    && (t.tsym != s.tsym || t.isReferenceProjection() == s.isReferenceProjection())\n@@ -1240,11 +1207,2 @@\n-                    else {\n-                        \/\/ if T.ref <: S, then T[] <: S[]\n-                        Type es = elemtype(s);\n-                        Type et = elemtype(t);\n-                        if (allowPrimitiveClasses && et.isPrimitiveClass()) {\n-                            et = et.referenceProjection();\n-                            if (es.isPrimitiveClass())\n-                                es = es.referenceProjection();  \/\/ V <: V, surely\n-                        }\n-                        return isSubtypeNoCapture(et, es);\n-                    }\n+                    else\n+                        return isSubtypeNoCapture(t.elemtype, elemtype(s));\n@@ -1470,2 +1428,1 @@\n-                    && t.isReferenceProjection() == s.isReferenceProjection()\n-                    && visit(getEnclosingType(t), getEnclosingType(s))\n+                    && visit(t.getEnclosingType(), s.getEnclosingType())\n@@ -1474,8 +1431,0 @@\n-                \/\/ where\n-                private Type getEnclosingType(Type t) {\n-                    Type et = t.getEnclosingType();\n-                    if (et.isReferenceProjection()) {\n-                        et = et.valueProjection();\n-                    }\n-                    return et;\n-                }\n@@ -1641,9 +1590,0 @@\n-\n-                    \/\/ -----------------------------------  Unspecified behavior ----------------\n-\n-                    \/* If a primitive class V implements an interface I, then does \"? extends I\" contain V?\n-                       It seems widening must be applied here to answer yes to compile some common code\n-                       patterns.\n-                    *\/\n-\n-                    \/\/ ---------------------------------------------------------------------------\n@@ -1739,1 +1679,1 @@\n-            if (isSubtype(erasure(ts.type.referenceProjectionOrSelf()), erasure(ss.type))) {\n+            if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n@@ -1794,1 +1734,1 @@\n-                if (s.hasTag(ERROR) || (s.hasTag(BOT) && (!allowPrimitiveClasses || !t.isPrimitiveClass())))\n+                if (s.hasTag(ERROR) || s.hasTag(BOT))\n@@ -1813,10 +1753,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        if (t.isPrimitiveClass()) {\n-                            \/\/ (s) Value ? == (s) Value.ref\n-                            t = t.referenceProjection();\n-                        }\n-                        if (s.isPrimitiveClass()) {\n-                            \/\/ (Value) t ? == (Value.ref) t\n-                            s = s.referenceProjection();\n-                        }\n-                    }\n@@ -2199,0 +2129,4 @@\n+        return makeArrayType(t, 1);\n+    }\n+\n+    public ArrayType makeArrayType(Type t, int dimensions) {\n@@ -2202,1 +2136,5 @@\n-        return new ArrayType(t, syms.arrayClass);\n+        ArrayType result = new ArrayType(t, syms.arrayClass);\n+        for (int i = 1; i < dimensions; i++) {\n+            result = new ArrayType(result, syms.arrayClass);\n+        }\n+        return result;\n@@ -2216,29 +2154,0 @@\n-     * Further caveats in Valhalla: There are two \"hazards\" we need to watch out for when using\n-     * this method.\n-     *\n-     * 1. Since Foo.ref and Foo.val share the same symbol, that of Foo.class, a call to\n-     *    asSuper(Foo.ref.type, Foo.val.type.tsym) would return non-null. This MAY NOT BE correct\n-     *    depending on the call site. Foo.val is NOT a super type of Foo.ref either in the language\n-     *    model or in the VM's world view. An example of such an hazardous call used to exist in\n-     *    Gen.visitTypeCast. When we emit code for  (Foo) Foo.ref.instance a check for whether we\n-     *    really need the cast cannot\/shouldn't be gated on\n-     *\n-     *        asSuper(tree.expr.type, tree.clazz.type.tsym) == null)\n-     *\n-     *    but use !types.isSubtype(tree.expr.type, tree.clazz.type) which operates in terms of\n-     *    types. When we operate in terms of symbols, there is a loss of type information leading\n-     *    to a hazard. Whether a call to asSuper should be transformed into a isSubtype call is\n-     *    tricky. isSubtype returns just a boolean while asSuper returns richer information which\n-     *    may be required at the call site. Also where the concerned symbol corresponds to a\n-     *    generic class, an asSuper call cannot be conveniently rewritten as an isSubtype call\n-     *    (see that asSuper(ArrayList<String>.type, List<T>.tsym) != null while\n-     *    isSubType(ArrayList<String>.type, List<T>.type) is false;) So care needs to be exercised.\n-     *\n-     * 2. Given a primitive class Foo, a call to asSuper(Foo.type, SuperclassOfFoo.tsym) and\/or\n-     *    a call to asSuper(Foo.type, SuperinterfaceOfFoo.tsym) would answer null. In many places\n-     *    that is NOT what we want. An example of such a hazardous call used to occur in\n-     *    Attr.visitForeachLoop when checking to make sure the for loop's control variable of a type\n-     *    that implements Iterable: viz: types.asSuper(exprType, syms.iterableType.tsym);\n-     *    These hazardous calls should be rewritten as\n-     *    types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym); instead.\n-     *\n@@ -2257,6 +2166,0 @@\n-\n-        if (allowPrimitiveClasses && t.isPrimitiveClass()) {\n-            \/\/ No man may be an island, but the bell tolls for a value.\n-            return t.tsym == sym ? t : null;\n-        }\n-\n@@ -2393,12 +2296,3 @@\n-\n-        if ((sym.flags() & STATIC) != 0)\n-            return sym.type;\n-\n-        \/* If any primitive class types are involved, switch over to the reference universe,\n-           where the hierarchy is navigable. V and V.ref have identical membership\n-           with no bridging needs.\n-        *\/\n-        if (allowPrimitiveClasses && t.isPrimitiveClass())\n-            t = t.referenceProjection();\n-\n-        return memberType.visit(t, sym);\n+        return (sym.flags() & STATIC) != 0\n+            ? sym.type\n+            : memberType.visit(t, sym);\n@@ -2533,1 +2427,1 @@\n-                        default: return s.dropMetadata(Annotations.class);\n+                        default: return s.cloneWithMetadata(t.getMetadata()).dropMetadata(Annotations.class);\n@@ -2557,19 +2451,7 @@\n-                \/\/ erasure(projection(primitive)) = projection(erasure(primitive))\n-                Type erased = eraseClassType(t, recurse);\n-                if (erased.hasTag(CLASS) && t.flavor != erased.getFlavor()) {\n-                    erased = new ClassType(erased.getEnclosingType(),\n-                            List.nil(), erased.tsym,\n-                            erased.getMetadata(), t.flavor);\n-                }\n-                return erased;\n-            }\n-                \/\/ where\n-                private Type eraseClassType(ClassType t, Boolean recurse) {\n-                    Type erased = t.tsym.erasure(Types.this);\n-                    if (recurse) {\n-                        erased = new ErasedClassType(erased.getEnclosingType(), erased.tsym,\n-                                                     t.dropMetadata(Annotations.class).getMetadata());\n-                        return erased;\n-                    } else {\n-                        return combineMetadata(erased, t);\n-                    }\n+                Type erased = t.tsym.erasure(Types.this);\n+                if (recurse) {\n+                    erased = new ErasedClassType(erased.getEnclosingType(),erased.tsym,\n+                            t.dropMetadata(Annotations.class).getMetadata());\n+                    return erased;\n+                } else {\n+                    return combineMetadata(erased, t);\n@@ -2577,0 +2459,1 @@\n+            }\n@@ -2896,1 +2779,1 @@\n-                                         t.getMetadata(), t.getFlavor());\n+                                         t.getMetadata());\n@@ -4017,1 +3900,1 @@\n-                                 class1.tsym, List.nil(), class1.getFlavor());\n+                                 class1.tsym, List.nil());\n@@ -4577,1 +4460,1 @@\n-                                 cls.getMetadata(), cls.getFlavor());\n+                                 cls.getMetadata());\n@@ -5251,4 +5134,1 @@\n-                    if (types.allowPrimitiveClasses && type.isPrimitiveClass())\n-                        append('Q');\n-                    else\n-                        append('L');\n+                    append('L');\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":45,"deletions":165,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -559,1 +559,0 @@\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -170,1 +169,1 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -189,1 +188,1 @@\n-    \/** Switch: allow primitive classes ?\n+    \/** Switch: allow value classes ?\n@@ -191,1 +190,1 @@\n-    boolean allowPrimitiveClasses;\n+    boolean allowValueClasses;\n@@ -281,1 +280,1 @@\n-            ((names.isInitOrVNew(owner.name) ||    \/\/ i.e. we are in a constructor\n+            ((owner.name == names.init ||    \/\/ i.e. we are in a constructor\n@@ -808,1 +807,1 @@\n-                List<Type> bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));\n+                List<Type> bounds = List.of(attribType(tvar.bounds.head, env));\n@@ -810,1 +809,1 @@\n-                    bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));\n+                    bounds = bounds.prepend(attribType(bound, env));\n@@ -946,0 +945,2 @@\n+        boolean ctorProloguePrev = env.info.ctorPrologue;\n+        env.info.ctorPrologue = false;\n@@ -968,3 +969,2 @@\n-                \/\/ If this class appears as an anonymous class\n-                \/\/ in a superclass constructor call\n-                \/\/ disable implicit outer instance from being passed.\n+                \/\/ If this class appears as an anonymous class in a constructor\n+                \/\/ prologue, disable implicit outer instance from being passed.\n@@ -972,2 +972,1 @@\n-                if (env.info.isSelfCall &&\n-                        env.tree.hasTag(NEWCLASS)) {\n+                if (ctorProloguePrev && env.tree.hasTag(NEWCLASS)) {\n@@ -981,0 +980,1 @@\n+            env.info.ctorPrologue = ctorProloguePrev;\n@@ -990,0 +990,2 @@\n+        boolean ctorProloguePrev = env.info.ctorPrologue;\n+        env.info.ctorPrologue = false;\n@@ -1053,0 +1055,3 @@\n+            \/\/ Is this method a constructor?\n+            boolean isConstructor = TreeInfo.isConstructor(tree);\n+\n@@ -1080,1 +1085,1 @@\n-                if (names.isInitOrVNew(tree.name)) {\n+                if (isConstructor) {\n@@ -1083,5 +1088,2 @@\n-                        JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);\n-                        if (app == null ||\n-                                TreeInfo.name(app.meth) != names._this ||\n-                                !checkFirstConstructorStat(app, tree, false)) {\n-                            log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor(env.enclClass.sym));\n+                        if (!TreeInfo.hasConstructorCall(tree, names._this)) {\n+                            log.error(tree, Errors.NonCanonicalConstructorInvokeAnotherConstructor(env.enclClass.sym));\n@@ -1113,5 +1115,1 @@\n-                            JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);\n-                            if (app != null &&\n-                                    (TreeInfo.name(app.meth) == names._this ||\n-                                            TreeInfo.name(app.meth) == names._super) &&\n-                                    checkFirstConstructorStat(app, tree, false)) {\n+                            if (TreeInfo.hasAnyConstructorCall(tree)) {\n@@ -1195,5 +1193,3 @@\n-                if (names.isInitOrVNew(tree.name) && owner.type != syms.objectType) {\n-                    JCBlock body = tree.body;\n-                    if (body.stats.isEmpty() ||\n-                            TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {\n-                        JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),\n+                if (isConstructor && owner.type != syms.objectType) {\n+                    if (!TreeInfo.hasAnyConstructorCall(tree)) {\n+                        JCStatement supCall = make.at(tree.body.pos).Exec(make.Apply(List.nil(),\n@@ -1201,1 +1197,1 @@\n-                        body.stats = body.stats.prepend(supCall);\n+                        tree.body.stats = tree.body.stats.prepend(supCall);\n@@ -1204,1 +1200,1 @@\n-                            TreeInfo.isSuperCall(body.stats.head)) {\n+                            TreeInfo.hasConstructorCall(tree, names._super)) {\n@@ -1211,6 +1207,0 @@\n-                    } else if ((env.enclClass.sym.flags() & VALUE_CLASS) != 0 &&\n-                        (tree.mods.flags & GENERATEDCONSTR) == 0 &&\n-                        TreeInfo.isSuperCall(body.stats.head)) {\n-                        \/\/ value constructors are not allowed to call super directly,\n-                        \/\/ but tolerate compiler generated ones, these are ignored during code generation\n-                        log.error(tree.body.stats.head.pos(), Errors.CallToSuperNotAllowedInValueCtor);\n@@ -1240,0 +1230,3 @@\n+                \/\/ Start of constructor prologue\n+                localEnv.info.ctorPrologue = isConstructor;\n+\n@@ -1249,0 +1242,1 @@\n+            env.info.ctorPrologue = ctorProloguePrev;\n@@ -1304,3 +1298,0 @@\n-            \/* Don't want constant propagation\/folding for instance fields of primitive classes,\n-               as these can undergo updates via copy on write.\n-            *\/\n@@ -1308,1 +1299,1 @@\n-                if ((v.flags_field & FINAL) == 0 || ((v.flags_field & STATIC) == 0 && v.owner.isValueClass()) ||\n+                if ((v.flags_field & FINAL) == 0 ||\n@@ -1566,1 +1557,1 @@\n-                Type base = types.asSuper(exprType.referenceProjectionOrSelf(), syms.iterableType.tsym);\n+                Type base = types.asSuper(exprType, syms.iterableType.tsym);\n@@ -1582,1 +1573,1 @@\n-                    if (types.asSuper(iterSymbol.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym) == null) {\n+                    if (types.asSuper(iterSymbol.type.getReturnType(), syms.iteratorType.tsym) == null) {\n@@ -2019,1 +2010,1 @@\n-            types.asSuper(resource.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null &&\n+            types.asSuper(resource, syms.autoCloseableType.tsym) != null &&\n@@ -2208,2 +2199,1 @@\n-            \/\/ Those were all the cases that could result in a primitive. See if primitive boxing and primitive\n-            \/\/ value conversions bring about a convergence.\n+            \/\/ Those were all the cases that could result in a primitive\n@@ -2211,2 +2201,1 @@\n-                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type\n-                                         : t.isReferenceProjection() ? t.valueProjection() : t)\n+                                 .map(t -> t.isPrimitive() ? types.boxedClass(t).type : t)\n@@ -2223,1 +2212,1 @@\n-                                 .map(t -> chk.checkNonVoid(posIt.next(), allowPrimitiveClasses && t.isPrimitiveClass() ? t.referenceProjection() : t))\n+                                 .map(t -> chk.checkNonVoid(posIt.next(), t))\n@@ -2226,1 +2215,1 @@\n-            \/\/ both are known to be reference types (or projections).  The result is\n+            \/\/ both are known to be reference types.  The result is\n@@ -2539,7 +2528,0 @@\n-            \/\/ We are seeing a ...this(...) or ...super(...) call.\n-            \/\/ Check that this is the first statement in a constructor.\n-            checkFirstConstructorStat(tree, env.enclMethod, true);\n-\n-            \/\/ Record the fact\n-            \/\/ that this is a constructor call (using isSelfCall).\n-            localEnv.info.isSelfCall = true;\n@@ -2548,1 +2530,0 @@\n-            localEnv.info.constructorArgs = true;\n@@ -2550,1 +2531,0 @@\n-            localEnv.info.constructorArgs = false;\n@@ -2554,0 +2534,3 @@\n+            \/\/ Done with this()\/super() parameters. End of constructor prologue.\n+            env.info.ctorPrologue = false;\n+\n@@ -2664,4 +2647,0 @@\n-                \/\/ Special treatment for primitive classes: Given an expression v of type V where\n-                \/\/ V is a primitive class, v.getClass() is typed to be Class<? extends |V.ref|>\n-                Type wcb = types.erasure(allowPrimitiveClasses && qualifierType.isPrimitiveClass() ?\n-                                         qualifierType.referenceProjection() : qualifierType.baseType());\n@@ -2669,1 +2648,1 @@\n-                        List.of(new WildcardType(wcb,\n+                        List.of(new WildcardType(types.erasure(qualifierType.baseType()),\n@@ -2673,2 +2652,1 @@\n-                        restype.getMetadata(),\n-                        restype.getFlavor());\n+                        restype.getMetadata());\n@@ -2687,20 +2665,0 @@\n-        \/** Check that given application node appears as first statement\n-         *  in a constructor call.\n-         *  @param tree          The application node\n-         *  @param enclMethod    The enclosing method of the application.\n-         *  @param error         Should an error be issued?\n-         *\/\n-        boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {\n-            if (enclMethod != null && names.isInitOrVNew(enclMethod.name)) {\n-                JCBlock body = enclMethod.body;\n-                if (body.stats.head.hasTag(EXEC) &&\n-                    ((JCExpressionStatement) body.stats.head).expr == tree)\n-                    return true;\n-            }\n-            if (error) {\n-                log.error(tree.pos(),\n-                        Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));\n-            }\n-            return false;\n-        }\n-\n@@ -2843,10 +2801,0 @@\n-            \/\/ Check that it is an instantiation of a class and not a projection type\n-            if (allowPrimitiveClasses) {\n-                if (clazz.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) clazz;\n-                    if (fieldAccess.selected.type.isPrimitiveClass() &&\n-                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                        log.error(tree.pos(), Errors.ProjectionCantBeInstantiated);\n-                    }\n-                }\n-            }\n@@ -2877,2 +2825,1 @@\n-                                               clazztype.getMetadata(),\n-                                               clazztype.getFlavor());\n+                                               clazztype.getMetadata());\n@@ -3032,3 +2979,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        chk.checkParameterizationByPrimitiveClass(tree, clazztype);\n-                    }\n@@ -3107,3 +3051,0 @@\n-        \/\/ Likewise arg can't be null if it is a primitive class instance.\n-        if (allowPrimitiveClasses && arg.type.isPrimitiveClass())\n-            return arg;\n@@ -3599,2 +3540,1 @@\n-                    Name constructorName = owner.isConcreteValueClass() ? names.vnew : names.init;\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(constructorName)) {\n+                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n@@ -3663,1 +3603,0 @@\n-            Symbol lhsSym = TreeInfo.symbol(that.expr);\n@@ -3665,4 +3604,0 @@\n-                \/\/ TODO - a bit hacky but...\n-                if (lhsSym != null && lhsSym.isConcreteValueClass() && that.name == names.init) {\n-                    that.name = names.vnew;\n-                }\n@@ -3674,0 +3609,1 @@\n+                Symbol lhsSym = TreeInfo.symbol(that.expr);\n@@ -3757,1 +3693,1 @@\n-            that.sym = refSym.isInitOrVNew() ? refSym.baseSymbol() : refSym;\n+            that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;\n@@ -4401,10 +4337,0 @@\n-        \/\/ In a constructor body,\n-        \/\/ if symbol is a field or instance method, check that it is\n-        \/\/ not accessed before the supertype constructor is called.\n-        if (symEnv.info.isSelfCall &&\n-            sym.kind.matches(KindSelector.VAL_MTH) &&\n-            sym.owner.kind == TYP &&\n-            (sym.flags() & STATIC) == 0) {\n-            chk.earlyRefError(tree.pos(), sym.kind == VAR ?\n-                                          sym : thisSym(tree.pos(), env));\n-        }\n@@ -4447,9 +4373,0 @@\n-        if (allowPrimitiveClasses && tree.name == names._class && site.isPrimitiveClass()) {\n-            \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n-             * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n-             * always matching the behavior of Object::getClass\n-             *\/\n-             if (!tree.selected.hasTag(SELECT) || ((JCFieldAccess) tree.selected).name != names.val) {\n-                 tree.selected.setType(site = site.referenceProjection());\n-             }\n-        }\n@@ -4468,1 +4385,1 @@\n-                return;\n+                return ;\n@@ -4532,12 +4449,1 @@\n-            if (sym.name == names._this || sym.name == names._super) {\n-                \/\/ If `C' is the currently compiled class, check that\n-                \/\/ `C.this' does not appear in an explicit call to a constructor\n-                \/\/ also make sure that `super` is not used in constructor invocations\n-                if (env.info.isSelfCall &&\n-                        ((sym.name == names._this &&\n-                        site.tsym == env.enclClass.sym) ||\n-                        sym.name == names._super && env.info.constructorArgs &&\n-                        (sitesym.isInterface() || site.tsym == env.enclClass.sym))) {\n-                    chk.earlyRefError(tree.pos(), sym);\n-                }\n-            } else {\n+            if (sym.name != names._this && sym.name != names._super) {\n@@ -4572,1 +4478,1 @@\n-                Type site1 = types.asSuper(env.enclClass.sym.type.referenceProjectionOrSelf(), site.tsym);\n+                Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);\n@@ -4615,2 +4521,0 @@\n-                } else if (allowPrimitiveClasses && site.isPrimitiveClass() && isType(location) && resultInfo.pkind.contains(KindSelector.TYP) && (name == names.ref || name == names.val)) {\n-                    return site.tsym;\n@@ -4720,1 +4624,1 @@\n-                \/\/ except for three situations:\n+                \/\/ except for two situations:\n@@ -4723,3 +4627,0 @@\n-                    if (allowPrimitiveClasses) {\n-                        Assert.check(owntype.getFlavor() != Flavor.X_Typeof_X);\n-                    }\n@@ -4729,8 +4630,1 @@\n-                    \/\/ (a) If symbol is a primitive class and its reference projection\n-                    \/\/ is requested via the .ref notation, then adjust the computed type to\n-                    \/\/ reflect this.\n-                    if (allowPrimitiveClasses && owntype.isPrimitiveClass() && tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref) {\n-                        owntype = new ClassType(owntype.getEnclosingType(), owntype.getTypeArguments(), (TypeSymbol)sym, owntype.getMetadata(), Flavor.L_TypeOf_Q);\n-                    }\n-\n-                    \/\/ (b) If the symbol's type is parameterized, erase it\n+                    \/\/ (a) If the symbol's type is parameterized, erase it\n@@ -4743,1 +4637,1 @@\n-                    \/\/ (c) If the symbol's type is an inner class, then\n+                    \/\/ (b) If the symbol's type is an inner class, then\n@@ -4763,1 +4657,1 @@\n-                                owntype.getMetadata(), owntype.getFlavor());\n+                                owntype.getMetadata());\n@@ -4827,1 +4721,1 @@\n-            if (!names.isInitOrVNew(sym.name) || tree.hasTag(REFERENCE)) {\n+            if (sym.name != names.init || tree.hasTag(REFERENCE)) {\n@@ -5081,31 +4975,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        if (!allowPrimitiveClasses) {\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                    Feature.PRIMITIVE_CLASSES.error(sourceName));\n-        }\n-\n-        \/\/ Attribute the qualifier expression, and determine its symbol (if any).\n-        Type site = attribTree(tree.clazz, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n-        if (!pkind().contains(KindSelector.TYP_PCK))\n-            site = capture(site); \/\/ Capture field access\n-        if (!allowPrimitiveClasses) {\n-            result = types.createErrorType(names._default, site.tsym, site);\n-        } else {\n-            Symbol sym = switch (site.getTag()) {\n-                case WILDCARD -> throw new AssertionError(tree);\n-                case PACKAGE -> {\n-                    log.error(tree.pos, Errors.CantResolveLocation(Kinds.KindName.CLASS, site.tsym.getQualifiedName(), null, null,\n-                            Fragments.Location(Kinds.typeKindName(env.enclClass.type), env.enclClass.type, null)));\n-                    yield syms.errSymbol;\n-                }\n-                case ERROR -> types.createErrorType(names._default, site.tsym, site).tsym;\n-                default -> new VarSymbol(STATIC, names._default, site, site.tsym);\n-            };\n-\n-            if (site.hasTag(TYPEVAR) && sym.kind != ERR) {\n-                site = types.skipTypeVars(site, true);\n-            }\n-            result = checkId(tree, site, sym, env, resultInfo);\n-        }\n-    }\n-\n@@ -5140,1 +5003,0 @@\n-\n@@ -5199,1 +5061,1 @@\n-                                        clazztype.getMetadata(), clazztype.getFlavor());\n+                                        clazztype.getMetadata());\n@@ -5326,1 +5188,1 @@\n-                make.Modifiers(PUBLIC | ABSTRACT | (extending != null && TreeInfo.symbol(extending).isPrimitiveClass() ? PRIMITIVE_CLASS : 0)),\n+                make.Modifiers(PUBLIC | ABSTRACT),\n@@ -5349,1 +5211,1 @@\n-        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),\n+        result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),\n@@ -5467,5 +5329,0 @@\n-            if (allowPrimitiveClasses && c.type.isPrimitiveClass()) {\n-                final Env<AttrContext> env = typeEnvs.get(c);\n-                if (env != null && env.tree != null && env.tree.hasTag(CLASSDEF))\n-                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n-            }\n@@ -5649,1 +5506,1 @@\n-                    chk.checkConstraintsOfValueClass(env.tree.pos(), c);\n+                    chk.checkConstraintsOfValueClass((JCClassDecl) env.tree, c);\n@@ -5780,0 +5637,3 @@\n+        \/\/ Check for proper placement of super()\/this() calls.\n+        chk.checkSuperInitCalls(tree);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":62,"deletions":202,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    \/** Is this an environment for a this(...) or super(...) call?\n+    \/** Are we in the 'prologue' part of a constructor, prior to an explicit this()\/super()?\n@@ -54,5 +54,1 @@\n-    boolean isSelfCall = false;\n-\n-    \/** are we analyzing the arguments for a constructor invocation?\n-     *\/\n-    boolean constructorArgs = false;\n+    boolean ctorPrologue = false;\n@@ -139,2 +135,1 @@\n-        info.isSelfCall = isSelfCall;\n-        info.constructorArgs = constructorArgs;\n+        info.ctorPrologue = ctorPrologue;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrContext.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n+        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -231,1 +231,1 @@\n-    \/** Are primitive classes allowed\n+    \/** Are value classes allowed\n@@ -233,1 +233,1 @@\n-    private final boolean allowPrimitiveClasses;\n+    private final boolean allowValueClasses;\n@@ -367,9 +367,0 @@\n-    \/** Report an error that symbol cannot be referenced before super\n-     *  has been called.\n-     *  @param pos        Position to be used for error reporting.\n-     *  @param sym        The referenced symbol.\n-     *\/\n-    void earlyRefError(DiagnosticPosition pos, Symbol sym) {\n-        log.error(pos, Errors.CantRefBeforeCtorCalled(sym));\n-    }\n-\n@@ -646,5 +637,0 @@\n-        } else {\n-            if (allowPrimitiveClasses && found.hasTag(CLASS)) {\n-                if (inferenceContext != infer.emptyContext)\n-                    checkParameterizationByPrimitiveClass(pos, found);\n-            }\n@@ -781,1 +767,2 @@\n-    void checkConstraintsOfValueClass(DiagnosticPosition pos, ClassSymbol c) {\n+    void checkConstraintsOfValueClass(JCClassDecl tree, ClassSymbol c) {\n+        DiagnosticPosition pos = tree.pos();\n@@ -794,8 +781,0 @@\n-            Fragment fragment = c.isAbstract() && c.isValueClass() && c == st.tsym ? Fragments.AbstractValueClass(c) : Fragments.SuperclassOfValueClass(c, st);\n-            if ((st.tsym.flags() & HASINITBLOCK) != 0) {\n-                log.error(pos, Errors.AbstractValueClassDeclaresInitBlock(fragment));\n-            }\n-            Type encl = st.getEnclosingType();\n-            if (encl != null && encl.hasTag(CLASS)) {\n-                log.error(pos, Errors.AbstractValueClassCannotBeInner(fragment));\n-            }\n@@ -803,7 +782,1 @@\n-                switch (s.kind) {\n-                case VAR:\n-                    if ((s.flags() & STATIC) == 0) {\n-                        log.error(pos, Errors.InstanceFieldNotAllowed(s, fragment));\n-                    }\n-                    break;\n-                case MTH:\n+                if (s.kind == MTH) {\n@@ -812,13 +785,0 @@\n-                    } else if (s.isInitOrVNew()) {\n-                        MethodSymbol m = (MethodSymbol)s;\n-                        if (m.getParameters().size() > 0) {\n-                            log.error(pos, Errors.AbstractValueClassConstructorCannotTakeArguments(m, fragment));\n-                        } else if (m.getTypeParameters().size() > 0) {\n-                            log.error(pos, Errors.AbstractValueClassConstructorCannotBeGeneric(m, fragment));\n-                        } else if (m.type.getThrownTypes().size() > 0) {\n-                            log.error(pos, Errors.AbstractValueClassConstructorCannotThrow(m, fragment));\n-                        } else if (protection(m.flags()) > protection(m.owner.flags())) {\n-                            log.error(pos, Errors.AbstractValueClassConstructorHasWeakerAccess(m, fragment));\n-                        } else if ((m.flags() & EMPTYNOARGCONSTR) == 0) {\n-                                log.error(pos, Errors.AbstractValueClassNoArgConstructorMustBeEmpty(m, fragment));\n-                        }\n@@ -834,2 +794,2 @@\n-    Type checkConstructorRefType(JCExpression expr, Type t) {\n-        t = checkClassOrArrayType(expr, t);\n+    Type checkConstructorRefType(DiagnosticPosition pos, Type t) {\n+        t = checkClassOrArrayType(pos, t);\n@@ -838,1 +798,1 @@\n-                log.error(expr, Errors.AbstractCantBeInstantiated(t.tsym));\n+                log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));\n@@ -841,1 +801,1 @@\n-                log.error(expr, Errors.EnumCantBeInstantiated);\n+                log.error(pos, Errors.EnumCantBeInstantiated);\n@@ -844,10 +804,1 @@\n-                \/\/ Projection types may not be mentioned in constructor references\n-                if (expr.hasTag(SELECT)) {\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) expr;\n-                    if (allowPrimitiveClasses && fieldAccess.selected.type.isPrimitiveClass() &&\n-                            (fieldAccess.name == names.ref || fieldAccess.name == names.val)) {\n-                        log.error(expr, Errors.ProjectionCantBeInstantiated);\n-                        t = types.createErrorType(t);\n-                    }\n-                }\n-                t = checkClassType(expr, t, true);\n+                t = checkClassType(pos, t, true);\n@@ -857,1 +808,1 @@\n-                log.error(expr, Errors.GenericArrayCreation);\n+                log.error(pos, Errors.GenericArrayCreation);\n@@ -888,1 +839,0 @@\n-     *  @param primitiveClassOK       If false, a primitive class does not qualify\n@@ -890,2 +840,2 @@\n-    Type checkRefType(DiagnosticPosition pos, Type t, boolean primitiveClassOK) {\n-        if (t.isReference() && (!allowPrimitiveClasses || primitiveClassOK || !t.isPrimitiveClass()))\n+    Type checkRefType(DiagnosticPosition pos, Type t) {\n+        if (t.isReference())\n@@ -899,3 +849,3 @@\n-    \/** Check that type is an identity type, i.e. not a primitive\/value type\n-     *  nor its reference projection. When not discernible statically,\n-     *  give it the benefit of doubt and defer to runtime.\n+    \/** Check that type is an identity type, i.e. not a value type.\n+     *  When not discernible statically, give it the benefit of doubt\n+     *  and defer to runtime.\n@@ -917,1 +867,1 @@\n-        if (t.isPrimitive() || t.isValueClass() || t.isValueInterface() || t.isReferenceProjection())\n+        if (t.isPrimitive() || t.isValueClass())\n@@ -921,9 +871,0 @@\n-    \/** Check that type is a reference type, i.e. a class, interface or array type\n-     *  or a type variable.\n-     *  @param pos           Position to be used for error reporting.\n-     *  @param t             The type to be checked.\n-     *\/\n-    Type checkRefType(DiagnosticPosition pos, Type t) {\n-        return checkRefType(pos, t, true);\n-    }\n-\n@@ -938,1 +879,1 @@\n-            l.head = checkRefType(tl.head.pos(), l.head, false);\n+            l.head = checkRefType(tl.head.pos(), l.head);\n@@ -974,49 +915,0 @@\n-    void checkParameterizationByPrimitiveClass(DiagnosticPosition pos, Type t) {\n-        parameterizationByPrimitiveClassChecker.visit(t, pos);\n-    }\n-\n-    \/** parameterizationByPrimitiveClassChecker: A type visitor that descends down the given type looking for instances of primitive classes\n-     *  being used as type arguments and issues error against those usages.\n-     *\/\n-    private final Types.SimpleVisitor<Void, DiagnosticPosition> parameterizationByPrimitiveClassChecker =\n-            new Types.SimpleVisitor<Void, DiagnosticPosition>() {\n-\n-        @Override\n-        public Void visitType(Type t, DiagnosticPosition pos) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitClassType(ClassType t, DiagnosticPosition pos) {\n-            for (Type targ : t.allparams()) {\n-                if (allowPrimitiveClasses && targ.isPrimitiveClass()) {\n-                    log.error(pos, Errors.GenericParameterizationWithPrimitiveClass(t));\n-                }\n-                visit(targ, pos);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {\n-             return null;\n-        }\n-\n-        @Override\n-        public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {\n-            return visit(t.elemtype, pos);\n-        }\n-\n-        @Override\n-        public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {\n-            return visit(t.type, pos);\n-        }\n-    };\n-\n-\n-\n@@ -1155,1 +1047,1 @@\n-                (s.isInitOrVNew() ||\n+                (s.isConstructor() ||\n@@ -1171,5 +1063,1 @@\n-        Type varType = types.upward(t, types.captures(t)).baseType();\n-        if (allowPrimitiveClasses && varType.hasTag(CLASS)) {\n-            checkParameterizationByPrimitiveClass(pos, varType);\n-        }\n-        return varType;\n+        return types.upward(t, types.captures(t)).baseType();\n@@ -1198,1 +1086,0 @@\n-        \/\/ TODO - is enum so <init>\n@@ -1382,1 +1269,1 @@\n-            if (names.isInitOrVNew(sym.name)) {\n+            if (sym.name == names.init) {\n@@ -1446,0 +1333,4 @@\n+            if ((flags & (INTERFACE | VALUE_CLASS)) == 0) {\n+                implicit |= IDENTITY_TYPE;\n+            }\n+\n@@ -1447,2 +1338,2 @@\n-                \/\/ enums can't be declared abstract, final, sealed or non-sealed or primitive\/value\n-                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | PRIMITIVE_CLASS | VALUE_CLASS);\n+                \/\/ enums can't be declared abstract, final, sealed or non-sealed or value\n+                mask &= ~(ABSTRACT | FINAL | SEALED | NON_SEALED | VALUE_CLASS);\n@@ -1462,4 +1353,0 @@\n-            \/\/ primitive classes are implicitly final value classes.\n-            if ((flags & PRIMITIVE_CLASS) != 0)\n-                implicit |= VALUE_CLASS | FINAL;\n-\n@@ -1506,1 +1393,1 @@\n-                               FINAL | NATIVE | SYNCHRONIZED | PRIMITIVE_CLASS)\n+                               FINAL | NATIVE | SYNCHRONIZED)\n@@ -1510,1 +1397,5 @@\n-                        PRIMITIVE_CLASS | VALUE_CLASS)\n+                        VALUE_CLASS)\n+                 &&\n+                 checkDisjoint(pos, flags,\n+                        INTERFACE,\n+                        VALUE_CLASS)\n@@ -1715,2 +1606,1 @@\n-                tree.selected.type.isParameterized() &&\n-                    (tree.name != names.ref || !tree.type.isReferenceProjection())) {\n+                tree.selected.type.isParameterized()) {\n@@ -1720,2 +1610,0 @@\n-                \/\/ Tolerate the pseudo-select V.ref: V<T>.ref will be static if V<T> is and\n-                \/\/ should not be confused as selecting a static member of a parameterized type.\n@@ -1785,1 +1673,1 @@\n-                    env.enclMethod != null && names.isInitOrVNew(env.enclMethod.name);\n+                    env.enclMethod != null && env.enclMethod.name == names.init;\n@@ -2386,1 +2274,1 @@\n-                (env.info.isAnonymousDiamond && !m.isInitOrVNew() && !m.isPrivate());\n+                (env.info.isAnonymousDiamond && !m.isConstructor() && !m.isPrivate());\n@@ -2542,39 +2430,0 @@\n-    \/\/ A primitive class cannot contain a field of its own type either or indirectly.\n-    void checkNonCyclicMembership(JCClassDecl tree) {\n-        if (allowPrimitiveClasses) {\n-            Assert.check((tree.sym.flags_field & LOCKED) == 0);\n-            try {\n-                tree.sym.flags_field |= LOCKED;\n-                for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (l.head.hasTag(VARDEF)) {\n-                        JCVariableDecl field = (JCVariableDecl) l.head;\n-                        if (cyclePossible(field.sym)) {\n-                            checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n-                        }\n-                    }\n-                }\n-            } finally {\n-                tree.sym.flags_field &= ~LOCKED;\n-            }\n-        }\n-    }\n-    \/\/ where\n-    private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {\n-        if ((c.flags_field & LOCKED) != 0) {\n-            log.error(pos, Errors.CyclicPrimitiveClassMembership(c));\n-            return;\n-        }\n-        try {\n-            c.flags_field |= LOCKED;\n-            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n-                checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);\n-            }\n-        } finally {\n-            c.flags_field &= ~LOCKED;\n-        }\n-    }\n-        \/\/ where\n-        private boolean cyclePossible(VarSymbol symbol) {\n-            return (symbol.flags() & STATIC) == 0 && allowPrimitiveClasses && symbol.type.isPrimitiveClass();\n-        }\n-\n@@ -2831,1 +2680,0 @@\n-        boolean cHasIdentity = (c.tsym.flags() & IDENTITY_TYPE) != 0;\n@@ -2839,1 +2687,1 @@\n-                if (cIsValue &&  identitySuper != null) {\n+                if (cIsValue && identitySuper != null && identitySuper.tsym != syms.objectType.tsym) { \/\/ Object is special\n@@ -2842,6 +2690,0 @@\n-                } else if (cHasIdentity &&  valueSuper != null) {\n-                    log.error(pos, Errors.IdentityTypeHasValueSuperType(c, valueSuper));\n-                    break;\n-                } else if (identitySuper != null && valueSuper != null) {\n-                    log.error(pos, Errors.MutuallyIncompatibleSupers(c, identitySuper, valueSuper));\n-                    break;\n@@ -2946,1 +2788,1 @@\n-                     !s.isInitOrVNew();\n+                     !s.isConstructor();\n@@ -3005,1 +2847,1 @@\n-                     !s.isInitOrVNew();\n+                     !s.isConstructor();\n@@ -3888,1 +3730,1 @@\n-                if (s.kind == MTH && !s.isInitOrVNew())\n+                if (s.kind == MTH && !s.isConstructor())\n@@ -3896,1 +3738,1 @@\n-                if (s.kind == MTH && s.isInitOrVNew())\n+                if (s.kind == MTH && s.isConstructor())\n@@ -3915,1 +3757,1 @@\n-                        (s.kind == MTH && !s.isInitOrVNew() &&\n+                        (s.kind == MTH && !s.isConstructor() &&\n@@ -3917,1 +3759,1 @@\n-                        (s.kind == MTH && s.isInitOrVNew())) {\n+                        (s.kind == MTH && s.isConstructor())) {\n@@ -4191,4 +4033,5 @@\n-            JCMethodInvocation app = TreeInfo.firstConstructorCall(l.head);\n-            if (app == null) continue;\n-            JCMethodDecl meth = (JCMethodDecl) l.head;\n-            if (TreeInfo.name(app.meth) == names._this) {\n+            if (!TreeInfo.isConstructor(l.head))\n+                continue;\n+            JCMethodDecl meth = (JCMethodDecl)l.head;\n+            JCMethodInvocation app = TreeInfo.findConstructorCall(meth);\n+            if (app != null && TreeInfo.name(app.meth) == names._this) {\n@@ -4227,0 +4070,122 @@\n+\/* *************************************************************************\n+ * Verify the proper placement of super()\/this() calls.\n+ *\n+ *    - super()\/this() may only appear in constructors\n+ *    - There must be at most one super()\/this() call per constructor\n+ *    - The super()\/this() call, if any, must be a top-level statement in the\n+ *      constructor, i.e., not nested inside any other statement or block\n+ *    - There must be no return statements prior to the super()\/this() call\n+ **************************************************************************\/\n+\n+    void checkSuperInitCalls(JCClassDecl tree) {\n+        new SuperThisChecker().check(tree);\n+    }\n+\n+    private class SuperThisChecker extends TreeScanner {\n+\n+        \/\/ Match this scan stack: 1=JCMethodDecl, 2=JCExpressionStatement, 3=JCMethodInvocation\n+        private static final int MATCH_SCAN_DEPTH = 3;\n+\n+        private boolean constructor;        \/\/ is this method a constructor?\n+        private boolean firstStatement;     \/\/ at the first statement in method?\n+        private JCReturn earlyReturn;       \/\/ first return prior to the super()\/init(), if any\n+        private Name initCall;              \/\/ whichever of \"super\" or \"init\" we've seen already\n+        private int scanDepth;              \/\/ current scan recursion depth in method body\n+\n+        public void check(JCClassDecl classDef) {\n+            scan(classDef.defs);\n+        }\n+\n+        @Override\n+        public void visitMethodDef(JCMethodDecl tree) {\n+            Assert.check(!constructor);\n+            Assert.check(earlyReturn == null);\n+            Assert.check(initCall == null);\n+            Assert.check(scanDepth == 1);\n+\n+            \/\/ Initialize state for this method\n+            constructor = TreeInfo.isConstructor(tree);\n+            try {\n+\n+                \/\/ Scan method body\n+                if (tree.body != null) {\n+                    firstStatement = true;\n+                    for (List<JCStatement> l = tree.body.stats; l.nonEmpty(); l = l.tail) {\n+                        scan(l.head);\n+                        firstStatement = false;\n+                    }\n+                }\n+\n+                \/\/ Verify no 'return' seen prior to an explicit super()\/this() call\n+                if (constructor && earlyReturn != null && initCall != null)\n+                    log.error(earlyReturn.pos(), Errors.ReturnBeforeSuperclassInitialized);\n+            } finally {\n+                firstStatement = false;\n+                constructor = false;\n+                earlyReturn = null;\n+                initCall = null;\n+            }\n+        }\n+\n+        @Override\n+        public void scan(JCTree tree) {\n+            scanDepth++;\n+            try {\n+                super.scan(tree);\n+            } finally {\n+                scanDepth--;\n+            }\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation apply) {\n+            do {\n+\n+                \/\/ Is this a super() or this() call?\n+                Name methodName = TreeInfo.name(apply.meth);\n+                if (methodName != names._super && methodName != names._this)\n+                    break;\n+\n+                \/\/ super()\/this() calls must only appear in a constructor\n+                if (!constructor) {\n+                    log.error(apply.pos(), Errors.CallMustOnlyAppearInCtor);\n+                    break;\n+                }\n+\n+                \/\/ super()\/this() calls must be a top level statement\n+                if (scanDepth != MATCH_SCAN_DEPTH) {\n+                    log.error(apply.pos(), Errors.CtorCallsNotAllowedHere);\n+                    break;\n+                }\n+\n+                \/\/ super()\/this() calls must not appear more than once\n+                if (initCall != null) {\n+                    log.error(apply.pos(), Errors.RedundantSuperclassInit);\n+                    break;\n+                }\n+\n+                \/\/ If super()\/this() isn't first, require \"statements before super()\" feature\n+                if (!firstStatement)\n+                    preview.checkSourceLevel(apply.pos(), Feature.SUPER_INIT);\n+\n+                \/\/ We found a legitimate super()\/this() call; remember it\n+                initCall = methodName;\n+            } while (false);\n+\n+            \/\/ Proceed\n+            super.visitApply(apply);\n+        }\n+\n+        @Override\n+        public void visitReturn(JCReturn tree) {\n+            if (constructor && initCall == null && earlyReturn == null)\n+                earlyReturn = tree;             \/\/ we have seen a return but not (yet) a super()\/this()\n+            super.visitReturn(tree);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+    }\n+\n@@ -5258,1 +5223,1 @@\n-                    if (sym.isInitOrVNew() &&\n+                    if (sym.isConstructor() &&\n@@ -5286,1 +5251,1 @@\n-                        if (sym.isInitOrVNew()) {\n+                        if (sym.isConstructor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":173,"deletions":208,"binary":false,"changes":381,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -108,1 +107,0 @@\n-    boolean allowPrimitiveClasses;\n@@ -149,2 +147,0 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -208,1 +204,0 @@\n-        localEnv.info.isSelfCall = false;\n@@ -261,1 +256,0 @@\n-        localEnv.info.isSelfCall = false;\n@@ -512,4 +506,0 @@\n-        if (allowPrimitiveClasses) {\n-            ct.flavor = ct.flavor.metamorphose((c.flags_field & PRIMITIVE_CLASS) != 0);\n-        }\n-\n@@ -534,6 +524,0 @@\n-        if (allowPrimitiveClasses && ct.isPrimitiveClass()) {\n-            if (ct.projection != null) {\n-                ct.projection.typarams_field = ct.typarams_field;\n-                ct.projection.allparams_field = ct.allparams_field;\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.Consumer;\n@@ -391,0 +392,7 @@\n+        \/** A class whose initializers we are scanning. Because initializer\n+         *  scans can be triggered out of sequence when visiting certain nodes\n+         *  (e.g., super()), we protect against infinite loops that could be\n+         *  triggered by incorrect code (e.g., super() inside initializer).\n+         *\/\n+        JCClassDecl initScanClass;\n+\n@@ -476,0 +484,18 @@\n+\n+        \/\/ Do something with all static or non-static field initializers and initialization blocks.\n+        \/\/ Note: This method also sends nested class definitions to the handler.\n+        protected void forEachInitializer(JCClassDecl classDef, boolean isStatic, Consumer<? super JCTree> handler) {\n+            if (classDef == initScanClass)          \/\/ avoid infinite loops\n+                return;\n+            JCClassDecl initScanClassPrev = initScanClass;\n+            initScanClass = classDef;\n+            try {\n+                for (List<JCTree> defs = classDef.defs; defs.nonEmpty(); defs = defs.tail) {\n+                    JCTree def = defs.head;\n+                    if (!def.hasTag(METHODDEF) && ((TreeInfo.flags(def) & STATIC) != 0) == isStatic)\n+                        handler.accept(def);\n+                }\n+            } finally {\n+                initScanClass = initScanClassPrev;\n+            }\n+        }\n@@ -541,7 +567,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                        scanDef(l.head);\n-                        clearPendingExits(false);\n-                    }\n-                }\n+                forEachInitializer(tree, true, def -> {\n+                    scanDef(def);\n+                    clearPendingExits(false);\n+                });\n@@ -550,7 +573,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                        scanDef(l.head);\n-                        clearPendingExits(false);\n-                    }\n-                }\n+                forEachInitializer(tree, false, def -> {\n+                    scanDef(def);\n+                    clearPendingExits(false);\n+                });\n@@ -1367,34 +1387,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                        scan(l.head);\n-                        errorUncaught();\n-                    }\n-                }\n-\n-                \/\/ add intersection of all throws clauses of initial constructors\n-                \/\/ to set of caught exceptions, unless class is anonymous.\n-                if (!anonymousClass) {\n-                    boolean firstConstructor = true;\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (TreeInfo.isInitialConstructor(l.head)) {\n-                            List<Type> mthrown =\n-                                ((JCMethodDecl) l.head).sym.type.getThrownTypes();\n-                            if (firstConstructor) {\n-                                caught = mthrown;\n-                                firstConstructor = false;\n-                            } else {\n-                                caught = chk.intersect(mthrown, caught);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                \/\/ process all the instance initializers\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                        scan(l.head);\n-                        errorUncaught();\n-                    }\n-                }\n+                forEachInitializer(tree, true, def -> {\n+                    scan(def);\n+                    errorUncaught();\n+                });\n@@ -1455,1 +1445,1 @@\n-                if (TreeInfo.isInitialConstructor(tree))\n+                if (TreeInfo.hasConstructorCall(tree, names._super))\n@@ -1601,1 +1591,1 @@\n-                    if (types.asSuper(sup.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) != null) {\n+                    if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {\n@@ -1771,0 +1761,2 @@\n+\n+            \/\/ Mark as thrown the exceptions thrown by the method being invoked\n@@ -1773,0 +1765,8 @@\n+\n+            \/\/ After super(), scan initializers to uncover any exceptions they throw\n+            if (TreeInfo.name(tree.meth) == names._super) {\n+                forEachInitializer(classDef, false, def -> {\n+                    scan(def);\n+                    errorUncaught();\n+                });\n+            }\n@@ -2126,1 +2126,1 @@\n-        private boolean isInitialConstructor = false;\n+        private boolean isConstructor;\n@@ -2130,1 +2130,1 @@\n-            if (!isInitialConstructor) {\n+            if (!isConstructor) {\n@@ -2399,7 +2399,4 @@\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (!l.head.hasTag(METHODDEF) &&\n-                            (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                            scan(l.head);\n-                            clearPendingExits(false);\n-                        }\n-                    }\n+                    forEachInitializer(tree, true, def -> {\n+                        scan(def);\n+                        clearPendingExits(false);\n+                    });\n@@ -2429,9 +2426,0 @@\n-                    \/\/ process all the instance initializers\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (!l.head.hasTag(METHODDEF) &&\n-                            (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                            scan(l.head);\n-                            clearPendingExits(false);\n-                        }\n-                    }\n-\n@@ -2477,1 +2465,1 @@\n-                boolean lastInitialConstructor = isInitialConstructor;\n+                boolean isConstructorPrev = isConstructor;\n@@ -2479,1 +2467,1 @@\n-                    isInitialConstructor = TreeInfo.isInitialConstructor(tree);\n+                    isConstructor = TreeInfo.isConstructor(tree);\n@@ -2481,1 +2469,2 @@\n-                    if (!isInitialConstructor) {\n+                    \/\/ We only track field initialization inside constructors\n+                    if (!isConstructor) {\n@@ -2490,0 +2479,2 @@\n+\n+                    \/\/ Mark all method parameters as DA\n@@ -2505,1 +2496,1 @@\n-                    if (isInitialConstructor) {\n+                    if (isConstructor) {\n@@ -2547,1 +2538,1 @@\n-                    isInitialConstructor = lastInitialConstructor;\n+                    isConstructor = isConstructorPrev;\n@@ -2564,1 +2555,1 @@\n-                if (inMethod && isInitialConstructor) {\n+                if (inMethod && isConstructor) {\n@@ -3020,0 +3011,23 @@\n+\n+            \/\/ Handle superclass constructor invocations\n+            if (isConstructor) {\n+\n+                \/\/ If super(): at this point all initialization blocks will execute\n+                Name name = TreeInfo.name(tree.meth);\n+                if (name == names._super) {\n+                    forEachInitializer(classDef, false, def -> {\n+                        scan(def);\n+                        clearPendingExits(false);\n+                    });\n+                }\n+\n+                \/\/ If this(): at this point all final uninitialized fields will get initialized\n+                else if (name == names._this) {\n+                    for (int address = firstadr; address < nextadr; address++) {\n+                        VarSymbol sym = vardecls[address].sym;\n+                        if (isFinalUninitializedField(sym) && !sym.isStatic())\n+                            letInit(tree.pos(), sym);\n+                    }\n+                }\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":88,"deletions":74,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -344,1 +344,1 @@\n-                Name name = msym.name.table.names.isInitOrVNew(msym.name) ?\n+                Name name = msym.name == msym.name.table.names.init ?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -356,2 +356,1 @@\n-            \/\/ TODO - can <vnew> exist in this context?\n-            if ((init = names.isInitOrVNew(owner.name)) || owner.name == names.clinit) {\n+            if ((init = (owner.name == names.init)) || owner.name == names.clinit) {\n@@ -376,1 +375,1 @@\n-                make.QualIdent(lambdaType.getReturnType().tsym).setType(lambdaType.getReturnType()),\n+                make.QualIdent(lambdaType.getReturnType().tsym),\n@@ -1672,2 +1671,1 @@\n-                Name constructorName = csym.isConcreteValueClass() ? names.vnew : names.init;\n-                for (Symbol s : csym.members_field.getSymbolsByName(constructorName)) {\n+                for (Symbol s : csym.members_field.getSymbolsByName(names.init)) {\n@@ -1777,1 +1775,1 @@\n-                    && !names.isInitOrVNew(sym.name);\n+                    && sym.name != names.init;\n@@ -1875,1 +1873,1 @@\n-                return types.asSuper(tree.target.referenceProjectionOrSelf(), syms.serializableType.tsym) != null;\n+                return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n@@ -1899,2 +1897,0 @@\n-                } else if (methodName.equals(\"<vnew>\")) {\n-                    methodName = \"vnew\";\n@@ -2355,1 +2351,1 @@\n-                          (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner() || tree.sym.owner.isValueClass()));\n+                          (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-    private final boolean allowPrimitiveClasses;\n@@ -134,1 +133,0 @@\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -1148,1 +1146,1 @@\n-        } else if (names.isInitOrVNew(sym.name) && sym.owner.isDirectlyOrIndirectlyLocal()) {\n+        } else if (sym.name == names.init && sym.owner.isDirectlyOrIndirectlyLocal()) {\n@@ -1237,3 +1235,0 @@\n-                \/\/ Make sure not to lose type fidelity due to symbol sharing between projections\n-                boolean requireReferenceProjection = allowPrimitiveClasses &&\n-                        tree.hasTag(SELECT) && ((JCFieldAccess) tree).name == names.ref && tree.type.isReferenceProjection();\n@@ -1255,3 +1250,0 @@\n-                    if (requireReferenceProjection) {\n-                        tree.setType(tree.type.referenceProjection());\n-                    }\n@@ -1261,3 +1253,0 @@\n-                    if (requireReferenceProjection) {\n-                        tree.setType(tree.type.referenceProjection());\n-                    }\n@@ -1361,1 +1350,0 @@\n-                Name constructorName = accOwner.isConcreteValueClass() ? names.vnew : names.init;\n@@ -1364,1 +1352,1 @@\n-                    constructorName,\n+                    names.init,\n@@ -1408,1 +1396,1 @@\n-        if (names.isInitOrVNew(sym.name)) {\n+        if (sym.name == names.init) {\n@@ -1621,1 +1609,1 @@\n-            (owner.isInitOrVNew() && owner.isAnonymous()) ||\n+            (owner.isConstructor() && owner.isAnonymous()) ||\n@@ -1623,1 +1611,1 @@\n-            (owner.isInitOrVNew() && c.isInner() &&\n+            (owner.isConstructor() && c.isInner() &&\n@@ -1820,1 +1808,1 @@\n-        if (types.asSuper(resource.type.referenceProjectionOrSelf(), syms.autoCloseableType.tsym) == null) {\n+        if (types.asSuper(resource.type, syms.autoCloseableType.tsym) == null) {\n@@ -1862,1 +1850,1 @@\n-                chk.earlyRefError(pos, c);\n+                log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));\n@@ -1902,1 +1890,0 @@\n-            Assert.error();\n@@ -1914,1 +1901,0 @@\n-                    Assert.error();\n@@ -2204,2 +2190,1 @@\n-        return (tree == null) ? null :\n-                applyPrimitiveConversionsAsNeeded(boxIfNeeded(translate(tree), type), type);\n+        return (tree == null) ? null : boxIfNeeded(translate(tree), type);\n@@ -2344,1 +2329,1 @@\n-        tree.mods.flags &= AdjustedClassFlags;\n+        tree.mods.flags &= ClassFlags;\n@@ -2355,2 +2340,2 @@\n-        \/\/ If this$n was accessed, add the field definition and\n-        \/\/ update initial constructors to initialize it\n+        \/\/ If this$n was accessed, add the field definition and prepend\n+        \/\/ initializer code to any super() invocation to initialize it\n@@ -2361,5 +2346,7 @@\n-           for (JCTree def : tree.defs) {\n-                if (TreeInfo.isInitialConstructor(def)) {\n-                  JCMethodDecl mdef = (JCMethodDecl) def;\n-                  mdef.body.stats = mdef.body.stats.prepend(\n-                      initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+            for (JCTree def : tree.defs) {\n+                if (TreeInfo.isConstructor(def)) {\n+                    JCMethodDecl mdef = (JCMethodDecl)def;\n+                    if (TreeInfo.hasConstructorCall(mdef, names._super)) {\n+                        List<JCStatement> initializer = List.of(initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+                        TreeInfo.mapSuperCalls(mdef.body, supercall -> make.Block(0, initializer.append(supercall)));\n+                    }\n@@ -2754,1 +2741,0 @@\n-        \/\/ TODO - enum so is always <init>\n@@ -2796,1 +2782,1 @@\n-        if (names.isInitOrVNew(tree.name) &&\n+        if (tree.name == names.init &&\n@@ -2831,4 +2817,2 @@\n-            \/\/ If this is an initial constructor, i.e., it does not start with\n-            \/\/ this(...), insert initializers for this$n and proxies\n-            \/\/ before (pre-1.4, after) the call to superclass constructor.\n-            JCStatement selfCall = translate(tree.body.stats.head);\n+            \/\/ Determine whether this constructor has a super() invocation\n+            boolean invokesSuper = TreeInfo.hasConstructorCall(tree, names._super);\n@@ -2836,1 +2820,2 @@\n-            List<JCStatement> added = List.nil();\n+            \/\/ Create initializers for this$n and proxies\n+            ListBuffer<JCStatement> added = new ListBuffer<>();\n@@ -2843,1 +2828,1 @@\n-                    if (TreeInfo.isInitialConstructor(tree)) {\n+                    if (invokesSuper) {\n@@ -2857,0 +2842,9 @@\n+            \/\/ Recursively translate existing local statements\n+            tree.body.stats = translate(tree.body.stats);\n+\n+            \/\/ Prepend initializers in front of super() call\n+            if (added.nonEmpty()) {\n+                List<JCStatement> initializers = added.toList();\n+                TreeInfo.mapSuperCalls(tree.body, supercall -> make.Block(0, initializers.append(supercall)));\n+            }\n+\n@@ -2860,4 +2854,0 @@\n-            \/\/ recursively translate following local statements and\n-            \/\/ combine with this- or super-call\n-            List<JCStatement> stats = translate(tree.body.stats.tail);\n-            tree.body.stats = stats.prepend(selfCall).prependList(added);\n@@ -2877,1 +2867,1 @@\n-        if (names.isInitOrVNew(tree.name) && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+        if (tree.name == names.init && ((tree.sym.flags_field & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n@@ -3119,2 +3109,1 @@\n-        \/\/ TODO - is enum so always <init>.\n-        if (names.isInitOrVNew(meth.name) && meth.owner == syms.enumSym)\n+        if (meth.name == names.init && meth.owner == syms.enumSym)\n@@ -3125,1 +3114,1 @@\n-        if (names.isInitOrVNew(meth.name)) {\n+        if (meth.name==names.init) {\n@@ -3233,11 +3222,0 @@\n-    \/** Apply primitive value\/reference conversions as needed *\/\n-    @SuppressWarnings(\"unchecked\")\n-    <T extends JCExpression> T applyPrimitiveConversionsAsNeeded(T tree, Type type) {\n-        boolean haveValue = tree.type.isPrimitiveClass();\n-        if (haveValue == type.isPrimitiveClass())\n-            return tree;\n-        \/\/ For narrowing conversion, insert a cast which should trigger a null check\n-        \/\/ For widening conversions, insert a cast if emitting a unified class file.\n-        return (T) make.TypeCast(type, tree);\n-    }\n-\n@@ -3642,1 +3620,1 @@\n-            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type.referenceProjectionOrSelf()),\n+            Type iterableType = types.asSuper(types.cvarUpperBound(tree.expr.type),\n@@ -3652,1 +3630,1 @@\n-            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType().referenceProjectionOrSelf(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n+            Assert.check(types.isSameType(types.erasure(types.asSuper(iterator.type.getReturnType(), syms.iteratorType.tsym)), types.erasure(syms.iteratorType)));\n@@ -3731,17 +3709,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        Type fieldType = tree.field.type;\n-        tree.field = translate(tree.field, tree);\n-        tree.value = translate(tree.value, fieldType); \/\/ important to use pre-translation type.\n-\n-        \/\/ If translated field is an Apply, we are\n-        \/\/ seeing an access method invocation. In this case, append\n-        \/\/ right hand side as last argument of the access method.\n-        if (tree.field.hasTag(APPLY)) {\n-            JCMethodInvocation app = (JCMethodInvocation) tree.field;\n-            app.args = List.of(tree.value).prependList(app.args);\n-            result = app;\n-        } else {\n-            result = tree;\n-        }\n-    }\n-\n@@ -4244,5 +4205,0 @@\n-        \/* JDK-8269956: Where a reflective (class) literal is needed, the unqualified Point.class is\n-         * always the \"primary\" mirror - representing the primitive reference runtime type - thereby\n-         * always matching the behavior of Object::getClass\n-         *\/\n-        boolean needPrimaryMirror = tree.name == names._class && tree.selected.type.isReferenceProjection();\n@@ -4250,3 +4206,0 @@\n-        if (needPrimaryMirror && allowPrimitiveClasses && tree.selected.type.isPrimitiveClass()) {\n-            tree.selected.setType(tree.selected.type.referenceProjection());\n-        }\n@@ -4260,1 +4213,1 @@\n-            Assert.checkNonNull(types.asSuper(currentClass.type.referenceProjectionOrSelf(), supSym));\n+            Assert.checkNonNull(types.asSuper(currentClass.type, supSym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":39,"deletions":86,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-    private final boolean allowValueClasses;\n@@ -92,2 +91,0 @@\n-        Source source = Source.instance(context);\n-        allowValueClasses = Source.Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -190,3 +187,0 @@\n-        if (tree.name == tree.name.table.names.init && allowValueClasses && enclScope.owner.isConcreteValueClass()) {\n-            tree.name = tree.name.table.names.vnew;\n-        }\n@@ -245,15 +239,0 @@\n-\n-        if (m.isInitOrVNew() && m.type.getParameterTypes().size() == 0) {\n-            int statsSize = tree.body.stats.size();\n-            if (statsSize == 0) {\n-                m.flags_field |= EMPTYNOARGCONSTR;\n-            } else if (statsSize == 1 && TreeInfo.isSuperCall(tree.body.stats.head)) {\n-                JCExpressionStatement exec = (JCExpressionStatement) tree.body.stats.head;\n-                JCMethodInvocation meth = (JCMethodInvocation)exec.expr;\n-                if (meth.args.size() == 0) {\n-                    \/\/ Deem a constructor \"empty\" even if it contains a 'super' call,\n-                    \/\/ as long as it has no argument expressions (to respect common coding style).\n-                    m.flags_field |= EMPTYNOARGCONSTR;\n-                }\n-            }\n-        }\n@@ -280,6 +259,0 @@\n-    @Override\n-    public void visitBlock(JCBlock tree) {\n-        if ((tree.flags & STATIC) == 0 && tree.stats.size() > 0)\n-            env.info.scope.owner.flags_field |= HASINITBLOCK;\n-    }\n-\n@@ -325,3 +298,0 @@\n-        \/* Don't want constant propagation\/folding for instance fields of primitive classes,\n-           as these can undergo updates via copy on write.\n-        *\/\n@@ -330,1 +300,1 @@\n-            if ((v.flags_field & FINAL) != 0 && ((v.flags_field & STATIC) != 0 || !v.owner.isValueClass()) &&\n+            if ((v.flags_field & FINAL) != 0 &&\n@@ -364,1 +334,1 @@\n-        if (m.isInitOrVNew()) {\n+        if (m.isConstructor()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":2,"deletions":32,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1059,2 +1059,1 @@\n-            Name constructorName = tsym.isConcreteValueClass() ? names.vnew : names.init;\n-            for (Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n+            for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-    public final boolean allowValueClasses;\n@@ -115,1 +114,0 @@\n-    final boolean allowPrimitiveClasses;\n@@ -153,2 +151,0 @@\n-        allowValueClasses = Feature.VALUE_CLASSES.allowedInSource(source);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -224,1 +220,1 @@\n-        if (names.isInitOrVNew(bestSoFar.name) &&\n+        if (bestSoFar.name == names.init &&\n@@ -297,1 +293,1 @@\n-        return owner.isInitOrVNew() ||\n+        return owner.isConstructor() ||\n@@ -409,1 +405,1 @@\n-        if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) return false;\n+        if (sym.name == names.init && sym.owner != site.tsym) return false;\n@@ -423,14 +419,0 @@\n-        if (allowPrimitiveClasses) {\n-            if (sym.kind == MTH || sym.kind == VAR) {\n-                \/* If any primitive class types are involved, ask the same question in the reference universe,\n-                   where the hierarchy is navigable\n-                *\/\n-                if (site.isPrimitiveClass())\n-                    site = site.referenceProjection();\n-            } else if (sym.kind == TYP) {\n-                \/\/ A type is accessible in a reference projection if it was\n-                \/\/ accessible in the value projection.\n-                if (site.isReferenceProjection())\n-                    site = site.valueProjection();\n-            }\n-        }\n@@ -488,1 +470,1 @@\n-        if (sym.kind != MTH || sym.isInitOrVNew() || sym.isStatic())\n+        if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())\n@@ -490,6 +472,4 @@\n-\n-        \/* If any primitive class types are involved, ask the same question in the reference universe,\n-           where the hierarchy is navigable\n-        *\/\n-        if (allowPrimitiveClasses && site.isPrimitiveClass()) {\n-            site = site.referenceProjection();\n+        else {\n+            Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);\n+            return (s2 == null || s2 == sym || sym.owner == s2.owner || (sym.owner.isInterface() && s2.owner == syms.objectType.tsym) ||\n+                    !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));\n@@ -497,4 +477,0 @@\n-\n-        Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);\n-        return (s2 == null || s2 == sym || sym.owner == s2.owner || (sym.owner.isInterface() && s2.owner == syms.objectType.tsym) ||\n-                !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));\n@@ -1535,2 +1511,1 @@\n-                if (staticOnly &&\n-                        sym.kind == VAR &&\n+                if (sym.kind == VAR &&\n@@ -1538,4 +1513,7 @@\n-                        (sym.flags() & STATIC) == 0)\n-                    return new StaticError(sym);\n-                else\n-                    return sym;\n+                        (sym.flags() & STATIC) == 0) {\n+                    if (staticOnly)\n+                        return new StaticError(sym);\n+                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0)\n+                        return new RefBeforeCtorCalledError(sym);\n+                }\n+                return sym;\n@@ -1720,1 +1698,1 @@\n-                    if (types.asSuper(m1Owner.type.referenceProjectionOrSelf(), m2Owner) != null &&\n+                    if (types.asSuper(m1Owner.type, m2Owner) != null &&\n@@ -1725,1 +1703,1 @@\n-                    if (types.asSuper(m2Owner.type.referenceProjectionOrSelf(), m1Owner) != null &&\n+                    if (types.asSuper(m2Owner.type, m1Owner) != null &&\n@@ -1892,1 +1870,1 @@\n-            if (names.isInitOrVNew(name)) return bestSoFar;\n+            if (name == names.init) return bestSoFar;\n@@ -2038,5 +2016,9 @@\n-                    if (staticOnly &&\n-                        sym.kind == MTH &&\n-                        sym.owner.kind == TYP &&\n-                        (sym.flags() & STATIC) == 0) return new StaticError(sym);\n-                    else return sym;\n+                    if (sym.kind == MTH &&\n+                            sym.owner.kind == TYP &&\n+                            (sym.flags() & STATIC) == 0) {\n+                        if (staticOnly)\n+                            return new StaticError(sym);\n+                        if (env1.info.ctorPrologue && env1 == env)\n+                            return new RefBeforeCtorCalledError(sym);\n+                    }\n+                    return sym;\n@@ -2327,16 +2309,0 @@\n-        return findMemberTypeInternal(env,site, name, c);\n-    }\n-\n-    \/** Find qualified member type.\n-     *  @param env       The current environment.\n-     *  @param site      The original type from where the selection takes\n-     *                   place.\n-     *  @param name      The type's name.\n-     *  @param c         The class to search for the member type. This is\n-     *                   always a superclass or implemented interface of\n-     *                   site's class.\n-     *\/\n-    Symbol findMemberTypeInternal(Env<AttrContext> env,\n-                          Type site,\n-                          Name name,\n-                          TypeSymbol c) {\n@@ -2391,8 +2357,0 @@\n-        return findTypeInternal(env, name);\n-    }\n-\n-    \/** Find an unqualified type symbol.\n-     *  @param env       The current environment.\n-     *  @param name      The type's name.\n-     *\/\n-    Symbol findTypeInternal(Env<AttrContext> env, Name name) {\n@@ -2936,2 +2894,1 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n-        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n+        return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n@@ -2971,1 +2928,0 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2973,1 +2929,1 @@\n-                                    constructorName, argtypes,\n+                                    names.init, argtypes,\n@@ -2996,1 +2952,0 @@\n-        Name constructorName = allowValueClasses && site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n@@ -2998,1 +2953,1 @@\n-                new BasicLookupHelper(constructorName, site, argtypes, typeargtypes) {\n+                new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {\n@@ -3013,1 +2968,1 @@\n-                                sym = accessMethod(sym, pos, site, constructorName, true, argtypes, typeargtypes);\n+                                sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);\n@@ -3060,2 +3015,1 @@\n-        Name constructorName = site.tsym.isConcreteValueClass() ? names.vnew : names.init;\n-        for (final Symbol sym : tsym.members().getSymbolsByName(constructorName)) {\n+        for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {\n@@ -3070,1 +3024,1 @@\n-                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), constructorName, constrType, site.tsym) {\n+                    MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {\n@@ -3112,1 +3066,1 @@\n-        if (!names.isInitOrVNew(name)) {\n+        if (!name.equals(names.init)) {\n@@ -3627,1 +3581,1 @@\n-                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head.referenceProjectionOrSelf()), originalSite))) {\n+                        types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {\n@@ -3692,1 +3646,1 @@\n-                Type asSuperSite = types.asSuper(argtypes.head.referenceProjectionOrSelf(), site.tsym);\n+                Type asSuperSite = types.asSuper(argtypes.head, site.tsym);\n@@ -3717,2 +3671,1 @@\n-            \/\/ TODO - array constructor will be <init>\n-            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -3750,1 +3703,1 @@\n-            super(referenceTree, site.tsym.isConcreteValueClass() ? names.vnew : names.init, site, argtypes, typeargtypes, maxPhase);\n+            super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);\n@@ -3754,1 +3707,1 @@\n-                            site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata(), site.getFlavor());\n+                                site.tsym.type.getTypeArguments() : List.nil(), site.tsym, site.getMetadata());\n@@ -3828,1 +3781,4 @@\n-                    if (staticOnly) sym = new StaticError(sym);\n+                    if (staticOnly)\n+                        sym = new StaticError(sym);\n+                    else if (env1.info.ctorPrologue)\n+                        sym = new RefBeforeCtorCalledError(sym);\n@@ -3842,0 +3798,2 @@\n+                    if (env.info.ctorPrologue)\n+                        log.error(pos, Errors.CantRefBeforeCtorCalled(name));\n@@ -3844,1 +3802,1 @@\n-                            types.asSuper(env.enclClass.type.referenceProjectionOrSelf(), c), env.enclClass.sym);\n+                            types.asSuper(env.enclClass.type, c), env.enclClass.sym);\n@@ -3943,2 +3901,2 @@\n-        if (env.info.isSelfCall && thisType.tsym == env.enclClass.sym) {\n-            log.error(pos, Errors.CantRefBeforeCtorCalled(\"this\"));\n+        if (env.info.ctorPrologue && thisType.tsym == env.enclClass.sym) {\n+            log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n@@ -4157,1 +4115,1 @@\n-            boolean isConstructor = names.isInitOrVNew(name);\n+            boolean isConstructor = name == names.init;\n@@ -4256,1 +4214,1 @@\n-                              names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n+                              ws.name == names.init ? ws.owner.name : ws.name,\n@@ -4273,1 +4231,1 @@\n-                              names.isInitOrVNew(ws.name) ? ws.owner.name : ws.name,\n+                              ws.name == names.init ? ws.owner.name : ws.name,\n@@ -4330,1 +4288,0 @@\n-                boolean isConstructor = names.isInitOrVNew(name);\n@@ -4339,2 +4296,2 @@\n-                        isConstructor ? KindName.CONSTRUCTOR : kind.absentKind(),\n-                        isConstructor ? site.tsym.name : name,\n+                        name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),\n+                        name == names.init ? site.tsym.name : name,\n@@ -4500,1 +4457,1 @@\n-            if (names.isInitOrVNew(sym.name) && sym.owner != site.tsym) {\n+            if (sym.name == names.init && sym.owner != site.tsym) {\n@@ -4649,1 +4606,5 @@\n-            super(STATICERR, sym, \"static error\");\n+            this(sym, \"static error\");\n+        }\n+\n+        StaticError(Symbol sym, String debugName) {\n+            super(STATICERR, sym, debugName);\n@@ -4668,0 +4629,26 @@\n+    \/**\n+     * Specialization of {@link InvalidSymbolError} for illegal\n+     * early accesses within a constructor prologue.\n+     *\/\n+    class RefBeforeCtorCalledError extends StaticError {\n+\n+        RefBeforeCtorCalledError(Symbol sym) {\n+            super(sym, \"prologue error\");\n+        }\n+\n+        @Override\n+        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,\n+                DiagnosticPosition pos,\n+                Symbol location,\n+                Type site,\n+                Name name,\n+                List<Type> argtypes,\n+                List<Type> typeargtypes) {\n+            Symbol errSym = ((sym.kind == TYP && sym.type.hasTag(CLASS))\n+                ? types.erasure(sym.type).tsym\n+                : sym);\n+            return diags.create(dkind, log.currentSource(), pos,\n+                    \"cant.ref.before.ctor.called\", errSym);\n+        }\n+    }\n+\n@@ -4713,1 +4700,1 @@\n-            if (names.isInitOrVNew(sname)) sname = s1.owner.name;\n+            if (sname == names.init) sname = s1.owner.name;\n@@ -4781,1 +4768,1 @@\n-            super(sym);\n+            super(sym, \"bad method ref error\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":88,"deletions":101,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-        MethodSymbol sym = (MethodSymbol)TreeInfo.symbolFor(invoke.meth);\n+        Symbol sym = TreeInfo.symbolFor(invoke.meth);\n@@ -533,1 +533,1 @@\n-    private void invoke(JCTree site, MethodSymbol sym, List<JCExpression> args, RefSet<?> receiverRefs) {\n+    private void invoke(JCTree site, Symbol sym, List<JCExpression> args, RefSet<?> receiverRefs) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-                !names.isInitOrVNew(sym.name) &&\n+                sym.name != names.init &&\n@@ -505,7 +505,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        tree.field = translate(tree.field, null);\n-        tree.value = translate(tree.value, erasure(tree.field.type));\n-        tree.type = erasure(tree.type);\n-        result = retype(tree, tree.type, pt);\n-    }\n-\n@@ -680,1 +673,0 @@\n-        \/\/ TODO - is enum so <init>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -43,1 +42,0 @@\n-import com.sun.tools.javac.jvm.Target;\n@@ -62,1 +60,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n@@ -575,1 +572,0 @@\n-            localEnv.info.isSelfCall = false;\n@@ -1146,9 +1142,2 @@\n-            if (tree.sym != syms.objectType.tsym && tree.sym != syms.recordType.tsym) {\n-                if ((tree.sym.flags() & (ABSTRACT | INTERFACE | VALUE_CLASS)) == 0) {\n-                    tree.sym.flags_field |= IDENTITY_TYPE;\n-                }\n-                if ((tree.sym.flags() & (ABSTRACT | IDENTITY_TYPE | INTERFACE)) == ABSTRACT) {\n-                    if (abstractClassHasImplicitIdentity(tree)) {\n-                        tree.sym.flags_field |= IDENTITY_TYPE;\n-                    }\n-                }\n+            if ((tree.sym.flags() & (INTERFACE | VALUE_CLASS)) == 0) {\n+                tree.sym.flags_field |= IDENTITY_TYPE;\n@@ -1158,44 +1147,0 @@\n-            \/\/ where\n-            private boolean abstractClassHasImplicitIdentity(JCClassDecl tree) {\n-\n-                Type t = tree.sym.type;\n-\n-                if (t == null || t.tsym == null || t.tsym.kind == ERR)\n-                    return false;\n-\n-                if ((t.tsym.flags() & HASINITBLOCK) != 0) {\n-                    return true;\n-                }\n-\n-                \/\/ No instance fields and no arged constructors both mean inner classes cannot be value class supers.\n-                Type encl = t.getEnclosingType();\n-                if (encl != null && encl.hasTag(CLASS)) {\n-                    return true;\n-                }\n-                for (Symbol s : t.tsym.members().getSymbols(NON_RECURSIVE)) {\n-                    switch (s.kind) {\n-                        case VAR:\n-                            if ((s.flags() & STATIC) == 0) {\n-                                return true;\n-                            }\n-                            break;\n-                        case MTH:\n-                            if ((s.flags() & (SYNCHRONIZED | STATIC)) == SYNCHRONIZED) {\n-                                return true;\n-                            } else if (s.isInitOrVNew()) {\n-                                MethodSymbol m = (MethodSymbol)s;\n-                                if (m.getParameters().size() > 0\n-                                        || m.getTypeParameters().size() > 0\n-                                        || m.type.getThrownTypes().nonEmpty()\n-                                        || (m.flags() & EMPTYNOARGCONSTR) == 0\n-                                        || (Check.protection(m.flags()) > Check.protection(m.owner.flags()))) {\n-                                    return true;\n-                                }\n-                            }\n-                            break;\n-                    }\n-                }\n-                return false;\n-            }\n-\n-\n@@ -1395,2 +1340,1 @@\n-                Name constructorName = owner().isConcreteValueClass() ? names.vnew : names.init;\n-                constructorSymbol = new MethodSymbol(flags, constructorName,\n+                constructorSymbol = new MethodSymbol(flags, names.init,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":3,"deletions":59,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -245,6 +245,1 @@\n-\n-        \/\/ value classes related bytecodes\n-        aconst_init     = 203,\n-        withfield       = 204,\n-\n-        ByteCodeCount   = 205;\n+        ByteCodeCount   = 203;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ByteCodes.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;\n@@ -284,7 +285,0 @@\n-        public void visitWithField(JCWithField tree) {\n-            SourceRange sr = new SourceRange(startPos(tree), endPos(tree));\n-            sr.mergeWith(csp(tree.field));\n-            sr.mergeWith(csp(tree.value));\n-            result = sr;\n-        }\n-\n@@ -387,7 +381,0 @@\n-        @Override\n-        public void visitDefaultValue(JCDefaultValue tree) {\n-            SourceRange sr = new SourceRange(startPos(tree), endPos(tree));\n-            sr.mergeWith(csp(tree.clazz));\n-            result = sr;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/CRTable.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- *     classig    ::= 'L' name [typeargs] ';' | 'Q' name [typeargs] ';'\n+ *     classig    ::= 'L' name [typeargs] ';'\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -64,0 +63,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties;\n@@ -66,0 +66,1 @@\n+import com.sun.tools.javac.tree.JCTree;\n@@ -77,0 +78,1 @@\n+import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;\n@@ -112,4 +114,0 @@\n-    \/** Switch: allow primitive classes.\n-     *\/\n-    boolean allowPrimitiveClasses;\n-\n@@ -294,1 +292,0 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -514,1 +511,0 @@\n-        case 'Q':\n@@ -518,4 +514,0 @@\n-                if ((char) signature[sigp] == 'Q' && !allowPrimitiveClasses) {\n-                    throw badClassFile(\"bad.class.signature\",\n-                                       quoteBadSignature());\n-                }\n@@ -579,2 +571,1 @@\n-        byte prefix = signature[sigp];\n-        if (prefix != 'L' && (!allowPrimitiveClasses || prefix != 'Q'))\n+        if (signature[sigp] != 'L')\n@@ -585,1 +576,0 @@\n-        ClassType.Flavor flavor;\n@@ -597,2 +587,0 @@\n-                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -602,2 +590,1 @@\n-                        \/\/ Todo: This spews out more objects than before, i.e no reuse with identical flavor\n-                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata(), flavor);\n+                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata());\n@@ -605,1 +592,1 @@\n-                    return new ClassType(outer, List.nil(), t, List.nil(), flavor);\n+                    return new ClassType(outer, List.nil(), t, List.nil());\n@@ -615,3 +602,1 @@\n-                \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                outer = new ClassType(outer, sigToTypes('>'), t, List.nil(), flavor) {\n+                outer = new ClassType(outer, sigToTypes('>'), t, List.nil()) {\n@@ -680,3 +665,1 @@\n-                    \/\/ We are seeing QFoo; or LFoo; The name itself does not shine any light on default val-refness\n-                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                    outer = new ClassType(outer, List.nil(), t, List.nil(), flavor);\n+                    outer = new ClassType(outer, List.nil(), t, List.nil());\n@@ -874,13 +857,0 @@\n-                    if (sym.isInitOrVNew() && sym.type.getParameterTypes().size() == 0) {\n-                        try {\n-                            int code_length = buf.getInt(bp + 4);\n-                            if ((code_length == 1 && buf.getByte(bp + 8) == (byte) ByteCodes.return_) ||\n-                                (code_length == 5 && buf.getByte(bp + 8) == ByteCodes.aload_0 &&\n-                                    buf.getByte(bp + 9) == (byte) ByteCodes.invokespecial &&\n-                                            buf.getByte(bp + 12) == (byte) ByteCodes.return_)) {\n-                                sym.flags_field |= EMPTYNOARGCONSTR;\n-                            }\n-                        } catch (UnderflowException e) {\n-                            throw badClassFile(\"bad.class.truncated.at.offset\", Integer.toString(e.getLength()));\n-                        }\n-                    }\n@@ -1066,7 +1036,0 @@\n-                        \/\/ Map value class factory methods back to constructors for the benefit of earlier pipeline stages\n-                        if (sym.kind == MTH && sym.name == names.vnew && !sym.type.getReturnType().hasTag(TypeTag.VOID)) {\n-                            sym.type = new MethodType(sym.type.getParameterTypes(),\n-                                    syms.voidType,\n-                                    sym.type.getThrownTypes(),\n-                                    syms.methodClass);\n-                        }\n@@ -1426,1 +1389,1 @@\n-        if (!names.isInitOrVNew(nt.name))\n+        if (nt.name != names.init)\n@@ -2360,7 +2323,0 @@\n-        if (names.isInitOrVNew(name) && ((flags & STATIC) != 0)) {\n-            flags &= ~STATIC;\n-            type = new MethodType(type.getParameterTypes(),\n-                    syms.voidType,\n-                    type.getThrownTypes(),\n-                    syms.methodClass);\n-        }\n@@ -2368,1 +2324,1 @@\n-        if (names.isInitOrVNew(name) && currentOwner.hasOuterInstance()) {\n+        if (name == names.init && currentOwner.hasOuterInstance()) {\n@@ -2413,1 +2369,1 @@\n-            ((name == names.init || name == names.vnew) && !t.getReturnType().hasTag(TypeTag.VOID))) {\n+            (name == names.init && !t.getReturnType().hasTag(TypeTag.VOID))) {\n@@ -2477,1 +2433,1 @@\n-        if (names.isInitOrVNew(sym.name) && currentOwner.hasOuterInstance()) {\n+        if (sym.name == names.init && currentOwner.hasOuterInstance()) {\n@@ -2641,8 +2597,0 @@\n-        if (c == syms.objectType.tsym) {\n-            flags &= ~IDENTITY_TYPE; \/\/ jlO lacks identity even while being a concrete class.\n-        }\n-        if ((flags & PRIMITIVE_CLASS) != 0) {\n-            if (!allowPrimitiveClasses || (flags & (FINAL | PRIMITIVE_CLASS | IDENTITY_TYPE)) != (FINAL | PRIMITIVE_CLASS)) {\n-                throw badClassFile(\"bad.access.flags\", Flags.toString(flags));\n-            }\n-        }\n@@ -2906,3 +2854,0 @@\n-        if ((flags & (ABSTRACT | INTERFACE | ACC_VALUE | ACC_MODULE)) == 0) {\n-            flags |= ACC_IDENTITY;\n-        }\n@@ -2913,12 +2858,0 @@\n-        if ((flags & ACC_PRIMITIVE) != 0) {\n-            flags &= ~ACC_PRIMITIVE;\n-            if (allowPrimitiveClasses) {\n-                flags |= PRIMITIVE_CLASS;\n-            }\n-        }\n-        if ((flags & ACC_VALUE) != 0) {\n-            flags &= ~ACC_VALUE;\n-            if (allowValueClasses) {\n-                flags |= VALUE_CLASS;\n-            }\n-        }\n@@ -2928,0 +2861,2 @@\n+        } else if ((flags & INTERFACE) == 0 && allowValueClasses) {\n+            flags |= VALUE_CLASS;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":14,"deletions":79,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-import com.sun.tools.javac.code.Scope.WriteableScope;\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -113,2 +111,0 @@\n-    private boolean allowPrimitiveClasses;\n-\n@@ -148,2 +144,0 @@\n-    private final Symtab syms;\n-\n@@ -184,1 +178,0 @@\n-        syms = Symtab.instance(context);\n@@ -200,2 +193,0 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -234,1 +225,1 @@\n-            if ((f & 1) != 0) {\n+            if ((f & 1) != 0 && flagName[i] != \"\") {\n@@ -246,1 +237,2 @@\n-            \"IDENTITY\", \"VOLATILE\", \"TRANSIENT\", \"NATIVE\", \"INTERFACE\",\n+            \/\/ the empty position should be for synchronized but right now we don't have any test checking it\n+            \"\", \"VOLATILE\", \"TRANSIENT\", \"NATIVE\", \"INTERFACE\",\n@@ -1076,1 +1068,1 @@\n-        if ((m.isInitOrVNew() || m.isValueObjectFactory()) && (m.flags_field & RECORD) != 0)\n+        if (m.isConstructor() && (m.flags_field & RECORD) != 0)\n@@ -1301,4 +1293,0 @@\n-                if (debugstackmap) System.out.print(\"object(\" + types.erasure(t).tsym + \")\");\n-                databuf.appendByte(7);\n-                databuf.appendChar(allowPrimitiveClasses && t.isPrimitiveClass() ? poolWriter.putClass(new ConstantPoolQType(types.erasure(t), types)) : poolWriter.putClass(types.erasure(t)));\n-                break;\n@@ -1618,1 +1606,1 @@\n-            flags = flags & AdjustedClassFlags;\n+            flags = flags & ClassFlags;\n@@ -1646,1 +1634,1 @@\n-            case TYP: poolWriter.enterInnerClass((ClassSymbol)sym); break;\n+            case TYP: poolWriter.enterInner((ClassSymbol)sym); break;\n@@ -1653,1 +1641,1 @@\n-                poolWriter.enterInnerClass(local);\n+                poolWriter.enterInner(local);\n@@ -1792,5 +1780,1 @@\n-        if ((flags & PRIMITIVE_CLASS) != 0)\n-            result |= ACC_PRIMITIVE;\n-        if ((flags & VALUE_CLASS) != 0)\n-            result |= ACC_VALUE;\n-        if ((flags & IDENTITY_TYPE) != 0)\n+        if ((flags & IDENTITY_TYPE) != 0) {\n@@ -1798,0 +1782,1 @@\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.ToIntFunction;\n@@ -37,0 +38,1 @@\n+import static com.sun.tools.javac.code.TypeTag.DOUBLE;\n@@ -38,0 +40,1 @@\n+import static com.sun.tools.javac.code.TypeTag.LONG;\n@@ -39,0 +42,11 @@\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Class;\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Double;\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Fieldref;\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Float;\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Integer;\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_InterfaceMethodref;\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Long;\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodHandle;\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodType;\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Methodref;\n+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_String;\n@@ -185,1 +199,0 @@\n-    private boolean allowPrimitiveClasses;\n@@ -199,2 +212,1 @@\n-                PoolWriter poolWriter,\n-                boolean allowPrimitiveClasses) {\n+                PoolWriter poolWriter) {\n@@ -222,1 +234,0 @@\n-        this.allowPrimitiveClasses = allowPrimitiveClasses;\n@@ -393,11 +404,0 @@\n-    public void emitLdc(LoadableConstant constant, int od) {\n-        if (od <= 255) {\n-            emitop1(ldc1, od, constant);\n-        }\n-        else {\n-            emitop2(ldc2, od, constant);\n-        }\n-    }\n-\n-    \/** Emit a ldc (or ldc_w) instruction, taking into account operand size\n-     *\/\n@@ -406,1 +406,4 @@\n-        if (od <= 255) {\n+        Type constantType = types.constantType(constant);\n+        if (constantType.hasTag(LONG) || constantType.hasTag(DOUBLE)) {\n+            emitop2(ldc2w, od, constant);\n+        } else if (od <= 255) {\n@@ -408,2 +411,1 @@\n-        }\n-        else {\n+        } else {\n@@ -466,1 +468,1 @@\n-        if (member.isInitOrVNew())\n+        if (member.isConstructor())\n@@ -1025,6 +1027,1 @@\n-            state.push(uninitializedObject(t.tsym.erasure(types), cp - 3));\n-            break;\n-        }\n-        case aconst_init: {\n-            Type t = (Type)data;\n-            state.push(t.tsym.erasure(types));\n+            state.push(uninitializedObject(t.tsym.erasure(types), cp-3));\n@@ -1059,3 +1056,0 @@\n-        case withfield:\n-            state.pop(((Symbol)data).erasure(types));\n-            break;\n@@ -1072,1 +1066,1 @@\n-            Type t = types.erasure(data instanceof  ConstantPoolQType ? ((ConstantPoolQType)data).type: (Type)data);\n+            Type t = types.erasure((Type)data);\n@@ -1075,0 +1069,1 @@\n+        case ldc2:\n@@ -1082,3 +1077,0 @@\n-        case ldc2:\n-            state.push(types.constantType((LoadableConstant)data));\n-            break;\n@@ -1388,1 +1380,1 @@\n-            if (meth.isInitOrVNew() && thisType != syms.objectType) {\n+            if (meth.isConstructor() && thisType != syms.objectType) {\n@@ -1786,6 +1778,2 @@\n-                if (!allowPrimitiveClasses) {\n-                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)));\n-                } else {\n-                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)) ||\n-                            (old.isPrimitiveClass() != t.isPrimitiveClass() && types.isConvertible(types.erasure(old), types.erasure(t))));\n-                }\n+                Assert.check(types.isSubtype(types.erasure(old),\n+                                       types.erasure(t)));\n@@ -2467,2 +2455,0 @@\n-            mnem[aconst_init] = \"aconst_init\";\n-            mnem[withfield] = \"withfield\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":27,"deletions":41,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-    private static final Object[] NO_STATIC_ARGS = new Object[0];\n@@ -82,1 +81,0 @@\n-    private final TransValues transValues;\n@@ -119,1 +117,0 @@\n-        transValues = TransValues.instance(context);\n@@ -137,2 +134,0 @@\n-        Source source = Source.instance(context);\n-        allowPrimitiveClasses = Source.Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -183,2 +178,0 @@\n-    boolean allowPrimitiveClasses;\n-\n@@ -274,14 +267,0 @@\n-    \/** Insert a reference to given type in the constant pool,\n-     *  checking for an array with too many dimensions;\n-     *  return the reference's index.\n-     *  @param type   The type for which a reference is inserted.\n-     *\/\n-    int makeRef(DiagnosticPosition pos, Type type, boolean emitQtype) {\n-        checkDimension(pos, type);\n-        if (emitQtype) {\n-            return poolWriter.putClass(new ConstantPoolQType(type, types));\n-        } else {\n-            return poolWriter.putClass(type);\n-        }\n-    }\n-\n@@ -294,1 +273,1 @@\n-        return makeRef(pos, type, false);\n+        return poolWriter.putClass(checkDimension(pos, type));\n@@ -348,1 +327,1 @@\n-        else items.makeMemberItem(msym, names.isInitOrVNew(name)).invoke();\n+        else items.makeMemberItem(msym, name == names.init).invoke();\n@@ -565,1 +544,1 @@\n-    \/** Insert instance initializer code into initial constructor.\n+    \/** Insert instance initializer code into constructors prior to the super() call.\n@@ -572,31 +551,5 @@\n-        if (names.isInitOrVNew(md.name) && TreeInfo.isInitialConstructor(md)) {\n-            \/\/ We are seeing a constructor that does not call another\n-            \/\/ constructor of the same class.\n-            List<JCStatement> stats = md.body.stats;\n-            ListBuffer<JCStatement> newstats = new ListBuffer<>();\n-\n-            if (stats.nonEmpty()) {\n-                \/\/ Copy initializers of synthetic variables generated in\n-                \/\/ the translation of inner classes.\n-                while (TreeInfo.isSyntheticInit(stats.head)) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n-                \/\/ Copy superclass constructor call\n-                newstats.append(stats.head);\n-                stats = stats.tail;\n-                \/\/ Copy remaining synthetic initializers.\n-                while (stats.nonEmpty() &&\n-                       TreeInfo.isSyntheticInit(stats.head)) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n-                \/\/ Now insert the initializer code.\n-                newstats.appendList(initCode);\n-                \/\/ And copy all remaining statements.\n-                while (stats.nonEmpty()) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n-            }\n-            md.body.stats = newstats.toList();\n+        if (TreeInfo.isConstructor(md) && TreeInfo.hasConstructorCall(md, names._super)) {\n+            \/\/ We are seeing a constructor that has a super() call.\n+            \/\/ Find the super() invocation and append the given initializer code.\n+            TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.prepend(supercall)));\n+\n@@ -975,1 +928,1 @@\n-            if (meth.isInitOrVNew()) {\n+            if (meth.isConstructor()) {\n@@ -1015,3 +968,0 @@\n-                    } else if (env.enclMethod.sym.isValueObjectFactory()) {\n-                        items.makeLocalItem(env.enclMethod.factoryProduct).load();\n-                        code.emitop0(areturn);\n@@ -1072,2 +1022,1 @@\n-                                        poolWriter,\n-                                        allowPrimitiveClasses);\n+                                        poolWriter);\n@@ -1083,1 +1032,1 @@\n-                if (meth.isInitOrVNew() && selfType != syms.objectType)\n+                if (meth.isConstructor() && selfType != syms.objectType)\n@@ -1174,31 +1123,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        switch(tree.field.getTag()) {\n-            case IDENT:\n-                Symbol sym = ((JCIdent) tree.field).sym;\n-                items.makeThisItem().load();\n-                genExpr(tree.value, tree.field.type).load();\n-                sym = binaryQualifier(sym, env.enclClass.type);\n-                code.emitop2(withfield, sym, PoolWriter::putMember);\n-                result = items.makeStackItem(tree.type);\n-                break;\n-            case SELECT:\n-                JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;\n-                sym = TreeInfo.symbol(fieldAccess);\n-                \/\/ JDK-8207332: To maintain the order of side effects, must compute value ahead of field\n-                genExpr(tree.value, tree.field.type).load();\n-                genExpr(fieldAccess.selected, fieldAccess.selected.type).load();\n-                if (Code.width(tree.field.type) == 2) {\n-                    code.emitop0(dup_x2);\n-                    code.emitop0(pop);\n-                } else {\n-                    code.emitop0(swap);\n-                }\n-                sym = binaryQualifier(sym, fieldAccess.selected.type);\n-                code.emitop2(withfield, sym, PoolWriter::putMember);\n-                result = items.makeStackItem(tree.type);\n-                break;\n-            default:\n-                Assert.check(false);\n-        }\n-    }\n-\n@@ -2130,1 +2048,1 @@\n-                code.emitAnewarray(makeRef(pos, elemtype, elemtype.isPrimitiveClass()), type);\n+                code.emitAnewarray(makeRef(pos, elemtype), type);\n@@ -2356,1 +2274,0 @@\n-        \/\/ primitive reference conversion is a nop when we bifurcate the primitive class, as the VM sees a subtyping relationship.\n@@ -2359,9 +2276,2 @@\n-            (!tree.clazz.type.isReferenceProjection() || !types.isSameType(tree.clazz.type.valueProjection(), tree.expr.type) || true) &&\n-           !types.isSubtype(tree.expr.type, tree.clazz.type)) {\n-            checkDimension(tree.pos(), tree.clazz.type);\n-            if (tree.clazz.type.isPrimitiveClass()) {\n-                code.emitop2(checkcast, new ConstantPoolQType(tree.clazz.type, types), PoolWriter::putClass);\n-            } else {\n-                code.emitop2(checkcast, tree.clazz.type, PoolWriter::putClass);\n-            }\n-\n+           types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {\n+            code.emitop2(checkcast, checkDimension(tree.pos(), tree.clazz.type), PoolWriter::putClass);\n@@ -2429,1 +2339,1 @@\n-            code.emitLdc((LoadableConstant) tree.selected.type, makeRef(tree.pos(), tree.selected.type, tree.selected.type.isPrimitiveClass()));\n+            code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));\n@@ -2488,12 +2398,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        if (tree.type.isValueClass()) {\n-            code.emitop2(aconst_init, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);\n-        } else if (tree.type.isReference()) {\n-            code.emitop0(aconst_null);\n-        } else {\n-            code.emitop0(zero(Code.typecode(tree.type)));\n-        }\n-        result = items.makeStackItem(tree.type);\n-        return;\n-    }\n-\n@@ -2556,1 +2454,0 @@\n-            cdef = transValues.translateTopLevelClass(cdef, make);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":15,"deletions":118,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-            MethodType mtype = (MethodType)member.externalType(types); \/\/ static factories\n+            MethodType mtype = (MethodType)member.erasure(types);\n@@ -593,9 +593,0 @@\n-\n-        private void ldc() {\n-            if (typecode == LONGcode || typecode == DOUBLEcode) {\n-                code.emitop2(ldc2w, value, PoolWriter::putConstant);\n-            } else {\n-                code.emitLdc(value);\n-            }\n-        }\n-\n@@ -617,1 +608,1 @@\n-                    ldc();\n+                    code.emitLdc(value);\n@@ -624,1 +615,1 @@\n-                    ldc();\n+                    code.emitLdc(value);\n@@ -631,1 +622,1 @@\n-                    ldc();\n+                    code.emitLdc(value);\n@@ -639,1 +630,1 @@\n-                    ldc();\n+                    code.emitLdc(value);\n@@ -642,1 +633,1 @@\n-                ldc();\n+                code.emitLdc(value);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Items.java","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.tools.javac.code.Type.ConstantPoolQType;\n@@ -124,6 +123,0 @@\n-        \/* Their is nothing to be gained by having the pair of class types Foo.ref and Foo.val\n-           result in two different CONSTANT_Class_info strucures in the pool. These are\n-           indistinguishable at the class file level. Hence we coalesce them here.\n-        *\/\n-        if (t.isReferenceProjection())\n-            t = t.valueProjection();\n@@ -133,8 +126,0 @@\n-    \/**\n-     * Puts a type into the pool and return its index. The type could be either a class, a type variable\n-     * or an array type.\n-     *\/\n-    int putClass(ConstantPoolQType t) {\n-        return pool.writeIfNeeded(t);\n-    }\n-\n@@ -243,1 +228,1 @@\n-    void enterInnerClass(ClassSymbol c) {\n+    void enterInner(ClassSymbol c) {\n@@ -249,1 +234,1 @@\n-            enterInnerClass(c.owner.enclClass());\n+            enterInner(c.owner.enclClass());\n@@ -349,1 +334,1 @@\n-            enterInnerClass(c);\n+            enterInner(c);\n@@ -399,1 +384,1 @@\n-                    Type ct = c instanceof ConstantPoolQType ? ((ConstantPoolQType)c).type : (Type)c;\n+                    Type ct = (Type)c;\n@@ -402,1 +387,1 @@\n-                      c instanceof ConstantPoolQType ? names.fromString(\"Q\" + externalize(ct.tsym.flatName()) + \";\") : externalize(ct.tsym.flatName());\n+                            externalize(ct.tsym.flatName());\n@@ -406,1 +391,1 @@\n-                        enterInnerClass((ClassSymbol)ct.tsym);\n+                        enterInner((ClassSymbol)ct.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import static com.sun.tools.javac.tree.JCTree.Tag.LITERAL;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/StringConcat.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -214,0 +214,6 @@\n+    \/** Does the target VM support value classes\n+     *\/\n+    public boolean hasValueClasses() {\n+        return compareTo(JDK1_19) >= 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,432 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.jvm;\n-\n-import com.sun.tools.javac.code.Flags;\n-import com.sun.tools.javac.code.Scope.LookupKind;\n-import com.sun.tools.javac.code.Symbol;\n-import com.sun.tools.javac.code.Symbol.MethodSymbol;\n-import com.sun.tools.javac.code.Symbol.VarSymbol;\n-import com.sun.tools.javac.code.Symtab;\n-import com.sun.tools.javac.code.Type;\n-import com.sun.tools.javac.code.Type.MethodType;\n-import com.sun.tools.javac.code.Types;\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.JCAssign;\n-import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n-import com.sun.tools.javac.tree.JCTree.JCExpression;\n-import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;\n-import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n-import com.sun.tools.javac.tree.JCTree.JCIdent;\n-import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n-import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n-import com.sun.tools.javac.tree.JCTree.JCNewClass;\n-import com.sun.tools.javac.tree.JCTree.JCReturn;\n-import com.sun.tools.javac.tree.JCTree.JCStatement;\n-import com.sun.tools.javac.tree.TreeInfo;\n-import com.sun.tools.javac.tree.TreeMaker;\n-import com.sun.tools.javac.tree.TreeTranslator;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.List;\n-import com.sun.tools.javac.util.Name;\n-import com.sun.tools.javac.util.Names;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import static com.sun.tools.javac.code.Flags.RECORD;\n-import static com.sun.tools.javac.code.Flags.STATIC;\n-import static com.sun.tools.javac.code.Flags.ABSTRACT;\n-import static com.sun.tools.javac.code.Flags.VALUE_CLASS;\n-import static com.sun.tools.javac.code.Kinds.Kind.MTH;\n-import static com.sun.tools.javac.code.Kinds.Kind.TYP;\n-import static com.sun.tools.javac.code.Kinds.Kind.VAR;\n-import static com.sun.tools.javac.tree.JCTree.Tag.APPLY;\n-import static com.sun.tools.javac.tree.JCTree.Tag.EXEC;\n-import static com.sun.tools.javac.tree.JCTree.Tag.IDENT;\n-\n-\/**\n- * This pass translates value class constructors into static factory methods and patches up constructor\n- * calls to become invocations of those static factory methods.\n- *\n- * We get commissioned as a subpass of Gen. Constructor trees undergo plenty of change in Lower\n- * (enclosing instance injection, captured locals ...) and in Gen (instance field initialization,\n- * see normalizeDefs) and so it is most effective to wait until things reach a quiescent state\n- * before undertaking the tinkering that we do.\n- *\n- * See https:\/\/bugs.openjdk.java.net\/browse\/JDK-8198749 for the kind of transformations we do.\n- *\n- *\/\n-public class TransValues extends TreeTranslator {\n-\n-    protected static final Context.Key<TransValues> transValueClass = new Context.Key<>();\n-\n-    private Symtab syms;\n-    private TreeMaker make;\n-    private Types types;\n-    private Names names;\n-\n-    \/* Is an assignment undergoing translation just an assignment statement ?\n-       Or is also a value ??\n-    *\/\n-    private boolean requireRVal;\n-\n-    \/\/ class currently undergoing translation.\n-    private JCClassDecl currentClass;\n-\n-    \/\/ method currently undergoing translation.\n-    private JCMethodDecl currentMethod;\n-\n-    \/\/ list of factories synthesized so far.\n-    private List<JCTree> staticFactories;\n-\n-    \/\/ Map from constructor symbols to factory symbols.\n-    private Map<MethodSymbol, MethodSymbol> init2factory = new HashMap<>();\n-\n-    public static TransValues instance(Context context) {\n-        TransValues instance = context.get(transValueClass);\n-        if (instance == null) {\n-            instance = new TransValues(context);\n-            context.put(transValueClass, instance);\n-        }\n-        return instance;\n-    }\n-\n-    protected TransValues(Context context) {\n-        syms = Symtab.instance(context);\n-        make = TreeMaker.instance(context);\n-        types = Types.instance(context);\n-        names = Names.instance(context);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T extends JCTree> T translate(T tree, boolean requireRVal) {\n-        boolean priorRequireRVal = this.requireRVal;\n-        try {\n-            this.requireRVal = requireRVal;\n-            if (tree == null) {\n-                return null;\n-            } else {\n-                tree.accept(this);\n-                JCTree tmpResult = this.result;\n-                this.result = null;\n-                return (T)tmpResult; \/\/ XXX cast\n-            }\n-        } finally {\n-             this.requireRVal = priorRequireRVal;\n-        }\n-    }\n-\n-    @Override\n-    public <T extends JCTree> T translate(T tree) {\n-        return translate(tree, true);\n-    }\n-\n-    public JCClassDecl translateTopLevelClass(JCClassDecl classDecl, TreeMaker make) {\n-        try {\n-            this.make = make;\n-            translate(classDecl);\n-        } finally {\n-            \/\/ note that recursive invocations of this method fail hard\n-            this.make = null;\n-        }\n-        init2factory = new HashMap<>();\n-        return classDecl;\n-    }\n-\n-    @Override\n-    public void visitClassDef(JCClassDecl classDecl) {\n-        JCClassDecl previousClass = currentClass;\n-        List<JCTree> previousFactories = staticFactories;\n-        staticFactories = List.nil();\n-        currentClass = classDecl;\n-        try {\n-            super.visitClassDef(classDecl);\n-            classDecl.defs = classDecl.defs.appendList(staticFactories);\n-            staticFactories = List.nil();\n-        }\n-        finally {\n-            currentClass = previousClass;\n-            staticFactories = previousFactories;\n-        }\n-    }\n-\n-    @Override\n-    public void visitMethodDef(JCMethodDecl tree) {\n-        JCMethodDecl previousMethod = currentMethod;\n-        currentMethod = tree;\n-        try {\n-            if (transformToValueFactory()) {\n-\n-                \/\/ Mutate this value class constructor into an equivalent static factory\n-                make.at(tree.pos());\n-                JCExpressionStatement exec = chainedConstructorCall(tree);\n-                Assert.check(exec != null && TreeInfo.isSelfCall(exec));\n-                JCMethodInvocation call = (JCMethodInvocation) exec.expr;\n-\n-                \/* Unlike the reference construction sequence where `this' is allocated ahead of time and\n-                   is passed as an argument into the <init> method, the value static factory must allocate the\n-                   instance that forms the `product' by itself. We do that by injecting a prologue here.\n-                *\/\n-                VarSymbol product = currentMethod.factoryProduct = new VarSymbol(0, names.dollarValue, currentClass.sym.type, currentMethod.sym); \/\/ TODO: owner needs rewiring\n-                JCExpression rhs;\n-\n-                final Name name = TreeInfo.name(call.meth);\n-                MethodSymbol symbol = (MethodSymbol)TreeInfo.symbol(call.meth);\n-                if (names._super.equals(name)) { \/\/ \"initial\" constructor.\n-                    \/\/ Synthesize code to allocate factory \"product\" via: V $this = V.default;\n-                    Assert.check(symbol.type.getParameterTypes().size() == 0);\n-                    final JCExpression type = make.Type(currentClass.type);\n-                    rhs = make.DefaultValue(type);\n-                    rhs.type = currentClass.type;\n-                } else {\n-                    \/\/ This must be a chained call of form `this(args)'; Mutate it into a factory invocation i.e V $this = V.init(args);\n-                    Assert.check(TreeInfo.name(TreeInfo.firstConstructorCall(tree).meth) == names._this);\n-                    MethodSymbol factory = getValueObjectFactory(symbol);\n-                    final JCIdent ident = make.Ident(factory);\n-                    rhs = make.App(ident, call.args);\n-                    ((JCMethodInvocation)rhs).varargsElement = call.varargsElement;\n-                }\n-\n-                \/* The static factory product allocation prologue must precede any synthetic inits !!!\n-                   as these may reference `this' which gets pre-allocated for references but\n-                   not for value objects.\n-                *\/\n-                JCStatement prologue = make.VarDef(product, rhs);\n-                tree.body.stats = tree.body.stats.prepend(prologue).diff(List.of(exec));\n-                tree.body = translate(tree.body);\n-\n-                MethodSymbol factorySym = getValueObjectFactory(tree.sym);\n-                currentMethod.setType(factorySym.type);\n-                currentMethod.factoryProduct = product;\n-                currentClass.sym.members().remove(tree.sym);\n-                tree.sym = factorySym;\n-                currentClass.sym.members().enter(factorySym);\n-                tree.mods.flags |= STATIC;\n-\n-                \/* We may need an epilogue that returns the factory product, but we can't eagerly insert\n-                   a return here, since we don't know much about control flow here. Gen#genMethod\n-                   will insert a return of the factory product if control does reach the end and would\n-                   \"fall off the cliff\" otherwise.\n-                *\/\n-\n-                result = tree;\n-                return;\n-            }\n-            super.visitMethodDef(tree);\n-        } finally {\n-            currentMethod = previousMethod;\n-        }\n-    }\n-\n-    @Override\n-    public void visitReturn(JCReturn tree) {\n-        if (transformToValueFactory()) {\n-            result = make.Return(make.Ident(currentMethod.factoryProduct));\n-        } else {\n-            super.visitReturn(tree);\n-        }\n-    }\n-\n-    \/* Note: 1. Assignop does not call for any translation, since value class instance fields are final and\n-       so cannot be AssignedOped. 2. Any redundantly qualified this would have been lowered already.\n-    *\/\n-    @Override\n-    public void visitAssign(JCAssign tree) {\n-        if (transformToValueFactory()) {\n-            Symbol symbol = null;\n-            switch(tree.lhs.getTag()) {\n-                case IDENT:\n-                    symbol = ((JCIdent)tree.lhs).sym;\n-                    break;\n-                case SELECT:\n-                    JCFieldAccess fieldAccess = (JCFieldAccess) tree.lhs;\n-                    if (fieldAccess.selected.hasTag(IDENT) && ((JCIdent)fieldAccess.selected).name == names._this) {\n-                        symbol = fieldAccess.sym;\n-                    }\n-                    break;\n-                default:\n-                    break;\n-            }\n-            if (isInstanceMemberAccess(symbol)) {\n-                final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);\n-                result = make.Assign(facHandle, make.WithField(make.Select(facHandle, symbol), translate(tree.rhs)).setType(currentClass.type)).setType(currentClass.type);\n-                if (requireRVal) {\n-                    result = make.Select(make.Parens((JCExpression) result).setType(currentClass.type), symbol);\n-                }\n-                return;\n-            }\n-        }\n-        super.visitAssign(tree);\n-    }\n-\n-    @Override\n-    public void visitExec(JCExpressionStatement tree) {\n-        if (transformToValueFactory()) {\n-            tree.expr = translate(tree.expr, false);\n-            result = tree;\n-        } else {\n-            super.visitExec(tree);\n-        }\n-    }\n-\n-    @Override\n-    public void visitIdent(JCIdent ident) {\n-        if (transformToValueFactory()) {\n-            Symbol symbol = ident.sym;\n-            if (isInstanceMemberAccess(symbol)) {\n-                final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);\n-                result = make.Select(facHandle, symbol);\n-                return;\n-            } else if (symbol.name == names._this) {\n-                result = make.Ident(currentMethod.factoryProduct);\n-                return;\n-            }\n-        }\n-        super.visitIdent(ident);\n-    }\n-\n-    @Override\n-    public void visitSelect(JCFieldAccess fieldAccess) {\n-        if (transformToValueFactory()) { \/\/ Qualified this would have been lowered already.\n-            if (fieldAccess.selected.hasTag(IDENT) && ((JCIdent)fieldAccess.selected).name == names._this) {\n-                Symbol symbol = fieldAccess.sym;\n-                if (isInstanceMemberAccess(symbol)) {\n-                    final JCIdent facHandle = make.Ident(currentMethod.factoryProduct);\n-                    result = make.Select(facHandle, symbol);\n-                    return;\n-                }\n-            }\n-        }\n-        \/* If a static member is being selected via a V.ref as a TYP, rewrite\n-           V.ref.member to V.member\n-        *\/\n-        fieldAccess.selected = translate(fieldAccess.selected);\n-        if (fieldAccess.name != names._class) {  \/\/ TODO: this and super ??\n-            Symbol sym = TreeInfo.symbol(fieldAccess);\n-            Symbol sitesym = TreeInfo.symbol(fieldAccess.selected);\n-            Type selectedType = fieldAccess.selected.type;\n-            if (selectedType.isReferenceProjection()) {\n-                switch (sym.kind) {\n-                    case MTH:\n-                    case VAR:\n-                        if (sym.isStatic() && sitesym != null && sitesym.kind == TYP) {\n-                            fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n-                        }\n-                        break;\n-                    case TYP:\n-                        fieldAccess.selected = make.Type(types.erasure(selectedType.valueProjection()));\n-                        break;\n-                }\n-            }\n-        }\n-        result = fieldAccess;\n-    }\n-\n-    \/\/ Translate a reference style instance creation attempt on a value class to a static factory call.\n-    @Override\n-    public void visitNewClass(JCNewClass tree) {\n-        if (tree.clazz.type.isValueClass()) {\n-            \/\/ Enclosing instances or anonymous classes should have been eliminated by now.\n-            Assert.check(tree.encl == null && tree.def == null);\n-            tree.args = translate(tree.args);\n-            Assert.check(tree.def == null);\n-            MethodSymbol sFactory = getValueObjectFactory((MethodSymbol) tree.constructor);\n-            make.at(tree.pos());\n-            JCExpression declClass = make.Type(tree.constructor.owner.type);\n-            JCExpression meth = make.Select(declClass, sFactory);\n-            meth.type = types.erasure(meth.type);\n-            final JCMethodInvocation apply = make.Apply(tree.typeargs, meth, tree.args);\n-            apply.varargsElement = tree.varargsElement;\n-            apply.type = meth.type.getReturnType();\n-            result = apply;\n-            return;\n-        }\n-        super.visitNewClass(tree);\n-    }\n-\n-    \/\/ Utility methods ...\n-    private boolean transformToValueFactory() {\n-        \/\/ We lower any constructors in abstract value classes to <init> methods while a\n-        \/\/ constructor in a concrete value class is lowered into a static value factory method\n-        return currentClass != null && (currentClass.sym.flags() & (ABSTRACT | VALUE_CLASS)) == VALUE_CLASS && currentMethod != null && currentMethod.sym.name == names.vnew;\n-    }\n-\n-    private boolean isInstanceMemberAccess(Symbol symbol) {\n-        return symbol != null\n-                && (symbol.name != names._this && symbol.name != names._super)\n-                && (symbol.kind == VAR || symbol.kind == MTH)\n-                && symbol.owner == currentClass.sym && !symbol.isStatic();\n-    }\n-\n-    private MethodSymbol getValueObjectFactory(MethodSymbol init) {\n-        Assert.check(init.name.equals(names.vnew));\n-        Assert.check(init.owner.type.isValueClass());\n-        MethodSymbol factory = init2factory.get(init);\n-        if (factory != null)\n-            return factory;\n-\n-        MethodType factoryType = new MethodType(init.type.getParameterTypes(),\n-                                                init.owner.type,\n-                                                init.type.getThrownTypes(),\n-                                                init.owner.type.tsym);\n-        factory = new MethodSymbol(init.flags_field | STATIC,\n-                                        names.vnew,\n-                                        factoryType,\n-                                        init.owner);\n-        factory.params = init.params;\n-        \/\/ Re-patch the return type on the erased method type, or code generation will fail\n-        factory.erasure_field = new MethodType(init.erasure(types).getParameterTypes(),\n-                init.owner.type,\n-                init.type.getThrownTypes(),\n-                init.owner.type.tsym);\n-        factory.setAttributes(init);\n-        init2factory.put(init, factory);\n-        return factory;\n-    }\n-\n-    \/** Return the *statement* in the constructor that `chains' to another constructor call either\n-     *  in the same class or its superclass. One MUST exist except for jlO, though may be buried\n-     *  under synthetic initializations.\n-     *\/\n-    private JCExpressionStatement chainedConstructorCall(JCMethodDecl md) {\n-        if (names.isInitOrVNew(md.name) && md.body != null) {\n-            for (JCStatement statement : md.body.stats) {\n-                if (statement.hasTag(EXEC)) {\n-                    JCExpressionStatement exec = (JCExpressionStatement)statement;\n-                    if (exec.expr.hasTag(APPLY)) {\n-                        JCMethodInvocation apply = (JCMethodInvocation)exec.expr;\n-                        Name name = TreeInfo.name(apply.meth);\n-                        if (name == names._super || name == names._this)\n-                            return exec;\n-                    }\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/TransValues.java","additions":0,"deletions":432,"binary":false,"changes":432,"status":"deleted"},{"patch":"@@ -33,1 +33,1 @@\n-import java.util.Collections;\n+import java.util.Comparator;\n@@ -44,0 +44,1 @@\n+import java.util.function.ToIntFunction;\n@@ -1784,1 +1785,1 @@\n-                                names.isInitOrVNew(((JCMethodDecl) t).sym.name) ||\n+                                ((JCMethodDecl) t).sym.name == names.init ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-            return (DeclaredType) new Type.ClassType(outer, targs.toList(), sym, sym.type.getFlavor());\n+            return (DeclaredType) new Type.ClassType(outer, targs.toList(), sym);\n@@ -301,1 +301,1 @@\n-        if (types.asSuper(site.referenceProjectionOrSelf(), sym.getEnclosingElement()) == null)\n+        if (types.asSuper(site, sym.getEnclosingElement()) == null)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;\n@@ -197,1 +198,0 @@\n-        this.allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && fac.options.isSet(\"enablePrimitiveClasses\");\n@@ -222,1 +222,0 @@\n-        this.allowPrimitiveClasses = parser.allowPrimitiveClasses;\n@@ -261,4 +260,0 @@\n-    \/** Switch: are primitive classes allowed in this source level?\n-     *\/\n-     boolean allowPrimitiveClasses;\n-\n@@ -532,16 +527,0 @@\n-    \/** If next input token matches one of the two given tokens, skip it, otherwise report\n-     *  an error.\n-     *\n-     * @return The actual token kind.\n-     *\/\n-    public TokenKind accept2(TokenKind tk1, TokenKind tk2) {\n-        TokenKind returnValue = token.kind;\n-        if (token.kind == tk1 || token.kind == tk2) {\n-            nextToken();\n-        } else {\n-            setErrorEndPos(token.pos);\n-            reportSyntaxError(S.prevToken().endPos, Errors.Expected2(tk1, tk2));\n-        }\n-        return returnValue;\n-    }\n-\n@@ -1539,6 +1518,0 @@\n-                            case DEFAULT:\n-                                if (typeArgs != null) return illegal();\n-                                selectExprMode();\n-                                t = to(F.at(pos).DefaultValue(t));\n-                                nextToken();\n-                                break loop;\n@@ -1610,2 +1583,1 @@\n-                            \/\/is a generic type i.e. A<S>::m or a default value creation of\n-                            \/\/the form ValueType<S>.default\n+                            \/\/is a generic type i.e. A<S>::m\n@@ -1624,6 +1596,0 @@\n-                                if (token.kind == DEFAULT) {\n-                                    t =  toP(F.at(token.pos).DefaultValue(t));\n-                                    nextToken();\n-                                    selectExprMode();\n-                                    return term3Rest(t, typeArgs);\n-                                }\n@@ -1860,2 +1826,1 @@\n-     * method reference or a default value creation that uses a parameterized type\n-     * or a binary expression. To disambiguate, look for a\n+     * method reference or a binary expression. To disambiguate, look for a\n@@ -2472,1 +2437,1 @@\n-            TokenKind selector = accept2(CLASS, DEFAULT);\n+            accept(CLASS);\n@@ -2490,5 +2455,1 @@\n-                if (selector == CLASS) {\n-                    t = toP(F.at(pos).Select(t, names._class));\n-                } else {\n-                    t = toP(F.at(pos).DefaultValue(t));\n-                }\n+                t = toP(F.at(pos).Select(t, names._class));\n@@ -2526,1 +2487,0 @@\n-            \/\/ TODO - will be converted in Attr\n@@ -2615,1 +2575,1 @@\n-            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.VALUE_CLASS | Flags.FINAL);\n+            long badModifiers = mods.flags & ~(Flags.VALUE_CLASS | Flags.FINAL);\n@@ -2740,2 +2700,1 @@\n-        JCNewClass newClass = toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));\n-        return newClass;\n+        return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));\n@@ -2972,1 +2931,1 @@\n-        if ((isPrimitiveModifier() && allowPrimitiveClasses) || (isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n+        if ((isValueModifier()) && allowValueClasses) {\n@@ -3569,4 +3528,0 @@\n-                if (isPrimitiveModifier()) {\n-                    flag = Flags.PRIMITIVE_CLASS;\n-                    break;\n-                }\n@@ -3577,4 +3532,0 @@\n-                if (isIdentityModifier()) {\n-                    flag = Flags.IDENTITY_TYPE;\n-                    break;\n-                }\n@@ -3847,5 +3798,0 @@\n-        if (name == names.primitive) {\n-            if (allowPrimitiveClasses) {\n-                return Source.JDK18;\n-            }\n-        }\n@@ -3859,7 +3805,0 @@\n-        if (name == names.identity) {\n-            if (allowPrimitiveClasses) {\n-                return Source.JDK18;\n-            } else if (shouldWarn) {\n-                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n-            }\n-        }\n@@ -4392,2 +4331,1 @@\n-                \/\/ TODO - specifically for record.\n-                if (names.isInitOrVNew(methDef.name) && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+                if (methDef.name == names.init && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n@@ -4934,26 +4872,0 @@\n-    protected boolean isPrimitiveModifier() {\n-        if (token.kind == IDENTIFIER && token.name() == names.primitive) {\n-            boolean isPrimitiveModifier = false;\n-            Token next = S.token(1);\n-            switch (next.kind) {\n-                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n-                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n-                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n-                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n-                case CLASS: case INTERFACE: case ENUM:\n-                    isPrimitiveModifier = true;\n-                    break;\n-                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive identity || primitive value || new primitive Comparable() {}\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n-                            || next.name() == names.value || (mode & EXPR) != 0)\n-                        isPrimitiveModifier = true;\n-                    break;\n-            }\n-            if (isPrimitiveModifier) {\n-                checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -4972,3 +4884,3 @@\n-                case IDENTIFIER: \/\/ value record R || value value || value identity || value primitive || new value Comparable() {} ??\n-                    if (next.name() == names.record || next.name() == names.value || next.name() == names.identity\n-                            || next.name() == names.primitive || (mode & EXPR) != 0)\n+                case IDENTIFIER: \/\/ value record R || value value || new value Comparable() {} ??\n+                    if (next.name() == names.record || next.name() == names.value\n+                            || (mode & EXPR) != 0)\n@@ -4986,26 +4898,0 @@\n-    protected boolean isIdentityModifier() {\n-        if (token.kind == IDENTIFIER && token.name() == names.identity) {\n-            boolean isIdentityModifier = false;\n-            Token next = S.token(1);\n-            switch (next.kind) {\n-                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n-                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n-                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n-                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n-                case CLASS: case INTERFACE: case ENUM:\n-                    isIdentityModifier = true;\n-                    break;\n-                case IDENTIFIER: \/\/ identity record R || identity primitive || || identity identity || identity value || new identity Comparable() {}\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n-                            || next.name() == names.value || (mode & EXPR) != 0)\n-                        isIdentityModifier = true;\n-                    break;\n-            }\n-            if (isIdentityModifier) {\n-                checkSourceLevel(Feature.VALUE_CLASSES);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -5041,2 +4927,1 @@\n-                        next.name() == names.value ||\n-                        next.name() == names.identity;\n+                        next.name() == names.value;\n@@ -5073,1 +4958,1 @@\n-            if (!isRecord || !names.isInitOrVNew(name) || token.kind == LPAREN) {\n+            if (!isRecord || name != names.init || token.kind == LPAREN) {\n@@ -5529,4 +5414,1 @@\n-        if (feature == Feature.PRIMITIVE_CLASSES && !allowPrimitiveClasses) {\n-            \/\/ primitive classes are special\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n-        } else if (preview.isPreview(feature) && !preview.isEnabled()) {\n+        if (preview.isPreview(feature) && !preview.isEnabled()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":15,"deletions":133,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -1344,1 +1343,1 @@\n-                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs, List.nil(), Flavor.X_Typeof_X);\n+                            cs.type = new ClassType(cs.type.getEnclosingType(), null, cs, List.nil());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -236,3 +236,11 @@\n-# 0: name\n-compiler.err.call.must.be.first.stmt.in.ctor=\\\n-    call to {0} must be first statement in constructor\n+compiler.err.call.must.only.appear.in.ctor=\\\n+    explicit constructor invocation may only appear within a constructor body\n+\n+compiler.err.redundant.superclass.init=\\\n+    redundant explicit constructor invocation\n+\n+compiler.err.ctor.calls.not.allowed.here=\\\n+    explicit constructor invocation not allowed here\n+\n+compiler.err.return.before.superclass.initialized=\\\n+    ''return'' not allowed before explicit constructor invocation\n@@ -282,6 +290,0 @@\n-compiler.misc.value.interface.nonfunctional=\\\n-    since it is a value interface\n-\n-compiler.misc.identity.interface.nonfunctional=\\\n-    since it is an identity interface\n-\n@@ -396,1 +398,1 @@\n-# 0: symbol or string\n+# 0: symbol or name\n@@ -3209,0 +3211,3 @@\n+compiler.misc.feature.super.init=\\\n+    statements before super()\n+\n@@ -3910,2 +3915,2 @@\n-compiler.err.first.statement.must.be.call.to.another.constructor=\\\n-    constructor is not canonical, so its first statement must invoke another constructor of class {0}\n+compiler.err.non.canonical.constructor.invoke.another.constructor=\\\n+    constructor is not canonical, so it must invoke another constructor of class {0}\n@@ -4048,3 +4053,0 @@\n-compiler.misc.feature.primitive.classes=\\\n-    primitive classes\n-\n@@ -4054,9 +4056,0 @@\n-# 0: symbol\n-compiler.err.cyclic.primitive.class.membership=\\\n-    cyclic primitive class membership involving {0}\n-\n-# 0: string (expected version)\n-compiler.err.primitive.classes.not.supported=\\\n-    primitive classes are not supported\\n\\\n-     (use -source {0} or higher to enable primitive classes and pass compiler option: -XDenablePrimitiveClasses)\n-\n@@ -4066,4 +4059,0 @@\n-# 0: type\n-compiler.err.generic.parameterization.with.primitive.class=\\\n-    Inferred type {0} involves generic parameterization by a primitive class\n-\n@@ -4074,8 +4063,0 @@\n-# 0: type, 1: type\n-compiler.err.identity.type.has.value.super.type=\\\n-    The value type {1} cannot be a supertype of the identity type {0}\n-\n-# 0: type, 1: type, 2: type\n-compiler.err.mutually.incompatible.supers=\\\n-    The type {0} has mutually incompatible supertypes: the identity type {1} and the value type {2}\n-\n@@ -4090,46 +4071,0 @@\n-# 0: symbol, 1: message segment\n-compiler.err.abstract.value.class.constructor.cannot.take.arguments=\\\n-    {1} defines a constructor {0} that takes arguments. This is disallowed\n-\n-# 0: symbol, 1: message segment\n-compiler.err.abstract.value.class.constructor.cannot.be.generic=\\\n-    {1} defines a generic constructor {0}. This is disallowed\n-\n-# 0: symbol, 1: message segment\n-compiler.err.abstract.value.class.constructor.cannot.throw=\\\n-    {1} defines a constructor {0} that throws an exception. This is disallowed\n-\n-# 0: symbol, 1: message segment\n-compiler.err.abstract.value.class.constructor.has.weaker.access=\\\n-    {1} defines a constructor {0} with a weaker access privilege than the declaring class. This is disallowed\n-\n-# 0: symbol, 1: message segment\n-compiler.err.instance.field.not.allowed=\\\n-    {1} defines an instance field {0}. This is disallowed\n-\n-# 0: symbol, 1: message segment\n-compiler.err.abstract.value.class.no.arg.constructor.must.be.empty=\\\n-    {1} defines a nonempty no-arg constructor {0}. This is disallowed\n-\n-# 0: message segment\n-compiler.err.abstract.value.class.declares.init.block=\\\n-    {0} declares one or more non-empty instance initializer blocks. This is disallowed.\n-\n-# 0: message segment\n-compiler.err.abstract.value.class.cannot.be.inner=\\\n-    {0} is an inner class. This is disallowed.\n-\n-# 0: symbol, 1: type\n-compiler.misc.superclass.of.value.class=\\\n-    The super class {1} of the value class {0}\n-\n-# 0: symbol\n-compiler.misc.abstract.value.class=\\\n-    The abstract value class {0}\n-\n-compiler.err.projection.cant.be.instantiated=\\\n-    Illegal attempt to instantiate a projection type\n-\n-compiler.err.call.to.super.not.allowed.in.value.ctor=\\\n-    call to super not allowed in value class constructor\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":17,"deletions":82,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -136,4 +136,0 @@\n-        \/** Withfields, of type WithField.\n-         *\/\n-        WITHFIELD,\n-\n@@ -264,4 +260,0 @@\n-        \/** Default values, of type DefaultValueTree.\n-         *\/\n-        DEFAULT_VALUE,\n-\n@@ -896,3 +888,0 @@\n-        \/** nascent value that evolves into the return value for a value factory *\/\n-        public VarSymbol factoryProduct;\n-\n@@ -966,4 +955,0 @@\n-\n-        public boolean isInitOrVNew() {\n-            return name.table.names.isInitOrVNew(name);\n-        }\n@@ -1190,30 +1175,0 @@\n-    \/**\n-     * A withfield expression\n-     *\/\n-    public static class JCWithField extends JCExpression implements WithFieldTree {\n-        public JCExpression field;\n-        public JCExpression value;\n-        protected JCWithField(JCExpression field, JCExpression value) {\n-            this.field = field;\n-            this.value = value;\n-        }\n-        @Override\n-        public void accept(Visitor v) { v.visitWithField(this); }\n-\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() { return Kind.WITH_FIELD; }\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getField() { return field; }\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getValue() { return value; }\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n-            return v.visitWithField(this, d);\n-        }\n-\n-        @Override\n-        public Tag getTag() {\n-            return WITHFIELD;\n-        }\n-    }\n-\n@@ -1427,26 +1382,0 @@\n-    \/**\n-     * A \"Identifier<TA1, TA2>.default\" construction.\n-     *\/\n-    public static class JCDefaultValue extends JCPolyExpression implements DefaultValueTree {\n-        public JCExpression clazz;\n-\n-        protected JCDefaultValue(JCExpression clazz) {\n-            this.clazz = clazz;\n-        }\n-        @Override\n-        public void accept(Visitor v) { v.visitDefaultValue(this); }\n-\n-        @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() { return Kind.DEFAULT_VALUE; }\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public JCExpression getType() { return clazz; }\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public <R,D> R accept(TreeVisitor<R,D> v, D d) {\n-            return v.visitDefaultValue(this, d);\n-        }\n-        @Override\n-        public Tag getTag() {\n-            return DEFAULT_VALUE;\n-        }\n-    }\n-\n@@ -3545,1 +3474,0 @@\n-        JCDefaultValue DefaultValue(JCExpression type);\n@@ -3621,1 +3549,0 @@\n-        public void visitWithField(JCWithField that)         { visitTree(that); }\n@@ -3627,1 +3554,0 @@\n-        public void visitDefaultValue(JCDefaultValue that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -605,1 +605,1 @@\n-            if (tree.isInitOrVNew() &&\n+            if (tree.name == tree.name.table.names.init &&\n@@ -612,1 +612,1 @@\n-            if (tree.isInitOrVNew()) {\n+            if (tree.name == tree.name.table.names.init) {\n@@ -752,9 +752,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        try {\n-            printExpr(tree.clazz, TreeInfo.postfixPrec);\n-            print(\".default\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n@@ -797,12 +788,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        try {\n-            print(\"__WithField(\");\n-            printExpr(tree.field);\n-            print(\", \");\n-            printExpr(tree.value);\n-            print(\")\");\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -202,7 +202,0 @@\n-    @DefinedBy(Api.COMPILER_TREE)\n-    public JCTree visitDefaultValue(DefaultValueTree node, P p) {\n-        JCDefaultValue t = (JCDefaultValue) node;\n-        JCExpression clazz = copy(t.clazz, p);\n-        return M.at(t.pos).DefaultValue(clazz);\n-    }\n-\n@@ -253,2 +246,1 @@\n-        JCIdent ident = M.at(t.pos).Ident(t.name);\n-        return ident;\n+        return M.at(t.pos).Ident(t.name);\n@@ -378,2 +370,1 @@\n-        JCFieldAccess select = M.at(t.pos).Select(selected, t.name);\n-        return select;\n+        return M.at(t.pos).Select(selected, t.name);\n@@ -581,8 +572,0 @@\n-    @DefinedBy(Api.COMPILER_TREE)\n-    public JCTree visitWithField(WithFieldTree node, P p) {\n-        JCWithField t = (JCWithField) node;\n-        JCExpression field = copy(t.field, p);\n-        JCExpression value = copy(t.value, p);\n-        return M.at(t.pos).WithField(field, value);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import java.util.function.Function;\n@@ -84,12 +85,1 @@\n-            return name == name.table.names.init || name == name.table.names.vnew;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/** Is tree a value factory declaration?\n-     *\/\n-    public static boolean isValueFactory(JCTree tree) {\n-        if (tree.hasTag(METHODDEF)) {\n-            Name name = ((JCMethodDecl) tree).name;\n-            return name == name.table.names.vnew;\n+            return name == name.table.names.init;\n@@ -123,1 +113,1 @@\n-            if (isConstructor(l.head) || isValueFactory(l.head)) return true;\n+            if (isConstructor(l.head)) return true;\n@@ -127,22 +117,0 @@\n-    \/** Is there a constructor invocation in the given list of trees?\n-     *  Optionally, check only for no-arg ctor invocation\n-     *\/\n-    public static Name getConstructorInvocationName(List<? extends JCTree> trees, Names names, boolean argsAllowed) {\n-        for (JCTree tree : trees) {\n-            if (tree.hasTag(EXEC)) {\n-                JCExpressionStatement stat = (JCExpressionStatement)tree;\n-                if (stat.expr.hasTag(APPLY)) {\n-                    JCMethodInvocation apply = (JCMethodInvocation)stat.expr;\n-                    if (argsAllowed || apply.args.size() == 0) {\n-                        Name methName = TreeInfo.name(apply.meth);\n-                        if (methName == names._this ||\n-                                methName == names._super) {\n-                            return methName;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return names.empty;\n-    }\n-\n@@ -187,12 +155,0 @@\n-    \/** Is this a call to this or super?\n-     *\/\n-    public static boolean isSelfCall(JCTree tree) {\n-        Name name = calledMethodName(tree);\n-        if (name != null) {\n-            Names names = name.table.names;\n-            return name==names._this || name==names._super;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n@@ -255,2 +211,15 @@\n-    \/** Is this a constructor whose first (non-synthetic) statement is not\n-     *  of the form this(...)?\n+    \/** Is the given method a constructor containing a super() or this() call?\n+      *\/\n+    public static boolean hasAnyConstructorCall(JCMethodDecl tree) {\n+        return hasConstructorCall(tree, null);\n+    }\n+\n+    \/** Is the given method a constructor containing a super() and\/or this() call?\n+      * The \"target\" is either names._this, names._super, or null for either\/both.\n+      *\/\n+    public static boolean hasConstructorCall(JCMethodDecl tree, Name target) {\n+        JCMethodInvocation app = findConstructorCall(tree);\n+        return app != null && (target == null || target == name(app.meth));\n+    }\n+\n+    \/** Find the first super() or init() call in the given constructor.\n@@ -258,22 +227,81 @@\n-    public static boolean isInitialConstructor(JCTree tree) {\n-        JCMethodInvocation app = firstConstructorCall(tree);\n-        if (app == null) return false;\n-        Name meth = name(app.meth);\n-        return meth == null || meth != meth.table.names._this;\n-    }\n-\n-    \/** Return the first call in a constructor definition. *\/\n-    public static JCMethodInvocation firstConstructorCall(JCTree tree) {\n-        if (!tree.hasTag(METHODDEF)) return null;\n-        JCMethodDecl md = (JCMethodDecl) tree;\n-        if (!md.isInitOrVNew()) return null;\n-        if (md.body == null) return null;\n-        List<JCStatement> stats = md.body.stats;\n-        \/\/ Synthetic initializations can appear before the super call.\n-        while (stats.nonEmpty() && isSyntheticInit(stats.head))\n-            stats = stats.tail;\n-        if (stats.isEmpty()) return null;\n-        if (!stats.head.hasTag(EXEC)) return null;\n-        JCExpressionStatement exec = (JCExpressionStatement) stats.head;\n-        if (!exec.expr.hasTag(APPLY)) return null;\n-        return (JCMethodInvocation)exec.expr;\n+    public static JCMethodInvocation findConstructorCall(JCMethodDecl md) {\n+        if (!TreeInfo.isConstructor(md) || md.body == null)\n+            return null;\n+        return new ConstructorCallFinder(md.name.table.names).find(md).head;\n+    }\n+\n+    \/** Finds all calls to this() and\/or super() in a given constructor.\n+     *  We can't assume they will be \"top level\" statements, because\n+     *  some synthetic calls to super() are added inside { } blocks.\n+     *  So we must recurse through the method's entire syntax tree.\n+     *\/\n+    private static class ConstructorCallFinder extends TreeScanner {\n+\n+        final ListBuffer<JCMethodInvocation> calls = new ListBuffer<>();\n+        final Names names;\n+\n+        ConstructorCallFinder(Names names) {\n+            this.names = names;\n+        }\n+\n+        List<JCMethodInvocation> find(JCMethodDecl meth) {\n+            scan(meth);\n+            return calls.toList();\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation invoke) {\n+            Name name = TreeInfo.name(invoke.meth);\n+            if ((name == names._this || name == names._super))\n+                calls.append(invoke);\n+            super.visitApply(invoke);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            \/\/ don't descend any further\n+        }\n+    }\n+\n+    \/** Finds super() invocations and translates them using the given mapping.\n+     *\/\n+    public static void mapSuperCalls(JCBlock block, Function<? super JCExpressionStatement, ? extends JCStatement> mapper) {\n+        block.stats = block.stats.map(new TreeInfo.SuperCallTranslator(mapper)::translate);\n+    }\n+\n+    \/** Finds all super() invocations and translates them somehow.\n+     *\/\n+    private static class SuperCallTranslator extends TreeTranslator {\n+\n+        final Function<? super JCExpressionStatement, ? extends JCStatement> translator;\n+\n+        \/** Constructor.\n+         *\n+         * @param translator translates super() invocations, returning replacement statement or null for no change\n+         *\/\n+        SuperCallTranslator(Function<? super JCExpressionStatement, ? extends JCStatement> translator) {\n+            this.translator = translator;\n+        }\n+\n+        \/\/ Because it returns void, anywhere super() can legally appear must be a location where a JCStatement\n+        \/\/ could also appear, so it's OK that we are replacing a JCExpressionStatement with a JCStatement here.\n+        @Override\n+        public void visitExec(JCExpressionStatement stat) {\n+            if (!TreeInfo.isSuperCall(stat) || (result = this.translator.apply(stat)) == null)\n+                super.visitExec(stat);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            \/\/ don't descend any further\n+        }\n@@ -505,2 +533,0 @@\n-            case DEFAULT_VALUE:\n-                return getStartPos(((JCDefaultValue) tree).clazz);\n@@ -662,2 +688,0 @@\n-            case WITHFIELD:\n-                return getEndPos(((JCWithField) tree).value, endPosTable);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":99,"deletions":75,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -269,6 +269,0 @@\n-    public JCWithField WithField(JCExpression field, JCExpression value) {\n-        JCWithField tree = new JCWithField(field, value);\n-        tree.pos = pos;\n-        return tree;\n-    }\n-\n@@ -310,6 +304,0 @@\n-    public JCDefaultValue DefaultValue(JCExpression type) {\n-        JCDefaultValue tree = new JCDefaultValue(type);\n-        tree.pos = pos;\n-        return tree;\n-    }\n-\n@@ -877,22 +865,7 @@\n-                if (t.isReferenceProjection()) {\n-                    \/\/ For parameterized types, we want V.ref<A1 ... An> not V<A1 ... An>.ref\n-                    JCExpression vp = Type(t.valueProjection());\n-                    if (vp.hasTag(Tag.TYPEAPPLY)) {\n-                        \/\/ vp now is V<A1 ... An>, build V.ref<A1 ... An>\n-                        JCFieldAccess f = Select(((JCTypeApply) vp).clazz, t.tsym);\n-                        f.name = names.ref;\n-                        tp = TypeApply(f, ((JCTypeApply) vp).arguments);\n-                    } else {\n-                        JCFieldAccess f = Select(vp, t.tsym);\n-                        f.name = names.ref;\n-                        tp = f;\n-                    }\n-                } else {\n-                    Type outer = t.getEnclosingType();\n-                    JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n-                            ? Select(Type(outer), t.tsym)\n-                            : QualIdent(t.tsym);\n-                    tp = t.getTypeArguments().isEmpty()\n-                            ? clazz\n-                            : TypeApply(clazz, Types(t.getTypeArguments()));\n-                }\n+                Type outer = t.getEnclosingType();\n+                JCExpression clazz = outer.hasTag(CLASS) && t.tsym.owner.kind == TYP\n+                        ? Select(Type(outer), t.tsym)\n+                        : QualIdent(t.tsym);\n+                tp = t.getTypeArguments().isEmpty()\n+                        ? clazz\n+                        : TypeApply(clazz, Types(t.getTypeArguments()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":7,"deletions":34,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -158,5 +158,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        scan(tree.field);\n-        scan(tree.value);\n-    }\n-\n@@ -191,4 +186,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        scan(tree.clazz);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -183,6 +183,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        tree.field = translate(tree.field);\n-        tree.value = translate(tree.value);\n-        result = tree;\n-    }\n-\n@@ -405,5 +399,0 @@\n-    public void visitDefaultValue(JCDefaultValue tree) {\n-        tree.clazz = translate(tree.clazz);\n-        result = tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-    public final Name _default;\n@@ -96,1 +95,0 @@\n-    public final Name vnew;\n@@ -108,2 +106,0 @@\n-    public final Name primitive;\n-    public final Name identity;\n@@ -217,2 +213,0 @@\n-    public final Name ref;\n-    public final Name val;\n@@ -268,1 +262,0 @@\n-        _default = fromString(\"default\");\n@@ -304,1 +297,0 @@\n-        vnew = fromString(\"<vnew>\");\n@@ -316,2 +308,0 @@\n-        primitive = fromString(\"primitive\");\n-        identity = fromString(\"identity\");\n@@ -423,1 +413,0 @@\n-        \/\/ primitive classes\n@@ -425,2 +414,0 @@\n-        ref = fromString(\"ref\");\n-        val = fromString(\"val\");\n@@ -478,2 +465,2 @@\n-    public boolean isInitOrVNew(Name name) {\n-        return name == init || name == vnew;\n+    public boolean isInit(Name name) {\n+        return name == init;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -432,1 +432,3 @@\n-                String ms = (s.isInitOrVNew()) ? ownerName : s.name.toString();\n+                String ms = (s.name == s.name.table.names.init)\n+                    ? ownerName\n+                    : s.name.toString();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n@@ -431,1 +432,3 @@\n-                                     .map(TreeInfo::firstConstructorCall)\n+                                     .filter(JCMethodDecl.class::isInstance)\n+                                     .map(JCMethodDecl.class::cast)\n+                                     .map(TreeInfo::findConstructorCall)\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/ExpressionToTypeInfo.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8308590\n+ * @summary  value classes\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestValueClasses\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestValueClasses extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestValueClasses();\n+        tester.runTests();\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testValueClassModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"package p; public value class ValueClass {}\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/ValueClass.html\", true,\n+                \"\"\"\n+                <div class=\"type-signature\"><span class=\"modifiers\">public value final class <\/span><span class=\"element-name type-name-label\">ValueClass<\/span>\n+                \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testValueClasses\/TestValueClasses.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/jdk\/jshell\/Test8294583.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/jdk\/jshell\/Test8296012.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore 8316628\n","filename":"test\/langtools\/jdk\/jshell\/ToolEnablePreviewTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -115,0 +115,4 @@\n+    protected void assertOKWithWarning(String warning, int numberOfTimes, String... constructs) {\n+        assertCompile(expandMarkers(constructs), () -> assertCompileSucceededWithWarning(warning, numberOfTimes), false);\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/CompilationTestCase.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,0 +87,6 @@\n+    public boolean containsWarningKey(String key, int numberOfWarnings) {\n+        return diags.stream()\n+                .filter(d -> d.getKind() == Diagnostic.Kind.WARNING || d.getKind() == Diagnostic.Kind.MANDATORY_WARNING)\n+                .filter(d -> d.getCode().equals(key)).count() == numberOfWarnings;\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/Diagnostics.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -157,0 +157,8 @@\n+    protected void assertCompileSucceededWithWarning(String warning, int numberOfWarnings) {\n+        if (diags.errorsFound())\n+            fail(\"Expected successful compilation\");\n+        if (!diags.containsWarningKey(warning, numberOfWarnings)) {\n+            fail(String.format(\"Expected compilation warning with %s, found %s\", warning, diags.keys()));\n+        }\n+    }\n+\n","filename":"test\/langtools\/lib\/combo\/tools\/javac\/combo\/JavacTemplateTestBase.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-AnonymousInSuperCallNegTest.java:23:49: compiler.err.cant.ref.before.ctor.called: x\n+AnonymousInSuperCallNegTest.java:23:49: compiler.err.no.encl.instance.of.type.in.scope: AnonymousInSuperCallNegTest.JavacBug\n","filename":"test\/langtools\/tools\/javac\/AnonymousClass\/AnonymousInSuperCallNegTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n---- IDENTITY\n+---\n@@ -5,1 +5,1 @@\n---- IDENTITY\n+---\n@@ -8,1 +8,1 @@\n---- IDENTITY\n+---\n@@ -10,1 +10,1 @@\n---- STATIC IDENTITY\n+--- STATIC\n@@ -13,1 +13,1 @@\n---- IDENTITY\n+---\n@@ -15,1 +15,1 @@\n---- PRIVATE IDENTITY\n+--- PRIVATE\n@@ -18,1 +18,1 @@\n---- IDENTITY\n+---\n@@ -20,1 +20,1 @@\n---- PRIVATE STATIC IDENTITY\n+--- PRIVATE STATIC\n@@ -23,1 +23,1 @@\n---- FINAL IDENTITY\n+--- FINAL\n@@ -25,1 +25,1 @@\n---- FINAL IDENTITY\n+--- FINAL\n@@ -28,1 +28,1 @@\n---- FINAL IDENTITY\n+--- FINAL\n@@ -30,1 +30,1 @@\n---- STATIC FINAL IDENTITY\n+--- STATIC FINAL\n@@ -33,1 +33,1 @@\n---- FINAL IDENTITY\n+--- FINAL\n@@ -35,1 +35,1 @@\n---- PRIVATE FINAL IDENTITY\n+--- PRIVATE FINAL\n@@ -38,1 +38,1 @@\n---- FINAL IDENTITY\n+--- FINAL\n@@ -40,1 +40,1 @@\n---- PRIVATE STATIC FINAL IDENTITY\n+--- PRIVATE STATIC FINAL\n@@ -43,1 +43,1 @@\n---- IDENTITY ABSTRACT\n+--- ABSTRACT\n@@ -45,1 +45,1 @@\n---- IDENTITY ABSTRACT\n+--- ABSTRACT\n@@ -53,1 +53,1 @@\n---- IDENTITY ABSTRACT\n+--- ABSTRACT\n@@ -55,1 +55,1 @@\n---- PRIVATE IDENTITY ABSTRACT\n+--- PRIVATE ABSTRACT\n@@ -63,1 +63,1 @@\n---- PUBLIC IDENTITY\n+--- PUBLIC\n@@ -65,1 +65,1 @@\n---- PROTECTED IDENTITY\n+--- PROTECTED\n@@ -68,1 +68,1 @@\n---- PUBLIC IDENTITY\n+--- PUBLIC\n@@ -70,1 +70,1 @@\n---- PROTECTED STATIC IDENTITY\n+--- PROTECTED STATIC\n@@ -73,1 +73,1 @@\n---- PUBLIC IDENTITY\n+--- PUBLIC\n@@ -75,1 +75,1 @@\n---- PUBLIC IDENTITY\n+--- PUBLIC\n@@ -78,1 +78,1 @@\n---- PUBLIC IDENTITY\n+--- PUBLIC\n@@ -80,1 +80,1 @@\n---- PUBLIC STATIC IDENTITY\n+--- PUBLIC STATIC\n@@ -83,1 +83,1 @@\n---- PUBLIC FINAL IDENTITY\n+--- PUBLIC FINAL\n@@ -85,1 +85,1 @@\n---- PROTECTED FINAL IDENTITY\n+--- PROTECTED FINAL\n@@ -88,1 +88,1 @@\n---- PUBLIC FINAL IDENTITY\n+--- PUBLIC FINAL\n@@ -90,1 +90,1 @@\n---- PROTECTED STATIC FINAL IDENTITY\n+--- PROTECTED STATIC FINAL\n@@ -93,1 +93,1 @@\n---- PUBLIC FINAL IDENTITY\n+--- PUBLIC FINAL\n@@ -95,1 +95,1 @@\n---- PUBLIC FINAL IDENTITY\n+--- PUBLIC FINAL\n@@ -98,1 +98,1 @@\n---- PUBLIC FINAL IDENTITY\n+--- PUBLIC FINAL\n@@ -100,1 +100,1 @@\n---- PUBLIC STATIC FINAL IDENTITY\n+--- PUBLIC STATIC FINAL\n@@ -103,1 +103,1 @@\n---- PUBLIC IDENTITY ABSTRACT\n+--- PUBLIC ABSTRACT\n@@ -105,1 +105,1 @@\n---- PROTECTED IDENTITY ABSTRACT\n+--- PROTECTED ABSTRACT\n@@ -113,1 +113,1 @@\n---- PUBLIC IDENTITY ABSTRACT\n+--- PUBLIC ABSTRACT\n@@ -115,1 +115,1 @@\n---- PUBLIC IDENTITY ABSTRACT\n+--- PUBLIC ABSTRACT\n@@ -203,1 +203,1 @@\n---- IDENTITY\n+---\n@@ -239,1 +239,1 @@\n---- PUBLIC IDENTITY ABSTRACT\n+--- PUBLIC ABSTRACT\n@@ -243,1 +243,1 @@\n---- PROTECTED IDENTITY ABSTRACT\n+--- PROTECTED ABSTRACT\n@@ -245,1 +245,1 @@\n---- PUBLIC STATIC FINAL IDENTITY\n+--- PUBLIC STATIC FINAL\n@@ -247,1 +247,1 @@\n---- PUBLIC FINAL IDENTITY\n+--- PUBLIC FINAL\n@@ -249,1 +249,1 @@\n---- PROTECTED STATIC FINAL IDENTITY\n+--- PROTECTED STATIC FINAL\n@@ -251,1 +251,1 @@\n---- PROTECTED FINAL IDENTITY\n+--- PROTECTED FINAL\n@@ -253,1 +253,1 @@\n---- PUBLIC STATIC IDENTITY\n+--- PUBLIC STATIC\n@@ -255,1 +255,1 @@\n---- PUBLIC IDENTITY\n+--- PUBLIC\n@@ -257,1 +257,1 @@\n---- PROTECTED STATIC IDENTITY\n+--- PROTECTED STATIC\n@@ -259,1 +259,1 @@\n---- PROTECTED IDENTITY\n+--- PROTECTED\n@@ -263,1 +263,1 @@\n---- PRIVATE IDENTITY ABSTRACT\n+--- PRIVATE ABSTRACT\n@@ -267,1 +267,1 @@\n---- IDENTITY ABSTRACT\n+--- ABSTRACT\n@@ -269,1 +269,1 @@\n---- PRIVATE STATIC FINAL IDENTITY\n+--- PRIVATE STATIC FINAL\n@@ -271,1 +271,1 @@\n---- PRIVATE FINAL IDENTITY\n+--- PRIVATE FINAL\n@@ -273,1 +273,1 @@\n---- STATIC FINAL IDENTITY\n+--- STATIC FINAL\n@@ -275,1 +275,1 @@\n---- FINAL IDENTITY\n+--- FINAL\n@@ -277,1 +277,1 @@\n---- PRIVATE STATIC IDENTITY\n+--- PRIVATE STATIC\n@@ -279,1 +279,1 @@\n---- PRIVATE IDENTITY\n+--- PRIVATE\n@@ -281,1 +281,1 @@\n---- STATIC IDENTITY\n+--- STATIC\n@@ -283,1 +283,1 @@\n---- IDENTITY\n+---\n@@ -286,1 +286,1 @@\n---- PUBLIC IDENTITY\n+--- PUBLIC\n@@ -288,1 +288,1 @@\n---- PUBLIC STATIC IDENTITY\n+--- PUBLIC STATIC\n@@ -291,1 +291,1 @@\n---- PUBLIC IDENTITY\n+--- PUBLIC\n@@ -293,1 +293,1 @@\n---- PUBLIC STATIC IDENTITY\n+--- PUBLIC STATIC\n@@ -296,1 +296,1 @@\n---- PUBLIC IDENTITY\n+--- PUBLIC\n@@ -298,1 +298,1 @@\n---- PUBLIC STATIC IDENTITY\n+--- PUBLIC STATIC\n@@ -301,1 +301,1 @@\n---- PUBLIC IDENTITY\n+--- PUBLIC\n@@ -303,1 +303,1 @@\n---- PUBLIC STATIC IDENTITY\n+--- PUBLIC STATIC\n@@ -306,1 +306,1 @@\n---- PUBLIC FINAL IDENTITY\n+--- PUBLIC FINAL\n@@ -308,1 +308,1 @@\n---- PUBLIC STATIC FINAL IDENTITY\n+--- PUBLIC STATIC FINAL\n@@ -311,1 +311,1 @@\n---- PUBLIC FINAL IDENTITY\n+--- PUBLIC FINAL\n@@ -313,1 +313,1 @@\n---- PUBLIC STATIC FINAL IDENTITY\n+--- PUBLIC STATIC FINAL\n@@ -316,1 +316,1 @@\n---- PUBLIC FINAL IDENTITY\n+--- PUBLIC FINAL\n@@ -318,1 +318,1 @@\n---- PUBLIC STATIC FINAL IDENTITY\n+--- PUBLIC STATIC FINAL\n@@ -321,1 +321,1 @@\n---- PUBLIC FINAL IDENTITY\n+--- PUBLIC FINAL\n@@ -323,1 +323,1 @@\n---- PUBLIC STATIC FINAL IDENTITY\n+--- PUBLIC STATIC FINAL\n@@ -412,1 +412,1 @@\n---- PUBLIC STATIC FINAL IDENTITY\n+--- PUBLIC STATIC FINAL\n@@ -414,1 +414,1 @@\n---- PUBLIC STATIC FINAL IDENTITY\n+--- PUBLIC STATIC FINAL\n@@ -416,1 +416,1 @@\n---- PUBLIC STATIC FINAL IDENTITY\n+--- PUBLIC STATIC FINAL\n@@ -418,1 +418,1 @@\n---- PUBLIC STATIC FINAL IDENTITY\n+--- PUBLIC STATIC FINAL\n@@ -420,1 +420,1 @@\n---- PUBLIC STATIC IDENTITY\n+--- PUBLIC STATIC\n@@ -422,1 +422,1 @@\n---- PUBLIC STATIC IDENTITY\n+--- PUBLIC STATIC\n@@ -424,1 +424,1 @@\n---- PUBLIC STATIC IDENTITY\n+--- PUBLIC STATIC\n@@ -426,1 +426,1 @@\n---- PUBLIC STATIC IDENTITY\n+--- PUBLIC STATIC\n","filename":"test\/langtools\/tools\/javac\/ClassFileModifiers\/ClassModifiers.out","additions":85,"deletions":85,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n---- IDENTITY\n+---\n@@ -11,1 +11,1 @@\n---- PUBLIC FINAL IDENTITY\n+--- PUBLIC FINAL\n@@ -20,1 +20,1 @@\n---- IDENTITY\n+---\n@@ -25,1 +25,1 @@\n---- FINAL IDENTITY\n+--- FINAL\n@@ -34,1 +34,1 @@\n---- IDENTITY\n+---\n","filename":"test\/langtools\/tools\/javac\/ClassFileModifiers\/MemberModifiers.out","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8194743\n+ * @summary Permit additional statements before this\/super in constructors\n+ * @compile\/fail\/ref=SuperInitFails.out -XDrawDiagnostics SuperInitFails.java\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+public class SuperInitFails extends AtomicReference<Object> implements Iterable<Object> {\n+\n+    private int x;\n+\n+\/\/\/ GOOD EXAMPLES\n+\n+    public SuperInitFails() {           \/\/ this should be OK\n+    }\n+\n+    public SuperInitFails(Object x) {\n+        this.x = x.hashCode();          \/\/ this should be OK\n+    }\n+\n+    public SuperInitFails(byte x) {\n+        super();                        \/\/ this should be OK\n+    }\n+\n+    public SuperInitFails(char x) {\n+        this((int)x);                   \/\/ this should be OK\n+    }\n+\n+\/\/\/ FAIL EXAMPLES\n+\n+    {\n+        this(1);                        \/\/ this should FAIL\n+    }\n+\n+    {\n+        super();                        \/\/ this should FAIL\n+    }\n+\n+    void normalMethod1() {\n+        super();                        \/\/ this should FAIL\n+    }\n+\n+    void normalMethod2() {\n+        this();                         \/\/ this should FAIL\n+    }\n+\n+    void normalMethod3() {\n+        Runnable r = () -> super();     \/\/ this should FAIL\n+    }\n+\n+    void normalMethod4() {\n+        Runnable r = () -> this();      \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(short x) {\n+        hashCode();                     \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(float x) {\n+        this.hashCode();                \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(int x) {\n+        super.hashCode();               \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(long x) {\n+        SuperInitFails.this.hashCode();      \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(double x) {\n+        SuperInitFails.super.hashCode();     \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(byte[] x) {\n+        {\n+            super();                    \/\/ this should FAIL\n+        }\n+    }\n+\n+    public SuperInitFails(char[] x) {\n+        if (x.length == 0)\n+            return;                     \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(short[] x) {\n+        this.x = x.length;              \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(float[] x) {\n+        System.identityHashCode(this);  \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(int[] x) {\n+        this(this);                     \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(long[] x) {\n+        this(Object.this);              \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(double[] x) {\n+        Iterable.super.spliterator();   \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(byte[][] x) {\n+        super(new Object() {\n+            {\n+                super();                \/\/ this should FAIL\n+            }\n+        });\n+    }\n+\n+    public SuperInitFails(char[][] x) {\n+        new Inner1();                   \/\/ this should FAIL\n+        super();\n+    }\n+\n+    class Inner1 {\n+    }\n+\n+    record Record1(int value) {\n+        Record1(float x) {              \/\/ this should FAIL\n+        }\n+    }\n+\n+    record Record2(int value) {\n+        Record2(float x) {              \/\/ this should FAIL\n+            super();\n+        }\n+    }\n+\n+    @Override\n+    public java.util.Iterator<Object> iterator() {\n+        return null;\n+    }\n+\n+    public SuperInitFails(short[][] x) {\n+        class Foo {\n+            Foo() {\n+                SuperInitFails.this.hashCode();\n+            }\n+        };\n+        new Foo();                      \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(float[][] x) {\n+        Runnable r = () -> {\n+            super();                    \/\/ this should FAIL\n+        };\n+    }\n+\n+    public SuperInitFails(int[][] z) {\n+        super((Runnable)() -> x);       \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(long[][] z) {\n+        super(new Inner1());            \/\/ this should FAIL\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+SuperInitFails.java:57:9: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:62:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:67:9: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:72:23: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:77:23: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:94:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:99:33: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:104:14: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:108:20: compiler.err.not.encl.class: java.lang.Object\n+SuperInitFails.java:112:17: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:119:22: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:125:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:133:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record1\n+SuperInitFails.java:138:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record2\n+SuperInitFails.java:154:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:165:31: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:169:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:33:13: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:37:14: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:41:14: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:45:13: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:49:33: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:53:32: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:83:18: compiler.err.ctor.calls.not.allowed.here\n+SuperInitFails.java:89:13: compiler.err.return.before.superclass.initialized\n+SuperInitFails.java:160:18: compiler.err.ctor.calls.not.allowed.here\n+- compiler.note.preview.filename: SuperInitFails.java, DEFAULT\n+- compiler.note.preview.recompile\n+26 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,481 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8194743\n+ * @summary Test valid placements of super()\/this() in constructors\n+ * @enablePreview\n+ * @ignore fails at execution time because of Optional\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class SuperInitGood {\n+\n+    SuperInitGood(Object obj) {\n+    }\n+\n+    SuperInitGood(int x) {\n+    }\n+\n+    \/\/ Default constructor provided by compiler\n+    static class Test0 {\n+    }\n+\n+    \/\/ No explicit calls to this()\/super()\n+    static class Test1 {\n+        Test1() {\n+        }\n+        Test1(int a) {\n+            this.hashCode();\n+        }\n+    }\n+\n+    \/\/ Explicit calls to this()\/super()\n+    static class Test2<T> {\n+        static int i;\n+        Test2() {\n+            this(0);\n+        }\n+        Test2(int i) {\n+            Test2.i = i;\n+            super();\n+        }\n+        Test2(T obj) {\n+            this(java.util.Objects.hashCode(obj));\n+        }\n+        public T get() {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Explicit this()\/super() with stuff in front\n+    static class Test3 {\n+        int x;\n+        final int y;\n+        final int z;\n+\n+        Test3() {\n+            new Object().hashCode();\n+            new Object().hashCode();\n+            super();\n+            this.x = new Object().hashCode();\n+            this.y = new Object().hashCode() % 17;\n+            this.z = this.x + this.y;\n+        }\n+    }\n+\n+    \/\/ Reference within constructor to outer class that's also my superclass\n+    class Test5 extends SuperInitGood {\n+        Test5(Object obj) {\n+            if (obj == null)\n+                throw new IllegalArgumentException();\n+            super(SuperInitGood.this);      \/\/ NOT a 'this' reference\n+        }\n+    }\n+\n+    \/\/ Initialization blocks\n+    class Test6 {\n+        final long startTime;\n+        final int x;\n+        {\n+            this.x = 12;\n+        }\n+        Test6() {\n+            long now = System.nanoTime();\n+            long then = now + 1000000L;\n+            while (System.nanoTime() < then) {\n+                try {\n+                    Thread.sleep(1);\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    break;\n+                }\n+            }\n+            super();\n+            this.startTime = now;\n+        }\n+    }\n+\n+    \/\/ Mix up inner classes, proxies, and super() calls\n+    \/\/ Copied mostly from UnverifiableInitForNestedLocalClassTest.java\n+    public static void test7(final String arg) {\n+        final String inlined = \" inlined \";\n+        class LocalClass {\n+            String m() {\n+                return \"LocalClass \" + arg + inlined;\n+            }\n+\n+            class SubClass extends LocalClass {\n+                @Override\n+                String m() {\n+                    return \"SubClass \" + arg + inlined;\n+                }\n+            }\n+\n+            class SubSubClass extends SubClass {\n+                @Override\n+                String m() {\n+                    return \"SubSubClass \" + arg + inlined;\n+                }\n+            }\n+\n+            class AnotherLocal {\n+                class AnotherSub extends LocalClass {\n+                    AnotherSub() {\n+                    }\n+                    AnotherSub(int x) {\n+                        this((char)x);\n+                    }\n+                    AnotherSub(char y) {\n+                        super();\n+                    }\n+                    @Override\n+                    String m() {\n+                        return \"AnotherSub \" + arg + inlined;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Anonymous inner class\n+    public static void test8() {\n+        new Test2<Byte>(null) {\n+            @Override\n+            public Byte get() {\n+                return (byte)-1;\n+            }\n+        };\n+    }\n+\n+    \/\/ Qualified super() invocation\n+    public static class Test9 extends Test5 {\n+\n+        public Test9(SuperInitGood implicit, Object obj) {\n+            obj.hashCode();\n+            implicit.super(obj);\n+        }\n+    }\n+\n+    \/\/ Copied from WhichImplicitThis6\n+    public static class Test10 {\n+        private int i;\n+        public Test10(int i) {}\n+        public class Sub extends Test10 {\n+            public Sub() {\n+                super(i); \/\/ i is not inherited, so it is the enclosing i\n+            }\n+        }\n+    }\n+\n+    \/\/ Two constructors where only one invokes super()\n+    public static class Test11 {\n+        public Test11() {\n+        }\n+        public Test11(int x) {\n+            super();\n+        }\n+    }\n+\n+    \/\/ Nested version of the previous test\n+    public static class Test12 {\n+        Test12() {\n+            class Sub {\n+                public Sub() {\n+                }\n+                public Sub(int j) {\n+                    super();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Nested super()'s requiring initialization code appended\n+    public static class Test13 extends SuperInitGood {\n+        final int x = new Object().hashCode();\n+        Test13() {\n+            super(new Object() {\n+                public void foo() {\n+                    class Bar {\n+                        final int y = new Object().hashCode();\n+                        Bar() {\n+                            super();\n+                        }\n+                        Bar(int ignored) {\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    \/\/ Initializer in initializer block\n+    public static class Test14 {\n+        final int x;                \/\/ initialized in constructor\n+        final int y;                \/\/ initialized in initialization block\n+        final int z = 13;           \/\/ initialized with intializer value\n+        public Test14() {\n+            this(0);\n+        }\n+        public Test14(boolean z) {\n+            this.x = z ? 1 : 0;\n+        }\n+        public Test14(int x) {\n+            super();\n+            this.x = x;\n+        }\n+        {\n+            this.y = -1;\n+        }\n+    }\n+\n+    \/\/ Qualified super() invocation with superclass instance\n+    public static class Test15 {\n+\n+        final String name;\n+\n+        public Test15(String name) {\n+            this.name = name;\n+        }\n+\n+        public class Test15b extends Test15 {\n+\n+            public Test15b(String name) {\n+                super(name);\n+            }\n+\n+            public String getName() {\n+                return Test15.this.name;\n+            }\n+        }\n+    }\n+\n+    public static class Test15c extends Test15.Test15b {\n+        public Test15c(Test15 a, String name) {\n+            a.super(name);\n+        }\n+    }\n+\n+    \/\/ Mixing up outer instances, proxies, and initializers\n+    public static class Test16 {\n+\n+        final String x = String.valueOf(new Object().hashCode());\n+\n+        public void run() {\n+\n+            final String y = String.valueOf(new Object().hashCode());\n+\n+            class Sub {\n+\n+                final String z;\n+\n+                Sub(String z, int ignored) {\n+                    this(z, (float)ignored);\n+                }\n+\n+                Sub(String z, float ignored) {\n+                    this.z = z;\n+                }\n+\n+                Sub(String z, byte ignored) {\n+                    super();\n+                    this.z = z;\n+                }\n+\n+                Sub(String z, char ignored) {\n+                    this(z, (int)ignored);\n+                }\n+\n+                String x() {\n+                    return x;\n+                }\n+\n+                String y() {\n+                    return y;\n+                }\n+\n+                String z() {\n+                    return z;\n+                }\n+            }\n+\n+            final String z = String.valueOf(new Object().hashCode());\n+\n+            final Sub[] subs = new Sub[] {\n+                new Sub(z, 1),\n+                new Sub(z, -1),\n+                new Sub(z, (float)0),\n+                new Sub(z, (byte)0),\n+                new Sub(z, (char)0)\n+            };\n+\n+            for (int i = 0; i < subs.length; i++) {\n+                \/\/System.err.println(\"i = \" + i);\n+                final Sub sub = subs[i];\n+                final String subx = sub.x();\n+                final String suby = sub.y();\n+                final String subz = sub.z();\n+                if (!x.equals(subx))\n+                    throw new RuntimeException(\"x=\" + x + \" but sub[\" + i + \"].x()=\" + subx);\n+                if (!y.equals(suby))\n+                    throw new RuntimeException(\"y=\" + y + \" but sub[\" + i + \"].y()=\" + suby);\n+                if (!z.equals(subz))\n+                    throw new RuntimeException(\"z=\" + z + \" but sub[\" + i + \"].z()=\" + subz);\n+            }\n+        }\n+    }\n+\n+    \/\/ Records\n+    public class Test17 {\n+\n+        record Rectangle(float length, float width) { }\n+\n+        record StringHolder(String string) {\n+            StringHolder {\n+                java.util.Objects.requireNonNull(string);\n+            }\n+        }\n+\n+        record ValueHolder(int value) {\n+            ValueHolder(float x) {\n+                if (Float.isNaN(x))\n+                    throw new IllegalArgumentException();\n+                this((int)x);\n+            }\n+        }\n+    }\n+\n+    \/\/ Exceptions thrown by initializer block\n+    public static class Test18 extends AtomicReference<Object> {\n+\n+        {\n+            if ((this.get().hashCode() % 3) == 0)\n+                throw new MyException();\n+        }\n+\n+        public Test18(Object obj) throws MyException {\n+            super(obj);\n+        }\n+\n+        public Test18(boolean fail) throws MyException {\n+            Object obj;\n+            for (obj = new Object(); true; obj = new Object()) {\n+                if (((obj.hashCode() % 3) == 0) != fail)\n+                    continue;\n+                break;\n+            }\n+            this(obj);\n+        }\n+\n+        public static class MyException extends Exception {\n+        }\n+    }\n+\n+    \/\/ super()\/this() within outer try block but inside inner class\n+    public static class Test19 {\n+        public Test19(int x) {\n+            try {\n+                new Test1(x) {\n+                    @Override\n+                    public int hashCode() {\n+                        return x ^ super.hashCode();\n+                    }\n+                };\n+            } catch (StackOverflowError e) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    \/\/ local class declared before super(), but not used until after super()\n+    public static class Test20 {\n+        public Test20() {\n+            class Foo {\n+                Foo() {\n+                    Test20.this.hashCode();\n+                }\n+            }\n+            super();\n+            new Foo();\n+        }\n+    }\n+\n+    \/\/ local class inside super() parameter list\n+    public static class Test21 extends AtomicReference<Object> {\n+        private int x;\n+        public Test21() {\n+            super(switch (\"foo\".hashCode()) {\n+                default -> {\n+                    class Nested {{ System.out.println(x); }}       \/\/ class is NOT instantiated - OK\n+                    yield \"bar\";\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new Test0();\n+        new Test1();\n+        new Test1(7);\n+        new Test2<Byte>();\n+        new Test2<>(args);\n+        new Test3();\n+        new SuperInitGood(3).new Test5(3);\n+        new SuperInitGood(3).new Test6();\n+        SuperInitGood.test7(\"foo\");\n+        SuperInitGood.test8();\n+        new Test9(new SuperInitGood(5), \"abc\");\n+        new Test10(7);\n+        new Test11(9);\n+        new Test12();\n+        new Test13();\n+        Test14 t14 = new Test14();\n+        assert t14.x == 0 && t14.y == -1 && t14.z == 13;\n+        t14 = new Test14(7);\n+        assert t14.x == 7 && t14.y == -1 && t14.z == 13;\n+        new Test15c(new Test15(\"foo\"), \"bar\");\n+        new Test16().run();\n+        new Test17.StringHolder(\"foo\");\n+        try {\n+            new Test17.StringHolder(null);\n+            throw new Error();\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            new Test18(true);\n+            assert false : \"expected exception\";\n+        } catch (Test18.MyException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            new Test18(false);\n+        } catch (Test18.MyException e) {\n+            assert false : \"unexpected exception: \" + e;\n+        }\n+        new Test19(123);\n+        new Test20();\n+        new Test21();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitGood.java","additions":481,"deletions":0,"binary":false,"changes":481,"status":"added"},{"patch":"@@ -77,2 +77,2 @@\n-            \"0: #118(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n-            \"1: #118(): LOCAL_VARIABLE, {start_pc=2, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #120(): CAST, offset=1, type_index=0, location=[TYPE_ARGUMENT(0)]\",\n+            \"1: #120(): LOCAL_VARIABLE, {start_pc=5, length=2, index=1}, location=[TYPE_ARGUMENT(0)]\",\n@@ -84,1 +84,1 @@\n-            \"0: #118(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n+            \"0: #120(): METHOD_RETURN, location=[TYPE_ARGUMENT(0)]\",\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/BridgeShouldHaveNoInteriorAnnotationsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        return \"void eqtestObject() { if (null == new @TA String()); }\";\n+        return \"void eqtestObject(String s) { if (s == new @TA String()); }\";\n@@ -76,1 +76,1 @@\n-        return \"void eqtestObjectGeneric() { if (null == new @TA ArrayList<@TB String >()); }\";\n+        return \"void eqtestObjectGeneric(ArrayList<String> as) { if (as == new @TA ArrayList<@TB String >()); }\";\n@@ -173,1 +173,1 @@\n-        return \"void eqtestObject() { if (null == new @RTA @RTA String()); }\";\n+        return \"void eqtestObject(String s) { if (s == new @RTA @RTA String()); }\";\n@@ -180,1 +180,1 @@\n-        return \"void eqtestObjectGeneric() { if (null == new @RTA @RTA ArrayList<@RTB @RTB String >()); }\";\n+        return \"void eqtestObjectGeneric(ArrayList<String> as) { if (as == new @RTA @RTA ArrayList<@RTB @RTB String >()); }\";\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/NewObjects.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/api\/TestApisWithProjections.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-compiler.warn.preview.feature.use                       # preview feature support: not generated currently\n@@ -230,6 +229,0 @@\n-\n-# Primitive Classes\n-compiler.err.cyclic.primitive.class.membership\n-compiler.misc.feature.primitive.classes\n-compiler.err.generic.parameterization.with.primitive.class\n-\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.abstract.value.class.cannot.be.inner\n-\/\/ key: compiler.misc.abstract.value.class\n-\n-public class AbstractValueClassCannotBeInner {\n-    abstract value class Inner {}\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AbstractValueClassCannotBeInner.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.abstract.value.class.constructor.cannot.be.generic\n-\/\/ key: compiler.misc.abstract.value.class\n-\n-public abstract value class AbstractValueClassConstructorCannotBeGeneric {\n-    <T> AbstractValueClassConstructorCannotBeGeneric() {}\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AbstractValueClassConstructorCannotBeGeneric.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.abstract.value.class.constructor.cannot.throw\n-\/\/ key: compiler.misc.abstract.value.class\n-\n-public abstract value class AbstractValueClassConstructorCannotThrow {\n-    AbstractValueClassConstructorCannotThrow() throws Exception {}\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AbstractValueClassConstructorCannotThrow.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.abstract.value.class.constructor.has.weaker.access\n-\/\/ key: compiler.misc.abstract.value.class\n-\n-public abstract value class AbstractValueClassConstructorHasWeakerAccess {\n-    private AbstractValueClassConstructorHasWeakerAccess() {}\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AbstractValueClassConstructorHasWeakerAccess.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.abstract.value.class.no.arg.constructor.must.be.empty\n-\/\/ key: compiler.misc.abstract.value.class\n-\n-public abstract value class AbstractValueClassNoArgConstructorMustBeEmpty {\n-    public AbstractValueClassNoArgConstructorMustBeEmpty() {\n-        System.out.println(\"\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AbstractValueClassNoArgConstructorMustBeEmpty.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.abstract.value.class.declares.init.block\n-\/\/ key: compiler.misc.abstract.value.class\n-\n-public abstract value class AbstractValueClassWithInstanceInitializer {\n-    int f;\n-    { f = 42; }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AbstractValueClassWithInstanceInitializer.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.abstract.value.class.constructor.cannot.take.arguments\n-\/\/ key: compiler.misc.abstract.value.class\n-\n-public abstract value class AbstractValueClassWithNonTrivialConst {\n-    AbstractValueClassWithNonTrivialConst(int i) {}\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AbstractValueClassWithNonTrivialConst.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.call.must.be.first.stmt.in.ctor\n-\n-class CallMustBeFirst {\n-    CallMustBeFirst() {\n-        int i = 0;\n-        super();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallMustBeFirst.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.call.must.only.appear.in.ctor\n+\n+class CallOnlyInConstructor {\n+    void foo() {\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallOnlyInConstructor.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.ctor.calls.not.allowed.here\n+\n+class CallsNotAllowedHere {\n+    public CallsNotAllowedHere() {\n+        {\n+            super();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallsNotAllowedHere.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.super.init\n+ \/\/ key: compiler.warn.preview.feature.use\n+ \/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class FeatureStatementsBeforeSuper {\n+    FeatureStatementsBeforeSuper() {\n+        System.out.println();\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureStatementsBeforeSuper.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.first.statement.must.be.call.to.another.constructor\n+\/\/ key: compiler.err.non.canonical.constructor.invoke.another.constructor\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FirstInvocationMustBeAnotherConstructor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.illegal.combination.of.modifiers\n-\/\/ key: compiler.err.identity.type.has.value.super.type\n-\/\/ key: compiler.err.value.type.has.identity.super.type\n-\/\/ key: compiler.err.mutually.incompatible.supers\n-\n-value identity class IdentityValueClass {}\n-\n-value interface VI {}\n-class C implements VI {}\n-\n-identity interface II {}\n-value class V implements II {}\n-abstract class B implements VI, II {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IdentityValueClash.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.instance.field.not.allowed\n-\/\/ key: compiler.misc.superclass.of.value.class\n-\n-abstract class InstanceFieldNotAllowedInValueClass {\n-    int i;\n-}\n-\n-value class V extends InstanceFieldNotAllowedInValueClass {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InstanceFieldNotAllowedInValueClass.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,27 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.primitive.classes.not.supported\n-\n-public primitive class PrimitiveClassesNotSupported {\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitiveClassesNotSupported.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.projection.cant.be.instantiated\n-\/\/ options: -XDenablePrimitiveClasses\n-\n-public primitive class ProjectionCantBeInstantiated {\n-    int x = 42;\n-    public static void main(String[] args) {\n-        new ProjectionCantBeInstantiated();\n-        new ProjectionCantBeInstantiated.ref();\n-        new ProjectionCantBeInstantiated.val();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ProjectionCantBeInstantiated.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.redundant.superclass.init\n+\n+class RedundantSuperclassInit {\n+    RedundantSuperclassInit() {\n+        super();\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RedundantSuperclassInit.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.return.before.superclass.initialized\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class ReturnBeforeSuperclassInit {\n+    ReturnBeforeSuperclassInit(boolean maybe) {\n+        if (maybe)\n+            return;\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ReturnBeforeSuperclassInit.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.call.to.super.not.allowed.in.value.ctor\n-\/\/ options: -XDenablePrimitiveClasses\n-\n-primitive class SuperNotAllowedInPrimitiveCtor {\n-\n-    SuperNotAllowedInPrimitiveCtor() {\n-        super();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SuperNotAllowedInPrimitiveCtor.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -26,1 +26,0 @@\n-\/\/ options: -XDenablePrimitiveClasses\n@@ -28,1 +27,1 @@\n-primitive class TypeReqIdentity {\n+value class TypeReqIdentity {\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TypeReqIdentity.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.bad.functional.intf.anno.1\n-\/\/ key: compiler.misc.not.a.functional.intf.1\n-\/\/ key: compiler.misc.value.interface.nonfunctional\n-\/\/ key: compiler.misc.identity.interface.nonfunctional\n-\n-@FunctionalInterface\n-value interface I {\n-    void m();\n-}\n-\n-identity interface J {\n-    void m();\n-}\n-\n-@FunctionalInterface\n-interface K extends J {\n-}\n-\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueOrIdentityInterfacesAreNotFunctional.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.value.type.has.identity.super.type\n+\n+abstract class AC {}\n+value class V extends AC {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueWithIdentitySuper.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/patterns\/NullsInDeconstructionPatterns2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8314226.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/patterns\/Unnamed.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308590\n+ * @summary Test basic modeling for value classes\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *     jdk.compiler\/com.sun.tools.javac.api\n+ *     jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask JavacTestingAbstractProcessor\n+ * @run main TestValueClasses\n+ *\/\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.*;\n+\n+import javax.annotation.processing.*;\n+import javax.lang.model.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.type.*;\n+import javax.lang.model.util.*;\n+import java.time.*;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.Mode;\n+import toolbox.Task.OutputKind;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class TestValueClasses extends TestRunner {\n+\n+    protected ToolBox tb;\n+\n+    TestValueClasses() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new TestValueClasses().runTests();\n+    }\n+\n+    \/**\n+     * Run all methods annotated with @Test, and throw an exception if any\n+     * errors are reported..\n+     *\n+     * @throws Exception if any errors occurred\n+     *\/\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    void checkOutputContains(String log, String... expect) throws Exception {\n+        for (String e : expect) {\n+            if (!log.contains(e)) {\n+                throw new Exception(\"expected output not found: \" + e);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testValueClassesProcessor(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path r = src.resolve(\"Test\");\n+\n+        Path classes = base.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        tb.writeJavaFiles(r,\n+                \"\"\"\n+                interface Interface {}\n+\n+                value class ValueClass {}\n+\n+                class IdentityClass {}\n+                \"\"\"\n+        );\n+\n+        List<String> expected = List.of(\n+                \"- compiler.note.proc.messager: visiting: Interface Modifiers: [abstract]\",\n+                \"- compiler.note.proc.messager: visiting: ValueClass Modifiers: [value, final]\",\n+                \"- compiler.note.proc.messager:     constructor modifiers: []\",\n+                \"- compiler.note.proc.messager: visiting: IdentityClass Modifiers: []\",\n+                \"- compiler.note.proc.messager:     constructor modifiers: []\"\n+        );\n+\n+        for (Mode mode : new Mode[] {Mode.API}) {\n+            List<String> log = new JavacTask(tb, mode)\n+                    .options(\"-processor\", ValueClassesProcessor.class.getName(),\n+                            \"-XDrawDiagnostics\")\n+                    .files(findJavaFiles(src))\n+                    .outdir(classes)\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+\n+            System.out.println(\"log:\" +log);\n+\n+            if (!expected.equals(log)) {\n+                if (expected.size() == log.size()) {\n+                    for (int i = 0; i < expected.size(); i++) {\n+                        if (!expected.get(i).equals(log.get(i))) {\n+                            System.err.println(\"failing at line \" + (i + 1));\n+                            System.err.println(\"    expecting \" + expected.get(i));\n+                            System.err.println(\"    found \" + log.get(i));\n+                        }\n+                    }\n+                } else {\n+                    System.err.println(\"expected and log lists differ in length\");\n+                }\n+                throw new AssertionError(\"Unexpected output: \" + log);\n+            }\n+        }\n+    }\n+\n+    public static final class ValueClassesProcessor extends JavacTestingAbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver()) {\n+                Messager messager = processingEnv.getMessager();\n+                ElementScanner scanner = new ValueClassesScanner(messager);\n+                for(Element rootElement : roundEnv.getRootElements()) {\n+                    scanner.visit(rootElement);\n+                }\n+            }\n+            return true;\n+        }\n+\n+        class ValueClassesScanner extends ElementScanner<Void, Void> {\n+\n+            Messager messager;\n+\n+            public ValueClassesScanner(Messager messager) {\n+                this.messager = messager;\n+            }\n+\n+            @Override\n+            public Void visitType(TypeElement element, Void p) {\n+                messager.printNote(\"visiting: \" + element.getSimpleName() + \" Modifiers: \" + element.getModifiers());\n+                List<? extends Element> enclosedElements = element.getEnclosedElements();\n+                for (Element elem : enclosedElements) {\n+                    System.out.println(\"visiting \" + elem.getSimpleName());\n+                    switch (elem.getSimpleName().toString()) {\n+                        case \"<init>\":\n+                            messager.printNote(\"    constructor modifiers: \" + elem.getModifiers());\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                }\n+                return super.visitType(element, p);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestValueClasses.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -406,2 +406,2 @@\n-        \/\/ first invocation should be one to the canonical\n-        assertFail(\"compiler.err.first.statement.must.be.call.to.another.constructor\",\n+        \/\/ constructor is not canonical, so it must only invoke another constructor\n+        assertFail(\"compiler.err.non.canonical.constructor.invoke.another.constructor\",\n@@ -410,1 +410,1 @@\n-        assertFail(\"compiler.err.first.statement.must.be.call.to.another.constructor\",\n+        assertFail(\"compiler.err.non.canonical.constructor.invoke.another.constructor\",\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -129,64 +129,0 @@\n-\n-    @Test\n-    public void testPrimitiveRecordClassFileReading(Path base) throws Exception {\n-        Path src = base.resolve(\"src\");\n-\n-        tb.writeJavaFiles(src,\n-                           \"\"\"\n-                           public primitive record R(int i, @A long j, java.util.List<String> l) {}\n-                           \"\"\",\n-                           \"\"\"\n-                           public @interface A {}\n-                           \"\"\");\n-\n-        Path out = base.resolve(\"out\");\n-        Files.createDirectories(out);\n-\n-        new JavacTask(tb)\n-                .outdir(out)\n-                .options(\"-XDenablePrimitiveClasses\")\n-                .files(findJavaFiles(src))\n-                .run();\n-\n-        \/\/read the class file back, to verify javac's ClassReader\n-        \/\/reads the Record attribute properly:\n-        String output = new JavacTask(tb)\n-                .options(\"-Xprint\", \"-XDenablePrimitiveClasses\")\n-                .classpath(out.toString())\n-                .classes(\"R\")\n-                .run()\n-                .writeAll()\n-                .getOutput(Task.OutputKind.STDOUT)\n-                .replaceAll(\"\\\\R\", \"\\n\");\n-\n-        String expected =\n-                \"\"\"\n-                \\n\\\n-                public primitive value record R(int i, @A long j, java.util.List<java.lang.String> l) {\n-                  private final int i;\n-                  @A\n-                  private final long j;\n-                  private final java.util.List<java.lang.String> l;\n-                \\n\\\n-                  public final java.lang.String toString();\n-                \\n\\\n-                  public final int hashCode();\n-                \\n\\\n-                  public final boolean equals(java.lang.Object arg0);\n-                \\n\\\n-                  public int i();\n-                \\n\\\n-                  @A\n-                  public long j();\n-                \\n\\\n-                  public java.util.List<java.lang.String> l();\n-                \\n\\\n-                  public R(int i,\n-                    @A long j,\n-                    java.util.List<java.lang.String> l);\n-                }\n-                \"\"\";\n-        if (!Objects.equals(expected, output)) {\n-            throw new AssertionError(\"Unexpected output: \" + output);\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/records\/RecordReading.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/unnamed\/UnnamedLocalVariableTable.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8212175\n- * @summary Trouble creating an anonymous value class with diamond syntax\n- * @compile -XDenablePrimitiveClasses AnonymousValue.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses AnonymousValue\n- *\/\n-\n-import java.util.function.Function;\n-\n-public class AnonymousValue {\n-\t static Function<String, String> capitalizer() {\n-        return new primitive Function<>() {\n-            int x = 10;\n-\t\t\t@Override\n-\t\t\tpublic String apply(String t) {\n-\t\t\t\treturn t.toUpperCase();\n-\t\t\t}\n-        };\n-\t }\n-     public static void main(String[] args) {\n-\t\t if (!capitalizer().apply(\"blah\").equals(\"BLAH\"))\n-            throw new AssertionError(\"Failed\");\n-\t }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValue.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8209400 8215246\n- * @summary Allow anonymous classes to be value types\n- * @compile -XDenablePrimitiveClasses AnonymousValueType.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Xverify:none AnonymousValueType\n- *\/\n-\n-\n-public class AnonymousValueType {\n-    public static void main(String[] args) {\n-        Object o = new primitive Comparable<String>() {\n-            int x = 10;\n-            @Override\n-            public int compareTo(String o) {\n-                return 0;\n-            }\n-        };\n-        if (!o.toString().equals(\"AnonymousValueType$1@\" + Integer.toHexString(o.hashCode())))\n-            throw new AssertionError(\"Broken\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AnonymousValueType.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222634\n- * @summary Check array creation with V and V.ref\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile -XDenablePrimitiveClasses ArrayCreationWithQuestion.java\n- * @run main\/othervm -Xverify:none -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ArrayCreationWithQuestion\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class ArrayCreationWithQuestion {\n-\n-    static primitive class VT {\n-        VT.ref[] a1 = new VT.ref[42];\n-        VT.ref[] a2 = new VT.ref[42];\n-        VT[] a3 = new VT[42];\n-        VT[] a4 = new VT[42];\n-    }\n-\n-    public static void main(String[] args) {\n-        new ArrayCreationWithQuestion().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"ArrayCreationWithQuestion$VT.class\").toString() };\n-        runCheck(params, new String [] {\n-        \"         6: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n-        \"        17: anewarray     #1                  \/\/ class ArrayCreationWithQuestion$VT\",\n-        \"        28: anewarray     #10                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n-        \"        39: anewarray     #10                 \/\/ class \\\"QArrayCreationWithQuestion$VT;\\\"\",\n-         });\n-\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayCreationWithQuestion.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222402\n- * @summary LW2 array support in javac\n- * @compile -XDenablePrimitiveClasses ArrayRelationsTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ArrayRelationsTest\n- *\/\n-\n-public primitive class ArrayRelationsTest {\n-\n-    int x = 42;\n-\n-    public static void main(String [] args) {\n-        ArrayRelationsTest.ref [] la = new ArrayRelationsTest.ref[10];\n-        ArrayRelationsTest [] qa = new ArrayRelationsTest[10];\n-        boolean cce = false;\n-        try {\n-            qa = (ArrayRelationsTest[]) (Object []) (new String [10]);\n-        } catch (ClassCastException e) {\n-            cce = true;\n-        }\n-        if (!cce) {\n-            throw new AssertionError(\"Missing CCE\");\n-        }\n-        la = qa;\n-        ArrayRelationsTest.ref[] la2 = qa;\n-        ArrayRelationsTest [] qa2 = (ArrayRelationsTest []) la2;\n-        boolean npe = false;\n-        try {\n-            la2[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-            throw new AssertionError(\"Missing NPE\");\n-        }\n-        npe = false;\n-        Object [] oa = qa;\n-        try {\n-            oa[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-            throw new AssertionError(\"Missing NPE\");\n-        }\n-\n-        \/\/ round trip;\n-        Object o = oa = la = qa;\n-        qa = (ArrayRelationsTest[]) (la = (ArrayRelationsTest.ref []) (oa = (Object []) o));\n-        qa [0] = new ArrayRelationsTest();\n-\n-        npe = false;\n-        try {\n-            la[0] = null;\n-        } catch (NullPointerException e) {\n-            npe = true;\n-        }\n-        if (!npe) {\n-            throw new AssertionError(\"Missing NPE\");\n-        }\n-\n-        la = new ArrayRelationsTest.ref [10];\n-\n-        cce = false;\n-        try {\n-            qa = (ArrayRelationsTest[]) la;\n-        } catch (ClassCastException c) {\n-            cce = true;\n-        }\n-        if (!cce) {\n-            throw new AssertionError(\"Unexpected CCE behavior\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ArrayRelationsTest.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8222634\n- * @summary Check various code snippets that were incorrectly failing to compile.\n- * @compile -XDenablePrimitiveClasses AssortedTests.java\n- *\/\n-\n-primitive class MyValue1 {\n-    final int x = 0;\n-}\n-\n-class X {\n-    static final MyValue1 vField = new MyValue1();\n-\n-    primitive class MyValue2 {\n-        final MyValue1.ref vBoxField;\n-\n-        public MyValue2() {\n-            vBoxField = new MyValue1();\n-        }\n-    }\n-\n-    public static void main(String[] args) { }\n-}\n-\n-primitive class MyValue3 {\n-    final int x = 0;\n-    public int hash() { return 0; }\n-}\n-\n-class Y {\n-\n-    primitive class MyValue4 {\n-        final MyValue3.ref vBoxField = null;\n-\n-        public int test() {\n-            return vBoxField.hash();\n-        }\n-    }\n-\n-    public static void main(String[] args) { }\n-}\n-\n-interface MyInterface {\n-    public void test(MyValue5.ref vt);\n-}\n-\n-primitive class MyValue5 implements MyInterface {\n-    final int x = 0;\n-\n-    @Override\n-    public void test(MyValue5.ref vt) { }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AssortedTests.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary V.ref class should not inadvertently carry over attributes from V.class\n- * @bug 8244713\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -XDenablePrimitiveClasses AttributesTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses AttributesTest\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-\n-public class AttributesTest {\n-\n-    void foo() {\n-        @Deprecated\n-        primitive class V<T> {}\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        ClassFile cls = ClassFile.read(AttributesTest.class.getResourceAsStream(\"AttributesTest$1V.class\"));\n-\n-        if (cls == null) {\n-            throw new AssertionError(\"Could not locate the class files\");\n-        }\n-\n-        \/* Check emission of inner class attribute *\/\n-        InnerClasses_attribute inners = (InnerClasses_attribute) cls.attributes.get(Attribute.InnerClasses);\n-        if (inners == null) {\n-            throw new AssertionError(\"Missing inner class attribute\");\n-        }\n-        if (inners.number_of_classes != 1) {\n-            throw new AssertionError(\"Unexpected inner class attribute\");\n-        }\n-        String name = inners.classes[0].getInnerName(cls.constant_pool);\n-        if (!name.equals(\"V\")) {\n-            throw new AssertionError(\"Unexpected inner class \" + name);\n-        }\n-\n-        \/\/ Test emission of nest host attribute. Nest members attribute tested in InlineNesting*\n-        NestHost_attribute nestHost = (NestHost_attribute)cls.attributes.get(Attribute.NestHost);\n-        CONSTANT_Class_info host = nestHost != null ? nestHost.getNestTop(cls.constant_pool) : null;\n-        if (host == null || !host.getName().equals(\"AttributesTest\")) {\n-            throw new RuntimeException(\"Wrong Nest host \" + host.getName());\n-        }\n-\n-        \/\/ Test signature attribute\n-        Signature_attribute signature = (Signature_attribute)cls.attributes.get(Attribute.Signature);\n-        String sign =  signature.getSignature(cls.constant_pool);\n-        if (sign == null || !sign.equals(\"<T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\")) {\n-            throw new RuntimeException(\"Wrong signature \" + sign);\n-        }\n-\n-        \/\/ Test SourceFile attribute\n-        SourceFile_attribute source = (SourceFile_attribute)cls.attributes.get(Attribute.SourceFile);\n-        String src =  source.getSourceFile(cls.constant_pool);\n-        if (src == null || !src.equals(\"AttributesTest.java\")) {\n-            throw new RuntimeException(\"Wrong source \" + src);\n-        }\n-\n-        \/\/ Test Deprecated attribute\n-        Deprecated_attribute depr = (Deprecated_attribute) cls.attributes.get(Attribute.Deprecated);\n-        if (depr == null) {\n-            throw new RuntimeException(\"Missing deprecated annotation\");\n-        }\n-\n-        \/\/ Test EnclosingMethod attribute\n-        EnclosingMethod_attribute meth = (EnclosingMethod_attribute) cls.attributes.get(Attribute.EnclosingMethod);\n-        if (meth == null) {\n-            throw new RuntimeException(\"Missing enclosing method attribute\");\n-        }\n-        String mName = meth.getMethodName(cls.constant_pool);\n-        if (mName == null || !mName.equals(\"foo\")) {\n-            throw new RuntimeException(\"Wrong enclosing method \" + mName);\n-        }\n-\n-        \/\/ The following attributes should not be present in the projection file.\n-        String [] shouldBeAbsent = {\n-                                        \"SourceDebugExtension\",\n-                                        \"BootstrapMethods\",\n-                                        \"Module\",\n-                                        \"ModulePackages\",\n-                                        \"ModuleMainClass\",\n-                                        \"Synthetic\",\n-                                   };\n-        for (String attr : shouldBeAbsent) {\n-            if (cls.getAttribute(attr) != null) {\n-                throw new RuntimeException(\"Unexpected attribute: \" + attr);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AttributesTest.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8244711\n- * @summary Test that primitive classes work well with TWR\n- * @compile -XDenablePrimitiveClasses AutoCloseableTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses AutoCloseableTest\n- *\/\n-\n-public class AutoCloseableTest {\n-\n-    primitive static class Foo implements AutoCloseable {\n-\n-        String s = \"Exception while closing AutoCloseable\";\n-\n-        @Override\n-        public void close() throws Exception {\n-            throw new Exception(s);\n-        }\n-\n-    }\n-\n-    public static void main(String[] args) {\n-        String expected = \"\";\n-        String found = \"\";\n-        try (Foo foo = new Foo()) {\n-            expected = foo.s;\n-        } catch (Exception e) {\n-            found = e.getMessage();\n-        }\n-        if (expected.length() == 0 || !expected.equals(found))\n-            throw new AssertionError(\"Should not get here!\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AutoCloseableTest.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8214299\n- * @summary Strange errors from javac when mixing box and val types.\n- * @compile -XDenablePrimitiveClasses BogusIncompatibility.java\n- * @compile -XDenablePrimitiveClasses BogusIncompatibility.java\n- *\/\n-\n-public class BogusIncompatibility {\n-  MyValue.ref field = MyValue.create();\n-  MyValue.ref field2 = MyValue.create();\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BogusIncompatibility.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8214421 8221545 8222792\n- * @summary Q<->L mixing should be OK for upcasts and should use checkcasts for downcasts.\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile -XDenablePrimitiveClasses BoxValCastTest.java\n- * @run main\/othervm -Xverify:none -XX:+EnableValhalla -XX:+EnablePrimitiveClasses BoxValCastTest\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class BoxValCastTest {\n-\n-    static primitive class VT {\n-        int f = 0;\n-        static final VT.ref vtbox = (VT.ref) new VT(); \/\/ no binary cast\n-        static VT vt = (VT) vtbox; \/\/ binary cast\n-        static VT.ref box = vt; \/\/ no binary cast\n-        static VT.ref box2 = (VT) box; \/\/ binary cast\n-        static VT.ref box3 = id(new VT()); \/\/ no binary cast + no binary cast\n-\n-        static VT id(VT.ref vtb) {\n-            return (VT) vtb; \/\/ binary\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new BoxValCastTest().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"BoxValCastTest$VT.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-        \"checkcast     #7                  \/\/ class \\\"QBoxValCastTest$VT;\\\"\"\n-\n-         });\n-\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-         int errors = 0;\n-         for (String eo: expectedOut) {\n-             if (!out.contains(eo)) {\n-                 System.err.println(\"Match not found for string: \" + eo);\n-                 errors++;\n-             }\n-         }\n-         if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-         }\n-        String [] splits = out.split(\"checkcast     #7\", -1);\n-        if (splits.length != 4) {\n-             throw new AssertionError(\"Unexpected javap output: \" + splits.length);\n-        }\n-        splits = out.split(\"checkcast\", -1);\n-        if (splits.length != 9) {\n-             throw new AssertionError(\"Unexpected javap output: \" + splits.length);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/BoxValCastTest.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n@@ -34,1 +35,1 @@\n-\tprivate final int x, ymx;\n+    private final int x, ymx;\n@@ -36,1 +37,1 @@\n-\tCanonicalCtorTest(int x, int y) {\n+    CanonicalCtorTest(int x, int y) {\n@@ -38,2 +39,2 @@\n-\t\tymx = y - x;\n-\t\tthis.x = x;\n+        ymx = y - x;\n+        this.x = x;\n@@ -43,3 +44,3 @@\n-\t\tvalidate();                 \/\/ OK: DU = {}\n-\t\tthis.validate();            \/\/ OK: DU = {}\n-\t\tCanonicalCtorTest.this.validate();          \/\/ OK: DU = {}\n+        validate();                 \/\/ OK: DU = {}\n+        this.validate();            \/\/ OK: DU = {}\n+        CanonicalCtorTest.this.validate();          \/\/ OK: DU = {}\n@@ -47,3 +48,3 @@\n-\t\tassert (this.x > 0);        \/\/ OK: DU = {}\n-\t\tassert (this.y() > 0);      \/\/ OK: DU = {}\n-\t}\n+        assert (this.x > 0);        \/\/ OK: DU = {}\n+        assert (this.y() > 0);      \/\/ OK: DU = {}\n+    }\n@@ -51,3 +52,3 @@\n-\tint x() {\n-\t\treturn x;\n-\t}\n+    int x() {\n+        return x;\n+    }\n@@ -55,3 +56,3 @@\n-\tint y() {\n-\t\treturn ymx + x;\n-\t}\n+    int y() {\n+        return ymx + x;\n+    }\n@@ -59,3 +60,3 @@\n-\tvoid validate() {\n-\t\tassert (x() > 0 && y() > 0);\n-\t}\n+    void validate() {\n+        assert (x() > 0 && y() > 0);\n+    }\n@@ -63,5 +64,5 @@\n-\tpublic static void main(String... av) {\n-\t\tCanonicalCtorTest z = new CanonicalCtorTest(1, 10);\n-\t\tassert (z.x() == 1);\n-\t\tassert (z.y() == 10);\n-\t}\n+    public static void main(String... av) {\n+        CanonicalCtorTest z = new CanonicalCtorTest(1, 10);\n+        assert (z.x() == 1);\n+        assert (z.y() == 10);\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CanonicalCtorTest.java","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,13 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check that casting to a value type involves no null check when values are not recognized in source.\n- * @compile -XDenablePrimitiveClasses Point.java\n- * @compile\/fail\/ref=CastNoNullCheckTest.out -source 10 -XDrawDiagnostics CastNoNullCheckTest.java\n- *\/\n-\n-public class CastNoNullCheckTest {\n-    void m() {\n-        Object o = null;\n-        Point p = (Point) o;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNoNullCheckTest.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-- compiler.warn.source.no.system.modules.path: 10\n-CastNoNullCheckTest.java:11:9: compiler.err.cant.access: Point, (compiler.misc.bad.class.file.header: Point.class, (compiler.misc.bad.class.signature: \"QPoint;\"))\n-1 error\n-1 warning\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNoNullCheckTest.out","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -34,0 +34,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CastNullCheckTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8207332\n- * @summary Verify that chained assignments in value constructors are lowered correctly.\n- * @compile -XDenablePrimitiveClasses ChainedAssignmentTest.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ChainedAssignmentTest\n- *\/\n-\n-public class ChainedAssignmentTest {\n-\n-    static primitive class Point {\n-        int x;\n-        int y;\n-        Point() {\n-            x = y = 1234; \/\/ Problematic\n-        }\n-    }\n-\n-    static primitive class LongPoint {\n-        long x;\n-        long y;\n-        LongPoint() {\n-            x = y = 1234; \/\/ Problematic\n-        }\n-    }\n-    public static void main(String[] args) {\n-        Point p = new Point();\n-        if (p.x != 1234 || p.y != 1234)\n-            throw new AssertionError(\"Broken\");\n-\n-        LongPoint lp = new LongPoint();\n-        if (lp.x != 1234 || lp.y != 1234)\n-            throw new AssertionError(\"Broken\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ChainedAssignmentTest.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237067\n- * @summary [lworld] Check good and bad selectors on a type name\n- * @compile\/fail\/ref=CheckBadSelector.out -XDrawDiagnostics -XDenablePrimitiveClasses CheckBadSelector.java\n- *\/\n-\n-primitive final class Point {\n-\n-    void badSelector() {\n-        Class<?> c = int.class;\n-        int i = int.default;\n-        int x = int.whatever;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckBadSelector.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -5,0 +5,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckCyclicMembership.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,11 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check that a concrete class is not allowed to be the super class of a primitive class\n- *\n- * @compile\/fail\/ref=CheckExtends.out -XDrawDiagnostics -XDenablePrimitiveClasses CheckExtends.java\n- *\/\n-\n-final primitive class CheckExtends extends Object {\n-    static class NestedConcrete {}\n-    static primitive class NestedPrimitive extends NestedConcrete {}\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckExtends.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-CheckExtends.java:10:22: compiler.err.concrete.supertype.for.value.class: CheckExtends.NestedPrimitive, CheckExtends.NestedConcrete\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckExtends.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,13 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237067\n- * @summary Check that feature gated constructs are not allowed in previous versions.\n- * @compile\/fail\/ref=CheckFeatureGate1.out --release=13 -XDrawDiagnostics CheckFeatureGate1.java\n- *\/\n-\n-public class CheckFeatureGate1 {\n-\n-    static primitive class Val {\n-        public int v = 42;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate1.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-CheckFeatureGate1.java:10:12: compiler.err.primitive.classes.not.supported: 21\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate1.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,21 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8237067\n- * @summary Check that .default is not allowed in previous versions.\n- * @compile\/fail\/ref=CheckFeatureGate2.out --release=13 -XDrawDiagnostics CheckFeatureGate2.java\n- *\/\n-\n-public class CheckFeatureGate2 {\n-\n-    static <T> void checkDefaultT(Class<T> clazz) throws Exception {\n-        while (T.default != null)\n-            throw new AssertionError(\"Generic object should default to null\");\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        int a = int.default;\n-        String s = String.default;\n-        int[] ia = int[].default;\n-        checkDefaultT(Object.class);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate2.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-CheckFeatureGate2.java:11:17: compiler.err.primitive.classes.not.supported: 21\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFeatureGate2.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFieldDescriptors.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Value types and their instance fields are implicitly final\n- *\n- * @compile\/fail\/ref=CheckFinal.out -XDrawDiagnostics -XDenablePrimitiveClasses CheckFinal.java\n- *\/\n-\n-primitive class CheckFinal { \/\/ implicitly final\n-    int fi;  \/\/ implicitly final\n-    final int fe; \/\/ explicitly final\n-    void f(int x) {\n-        int y;\n-        x = y = 0;\n-        this.fi = 100;  \/\/ Error.\n-        this.fe = 100;  \/\/ Error.\n-        this.xs = 100; \/\/ OK.\n-        this.xsf = 100; \/\/ Error\n-\n-        CheckFinal cf = new CheckFinal() {}; \/\/ Error, final class cannot be extended.\n-    }\n-    final Object o = new Object() { int i;\n-                         void foo() {\n-                             i = 100;\n-                         };\n-                     };\n-    static int xs; \/\/ OK.\n-    static final int xsf; \/\/ OK.\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFinal.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-CheckFinal.java:14:13: compiler.err.cant.assign.val.to.var: final, fi\n-CheckFinal.java:15:13: compiler.err.cant.assign.val.to.var: final, fe\n-CheckFinal.java:17:13: compiler.err.cant.assign.val.to.var: static final, xsf\n-CheckFinal.java:19:29: compiler.err.cant.inherit.from.final: CheckFinal\n-CheckFinal.java:19:42: compiler.err.identity.type.has.value.super.type: compiler.misc.anonymous.class: CheckFinal, CheckFinal\n-5 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFinal.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Check value flag in class file\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -XDallowWithFieldOperator -XDenablePrimitiveClasses Point.java\n- * @run main CheckFlags\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-\n-public class CheckFlags {\n-    public static void main(String[] args) throws Exception {\n-        ClassFile cls = ClassFile.read(CheckFlags.class.getResourceAsStream(\"Point.class\"));\n-\n-        if (!cls.access_flags.is(AccessFlags.ACC_PRIMITIVE))\n-            throw new Exception(\"Value flag not set\");\n-\n-        if (!cls.access_flags.is(AccessFlags.ACC_FINAL))\n-            throw new Exception(\"Final flag not set\");\n-\n-        Field [] flds = cls.fields;\n-\n-        for (Field fld : flds) {\n-            if (!fld.access_flags.is(AccessFlags.ACC_FINAL))\n-                throw new Exception(\"Final flag not set\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlags.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableCycles.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableFlagFromClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckFlattenableSyntheticFields.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8237071\n- * @summary Totalize System.identityHashCode for inline types.\n- * @compile -XDenablePrimitiveClasses CheckIdentityHash.java\n- *\/\n-\n-final primitive class CheckIdentityHash {\n-    int identityHashCode(CheckIdentityHash x) {\n-        return 0;\n-    }\n-    void test(CheckIdentityHash v) {\n-        this.identityHashCode(v);\n-        System.identityHashCode(v);\n-        System.identityHashCode(this);\n-        java.lang.System.identityHashCode(v);\n-        java.lang.System.identityHashCode(this);\n-    }\n-    int x = 10;\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckIdentityHash.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8237071\n- * @summary Totalize System.identityHashCode for inline types.\n- * @compile -XDenablePrimitiveClasses CheckIdentityHash01.java\n- *\/\n-import static java.lang.System.*;\n-\n-public final primitive class CheckIdentityHash01 {\n-    void test(CheckIdentityHash01 v) {\n-\n-        identityHashCode(v);      \/\/ <- error\n-        identityHashCode(this);   \/\/ <- error\n-\n-        System system = null;\n-        system.identityHashCode(v);      \/\/ <- error\n-        system.identityHashCode(this);   \/\/ <- error\n-\n-        System.identityHashCode(v);      \/\/ <- error\n-        System.identityHashCode(this);   \/\/ <- error\n-\n-        java.lang.System.identityHashCode(v);    \/\/ <- error\n-        java.lang.System.identityHashCode(this); \/\/ <- error\n-    }\n-    int x = 10;\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckIdentityHash01.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8211910\n- * @summary [lworld] Reinstate support for local value classes.\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n- * @compile -XDenablePrimitiveClasses CheckLocalClasses.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses CheckLocalClasses\n- *\/\n-\n-import com.sun.tools.classfile.*;\n-\n-public class CheckLocalClasses {\n-    public class RefOuter {\n-        void foo() {\n-            RefOuter o = new RefOuter();\n-            primitive  class Inner {\n-                private final int value2;\n-                public Inner(int value2) {\n-                    System.out.println(o);\n-                    this.value2 = value2;\n-                }\n-            }\n-        }\n-    }\n-    public primitive class ValueOuter {\n-        int x = 10;\n-        void foo() {\n-            ValueOuter o = new ValueOuter();\n-            primitive class Inner {\n-                private final int value2;\n-                public Inner(int value2) {\n-                    System.out.println(o);\n-                    this.value2 = value2;\n-                }\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        ClassFile cls = ClassFile.read(CheckLocalClasses.class.getResourceAsStream(\"CheckLocalClasses$ValueOuter$1Inner.class\"));\n-\n-        if (!cls.access_flags.is(AccessFlags.ACC_PRIMITIVE))\n-            throw new Exception(\"Value flag not set\");\n-\n-        if (!cls.access_flags.is(AccessFlags.ACC_FINAL))\n-            throw new Exception(\"Final flag not set\");\n-\n-        cls = ClassFile.read(CheckLocalClasses.class.getResourceAsStream(\"CheckLocalClasses$RefOuter$1Inner.class\"));\n-\n-        if (!cls.access_flags.is(AccessFlags.ACC_PRIMITIVE))\n-            throw new Exception(\"Value flag not set\");\n-\n-        if (!cls.access_flags.is(AccessFlags.ACC_FINAL))\n-            throw new Exception(\"Final flag not set\");\n-\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckLocalClasses.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check various semantic constraints on value creation via default\n- *\n- * @compile\/fail\/ref=CheckMakeDefault.out -XDrawDiagnostics -XDenablePrimitiveClasses CheckMakeDefault.java\n- *\/\n-primitive final class Point {\n-\n-    primitive interface I { int x = 10; } \/\/ Error\n-    primitive abstract class A { int x = 10; } \/\/ Error\n-    static final class Sinner {\n-        static Sinner make() {\n-            return Sinner.default;\n-        }\n-    }\n-\n-    primitive static final class SinnerValue {\n-        static SinnerValue make() {\n-            return SinnerValue.default;\n-        } int x = 10;\n-    }\n-\n-    final int x;\n-    final int y;\n-\n-    final int nonbool = boolean.default;\n-    final boolean nonbyte = byte.default;\n-    final boolean nonchar = char.default;\n-    final boolean nonint = int.default;\n-    final boolean nonshort = short.default;\n-    final boolean nonlong = long.default;\n-    final boolean nonfloat = float.default;\n-    final boolean nondouble = double.default;\n-    final int nonString = String.default;\n-    final int nonbyteArray = byte[].default;\n-\n-    Point() {}\n-    Point (int x, int y) {}\n-\n-    static Point make(int x, int y) {\n-       Point p = Point.default;\n-       String s = String.default;\n-       Object o = SinnerValue.default;\n-       return new Point(x, y);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMakeDefault.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,13 +0,0 @@\n-CheckMakeDefault.java:9:15: compiler.err.illegal.combination.of.modifiers: interface, primitive\n-CheckMakeDefault.java:10:24: compiler.err.illegal.combination.of.modifiers: abstract, primitive\n-CheckMakeDefault.java:26:32: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: boolean, int)\n-CheckMakeDefault.java:27:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte, boolean)\n-CheckMakeDefault.java:28:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: char, boolean)\n-CheckMakeDefault.java:29:31: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, boolean)\n-CheckMakeDefault.java:30:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: short, boolean)\n-CheckMakeDefault.java:31:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, boolean)\n-CheckMakeDefault.java:32:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, boolean)\n-CheckMakeDefault.java:33:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, boolean)\n-CheckMakeDefault.java:34:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n-CheckMakeDefault.java:35:36: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte[], int)\n-12 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMakeDefault.out","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,19 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check null store into multidimensional array\n- * @compile\/fail\/ref=CheckMultiDimensionalArrayStore.out -XDrawDiagnostics -XDdev -XDenablePrimitiveClasses CheckMultiDimensionalArrayStore.java\n- *\/\n-\n-public class CheckMultiDimensionalArrayStore {\n-    primitive final class V {\n-        final int x = 10;\n-        class Y {\n-            V [][][] va = new V[][][] {{{ null }}};\n-            V [][] va2 =  {{ null }};\n-            void foo() {\n-                va = new V[][][] {{{ null }}};\n-                va[0][0][0] = null;\n-            }\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMultiDimensionalArrayStore.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-CheckMultiDimensionalArrayStore.java:11:43: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:12:30: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:14:38: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-CheckMultiDimensionalArrayStore.java:15:31: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, CheckMultiDimensionalArrayStore.V)\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckMultiDimensionalArrayStore.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullAssign.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullCastable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckNullWithQuestion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,14 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8222790\n- * @summary javac diagnostics don't discriminate between inline types and there nullable projection types.\n- *\n- * @compile\/fail\/ref=CheckQuestionInMessages.out -XDrawDiagnostics -XDenablePrimitiveClasses CheckQuestionInMessages.java\n- *\/\n-\n-import java.util.List;\n-\n-primitive class X {\n-    List<X.ref> ls = new Object();\n-    X.ref[] xa = new Object[10];  \/\/ no support for Object.ref yet, but they are the same.\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckQuestionInMessages.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-CheckQuestionInMessages.java:12:22: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object, java.util.List<X.ref>)\n-CheckQuestionInMessages.java:13:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Object[], X.ref[])\n-2 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckQuestionInMessages.out","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSeparateCompile.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckStaticFinalAssign.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSuperCompileOnly.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckSynchronized.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n@@ -10,1 +11,1 @@\n-\tprivate final int x, ymx;\n+    private final int x, ymx;\n@@ -12,1 +13,1 @@\n-\tV(int x, int y) {\n+    V(int x, int y) {\n@@ -14,2 +15,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -17,3 +18,3 @@\n-\t\tvalidate();                 \/\/ BAD to call instance method DU = {x, ymx}\n-\t\tthis.validate();            \/\/ BAD to call instance method DU = {x, ymx}\n-\t\tV.this.validate();          \/\/ BAD to call instance method DU = {x, ymx}\n+        validate();                 \/\/ BAD to call instance method DU = {x, ymx}\n+        this.validate();            \/\/ BAD to call instance method DU = {x, ymx}\n+        V.this.validate();          \/\/ BAD to call instance method DU = {x, ymx}\n@@ -21,2 +22,2 @@\n-\t\tSystem.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x, ymx}\n-\t\tSystem.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x, ymx}\n+        System.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x, ymx}\n+        System.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x, ymx}\n@@ -24,2 +25,2 @@\n-\t\tV v = this;                 \/\/ BAD to create alias  DU = {x, ymx}\n-\t\tv = V.this;                 \/\/ BAD to create alias  DU = {x, ymx}\n+        V v = this;                 \/\/ BAD to create alias  DU = {x, ymx}\n+        v = V.this;                 \/\/ BAD to create alias  DU = {x, ymx}\n@@ -27,2 +28,2 @@\n-\t\tymx = y - x;                \/\/ OK, implicit this for field write.\n-\t\tint l = this.ymx;           \/\/ OK, explicit this for DA field read.\n+        ymx = y - x;                \/\/ OK, implicit this for field write.\n+        int l = this.ymx;           \/\/ OK, explicit this for DA field read.\n@@ -30,2 +31,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -33,3 +34,3 @@\n-\t\tvalidate();                 \/\/ BAD to call instance method DU = {x}\n-\t\tthis.validate();            \/\/ BAD to call instance method DU = {x}\n-\t\tV.this.validate();          \/\/ BAD to call instance method DU = {x}\n+        validate();                 \/\/ BAD to call instance method DU = {x}\n+        this.validate();            \/\/ BAD to call instance method DU = {x}\n+        V.this.validate();          \/\/ BAD to call instance method DU = {x}\n@@ -37,2 +38,2 @@\n-\t\tSystem.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x}\n-\t\tSystem.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x}\n+        System.out.println(this);   \/\/ BAD to pass `this' as argument DU = {x}\n+        System.out.println(V.this); \/\/ BAD to pass `this' as argument DU = {x}\n@@ -40,2 +41,2 @@\n-\t\tv = this;                   \/\/ BAD to create alias  DU = {x}\n-\t\tv = V.this;                 \/\/ BAD to create alias  DU = {x}\n+        v = this;                   \/\/ BAD to create alias  DU = {x}\n+        v = V.this;                 \/\/ BAD to create alias  DU = {x}\n@@ -43,1 +44,1 @@\n-\t\tthis.x = x;\n+        this.x = x;\n@@ -47,2 +48,2 @@\n-\t\tOK();                       \/\/ OK to call static methods.\n-\t\tthis.OK();                  \/\/ OK to call static methods.\n+        OK();                       \/\/ OK to call static methods.\n+        this.OK();                  \/\/ OK to call static methods.\n@@ -50,3 +51,3 @@\n-\t\tvalidate();                 \/\/ OK: DU = {}\n-\t\tthis.validate();            \/\/ OK: DU = {}\n-\t\tV.this.validate();          \/\/ OK: DU = {}\n+        validate();                 \/\/ OK: DU = {}\n+        this.validate();            \/\/ OK: DU = {}\n+        V.this.validate();          \/\/ OK: DU = {}\n@@ -54,2 +55,2 @@\n-\t\tSystem.out.println(this);   \/\/ OK: DU = {}\n-\t\tSystem.out.println(V.this); \/\/ OK: DU = {}\n+        System.out.println(this);   \/\/ OK: DU = {}\n+        System.out.println(V.this); \/\/ OK: DU = {}\n@@ -57,5 +58,5 @@\n-\t\tv = this;                   \/\/ OK: DU = {}\n-\t\tv = V.this;                 \/\/ OK: DU = {}\n-\t\tassert (this.x > 0);        \/\/ OK: DU = {}\n-\t\tassert (this.y() > 0);      \/\/ OK: DU = {}\n-\t}\n+        v = this;                   \/\/ OK: DU = {}\n+        v = V.this;                 \/\/ OK: DU = {}\n+        assert (this.x > 0);        \/\/ OK: DU = {}\n+        assert (this.y() > 0);      \/\/ OK: DU = {}\n+    }\n@@ -63,1 +64,1 @@\n-\tV() { \/\/ non-initial constructor. All, statements below are OK.\n+    V() { \/\/ non-initial constructor. All, statements below are OK.\n@@ -65,2 +66,2 @@\n-\t\tOK();                       \n-\t\tthis.OK();                  \n+        OK();\n+        this.OK();\n@@ -68,3 +69,3 @@\n-\t\tvalidate();                 \n-\t\tthis.validate();            \n-\t\tV.this.validate();          \n+        validate();\n+        this.validate();\n+        V.this.validate();\n@@ -72,2 +73,2 @@\n-\t\tSystem.out.println(this);   \n-\t\tSystem.out.println(V.this); \n+        System.out.println(this);\n+        System.out.println(V.this);\n@@ -75,2 +76,2 @@\n-\t\tV v = this;                 \n-\t\tv = V.this;                 \n+        V v = this;\n+        v = V.this;\n@@ -78,1 +79,1 @@\n-\t\tint l = this.ymx;           \n+        int l = this.ymx;\n@@ -80,3 +81,3 @@\n-\t\tassert (this.x > 0);        \n-\t\tassert (this.y() > 0);      \n-\t}\n+        assert (this.x > 0);\n+        assert (this.y() > 0);\n+    }\n@@ -84,2 +85,2 @@\n-\tstatic void OK() {\n-\t}\n+    static void OK() {\n+    }\n@@ -87,3 +88,3 @@\n-\tint x() {\n-\t\treturn x;\n-\t}\n+    int x() {\n+        return x;\n+    }\n@@ -91,3 +92,3 @@\n-\tint y() {\n-\t\treturn ymx + x;\n-\t}\n+    int y() {\n+        return ymx + x;\n+    }\n@@ -95,3 +96,3 @@\n-\tvoid validate() {\n-\t\tassert (x() > 0 && y() > 0);\n-\t}\n+    void validate() {\n+        assert (x() > 0 && y() > 0);\n+    }\n@@ -99,5 +100,5 @@\n-\tpublic static void main(String... av) {\n-\t\tV z = new V(1, 10);\n-\t\tassert (z.x() == 1);\n-\t\tassert (z.y() == 10);\n-\t}\n+    public static void main(String... av) {\n+        V z = new V(1, 10);\n+        assert (z.x() == 1);\n+        assert (z.y() == 10);\n+    }\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckThisLeak.java","additions":66,"deletions":65,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CheckValueModifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralNegativeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ClassLiteralTypingTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CompilerNoBogusAssert.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CompilesJustFine.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConditionalInlineTypeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Check constant propagation behavior\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile -XDenablePrimitiveClasses ConstantPropagationTest.java\n- * @run main\/othervm -Xverify:none -XX:+EnableValhalla -XX:+EnablePrimitiveClasses ConstantPropagationTest\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class ConstantPropagationTest {\n-\n-    static final primitive class X {\n-        static final int sfif = 8888;\n-        final int ifif = 9999;\n-        static void foo(X x) {\n-            System.out.println(sfif);\n-            System.out.println(x.ifif);\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new ConstantPropagationTest().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"ConstantPropagationTest$X.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-         \"ConstantValue: int 8888\",\n-         \"3: sipush        8888\",\n-         }, new String [] {\n-         \"ConstantValue: int 9999\"\n-         });\n-\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut, String [] unexpectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-        for (String eo: unexpectedOut) {\n-            if (out.contains(eo)) {\n-                System.err.println(\"Unexpected output found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-        if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConstantPropagationTest.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ConsumeUnifiedClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/CtorChain.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DefaultNonInlines.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DefaultOfPrimitiveReference.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n@@ -42,1 +43,1 @@\n- \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DocLintSyntheticsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/DualNonDuplicateErrors.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/EmptyValueTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/EnhancedForLoopTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ExplicitLambdaWithNullableTypes3.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericArrayRegression.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n@@ -35,1 +36,1 @@\n-  \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues1.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n@@ -37,1 +38,1 @@\n-  \n+\n@@ -41,1 +42,1 @@\n-  \n+\n@@ -45,1 +46,1 @@\n-  \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues2.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n@@ -37,1 +38,1 @@\n-  \n+\n@@ -41,1 +42,1 @@\n-  \n+\n@@ -44,1 +45,1 @@\n-    \n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues3.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues4.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GenericsAndValues5.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/GetClassTypingTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InferredValueParameterizationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineClassTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InlineDiamondTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerClassAttributeValuenessTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InnerValueNew.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/InstanceofProjectionArray.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/IntercastTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LocalValueNew.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LookupOnLoxTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/LubWithInlines.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoCrashTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/NoUnnecessaryCast.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/OverloadingPhaseTest2.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ParameterizedDefault.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/Point.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PreloadAttributeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/PrimitiveClassesCompilationTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectedArrayDotClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProjectionRelationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ProperTypeApplySelectTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QPointConsumer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QTypeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n@@ -34,1 +35,1 @@\n-    class Inner { \n+    class Inner {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedSuperCtor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/QualifiedThisTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/RefDotClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileGenerics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SeparateCompileTest01.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n@@ -46,1 +47,1 @@\n-            int l = 1234; \n+            int l = 1234;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SideEffectTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SignatureTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SmallSetTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StaticSelectedThroughProjection.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/StreamsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/SuperHashCodeEqualsToStringTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/T8279655.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestQualifierOnInit.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TestReflectiveMirrors.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ThisIsNotAnInstanceField.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/TypeRelationsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnannotatedProjection.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassInnerClassesTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnifiedPrimitiveClassNestHostTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/UnrelatedThisLeak.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValRefTokensTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueAsEnclosingClass.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueBootstrapMethodsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n@@ -43,2 +44,2 @@\n-    \n-    public static void main(String [] args) {   \n+\n+    public static void main(String [] args) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueConstructorRef.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueCreationTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValueNewReadWrite.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/ValuesAsRefs.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8205686 8215109\n- * @summary __WithField seems to have trouble if the value type is a generic type.\n- * @compile -XDenablePrimitiveClasses WithFieldOfGenericType.java\n- * @run main\/othervm -XX:+EnableValhalla -XX:+EnablePrimitiveClasses WithFieldOfGenericType\n- *\/\n-\n-public final primitive class WithFieldOfGenericType<E> {\n-  private final boolean value;\n-\n-  public static <E> WithFieldOfGenericType<E> create() {\n-    return new WithFieldOfGenericType<>(true);\n-  }\n-\n-  private WithFieldOfGenericType(boolean value) {\n-    this.value = value;\n-  }\n-\n-  public static void main(String[] args) {\n-     WithFieldOfGenericType<String> w = create();\n-     if (w.value != true)\n-        throw new AssertionError(\"Withfield didn't work!\");\n-  }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldOfGenericType.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+ * @ignore\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/WithFieldRuntimeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore\n@@ -54,1 +55,1 @@\n-public primitive record ApplicableAnnotationsOnPrimitiveRecords(@FieldAnnotation @MethodAnnotation @ParameterAnnotation String s, @FieldAnnotation @MethodAnnotation @ParameterAnnotation int i) {\n+public value record ApplicableAnnotationsOnPrimitiveRecords(@FieldAnnotation @MethodAnnotation @ParameterAnnotation String s, @FieldAnnotation @MethodAnnotation @ParameterAnnotation int i) {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/records\/ApplicableAnnotationsOnPrimitiveRecords.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8212175\n+ * @summary Trouble creating an anonymous value class with diamond syntax\n+ * @ignore 8316628\n+ *\/\n+\n+import java.util.function.Function;\n+\n+public class AnonymousValue {\n+    static Function<String, String> capitalizer() {\n+        return new value Function<>() {\n+            int x = 10;\n+            @Override\n+            public String apply(String t) {\n+                return t.toUpperCase();\n+            }\n+        };\n+    }\n+    public static void main(String[] args) {\n+        if (!capitalizer().apply(\"blah\").equals(\"BLAH\"))\n+            throw new AssertionError(\"Failed\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnonymousValue.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8209400 8215246\n+ * @summary Allow anonymous classes to be value types\n+ * @ignore 8316628\n+ *\/\n+\n+public class AnonymousValueType {\n+    public static void main(String[] args) {\n+        Object o = new value Comparable<String>() {\n+            int x = 10;\n+            @Override\n+            public int compareTo(String o) {\n+                return 0;\n+            }\n+        };\n+        if (!o.toString().equals(\"AnonymousValueType$1@\" + Integer.toHexString(o.hashCode())))\n+            throw new AssertionError(\"Broken\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnonymousValueType.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8222634\n+ * @summary Check array creation with V and V.ref\n+ * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n+ * @modules jdk.compiler\n+ * @compile ArrayCreationWithQuestion.java\n+ * @run main ArrayCreationWithQuestion\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Paths;\n+\n+public class ArrayCreationWithQuestion {\n+\n+    static value class VT {\n+        VT[] a1;\n+        VT[] a2;\n+\n+        VT() {\n+            a1 = new VT[42];\n+            a2 = new VT[42];\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new ArrayCreationWithQuestion().run();\n+    }\n+\n+    void run() {\n+        String [] params = new String [] { \"-v\",\n+                Paths.get(System.getProperty(\"test.classes\"),\n+                        \"ArrayCreationWithQuestion$VT.class\").toString() };\n+        runCheck(params, new String [] {\n+                \"         7: anewarray     #7                  \/\/ class ArrayCreationWithQuestion$VT\",\n+                \"        16: anewarray     #7                  \/\/ class ArrayCreationWithQuestion$VT\",\n+        });\n+\n+    }\n+\n+    void runCheck(String [] params, String [] expectedOut) {\n+        StringWriter s;\n+        String out;\n+\n+        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n+            com.sun.tools.javap.Main.run(params, pw);\n+            out = s.toString();\n+        }\n+        int errors = 0;\n+        for (String eo: expectedOut) {\n+            if (!out.contains(eo)) {\n+                System.err.println(\"Match not found for string: \" + eo);\n+                errors++;\n+            }\n+        }\n+        if (errors > 0) {\n+            throw new AssertionError(\"Unexpected javap output: \" + out);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ArrayCreationWithQuestion.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n- * @compile -XDenablePrimitiveClasses AsSuperTests.java\n+ * @compile AsSuperTests.java\n@@ -39,1 +39,1 @@\n-   work correctly with primitive types.\n+   work correctly with value classes.\n@@ -48,1 +48,1 @@\n-abstract class Base<T> {\n+abstract value class Base<T> {\n@@ -61,1 +61,1 @@\n-    static primitive class Foo<X> extends Base {}\n+    static value class Foo<X> extends Base {}\n@@ -64,1 +64,1 @@\n-primitive class X extends Base implements I {\n+value class X extends Base implements I {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AsSuperTests.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/langtools\/tools\/javac\/valhalla\/primitive-classes\/AsSuperTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8208067\n+ * @summary Verify that instance methods are callable from ctor after all instance fields are DA.\n+ * @ignore\n+ *\/\n+\n+\/\/ see JDK-8316628\n+public value class CanonicalCtorTest {\n+\n+    private final int x, ymx;\n+\n+    CanonicalCtorTest(int x, int y) {\n+\n+        ymx = y - x;\n+        this.x = x;\n+\n+        \/\/ ALL fields are assigned now.\n+\n+        validate();                 \/\/ OK: DU = {}\n+        this.validate();            \/\/ OK: DU = {}\n+        CanonicalCtorTest.this.validate();          \/\/ OK: DU = {}\n+\n+        assert (this.x > 0);        \/\/ OK: DU = {}\n+        assert (this.y() > 0);      \/\/ OK: DU = {}\n+    }\n+\n+    int x() {\n+        return x;\n+    }\n+\n+    int y() {\n+        return ymx + x;\n+    }\n+\n+    void validate() {\n+        assert (x() > 0 && y() > 0);\n+    }\n+\n+    public static void main(String... av) {\n+        CanonicalCtorTest z = new CanonicalCtorTest(1, 10);\n+        assert (z.x() == 1);\n+        assert (z.y() == 10);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CanonicalCtorTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check various semantic constraints on value creation via default\n- *\n- * @compile\/fail\/ref=CheckMakeDefault.out -XDrawDiagnostics -XDenablePrimitiveClasses CheckMakeDefault.java\n- *\/\n-value final class Point {\n-\n-    value interface I { int x = 10; }\n-    value abstract class A { int x = 10; }\n-    static final class Sinner {\n-        static Sinner make() {\n-            return Sinner.default;\n-        }\n-    }\n-\n-    value static final class SinnerValue {\n-        static SinnerValue make() {\n-            return SinnerValue.default;\n-        } int x = 10;\n-    }\n-\n-    final int x;\n-    final int y;\n-\n-    final int nonbool = boolean.default;\n-    final boolean nonbyte = byte.default;\n-    final boolean nonchar = char.default;\n-    final boolean nonint = int.default;\n-    final boolean nonshort = short.default;\n-    final boolean nonlong = long.default;\n-    final boolean nonfloat = float.default;\n-    final boolean nondouble = double.default;\n-    final int nonString = String.default;\n-    final int nonbyteArray = byte[].default;\n-\n-    Point() {}\n-    Point (int x, int y) {}\n-\n-    static Point make(int x, int y) {\n-       Point p = Point.default;\n-       String s = String.default;\n-       Object o = SinnerValue.default;\n-       return new Point(x, y);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckMakeDefault.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-CheckMakeDefault.java:10:20: compiler.err.abstract.value.class.cannot.be.inner: (compiler.misc.abstract.value.class: Point.A)\n-CheckMakeDefault.java:26:32: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: boolean, int)\n-CheckMakeDefault.java:27:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte, boolean)\n-CheckMakeDefault.java:28:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: char, boolean)\n-CheckMakeDefault.java:29:31: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, boolean)\n-CheckMakeDefault.java:30:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: short, boolean)\n-CheckMakeDefault.java:31:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, boolean)\n-CheckMakeDefault.java:32:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, boolean)\n-CheckMakeDefault.java:33:37: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, boolean)\n-CheckMakeDefault.java:34:33: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.String, int)\n-CheckMakeDefault.java:35:36: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: byte[], int)\n-11 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CheckMakeDefault.out","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Check constant propagation behavior\n- * @modules jdk.compiler\/com.sun.tools.javac.util jdk.jdeps\/com.sun.tools.javap\n- * @compile ConstantPropagationTest.java\n- * @run main\/othervm -Xverify:none ConstantPropagationTest\n- * @modules jdk.compiler\n- *\/\n-\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Paths;\n-\n-public class ConstantPropagationTest {\n-\n-    static final value class X {\n-        static final int sfif = 8888;\n-        final int ifif = 9999;\n-        static void foo(X x) {\n-            System.out.println(sfif);\n-            System.out.println(x.ifif);\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        new ConstantPropagationTest().run();\n-    }\n-\n-    void run() {\n-        String [] params = new String [] { \"-v\",\n-                                            Paths.get(System.getProperty(\"test.classes\"),\n-                                                \"ConstantPropagationTest$X.class\").toString() };\n-        runCheck(params, new String [] {\n-\n-         \"ConstantValue: int 8888\",\n-         \"3: sipush        8888\",\n-         }, new String [] {\n-         \"ConstantValue: int 9999\"\n-         });\n-\n-     }\n-\n-     void runCheck(String [] params, String [] expectedOut, String [] unexpectedOut) {\n-        StringWriter s;\n-        String out;\n-\n-        try (PrintWriter pw = new PrintWriter(s = new StringWriter())) {\n-            com.sun.tools.javap.Main.run(params, pw);\n-            out = s.toString();\n-        }\n-        int errors = 0;\n-        for (String eo: expectedOut) {\n-            if (!out.contains(eo)) {\n-                System.err.println(\"Match not found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-        for (String eo: unexpectedOut) {\n-            if (out.contains(eo)) {\n-                System.err.println(\"Unexpected output found for string: \" + eo);\n-                errors++;\n-            }\n-        }\n-        if (errors > 0) {\n-             throw new AssertionError(\"Unexpected javap output: \" + out);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConstantPropagationTest.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+ * @ignore Verifier error\n@@ -49,1 +50,1 @@\n-    public static primitive class P {\n+    public static class P {\n@@ -62,1 +63,1 @@\n-        Supplier<P.ref> sxp = P::new;\n+        Supplier<P> sxp = P::new;\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConstructorRefTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * @compile\/fail\/ref=ConsumeValueClassAtLowerLevel.out --source 16 -XDrawDiagnostics ConsumeValueClassAtLowerLevel.java\n+ * @compile --source 16 -XDrawDiagnostics ConsumeValueClassAtLowerLevel.java\n@@ -12,4 +12,0 @@\n-        \/* GenericPoint was compiled with a source that allows value classes but ConsumeValueClassAtLowerLevel was not\n-         * so GenericPoint has a <vnew> initializer but in a source that doesn't allow value classes we look for <ini>\n-         * thus the compiler error in the second compilation of ConsumeValueClassAtLowerLevel.java\n-         *\/\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ConsumeValueClassAtLowerLevel.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public class NoAutoInheritanceOfIdentityFlagBit { \/\/ ACC_IDENTITY - concrete class\n+public class NoAutoInheritanceOfIdentityFlagBit { \/\/ ACC_IDENTITY not a value class\n@@ -38,1 +38,1 @@\n-    abstract class A {}  \/\/ ACC_IDENTITY: Inner class\n+    abstract class A {}  \/\/ ACC_IDENTITY not a value class\n@@ -40,1 +40,1 @@\n-    static abstract class B {}  \/\/ NO ACC_IDENTITY: No an inner class with an enclosing instance\n+    static abstract class B {}  \/\/ ACC_IDENTITY not a value class\n@@ -42,3 +42,1 @@\n-    static abstract class C {\n-        int f; \/\/ ACC_IDENTITY since an instance field is declared.\n-    }\n+    static abstract class C {} \/\/ ACC_IDENTITY not a value class\n@@ -50,1 +48,1 @@\n-    static abstract class F extends C {} \/\/ No ACC_IDENTITY - since no auto propagation.\n+    static abstract class F extends C {} \/\/ ACC_IDENTITY no value class\n@@ -62,2 +60,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -78,2 +76,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/NoAutoInheritanceOfIdentityFlagBit.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    public static abstract class A0 { \/\/ Trivial constructor - no induced identity.\n+    public static abstract class A0 { \/\/ ACC_IDENTITY\n@@ -44,2 +44,2 @@\n-    public static abstract class A1 {\n-        private A1() {} \/\/ restricted constructor\n+    public static abstract class A1 { \/\/ ACC_IDENTITY\n+        private A1() {}\n@@ -48,2 +48,2 @@\n-    public static abstract class A2 {\n-        public <T> A2() {} \/\/ generic constructor\n+    public static abstract class A2 { \/\/ ACC_IDENTITY\n+        public <T> A2() {}\n@@ -52,2 +52,2 @@\n-    public static abstract class A3 {\n-        public A3() throws RuntimeException {} \/\/ throws\n+    public static abstract class A3 { \/\/ ACC_IDENTITY\n+        public A3() throws RuntimeException {}\n@@ -56,2 +56,2 @@\n-    public static abstract class A4 {\n-        public A4(int x) {} \/\/ not no-arg\n+    public static abstract class A4 { \/\/ ACC_IDENTITY\n+        public A4(int x) {}\n@@ -60,1 +60,1 @@\n-    public static abstract class A5 {\n+    public static abstract class A5 { \/\/ ACC_IDENTITY\n@@ -68,2 +68,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/NontrivialCtorInducedIdentity.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-       \/\/ NOT ACC_IDENTITY  - flags bits are not auto inherited from extended identity class.\n+       \/\/ ACC_IDENTITY\n@@ -43,1 +43,1 @@\n-    static abstract identity class A1 {\n+    static abstract class A1 {\n@@ -52,1 +52,1 @@\n-        \/\/ NOT ACC_IDENTITY - flags bits are not auto inherited from extended identity class.\n+        \/\/ ACC_IDENTITY\n@@ -56,1 +56,1 @@\n-        \/\/ ACC_IDENTITY as it declares a non-empty initializer block.\n+        \/\/ ACC_IDENTITY\n@@ -63,1 +63,1 @@\n-        \/\/ NOT ACC_IDENTITY as flag bits are not auto inherited from the extended implicit identity class.\n+        \/\/ ACC_IDENTITY\n@@ -67,1 +67,1 @@\n-        \/\/ ACC_IDENTITY as declares a synchronized method.\n+        \/\/ ACC_IDENTITY\n@@ -73,1 +73,1 @@\n-        \/\/ NOT ACC_IDENTITY as flag bits are not auto inherited from the extended implicit identity class.\n+        \/\/ ACC_IDENTITY\n@@ -77,1 +77,1 @@\n-        \/\/ ACC_IDENTITY as it is an inner class\n+        \/\/ ACC_IDENTITY\n@@ -81,1 +81,1 @@\n-        \/\/ ACC_IDENTITY as it defines a arg'ed constructor.\n+        \/\/ ACC_IDENTITY\n@@ -86,1 +86,1 @@\n-        \/\/ !ACC_IDENTITY as its constructor is deemed empty due to mere vacuous chaining.\n+        \/\/ ACC_IDENTITY\n@@ -92,1 +92,1 @@\n-        \/\/ ACC_IDENTITY as it defines a non empty constructor.\n+        \/\/ ACC_IDENTITY\n@@ -98,1 +98,1 @@\n-    static abstract class A11 { \/\/ !ACC_IDENTITY.\n+    static abstract value class A11 { \/\/ ACC_IDENTITY.\n@@ -119,1 +119,1 @@\n-        \/\/ !ACC_IDENTITY\n+        \/\/ ACC_IDENTITY\n@@ -125,2 +125,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -137,2 +137,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -145,2 +145,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -153,2 +153,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should NOT be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -165,2 +165,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n@@ -172,1 +172,1 @@\n-        \/\/ The following are all proper non-identity classes\n+        \/\/ The following two classes are proper non-identity classes\n@@ -182,2 +182,2 @@\n-        if (cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n-            throw new Exception(\"ACC_IDENTITY flag should not be set!\");\n+        if (!cls.access_flags.is(AccessFlags.ACC_IDENTITY))\n+            throw new Exception(\"ACC_IDENTITY flag should be set!\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/PermitsValueTest.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -65,3 +65,1 @@\n-         \/\/ Check that constructor invocation has been lowered into invokestatic\n-         \/\/ of the factory method.\n-         \"4: invokestatic  #10                 \/\/ Method \\\"<vnew>\\\":(II)LValueCreationTest$Point;\",\n+         \"0: new           #8                  \/\/ class ValueCreationTest$Point\",\n@@ -72,17 +70,12 @@\n-         \"static ValueCreationTest$Point ValueCreationTest$Point(int, int);\",\n-         \"descriptor: (II)LValueCreationTest$Point;\",\n-         \"flags: (0x0008) ACC_STATIC\",\n-         \"0: aconst_init   #1                  \/\/ class ValueCreationTest$Point\",\n-         \"3: astore_2\",\n-         \"4: iload_0\",\n-         \"5: aload_2\",\n-         \"6: swap\",\n-         \"7: withfield     #3                  \/\/ Field x:I\",\n-        \"10: astore_2\",\n-        \"11: iload_1\",\n-        \"12: aload_2\",\n-        \"13: swap\",\n-        \"14: withfield     #7                  \/\/ Field y:I\",\n-        \"17: astore_2\",\n-        \"18: aload_2\",\n-        \"19: areturn\"\n+         \"ValueCreationTest$Point(int, int);\",\n+         \"descriptor: (II)V\",\n+         \"flags: (0x0000)\",\n+         \"0: aload_0\",\n+         \"1: invokespecial #1                  \/\/ Method java\/lang\/Object.\\\"<init>\\\":()V\",\n+         \"4: aload_0\",\n+         \"5: iload_1\",\n+         \"6: putfield      #7                  \/\/ Field x:I\",\n+         \"9: aload_0\",\n+        \"10: iload_2\",\n+        \"11: putfield      #13                 \/\/ Field y:I\",\n+        \"14: return\"\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueCreationTest.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng ValueObjectCompilationTests\n+ * @run junit ValueObjectCompilationTests\n@@ -45,0 +45,4 @@\n+import com.sun.tools.javac.util.Assert;\n+\n+import com.sun.tools.classfile.Attribute;\n+import com.sun.tools.classfile.Attributes;\n@@ -57,2 +61,1 @@\n-import static org.testng.Assert.assertTrue;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -64,2 +67,1 @@\n-@Test\n-public class ValueObjectCompilationTests extends CompilationTestCase {\n+class ValueObjectCompilationTests extends CompilationTestCase {\n@@ -71,15 +73,2 @@\n-    public void testAbstractValueClassConstraints() {\n-        assertFail(\"compiler.err.instance.field.not.allowed\",\n-                \"\"\"\n-                abstract value class V {\n-                    int f;  \/\/ Error, abstract value class may not declare an instance field.\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.cannot.be.inner\",\n-                \"\"\"\n-                class Outer {\n-                    abstract value class V {\n-                        \/\/ Error, an abstract value class cant be an inner class\n-                    }\n-                }\n-                \"\"\");\n+    @Test\n+    void testAbstractValueClassConstraints() {\n@@ -94,12 +83,0 @@\n-        assertFail(\"compiler.err.abstract.value.class.declares.init.block\",\n-                \"\"\"\n-                abstract value class V {\n-                    { int f = 42; } \/\/ Error, abstract value class may not declare an instance initializer.\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.take.arguments\",\n-                \"\"\"\n-                abstract value class V {\n-                    V(int x) {}  \/\/ Error, abstract value class may not declare a non-trivial constructor.\n-                }\n-                \"\"\");\n@@ -108,5 +85,2 @@\n-    public void testAnnotationsConstraints() {\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n-                \"\"\"\n-                identity @interface IA {}\n-                \"\"\");\n+    @Test\n+    void testAnnotationsConstraints() {\n@@ -119,1 +93,2 @@\n-    public void testCheckFeatureSourceLevel() {\n+    @Test\n+    void testCheckFeatureSourceLevel() {\n@@ -130,17 +105,2 @@\n-    public void testSuperClassConstraints() {\n-        assertFail(\"compiler.err.instance.field.not.allowed\",\n-                \"\"\"\n-                abstract class I { \/\/ identity class since it declares an instance field.\n-                    int f;\n-                }\n-                value class V extends I {}\n-                \"\"\");\n-\n-        assertFail(\"compiler.err.abstract.value.class.cannot.be.inner\",\n-                \"\"\"\n-                class Outer {\n-                    abstract class I {} \/\/ has identity since is an inner class\n-                    static value class V extends I\n-                }\n-                \"\"\");\n-\n+    @Test\n+    void testSuperClassConstraints() {\n@@ -149,1 +109,1 @@\n-                abstract class I { \/\/ has identity since it declared a synchronized instance method.\n+                abstract class I {\n@@ -154,16 +114,0 @@\n-\n-        assertFail(\"compiler.err.abstract.value.class.declares.init.block\",\n-                \"\"\"\n-                abstract class I { \/\/ has identity since it declares an instance initializer\n-                    { int f = 42; }\n-                }\n-                value class V extends I {}\n-                \"\"\");\n-\n-        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.take.arguments\",\n-                \"\"\"\n-                abstract class I { \/\/ has identity since it declares a non-trivial constructor\n-                    I(int x) {}\n-                }\n-                value class V extends I {}\n-                \"\"\");\n@@ -178,27 +122,9 @@\n-    public void testSynchronizeOnValueInterfaceInstance() {\n-        assertFail(\"compiler.err.type.found.req\",\n-                \"\"\"\n-                value interface VI {\n-                    default void foo(VI vi) {\n-                        synchronized (vi) {} \/\/ Error\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testRepeatedModifiers() {\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            String[] testOptions = {\"-XDenablePrimitiveClasses\"};\n-            setCompileOptions(testOptions);\n-            String[] sources = new String[] {\n-                    \"static static class StaticTest {}\",\n-                    \"native native class NativeTest {}\",\n-                    \"value value primitive class ValueTest {}\",\n-                    \"primitive primitive value class PrimitiveTest {}\"\n-            };\n-            for (String source : sources) {\n-                assertFail(\"compiler.err.repeated.modifier\", source);\n-            }\n-        } finally {\n-            setCompileOptions(previousOptions);\n+    @Test\n+    void testRepeatedModifiers() {\n+        String[] sources = new String[] {\n+                \"static static class StaticTest {}\",\n+                \"native native class NativeTest {}\",\n+                \"value value class ValueTest {}\"\n+        };\n+        for (String source : sources) {\n+            assertFail(\"compiler.err.repeated.modifier\", source);\n@@ -208,1 +134,2 @@\n-    public void testParserTest() {\n+    @Test\n+    void testParserTest() {\n@@ -250,1 +177,2 @@\n-    public void testSemanticsViolations() {\n+    @Test\n+    void testSemanticsViolations() {\n@@ -256,6 +184,0 @@\n-        assertFail(\"compiler.err.abstract.value.class.cannot.be.inner\",\n-                \"\"\"\n-                class Outer {\n-                    abstract value class AbsValue {}\n-                }\n-                \"\"\");\n@@ -299,16 +221,0 @@\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n-                \"\"\"\n-                value identity class ValueIdentity {}\n-                \"\"\");\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n-                \"\"\"\n-                identity value class IdentityValue {}\n-                \"\"\");\n-        assertFail(\"compiler.err.call.to.super.not.allowed.in.value.ctor\",\n-                \"\"\"\n-                value class V {\n-                    V() {\n-                        super();\n-                    }\n-                }\n-                \"\"\");\n@@ -397,164 +303,2 @@\n-    public void testNontrivialConstructor() {\n-        assertOK(\n-                \"\"\"\n-                abstract value class V {\n-                    public V() {} \/\/ trivial ctor\n-                }\n-                \"\"\"\n-        );\n-        assertFail(\"compiler.err.abstract.value.class.constructor.has.weaker.access\",\n-                \"\"\"\n-                abstract value class V {\n-                    private V() {} \/\/ non-trivial, more restrictive access than the class.\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.take.arguments\",\n-                \"\"\"\n-                abstract value class V {\n-                    public V(int x) {} \/\/ non-trivial ctor as it declares formal parameters.\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.be.generic\",\n-                \"\"\"\n-                abstract value class V {\n-                    <T> V() {} \/\/ non trivial as it declares type parameters.\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.constructor.cannot.throw\",\n-                \"\"\"\n-                abstract value class V {\n-                    V() throws Exception {} \/\/ non-trivial as it throws\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.abstract.value.class.no.arg.constructor.must.be.empty\",\n-                \"\"\"\n-                abstract value class V {\n-                    V() {\n-                        System.out.println(\"\");\n-                    } \/\/ non-trivial as it has a body.\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testFunctionalInterface() {\n-        assertFail(\"compiler.err.bad.functional.intf.anno.1\",\n-                \"\"\"\n-                @FunctionalInterface\n-                identity interface I { \/\/ Error\n-                    void m();\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.bad.functional.intf.anno.1\",\n-                \"\"\"\n-                @FunctionalInterface\n-                value interface K { \/\/ Error\n-                    void m();\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                identity interface L {\n-                    void m();\n-                }\n-                class Test {\n-                    void foo() {\n-                        var t = (L) () -> {}; \/\/ Error\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                value interface M {\n-                    void m();\n-                }\n-                class Test {\n-                    void foo() {\n-                        var u = (M) () -> {}; \/\/ Error\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.bad.functional.intf.anno.1\",\n-                \"\"\"\n-                identity interface I {\n-                    void m();\n-                }\n-\n-                @FunctionalInterface\n-                interface J extends I  {}\n-                \"\"\");\n-        assertFail(\"compiler.err.bad.functional.intf.anno.1\",\n-                \"\"\"\n-                value interface I {\n-                    void m();\n-                }\n-\n-                @FunctionalInterface\n-                interface J extends I  {}\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                identity interface I {}\n-                interface K extends I {}\n-                interface J {\n-                    void m();\n-                }\n-                class Test {\n-                    void foo() {\n-                        J j = (J&K)() -> {};\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.prob.found.req\",\n-                \"\"\"\n-                value interface I {}\n-                interface K extends I {}\n-                interface J {\n-                    void m();\n-                }\n-                class Test {\n-                    void foo() {\n-                        J j = (J&K)() -> {};\n-                    }\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testSupers() {\n-        assertFail(\"compiler.err.mutually.incompatible.supers\",\n-                \"\"\"\n-                identity interface II {}\n-                value interface VI {}\n-                abstract class X implements II, VI {}\n-                \"\"\");\n-        assertFail(\"compiler.err.value.type.has.identity.super.type\",\n-                \"\"\"\n-                identity interface II {}\n-                interface GII extends II {} \/\/ OK.\n-                value interface BVI extends GII {} \/\/ Error\n-                \"\"\");\n-        assertFail(\"compiler.err.identity.type.has.value.super.type\",\n-                \"\"\"\n-                value interface VI {}\n-                interface GVI extends VI {} \/\/ OK.\n-                identity interface BII extends GVI {} \/\/ Error\n-                \"\"\");\n-        assertFail(\"compiler.err.value.type.has.identity.super.type\",\n-                \"\"\"\n-                identity interface II {}\n-                value class BVC implements II {} \/\/ Error\n-                \"\"\");\n-        assertFail(\"compiler.err.identity.type.has.value.super.type\",\n-                \"\"\"\n-                value interface VI {}\n-                class BIC implements VI {} \/\/ Error\n-                \"\"\");\n-        assertFail(\"compiler.err.identity.type.has.value.super.type\",\n-                \"\"\"\n-                value interface I {}\n-                class Test {\n-                    I i = new I() {};\n-                }\n-                \"\"\");\n-    }\n-\n-    public void testInteractionWithSealedClasses() {\n+    @Test\n+    void testInteractionWithSealedClasses() {\n@@ -566,1 +310,2 @@\n-        );assertOK(\n+        );\n+        assertOK(\n@@ -568,1 +313,1 @@\n-                abstract sealed value interface SI {}\n+                abstract sealed interface SI {}\n@@ -574,4 +319,4 @@\n-                abstract sealed identity class SC {}\n-                final identity class IC extends SC {}\n-                non-sealed identity class IC2 extends SC {}\n-                final identity class IC3 extends IC2 {}\n+                abstract sealed class SC {}\n+                final class IC extends SC {}\n+                non-sealed class IC2 extends SC {}\n+                final class IC3 extends IC2 {}\n@@ -582,4 +327,4 @@\n-                abstract sealed identity interface SI {}\n-                final identity class IC implements SI {}\n-                non-sealed identity class IC2 implements SI {}\n-                final identity class IC3 extends IC2 {}\n+                abstract sealed interface SI {}\n+                final class IC implements SI {}\n+                non-sealed class IC2 implements SI {}\n+                final class IC3 extends IC2 {}\n@@ -602,1 +347,2 @@\n-    public void testCheckClassFileFlags() throws Exception {\n+    @Test\n+    void testCheckClassFileFlags() throws Exception {\n@@ -623,1 +369,0 @@\n-                    \/\/ abstract inner class is implicitly an `identity` class\n@@ -632,1 +377,1 @@\n-                    assertTrue((classFile.access_flags.flags & Flags.ACC_IDENTITY) != 0);\n+                    Assert.check((classFile.access_flags.flags & Flags.ACC_IDENTITY) != 0);\n@@ -639,2 +384,1 @@\n-                identity interface I {}\n-                class Sub implements I {}\n+                class C {}\n@@ -644,1 +388,0 @@\n-                    \/\/ declares a non-static field so it is implicitly an identity class\n@@ -650,1 +393,0 @@\n-                    \/\/ declares a synchronized method so it is implicitly an identity class\n@@ -656,1 +398,0 @@\n-                    \/\/ declares a synchronized method so it is implicitly an identity class\n@@ -663,1 +404,0 @@\n-                    \/\/ declares an instance initializer so it is implicitly an identity class\n@@ -669,1 +409,0 @@\n-                    \/\/ declares a non-trivial constructor\n@@ -676,3 +415,0 @@\n-                \"\"\"\n-                    identity enum E {}\n-                \"\"\",\n@@ -681,3 +417,0 @@\n-                \"\"\",\n-                \"\"\"\n-                   identity record R() {}\n@@ -689,2 +422,1 @@\n-                assertTrue(classFile.access_flags.is(Flags.ACC_IDENTITY));\n-                assertTrue(!classFile.access_flags.is(Flags.VALUE_CLASS));\n+                Assert.check(classFile.access_flags.is(Flags.ACC_IDENTITY));\n@@ -697,4 +429,3 @@\n-                            value interface I {}\n-                            abstract class A implements I {} \/\/ not a value class as it doens't have the value modifier\n-                            value class Sub extends A {} \/\/implicitly final\n-                            \"\"\";\n+                    abstract value class A {}\n+                    value class Sub extends A {} \/\/implicitly final\n+                    \"\"\";\n@@ -706,1 +437,1 @@\n-                        assertTrue((classFile.access_flags.flags & (Flags.VALUE_CLASS | Flags.FINAL)) != 0);\n+                        Assert.check((classFile.access_flags.flags & (Flags.VALUE_CLASS | Flags.FINAL)) != 0);\n@@ -709,4 +440,1 @@\n-                        assertTrue((classFile.access_flags.flags & (Flags.ABSTRACT)) != 0);\n-                        break;\n-                    case \"I\":\n-                        assertTrue((classFile.access_flags.flags & (Flags.INTERFACE | Flags.VALUE_CLASS)) != 0);\n+                        Assert.check((classFile.access_flags.flags & (Flags.ABSTRACT)) != 0);\n@@ -742,1 +470,1 @@\n-                        assertTrue(field.access_flags.is(Flags.FINAL));\n+                        Assert.check(field.access_flags.is(Flags.FINAL));\n@@ -749,2 +477,3 @@\n-    public void testCheckVnew() throws Exception {\n-        for (String source : List.of(\n+    @Test\n+    void testSelectors() throws Exception {\n+        assertOK(\n@@ -752,2 +481,5 @@\n-                abstract value class A {}\n-                \"\"\",\n+                value class V {\n+                    void selector() {\n+                        Class<?> c = int.class;\n+                    }\n+                }\n@@ -755,1 +487,2 @@\n-                value class A {}\n+        );\n+        assertFail(\"compiler.err.expected\",\n@@ -757,14 +490,3 @@\n-        )) {\n-            File dir = assertOK(true, source);\n-            for (final File fileEntry : dir.listFiles()) {\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                boolean isAbstract = classFile.access_flags.is(Flags.ABSTRACT);\n-                for (Method method : classFile.methods) {\n-                    if (isAbstract) {\n-                        assertTrue(method.getName(classFile.constant_pool).equals(\"<init>\"));\n-                        assertTrue(!method.access_flags.is(Flags.STATIC));\n-                    } else {\n-                        assertTrue(method.getName(classFile.constant_pool).equals(\"<vnew>\"));\n-                        assertTrue(method.access_flags.is(Flags.STATIC));\n-                        assertTrue(!method.access_flags.is(Flags.ABSTRACT));\n-                        assertTrue(method.descriptor.getReturnType(classFile.constant_pool).equals(\"A\"));\n+                value class V {\n+                    void selector() {\n+                        int i = int.some_selector;\n@@ -773,0 +495,8 @@\n+                \"\"\"\n+        );\n+    }\n+\n+    private File findClassFileOrFail(File dir, String name) {\n+        for (final File fileEntry : dir.listFiles()) {\n+            if (fileEntry.getName().equals(name)) {\n+                return fileEntry;\n@@ -775,0 +505,2 @@\n+        throw new AssertionError(\"file not found\");\n+    }\n@@ -776,28 +508,8 @@\n-        \/\/ check that <vnew> is invoked with invokestatic\n-        for (String source : List.of(\n-                \"\"\"\n-                value class A {\n-                    void FIND_ME() {\n-                        A a = new A();\n-                    }\n-                }\n-                \"\"\"\n-        )) {\n-            File dir = assertOK(true, source);\n-            for (final File fileEntry : dir.listFiles()) {\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Method method : classFile.methods) {\n-                    if (method.getName(classFile.constant_pool).equals(\"FIND_ME\")) {\n-                        Code_attribute code_attribute = (Code_attribute)method.attributes.get(\"Code\");\n-                        boolean firstInst = true;\n-                        for (Instruction inst: code_attribute.getInstructions()) {\n-                            if (firstInst) {\n-                                assertTrue(inst.getMnemonic().equals(\"invokestatic\"));\n-                                CONSTANT_Methodref_info methodInfo =\n-                                        (CONSTANT_Methodref_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n-                                assertTrue(methodInfo.getClassInfo().getName().equals(\"A\"));\n-                                assertTrue(methodInfo.getNameAndTypeInfo().getName().equals(\"<vnew>\"));\n-                                break;\n-                            }\n-                        }\n-                    }\n+    private Attribute findAttributeOrFail(Attributes attributes, Class<? extends Attribute> attrClass, int numberOfAttributes) {\n+        int attrCount = 0;\n+        Attribute result = null;\n+        for (Attribute attribute : attributes) {\n+            if (attribute.getClass() == attrClass) {\n+                attrCount++;\n+                if (result == null) {\n+                    result = attribute;\n@@ -807,0 +519,4 @@\n+        if (attrCount == 0) throw new AssertionError(\"attribute not found\");\n+        if (attrCount != numberOfAttributes) throw new AssertionError(\"incorrect number of attributes found\");\n+        return result;\n+    }\n@@ -808,38 +524,4 @@\n-        \/\/ checking the aconst_init and withfield instructions\n-        for (String source : List.of(\n-                \"\"\"\n-                value class A {\n-                    int i;\n-                    String s;\n-\n-                    A(int i, String s) {\n-                        this.i = i;\n-                        this.s = s;\n-                    }\n-                }\n-                \"\"\"\n-        )) {\n-            File dir = assertOK(true, source);\n-            for (final File fileEntry : dir.listFiles()) {\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (Method method : classFile.methods) {\n-                    if (method.getName(classFile.constant_pool).equals(\"<vnew>\")) {\n-                        Code_attribute code_attribute = (Code_attribute)method.attributes.get(\"Code\");\n-                        for (Instruction inst: code_attribute.getInstructions()) {\n-                            if (inst.getMnemonic().equals(\"aconst_init\")) {\n-                                CONSTANT_Class_info classInfo =\n-                                        (CONSTANT_Class_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n-                                assertTrue(classInfo.getName().equals(\"A\"));\n-                            } else if (inst.getMnemonic().equals(\"withfield\")) {\n-                                CONSTANT_Fieldref_info fieldInfo = (CONSTANT_Fieldref_info)classFile.constant_pool.get(inst.getUnsignedShort(1));\n-                                assertTrue(fieldInfo.getClassName().equals(\"A\"));\n-                                ConstantPool.CONSTANT_NameAndType_info nameAndType = fieldInfo.getNameAndTypeInfo();\n-                                if (nameAndType.getName().equals(\"i\")) {\n-                                    assertTrue(nameAndType.getType().equals(\"I\"));\n-                                } else if (nameAndType.getName().equals(\"s\")) {\n-                                    assertTrue(nameAndType.getType().equals(\"Ljava\/lang\/String;\"));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+    private void checkAttributeNotPresent(Attributes attributes, Class<? extends Attribute> attrClass) {\n+        for (Attribute attribute : attributes) {\n+            if (attribute.getClass() == attrClass) {\n+                throw new AssertionError(\"attribute found\");\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":93,"deletions":411,"binary":false,"changes":504,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectsBinaryCompatibilityTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @summary Check various withfield constrains\n- * @compile\/fail\/ref=WithFieldNegativeTests.out -XDrawDiagnostics -XDenablePrimitiveClasses WithFieldNegativeTests.java\n- *\/\n-\n-value final class A {\n-    final int x = 10;\n-    static final int sx = 10;\n-\n-    value final class B {\n-\n-        final A a = A.default;\n-\n-        void foo(A a) {\n-            a.x = 100;\n-            a.sx = 100;\n-        }\n-    }\n-\n-    void withfield(B b) {\n-            b.a.x = 11;\n-    }\n-\n-    void foo(A a, final A fa) {\n-        a.x = 100;\n-        (a).x = 100;\n-        fa.x = 100;\n-        x = 100;\n-        this.x = 100;\n-        A.this.x = 100;\n-    }\n-}\n-\n-class C {\n-    void foo(A a) {\n-        a.x = 100;\n-        a.sx = 100;\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/WithFieldNegativeTests.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-WithFieldNegativeTests.java:16:14: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:17:14: compiler.err.cant.assign.val.to.var: static final, sx\n-WithFieldNegativeTests.java:22:16: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:26:10: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:27:12: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:28:11: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:29:9: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:30:13: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:31:15: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:37:10: compiler.err.cant.assign.val.to.var: final, x\n-WithFieldNegativeTests.java:38:10: compiler.err.cant.assign.val.to.var: static final, sx\n-11 errors\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/WithFieldNegativeTests.out","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8205686 8215109\n- * @summary __WithField seems to have trouble if the value type is a generic type.\n- * @compile -XDrawDiagnostics -XDdev WithFieldOfGenericType.java\n- * @run main\/othervm WithFieldOfGenericType\n- *\/\n-\n-public final value class WithFieldOfGenericType<E> {\n-  private final boolean value;\n-\n-  public static <E> WithFieldOfGenericType<E> create() {\n-    return new WithFieldOfGenericType<>(true);\n-  }\n-\n-  private WithFieldOfGenericType(boolean value) {\n-    this.value = value;\n-  }\n-\n-  public static void main(String[] args) {\n-     WithFieldOfGenericType<String> w = create();\n-     if (w.value != true)\n-        throw new AssertionError(\"Withfield didn't work!\");\n-  }\n-}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/WithFieldOfGenericType.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/class_flags\/CheckClassfileFlagsTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/lworld-values\/classfile_flags\/CheckClassfileFlagsTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,2 @@\n+CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.signature: \"QValueWithInvalidFlags;\"))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/class_flags\/CheckClassfileFlagsTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/class_flags\/ValueWithInvalidFlags.jcod","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/lworld-values\/classfile_flags\/ValueWithInvalidFlags.jcod","status":"renamed"},{"patch":"@@ -1,2 +0,0 @@\n-CheckClassfileFlagsTest.java:15:9: compiler.err.cant.access: ValueWithInvalidFlags, (compiler.misc.bad.class.file.header: ValueWithInvalidFlags.class, (compiler.misc.bad.class.signature: \"QValueWithInvalidFlags;\"))\n-1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/lworld-values\/classfile_flags\/CheckClassfileFlagsTest.out","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -33,0 +33,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/separate_compilation\/ConcreteValue.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}