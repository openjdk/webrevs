{"files":[{"patch":"@@ -1177,1 +1177,1 @@\n-            version: \"7.5.2\",\n+            version: \"7.5.1\",\n@@ -1179,1 +1179,1 @@\n-            file: \"bundles\/jtreg-7.5.2+1.zip\",\n+            file: \"bundles\/jtreg-7.5.1+1.zip\",\n@@ -1479,0 +1479,1 @@\n+        args = concat(args, \"--with-version-pre=\" + version_numbers.get(\"DEFAULT_PROMOTED_VERSION_PRE\"));\n","filename":"make\/conf\/jib-profiles.js","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+include gensrc\/GensrcValueClasses.gmk\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1657,0 +1657,3 @@\n+  } else if (_entry_point == nullptr) {\n+    \/\/ See CallLeafNoFPIndirect\n+    return 1 * NativeInstruction::instruction_size;\n@@ -1765,3 +1768,0 @@\n-  \/\/ n.b. frame size includes space for return pc and rfp\n-  const int framesize = C->output()->frame_size_in_bytes();\n-\n@@ -1772,4 +1772,1 @@\n-  if (C->clinit_barrier_on_entry()) {\n-    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n-\n-    Label L_skip_barrier;\n+  __ verified_entry(C, 0);\n@@ -1777,8 +1774,2 @@\n-    __ mov_metadata(rscratch2, C->method()->holder()->constant_encoding());\n-    __ clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);\n-    __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n-    __ bind(L_skip_barrier);\n-  }\n-\n-  if (C->max_vector_size() > 0) {\n-    __ reinitialize_ptrue();\n+  if (C->stub_function() == nullptr) {\n+    __ entry_barrier();\n@@ -1787,25 +1778,2 @@\n-  int bangsize = C->output()->bang_size_in_bytes();\n-  if (C->output()->need_stack_bang(bangsize))\n-    __ generate_stack_overflow_check(bangsize);\n-\n-  __ build_frame(framesize);\n-\n-  if (C->stub_function() == nullptr) {\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    \/\/ Dummy labels for just measuring the code size\n-    Label dummy_slow_path;\n-    Label dummy_continuation;\n-    Label dummy_guard;\n-    Label* slow_path = &dummy_slow_path;\n-    Label* continuation = &dummy_continuation;\n-    Label* guard = &dummy_guard;\n-    if (!Compile::current()->output()->in_scratch_emit_size()) {\n-      \/\/ Use real labels from actual stub when not emitting code for the purpose of measuring its size\n-      C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n-      Compile::current()->output()->add_stub(stub);\n-      slow_path = &stub->entry();\n-      continuation = &stub->continuation();\n-      guard = &stub->guard();\n-    }\n-    \/\/ In the C2 code, we move the non-hot part of nmethod entry barriers out-of-line to a stub.\n-    bs->nmethod_entry_barrier(masm, slow_path, continuation, guard);\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    __ bind(*_verified_entry);\n@@ -1828,6 +1796,0 @@\n-uint MachPrologNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n@@ -1876,1 +1838,1 @@\n-  __ remove_frame(framesize);\n+  __ remove_frame(framesize, C->needs_stack_repair());\n@@ -1895,5 +1857,0 @@\n-uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {\n-  \/\/ Variable size. Determine dynamically.\n-  return MachNode::size(ra_);\n-}\n-\n@@ -2195,1 +2152,12 @@\n-\/\/=============================================================================\n+\/\/\/=============================================================================\n+#ifndef PRODUCT\n+void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n+{\n+  st->print_cr(\"# MachVEPNode\");\n+  if (!_verified) {\n+    st->print_cr(\"\\t load_class\");\n+  } else {\n+    st->print_cr(\"\\t unpack_inline_arg\");\n+  }\n+}\n+#endif\n@@ -2197,0 +2165,31 @@\n+void MachVEPNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc* ra_) const\n+{\n+  if (!_verified) {\n+    __ ic_check(1);\n+  } else {\n+    \/\/ insert a nop at the start of the prolog so we can patch in a\n+    \/\/ branch if we need to invalidate the method later\n+    __ nop();\n+\n+    \/\/ TODO 8284443 Avoid creation of temporary frame\n+    if (ra_->C->stub_function() == nullptr) {\n+      __ verified_entry(ra_->C, 0);\n+      __ entry_barrier();\n+      int framesize = ra_->C->output()->frame_slots() << LogBytesPerInt;\n+      __ remove_frame(framesize, false);\n+    }\n+    \/\/ Unpack inline type args passed as oop and then jump to\n+    \/\/ the verified entry point (skipping the unverified entry).\n+    int sp_inc = __ unpack_inline_args(ra_->C, _receiver_only);\n+    \/\/ Emit code for verified entry and save increment for stack repair on return\n+    __ verified_entry(ra_->C, sp_inc);\n+    if (Compile::current()->output()->in_scratch_emit_size()) {\n+      Label dummy_verified_entry;\n+      __ b(dummy_verified_entry);\n+    } else {\n+      __ b(*_verified_entry);\n+    }\n+  }\n+}\n+\n+\/\/=============================================================================\n@@ -2219,5 +2218,0 @@\n-uint MachUEPNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_);\n-}\n-\n@@ -3716,0 +3710,31 @@\n+    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic() && _method->return_type()->is_loaded()) {\n+      \/\/ The last return value is not set by the callee but used to pass the null marker to compiled code.\n+      \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n+      uint con = (tf()->range_cc()->cnt() - 1);\n+      for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+        ProjNode* proj = fast_out(i)->as_Proj();\n+        if (proj->_con == con) {\n+          \/\/ Set null marker if r0 is non-null (a non-null value is returned buffered or scalarized)\n+          OptoReg::Name optoReg = ra_->get_reg_first(proj);\n+          VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n+          Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n+          __ cmp(r0, zr);\n+          __ cset(toReg, Assembler::NE);\n+          if (reg->is_stack()) {\n+            int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n+            __ str(toReg, Address(sp, st_off));\n+          }\n+          break;\n+        }\n+      }\n+      if (return_value_is_used()) {\n+        \/\/ An inline type is returned as fields in multiple registers.\n+        \/\/ R0 either contains an oop if the inline type is buffered or a pointer\n+        \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero r0\n+        \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+        \/\/ r0 &= (r0 & 1) - 1\n+        __ andr(rscratch1, r0, 0x1);\n+        __ sub(rscratch1, rscratch1, 0x1);\n+        __ andr(r0, r0, rscratch1);\n+      }\n+    }\n@@ -6825,1 +6850,1 @@\n-    \"mov  $dst, $con\\t# ptr\\n\\t\"\n+    \"mov  $dst, $con\\t# ptr\"\n@@ -8034,0 +8059,30 @@\n+instruct castI2N(iRegNNoSp dst, iRegI src) %{\n+  match(Set dst (CastI2N src));\n+\n+  ins_cost(INSN_COST);\n+  format %{ \"mov $dst, $src\\t# int -> narrow ptr\" %}\n+\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ mov(as_Register($dst$$reg), as_Register($src$$reg));\n+    }\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct castN2X(iRegLNoSp dst, iRegN src) %{\n+  match(Set dst (CastP2X src));\n+\n+  ins_cost(INSN_COST);\n+  format %{ \"mov $dst, $src\\t# ptr -> long\" %}\n+\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ mov(as_Register($dst$$reg), as_Register($src$$reg));\n+    }\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -14987,1 +15042,1 @@\n-instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, Universe dummy, rFlagsReg cr)\n+instruct clearArray_reg_reg_immL0(iRegL_R11 cnt, iRegP_R10 base, immL0 zero, Universe dummy, rFlagsReg cr)\n@@ -14989,1 +15044,1 @@\n-  match(Set dummy (ClearArray cnt base));\n+  match(Set dummy (ClearArray (Binary cnt base) zero));\n@@ -15006,0 +15061,16 @@\n+instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, iRegL val, Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->word_copy_only());\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, KILL cr);\n+\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ClearArray $cnt, $base, $val\" %}\n+\n+  ins_encode %{\n+    __ fill_words($base$$Register, $cnt$$Register, $val$$Register);\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -15009,1 +15080,2 @@\n-            < (uint64_t)(BlockZeroingLowLimit >> LogBytesPerWord));\n+            < (uint64_t)(BlockZeroingLowLimit >> LogBytesPerWord)\n+            && !((ClearArrayNode*)n)->word_copy_only());\n@@ -16360,0 +16432,18 @@\n+\/\/ entry point is null, target holds the address to call\n+instruct CallLeafNoFPIndirect(iRegP target)\n+%{\n+  predicate(n->as_Call()->entry_point() == nullptr);\n+\n+  match(CallLeafNoFP target);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"CALL, runtime leaf nofp indirect $target\" %}\n+\n+  ins_encode %{\n+    __ blr($target$$Register);\n+  %}\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n@@ -16362,0 +16452,2 @@\n+  predicate(n->as_Call()->entry_point() != nullptr);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":154,"deletions":62,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -37,0 +38,4 @@\n+#include \"runtime\/signature.hpp\"\n+\n+\n+class ciInlineKlass;\n@@ -679,0 +684,22 @@\n+  \/\/ markWord tests, kills markWord reg\n+  void test_markword_is_inline_type(Register markword, Label& is_inline_type);\n+\n+  \/\/ inlineKlass queries, kills temp_reg\n+  void test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type, bool can_be_null = true);\n+\n+  void test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free);\n+  void test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free);\n+  void test_field_is_flat(Register flags, Register temp_reg, Label& is_flat);\n+  void test_field_has_null_marker(Register flags, Register temp_reg, Label& has_null_marker);\n+\n+  \/\/ Check oops for special arrays, i.e. flat arrays and\/or null-free arrays\n+  void test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label);\n+  void test_flat_array_oop(Register klass, Register temp_reg, Label& is_flat_array);\n+  void test_non_flat_array_oop(Register oop, Register temp_reg, Label&is_non_flat_array);\n+  void test_null_free_array_oop(Register oop, Register temp_reg, Label& is_null_free_array);\n+  void test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array);\n+\n+  \/\/ Check array klass layout helper for flat or null-free arrays...\n+  void test_flat_array_layout(Register lh, Label& is_flat_array);\n+  void test_non_flat_array_layout(Register lh, Label& is_non_flat_array);\n+\n@@ -916,0 +943,2 @@\n+  void load_metadata(Register dst, Register src);\n+\n@@ -932,0 +961,9 @@\n+  void flat_field_copy(DecoratorSet decorators, Register src, Register dst, Register inline_layout_info);\n+\n+  \/\/ inline type data payload offsets...\n+  void payload_offset(Register inline_klass, Register offset);\n+  void payload_address(Register oop, Register data, Register inline_klass);\n+  \/\/ get data payload ptr a flat value array at index, kills rcx and index\n+  void data_for_value_array_index(Register array, Register array_klass,\n+                                  Register index, Register data);\n+\n@@ -945,0 +983,2 @@\n+  void load_prototype_header(Register dst, Register src);\n+\n@@ -997,0 +1037,9 @@\n+\n+  \/\/ Object \/ value buffer allocation...\n+  \/\/ Allocate instance of klass, assumes klass initialized by caller\n+  \/\/ new_obj prefers to be rax\n+  \/\/ Kills t1 and t2, perserves klass, return allocation in new_obj (rsi on LP64)\n+  void allocate_instance(Register klass, Register new_obj,\n+                         Register t1, Register t2,\n+                         bool clear_fields, Label& alloc_failed);\n+\n@@ -1007,0 +1056,5 @@\n+  \/\/ For field \"index\" within \"klass\", return inline_klass ...\n+  void get_inline_type_field_klass(Register klass, Register index, Register inline_klass);\n+  void inline_layout_info(Register holder_klass, Register index, Register layout_info);\n+\n+\n@@ -1472,0 +1526,18 @@\n+  void verified_entry(Compile* C, int sp_inc);\n+\n+  \/\/ Inline type specific methods\n+  #include \"asm\/macroAssembler_common.hpp\"\n+\n+  int store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter = true);\n+  bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[]);\n+  bool unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index,\n+                            VMReg from, int& from_index, VMRegPair* to, int to_count, int& to_index,\n+                            RegState reg_state[]);\n+  bool pack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, int vtarg_index,\n+                          VMRegPair* from, int from_count, int& from_index, VMReg to,\n+                          RegState reg_state[], Register val_array);\n+  int extend_stack_for_inline_args(int args_on_stack);\n+  void remove_frame(int initial_framesize, bool needs_stack_repair);\n+  VMReg spill_reg_for(VMReg reg);\n+  void save_stack_increment(int sp_inc, int frame_size);\n+\n@@ -1543,0 +1615,2 @@\n+  void fill_words(Register base, uint64_t cnt, Register value);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -618,0 +618,4 @@\n+  if (_entry_point == nullptr) {\n+    \/\/ CallLeafNoFPInDirect\n+    return 3; \/\/ callq (register)\n+  }\n@@ -624,0 +628,1 @@\n+\n@@ -849,14 +854,1 @@\n-  int framesize = C->output()->frame_size_in_bytes();\n-  int bangsize = C->output()->bang_size_in_bytes();\n-\n-  if (C->clinit_barrier_on_entry()) {\n-    assert(VM_Version::supports_fast_class_init_checks(), \"sanity\");\n-    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n-\n-    Label L_skip_barrier;\n-    Register klass = rscratch1;\n-\n-    __ mov_metadata(klass, C->method()->holder()->constant_encoding());\n-    __ clinit_barrier(klass, &L_skip_barrier \/*L_fast_path*\/);\n-\n-    __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); \/\/ slow path\n+  __ verified_entry(C);\n@@ -864,1 +856,2 @@\n-    __ bind(L_skip_barrier);\n+  if (ra_->C->stub_function() == nullptr) {\n+    __ entry_barrier();\n@@ -867,1 +860,3 @@\n-  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, false, C->stub_function() != nullptr);\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    __ bind(*_verified_entry);\n+  }\n@@ -879,6 +874,0 @@\n-uint MachPrologNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n@@ -931,13 +920,3 @@\n-  int framesize = C->output()->frame_size_in_bytes();\n-  assert((framesize & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n-  \/\/ Remove word for return adr already pushed\n-  \/\/ and RBP\n-  framesize -= 2*wordSize;\n-\n-  \/\/ Note that VerifyStackAtCalls' Majik cookie does not change the frame size popped here\n-\n-  if (framesize) {\n-    __ addq(rsp, framesize);\n-  }\n-\n-  __ popq(rbp);\n+  \/\/ Subtract two words to account for return address and rbp\n+  int initial_framesize = C->output()->frame_size_in_bytes() - 2*wordSize;\n+  __ remove_frame(initial_framesize, C->needs_stack_repair());\n@@ -962,6 +941,0 @@\n-uint MachEpilogNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n@@ -1569,0 +1542,43 @@\n+\/\/=============================================================================\n+#ifndef PRODUCT\n+void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n+{\n+  st->print_cr(\"MachVEPNode\");\n+}\n+#endif\n+\n+void MachVEPNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra_) const\n+{\n+  CodeBuffer* cbuf = masm->code();\n+  uint insts_size = cbuf->insts_size();\n+  if (!_verified) {\n+    __ ic_check(1);\n+  } else {\n+    \/\/ TODO 8284443 Avoid creation of temporary frame\n+    if (ra_->C->stub_function() == nullptr) {\n+      __ verified_entry(ra_->C, 0);\n+      __ entry_barrier();\n+      int initial_framesize = ra_->C->output()->frame_size_in_bytes() - 2*wordSize;\n+      __ remove_frame(initial_framesize, false);\n+    }\n+    \/\/ Unpack inline type args passed as oop and then jump to\n+    \/\/ the verified entry point (skipping the unverified entry).\n+    int sp_inc = __ unpack_inline_args(ra_->C, _receiver_only);\n+    \/\/ Emit code for verified entry and save increment for stack repair on return\n+    __ verified_entry(ra_->C, sp_inc);\n+    if (Compile::current()->output()->in_scratch_emit_size()) {\n+      Label dummy_verified_entry;\n+      __ jmp(dummy_verified_entry);\n+    } else {\n+      __ jmp(*_verified_entry);\n+    }\n+  }\n+  \/* WARNING these NOPs are critical so that verified entry point is properly\n+     4 bytes aligned for patching by NativeJump::patch_verified_entry() *\/\n+  int nops_cnt = 4 - ((cbuf->insts_size() - insts_size) & 0x3);\n+  nops_cnt &= 0x3; \/\/ Do not add nops if code is aligned.\n+  if (nops_cnt > 0) {\n+    __ nop(nops_cnt);\n+  }\n+}\n+\n@@ -1589,7 +1605,0 @@\n-uint MachUEPNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n-\n@@ -3070,0 +3079,16 @@\n+\/\/ Indirect Narrow Oop Operand\n+operand indCompressedOop(rRegN reg) %{\n+  predicate(UseCompressedOops && (CompressedOops::shift() == Address::times_8));\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(DecodeN reg);\n+\n+  op_cost(10);\n+  format %{\"[R12 + $reg << 3] (compressed oop addressing)\" %}\n+  interface(MEMORY_INTER) %{\n+    base(0xc); \/\/ R12\n+    index($reg);\n+    scale(0x3);\n+    disp(0x0);\n+  %}\n+%}\n+\n@@ -3416,1 +3441,1 @@\n-               indCompressedOopOffset,\n+               indCompressedOop, indCompressedOopOffset,\n@@ -5957,0 +5982,26 @@\n+instruct castI2N(rRegN dst, rRegI src)\n+%{\n+  match(Set dst (CastI2N src));\n+\n+  format %{ \"movq    $dst, $src\\t# int -> narrow ptr\" %}\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ movl($dst$$Register, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg); \/\/ XXX\n+%}\n+\n+instruct castN2X(rRegL dst, rRegN src)\n+%{\n+  match(Set dst (CastP2X src));\n+\n+  format %{ \"movq    $dst, $src\\t# ptr -> long\" %}\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ movptr($dst$$Register, $src$$Register);\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg); \/\/ XXX\n+%}\n+\n@@ -12088,0 +12139,1 @@\n+\n@@ -12090,1 +12142,1 @@\n-instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,\n+instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n@@ -12093,3 +12145,120 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() && (UseAVX <= 2));\n-  match(Set dummy (ClearArray cnt base));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"jg      LARGE\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"jge     LOOP\\n\\t\"\n+    $$emit$$\"jmp     DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseFastStosb) {\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n+                            Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    $$emit$$\"cmp     InitArrayShortSize,rcx\\n\\t\"\n+    $$emit$$\"jg      LARGE\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"js      DONE\\t# Zero length\\n\\t\"\n+    $$emit$$\"mov     rax,(rdi,rcx,8)\\t# LOOP\\n\\t\"\n+    $$emit$$\"dec     rcx\\n\\t\"\n+    $$emit$$\"jge     LOOP\\n\\t\"\n+    $$emit$$\"jmp     DONE\\n\\t\"\n+    $$emit$$\"# LARGE:\\n\\t\"\n+    if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\\n\\t\"\n+    }\n+    $$emit$$\"# DONE\"\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Small non-constant length ClearArray for AVX512 targets.\n+instruct rep_stos_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                       Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  ins_cost(125);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -12143,2 +12312,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, false, knoreg);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, false, $ktmp$$KRegister);\n@@ -12149,3 +12318,2 @@\n-\/\/ Small non-constant length ClearArray for AVX512 targets.\n-instruct rep_stos_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegI zero,\n-                       Universe dummy, rFlagsReg cr)\n+instruct rep_stos_evex_word_copy(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                                 Universe dummy, rFlagsReg cr)\n@@ -12153,2 +12321,2 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() && (UseAVX > 2));\n-  match(Set dummy (ClearArray cnt base));\n+  predicate(!((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n@@ -12156,1 +12324,1 @@\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, KILL zero, KILL cr);\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -12204,2 +12372,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, false, $ktmp$$KRegister);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, false, true, $ktmp$$KRegister);\n@@ -12211,1 +12379,1 @@\n-instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,\n+instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n@@ -12214,3 +12382,99 @@\n-  predicate((UseAVX <=2) && ((ClearArrayNode*)n)->is_large());\n-  match(Set dummy (ClearArray cnt base));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);\n+  predicate(((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    if (UseFastStosb) {\n+       $$emit$$\"shlq    rcx,3\\t# Convert doublewords to bytes\\n\\t\"\n+       $$emit$$\"rep     stosb\\t# Store rax to *rdi++ while rcx--\"\n+    } else if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n+    }\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,\n+                                  Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX <= 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, USE_KILL val, KILL cr);\n+\n+  format %{ $$template\n+    if (UseXMMForObjInit) {\n+       $$emit$$\"movdq   $tmp, $val\\n\\t\"\n+       $$emit$$\"punpcklqdq $tmp, $tmp\\n\\t\"\n+       $$emit$$\"vinserti128_high $tmp, $tmp\\n\\t\"\n+       $$emit$$\"jmpq    L_zero_64_bytes\\n\\t\"\n+       $$emit$$\"# L_loop:\\t# 64-byte LOOP\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,0x20(rax)\\n\\t\"\n+       $$emit$$\"add     0x40,rax\\n\\t\"\n+       $$emit$$\"# L_zero_64_bytes:\\n\\t\"\n+       $$emit$$\"sub     0x8,rcx\\n\\t\"\n+       $$emit$$\"jge     L_loop\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jl      L_tail\\n\\t\"\n+       $$emit$$\"vmovdqu $tmp,(rax)\\n\\t\"\n+       $$emit$$\"add     0x20,rax\\n\\t\"\n+       $$emit$$\"sub     0x4,rcx\\n\\t\"\n+       $$emit$$\"# L_tail:\\t# Clearing tail bytes\\n\\t\"\n+       $$emit$$\"add     0x4,rcx\\n\\t\"\n+       $$emit$$\"jle     L_end\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"# L_sloop:\\t# 8-byte short loop\\n\\t\"\n+       $$emit$$\"vmovq   xmm0,(rax)\\n\\t\"\n+       $$emit$$\"add     0x8,rax\\n\\t\"\n+       $$emit$$\"dec     rcx\\n\\t\"\n+       $$emit$$\"jge     L_sloop\\n\\t\"\n+       $$emit$$\"# L_end:\\n\\t\"\n+    } else {\n+       $$emit$$\"rep     stosq\\t# Store rax to *rdi++ while rcx--\"\n+    }\n+  %}\n+  ins_encode %{\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Large non-constant length ClearArray for AVX512 targets.\n+instruct rep_stos_large_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                             Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -12255,2 +12519,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, true, knoreg);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, false, $ktmp$$KRegister);\n@@ -12261,3 +12525,2 @@\n-\/\/ Large non-constant length ClearArray for AVX512 targets.\n-instruct rep_stos_large_evex(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegI zero,\n-                             Universe dummy, rFlagsReg cr)\n+instruct rep_stos_large_evex_word_copy(rcx_RegL cnt, rdi_RegP base, legRegD tmp, kReg ktmp, rax_RegL val,\n+                                       Universe dummy, rFlagsReg cr)\n@@ -12265,3 +12528,3 @@\n-  predicate((UseAVX > 2) && ((ClearArrayNode*)n)->is_large());\n-  match(Set dummy (ClearArray cnt base));\n-  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, KILL zero, KILL cr);\n+  predicate(((ClearArrayNode*)n)->is_large() && ((ClearArrayNode*)n)->word_copy_only() && (UseAVX > 2));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, TEMP tmp, TEMP ktmp, USE_KILL val, KILL cr);\n@@ -12306,2 +12569,2 @@\n-    __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,\n-                 $tmp$$XMMRegister, true, $ktmp$$KRegister);\n+    __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,\n+                 $tmp$$XMMRegister, true, true, $ktmp$$KRegister);\n@@ -12313,1 +12576,1 @@\n-instruct rep_stos_im(immL cnt, rRegP base, regD tmp, rRegI zero, kReg ktmp, Universe dummy, rFlagsReg cr)\n+instruct rep_stos_im(immL cnt, rRegP base, regD tmp, rax_RegL val, kReg ktmp, Universe dummy, rFlagsReg cr)\n@@ -12315,2 +12578,3 @@\n-  predicate(!((ClearArrayNode*)n)->is_large() && (MaxVectorSize >= 32) && VM_Version::supports_avx512vl());\n-  match(Set dummy (ClearArray cnt base));\n+  predicate(!((ClearArrayNode*)n)->is_large() && !((ClearArrayNode*)n)->word_copy_only() &&\n+            ((MaxVectorSize >= 32) && VM_Version::supports_avx512vl()));\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n@@ -12318,1 +12582,1 @@\n-  effect(TEMP tmp, TEMP zero, TEMP ktmp, KILL cr);\n+  effect(TEMP tmp, USE_KILL val, TEMP ktmp, KILL cr);\n@@ -12321,1 +12585,1 @@\n-   __ clear_mem($base$$Register, $cnt$$constant, $zero$$Register, $tmp$$XMMRegister, $ktmp$$KRegister);\n+    __ clear_mem($base$$Register, $cnt$$constant, $val$$Register, $tmp$$XMMRegister, $ktmp$$KRegister);\n@@ -14194,0 +14458,15 @@\n+\/\/ entry point is null, target holds the address to call\n+instruct CallLeafNoFPInDirect(rRegP target)\n+%{\n+  predicate(n->as_Call()->entry_point() == nullptr);\n+  match(CallLeafNoFP target);\n+\n+  ins_cost(300);\n+  format %{ \"call_leaf_nofp,runtime indirect \" %}\n+  ins_encode %{\n+     __ call($target$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -14196,0 +14475,1 @@\n+  predicate(n->as_Call()->entry_point() != nullptr);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":362,"deletions":82,"binary":false,"changes":444,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+  AD.addInclude(AD._CPP_file, \"gc\/shared\/barrierSetAssembler.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -58,0 +59,3 @@\n+bool CDSConfig::_module_patching_disables_cds = false;\n+bool CDSConfig::_java_base_module_patching_disables_cds = false;\n+\n@@ -141,0 +145,3 @@\n+    if (is_valhalla_preview()) {\n+      tmp.print_raw(\"_valhalla\");\n+    }\n@@ -296,1 +303,1 @@\n-  if (Arguments::is_incompatible_cds_internal_module_property(key)) {\n+  if (Arguments::is_incompatible_cds_internal_module_property(key) && !Arguments::patching_migrated_classes(key, value)) {\n@@ -329,2 +336,1 @@\n-    \"jdk.module.upgrade.path\",\n-    \"jdk.module.patch.0\"\n+    \"jdk.module.upgrade.path\"\n@@ -334,2 +340,1 @@\n-    \"--upgrade-module-path\",\n-    \"--patch-module\"\n+    \"--upgrade-module-path\"\n@@ -358,0 +363,6 @@\n+\n+  if (module_patching_disables_cds()) {\n+    vm_exit_during_initialization(\n+            \"Cannot use the following option when dumping the shared archive\", \"--patch-module\");\n+  }\n+\n@@ -386,0 +397,10 @@\n+\n+  if (module_patching_disables_cds()) {\n+    if (RequireSharedSpaces) {\n+      warning(\"CDS is disabled when the %s option is specified.\", \"--patch-module\");\n+    } else {\n+      log_info(cds)(\"CDS is disabled when the %s option is specified.\", \"--patch-module\");\n+    }\n+    return true;\n+  }\n+\n@@ -623,1 +644,1 @@\n-bool CDSConfig::check_vm_args_consistency(bool patch_mod_javabase, bool mode_flag_cmd_line) {\n+bool CDSConfig::check_vm_args_consistency(bool mode_flag_cmd_line) {\n@@ -689,1 +710,1 @@\n-  if (is_using_archive() && patch_mod_javabase) {\n+  if (is_using_archive() && java_base_module_patching_disables_cds() && module_patching_disables_cds()) {\n@@ -908,0 +929,4 @@\n+  if (is_valhalla_preview()) {\n+    \/\/ Not working yet -- e.g., HeapShared::oop_hash() needs to be implemented for value oops\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -266,0 +266,3 @@\n+  case vmIntrinsics::_newNullRestrictedNonAtomicArray:\n+  case vmIntrinsics::_newNullRestrictedAtomicArray:\n+  case vmIntrinsics::_newNullableAtomicArray:\n@@ -336,0 +339,2 @@\n+  case vmIntrinsics::_makePrivateBuffer:\n+  case vmIntrinsics::_finishPrivateBuffer:\n@@ -345,0 +350,2 @@\n+  case vmIntrinsics::_getValue:\n+  case vmIntrinsics::_getFlatValue:\n@@ -354,0 +361,2 @@\n+  case vmIntrinsics::_putValue:\n+  case vmIntrinsics::_putFlatValue:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+#include \"oops\/arrayKlass.hpp\"\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n+#include \"oops\/flatArrayOop.hpp\"\n@@ -35,0 +39,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -77,1 +82,1 @@\n-  return Universe::objectArrayKlass()->allocate_instance(length, THREAD);\n+  return Universe::objectArrayKlass()->allocate_instance(length, ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n@@ -108,2 +113,2 @@\n-\n-objArrayOop oopFactory::new_objArray(Klass* klass, int length, TRAPS) {\n+objArrayOop oopFactory::new_objArray(Klass* klass, int length, ArrayKlass::ArrayProperties properties, TRAPS) {\n+  assert(klass->is_klass(), \"must be instance class\");\n@@ -111,0 +116,1 @@\n+    assert(properties == ArrayKlass::ArrayProperties::DEFAULT, \"properties only apply to single dimension arrays\");\n@@ -113,1 +119,1 @@\n-    return InstanceKlass::cast(klass)->allocate_objArray(1, length, THREAD);\n+    return InstanceKlass::cast(klass)->allocate_objArray(length, properties, THREAD);\n@@ -117,0 +123,20 @@\n+objArrayOop oopFactory::new_objArray(Klass* klass, int length, TRAPS) {\n+  return  new_objArray(klass, length, ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+}\n+\n+flatArrayOop oopFactory::new_flatArray(Klass* k, int length, ArrayKlass::ArrayProperties props, LayoutKind lk, TRAPS) {\n+  InlineKlass* klass = InlineKlass::cast(k);\n+\n+  ArrayKlass* array_type = klass->array_klass(CHECK_NULL);\n+  ObjArrayKlass* oak = ObjArrayKlass::cast(array_type)->klass_with_properties(props, CHECK_NULL);\n+\n+  assert(oak->is_flatArray_klass(), \"Expected to be\");\n+  assert(FlatArrayKlass::cast(oak)->layout_kind() == lk, \"Unexpected layout kind\");\n+\n+  flatArrayOop oop = (flatArrayOop)FlatArrayKlass::cast(oak)->allocate_instance(length, props, CHECK_NULL);\n+  assert(oop == nullptr || oop->is_flatArray(), \"sanity\");\n+  assert(oop == nullptr || oop->klass()->is_flatArray_klass(), \"sanity\");\n+\n+  return oop;\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -47,1 +47,3 @@\n-  Klass* _element_klass;            \/\/ The klass of the elements of this array type\n+ protected:\n+  Klass* _element_klass;            \/\/ The klass of the elements of this array type\n+  ObjArrayKlass* _next_refined_array_klass;\n@@ -50,0 +52,1 @@\n+ protected:\n@@ -51,2 +54,2 @@\n-  ObjArrayKlass(int n, Klass* element_klass, Symbol* name);\n-  static ObjArrayKlass* allocate_klass(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, TRAPS);\n+  ObjArrayKlass(int n, Klass* element_klass, Symbol* name, KlassKind kind, ArrayKlass::ArrayProperties props, markWord mw);\n+  static ObjArrayKlass* allocate_klass(ClassLoaderData* loader_data, int n, Klass* k, Symbol* name, ArrayKlass::ArrayProperties props, TRAPS);\n@@ -54,1 +57,0 @@\n-  objArrayOop allocate_instance(int length, TRAPS);\n@@ -59,4 +61,12 @@\n-  \/\/ Instance variables\n-  Klass* element_klass() const      { return _element_klass; }\n-  void set_element_klass(Klass* k)  { _element_klass = k; }\n-  Klass** element_klass_addr()      { return &_element_klass; }\n+  \/\/ Compiler\/Interpreter offset\n+  static ByteSize element_klass_offset() { return in_ByteSize(offset_of(ObjArrayKlass, _element_klass)); }\n+\n+  virtual Klass* element_klass() const      { return _element_klass; }\n+  virtual void set_element_klass(Klass* k)  { _element_klass = k; }\n+\n+  ObjArrayKlass* next_refined_array_klass() const      { return _next_refined_array_klass; }\n+  inline ObjArrayKlass* next_refined_array_klass_acquire() const;\n+  void set_next_refined_klass_klass(ObjArrayKlass* ak) { _next_refined_array_klass = ak; }\n+  inline void release_set_next_refined_klass(ObjArrayKlass* ak);\n+  ObjArrayKlass* klass_with_properties(ArrayKlass::ArrayProperties properties, TRAPS);\n+  static ByteSize next_refined_array_klass_offset() { return byte_offset_of(ObjArrayKlass, _next_refined_array_klass); }\n@@ -71,3 +81,0 @@\n-  \/\/ Compiler\/Interpreter offset\n-  static ByteSize element_klass_offset() { return byte_offset_of(ObjArrayKlass, _element_klass); }\n-\n@@ -85,0 +92,3 @@\n+  static ArrayDescription array_layout_selection(Klass* element, ArrayProperties properties);\n+\n+  virtual objArrayOop allocate_instance(int length, ArrayProperties props, TRAPS);\n@@ -94,0 +104,3 @@\n+  virtual void remove_unshareable_info();\n+  virtual void remove_java_mirror();\n+  void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS);\n@@ -95,6 +108,0 @@\n- private:\n-  \/\/ Either oop or narrowOop depending on UseCompressedOops.\n-  \/\/ must be called from within ObjArrayKlass.cpp\n-  void do_copy(arrayOop s, size_t src_offset,\n-               arrayOop d, size_t dst_offset,\n-               int length, TRAPS);\n@@ -156,1 +163,1 @@\n-  void oop_print_value_on(oop obj, outputStream* st);\n+  virtual void oop_print_value_on(oop obj, outputStream* st);\n@@ -158,1 +165,1 @@\n-  void oop_print_on      (oop obj, outputStream* st);\n+  virtual void oop_print_on      (oop obj, outputStream* st);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -78,1 +79,4 @@\n-  return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n+  u2 identity_flag = (Arguments::enable_preview()) ? JVM_ACC_IDENTITY : 0;\n+\n+  return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC\n+                    | identity_flag;\n@@ -81,1 +85,1 @@\n-TypeArrayKlass::TypeArrayKlass(BasicType type, Symbol* name) : ArrayKlass(name, Kind) {\n+TypeArrayKlass::TypeArrayKlass(BasicType type, Symbol* name) : ArrayKlass(name, Kind, ArrayKlass::ArrayProperties::DEFAULT) {\n@@ -101,1 +105,0 @@\n-  \/\/ For typeArrays this is only called for the last dimension\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+    case Op_StoreLSpecial:\n@@ -318,1 +319,1 @@\n-        if (offset == Type::OffsetBot || tptr->_offset == Type::OffsetBot)\n+        if (offset == Type::OffsetBot || tptr->offset() == Type::OffsetBot)\n@@ -320,1 +321,1 @@\n-        offset += tptr->_offset; \/\/ correct if base is offsetted\n+        offset += tptr->offset(); \/\/ correct if base is offsetted\n@@ -365,1 +366,5 @@\n-      Block *inb = get_block_for_node(mach->in(j));\n+      Block* inb = get_block_for_node(mach->in(j));\n+      if (mach->in(j)->is_Con() && mach->in(j)->req() == 1 && inb == get_block_for_node(mach)) {\n+        \/\/ Ignore constant loads scheduled in the same block (we can simply hoist them as well)\n+        continue;\n+      }\n@@ -438,0 +443,21 @@\n+  \/\/ Hoist constant load inputs as well.\n+  for (uint i = 1; i < best->req(); ++i) {\n+    Node* n = best->in(i);\n+    if (n->is_Con() && get_block_for_node(n) == get_block_for_node(best)) {\n+      get_block_for_node(n)->find_remove(n);\n+      block->add_inst(n);\n+      map_node_to_block(n, block);\n+      \/\/ Constant loads may kill flags (for example, when XORing a register).\n+      \/\/ Check for flag-killing projections that also need to be hoisted.\n+      for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+        Node* proj = n->fast_out(j);\n+        if (proj->is_MachProj()) {\n+          get_block_for_node(proj)->find_remove(proj);\n+          block->add_inst(proj);\n+          map_node_to_block(proj, block);\n+        }\n+      }\n+    }\n+  }\n+\n+\n@@ -746,0 +772,1 @@\n+        case Op_StoreLSpecial:\n@@ -912,1 +939,1 @@\n-  uint r_cnt = mcall->tf()->range()->cnt();\n+  uint r_cnt = mcall->tf()->range_cc()->cnt();\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class UnswitchCandidate;\n@@ -88,1 +89,1 @@\n-       };\n+         FlatArrays            = 1<<18};\n@@ -111,0 +112,1 @@\n+  bool is_flat_arrays() const { return _loop_flags & FlatArrays; }\n@@ -124,0 +126,1 @@\n+  void mark_flat_arrays() { _loop_flags |= FlatArrays; }\n@@ -736,0 +739,1 @@\n+  bool no_unswitch_candidate() const;\n@@ -1481,1 +1485,2 @@\n-  IfNode* find_unswitch_candidate(const IdealLoopTree* loop) const;\n+  IfNode* find_unswitch_candidates(const IdealLoopTree* loop, Node_List& flat_array_checks) const;\n+  IfNode* find_unswitch_candidate_from_idoms(const IdealLoopTree* loop) const;\n@@ -1488,1 +1493,1 @@\n-                                   const UnswitchedLoopSelector& unswitched_loop_selector);\n+                                   const UnswitchCandidate& unswitch_candidate, const IfNode* loop_selector);\n@@ -1496,0 +1501,1 @@\n+                                            const UnswitchCandidate& unswitch_candidate,\n@@ -1635,0 +1641,1 @@\n+  void move_flat_array_check_out_of_loop(Node* n);\n@@ -1636,0 +1643,1 @@\n+  bool flat_array_element_type_check(Node *n);\n@@ -1825,0 +1833,2 @@\n+  void collect_flat_array_checks(const IdealLoopTree* loop, Node_List& flat_array_checks) const;\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -66,0 +67,6 @@\n+  \/\/ Inline types should not be split through Phis because they cannot be merged\n+  \/\/ through Phi nodes but each value input needs to be merged individually.\n+  if (n->is_InlineType()) {\n+    return nullptr;\n+  }\n+\n@@ -763,0 +770,4 @@\n+      if (inp->isa_InlineType()) {\n+        \/\/ TODO 8302217 This prevents PhiNode::push_inline_types_through\n+        return nullptr;\n+      }\n@@ -1092,0 +1103,48 @@\n+\/\/ We can't use immutable memory for the flat array check because we are loading the mark word which is\n+\/\/ mutable. Although the bits we are interested in are immutable (we check for markWord::unlocked_value),\n+\/\/ we need to use raw memory to not break anti dependency analysis. Below code will attempt to still move\n+\/\/ flat array checks out of loops, mainly to enable loop unswitching.\n+void PhaseIdealLoop::move_flat_array_check_out_of_loop(Node* n) {\n+  \/\/ Skip checks for more than one array\n+  if (n->req() > 3) {\n+    return;\n+  }\n+  Node* mem = n->in(FlatArrayCheckNode::Memory);\n+  Node* array = n->in(FlatArrayCheckNode::ArrayOrKlass)->uncast();\n+  IdealLoopTree* check_loop = get_loop(get_ctrl(n));\n+  IdealLoopTree* ary_loop = get_loop(get_ctrl(array));\n+\n+  \/\/ Check if array is loop invariant\n+  if (!check_loop->is_member(ary_loop)) {\n+    \/\/ Walk up memory graph from the check until we leave the loop\n+    VectorSet wq;\n+    wq.set(mem->_idx);\n+    while (check_loop->is_member(get_loop(ctrl_or_self(mem)))) {\n+      if (mem->is_Phi()) {\n+        mem = mem->in(1);\n+      } else if (mem->is_MergeMem()) {\n+        mem = mem->as_MergeMem()->memory_at(Compile::AliasIdxRaw);\n+      } else if (mem->is_Proj()) {\n+        mem = mem->in(0);\n+      } else if (mem->is_MemBar() || mem->is_SafePoint()) {\n+        mem = mem->in(TypeFunc::Memory);\n+      } else if (mem->is_Store() || mem->is_LoadStore() || mem->is_ClearArray()) {\n+        mem = mem->in(MemNode::Memory);\n+      } else {\n+#ifdef ASSERT\n+        mem->dump();\n+#endif\n+        ShouldNotReachHere();\n+      }\n+      if (wq.test_set(mem->_idx)) {\n+        return;\n+      }\n+    }\n+    \/\/ Replace memory input and re-compute ctrl to move the check out of the loop\n+    _igvn.replace_input_of(n, 1, mem);\n+    set_ctrl_and_loop(n, get_early_ctrl(n));\n+    Node* bol = n->unique_out();\n+    set_ctrl_and_loop(bol, get_early_ctrl(bol));\n+  }\n+}\n+\n@@ -1104,0 +1163,6 @@\n+\n+  if (n->isa_FlatArrayCheck()) {\n+    move_flat_array_check_out_of_loop(n);\n+    return n;\n+  }\n+\n@@ -1379,0 +1444,98 @@\n+bool PhaseIdealLoop::flat_array_element_type_check(Node *n) {\n+  \/\/ If the CmpP is a subtype check for a value that has just been\n+  \/\/ loaded from an array, the subtype check guarantees the value\n+  \/\/ can't be stored in a flat array and the load of the value\n+  \/\/ happens with a flat array check then: push the type check\n+  \/\/ through the phi of the flat array check. This needs special\n+  \/\/ logic because the subtype check's input is not a phi but a\n+  \/\/ LoadKlass that must first be cloned through the phi.\n+  if (n->Opcode() != Op_CmpP) {\n+    return false;\n+  }\n+\n+  Node* klassptr = n->in(1);\n+  Node* klasscon = n->in(2);\n+\n+  if (klassptr->is_DecodeNarrowPtr()) {\n+    klassptr = klassptr->in(1);\n+  }\n+\n+  if (klassptr->Opcode() != Op_LoadKlass && klassptr->Opcode() != Op_LoadNKlass) {\n+    return false;\n+  }\n+\n+  if (!klasscon->is_Con()) {\n+    return false;\n+  }\n+\n+  Node* addr = klassptr->in(MemNode::Address);\n+\n+  if (!addr->is_AddP()) {\n+    return false;\n+  }\n+\n+  intptr_t offset;\n+  Node* obj = AddPNode::Ideal_base_and_offset(addr, &_igvn, offset);\n+\n+  if (obj == nullptr) {\n+    return false;\n+  }\n+\n+  assert(obj != nullptr && addr->in(AddPNode::Base) == addr->in(AddPNode::Address), \"malformed AddP?\");\n+  if (obj->Opcode() == Op_CastPP) {\n+    obj = obj->in(1);\n+  }\n+\n+  if (!obj->is_Phi()) {\n+    return false;\n+  }\n+\n+  Node* region = obj->in(0);\n+\n+  Node* phi = PhiNode::make_blank(region, n->in(1));\n+  for (uint i = 1; i < region->req(); i++) {\n+    Node* in = obj->in(i);\n+    Node* ctrl = region->in(i);\n+    if (addr->in(AddPNode::Base) != obj) {\n+      Node* cast = addr->in(AddPNode::Base);\n+      assert(cast->Opcode() == Op_CastPP && cast->in(0) != nullptr, \"inconsistent subgraph\");\n+      Node* cast_clone = cast->clone();\n+      cast_clone->set_req(0, ctrl);\n+      cast_clone->set_req(1, in);\n+      register_new_node(cast_clone, ctrl);\n+      const Type* tcast = cast_clone->Value(&_igvn);\n+      _igvn.set_type(cast_clone, tcast);\n+      cast_clone->as_Type()->set_type(tcast);\n+      in = cast_clone;\n+    }\n+    Node* addr_clone = addr->clone();\n+    addr_clone->set_req(AddPNode::Base, in);\n+    addr_clone->set_req(AddPNode::Address, in);\n+    register_new_node(addr_clone, ctrl);\n+    _igvn.set_type(addr_clone, addr_clone->Value(&_igvn));\n+    Node* klassptr_clone = klassptr->clone();\n+    klassptr_clone->set_req(2, addr_clone);\n+    register_new_node(klassptr_clone, ctrl);\n+    _igvn.set_type(klassptr_clone, klassptr_clone->Value(&_igvn));\n+    if (klassptr != n->in(1)) {\n+      Node* decode = n->in(1);\n+      assert(decode->is_DecodeNarrowPtr(), \"inconsistent subgraph\");\n+      Node* decode_clone = decode->clone();\n+      decode_clone->set_req(1, klassptr_clone);\n+      register_new_node(decode_clone, ctrl);\n+      _igvn.set_type(decode_clone, decode_clone->Value(&_igvn));\n+      klassptr_clone = decode_clone;\n+    }\n+    phi->set_req(i, klassptr_clone);\n+  }\n+  register_new_node(phi, region);\n+  Node* orig = n->in(1);\n+  _igvn.replace_input_of(n, 1, phi);\n+  split_if_with_blocks_post(n);\n+  if (n->outcnt() != 0) {\n+    _igvn.replace_input_of(n, 1, orig);\n+    _igvn.remove_dead_node(phi);\n+  }\n+  return true;\n+}\n+\n@@ -1385,0 +1548,4 @@\n+  if (flat_array_element_type_check(n)) {\n+    return;\n+  }\n+\n@@ -1535,0 +1702,5 @@\n+\n+  \/\/ Remove multiple allocations of the same inline type\n+  if (n->is_InlineType()) {\n+    n->as_InlineType()->remove_redundant_allocations(this);\n+  }\n@@ -2032,1 +2204,9 @@\n-  Node *sample_cmp = sample_bool->in(1);\n+  Node* sample_cmp = sample_bool->in(1);\n+  const Type* t = Type::TOP;\n+  const TypePtr* at = nullptr;\n+  if (sample_cmp->is_FlatArrayCheck()) {\n+    \/\/ Left input of a FlatArrayCheckNode is memory, set the (adr) type of the phi accordingly\n+    assert(sample_cmp->in(1)->bottom_type() == Type::MEMORY, \"unexpected input type\");\n+    t = Type::MEMORY;\n+    at = TypeRawPtr::BOTTOM;\n+  }\n@@ -2035,1 +2215,1 @@\n-  PhiNode *phi1 = new PhiNode(phi->in(0), Type::TOP);\n+  PhiNode *phi1 = new PhiNode(phi->in(0), t, at);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":182,"deletions":2,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+class MachVEPNode;\n@@ -512,0 +513,30 @@\n+\/\/------------------------------MachVEPNode-----------------------------------\n+\/\/ Machine Inline Type Entry Point Node\n+class MachVEPNode : public MachIdealNode {\n+public:\n+  Label* _verified_entry;\n+\n+  MachVEPNode(Label* verified_entry, bool verified, bool receiver_only) :\n+    _verified_entry(verified_entry),\n+    _verified(verified),\n+    _receiver_only(receiver_only) {\n+    init_class_id(Class_MachVEP);\n+  }\n+  virtual bool cmp(const Node &n) const {\n+    return (_verified_entry == ((MachVEPNode&)n)._verified_entry) &&\n+           (_verified == ((MachVEPNode&)n)._verified) &&\n+           (_receiver_only == ((MachVEPNode&)n)._receiver_only) &&\n+           MachIdealNode::cmp(n);\n+  }\n+  virtual uint size_of() const { return sizeof(*this); }\n+  virtual void emit(C2_MacroAssembler *masm, PhaseRegAlloc* ra_) const;\n+\n+#ifndef PRODUCT\n+  virtual const char* Name() const { return \"InlineType Entry-Point\"; }\n+  virtual void format(PhaseRegAlloc*, outputStream* st) const;\n+#endif\n+private:\n+  bool   _verified;\n+  bool   _receiver_only;\n+};\n+\n@@ -518,1 +549,0 @@\n-  virtual uint size(PhaseRegAlloc *ra_) const;\n@@ -530,1 +560,9 @@\n-  MachPrologNode( ) {}\n+  Label* _verified_entry;\n+\n+  MachPrologNode(Label* verified_entry) : _verified_entry(verified_entry) {\n+    init_class_id(Class_MachProlog);\n+  }\n+  virtual bool cmp(const Node &n) const {\n+    return (_verified_entry == ((MachPrologNode&)n)._verified_entry) && MachIdealNode::cmp(n);\n+  }\n+  virtual uint size_of() const { return sizeof(*this); }\n@@ -532,1 +570,0 @@\n-  virtual uint size(PhaseRegAlloc *ra_) const;\n@@ -549,1 +586,0 @@\n-  virtual uint size(PhaseRegAlloc *ra_) const;\n@@ -938,1 +974,1 @@\n-  NOT_LP64(bool return_value_is_used() const;)\n+  bool return_value_is_used() const;\n@@ -942,0 +978,1 @@\n+  bool returns_scalarized() const;\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":42,"deletions":5,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -244,1 +245,9 @@\n-    _orig_pc_slot = C->fixed_slots() - (sizeof(address) \/ VMRegImpl::stack_slot_size);\n+    int fixed_slots = C->fixed_slots();\n+    if (C->needs_stack_repair()) {\n+      fixed_slots -= 2;\n+    }\n+    \/\/ TODO 8284443 Only reserve extra slot if needed\n+    if (InlineTypeReturnedAsFields) {\n+      fixed_slots -= 2;\n+    }\n+    _orig_pc_slot = fixed_slots - (sizeof(address) \/ VMRegImpl::stack_slot_size);\n@@ -285,1 +294,2 @@\n-  MachPrologNode *prolog = new MachPrologNode();\n+  Label verified_entry;\n+  MachPrologNode* prolog = new MachPrologNode(&verified_entry);\n@@ -291,3 +301,2 @@\n-\n-  if( C->is_osr_compilation() ) {\n-    if( PoisonOSREntry ) {\n+  if (C->is_osr_compilation()) {\n+    if (PoisonOSREntry) {\n@@ -298,3 +307,14 @@\n-    if( C->method() && !C->method()->flags().is_static() ) {\n-      \/\/ Insert unvalidated entry point\n-      C->cfg()->insert( broot, 0, new MachUEPNode() );\n+    if (C->method()) {\n+      if (C->method()->has_scalarized_args()) {\n+        \/\/ Add entry point to unpack all inline type arguments\n+        C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ true, \/* receiver_only *\/ false));\n+        if (!C->method()->is_static()) {\n+          \/\/ Add verified\/unverified entry points to only unpack inline type receiver at interface calls\n+          C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ false, \/* receiver_only *\/ false));\n+          C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ true,  \/* receiver_only *\/ true));\n+          C->cfg()->insert(broot, 0, new MachVEPNode(&verified_entry, \/* verified *\/ false, \/* receiver_only *\/ true));\n+        }\n+      } else if (!C->method()->is_static()) {\n+        \/\/ Insert unvalidated entry point\n+        C->cfg()->insert(broot, 0, new MachUEPNode());\n+      }\n@@ -302,1 +322,0 @@\n-\n@@ -342,0 +361,25 @@\n+  if (!C->is_osr_compilation() && C->has_scalarized_args()) {\n+    \/\/ Compute the offsets of the entry points required by the inline type calling convention\n+    if (!C->method()->is_static()) {\n+      \/\/ We have entries at the beginning of the method, implemented by the first 4 nodes.\n+      \/\/ Entry                     (unverified) @ offset 0\n+      \/\/ Verified_Inline_Entry_RO\n+      \/\/ Inline_Entry              (unverified)\n+      \/\/ Verified_Inline_Entry\n+      uint offset = 0;\n+      _code_offsets.set_value(CodeOffsets::Entry, offset);\n+\n+      offset += ((MachVEPNode*)broot->get_node(0))->size(C->regalloc());\n+      _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry_RO, offset);\n+\n+      offset += ((MachVEPNode*)broot->get_node(1))->size(C->regalloc());\n+      _code_offsets.set_value(CodeOffsets::Inline_Entry, offset);\n+\n+      offset += ((MachVEPNode*)broot->get_node(2))->size(C->regalloc());\n+      _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry, offset);\n+    } else {\n+      _code_offsets.set_value(CodeOffsets::Entry, -1); \/\/ will be patched later\n+      _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry, 0);\n+    }\n+  }\n+\n@@ -503,1 +547,3 @@\n-          mcall->method_set((intptr_t)mcall->entry_point());\n+          if (mcall->entry_point() != nullptr) {\n+            mcall->method_set((intptr_t)mcall->entry_point());\n+          }\n@@ -758,0 +804,29 @@\n+      uint first_ind = spobj->first_index(sfpt->jvms());\n+      \/\/ Nullable, scalarized inline types have a null_marker input\n+      \/\/ that needs to be checked before using the field values.\n+      ScopeValue* properties = nullptr;\n+      if (cik->is_inlinetype()) {\n+        Node* null_marker_node = sfpt->in(first_ind++);\n+        assert(null_marker_node != nullptr, \"null_marker node not found\");\n+        if (!null_marker_node->is_top()) {\n+          const TypeInt* null_marker_type = null_marker_node->bottom_type()->is_int();\n+          if (null_marker_node->is_Con()) {\n+            properties = new ConstantIntValue(null_marker_type->get_con());\n+          } else {\n+            OptoReg::Name null_marker_reg = C->regalloc()->get_reg_first(null_marker_node);\n+            properties = new_loc_value(C->regalloc(), null_marker_reg, Location::normal);\n+          }\n+        }\n+      }\n+      if (cik->is_array_klass() && !cik->is_type_array_klass()) {\n+        jint props = ArrayKlass::ArrayProperties::DEFAULT;\n+        if (cik->as_array_klass()->element_klass()->is_inlinetype()) {\n+          if (cik->as_array_klass()->is_elem_null_free()) {\n+            props |= ArrayKlass::ArrayProperties::NULL_RESTRICTED;\n+          }\n+          if (!cik->as_array_klass()->is_elem_atomic()) {\n+            props |= ArrayKlass::ArrayProperties::NON_ATOMIC;\n+          }\n+        }\n+        properties = new ConstantIntValue(props);\n+      }\n@@ -759,1 +834,1 @@\n-                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), true, properties);\n@@ -762,1 +837,0 @@\n-      uint first_ind = spobj->first_index(sfpt->jvms());\n@@ -1009,0 +1083,1 @@\n+  bool return_scalarized = false;\n@@ -1029,1 +1104,1 @@\n-    if (mcall->returns_pointer()) {\n+    if (mcall->returns_pointer() || mcall->returns_scalarized()) {\n@@ -1032,0 +1107,3 @@\n+    if (mcall->returns_scalarized()) {\n+      return_scalarized = true;\n+    }\n@@ -1101,0 +1179,14 @@\n+          assert(!cik->is_inlinetype(), \"Synchronization on value object?\");\n+          ScopeValue* properties = nullptr;\n+          if (cik->is_array_klass() && !cik->is_type_array_klass()) {\n+            jint props = ArrayKlass::ArrayProperties::DEFAULT;\n+            if (cik->as_array_klass()->element_klass()->is_inlinetype()) {\n+              if (cik->as_array_klass()->is_elem_null_free()) {\n+                props |= ArrayKlass::ArrayProperties::NULL_RESTRICTED;\n+              }\n+              if (!cik->as_array_klass()->is_elem_atomic()) {\n+                props |= ArrayKlass::ArrayProperties::NON_ATOMIC;\n+              }\n+            }\n+            properties = new ConstantIntValue(props);\n+          }\n@@ -1102,1 +1194,1 @@\n-                                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n+                                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()), true, properties);\n@@ -1210,0 +1302,1 @@\n+      return_scalarized,\n@@ -1585,2 +1678,4 @@\n-          \/\/ This destination address is NOT PC-relative\n-          mcall->method_set((intptr_t)mcall->entry_point());\n+          if (mcall->entry_point() != nullptr) {\n+            \/\/ This destination address is NOT PC-relative\n+            mcall->method_set((intptr_t)mcall->entry_point());\n+          }\n@@ -1727,1 +1822,0 @@\n-\n@@ -3165,0 +3259,13 @@\n+\n+      \/\/ Do not allow a CheckCastPP node whose input is a raw pointer to\n+      \/\/ float past a safepoint.  This can occur when a buffered inline\n+      \/\/ type is allocated in a loop and the CheckCastPP from that\n+      \/\/ allocation is reused outside the loop.  If the use inside the\n+      \/\/ loop is scalarized the CheckCastPP will no longer be connected\n+      \/\/ to the loop safepoint.  See JDK-8264340.\n+      if (m->is_Mach() && m->as_Mach()->ideal_Opcode() == Op_CheckCastPP) {\n+        Node *def = m->in(1);\n+        if (def != nullptr && def->bottom_type()->base() == Type::RawPtr) {\n+          last_safept_node->add_prec(m);\n+        }\n+      }\n@@ -3323,0 +3430,19 @@\n+    if (C->has_scalarized_args()) {\n+      \/\/ Inline type entry points (MachVEPNodes) require lots of space for GC barriers and oop verification\n+      \/\/ when loading object fields from the buffered argument. Increase scratch buffer size accordingly.\n+      ciMethod* method = C->method();\n+      int barrier_size = UseZGC ? 200 : (7 DEBUG_ONLY(+ 37));\n+      int arg_num = 0;\n+      if (!method->is_static()) {\n+        if (method->is_scalarized_arg(arg_num)) {\n+          size += method->holder()->as_inline_klass()->oop_count() * barrier_size;\n+        }\n+        arg_num++;\n+      }\n+      for (ciSignatureStream str(method->signature()); !str.at_return_type(); str.next()) {\n+        if (method->is_scalarized_arg(arg_num)) {\n+          size += str.type()->as_inline_klass()->oop_count() * barrier_size;\n+        }\n+        arg_num++;\n+      }\n+    }\n@@ -3393,1 +3519,2 @@\n-  if (is_branch) \/\/ Restore label.\n+  \/\/ Restore label.\n+  if (is_branch) {\n@@ -3395,0 +3522,1 @@\n+  }\n@@ -3435,6 +3563,9 @@\n-      if (!target->is_static()) {\n-        \/\/ The UEP of an nmethod ensures that the VEP is padded. However, the padding of the UEP is placed\n-        \/\/ before the inline cache check, so we don't have to execute any nop instructions when dispatching\n-        \/\/ through the UEP, yet we can ensure that the VEP is aligned appropriately.\n-        _code_offsets.set_value(CodeOffsets::Entry, _first_block_size - MacroAssembler::ic_check_size());\n-      }\n+      if (_code_offsets.value(CodeOffsets::Verified_Inline_Entry) == -1) {\n+        _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry, _first_block_size);\n+      }\n+      if (_code_offsets.value(CodeOffsets::Verified_Inline_Entry_RO) == -1) {\n+        _code_offsets.set_value(CodeOffsets::Verified_Inline_Entry_RO, _first_block_size);\n+      }\n+      if (_code_offsets.value(CodeOffsets::Entry) == -1) {\n+        _code_offsets.set_value(CodeOffsets::Entry, _first_block_size);\n+      }\n@@ -3446,14 +3577,14 @@\n-                                     entry_bci,\n-                                     &_code_offsets,\n-                                     _orig_pc_slot_offset_in_bytes,\n-                                     code_buffer(),\n-                                     frame_size_in_words(),\n-                                     oop_map_set(),\n-                                     &_handler_table,\n-                                     inc_table(),\n-                                     compiler,\n-                                     has_unsafe_access,\n-                                     SharedRuntime::is_wide_vector(C->max_vector_size()),\n-                                     C->has_monitors(),\n-                                     C->has_scoped_access(),\n-                                     0);\n+                              entry_bci,\n+                              &_code_offsets,\n+                              _orig_pc_slot_offset_in_bytes,\n+                              code_buffer(),\n+                              frame_size_in_words(),\n+                              _oop_map_set,\n+                              &_handler_table,\n+                              inc_table(),\n+                              compiler,\n+                              has_unsafe_access,\n+                              SharedRuntime::is_wide_vector(C->max_vector_size()),\n+                              C->has_monitors(),\n+                              C->has_scoped_access(),\n+                              0);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":169,"deletions":38,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n@@ -61,0 +62,1 @@\n+#include \"oops\/access.hpp\"\n@@ -63,0 +65,1 @@\n+#include \"oops\/compressedOops.inline.hpp\"\n@@ -70,0 +73,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -88,0 +92,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -1952,0 +1957,103 @@\n+WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))\n+  oop aoop = JNIHandles::resolve(thing);\n+  if (!aoop->is_instance()) {\n+    return nullptr;\n+  }\n+  instanceHandle ih(THREAD, (instanceOop) aoop);\n+  InstanceKlass* klass = InstanceKlass::cast(ih->klass());\n+  if (klass->nonstatic_oop_map_count() == 0) {\n+    return nullptr;\n+  }\n+  const OopMapBlock* map = klass->start_of_nonstatic_oop_maps();\n+  const OopMapBlock* const end = map + klass->nonstatic_oop_map_count();\n+  int oop_count = 0;\n+  while (map < end) {\n+    oop_count += map->count();\n+    map++;\n+  }\n+\n+  objArrayHandle result_array =\n+      oopFactory::new_objArray_handle(vmClasses::Object_klass(), oop_count, CHECK_NULL);\n+  map = klass->start_of_nonstatic_oop_maps();\n+  int index = 0;\n+  while (map < end) {\n+    int offset = map->offset();\n+    for (unsigned int j = 0; j < map->count(); j++) {\n+      result_array->obj_at_put(index++, ih->obj_field(offset));\n+      offset += heapOopSize;\n+    }\n+    map++;\n+  }\n+  return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+WB_END\n+\n+\/\/ Collect Object oops but not value objects...loaded from heap\n+class CollectObjectOops : public BasicOopIterateClosure {\n+  public:\n+  GrowableArray<Handle>* _array;\n+\n+  CollectObjectOops() {\n+      _array = new GrowableArray<Handle>(128);\n+  }\n+\n+  void add_oop(oop o) {\n+    Handle oh = Handle(Thread::current(), o);\n+    if (oh != nullptr && oh->is_inline_type()) {\n+      oh->oop_iterate(this);\n+    } else {\n+      _array->append(oh);\n+    }\n+  }\n+\n+  template <class T> inline void add_oop(T* p) { add_oop(HeapAccess<>::oop_load(p)); }\n+  void do_oop(oop* o) { add_oop(o); }\n+  void do_oop(narrowOop* v) { add_oop(v); }\n+\n+  jobjectArray create_jni_result(JNIEnv* env, TRAPS) {\n+    objArrayHandle result_array =\n+        oopFactory::new_objArray_handle(vmClasses::Object_klass(), _array->length(), CHECK_NULL);\n+    for (int i = 0 ; i < _array->length(); i++) {\n+      result_array->obj_at_put(i, _array->at(i)());\n+    }\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+  }\n+};\n+\n+\/\/ Collect Object oops but not value objects...loaded from frames\n+class CollectFrameObjectOops : public BasicOopIterateClosure {\n+ public:\n+  CollectObjectOops _collect;\n+\n+  template <class T> inline void add_oop(T* p) { _collect.add_oop(RawAccess<>::oop_load(p)); }\n+  void do_oop(oop* o) { add_oop(o); }\n+  void do_oop(narrowOop* v) { add_oop(v); }\n+\n+  jobjectArray create_jni_result(JNIEnv* env, TRAPS) {\n+    return _collect.create_jni_result(env, THREAD);\n+  }\n+};\n+\n+\/\/ Collect Object oops for the given oop, iterate through value objects\n+WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))\n+  ResourceMark rm(thread);\n+  Handle objh(thread, JNIHandles::resolve(thing));\n+  CollectObjectOops collectOops;\n+  objh->oop_iterate(&collectOops);\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n+\/\/ Collect Object oops for the given frame deep, iterate through value objects\n+WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))\n+  KeepStackGCProcessedMark ksgcpm(THREAD);\n+  ResourceMark rm(THREAD);\n+  CollectFrameObjectOops collectOops;\n+  StackFrameStream sfs(thread, true \/* update *\/, true \/* process_frames *\/);\n+  while (depth > 0) { \/\/ Skip the native WB API frame\n+    sfs.next();\n+    frame* f = sfs.current();\n+    f->oops_do(&collectOops, nullptr, sfs.register_map());\n+    depth--;\n+  }\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n@@ -2918,0 +3026,6 @@\n+  {CC\"getObjectsViaKlassOopMaps0\",\n+      CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",    (void*)&WB_getObjectsViaKlassOopMaps},\n+  {CC\"getObjectsViaOopIterator0\",\n+          CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",(void*)&WB_getObjectsViaOopIterator},\n+  {CC\"getObjectsViaFrameOopIterator\",\n+      CC\"(I)[Ljava\/lang\/Object;\",                     (void*)&WB_getObjectsViaFrameOopIterator},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include <string.h>\n@@ -365,0 +366,12 @@\n+bool Arguments::patching_migrated_classes(const char* property, const char* value) {\n+  if (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {\n+    const char* property_suffix = property + MODULE_PROPERTY_PREFIX_LEN;\n+    if (matches_property_suffix(property_suffix, PATCH, PATCH_LEN)) {\n+      if (strcmp(value, \"java.base-valueclasses.jar\")) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1784,1 +1797,0 @@\n-static unsigned int patch_mod_count = 0;\n@@ -1791,1 +1803,1 @@\n-  if (!CDSConfig::check_vm_args_consistency(patch_mod_javabase, mode_flag_cmd_line)) {\n+  if (!CDSConfig::check_vm_args_consistency(mode_flag_cmd_line)) {\n@@ -2067,1 +2079,1 @@\n-      add_patch_mod_prefix(module_name, module_equal + 1);\n+      add_patch_mod_prefix(module_name, module_equal + 1, false \/* no append *\/, false \/* no cds *\/);\n@@ -2069,3 +2081,0 @@\n-      if (!create_numbered_module_property(\"jdk.module.patch\", patch_mod_tail, patch_mod_count++)) {\n-        return JNI_ENOMEM;\n-      }\n@@ -2079,0 +2088,64 @@\n+\/\/ VALUECLASS_STR must match string used in the build\n+#define VALUECLASS_STR \"valueclasses\"\n+#define VALUECLASS_JAR \"-\" VALUECLASS_STR \".jar\"\n+\n+\/\/ Finalize --patch-module args and --enable-preview related to value class module patches.\n+\/\/ Create all numbered properties passing module patches.\n+int Arguments::finalize_patch_module() {\n+  \/\/ If --enable-preview and EnableValhalla is true, each module may have value classes that\n+  \/\/ are to be patched into the module.\n+  \/\/ For each <module>-valueclasses.jar in <JAVA_HOME>\/lib\/valueclasses\/\n+  \/\/ appends the equivalent of --patch-module <module>=<JAVA_HOME>\/lib\/valueclasses\/<module>-valueclasses.jar\n+  if (enable_preview() && EnableValhalla) {\n+    char * valueclasses_dir = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+    const char * fileSep = os::file_separator();\n+\n+    jio_snprintf(valueclasses_dir, JVM_MAXPATHLEN, \"%s%slib%s\" VALUECLASS_STR \"%s\",\n+                 Arguments::get_java_home(), fileSep, fileSep, fileSep);\n+    DIR* dir = os::opendir(valueclasses_dir);\n+    if (dir != nullptr) {\n+      char * module_name = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+      char * path = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+\n+      for (dirent * entry = os::readdir(dir); entry != nullptr; entry = os::readdir(dir)) {\n+        \/\/ Test if file ends-with \"-valueclasses.jar\"\n+        int len = (int)strlen(entry->d_name) - (sizeof(VALUECLASS_JAR) - 1);\n+        if (len <= 0 || strcmp(&entry->d_name[len], VALUECLASS_JAR) != 0) {\n+          continue;         \/\/ too short or not the expected suffix\n+        }\n+\n+        strcpy(module_name, entry->d_name);\n+        module_name[len] = '\\0';     \/\/ truncate to just module-name\n+\n+        jio_snprintf(path, JVM_MAXPATHLEN, \"%s%s\", valueclasses_dir, &entry->d_name);\n+        add_patch_mod_prefix(module_name, path, true \/* append *\/, true \/* cds OK*\/);\n+        log_info(class)(\"--enable-preview appending value classes for module %s: %s\", module_name, entry->d_name);\n+      }\n+      FreeHeap(module_name);\n+      FreeHeap(path);\n+      os::closedir(dir);\n+    }\n+    FreeHeap(valueclasses_dir);\n+  }\n+\n+  \/\/ Create numbered properties for each module that has been patched either\n+  \/\/ by --patch-module or --enable-preview\n+  \/\/ Format is \"jdk.module.patch.<n>=<module_name>=<path>\"\n+  if (_patch_mod_prefix != nullptr) {\n+    char * prop_value = AllocateHeap(JVM_MAXPATHLEN + JVM_MAXPATHLEN + 1, mtArguments);\n+    unsigned int patch_mod_count = 0;\n+\n+    for (GrowableArrayIterator<ModulePatchPath *> it = _patch_mod_prefix->begin();\n+            it != _patch_mod_prefix->end(); ++it) {\n+      jio_snprintf(prop_value, JVM_MAXPATHLEN + JVM_MAXPATHLEN + 1, \"%s=%s\",\n+                   (*it)->module_name(), (*it)->path_string());\n+      if (!create_numbered_module_property(\"jdk.module.patch\", prop_value, patch_mod_count++)) {\n+        FreeHeap(prop_value);\n+        return JNI_ENOMEM;\n+      }\n+    }\n+    FreeHeap(prop_value);\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -2347,0 +2420,4 @@\n+      \/\/ --enable-preview enables Valhalla, EnableValhalla VM option will eventually be removed before integration\n+      if (FLAG_SET_CMDLINE(EnableValhalla, true) != JVMFlag::SUCCESS) {\n+        return JNI_EINVAL;\n+      }\n@@ -2826,10 +2903,5 @@\n-void Arguments::add_patch_mod_prefix(const char* module_name, const char* path) {\n-  \/\/ For java.base check for duplicate --patch-module options being specified on the command line.\n-  \/\/ This check is only required for java.base, all other duplicate module specifications\n-  \/\/ will be checked during module system initialization.  The module system initialization\n-  \/\/ will throw an ExceptionInInitializerError if this situation occurs.\n-  if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n-    if (patch_mod_javabase) {\n-      vm_exit_during_initialization(\"Cannot specify \" JAVA_BASE_NAME \" more than once to --patch-module\");\n-    } else {\n-      patch_mod_javabase = true;\n+void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool allow_append, bool allow_cds) {\n+  if (!allow_cds) {\n+    CDSConfig::set_module_patching_disables_cds();\n+    if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n+      CDSConfig::set_java_base_module_patching_disables_cds();\n@@ -2844,1 +2916,18 @@\n-  _patch_mod_prefix->push(new ModulePatchPath(module_name, path));\n+  \/\/ Scan patches for matching module\n+  int i = _patch_mod_prefix->find_if([&](ModulePatchPath* patch) {\n+    return (strcmp(module_name, patch->module_name()) == 0);\n+  });\n+  if (i == -1) {\n+    _patch_mod_prefix->push(new ModulePatchPath(module_name, path));\n+  } else {\n+    if (allow_append) {\n+      \/\/ append path to existing module entry\n+      _patch_mod_prefix->at(i)->append_path(path);\n+    } else {\n+      if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n+        vm_exit_during_initialization(\"Cannot specify \" JAVA_BASE_NAME \" more than once to --patch-module\");\n+      } else {\n+        vm_exit_during_initialization(\"Cannot specify a module more than once to --patch-module\", module_name);\n+      }\n+    }\n+  }\n@@ -2957,1 +3046,2 @@\n-  if (!check_vm_args_consistency()) {\n+  \/\/ finalize --module-patch and related --enable-preview\n+  if (finalize_patch_module() != JNI_OK) {\n@@ -2961,0 +3051,3 @@\n+  if (!check_vm_args_consistency()) {\n+    return JNI_ERR;\n+  }\n@@ -3849,0 +3942,12 @@\n+  if (!EnableValhalla || (is_interpreter_only() && !CDSConfig::is_dumping_archive() && !UseSharedSpaces)) {\n+    \/\/ Disable calling convention optimizations if inline types are not supported.\n+    \/\/ Also these aren't useful in -Xint. However, don't disable them when dumping or using\n+    \/\/ the CDS archive, as the values must match between dumptime and runtime.\n+    FLAG_SET_DEFAULT(InlineTypePassFieldsAsArgs, false);\n+    FLAG_SET_DEFAULT(InlineTypeReturnedAsFields, false);\n+  }\n+  if (!UseNonAtomicValueFlattening && !UseNullableValueFlattening && !UseAtomicValueFlattening) {\n+    \/\/ Flattening is disabled\n+    FLAG_SET_DEFAULT(UseArrayFlattening, false);\n+    FLAG_SET_DEFAULT(UseFieldFlattening, false);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":123,"deletions":18,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.hpp\"\n@@ -58,0 +60,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -303,0 +306,18 @@\n+\n+static Klass* get_refined_array_klass(Klass* k, frame* fr, RegisterMap* map, ObjectValue* sv, TRAPS) {\n+  \/\/ If it's an array, get the properties\n+  if (k->is_array_klass() && !k->is_typeArray_klass()) {\n+    assert(!k->is_refArray_klass() && !k->is_flatArray_klass(), \"Unexpected refined klass\");\n+    nmethod* nm = fr->cb()->as_nmethod_or_null();\n+    if (nm->is_compiled_by_c2()) {\n+      assert(sv->has_properties(), \"Property information is missing\");\n+      ArrayKlass::ArrayProperties props = static_cast<ArrayKlass::ArrayProperties>(StackValue::create_stack_value(fr, map, sv->properties())->get_jint());\n+      k = ObjArrayKlass::cast(k)->klass_with_properties(props, THREAD);\n+    } else {\n+      \/\/ TODO Graal needs to be fixed. Just go with the default properties for now\n+      k = ObjArrayKlass::cast(k)->klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+    }\n+  }\n+  return k;\n+}\n+\n@@ -304,2 +325,2 @@\n-static void print_objects(JavaThread* deoptee_thread,\n-                          GrowableArray<ScopeValue*>* objects, bool realloc_failures) {\n+static void print_objects(JavaThread* deoptee_thread, frame* deoptee, RegisterMap* map,\n+                          GrowableArray<ScopeValue*>* objects, bool realloc_failures, TRAPS) {\n@@ -321,0 +342,1 @@\n+    k = get_refined_array_klass(k, deoptee, map, sv, THREAD);\n@@ -354,2 +376,13 @@\n-  bool save_oop_result = chunk->at(0)->scope()->return_oop() && !thread->popframe_forcing_deopt_reexecution() && (exec_mode == Deoptimization::Unpack_deopt);\n-  Handle return_value;\n+  ScopeDesc* scope = chunk->at(0)->scope();\n+  bool save_oop_result = scope->return_oop() && !thread->popframe_forcing_deopt_reexecution() && (exec_mode == Deoptimization::Unpack_deopt);\n+  \/\/ In case of the return of multiple values, we must take care\n+  \/\/ of all oop return values.\n+  GrowableArray<Handle> return_oops;\n+  InlineKlass* vk = nullptr;\n+  if (save_oop_result && scope->return_scalarized()) {\n+    vk = InlineKlass::returned_inline_klass(map);\n+    if (vk != nullptr) {\n+      vk->save_oop_fields(map, return_oops);\n+      save_oop_result = false;\n+    }\n+  }\n@@ -361,1 +394,1 @@\n-    return_value = Handle(thread, result);\n+    return_oops.push(Handle(thread, result));\n@@ -368,1 +401,1 @@\n-  if (objects != nullptr) {\n+  if (objects != nullptr || vk != nullptr) {\n@@ -373,1 +406,9 @@\n-      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, CHECK_AND_CLEAR_(true));\n+      if (vk != nullptr) {\n+        realloc_failures = Deoptimization::realloc_inline_type_result(vk, map, return_oops, CHECK_AND_CLEAR_(true));\n+      }\n+      if (objects != nullptr) {\n+        realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &deoptee, &map, objects, CHECK_AND_CLEAR_(true));\n+        guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n+        bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci, CHECK_AND_CLEAR_(true));\n+      }\n@@ -378,1 +419,9 @@\n-      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, THREAD);\n+      if (vk != nullptr) {\n+        realloc_failures = Deoptimization::realloc_inline_type_result(vk, map, return_oops, THREAD);\n+      }\n+      if (objects != nullptr) {\n+        realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &deoptee, &map, objects, THREAD);\n+        guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n+        bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci, THREAD);\n+      }\n@@ -381,5 +430,2 @@\n-    guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n-    bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n-    Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci);\n-    if (TraceDeoptimization) {\n-      print_objects(deoptee_thread, objects, realloc_failures);\n+    if (TraceDeoptimization && objects != nullptr) {\n+      print_objects(deoptee_thread, &deoptee, &map, objects, realloc_failures, thread);\n@@ -388,1 +434,1 @@\n-  if (save_oop_result) {\n+  if (save_oop_result || vk != nullptr) {\n@@ -390,1 +436,2 @@\n-    deoptee.set_saved_oop_result(&map, return_value());\n+    assert(return_oops.length() == 1, \"no inline type\");\n+    deoptee.set_saved_oop_result(&map, return_oops.pop()());\n@@ -725,1 +772,1 @@\n-  \/\/ If the sender is deoptimized the we must retrieve the address of the handler\n+  \/\/ If the sender is deoptimized we must retrieve the address of the handler\n@@ -1241,2 +1288,10 @@\n-\n-    oop obj = nullptr;\n+    k = get_refined_array_klass(k, fr, reg_map, sv, THREAD);\n+\n+    \/\/ Check if the object may be null and has an additional null_marker input that needs\n+    \/\/ to be checked before using the field values. Skip re-allocation if it is null.\n+    if (k->is_inline_klass() && sv->has_properties()) {\n+      jint null_marker = StackValue::create_stack_value(fr, reg_map, sv->properties())->get_jint();\n+      if (null_marker == 0) {\n+        continue;\n+      }\n+    }\n@@ -1245,0 +1300,1 @@\n+    oop obj = nullptr;\n@@ -1272,0 +1328,4 @@\n+    } else if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* ak = FlatArrayKlass::cast(k);\n+      \/\/ Inline type array must be zeroed because not all memory is reassigned\n+      obj = ak->allocate_instance(sv->field_size(), ak->properties(), THREAD);\n@@ -1278,2 +1338,2 @@\n-    } else if (k->is_objArray_klass()) {\n-      ObjArrayKlass* ak = ObjArrayKlass::cast(k);\n+    } else if (k->is_refArray_klass()) {\n+      RefArrayKlass* ak = RefArrayKlass::cast(k);\n@@ -1281,1 +1341,1 @@\n-      obj = ak->allocate_instance(sv->field_size(), THREAD);\n+      obj = ak->allocate_instance(sv->field_size(), ak->properties(), THREAD);\n@@ -1303,0 +1363,15 @@\n+\/\/ We're deoptimizing at the return of a call, inline type fields are\n+\/\/ in registers. When we go back to the interpreter, it will expect a\n+\/\/ reference to an inline type instance. Allocate and initialize it from\n+\/\/ the register values here.\n+bool Deoptimization::realloc_inline_type_result(InlineKlass* vk, const RegisterMap& map, GrowableArray<Handle>& return_oops, TRAPS) {\n+  oop new_vt = vk->realloc_result(map, return_oops, THREAD);\n+  if (new_vt == nullptr) {\n+    CLEAR_PENDING_EXCEPTION;\n+    THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), true);\n+  }\n+  return_oops.clear();\n+  return_oops.push(Handle(THREAD, new_vt));\n+  return false;\n+}\n+\n@@ -1468,0 +1543,3 @@\n+  InstanceKlass* _klass;\n+  bool _is_flat;\n+  bool _is_null_free;\n@@ -1469,4 +1547,1 @@\n-  ReassignedField() {\n-    _offset = 0;\n-    _type = T_ILLEGAL;\n-  }\n+  ReassignedField() : _offset(0), _type(T_ILLEGAL), _klass(nullptr), _is_flat(false), _is_null_free(false) { }\n@@ -1486,0 +1561,6 @@\n+      if (fs.is_flat()) {\n+        field._is_flat = true;\n+        field._is_null_free = fs.is_null_free_inline_type();\n+        \/\/ Resolve klass of flat inline type field\n+        field._klass = InlineKlass::cast(klass->get_inline_type_field_klass(fs.index()));\n+      }\n@@ -1492,2 +1573,3 @@\n-\/\/ Restore fields of an eliminated instance object employing the same field order used by the compiler.\n-static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci) {\n+\/\/ Restore fields of an eliminated instance object employing the same field order used by the\n+\/\/ compiler when it scalarizes an object at safepoints.\n+static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci, int base_offset, TRAPS) {\n@@ -1496,0 +1578,19 @@\n+    BasicType type = fields->at(i)._type;\n+    int offset = base_offset + fields->at(i)._offset;\n+    \/\/ Check for flat inline type field before accessing the ScopeValue because it might not have any fields\n+    if (fields->at(i)._is_flat) {\n+      \/\/ Recursively re-assign flat inline type fields\n+      InstanceKlass* vk = fields->at(i)._klass;\n+      assert(vk != nullptr, \"must be resolved\");\n+      offset -= InlineKlass::cast(vk)->payload_offset(); \/\/ Adjust offset to omit oop header\n+      svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, is_jvmci, offset, CHECK_0);\n+      if (!fields->at(i)._is_null_free) {\n+        ScopeValue* scope_field = sv->field_at(svIndex);\n+        StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);\n+        int nm_offset = offset + InlineKlass::cast(vk)->null_marker_offset();\n+        obj->bool_field_put(nm_offset, value->get_jint() & 1);\n+        svIndex++;\n+      }\n+      continue; \/\/ Continue because we don't need to increment svIndex\n+    }\n+\n@@ -1498,3 +1599,2 @@\n-    int offset = fields->at(i)._offset;\n-    BasicType type = fields->at(i)._type;\n-      case T_OBJECT: case T_ARRAY:\n+      case T_OBJECT:\n+      case T_ARRAY:\n@@ -1572,0 +1672,1 @@\n+\n@@ -1575,0 +1676,14 @@\n+\/\/ restore fields of an eliminated inline type array\n+void Deoptimization::reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, bool is_jvmci, TRAPS) {\n+  InlineKlass* vk = vak->element_klass();\n+  assert(vk->maybe_flat_in_array(), \"should only be used for flat inline type arrays\");\n+  \/\/ Adjust offset to omit oop header\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT) - InlineKlass::cast(vk)->payload_offset();\n+  \/\/ Initialize all elements of the flat inline type array\n+  for (int i = 0; i < sv->field_size(); i++) {\n+    ScopeValue* val = sv->field_at(i);\n+    int offset = base_offset + (i << Klass::layout_helper_log2_element_size(vak->layout_helper()));\n+    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, is_jvmci, offset, CHECK);\n+  }\n+}\n+\n@@ -1576,1 +1691,1 @@\n-void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool is_jvmci) {\n+void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool is_jvmci, TRAPS) {\n@@ -1581,0 +1696,2 @@\n+    k = get_refined_array_klass(k, fr, reg_map, sv, THREAD);\n+\n@@ -1582,1 +1699,1 @@\n-    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n+    assert(obj.not_null() || realloc_failures || sv->has_properties(), \"reallocation was missed\");\n@@ -1620,1 +1737,4 @@\n-      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci);\n+      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci, 0, CHECK);\n+    } else if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+      reassign_flat_array_elements(fr, reg_map, sv, (flatArrayOop) obj(), vak, is_jvmci, CHECK);\n@@ -1624,1 +1744,1 @@\n-    } else if (k->is_objArray_klass()) {\n+    } else if (k->is_refArray_klass()) {\n@@ -1816,1 +1936,1 @@\n-  \/\/ Deoptimize only if the frame comes from compile code.\n+  \/\/ Deoptimize only if the frame comes from compiled code.\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":155,"deletions":35,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+  oop           _return_buffered_value; \/\/ buffered value being returned\n@@ -793,0 +794,3 @@\n+  oop return_buffered_value() const              { return _return_buffered_value; }\n+  void set_return_buffered_value(oop val)        { _return_buffered_value = val; }\n+\n@@ -859,0 +863,1 @@\n+  static ByteSize return_buffered_value_offset() { return byte_offset_of(JavaThread, _return_buffered_value); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -231,1 +233,2 @@\n-    value->l = cast_from_oop<jobject>(objArrayOop(a)->obj_at(index));\n+    oop o = objArrayOop(a)->obj_at(index, CHECK_(T_ILLEGAL)); \/\/ reading from a flat array can throw an OOM\n+    value->l = cast_from_oop<jobject>(o);\n@@ -273,0 +276,1 @@\n+\n@@ -276,0 +280,4 @@\n+      if (a->is_null_free_array() && obj == nullptr) {\n+         THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"null-restricted array\");\n+      }\n+\n@@ -760,3 +768,0 @@\n-  if (log_is_enabled(Debug, class, resolve)) {\n-    trace_class_resolution(nt);\n-  }\n@@ -768,3 +773,2 @@\n-  assert(!method()->is_object_initializer() &&\n-         (for_constant_pool_access || !method()->is_static_initializer()),\n-         \"Should not be the initializer\");\n+  assert(!method()->name()->starts_with('<') || for_constant_pool_access,\n+         \"should call new_constructor instead\");\n@@ -818,1 +822,2 @@\n-  assert(method()->is_object_initializer(), \"Should be the initializer\");\n+  assert(method()->is_object_constructor(),\n+         \"should call new_method instead\");\n@@ -867,0 +872,2 @@\n+\n+  int flags = 0;\n@@ -868,1 +875,4 @@\n-    java_lang_reflect_Field::set_trusted_final(rh());\n+    flags |= TRUSTED_FINAL;\n+  }\n+  if (fd->is_null_free_inline_type()) {\n+    flags |= NULL_RESTRICTED;\n@@ -870,0 +880,2 @@\n+  java_lang_reflect_Field::set_flags(rh(), flags);\n+\n@@ -980,1 +992,2 @@\n-    if (reflected_method->is_private() || reflected_method->name() == vmSymbols::object_initializer_name()) {\n+    if (reflected_method->is_private() ||\n+        reflected_method->name() == vmSymbols::object_initializer_name()) {\n@@ -1060,2 +1073,2 @@\n-    oop type_mirror = ptypes->obj_at(i);\n-    oop arg = args->obj_at(i);\n+    oop type_mirror = ptypes->obj_at(i, CHECK_NULL);\n+    oop arg = args->obj_at(i, CHECK_NULL);\n@@ -1162,1 +1175,0 @@\n-  assert(method->name() == vmSymbols::object_initializer_name(), \"invalid constructor\");\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-import java.io.ObjectStreamClass.RecordSupport;\n+import java.io.ObjectStreamClass.ConstructorSupport;\n+import java.io.ObjectStreamClass.ClassDataSlot;\n@@ -34,0 +35,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -38,0 +40,2 @@\n+import java.util.List;\n+import java.util.Locale;\n@@ -213,0 +217,2 @@\n+ * Value objects cannot be `java.io.Externalizable` because value objects are\n+ * immutable and `Externalizable.readExternal` is unable to modify the fields of the value.\n@@ -238,0 +244,4 @@\n+ * <p>Value classes are {@linkplain Serializable} through the use of the serialization proxy pattern.\n+ * See {@linkplain ObjectOutputStream##valueclass-serialization value class serialization} for details.\n+ * When the proxy is deserialized it re-constructs and returns the value object.\n+ *\n@@ -251,0 +261,10 @@\n+    private static final String TRACE_DEST =\n+            System.getProperty(\"TRACE\");\n+\n+    static void TRACE(String format, Object... args) {\n+        if (TRACE_DEST != null) {\n+            var ps = \"OUT\".equals(TRACE_DEST.toUpperCase(Locale.ROOT)) ? System.out : System.err;\n+            ps.println((\"TRACE \" + format).formatted(args));\n+        }\n+    }\n+\n@@ -428,0 +448,8 @@\n+     * <p>Serialization and deserialization of value classes is described in\n+     * {@linkplain ObjectOutputStream##valueclass-serialization value class serialization}.\n+     *\n+     * @implSpec\n+     * When enabled with {@code --enable-preview}, serialization and deserialization of\n+     * Core Library value classes migrated from pre-JEP 401 identity classes is\n+     * implementation specific.\n+     *\n@@ -2110,9 +2138,2 @@\n-        Object obj;\n-        try {\n-            obj = desc.isInstantiable() ? desc.newInstance() : null;\n-        } catch (Exception ex) {\n-            throw new InvalidClassException(desc.forClass().getName(),\n-                                            \"unable to create instance\", ex);\n-        }\n-\n-        passHandle = handles.assign(unshared ? unsharedMarker : obj);\n+        \/\/ Assign the handle and initially set to null or the unsharedMarker\n+        passHandle = handles.assign(unshared ? unsharedMarker : null);\n@@ -2124,11 +2145,12 @@\n-        final boolean isRecord = desc.isRecord();\n-        if (isRecord) {\n-            assert obj == null;\n-            obj = readRecord(desc);\n-            if (!unshared)\n-                handles.setObject(passHandle, obj);\n-        } else if (desc.isExternalizable()) {\n-            readExternalData((Externalizable) obj, desc);\n-        } else {\n-            readSerialData(obj, desc);\n-        }\n+        try {\n+            \/\/ Dispatch on the factory mode to read an object from the stream.\n+            Object obj = switch (desc.factoryMode()) {\n+                case READ_OBJECT_DEFAULT -> readSerialDefaultObject(desc, unshared);\n+                case READ_OBJECT_CUSTOM -> readSerialCustomData(desc, unshared);\n+                case READ_RECORD -> readRecord(desc, unshared);\n+                case READ_EXTERNALIZABLE -> readExternalObject(desc, unshared);\n+                case READ_OBJECT_VALUE -> readObjectValue(desc, unshared);\n+                case READ_NO_LOCAL_CLASS -> readAbsentLocalClass(desc, unshared);\n+                case null -> throw new AssertionError(\"Unknown factoryMode for: \" + desc.getName(),\n+                        resolveEx);\n+            };\n@@ -2136,1 +2158,1 @@\n-        handles.finish(passHandle);\n+            handles.finish(passHandle);\n@@ -2138,15 +2160,16 @@\n-        if (obj != null &&\n-            handles.lookupException(passHandle) == null &&\n-            desc.hasReadResolveMethod())\n-        {\n-            Object rep = desc.invokeReadResolve(obj);\n-            if (unshared && rep.getClass().isArray()) {\n-                rep = cloneArray(rep);\n-            }\n-            if (rep != obj) {\n-                \/\/ Filter the replacement object\n-                if (rep != null) {\n-                    if (rep.getClass().isArray()) {\n-                        filterCheck(rep.getClass(), Array.getLength(rep));\n-                    } else {\n-                        filterCheck(rep.getClass(), -1);\n+            if (obj != null &&\n+                handles.lookupException(passHandle) == null &&\n+                desc.hasReadResolveMethod())\n+            {\n+                Object rep = desc.invokeReadResolve(obj);\n+                if (unshared && rep.getClass().isArray()) {\n+                    rep = cloneArray(rep);\n+                }\n+                if (rep != obj) {\n+                    \/\/ Filter the replacement object\n+                    if (rep != null) {\n+                        if (rep.getClass().isArray()) {\n+                            filterCheck(rep.getClass(), Array.getLength(rep));\n+                        } else {\n+                            filterCheck(rep.getClass(), -1);\n+                        }\n@@ -2154,0 +2177,1 @@\n+                    handles.setObject(passHandle, obj = rep);\n@@ -2155,1 +2179,5 @@\n-                handles.setObject(passHandle, obj = rep);\n+\n+            return obj;\n+        } catch (UncheckedIOException uioe) {\n+            \/\/ Consistent re-throw for nested UncheckedIOExceptions\n+            throw uioe.getCause();\n@@ -2158,0 +2186,1 @@\n+    }\n@@ -2159,1 +2188,43 @@\n-        return obj;\n+    \/**\n+     * {@return a value class instance by invoking its constructor with field values read from the stream.\n+     * The fields of the class in the stream are matched to the local fields and applied to\n+     * the constructor.\n+     * If the stream contains superclasses with serializable fields,\n+     * an InvalidClassException is thrown with an incompatible class change message.\n+     *\n+     * @param desc the class descriptor read from the stream, the local class is a value class\n+     * @param unshared if the object is not to be shared\n+     * @throws InvalidClassException if the stream contains a superclass with serializable fields.\n+     * @throws IOException if there are I\/O errors while reading from the\n+     *         underlying {@code InputStream}\n+     *\/\n+    private Object readObjectValue(ObjectStreamClass desc, boolean unshared) throws IOException {\n+        final ObjectStreamClass localDesc = desc.getLocalDesc();\n+        TRACE(\"readObjectValue: %s, local class: %s\", desc.getName(), localDesc.getName());\n+        \/\/ Check for un-expected fields in superclasses\n+        List<ClassDataSlot> slots = desc.getClassDataLayout();\n+        for (int i = 0; i < slots.size()-1; i++) {\n+            ClassDataSlot slot = slots.get(i);\n+            if (slot.hasData && slot.desc.getFields(false).length > 0) {\n+                throw new InvalidClassException(\"incompatible class change to value class: \" +\n+                        \"stream class has non-empty super type: \" + desc.getName());\n+            }\n+        }\n+        \/\/ Read values for the value class fields\n+        FieldValues fieldValues = new FieldValues(desc, true);\n+\n+        \/\/ Get value object constructor adapted to take primitive value buffer and object array.\n+        MethodHandle consMH = ConstructorSupport.deserializationValueCons(desc);\n+        try {\n+            Object obj = (Object) consMH.invokeExact(fieldValues.primValues, fieldValues.objValues);\n+            if (!unshared)\n+                handles.setObject(passHandle, obj);\n+            return obj;\n+        } catch (Exception e) {\n+            throw new InvalidObjectException(e.getMessage(), e);\n+        } catch (Error e) {\n+            throw e;\n+        } catch (Throwable t) {\n+            throw new InvalidObjectException(\"ReflectiveOperationException \" +\n+                    \"during deserialization\", t);\n+        }\n@@ -2163,1 +2234,3 @@\n-     * If obj is non-null, reads externalizable data by invoking readExternal()\n+     * Creates a new object and invokes its readExternal method to read its contents.\n+     *\n+     * If the class is instantiable, read externalizable data by invoking readExternal()\n@@ -2166,1 +2239,2 @@\n-     * called.\n+     * called.  The new object is entered in the handle table immediately,\n+     * allowing it to leak before it is completely read.\n@@ -2168,1 +2242,1 @@\n-    private void readExternalData(Externalizable obj, ObjectStreamClass desc)\n+    private Object readExternalObject(ObjectStreamClass desc, boolean unshared)\n@@ -2171,0 +2245,17 @@\n+        TRACE(\"readExternalObject: %s\", desc.getName());\n+\n+        \/\/ For Externalizable objects,\n+        \/\/ create the instance, publish the ref, and read the data\n+        Externalizable obj = null;\n+        try {\n+            if (desc.isInstantiable()) {\n+                obj = (Externalizable) desc.newInstance();\n+            }\n+        } catch (Exception ex) {\n+            throw new InvalidClassException(desc.getName(),\n+                    \"unable to create instance\", ex);\n+        }\n+\n+        if (!unshared)\n+            handles.setObject(passHandle, obj);\n+\n@@ -2214,0 +2305,1 @@\n+        return obj;\n@@ -2222,4 +2314,5 @@\n-     **\/\n-    private Object readRecord(ObjectStreamClass desc) throws IOException {\n-        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();\n-        if (slots.length != 1) {\n+     *\/\n+    private Object readRecord(ObjectStreamClass desc, boolean unshared) throws IOException {\n+        TRACE(\"invoking readRecord: %s\", desc.getName());\n+        List<ClassDataSlot> slots = desc.getClassDataLayout();\n+        if (slots.size() != 1) {\n@@ -2227,3 +2320,3 @@\n-            for (int i = 0; i < slots.length-1; i++) {\n-                if (slots[i].hasData) {\n-                    new FieldValues(slots[i].desc, true);\n+            for (int i = 0; i < slots.size()-1; i++) {\n+                if (slots.get(i).hasData) {\n+                    new FieldValues(slots.get(i).desc, true);\n@@ -2243,1 +2336,1 @@\n-        MethodHandle ctrMH = RecordSupport.deserializationCtr(desc);\n+        MethodHandle ctrMH = ConstructorSupport.deserializationCtr(desc);\n@@ -2246,1 +2339,4 @@\n-            return (Object) ctrMH.invokeExact(fieldValues.primValues, fieldValues.objValues);\n+            Object obj = (Object) ctrMH.invokeExact(fieldValues.primValues, fieldValues.objValues);\n+            if (!unshared)\n+                handles.setObject(passHandle, obj);\n+            return obj;\n@@ -2258,1 +2354,53 @@\n-     * Reads (or attempts to skip, if obj is null or is tagged with a\n+     * Construct an object from the stream for a class that has only default read object behaviors.\n+     * For each object, the fields are read before any are assigned.\n+     * The new instance is entered in the handle table if it is unshared,\n+     * allowing it to escape before it is initialized.\n+     * The `readObject` and `readObjectNoData` methods are not present and are not called.\n+     *\n+     * @param desc the class descriptor\n+     * @param unshared true if the object should be shared\n+     * @return the object constructed from the stream data\n+     * @throws IOException if there are I\/O errors while reading from the\n+     *         underlying {@code InputStream}\n+     * @throws InvalidClassException if the instance creation fails\n+     *\/\n+    private Object readSerialDefaultObject(ObjectStreamClass desc, boolean unshared)\n+            throws IOException, InvalidClassException {\n+        if (!desc.isInstantiable()) {\n+            \/\/ No local class to create, read and discard\n+            return readAbsentLocalClass(desc, unshared);\n+        }\n+        TRACE(\"readSerialDefaultObject: %s\", desc.getName());\n+        try {\n+            final Object obj = desc.newInstance();\n+            if (!unshared)\n+                handles.setObject(passHandle, obj);\n+\n+            \/\/ Best effort Failure Atomicity; slotValues will be non-null if field\n+            \/\/ values can be set after reading all field data in the hierarchy.\n+            List<FieldValues> slotValues = desc.getClassDataLayout().stream()\n+                    .filter(s -> s.hasData)\n+                    .map(s1 -> {\n+                        var values = new FieldValues(s1.desc, true);\n+                        finishBlockData(s1.desc);\n+                        return values;\n+                    })\n+                    .toList();\n+\n+            if (handles.lookupException(passHandle) != null) {\n+                return null;    \/\/ some exception for a class, do not return the object\n+            }\n+\n+            \/\/ Check that the types are assignable for all slots before assigning.\n+            slotValues.forEach(v -> v.defaultCheckFieldValues(obj));\n+            slotValues.forEach(v -> v.defaultSetFieldValues(obj));\n+            return obj;\n+        } catch (InstantiationException | InvocationTargetException ex) {\n+            throw new InvalidClassException(desc.forClass().getName(),\n+                    \"unable to create instance\", ex);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Reads (or attempts to skip, if not instantiatable or is tagged with a\n@@ -2260,2 +2408,2 @@\n-     * object in stream, from superclass to subclass.  Expects that passHandle\n-     * is set to obj's handle before this method is called.\n+     * object in stream, from superclass to subclass.\n+     * Expects that passHandle is set to current handle before this method is called.\n@@ -2263,1 +2411,1 @@\n-    private void readSerialData(Object obj, ObjectStreamClass desc)\n+    private Object readSerialCustomData(ObjectStreamClass desc, boolean unshared)\n@@ -2266,16 +2414,3 @@\n-        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();\n-        \/\/ Best effort Failure Atomicity; slotValues will be non-null if field\n-        \/\/ values can be set after reading all field data in the hierarchy.\n-        \/\/ Field values can only be set after reading all data if there are no\n-        \/\/ user observable methods in the hierarchy, readObject(NoData). The\n-        \/\/ top most Serializable class in the hierarchy can be skipped.\n-        FieldValues[] slotValues = null;\n-\n-        boolean hasSpecialReadMethod = false;\n-        for (int i = 1; i < slots.length; i++) {\n-            ObjectStreamClass slotDesc = slots[i].desc;\n-            if (slotDesc.hasReadObjectMethod()\n-                  || slotDesc.hasReadObjectNoDataMethod()) {\n-                hasSpecialReadMethod = true;\n-                break;\n-            }\n+        if (!desc.isInstantiable()) {\n+            \/\/ No local class to create, read and discard\n+            return readAbsentLocalClass(desc, unshared);\n@@ -2283,34 +2418,12 @@\n-        \/\/ No special read methods, can store values and defer setting.\n-        if (!hasSpecialReadMethod)\n-            slotValues = new FieldValues[slots.length];\n-\n-        for (int i = 0; i < slots.length; i++) {\n-            ObjectStreamClass slotDesc = slots[i].desc;\n-            if (slots[i].hasData) {\n-                if (obj == null || handles.lookupException(passHandle) != null) {\n-                    \/\/ Read fields of the current descriptor into a new FieldValues and discard\n-                    new FieldValues(slotDesc, true);\n-                } else if (slotDesc.hasReadObjectMethod()) {\n-                    SerialCallbackContext oldContext = curContext;\n-                    if (oldContext != null)\n-                        oldContext.check();\n-                    try {\n-                        curContext = new SerialCallbackContext(obj, slotDesc);\n-\n-                        bin.setBlockDataMode(true);\n-                        slotDesc.invokeReadObject(obj, this);\n-                    } catch (ClassNotFoundException ex) {\n-                        \/*\n-                         * In most cases, the handle table has already\n-                         * propagated a CNFException to passHandle at this\n-                         * point; this mark call is included to address cases\n-                         * where the custom readObject method has cons'ed and\n-                         * thrown a new CNFException of its own.\n-                         *\/\n-                        handles.markException(passHandle, ex);\n-                    } finally {\n-                        curContext.setUsed();\n-                        if (oldContext!= null)\n-                            oldContext.check();\n-                        curContext = oldContext;\n-                    }\n+        TRACE(\"readSerialCustomData: %s, ex: %s\", desc.getName(), handles.lookupException(passHandle));\n+        try {\n+            Object obj = desc.newInstance();\n+            if (!unshared)\n+                handles.setObject(passHandle, obj);\n+            \/\/ Read data into each of the slots for the class\n+            return readSerialCustomSlots(obj, desc.getClassDataLayout());\n+        } catch (InstantiationException | InvocationTargetException ex) {\n+            throw new InvalidClassException(desc.forClass().getName(),\n+                    \"unable to create instance\", ex);\n+        }\n+    }\n@@ -2319,6 +2432,22 @@\n-                    \/*\n-                     * defaultDataEnd may have been set indirectly by custom\n-                     * readObject() method when calling defaultReadObject() or\n-                     * readFields(); clear it to restore normal read behavior.\n-                     *\/\n-                    defaultDataEnd = false;\n+    \/**\n+     * Reads from the stream using custom or default readObject methods appropriate.\n+     * For each slot, either the custom readObject method or the default reader of fields\n+     * is invoked. Unused slot specific custom data is discarded.\n+     * This function is used by {@link #readSerialCustomData}.\n+     *\n+     * @param obj the object to assign the values to\n+     * @param slots a list of slots to read from the stream\n+     * @return the object being initialized\n+     * @throws IOException if there are I\/O errors while reading from the\n+     *         underlying {@code InputStream}\n+     *\/\n+    private Object readSerialCustomSlots(Object obj, List<ClassDataSlot> slots) throws IOException {\n+        TRACE(\"    readSerialCustomSlots: %s\", slots);\n+\n+        for (ClassDataSlot slot : slots) {\n+            ObjectStreamClass slotDesc = slot.desc;\n+            if (slot.hasData) {\n+                if (slotDesc.hasReadObjectMethod() &&\n+                        handles.lookupException(passHandle) == null) {\n+                    \/\/ Invoke slot custom readObject method\n+                    readSlotViaReadObject(obj, slotDesc);\n@@ -2328,8 +2457,4 @@\n-                    if (slotValues != null) {\n-                        slotValues[i] = values;\n-                    } else if (obj != null) {\n-                        if (handles.lookupException(passHandle) == null) {\n-                            \/\/ passHandle NOT marked with an exception; set field values\n-                            values.defaultCheckFieldValues(obj);\n-                            values.defaultSetFieldValues(obj);\n-                        }\n+                    if (handles.lookupException(passHandle) == null) {\n+                        \/\/ Set the instance fields if no previous exception\n+                        values.defaultCheckFieldValues(obj);\n+                        values.defaultSetFieldValues(obj);\n@@ -2337,6 +2462,1 @@\n-                }\n-\n-                if (slotDesc.hasWriteObjectData()) {\n-                    skipCustomData();\n-                } else {\n-                    bin.setBlockDataMode(false);\n+                    finishBlockData(slotDesc);\n@@ -2345,4 +2465,2 @@\n-                if (obj != null &&\n-                    slotDesc.hasReadObjectNoDataMethod() &&\n-                    handles.lookupException(passHandle) == null)\n-                {\n+                if (slotDesc.hasReadObjectNoDataMethod() &&\n+                        handles.lookupException(passHandle) == null) {\n@@ -2353,0 +2471,2 @@\n+        return obj;\n+    }\n@@ -2354,11 +2474,78 @@\n-        if (obj != null && slotValues != null && handles.lookupException(passHandle) == null) {\n-            \/\/ passHandle NOT marked with an exception\n-            \/\/ Check that the non-primitive types are assignable for all slots\n-            \/\/ before assigning.\n-            for (int i = 0; i < slots.length; i++) {\n-                if (slotValues[i] != null)\n-                    slotValues[i].defaultCheckFieldValues(obj);\n-            }\n-            for (int i = 0; i < slots.length; i++) {\n-                if (slotValues[i] != null)\n-                    slotValues[i].defaultSetFieldValues(obj);\n+    \/**\n+     * Invoke the readObject method of the class to read and store the state from the stream.\n+     *\n+     * @param obj an instance of the class being created, only partially initialized.\n+     * @param slotDesc the ObjectStreamDescriptor for the current class\n+     * @throws IOException if there are I\/O errors while reading from the\n+     *         underlying {@code InputStream}\n+     *\/\n+    private void readSlotViaReadObject(Object obj, ObjectStreamClass slotDesc) throws IOException {\n+        TRACE(\"readSlotViaReadObject: %s\", slotDesc.getName());\n+        assert obj != null : \"readSlotViaReadObject called when obj == null\";\n+\n+        SerialCallbackContext oldContext = curContext;\n+        if (oldContext != null)\n+            oldContext.check();\n+        try {\n+            curContext = new SerialCallbackContext(obj, slotDesc);\n+\n+            bin.setBlockDataMode(true);\n+            slotDesc.invokeReadObject(obj, this);\n+        } catch (ClassNotFoundException ex) {\n+            \/*\n+             * In most cases, the handle table has already\n+             * propagated a CNFException to passHandle at this\n+             * point; this mark call is included to address cases\n+             * where the custom readObject method has cons'ed and\n+             * thrown a new CNFException of its own.\n+             *\/\n+            handles.markException(passHandle, ex);\n+        } finally {\n+            curContext.setUsed();\n+            if (oldContext!= null)\n+                oldContext.check();\n+            curContext = oldContext;\n+        }\n+\n+        \/*\n+         * defaultDataEnd may have been set indirectly by custom\n+         * readObject() method when calling defaultReadObject() or\n+         * readFields(); clear it to restore normal read behavior.\n+         *\/\n+        defaultDataEnd = false;\n+\n+        finishBlockData(slotDesc);\n+    }\n+\n+\n+    \/**\n+     * Read and discard an entire object, leaving a null reference in the HandleTable.\n+     * The descriptor of the class in the stream is used to read the fields from the stream.\n+     * There is no instance in which to store the field values.\n+     * Custom data following the fields of any slot is read and discarded.\n+     * References to nested objects are read and retained in the\n+     * handle table using the regular mechanism.\n+     * Handles later in the stream may refer to the nested objects.\n+     *\n+     * @param desc the stream class descriptor\n+     * @param unshared the unshared flag, ignored since no object is created\n+     * @return null, no object is created\n+     * @throws IOException if there are I\/O errors while reading from the\n+     *         underlying {@code InputStream}\n+     *\/\n+    private Object readAbsentLocalClass(ObjectStreamClass desc, boolean unshared)\n+            throws IOException {\n+        TRACE(\"readAbsentLocalClass: %s\", desc.getName());\n+        desc.getClassDataLayout().stream()\n+                .filter(s -> s.hasData)\n+                .forEach(s2 -> {new FieldValues(s2.desc, true); finishBlockData(s2.desc);});\n+        return null;\n+    }\n+\n+    \/\/ Finish handling of block data by skipping any remaining and setting BlockDataMode = false\n+    private void finishBlockData(ObjectStreamClass slotDesc) throws UncheckedIOException {\n+        try {\n+            if (slotDesc.hasWriteObjectData()) {\n+                skipCustomData();\n+            } else {\n+                bin.setBlockDataMode(false);\n@@ -2366,0 +2553,2 @@\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n@@ -2461,0 +2650,1 @@\n+         * @throws UncheckedIOException if any IOException occurs\n@@ -2462,2 +2652,9 @@\n-        FieldValues(ObjectStreamClass desc, boolean recordDependencies) throws IOException {\n-            this.desc = desc;\n+        FieldValues(ObjectStreamClass desc, boolean recordDependencies) throws UncheckedIOException {\n+            try {\n+                this.desc = desc;\n+                TRACE(\"    reading FieldValues: %s\", desc.getName());\n+                int primDataSize = desc.getPrimDataSize();\n+                primValues = (primDataSize > 0) ? new byte[primDataSize] : null;\n+                if (primDataSize > 0) {\n+                    bin.readFully(primValues, 0, primDataSize, false);\n+                }\n@@ -2465,18 +2662,14 @@\n-            int primDataSize = desc.getPrimDataSize();\n-            primValues = (primDataSize > 0) ? new byte[primDataSize] : null;\n-            if (primDataSize > 0) {\n-                bin.readFully(primValues, 0, primDataSize, false);\n-            }\n-            int numObjFields = desc.getNumObjFields();\n-            objValues = (numObjFields > 0) ? new Object[numObjFields] : null;\n-            objHandles = (numObjFields > 0) ? new int[numObjFields] : null;\n-            if (numObjFields > 0) {\n-                int objHandle = passHandle;\n-                ObjectStreamField[] fields = desc.getFields(false);\n-                int numPrimFields = fields.length - objValues.length;\n-                for (int i = 0; i < objValues.length; i++) {\n-                    ObjectStreamField f = fields[numPrimFields + i];\n-                    objValues[i] = readObject0(Object.class, f.isUnshared());\n-                    objHandles[i] = passHandle;\n-                    if (recordDependencies && f.getField() != null) {\n-                        handles.markDependency(objHandle, passHandle);\n+                int numObjFields = desc.getNumObjFields();\n+                objValues = (numObjFields > 0) ? new Object[numObjFields] : null;\n+                objHandles = (numObjFields > 0) ? new int[numObjFields] : null;\n+                if (numObjFields > 0) {\n+                    int objHandle = passHandle;\n+                    ObjectStreamField[] fields = desc.getFields(false);\n+                    int numPrimFields = fields.length - objValues.length;\n+                    for (int i = 0; i < objValues.length; i++) {\n+                        ObjectStreamField f = fields[numPrimFields + i];\n+                        objValues[i] = readObject0(Object.class, f.isUnshared());\n+                        objHandles[i] = passHandle;\n+                        if (recordDependencies && f.getField() != null) {\n+                            handles.markDependency(objHandle, passHandle);\n+                        }\n@@ -2485,0 +2678,1 @@\n+                    passHandle = objHandle;\n@@ -2486,1 +2680,2 @@\n-                passHandle = objHandle;\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":356,"deletions":161,"binary":false,"changes":517,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -490,0 +491,15 @@\n+     * <div class=\"preview-block\">\n+     *      <div class=\"preview-comment\">\n+     *          The \"identity hash code\" of a {@linkplain Class#isValue() value object}\n+     *          is computed by combining the identity hash codes of the value object's fields recursively.\n+     *      <\/div>\n+     * <\/div>\n+     * @apiNote\n+     * <div class=\"preview-block\">\n+     *      <div class=\"preview-comment\">\n+     *          Note that, like ==, this hash code exposes information about a value object's\n+     *          private fields that might otherwise be hidden by an identity object.\n+     *          Developers should be cautious about storing sensitive secrets in value object fields.\n+     *      <\/div>\n+     * <\/div>\n+     *\n@@ -2317,0 +2333,4 @@\n+            public int classFileFormatVersion(Class<?> clazz) {\n+                return clazz.getClassFileVersion();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -612,0 +613,6 @@\n+\n+    \/**\n+     * Returns the class file format version of the class.\n+     *\/\n+    int classFileFormatVersion(Class<?> klass);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-\n@@ -268,0 +267,2 @@\n+    exports jdk.internal.value to  \/\/ Needed by Unsafe\n+        jdk.unsupported;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+    private final boolean allowValueClasses;\n@@ -146,0 +147,2 @@\n+        this.allowValueClasses = (!preview.isPreview(Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -202,0 +205,4 @@\n+    \/** A hash table mapping local classes to a set of outer this fields\n+     *\/\n+    public Map<ClassSymbol, Set<JCExpression>> initializerOuterThis = new WeakHashMap<>();\n+\n@@ -780,1 +787,2 @@\n-            JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC,\n+            \/\/ IDENTITY_TYPE will be interpreted as ACC_SUPER for older class files so we are fine\n+            JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE,\n@@ -1252,1 +1260,2 @@\n-                ctag = makeEmptyClass(STATIC | SYNTHETIC, topClass).sym;\n+                \/\/ IDENTITY_TYPE will be interpreted as ACC_SUPER for older class files so we are fine\n+                ctag = makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE, topClass).sym;\n@@ -1408,3 +1417,4 @@\n-     *  @param pos        The source code position of the definition.\n-     *  @param freevars   The free variables.\n-     *  @param owner      The class in which the definitions go.\n+     *  @param pos               The source code position of the definition.\n+     *  @param freevars          The free variables.\n+     *  @param owner             The class in which the definitions go.\n+     *  @param additionalFlags   Any additional flags\n@@ -1501,1 +1511,1 @@\n-        VarSymbol outerThis = makeOuterThisVarSymbol(owner, FINAL | SYNTHETIC);\n+        VarSymbol outerThis = makeOuterThisVarSymbol(owner, FINAL | SYNTHETIC | (allowValueClasses && owner.isValueClass() ? STRICT : 0));\n@@ -1841,1 +1851,2 @@\n-        return makeEmptyClass(STATIC | SYNTHETIC, clazz).sym;\n+        \/\/ IDENTITY_TYPE will be interpreted as ACC_SUPER for older class files so we are fine\n+        return makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE, clazz).sym;\n@@ -1893,1 +1904,2 @@\n-        assertionsDisabledClassCache = makeEmptyClass(STATIC | SYNTHETIC, outermostClassDef.sym).sym;\n+        \/\/ IDENTITY_TYPE will be interpreted as ACC_SUPER for older class files so we are fine\n+        assertionsDisabledClassCache = makeEmptyClass(STATIC | SYNTHETIC | IDENTITY_TYPE, outermostClassDef.sym).sym;\n@@ -2181,1 +2193,1 @@\n-            tree.pos, freevars(currentClass), currentClass);\n+            tree.pos, freevars(currentClass), currentClass, allowValueClasses && currentClass.isValueClass() ? STRICT : LOCAL_CAPTURE_FIELD);\n@@ -2762,0 +2774,1 @@\n+            ListBuffer<JCStatement> initializers = new ListBuffer<>();\n@@ -2766,6 +2779,4 @@\n-                    tree.body.stats = tree.body.stats.append(\n-                            make.Exec(\n-                                    make.Assign(\n-                                            make.Select(make.This(field.owner.erasure(types)), field),\n-                                            make.Ident(param)).setType(field.erasure(types))));\n-                    \/\/ we don't need the flag at the field anymore\n+                    initializers.add(make.Exec(\n+                            make.Assign(\n+                                    make.Select(make.This(field.owner.erasure(types)), field),\n+                                    make.Ident(param)).setType(field.erasure(types))));\n@@ -2775,0 +2786,7 @@\n+            if (initializers.nonEmpty()) {\n+                if (allowValueClasses && (tree.sym.owner.isValueClass() || tree.sym.owner.hasStrict() || ((ClassSymbol)tree.sym.owner).isRecord())) {\n+                    TreeInfo.mapSuperCalls(tree.body, supercall -> make.Block(0, initializers.toList().append(supercall)));\n+                } else {\n+                    tree.body.stats = tree.body.stats.appendList(initializers);\n+                }\n+            }\n@@ -2990,0 +3008,11 @@\n+                if (currentMethodSym != null &&\n+                        ((currentMethodSym.flags_field & (STATIC | BLOCK)) == BLOCK) &&\n+                        currentMethodSym.owner.isValueClass()) {\n+                    \/\/ instance initializer in a value class\n+                    Set<JCExpression> outerThisSet = initializerOuterThis.get(currentClass);\n+                    if (outerThisSet == null) {\n+                        outerThisSet = new HashSet<>();\n+                    }\n+                    outerThisSet.add(thisArg);\n+                    initializerOuterThis.put(currentClass, outerThisSet);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":44,"deletions":15,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+    private final UnsetFieldsInfo unsetFieldsInfo;\n+\n@@ -130,0 +132,1 @@\n+        unsetFieldsInfo = UnsetFieldsInfo.instance(context);\n@@ -135,0 +138,5 @@\n+        generateEarlyLarvalFrame = options.isSet(\"generateEarlyLarvalFrame\");\n+        Preview preview = Preview.instance(context);\n+        Source source = Source.instance(context);\n+        allowValueClasses = (!preview.isPreview(Source.Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Source.Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -144,0 +152,2 @@\n+    private boolean generateEarlyLarvalFrame;\n+    private final boolean allowValueClasses;\n@@ -427,0 +437,2 @@\n+        \/\/ only used for value classes\n+        ListBuffer<JCStatement> initBlocks = new ListBuffer<>();\n@@ -442,2 +454,7 @@\n-                else if ((block.flags & SYNTHETIC) == 0)\n-                    initCode.append(block);\n+                else if ((block.flags & SYNTHETIC) == 0) {\n+                    if (c.isValueClass() || c.hasStrict()) {\n+                        initBlocks.append(block);\n+                    } else {\n+                        initCode.append(block);\n+                    }\n+                }\n@@ -482,2 +499,1 @@\n-        if (initCode.length() != 0) {\n-            List<JCStatement> inits = initCode.toList();\n+        if (initCode.length() != 0 || initBlocks.length() != 0) {\n@@ -487,1 +503,1 @@\n-                normalizeMethod((JCMethodDecl)t, inits, initTAlist);\n+                normalizeMethod((JCMethodDecl)t, initCode.toList(), initBlocks.toList(), initTAlist);\n@@ -550,1 +566,1 @@\n-    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<TypeCompound> initTAs) {\n+    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<JCStatement> initBlocks,  List<TypeCompound> initTAs) {\n@@ -554,1 +570,7 @@\n-            TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.prepend(supercall)));\n+            if (allowValueClasses & (md.sym.owner.isValueClass() || md.sym.owner.hasStrict() || ((md.sym.owner.flags_field & RECORD) != 0))) {\n+                rewriteInitializersIfNeeded(md, initCode);\n+                md.body.stats = initCode.appendList(md.body.stats);\n+                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initBlocks.prepend(supercall)));\n+            } else {\n+                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.prepend(supercall)));\n+            }\n@@ -563,0 +585,34 @@\n+    void rewriteInitializersIfNeeded(JCMethodDecl md, List<JCStatement> initCode) {\n+        if (lower.initializerOuterThis.containsKey(md.sym.owner)) {\n+            InitializerVisitor initializerVisitor = new InitializerVisitor(md, lower.initializerOuterThis.get(md.sym.owner));\n+            for (JCStatement init : initCode) {\n+                initializerVisitor.scan(init);\n+            }\n+        }\n+    }\n+\n+    public static class InitializerVisitor extends TreeScanner {\n+        JCMethodDecl md;\n+        Set<JCExpression> exprSet;\n+\n+        public InitializerVisitor(JCMethodDecl md, Set<JCExpression> exprSet) {\n+            this.md = md;\n+            this.exprSet = exprSet;\n+        }\n+\n+        @Override\n+        public void visitTree(JCTree tree) {}\n+\n+        @Override\n+        public void visitIdent(JCIdent tree) {\n+            if (exprSet.contains(tree)) {\n+                for (JCVariableDecl param: md.params) {\n+                    if (param.name == tree.name &&\n+                            ((param.sym.flags_field & (MANDATED | NOOUTERTHIS)) == (MANDATED | NOOUTERTHIS))) {\n+                        tree.sym = param.sym;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -947,0 +1003,5 @@\n+                Set<VarSymbol> prevUnsetFields = code.currentUnsetFields;\n+                if (meth.isConstructor()) {\n+                    code.currentUnsetFields = unsetFieldsInfo.getUnsetFields(env.enclClass.sym, tree.body);\n+                    code.initialUnsetFields = unsetFieldsInfo.getUnsetFields(env.enclClass.sym, tree.body);\n+                }\n@@ -954,0 +1015,2 @@\n+                } finally {\n+                    code.currentUnsetFields = prevUnsetFields;\n@@ -1022,1 +1085,2 @@\n-                                        poolWriter);\n+                                        poolWriter,\n+                                        generateEarlyLarvalFrame);\n@@ -1158,0 +1222,13 @@\n+            Set<VarSymbol> prevCodeUnsetFields = code.currentUnsetFields;\n+            try {\n+                genLoopHelper(loop, body, cond, step, testFirst);\n+            } finally {\n+                code.currentUnsetFields = prevCodeUnsetFields;\n+            }\n+        }\n+\n+        private void genLoopHelper(JCStatement loop,\n+                             JCStatement body,\n+                             JCExpression cond,\n+                             List<JCExpressionStatement> step,\n+                             boolean testFirst) {\n@@ -1216,0 +1293,1 @@\n+        Set<VarSymbol> prevCodeUnsetFields = code.currentUnsetFields;\n@@ -1221,0 +1299,1 @@\n+            code.currentUnsetFields = prevCodeUnsetFields;\n@@ -1296,0 +1375,10 @@\n+        Set<VarSymbol> prevCodeUnsetFields = code.currentUnsetFields;\n+        try {\n+            handleSwitchHelper(swtch, selector, cases, patternSwitch);\n+        } finally {\n+            code.currentUnsetFields = prevCodeUnsetFields;\n+        }\n+    }\n+\n+    void handleSwitchHelper(JCTree swtch, JCExpression selector, List<JCCase> cases,\n+                      boolean patternSwitch) {\n@@ -1307,1 +1396,1 @@\n-                             CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());\n+                        CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());\n@@ -1313,1 +1402,1 @@\n-                             CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());\n+                        CRT_FLOW_CONTROLLER, startpcCrt, code.curCP());\n@@ -1349,5 +1438,5 @@\n-                nlabels > 0 &&\n-                table_space_cost + 3 * table_time_cost <=\n-                lookup_space_cost + 3 * lookup_time_cost\n-                ?\n-                tableswitch : lookupswitch;\n+                    nlabels > 0 &&\n+                            table_space_cost + 3 * table_time_cost <=\n+                                    lookup_space_cost + 3 * lookup_time_cost\n+                            ?\n+                            tableswitch : lookupswitch;\n@@ -1389,2 +1478,2 @@\n-                            tableBase + 4 * (labels[i] - lo + 3),\n-                            pc - startpc);\n+                                tableBase + 4 * (labels[i] - lo + 3),\n+                                pc - startpc);\n@@ -1440,2 +1529,2 @@\n-                 \/\/ Emit line position for the end of a switch expression\n-                 code.statBegin(TreeInfo.endPos(swtch));\n+                \/\/ Emit line position for the end of a switch expression\n+                code.statBegin(TreeInfo.endPos(swtch));\n@@ -1544,0 +1633,9 @@\n+            Set<VarSymbol> prevCodeUnsetFields = code.currentUnsetFields;\n+            try {\n+                genTryHelper(body, catchers, env);\n+            } finally {\n+                code.currentUnsetFields = prevCodeUnsetFields;\n+            }\n+        }\n+\n+        void genTryHelper(JCTree body, List<JCCatch> catchers, Env<GenContext> env) {\n@@ -1563,2 +1661,2 @@\n-                env.info.finalize != null &&\n-                env.info.finalize.hasFinalizer();\n+                    env.info.finalize != null &&\n+                            env.info.finalize.hasFinalizer();\n@@ -1573,1 +1671,1 @@\n-                                                 code.branch(goto_));\n+                            code.branch(goto_));\n@@ -1596,1 +1694,1 @@\n-                                  catchallpc, 0);\n+                            catchallpc, 0);\n@@ -1611,2 +1709,2 @@\n-                              env.info.gaps.next().intValue(),\n-                              catchallpc, 0);\n+                        env.info.gaps.next().intValue(),\n+                        catchallpc, 0);\n@@ -1755,0 +1853,9 @@\n+        Set<VarSymbol> prevCodeUnsetFields = code.currentUnsetFields;\n+        try {\n+            visitIfHelper(tree);\n+        } finally {\n+            code.currentUnsetFields = prevCodeUnsetFields;\n+        }\n+    }\n+\n+    public void visitIfHelper(JCIf tree) {\n@@ -1759,1 +1866,1 @@\n-                             CRT_FLOW_CONTROLLER);\n+                CRT_FLOW_CONTROLLER);\n@@ -2083,0 +2190,2 @@\n+        Set<VarSymbol> tmpUnsetSymbols = unsetFieldsInfo.getUnsetFields(env.enclClass.sym, tree);\n+        code.currentUnsetFields = tmpUnsetSymbols != null ? tmpUnsetSymbols : code.currentUnsetFields;\n@@ -2361,1 +2470,1 @@\n-       }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":136,"deletions":27,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import com.sun.tools.javac.code.Flags.Flag;\n@@ -43,0 +44,1 @@\n+import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;\n@@ -55,0 +57,1 @@\n+import static com.sun.tools.javac.code.Flags.asFlagSet;\n@@ -63,0 +66,1 @@\n+import static com.sun.tools.javac.parser.Tokens.TokenKind.SYNCHRONIZED;\n@@ -204,0 +208,2 @@\n+        this.allowValueClasses = (!preview.isPreview(Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -229,0 +235,2 @@\n+        this.allowValueClasses = (!preview.isPreview(Feature.VALUE_CLASSES) || preview.isEnabled()) &&\n+                Feature.VALUE_CLASSES.allowedInSource(source);\n@@ -267,0 +275,4 @@\n+    \/** Switch: are value classes allowed in this source level?\n+     *\/\n+    boolean allowValueClasses;\n+\n@@ -1686,2 +1698,2 @@\n-                        if (!isMode(TYPE) && isUnboundMemberRef()) {\n-                            \/\/this is an unbound method reference whose qualifier\n+                        if (!isMode(TYPE) && isParameterizedTypePrefix()) {\n+                            \/\/this is either an unbound method reference whose qualifier\n@@ -1929,1 +1941,1 @@\n-    boolean isUnboundMemberRef() {\n+    boolean isParameterizedTypePrefix() {\n@@ -3024,0 +3036,5 @@\n+        if ((isValueModifier()) && allowValueClasses) {\n+            checkSourceLevel(Feature.VALUE_CLASSES);\n+            dc = token.docComment();\n+            return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));\n+        }\n@@ -3629,0 +3646,5 @@\n+                if (isValueModifier()) {\n+                    checkSourceLevel(Feature.VALUE_CLASSES);\n+                    flag = Flags.VALUE_CLASS;\n+                    break;\n+                }\n@@ -3894,0 +3916,7 @@\n+        if (name == names.value) {\n+            if (allowValueClasses) {\n+                return Source.JDK23;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK23));\n+            }\n+        }\n@@ -5011,0 +5040,26 @@\n+    protected boolean isValueModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.value) {\n+            boolean isValueModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n+                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n+                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n+                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n+                case CLASS: case INTERFACE: case ENUM:\n+                    isValueModifier = true;\n+                    break;\n+                case IDENTIFIER: \/\/ value record R || value value || new value Comparable() {} ??\n+                    if (next.name() == names.record || next.name() == names.value\n+                            || (mode & EXPR) != 0)\n+                        isValueModifier = true;\n+                    break;\n+            }\n+            if (isValueModifier) {\n+                checkSourceLevel(Feature.VALUE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -5038,1 +5093,3 @@\n-                case IDENTIFIER -> isNonSealedIdentifier(next, currentIsNonSealed ? 3 : 1) || next.name() == names.sealed;\n+                case IDENTIFIER -> isNonSealedIdentifier(next, currentIsNonSealed ? 3 : 1) ||\n+                        next.name() == names.sealed ||\n+                        allowValueClasses && next.name() == names.value;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":61,"deletions":4,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.tools.javac.comp.AttrContext;\n@@ -199,1 +198,2 @@\n-                return ident.name == names._this || ident.name == names._super;\n+                return ident.name == names._this && tree.type.tsym == currentClass.tsym ||\n+                       ident.name == names._super;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,0 +84,9 @@\n+compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/MemoryAccessProviderTest.java 8350208 generic-all\n+compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotResolvedJavaField.java 8350208 generic-all\n+\n+# Valhalla\n+compiler\/gcbarriers\/TestImplicitNullChecks.java 8367338 generic-all\n+compiler\/regalloc\/TestVerifyRegisterAllocator.java 8365895 windows-x64\n+compiler\/types\/TestArrayManyDimensions.java 8365895 windows-x64\n+compiler\/types\/correctness\/OffTest.java 8365895 windows-x64\n+\n@@ -103,0 +112,1 @@\n+runtime\/cds\/appcds\/redefineClass\/RedefineRunningMethods_Shared.java  8304168 generic-all\n@@ -122,0 +132,99 @@\n+\n+# Valhalla\n+runtime\/AccModule\/ConstModule.java 8294051 generic-all\n+runtime\/valhalla\/inlinetypes\/CircularityTest.java 8349037 generic-all\n+runtime\/valhalla\/inlinetypes\/verifier\/StrictInstanceFieldsTest.java CODETOOLS-7904031 generic-all\n+runtime\/valhalla\/inlinetypes\/verifier\/StrictStaticFieldsTest.java CODETOOLS-7904031 generic-all\n+\n+runtime\/cds\/TestDefaultArchiveLoading.java#coops_nocoh            8366774           generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#nocoops_nocoh          8366774           generic-all\n+\n+# Valhalla + COH\n+compiler\/c2\/autovectorization\/TestIndexOverflowIR.java                          8348568 generic-all\n+compiler\/c2\/irTests\/TestVectorConditionalMove.java                              8348568 generic-all\n+compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java                      8348568 generic-all\n+compiler\/c2\/irTests\/TestVectorizationNotRun.java                                8348568 generic-all\n+compiler\/c2\/TestCastX2NotProcessedIGVN.java                                     8348568 generic-all\n+compiler\/loopopts\/superword\/TestAlignVector.java                                8348568 generic-all\n+compiler\/loopopts\/superword\/TestAlignVector.java#NoAlignVector-COH              8348568 generic-all\n+compiler\/loopopts\/superword\/TestAlignVector.java#VerifyAlignVector-COH          8348568 generic-all\n+compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java       8348568 generic-all\n+compiler\/loopopts\/superword\/TestMulAddS2I.java                                  8348568 generic-all\n+compiler\/loopopts\/superword\/TestScheduleReordersScalarMemops.java               8348568 generic-all\n+compiler\/loopopts\/superword\/TestSplitPacks.java                                 8348568 generic-all\n+compiler\/loopopts\/superword\/TestUnorderedReductionPartialVectorization.java     8348568 generic-all\n+compiler\/vectorization\/TestFloatConversionsVector.java                          8348568 generic-all\n+compiler\/vectorization\/runner\/ArrayTypeConvertTest.java                         8348568 generic-all\n+compiler\/vectorization\/runner\/LoopCombinedOpTest.java                           8348568 generic-all\n+compiler\/vectorization\/runner\/VectorizationTestRunner.java                      8348568 generic-all\n+runtime\/FieldLayout\/TestOopMapSizeMinimal.java#no_coops_ccptr_coh               8348568 generic-all\n+\n+gc\/stress\/gcbasher\/TestGCBasherWithParallel.java                                8348568 generic-all\n+\n+gtest\/CompressedKlassGtest.java#use-zero-based-encoding-coh                     8348568 generic-all\n+gtest\/CompressedKlassGtest.java#use-zero-based-encoding-coh-large-class-space   8348568 generic-all\n+gtest\/MetaspaceGtests.java#UseCompactObjectHeaders                              8348568 generic-all\n+\n+runtime\/CompressedOops\/CompressedClassPointersEncodingScheme.java               8348568 generic-all\n+runtime\/FieldLayout\/BaseOffsets.java#no-coops-with-coh                          8348568 generic-all\n+runtime\/FieldLayout\/BaseOffsets.java#with-coop--with-coh                        8348568 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#coops_coh                            8348568 generic-all\n+runtime\/cds\/TestDefaultArchiveLoading.java#nocoops_coh                          8348568 generic-all\n+runtime\/cds\/appcds\/TestZGCWithCDS.java                                          8348568 generic-all\n+\n+# Valhalla + AOT\n+runtime\/cds\/appcds\/aotCache\/AOTCacheSupportForCustomLoaders.java                8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/AOTLoggingTag.java                                  8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/ClassPathLogging.java                               8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/ExcludedClasses.java                                8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/HelloAOTCache.java                                  8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/JavaAgent.java                                      8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/ManagementAgent.java                                8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/PackageInfoClass.java                               8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/SpecialCacheNames.java                              8366701 generic-all\n+runtime\/cds\/appcds\/aotCache\/VerifierFailOver.java                               8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/AOTCacheWithZGC.java                         8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/AOTLoaderConstraintsTest.java                8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/AddExports.java                              8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/AddOpens.java                                8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/AddReads.java                                8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java#aot                      8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/FakeCodeLocation.java                        8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/GeneratedInternedString.java                 8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/MethodHandleTest.java                        8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/NonFinalStaticWithInitVal.java               8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/StringConcatStress.java#aot                  8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/TestSetupAOTTest.java                        8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/TrainingRun.java                             8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/WeakReferenceTest.java                       8366701 generic-all\n+runtime\/cds\/appcds\/aotCode\/AOTCodeCompressedOopsTest.java                       8366701 generic-all\n+runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java                                    8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/AOTFlags.java                                       8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/FileNameSubstitution.java                           8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/JDK_AOT_VM_OPTIONS.java                             8366701 generic-all\n+runtime\/cds\/appcds\/aotProfile\/AOTProfileFlags.java                              8366701 generic-all\n+runtime\/cds\/appcds\/applications\/JavacBench.java#aot                             8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesAsCollectorTest.java#aot          8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesCastFailureTest.java#aot          8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesGeneralTest.java#aot              8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesInvokersTest.java#aot             8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesPermuteArgumentsTest.java#aot     8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesSpreadArgumentsTest.java#aot      8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/StringConcatStress.java#aot                  8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/TestSetupAOTTest.java                        8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/TrainingRun.java                             8366701 generic-all\n+runtime\/cds\/appcds\/aotClassLinking\/WeakReferenceTest.java                       8366701 generic-all\n+runtime\/cds\/appcds\/aotCode\/AOTCodeCompressedOopsTest.java                       8366701 generic-all\n+runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java                                    8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/AOTFlags.java                                       8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/FileNameSubstitution.java                           8366701 generic-all\n+runtime\/cds\/appcds\/aotFlags\/JDK_AOT_VM_OPTIONS.java                             8366701 generic-all\n+runtime\/cds\/appcds\/aotProfile\/AOTProfileFlags.java                              8366701 generic-all\n+runtime\/cds\/appcds\/applications\/JavacBench.java#aot                             8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesAsCollectorTest.java#aot          8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesCastFailureTest.java#aot          8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesGeneralTest.java#aot              8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesInvokersTest.java#aot             8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesPermuteArgumentsTest.java#aot     8366701 generic-all\n+runtime\/cds\/appcds\/methodHandles\/MethodHandlesSpreadArgumentsTest.java#aot      8366701 generic-all\n+\n@@ -150,0 +259,77 @@\n+# Valhalla TODO:\n+serviceability\/jvmti\/valhalla\/HeapDump\/HeapDump.java 8317416 generic-all\n+\n+serviceability\/sa\/ClhsdbCDSCore.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbCDSJstackPrintAll.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbFindPC.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbInspect.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbLongConstant.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbJdis.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbJstack.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintAll.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintAs.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbPrintStatics.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbSource.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbSymbol.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbWhere.java 8190936 generic-all\n+serviceability\/sa\/JhsdbThreadInfoTest.java 8190936 generic-all\n+serviceability\/sa\/TestClassDump.java 8190936 generic-all\n+serviceability\/sa\/TestClhsdbJstackLock.java 8190936 generic-all\n+serviceability\/sa\/TestCpoolForInvokeDynamic.java 8190936 generic-all\n+serviceability\/sa\/TestHeapDumpForInvokeDynamic.java 8190936 generic-all\n+serviceability\/sa\/TestHeapDumpForLargeArray.java 8190936 generic-all\n+serviceability\/sa\/TestIntConstant.java 8190936 generic-all\n+serviceability\/sa\/TestJhsdbJstackLock.java 8190936 generic-all\n+serviceability\/sa\/TestJmapCore.java 8190936 generic-all\n+serviceability\/sa\/TestJmapCoreMetaspace.java 8190936 generic-all\n+serviceability\/sa\/TestPrintMdo.java 8190936 generic-all\n+serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java 8190936 generic-all\n+serviceability\/sa\/ClhsdbDumpclass.java 8190936 generic-all\n+\n+# Array Changes TODO\n+serviceability\/sa\/CDSJMapClstats.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbClasses.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/DisableRegistryTest.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbDumpheap.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/ClhsdbTestConnectArgument.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJhisto.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstack.java#id1 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstackWithConcurrentLock.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstackXcompStress.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbPstack.java#process 8365722 generic-all\n+serviceability\/sa\/ClhsdbPstack.java#core 8365722 generic-all\n+serviceability\/sa\/ClhsdbScanOops.java#id0 8365722 generic-all\n+serviceability\/sa\/ClhsdbScanOops.java#id1 8365722 generic-all\n+serviceability\/sa\/DeadlockDetectionTest.java 8365722 generic-all\n+serviceability\/sa\/ClhsdbJstack.java#id0 8365722 generic-all\n+serviceability\/sa\/TestInstanceKlassSize.java 8365722 generic-all\n+serviceability\/sa\/TestSysProps.java 8365722 generic-all\n+serviceability\/sa\/sadebugd\/ClhsdbAttachToDebugServer.java 8365722 generic-all\n+resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8365722 generic-all\n+serviceability\/HeapDump\/DuplicateArrayClassesTest.java 8365722 generic-all\n+\n+resourcehogs\/serviceability\/sa\/ClhsdbRegionDetailsScanOopsForG1.java 8366806 generic-all\n+serviceability\/jvmti\/valhalla\/GetSetLocal\/ValueGetSetLocal.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/Accessible\/isPackagePrivate\/accipp001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/Accessible\/isPrivate\/isPrivate001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/Accessible\/isProtected\/isProtected001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/Accessible\/isPublic\/isPublic001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ClassObjectReference\/reflectedType\/reflectype001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ClassObjectReference\/toString\/tostring001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ReferenceType\/classObject\/classobj001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ReferenceType\/equals\/equals001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ReferenceType\/genericSignature\/genericSignature001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ReferenceType\/genericSignature\/genericSignature002\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ReferenceType\/hashCode\/hashcode001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ReferenceType\/isFinal\/isfinal001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ReferenceType\/isStatic\/isstatic001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ReferenceType\/isStatic\/isstatic002\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ReferenceType\/name\/name001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ReferenceType\/nestedTypes\/nestedtypes002\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/ReferenceType\/sourceName\/sourcename003\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/VirtualMachineManager\/connectedVirtualMachines\/convm001\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/VirtualMachineManager\/connectedVirtualMachines\/convm002\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jdi\/VirtualMachineManager\/connectedVirtualMachines\/convm003\/TestDescription.java 8366806 generic-all\n+vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM04\/em04t001\/TestDescription.java 8366806 generic-all\n+\n@@ -189,0 +375,2 @@\n+vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/byteMutation\/Test.java 8317172 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":188,"deletions":0,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-requiredVersion=7.5.2+1\n+requiredVersion=7.5.1+1\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import compiler.valhalla.inlinetypes.InlineTypeIRNode;\n@@ -90,1 +91,1 @@\n-    private static final String PREFIX = \"_#\";\n+    public static final String PREFIX = \"_#\";\n@@ -105,2 +106,2 @@\n-    private static final String STORE_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n-    private static final String LOAD_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n+    private static final String STORE_OF_CLASS_POSTFIX = \"( \\\\([^\\\\)]+\\\\))?(:|\\\\+)\\\\S* \\\\*\" + END;\n+    private static final String LOAD_OF_CLASS_POSTFIX = \"( \\\\([^\\\\)]+\\\\))?(:|\\\\+)\\\\S* \\\\*\" + END;\n@@ -155,0 +156,6 @@\n+    \/\/ Valhalla: Make sure that all Valhalla specific IR nodes are also properly initialized. Doing it here also\n+    \/\/           ensures that the Flag VM is able to pick up the correct compile phases.\n+    static {\n+        InlineTypeIRNode.forceStaticInitialization();\n+    }\n+\n@@ -386,2 +393,6 @@\n-        String regex = START + \"Allocate\\\\b\" + MID + \"allocationKlass:.*\\\\b\" + IS_REPLACED + \"\\\\s.*\" + END;\n-        macroNodes(ALLOC_OF, regex);\n+        allocateOfNodes(ALLOC_OF, IS_REPLACED);\n+    }\n+\n+    public static void allocateOfNodes(String irNodePlaceholder, String allocatee) {\n+        String regex = START + \"Allocate\\\\b\" + MID + \"allocationKlass:.*\\\\b\" + allocatee + \"\\\\s.*\" + END;\n+        macroNodes(irNodePlaceholder, regex);\n@@ -398,0 +409,4 @@\n+        allocateArrayOfNodes(ALLOC_ARRAY_OF, IS_REPLACED);\n+    }\n+\n+    public static void allocateArrayOfNodes(String irNodePlaceholder, String allocatee) {\n@@ -416,1 +431,1 @@\n-        String name_part = \"\\\\[+.(\" + partial_name_prefix + \")?\" + IS_REPLACED + \";\";\n+        String name_part = \"\\\\[+.(\" + partial_name_prefix + \")?\" + allocatee + \";\";\n@@ -418,1 +433,1 @@\n-        macroNodes(ALLOC_ARRAY_OF, regex);\n+        macroNodes(irNodePlaceholder, regex);\n@@ -483,1 +498,1 @@\n-        callOfNodes(CALL_OF, \"Call.*\");\n+        callOfNodes(CALL_OF, \"Call.*\", IS_REPLACED + \" \" );\n@@ -488,1 +503,6 @@\n-        callOfNodes(CALL_OF_METHOD, \"Call.*Java\");\n+        callOfNodes(CALL_OF_METHOD, \"Call.*Java\", IS_REPLACED + \" \");\n+    }\n+\n+    public static final String STATIC_CALL = PREFIX + \"STATIC_CALL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STATIC_CALL, \"CallStaticJava\");\n@@ -493,1 +513,19 @@\n-        callOfNodes(STATIC_CALL_OF_METHOD, \"CallStaticJava\");\n+        staticCallOfMethodNodes(STATIC_CALL_OF_METHOD, IS_REPLACED + \" \");\n+    }\n+\n+    public static void staticCallOfMethodNodes(String irNodePlaceholder, String calleeRegex) {\n+        callOfNodes(irNodePlaceholder, \"CallStaticJava\", calleeRegex);\n+    }\n+\n+    public static final String CALL_LEAF_NO_FP = PREFIX + \"CALL_LEAF_NO_FP\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CALL_LEAF_NO_FP, \"CallLeafNoFP\");\n+    }\n+\n+    public static final String CALL_LEAF_NO_FP_OF_METHOD = COMPOSITE_PREFIX + \"CALL_LEAF_NO_FP_OF_METHOD\" + POSTFIX;\n+    static {\n+        callLeafNoFpOfMethodNodes(CALL_LEAF_NO_FP_OF_METHOD, IS_REPLACED);\n+    }\n+\n+    public static void callLeafNoFpOfMethodNodes(String irNodePlaceholder, String calleeRegex) {\n+        callOfNodes(irNodePlaceholder, \"CallLeafNoFP\", calleeRegex);\n@@ -590,0 +628,5 @@\n+    public static final String CMP_N = PREFIX + \"CMP_N\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_N, \"CmpN\");\n+    }\n+\n@@ -704,1 +747,1 @@\n-        callOfNodes(DYNAMIC_CALL_OF_METHOD, \"CallDynamicJava\");\n+        callOfNodes(DYNAMIC_CALL_OF_METHOD, \"CallDynamicJava\", IS_REPLACED);\n@@ -840,0 +883,5 @@\n+    public static final String INLINE_TYPE = PREFIX + \"INLINE_TYPE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(INLINE_TYPE, \"InlineType\");\n+    }\n+\n@@ -880,1 +928,5 @@\n-        loadOfNodes(LOAD_OF_CLASS, \"Load(B|UB|S|US|I|L|F|D|P|N)\");\n+        anyLoadOfNodes(LOAD_OF_CLASS, IS_REPLACED);\n+    }\n+\n+    public static void anyLoadOfNodes(String irNodePlaceholder, String fieldHolder) {\n+        loadOfNodes(irNodePlaceholder, \"Load(B|UB|S|US|I|L|F|D|P|N)\", fieldHolder);\n@@ -890,1 +942,1 @@\n-        loadOfNodes(LOAD_B_OF_CLASS, \"LoadB\");\n+        loadOfNodes(LOAD_B_OF_CLASS, \"LoadB\", IS_REPLACED);\n@@ -900,1 +952,1 @@\n-        loadOfNodes(LOAD_D_OF_CLASS, \"LoadD\");\n+        loadOfNodes(LOAD_D_OF_CLASS, \"LoadD\", IS_REPLACED);\n@@ -910,1 +962,1 @@\n-        loadOfNodes(LOAD_F_OF_CLASS, \"LoadF\");\n+        loadOfNodes(LOAD_F_OF_CLASS, \"LoadF\", IS_REPLACED);\n@@ -920,1 +972,1 @@\n-        loadOfNodes(LOAD_I_OF_CLASS, \"LoadI\");\n+        loadOfNodes(LOAD_I_OF_CLASS, \"LoadI\", IS_REPLACED);\n@@ -945,1 +997,1 @@\n-        loadOfNodes(LOAD_L_OF_CLASS, \"LoadL\");\n+        loadOfNodes(LOAD_L_OF_CLASS, \"LoadL\", IS_REPLACED);\n@@ -955,1 +1007,1 @@\n-        loadOfNodes(LOAD_N_OF_CLASS, \"LoadN\");\n+        loadOfNodes(LOAD_N_OF_CLASS, \"LoadN\", IS_REPLACED);\n@@ -971,1 +1023,1 @@\n-        loadOfNodes(LOAD_P_OF_CLASS, \"LoadP\");\n+        loadOfNodes(LOAD_P_OF_CLASS, \"LoadP\", IS_REPLACED);\n@@ -981,1 +1033,1 @@\n-        loadOfNodes(LOAD_S_OF_CLASS, \"LoadS\");\n+        loadOfNodes(LOAD_S_OF_CLASS, \"LoadS\", IS_REPLACED);\n@@ -991,1 +1043,1 @@\n-        loadOfNodes(LOAD_UB_OF_CLASS, \"LoadUB\");\n+        loadOfNodes(LOAD_UB_OF_CLASS, \"LoadUB\", IS_REPLACED);\n@@ -1001,1 +1053,1 @@\n-        loadOfNodes(LOAD_US_OF_CLASS, \"LoadUS\");\n+        loadOfNodes(LOAD_US_OF_CLASS, \"LoadUS\", IS_REPLACED);\n@@ -1885,1 +1937,1 @@\n-        storeOfNodes(STORE_B_OF_CLASS, \"StoreB\");\n+        storeOfNodes(STORE_B_OF_CLASS, \"StoreB\", IS_REPLACED);\n@@ -1895,1 +1947,1 @@\n-        storeOfNodes(STORE_C_OF_CLASS, \"StoreC\");\n+        storeOfNodes(STORE_C_OF_CLASS, \"StoreC\", IS_REPLACED);\n@@ -1905,1 +1957,1 @@\n-        storeOfNodes(STORE_D_OF_CLASS, \"StoreD\");\n+        storeOfNodes(STORE_D_OF_CLASS, \"StoreD\", IS_REPLACED);\n@@ -1915,1 +1967,1 @@\n-        storeOfNodes(STORE_F_OF_CLASS, \"StoreF\");\n+        storeOfNodes(STORE_F_OF_CLASS, \"StoreF\", IS_REPLACED);\n@@ -1925,1 +1977,1 @@\n-        storeOfNodes(STORE_I_OF_CLASS, \"StoreI\");\n+        storeOfNodes(STORE_I_OF_CLASS, \"StoreI\", IS_REPLACED);\n@@ -1935,1 +1987,1 @@\n-        storeOfNodes(STORE_L_OF_CLASS, \"StoreL\");\n+        storeOfNodes(STORE_L_OF_CLASS, \"StoreL\", IS_REPLACED);\n@@ -1945,1 +1997,1 @@\n-        storeOfNodes(STORE_N_OF_CLASS, \"StoreN\");\n+        storeOfNodes(STORE_N_OF_CLASS, \"StoreN\", IS_REPLACED);\n@@ -1950,1 +2002,5 @@\n-        storeOfNodes(STORE_OF_CLASS, \"Store(B|C|S|I|L|F|D|P|N)\");\n+        anyStoreOfNodes(STORE_OF_CLASS, IS_REPLACED);\n+    }\n+\n+    public static void anyStoreOfNodes(String irNodePlaceholder, String fieldHolder) {\n+        storeOfNodes(irNodePlaceholder, \"Store(B|C|S|I|L|F|D|P|N)\", fieldHolder);\n@@ -1966,1 +2022,1 @@\n-        storeOfNodes(STORE_P_OF_CLASS, \"StoreP\");\n+        storeOfNodes(STORE_P_OF_CLASS, \"StoreP\", IS_REPLACED);\n@@ -2056,1 +2112,2 @@\n-        beforeMatchingNameRegex(SUBTYPE_CHECK, \"SubTypeCheck\");\n+        String regex = START + \"SubTypeCheck\" + MID + END;\n+        macroNodes(SUBTYPE_CHECK, regex);\n@@ -2838,1 +2895,1 @@\n-    private static void beforeMatching(String irNodePlaceholder, String regex) {\n+    public static void beforeMatching(String irNodePlaceholder, String regex) {\n@@ -2874,2 +2931,2 @@\n-    private static void callOfNodes(String irNodePlaceholder, String callRegex) {\n-        String regex = START + callRegex + MID + IS_REPLACED + \" \" +  END;\n+    private static void callOfNodes(String irNodePlaceholder, String callRegex, String calleeRegex) {\n+        String regex = START + callRegex + MID + calleeRegex + END;\n@@ -2883,1 +2940,1 @@\n-    private static void optoOnly(String irNodePlaceholder, String regex) {\n+    public static void optoOnly(String irNodePlaceholder, String regex) {\n@@ -2956,2 +3013,2 @@\n-    private static void loadOfNodes(String irNodePlaceholder, String irNodeRegex) {\n-        String regex = START + irNodeRegex + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+    private static void loadOfNodes(String irNodePlaceholder, String irNodeRegex, String loadee) {\n+        String regex = START + irNodeRegex + MID + \"@(\\\\w+: ?)*[\\\\w\/]*\\\\b\" + loadee + LOAD_OF_CLASS_POSTFIX;\n@@ -2961,2 +3018,2 @@\n-    private static void storeOfNodes(String irNodePlaceholder, String irNodeRegex) {\n-        String regex = START + irNodeRegex + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+    private static void storeOfNodes(String irNodePlaceholder, String irNodeRegex, String storee) {\n+        String regex = START + irNodeRegex + MID + \"@(\\\\w+: ?)*[\\\\w\/]*\\\\b\" + storee + STORE_OF_CLASS_POSTFIX;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":97,"deletions":40,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-requiredVersion=7.5.2+1\n+requiredVersion=7.5.1+1\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -384,0 +384,1 @@\n+        vmOptFinalFlag(map, \"TieredCompilation\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -154,0 +154,14 @@\n+  private native Object[] getObjectsViaKlassOopMaps0(Object thing);\n+  public Object[] getObjectsViaKlassOopMaps(Object thing) {\n+    Objects.requireNonNull(thing);\n+    return getObjectsViaKlassOopMaps0(thing);\n+  }\n+\n+  private native Object[] getObjectsViaOopIterator0(Object thing);\n+  public Object[] getObjectsViaOopIterator(Object thing) {\n+    Objects.requireNonNull(thing);\n+    return getObjectsViaOopIterator0(thing);\n+  }\n+\n+  public native Object[] getObjectsViaFrameOopIterator(int depth);\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}