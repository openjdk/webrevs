{"files":[{"patch":"@@ -1195,2 +1195,2 @@\n-            build_number: \"1\",\n-            file: \"bundles\/jcov-3.0+1.zip\",\n+            build_number: \"3\",\n+            file: \"bundles\/jcov-3.0+3.zip\",\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+# The `-utf8` option is used even for US English, as some names\n+# may contain non-ASCII characters, such as “Türkiye”.\n@@ -65,1 +67,2 @@\n-\t    -tzdatadir $(TZ_DATA_DIR))\n+\t    -tzdatadir $(TZ_DATA_DIR) \\\n+\t    -utf8)\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3949,0 +3949,4 @@\n+\/\/ Whether this node is expanded during code emission into a sequence of\n+\/\/ instructions and the first instruction can perform an implicit null check.\n+ins_attrib ins_is_late_expanded_null_check_candidate(false);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -137,0 +137,7 @@\n+  \/\/ Whether materializing the given address for a LDR\/STR requires an\n+  \/\/ additional lea instruction.\n+  static bool legitimize_address_requires_lea(const Address &a, int size) {\n+    return a.getMode() == Address::base_plus_offset &&\n+           !Address::offset_ok_for_immed(a.offset(), exact_log2(size));\n+  }\n+\n@@ -140,7 +147,5 @@\n-    if (a.getMode() == Address::base_plus_offset) {\n-      if (! Address::offset_ok_for_immed(a.offset(), exact_log2(size))) {\n-        block_comment(\"legitimize_address {\");\n-        lea(scratch, a);\n-        block_comment(\"} legitimize_address\");\n-        return Address(scratch);\n-      }\n+    if (legitimize_address_requires_lea(a, size)) {\n+      block_comment(\"legitimize_address {\");\n+      lea(scratch, a);\n+      block_comment(\"} legitimize_address\");\n+      return Address(scratch);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2067,0 +2067,4 @@\n+\/\/ Whether this node is expanded during code emission into a sequence of\n+\/\/ instructions and the first instruction can perform an implicit null check.\n+ins_attrib ins_is_late_expanded_null_check_candidate(false);\n+\n@@ -10581,1 +10585,2 @@\n-  predicate(!UseAPX);\n+  \/\/ Strict predicate check to make selection of xorI_rReg_im1 cost agnostic if immI src is -1.\n+  predicate(!UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n@@ -10595,1 +10600,2 @@\n-  predicate(UseAPX);\n+  \/\/ Strict predicate check to make selection of xorI_rReg_im1_ndd cost agnostic if immI src2 is -1.\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n@@ -10613,0 +10619,1 @@\n+  ins_cost(150);\n@@ -11255,1 +11262,2 @@\n-  predicate(!UseAPX);\n+  \/\/ Strict predicate check to make selection of xorL_rReg_im1 cost agnostic if immL32 src is -1.\n+  predicate(!UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n@@ -11269,1 +11277,2 @@\n-  predicate(UseAPX);\n+  \/\/ Strict predicate check to make selection of xorL_rReg_im1_ndd cost agnostic if immL32 src2 is -1.\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n@@ -11288,0 +11297,1 @@\n+  ins_cost(150);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -485,4 +485,0 @@\n-\n-void *operator new( size_t size, int, const char *, int ) throw() {\n-  return ::operator new( size );\n-}\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,5 +117,17 @@\n-    char jvm_path[JVM_MAXPATHLEN];\n-    os::jvm_path(jvm_path, sizeof(jvm_path));\n-    char *end = strrchr(jvm_path, *os::file_separator());\n-    if (end != nullptr) *end = '\\0';\n-    tmp.print(\"%s%sclasses\", jvm_path, os::file_separator());\n+    if (is_vm_statically_linked()) {\n+      \/\/ It's easier to form the path using JAVA_HOME as os::jvm_path\n+      \/\/ gives the path to the launcher executable on static JDK.\n+      const char* subdir = WINDOWS_ONLY(\"bin\") NOT_WINDOWS(\"lib\");\n+      tmp.print(\"%s%s%s%s%s%sclasses\",\n+                Arguments::get_java_home(), os::file_separator(),\n+                subdir, os::file_separator(),\n+                Abstract_VM_Version::vm_variant(), os::file_separator());\n+    } else {\n+      \/\/ Assume .jsa is in the same directory where libjvm resides on\n+      \/\/ non-static JDK.\n+      char jvm_path[JVM_MAXPATHLEN];\n+      os::jvm_path(jvm_path, sizeof(jvm_path));\n+      char *end = strrchr(jvm_path, *os::file_separator());\n+      if (end != nullptr) *end = '\\0';\n+      tmp.print(\"%s%sclasses\", jvm_path, os::file_separator());\n+    }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -295,2 +295,0 @@\n-  case vmIntrinsics::_dtanh:\n-  case vmIntrinsics::_dcbrt:\n@@ -322,0 +320,7 @@\n+  case vmIntrinsics::_dtanh:\n+  case vmIntrinsics::_dcbrt:\n+    if (!InlineMathNatives || !InlineIntrinsics) return true;\n+#if defined(AMD64) && (defined(COMPILER1) || defined(COMPILER2))\n+    if (!UseLibmIntrinsic) return true;\n+#endif\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  return Universe::boolArrayKlass()->allocate(length, THREAD);\n+  return Universe::boolArrayKlass()->allocate_instance(length, THREAD);\n@@ -52,1 +52,1 @@\n-  return Universe::charArrayKlass()->allocate(length, THREAD);\n+  return Universe::charArrayKlass()->allocate_instance(length, THREAD);\n@@ -56,1 +56,1 @@\n-  return Universe::floatArrayKlass()->allocate(length, THREAD);\n+  return Universe::floatArrayKlass()->allocate_instance(length, THREAD);\n@@ -60,1 +60,1 @@\n-  return Universe::doubleArrayKlass()->allocate(length, THREAD);\n+  return Universe::doubleArrayKlass()->allocate_instance(length, THREAD);\n@@ -64,1 +64,1 @@\n-  return Universe::byteArrayKlass()->allocate(length, THREAD);\n+  return Universe::byteArrayKlass()->allocate_instance(length, THREAD);\n@@ -68,1 +68,1 @@\n-  return Universe::shortArrayKlass()->allocate(length, THREAD);\n+  return Universe::shortArrayKlass()->allocate_instance(length, THREAD);\n@@ -72,1 +72,1 @@\n-  return Universe::intArrayKlass()->allocate(length, THREAD);\n+  return Universe::intArrayKlass()->allocate_instance(length, THREAD);\n@@ -76,1 +76,1 @@\n-  return Universe::longArrayKlass()->allocate(length, THREAD);\n+  return Universe::longArrayKlass()->allocate_instance(length, THREAD);\n@@ -96,1 +96,1 @@\n-  return klass->allocate(length, THREAD);\n+  return klass->allocate_instance(length, THREAD);\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  friend class VMStructs;\n+  friend class Deoptimization;\n@@ -38,0 +38,2 @@\n+  friend class oopFactory;\n+  friend class VMStructs;\n@@ -54,0 +56,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  TypeArrayKlass* ak = TypeArrayKlass::allocate(null_loader_data, type, sym, CHECK_NULL);\n+  TypeArrayKlass* ak = TypeArrayKlass::allocate_klass(null_loader_data, type, sym, CHECK_NULL);\n@@ -69,1 +69,1 @@\n-TypeArrayKlass* TypeArrayKlass::allocate(ClassLoaderData* loader_data, BasicType type, Symbol* name, TRAPS) {\n+TypeArrayKlass* TypeArrayKlass::allocate_klass(ClassLoaderData* loader_data, BasicType type, Symbol* name, TRAPS) {\n@@ -107,1 +107,1 @@\n-  return allocate(length, THREAD);\n+  return allocate_instance(length, THREAD);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,0 +79,30 @@\n+void PhaseCFG::move_node_and_its_projections_to_block(Node* n, Block* b) {\n+  assert(!is_CFG(n), \"cannot move CFG node\");\n+  Block* old = get_block_for_node(n);\n+  old->find_remove(n);\n+  b->add_inst(n);\n+  map_node_to_block(n, b);\n+  \/\/ Check for Mach projections that also need to be moved.\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* out = n->fast_out(i);\n+    if (!out->is_MachProj()) {\n+      continue;\n+    }\n+    assert(!n->is_MachProj(), \"nested projections are not allowed\");\n+    move_node_and_its_projections_to_block(out, b);\n+  }\n+}\n+\n+void PhaseCFG::ensure_node_is_at_block_or_above(Node* n, Block* b) {\n+  assert(!is_CFG(n), \"cannot move CFG node\");\n+  Block* current = get_block_for_node(n);\n+  if (current->dominates(b)) {\n+    return; \/\/ n is already placed above b, do nothing.\n+  }\n+  \/\/ We only expect nodes without further inputs, like MachTemp or load Base.\n+  assert(n->req() == 0 || (n->req() == 1 && n->in(0) == (Node*)C->root()),\n+         \"need for recursive hoisting not expected\");\n+  assert(b->dominates(current), \"precondition: can only move n to b if b dominates n\");\n+  move_node_and_its_projections_to_block(n, b);\n+}\n+\n@@ -163,1 +193,2 @@\n-    if (mach->barrier_data() != 0) {\n+    if (mach->barrier_data() != 0 &&\n+        !mach->is_late_expanded_null_check_candidate()) {\n@@ -165,4 +196,5 @@\n-      \/\/ not supported. These operations might expand into multiple assembly\n-      \/\/ instructions during code emission, including new memory accesses (e.g.\n-      \/\/ in G1's pre-barrier), which would invalidate the implicit null\n-      \/\/ exception table.\n+      \/\/ only supported if these are explicit marked as emitting a candidate\n+      \/\/ memory access instruction at their initial address. If not marked as\n+      \/\/ such, barrier-tagged operations might expand into one or several memory\n+      \/\/ access instructions located at arbitrary offsets from the initial\n+      \/\/ address, which would invalidate the implicit null exception table.\n@@ -325,0 +357,8 @@\n+      if (mach->in(j)->is_MachTemp()) {\n+        assert(mach->in(j)->outcnt() == 1, \"MachTemp nodes should not be shared\");\n+        \/\/ Ignore MachTemp inputs, they can be safely hoisted with the candidate.\n+        \/\/ MachTemp nodes have no inputs themselves and are only used to reserve\n+        \/\/ a scratch register for the implementation of the node (e.g. in\n+        \/\/ late-expanded GC barriers).\n+        continue;\n+      }\n@@ -396,24 +436,2 @@\n-        Node *temp = val->in(i);\n-        Block *tempb = get_block_for_node(temp);\n-        if (!tempb->dominates(block)) {\n-          assert(block->dominates(tempb), \"sanity check: temp node placement\");\n-          \/\/ We only expect nodes without further inputs, like MachTemp or load Base.\n-          assert(temp->req() == 0 || (temp->req() == 1 && temp->in(0) == (Node*)C->root()),\n-                 \"need for recursive hoisting not expected\");\n-          tempb->find_remove(temp);\n-          block->add_inst(temp);\n-          map_node_to_block(temp, block);\n-        }\n-      }\n-      valb->find_remove(val);\n-      block->add_inst(val);\n-      map_node_to_block(val, block);\n-      \/\/ DecodeN on x86 may kill flags. Check for flag-killing projections\n-      \/\/ that also need to be hoisted.\n-      for (DUIterator_Fast jmax, j = val->fast_outs(jmax); j < jmax; j++) {\n-        Node* n = val->fast_out(j);\n-        if( n->is_MachProj() ) {\n-          get_block_for_node(n)->find_remove(n);\n-          block->add_inst(n);\n-          map_node_to_block(n, block);\n-        }\n+        \/\/ Inputs of val may already be early enough, but if not move them together with val.\n+        ensure_node_is_at_block_or_above(val->in(i), block);\n@@ -421,0 +439,1 @@\n+      move_node_and_its_projections_to_block(val, block);\n@@ -444,0 +463,10 @@\n+\n+  \/\/ Move any MachTemp inputs to the end of the test block.\n+  for (uint i = 0; i < best->req(); i++) {\n+    Node* n = best->in(i);\n+    if (n == nullptr || !n->is_MachTemp()) {\n+      continue;\n+    }\n+    ensure_node_is_at_block_or_above(n, block);\n+  }\n+\n@@ -445,4 +474,1 @@\n-  Block *old_block = get_block_for_node(best);\n-  old_block->find_remove(best);\n-  block->add_inst(best);\n-  map_node_to_block(best, block);\n+  move_node_and_its_projections_to_block(best, block);\n@@ -458,11 +484,0 @@\n-  \/\/ Check for flag-killing projections that also need to be hoisted\n-  \/\/ Should be DU safe because no edge updates.\n-  for (DUIterator_Fast jmax, j = best->fast_outs(jmax); j < jmax; j++) {\n-    Node* n = best->fast_out(j);\n-    if( n->is_MachProj() ) {\n-      get_block_for_node(n)->find_remove(n);\n-      block->add_inst(n);\n-      map_node_to_block(n, block);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":59,"deletions":44,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -1287,2 +1287,2 @@\n-  Node* loop_iv_stride(Node* incr, IdealLoopTree* loop, Node*& xphi);\n-  PhiNode* loop_iv_phi(Node* xphi, Node* phi_incr, Node* x, IdealLoopTree* loop);\n+  Node* loop_iv_stride(Node* incr, Node*& xphi);\n+  PhiNode* loop_iv_phi(Node* xphi, Node* phi_incr, Node* x);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1851,0 +1851,4 @@\n+  bool is_raw_to_oop_cast = n->is_ConstraintCast() &&\n+                            n->in(1)->bottom_type()->isa_rawptr() &&\n+                            !n->bottom_type()->isa_rawptr();\n+\n@@ -1860,1 +1864,3 @@\n-      !n->is_Type()) {\n+      !is_raw_to_oop_cast && \/\/ don't extend live ranges of raw oops\n+      (KillPathsReachableByDeadTypeNode || !n->is_Type())\n+      ) {\n@@ -4454,1 +4460,1 @@\n-      Node* stride = loop_iv_stride(in, loop, xphi);\n+      Node* stride = loop_iv_stride(in, xphi);\n@@ -4460,1 +4466,1 @@\n-      PhiNode* phi = loop_iv_phi(xphi, nullptr, head, loop);\n+      PhiNode* phi = loop_iv_phi(xphi, nullptr, head);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -390,0 +390,7 @@\n+\n+  \/\/ Whether this node is expanded during code emission into a sequence of\n+  \/\/ instructions and the first instruction can perform an implicit null check.\n+  virtual bool is_late_expanded_null_check_candidate() const {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2112,2 +2112,4 @@\n-      assert(n->in(1)->as_Mach()->barrier_data() == 0,\n-             \"Implicit null checks on memory accesses with barriers are not yet supported\");\n+      MachNode* access = n->in(1)->as_Mach();\n+      assert(access->barrier_data() == 0 ||\n+             access->is_late_expanded_null_check_candidate(),\n+             \"Implicit null checks on memory accesses with barriers are only supported on nodes explicitly marked as null-check candidates\");\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -591,22 +591,0 @@\n-#endif \/\/ INCLUDE_G1GC\n-\n-#if INCLUDE_PARALLELGC\n-\n-WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))\n-  if (UseParallelGC) {\n-    return GenAlignment;\n-  }\n-  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_PSVirtualSpaceAlignment: Parallel GC is not enabled\");\n-WB_END\n-\n-WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))\n-  if (UseParallelGC) {\n-    return GenAlignment;\n-  }\n-  THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), \"WB_PSHeapGenerationAlignment: Parallel GC is not enabled\");\n-WB_END\n-\n-#endif \/\/ INCLUDE_PARALLELGC\n-\n-#if INCLUDE_G1GC\n-\n@@ -1105,0 +1083,16 @@\n+bool WhiteBox::is_asan_enabled() {\n+#ifdef ADDRESS_SANITIZER\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n+bool WhiteBox::is_ubsan_enabled() {\n+#ifdef UNDEFINED_BEHAVIOR_SANITIZER\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n@@ -1916,0 +1910,8 @@\n+WB_ENTRY(jboolean, WB_IsAsanEnabled(JNIEnv* env))\n+  return (jboolean) WhiteBox::is_asan_enabled();\n+WB_END\n+\n+WB_ENTRY(jboolean, WB_IsUbsanEnabled(JNIEnv* env))\n+  return (jboolean) WhiteBox::is_ubsan_enabled();\n+WB_END\n+\n@@ -2884,4 +2886,0 @@\n-#if INCLUDE_PARALLELGC\n-  {CC\"psVirtualSpaceAlignment\",CC\"()J\",               (void*)&WB_PSVirtualSpaceAlignment},\n-  {CC\"psHeapGenerationAlignment\",CC\"()J\",             (void*)&WB_PSHeapGenerationAlignment},\n-#endif\n@@ -3019,0 +3017,2 @@\n+  {CC\"isAsanEnabled\", CC\"()Z\",                        (void*)&WB_IsAsanEnabled },\n+  {CC\"isUbsanEnabled\", CC\"()Z\",                       (void*)&WB_IsUbsanEnabled },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -544,4 +544,0 @@\n-#ifdef LINUX\n-  { \"UseLinuxPosixThreadCPUClocks\", JDK_Version::jdk(24), JDK_Version::jdk(25), JDK_Version::jdk(26) },\n-  { \"UseOprofile\",                  JDK_Version::jdk(25), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n-#endif\n@@ -557,1 +553,3 @@\n-  { \"PerfDataSamplingInterval\",     JDK_Version::undefined(), JDK_Version::jdk(25), JDK_Version::jdk(26) },\n+#ifdef LINUX\n+  { \"UseOprofile\",                  JDK_Version::jdk(25), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1337,1 +1337,1 @@\n-      obj = ak->allocate(len, THREAD);\n+      obj = ak->allocate_instance(len, THREAD);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -502,0 +502,1 @@\n+  _suspend_resume_manager(this, &_handshake._lock),\n@@ -1204,1 +1205,1 @@\n-  return this->handshake_state()->suspend(register_vthread_SR);\n+  return this->suspend_resume_manager()->suspend(register_vthread_SR);\n@@ -1210,1 +1211,1 @@\n-  return this->handshake_state()->resume(register_vthread_SR);\n+  return this->suspend_resume_manager()->resume(register_vthread_SR);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/suspendResumeManager.hpp\"\n@@ -698,0 +699,3 @@\n+private:\n+  SuspendResumeManager _suspend_resume_manager;\n+public:\n@@ -700,1 +704,2 @@\n-  bool is_suspended()     { return _handshake.is_suspended(); }\n+  bool is_suspended()     { return _suspend_resume_manager.is_suspended(); }\n+  SuspendResumeManager* suspend_resume_manager() { return &_suspend_resume_manager; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -331,0 +331,8 @@\n+\n+\/\/ Conversion\n+static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror) {\n+  assert(java_lang_Class::is_primitive(basic_type_mirror),\n+    \"just checking\");\n+  return java_lang_Class::primitive_type(basic_type_mirror);\n+}\n+\n@@ -332,2 +340,1 @@\n-  assert(java_lang_Class::is_primitive(basic_type_mirror), \"just checking\");\n-  BasicType type = java_lang_Class::primitive_type(basic_type_mirror);\n+  BasicType type = basic_type_mirror_to_basic_type(basic_type_mirror);\n@@ -350,2 +357,5 @@\n-    Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);\n-    return TypeArrayKlass::cast(tak)->allocate(length, THREAD);\n+    BasicType type = basic_type_mirror_to_basic_type(element_mirror);\n+    if (type == T_VOID) {\n+      THROW_NULL(vmSymbols::java_lang_IllegalArgumentException());\n+    }\n+    return oopFactory::new_typeArray(type, length, CHECK_NULL);\n@@ -922,7 +932,0 @@\n-\/\/ Conversion\n-static BasicType basic_type_mirror_to_basic_type(oop basic_type_mirror) {\n-  assert(java_lang_Class::is_primitive(basic_type_mirror),\n-    \"just checking\");\n-  return java_lang_Class::primitive_type(basic_type_mirror);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3734,1 +3734,1 @@\n-                int ascii = JLA.uncheckedCountPositives(buf, pos, Math.min(avail, (int)utflen));\n+                int ascii = JLA.countPositives(buf, pos, Math.min(avail, (int)utflen));\n@@ -3747,1 +3747,1 @@\n-                    JLA.uncheckedInflateBytesToChars(buf, pos, cbuf, 0, ascii);\n+                    JLA.inflateBytesToChars(buf, pos, cbuf, 0, ascii);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2137,1 +2137,1 @@\n-            public int uncheckedCountPositives(byte[] bytes, int offset, int length) {\n+            public int countPositives(byte[] bytes, int offset, int length) {\n@@ -2164,1 +2164,1 @@\n-            public void uncheckedInflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n+            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n@@ -2168,1 +2168,1 @@\n-            public int uncheckedDecodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n+            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -306,2 +306,2 @@\n-     * <p>\n-     * <b>WARNING: This method does not perform any bound checks.<\/b>\n+     *\n+     * @implSpec Implementations of this method must perform bounds checks.\n@@ -309,1 +309,1 @@\n-    int uncheckedCountPositives(byte[] ba, int off, int len);\n+    int countPositives(byte[] ba, int off, int len);\n@@ -394,2 +394,2 @@\n-     * <p>\n-     * <b>WARNING: This method does not perform any bound checks.<\/b>\n+     *\n+     * @implSpec Implementations of this method must perform bounds checks.\n@@ -397,1 +397,1 @@\n-    void uncheckedInflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len);\n+    void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len);\n@@ -402,2 +402,2 @@\n-     * <p>\n-     * <b>WARNING: This method does not perform any bound checks.<\/b>\n+     *\n+     * @implSpec Implementations of this method must perform bounds checks.\n@@ -407,1 +407,1 @@\n-    int uncheckedDecodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len);\n+    int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -406,2 +406,1 @@\n-    uses sun.util.resources.LocaleData.CommonResourceBundleProvider;\n-    uses sun.util.resources.LocaleData.SupplementaryResourceBundleProvider;\n+    uses sun.util.resources.LocaleData.LocaleDataResourceBundleProvider;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3729,1 +3729,1 @@\n-            body.endpos = TreeInfo.endPos(tree.body);\n+            body.bracePos = TreeInfo.endPos(tree.body);\n@@ -4190,1 +4190,1 @@\n-                res.endpos = TreeInfo.endPos(tree);\n+                res.bracePos = TreeInfo.endPos(tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -519,1 +519,1 @@\n-            block.endpos = TreeInfo.endPos(clinitStats.last());\n+            block.bracePos = TreeInfo.endPos(clinitStats.last());\n@@ -578,2 +578,2 @@\n-            if (md.body.endpos == Position.NOPOS)\n-                md.body.endpos = TreeInfo.endPos(md.body.stats.last());\n+            if (md.body.bracePos == Position.NOPOS)\n+                md.body.bracePos = TreeInfo.endPos(md.body.stats.last());\n@@ -1188,1 +1188,1 @@\n-            code.statBegin(tree.endpos);\n+            code.statBegin(tree.bracePos);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -242,2 +242,2 @@\n-                ? new SimpleEndPosTable(this)\n-                : new EmptyEndPosTable(this);\n+                ? new SimpleEndPosTable()\n+                : new MinimalEndPosTable();\n@@ -648,0 +648,1 @@\n+     *  @return {@code tree}\n@@ -649,1 +650,1 @@\n-    protected void attach(JCTree tree, Comment dc) {\n+    protected <T extends JCTree> T attach(T tree, Comment dc) {\n@@ -654,0 +655,1 @@\n+        return tree;\n@@ -717,2 +719,9 @@\n-    protected void storeEnd(JCTree tree, int endpos) {\n-        endPosTable.storeEnd(tree, endpos);\n+    \/**\n+     * Store ending position for a tree, the value of which is the greater of\n+     * last error position in {@link #endPosTable} and the given ending position.\n+     * @param tree tree node\n+     * @param endpos the ending position to associate with {@code tree}\n+     * @return {@code tree}\n+     *\/\n+    protected <T extends JCTree> T storeEnd(T tree, int endpos) {\n+        return endPosTable.storeEnd(tree, endpos);\n@@ -721,2 +730,8 @@\n-    protected <T extends JCTree> T to(T t) {\n-        return endPosTable.to(t);\n+    \/**\n+     * Store current token's ending position for a tree, the value of which\n+     * will be the greater of last error position in {@link #endPosTable}\n+     * and the ending position of the current token.\n+     * @param tree tree node\n+     *\/\n+    protected <T extends JCTree> T to(T tree) {\n+        return storeEnd(tree, token.endPos);\n@@ -725,2 +740,8 @@\n-    protected <T extends JCTree> T toP(T t) {\n-        return endPosTable.toP(t);\n+    \/**\n+     * Store current token's ending position for a tree, the value of which\n+     * will be the greater of last error position in {@link #endPosTable}\n+     * and the ending position of the previous token.\n+     * @param tree tree node\n+     *\/\n+    protected <T extends JCTree> T toP(T tree) {\n+        return storeEnd(tree, S.prevToken().endPos);\n@@ -1756,1 +1777,1 @@\n-                    e.endpos = token.pos;\n+                    e.bracePos = token.pos;\n@@ -2834,1 +2855,1 @@\n-        \/\/ the Block node has a field \"endpos\" for first char of last token, which is\n+        \/\/ the Block node has a field \"bracePos\" for first char of last token, which is\n@@ -2836,1 +2857,1 @@\n-        t.endpos = token.pos;\n+        t.bracePos = token.pos;\n@@ -3162,1 +3183,1 @@\n-            t.endpos = token.endPos;\n+            t.bracePos = token.endPos;\n@@ -3683,3 +3704,1 @@\n-\n-        storeEnd(ann, S.prevToken().endPos);\n-        return ann;\n+        return toP(ann);\n@@ -3860,2 +3879,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4163,1 +4181,1 @@\n-        List<JCTree> topLevelDefs = isImplicitClass ?  constructImplicitClass(defs.toList()) : defs.toList();\n+        List<JCTree> topLevelDefs = isImplicitClass ? constructImplicitClass(defs.toList(), S.prevToken().endPos) : defs.toList();\n@@ -4173,1 +4191,0 @@\n-        this.endPosTable.setParser(null); \/\/ remove reference to parser\n@@ -4179,1 +4196,1 @@\n-    private List<JCTree> constructImplicitClass(List<JCTree> origDefs) {\n+    private List<JCTree> constructImplicitClass(List<JCTree> origDefs, int endPos) {\n@@ -4209,0 +4226,1 @@\n+        storeEnd(implicit, endPos);\n@@ -4224,0 +4242,1 @@\n+        int endPos = S.prevToken().endPos;\n@@ -4226,3 +4245,3 @@\n-        JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));\n-        attach(result, dc);\n-        return result;\n+        JCModuleDecl result = F.at(pos).ModuleDef(mods, kind, name, directives);\n+        storeEnd(result, endPos);\n+        return attach(result, dc);\n@@ -4418,2 +4437,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4466,2 +4484,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4506,2 +4523,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4554,2 +4570,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -4696,2 +4711,1 @@\n-        attach(result, dc);\n-        return result;\n+        return attach(result, dc);\n@@ -5157,2 +5171,1 @@\n-            attach(result, dc);\n-            return result;\n+            return attach(result, dc);\n@@ -5455,2 +5468,1 @@\n-            storeEnd(type, origEndPos);\n-            return type;\n+            return storeEnd(type, origEndPos);\n@@ -5682,2 +5694,2 @@\n-    \/*\n-     * a functional source tree and end position mappings\n+    \/**\n+     * A straightforward {@link EndPosTable} implementation.\n@@ -5687,10 +5699,1 @@\n-        private final IntHashTable endPosMap;\n-\n-        SimpleEndPosTable(JavacParser parser) {\n-            super(parser);\n-            endPosMap = new IntHashTable();\n-        }\n-\n-        public void storeEnd(JCTree tree, int endpos) {\n-            endPosMap.put(tree, errorEndPos > endpos ? errorEndPos : endpos);\n-        }\n+        private final IntHashTable endPosMap = new IntHashTable();\n@@ -5698,8 +5701,4 @@\n-        protected <T extends JCTree> T to(T t) {\n-            storeEnd(t, parser.token.endPos);\n-            return t;\n-        }\n-\n-        protected <T extends JCTree> T toP(T t) {\n-            storeEnd(t, parser.S.prevToken().endPos);\n-            return t;\n+        @Override\n+        public <T extends JCTree> T storeEnd(T tree, int endpos) {\n+            endPosMap.put(tree, Math.max(endpos, errorEndPos));\n+            return tree;\n@@ -5708,0 +5707,1 @@\n+        @Override\n@@ -5714,0 +5714,1 @@\n+        @Override\n@@ -5716,1 +5717,1 @@\n-            if (pos != -1) {\n+            if (pos != -1 && newTree != null) {\n@@ -5718,2 +5719,1 @@\n-                return pos;\n-            return Position.NOPOS;\n+            return pos;\n@@ -5724,2 +5724,2 @@\n-    \/*\n-     * a default skeletal implementation without any mapping overhead.\n+    \/**\n+     * A minimal implementation that only stores what's required.\n@@ -5727,19 +5727,1 @@\n-    protected static class EmptyEndPosTable extends AbstractEndPosTable {\n-\n-        EmptyEndPosTable(JavacParser parser) {\n-            super(parser);\n-        }\n-\n-        public void storeEnd(JCTree tree, int endpos) { \/* empty *\/ }\n-\n-        protected <T extends JCTree> T to(T t) {\n-            return t;\n-        }\n-\n-        protected <T extends JCTree> T toP(T t) {\n-            return t;\n-        }\n-\n-        public int getEndPos(JCTree tree) {\n-            return Position.NOPOS;\n-        }\n+    protected static class MinimalEndPosTable extends SimpleEndPosTable {\n@@ -5747,2 +5729,13 @@\n-        public int replaceTree(JCTree oldTree, JCTree newTree) {\n-            return Position.NOPOS;\n+        @Override\n+        public <T extends JCTree> T storeEnd(T tree, int endpos) {\n+            switch (tree.getTag()) {\n+            case MODULEDEF:\n+            case PACKAGEDEF:\n+            case CLASSDEF:\n+            case METHODDEF:\n+            case VARDEF:\n+                break;\n+            default:\n+                return tree;\n+            }\n+            return super.storeEnd(tree, endpos);\n@@ -5750,1 +5743,0 @@\n-\n@@ -5754,4 +5746,0 @@\n-        \/**\n-         * The current parser.\n-         *\/\n-        protected JavacParser parser;\n@@ -5764,25 +5752,1 @@\n-        public AbstractEndPosTable(JavacParser parser) {\n-            this.parser = parser;\n-        }\n-\n-        \/**\n-         * Store current token's ending position for a tree, the value of which\n-         * will be the greater of last error position and the ending position of\n-         * the current token.\n-         * @param t The tree.\n-         *\/\n-        protected abstract <T extends JCTree> T to(T t);\n-\n-        \/**\n-         * Store current token's ending position for a tree, the value of which\n-         * will be the greater of last error position and the ending position of\n-         * the previous token.\n-         * @param t The tree.\n-         *\/\n-        protected abstract <T extends JCTree> T toP(T t);\n-\n-        \/**\n-         * Set the error position during the parsing phases, the value of which\n-         * will be set only if it is greater than the last stored error position.\n-         * @param errPos The error position\n-         *\/\n+        @Override\n@@ -5794,4 +5758,0 @@\n-\n-        public void setParser(JavacParser parser) {\n-            this.parser = parser;\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":78,"deletions":118,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,2 +503,2 @@\n-    \/** The end position of given tree, if it is a block with\n-     *  defined endpos.\n+    \/** The closing brace position of given tree, if it is a block with\n+     *  defined bracePos.\n@@ -507,2 +507,2 @@\n-        if (tree.hasTag(BLOCK) && ((JCBlock) tree).endpos != Position.NOPOS)\n-            return ((JCBlock) tree).endpos;\n+        if (tree.hasTag(BLOCK) && ((JCBlock) tree).bracePos != Position.NOPOS)\n+            return ((JCBlock) tree).bracePos;\n@@ -516,2 +516,2 @@\n-                   ((JCSwitch) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitch) tree).endpos;\n+                   ((JCSwitch) tree).bracePos != Position.NOPOS) {\n+            return ((JCSwitch) tree).bracePos;\n@@ -519,2 +519,2 @@\n-                   ((JCSwitchExpression) tree).endpos != Position.NOPOS) {\n-            return ((JCSwitchExpression) tree).endpos;\n+                   ((JCSwitchExpression) tree).bracePos != Position.NOPOS) {\n+            return ((JCSwitchExpression) tree).bracePos;\n@@ -649,5 +649,0 @@\n-        if (endPosTable == null) {\n-            \/\/ fall back on limited info in the tree\n-            return endPos(tree);\n-        }\n-\n@@ -734,2 +729,2 @@\n-     *  end position of given tree, if it is a block with\n-     *  defined endpos.\n+     *  closing brace position of given tree, if it is a block with\n+     *  defined closing brace position.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+compiler\/gcbarriers\/TestImplicitNullChecks.java 8367338 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+    vm.asan \\\n+    vm.ubsan \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1554,0 +1554,5 @@\n+    public static final String NULL_CHECK = PREFIX + \"NULL_CHECK\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(NULL_CHECK, \"NullCheck\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+    vm.asan \\\n+    vm.ubsan \\\n","filename":"test\/jdk\/TEST.ROOT","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+        map.put(\"vm.asan\", this::isAsanEnabled);\n+        map.put(\"vm.ubsan\", this::isUbsanEnabled);\n@@ -732,0 +734,9 @@\n+    \/\/ Sanitizer support\n+    protected String isAsanEnabled() {\n+        return \"\" + WB.isAsanEnabled();\n+    }\n+\n+    protected String isUbsanEnabled() {\n+        return \"\" + WB.isUbsanEnabled();\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -314,4 +314,0 @@\n-  \/\/ Parallel GC\n-  public native long psVirtualSpaceAlignment();\n-  public native long psHeapGenerationAlignment();\n-\n@@ -343,0 +339,4 @@\n+  \/\/ Sanitizers\n+  public native boolean isAsanEnabled();\n+  public native boolean isUbsanEnabled();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}