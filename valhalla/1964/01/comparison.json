{"files":[{"patch":"@@ -7,1 +7,2 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists,copyright\n+#error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists,copyright\n+error=author,committer,executable,symlink,message,hg-tag,whitespace,problemlists,copyright\n@@ -30,1 +31,1 @@\n-pattern=^([124-8][0-9]{6}): \\[lworld\\] (\\S.*)$\n+pattern=^([124-8][0-9]{6}): \\[lw5\\] (\\S.*)$\n","filename":".jcheck\/conf","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import java.lang.reflect.RuntimeType;\n@@ -230,1 +231,2 @@\n-                              Constable {\n+                              Constable,\n+                              RuntimeType<T> {\n@@ -678,0 +680,12 @@\n+    \/**\n+     * Returns a {@code Class} object representing the null restricted type\n+     * of this class or interface.\n+     *\n+     * @return the {@code Class} representing the null restricted type of\n+     *         this class or interface\n+     * @since Valhalla\n+     *\/\n+    public Class<?> asNullRestrictedType() {\n+        return this;\n+    }\n+\n@@ -3566,1 +3580,1 @@\n-        if (obj != null && !isInstance(obj))\n+        if (!canCast(obj))\n@@ -3575,0 +3589,14 @@\n+    \/**\n+     * Tests whether a cast to this class or interface will succeed.\n+     *\/\n+    public boolean canCast(Object obj) {\n+        return obj == null || isInstance(obj);\n+    }\n+\n+    \/**\n+     * Returns this {@code Class}.\n+     *\/\n+    public Class<T> baseClass() {\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/**\n+ * A restricted interface optionally implemented by value objects.\n+ *\n+ * A value object is an instance of a value class, lacking identity.\n+ *\n+ * Every object is either an *identity object* or a *value object*. Identity\n+ * objects have a unique identity determined for them at instance creation time and\n+ * preserved throughout their life.\n+ *\n+ * value objects do *not* have an identity. Instead, they simply aggregate a\n+ * set of immutable field values. The lack of identity enables certain performance\n+ * optimizations by Java Virtual Machine implementations.\n+ * The following operations have special behavior when applied to value\n+ * objects:\n+ *\n+ * - The `==` operator, and the default implementation of the `Object.equals`\n+ * method, compare the values of the operands' fields. Value objects\n+ * created at different points in a program may be `==`.\n+ *\n+ * - The `System.identityHashCode` method, and the default implementation of the\n+ * `Object.hashCode` method, generate a hash code from the hash codes of a\n+ * value object's fields.\n+ *\n+ * - The `synchronized` modifier and `synchronized` statement always fail when\n+ * applied to a value object.\n+ *\n+ * A value class with an `implicit` constructor may also declare that it tolerates\n+ * implicit creation of instances via non-atomic field and array updates.\n+ * This means that, in a race condition, new class instances may be accidentally\n+ * created by intermixing field values from other instances, without any code\n+ * execution or other additional cooperation from the value class. A value class\n+ * opts in to allowing this behavior by implementing this interface.\n+ *\n+ * @since Valhalla\n+ *\/\n+\n+public interface LooselyConsistentValue {\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/LooselyConsistentValue.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.reflect.RuntimeType;\n@@ -119,0 +120,13 @@\n+    \/**\n+     * Returns a {@link RuntimeType} for the null-restricted type of {@code cls}.\n+     *\n+     * @param lookup unused\n+     * @param name unused\n+     * @param type the required result type (must be {@code RuntimeType.class})\n+     * @param cls the class, interface, or array type to be null-restricted\n+     * @return the null-restricted {@code RuntimeType}\n+     *\/\n+    public static RuntimeType<?> nullRestrictedClass(MethodHandles.Lookup lookup, String name, Class<?> type, Class<?> cls) {\n+        return RuntimeType.nullRestricted(cls);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -478,0 +478,10 @@\n+    \/**\n+     * Get the {@code RuntimeType} enforced on components of an array.\n+     *\n+     * @param array the array\n+     * @return the {@code RuntimeType} of the components of {@code array}\n+     *\/\n+    public static RuntimeType<?> componentType(Object array) {\n+        return array.getClass().getComponentType();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Array.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -294,0 +294,15 @@\n+    \/**\n+     * Get a {@code RuntimeType} representing the type that is\n+     * dynamically enforced by this field. If the field does\n+     * not perform dynamic checks, this is the type that is\n+     * enforced by bytecode verification (the same as\n+     * {@link #getType} in most cases, but {@code Object} in\n+     * the case of an interface type).\n+     *\n+     * @return a {@code RuntimeType} representing the type that\n+     *         is dynamically enforced by this field\n+     *\/\n+    public RuntimeType<?> getRuntimeType() {\n+        return !type.isInterface() ? type : Object.class;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect;\n+\n+import java.lang.constant.*;\n+import java.util.Optional;\n+import java.util.Objects;\n+\n+\/**\n+ * A {@code NullRestrictedClass} represents the null-restricted type of a class,\n+ * interface, or array type.\n+ *\/\n+final class NullRestrictedClass<T> implements RuntimeType<T> {\n+\n+    private final Class<T> c;\n+\n+    \/**\n+     * Assumes {@code c} is a class, interface, or array type, not a primitive.\n+     *\/\n+    NullRestrictedClass(Class<T> c) {\n+        this.c = c;\n+    }\n+\n+    \/**\n+     * Ensure an object is non-null and an instance of the class.\n+     * @throws NullPointerException if {@code arg} is {@code null}\n+     * @throws ClassCastException if {@code arg} is an instance of an incompatible class\n+     *\/\n+    public T cast(Object arg) {\n+        if (arg == null) throw new NullPointerException();\n+        return c.cast(arg);\n+    }\n+\n+    \/**\n+     * Tests whether {@code arg} is a non-null instance of the class.\n+     *\/\n+    public boolean canCast(Object arg) {\n+        return c.isInstance(arg);\n+    }\n+\n+    public Class<T> baseClass() {\n+        return c;\n+    }\n+\n+    public String toString() {\n+        \/\/ note that array types use descriptors\n+        return c.getName() + \"!\";\n+    }\n+\n+    public boolean equals(Object o) {\n+        return o instanceof NullRestrictedClass<?> that &&\n+               this.c.equals(that.c);\n+    }\n+\n+    public int hashCode() {\n+        return Objects.hash(NullRestrictedClass.class, c);\n+    }\n+\n+    public Optional<DynamicConstantDesc<NullRestrictedClass<T>>> describeConstable() {\n+        return c.describeConstable().map(classDesc ->\n+            DynamicConstantDesc.of(BSM_NULL_RESTRICTED_CLASS, classDesc));\n+    }\n+\n+    private static final DirectMethodHandleDesc BSM_NULL_RESTRICTED_CLASS =\n+        ConstantDescs.ofConstantBootstrap(\n+            ConstantDescs.CD_ConstantBootstraps,\n+            \"nullRestrictedClass\",\n+            RuntimeType.class.describeConstable().get(),\n+            ConstantDescs.CD_Class);\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/NullRestrictedClass.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect;\n+\n+import java.lang.constant.Constable;\n+\n+\/**\n+ * A {@code RuntimeType} represents a stable property of an object reference\n+ * that can be dynamically checked at run time. These checks may be applied\n+ * to a {@link Field} or an {@link Array} component.\n+ *\n+ * A {@code RuntimeType} might be a class, interface, or array type,\n+ * represented with a {@link java.lang.Class} object. It might also be a\n+ * null-restricted class, interface, or array type, which excludes the\n+ * {@code null} reference. Other kinds of {@code RuntimeType}s may be\n+ * supported in a future release.\n+ *\n+ * @param <T> the compile-time type enforced by this {@code RuntimeType}\n+ *\/\n+public sealed interface RuntimeType<T> extends Constable\n+                                       permits Class, NullRestrictedClass {\n+\n+    \/**\n+     * Ensure an object has this type. If not, throw a {@link RuntimeException}.\n+     *\n+     * @param ref the object reference to check\n+     * @return the reference after casting\n+     *\/\n+    T cast(Object ref);\n+\n+    \/**\n+     * Tests whether a cast to this type will succeed.\n+     *\n+     * @param ref the object reference to check\n+     * @return {@code true} iff the {@link #cast} operation will succeed\n+     *\/\n+    boolean canCast(Object ref);\n+\n+    \/**\n+     * The most-specific {@code Class} that includes all values of this\n+     * {@code RuntimeType}.\n+     *\n+     * @return a {@code Class}\n+     *\/\n+    Class<?> baseClass();\n+\n+    \/**\n+     * Create a null-restricted class, interface, or array type.\n+     *\n+     * @param <T> the compile-time type of the {@code Class} object\n+     * @param c   the class to which instances of the {@code RuntimeType}\n+     *            should belong\n+     * @return    a null-restricted {@code RuntimeType}\n+     *\n+     * @throws IllegalArgumentException if {@code c} represents a primitive type\n+     *\/\n+    public static <T> RuntimeType<T> nullRestricted(Class<T> c) {\n+        if (c.isPrimitive()) throw new IllegalArgumentException();\n+        return new NullRestrictedClass<T>(c);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/RuntimeType.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,493 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.RuntimeType;\n+import java.util.Arrays;\n+import java.util.function.IntFunction;\n+import java.util.stream.IntStream;\n+import java.lang.invoke.*;\n+import sun.invoke.util.Wrapper;\n+\n+import static java.lang.invoke.MethodHandles.*;\n+\n+\/**\n+ * Bootstrap methods for strictly-initialized array creation.\n+ *\/\n+public class ArrayCreation {\n+\n+    private ArrayCreation() {}\n+\n+    private static final Lookup LOOKUP = lookup();\n+    private static final MethodType MAKE_LARVAL_TYPE =\n+            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class);\n+    private static final MethodType MAKE_DEFAULT_TYPE =\n+            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class);\n+    private static final MethodType MAKE_FILLED_TYPE =\n+            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class, Object.class);\n+    private static final MethodType MAKE_COMPUTED_TYPE =\n+            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class, IntFunction.class);\n+    private static final MethodType MAKE_COPY_TYPE =\n+            MethodType.methodType(Object.class, RuntimeType.class, int.class, int.class, Object.class, int.class);\n+\n+    private static boolean isDefault(RuntimeType<?> componentType, Object value) {\n+        Class<?> c = componentType.baseClass();\n+        if (c.isPrimitive()) {\n+            return Wrapper.forPrimitiveType(c).zero().equals(value);\n+        } else {\n+            return value == null && componentType.canCast(null);\n+        }\n+    }\n+\n+    \/\/ makeLarval\n+\n+    private static Object makeLarval(RuntimeType<?> componentType, int flags, int length) {\n+        return Array.newInstance(componentType.baseClass(), length);\n+    }\n+\n+    \/\/ makeDefault\n+\n+    private static Object makeDefault(RuntimeType<?> componentType, int flags, int length) {\n+        if (!componentType.baseClass().isPrimitive() && !componentType.canCast(null)) {\n+            throw new AssertionError(\"unsupported component type: \" + componentType);\n+        }\n+        return Array.newInstance(componentType.baseClass(), length);\n+    }\n+\n+    \/\/ makeFilled\n+\n+    private static Object makeFilled(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        Object[] result = (Object[]) Array.newInstance(componentType.baseClass(), length);\n+        Arrays.fill(result, init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_byte(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        byte[] result = new byte[length];\n+        Arrays.fill(result, (byte) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_short(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        short[] result = new short[length];\n+        Arrays.fill(result, (short) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_int(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        int[] result = new int[length];\n+        Arrays.fill(result, (int) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_long(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        long[] result = new long[length];\n+        Arrays.fill(result, (long) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_float(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        float[] result = new float[length];\n+        Arrays.fill(result, (float) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_double(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        double[] result = new double[length];\n+        Arrays.fill(result, (double) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_boolean(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        boolean[] result = new boolean[length];\n+        Arrays.fill(result, (boolean) init);\n+        return result;\n+    }\n+\n+    private static Object makeFilled_char(RuntimeType<?> componentType, int flags, int length, Object init) {\n+        char[] result = new char[length];\n+        Arrays.fill(result, (char) init);\n+        return result;\n+    }\n+\n+    \/\/ makeComputed\n+\n+    private static Object makeComputed(RuntimeType<?> componentType, int flags,\n+                                         int length, IntFunction<?> func) {\n+        Object[] result = (Object[]) Array.newInstance(componentType.baseClass(), length);\n+        Arrays.setAll(result, func);\n+        return result;\n+    }\n+\n+    private static Object makeComputed_byte(RuntimeType<?> componentType, int flags,\n+                                            int length, IntFunction<?> func) {\n+        byte[] result = new byte[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (byte) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_short(RuntimeType<?> componentType, int flags,\n+                                              int length, IntFunction<?> func) {\n+        short[] result = new short[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (short) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_int(RuntimeType<?> componentType, int flags,\n+                                          int length, IntFunction<?> func) {\n+        int[] result = new int[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (int) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_long(RuntimeType<?> componentType, int flags,\n+                                            int length, IntFunction<?> func) {\n+        long[] result = new long[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (long) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_float(RuntimeType<?> componentType, int flags,\n+                                              int length, IntFunction<?> func) {\n+        float[] result = new float[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (float) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_double(RuntimeType<?> componentType, int flags,\n+                                                int length, IntFunction<?> func) {\n+        double[] result = new double[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (double) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_boolean(RuntimeType<?> componentType, int flags,\n+                                                  int length, IntFunction<?> func) {\n+        boolean[] result = new boolean[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (boolean) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    private static Object makeComputed_char(RuntimeType<?> componentType, int flags,\n+                                            int length, IntFunction<?> func) {\n+        char[] result = new char[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = (char) func.apply(i);\n+        }\n+        return result;\n+    }\n+\n+    \/\/ makeCopy\n+\n+    private static Object makeCopy(RuntimeType<?> componentType, int flags,\n+                                   int length, Object source, int start) {\n+        Object result = Array.newInstance(componentType.baseClass(), length);\n+        System.arraycopy(source, start, result, 0, length);\n+        return result;\n+    }\n+\n+    \/\/ bootstraps\n+\n+    \/**\n+     * Bootstrap method to create an array filled with a given constant initial value.\n+     * Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @param init          Initial value\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite constantFilled(Lookup lookup, String methodName,\n+                                          MethodType type, RuntimeType<?> componentType,\n+                                          int flags, int length, Object init) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        MethodHandle factory;\n+        if (isDefault(componentType, init)) {\n+            factory = LOOKUP.findStatic(ArrayCreation.class, \"makeDefault\", MAKE_DEFAULT_TYPE);\n+            if (length < 0) {\n+                factory = insertArguments(factory, 0, componentType, flags);\n+            } else {\n+                factory = insertArguments(factory, 0, componentType, flags, length);\n+            }\n+        } else {\n+            String mname = \"makeFilled\";\n+            if (componentType.baseClass().isPrimitive()) {\n+                mname += \"_\" + componentType;\n+            }\n+            factory = LOOKUP.findStatic(ArrayCreation.class, mname, MAKE_FILLED_TYPE);\n+            if (length < 0) {\n+                factory = insertArguments(factory, 0, componentType, flags);\n+                factory = insertArguments(factory, 1, init);\n+            } else {\n+                factory = insertArguments(factory, 0, componentType, flags, length, init);\n+            }\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with a dynamically-evaluated\n+     * initial value. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, and an appropriately-typed initial value,\n+     *                      with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite dynamicFilled(Lookup lookup, String methodName,\n+                                         MethodType type, RuntimeType<?> componentType,\n+                                         int flags, int length) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        String mname = \"makeFilled\";\n+        if (componentType.baseClass().isPrimitive()) {\n+            mname += \"_\" + componentType;\n+        }\n+        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, mname, MAKE_FILLED_TYPE);\n+        if (length  < 0) {\n+            factory = insertArguments(factory, 0, componentType, flags);\n+        } else {\n+            factory = insertArguments(factory, 0, componentType, flags, length);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with lazily-computed initial\n+     * values. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, and an IntFunction producing initial values,\n+     *                      with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite computed(Lookup lookup, String methodName,\n+                                    MethodType type, RuntimeType<?> componentType,\n+                                    int flags, int length) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        String mname = \"makeComputed\";\n+        if (componentType.baseClass().isPrimitive()) {\n+            mname += \"_\" + componentType;\n+        }\n+        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, mname, MAKE_COMPUTED_TYPE);\n+        if (length < 0) {\n+            factory = insertArguments(factory, 0, componentType, flags);\n+        } else {\n+            factory = insertArguments(factory, 0, componentType, flags, length);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with values copied from another\n+     * array. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, and a source array of initial values,\n+     *                      with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite copied(Lookup lookup, String methodName,\n+                                  MethodType type, RuntimeType<?> componentType,\n+                                  int flags, int length) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, \"makeCopy\", MAKE_COPY_TYPE);\n+        if (length < 0) {\n+            factory = insertArguments(factory, 0, componentType, flags);\n+            factory = insertArguments(factory, 2, 0);\n+        } else {\n+            factory = insertArguments(factory, 0, componentType, flags, length);\n+            factory = insertArguments(factory, 1, 0);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array filled with values copied from another\n+     * array, starting at an offset. Intended for use with {@code invokedynamic}\n+     * call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: an {@code int} length,\n+     *                      if necessary, a source array of initial values, and\n+     *                      a start offset into the array, with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param length        Length of the array, or -1 for dynamic\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite offsetCopied(Lookup lookup, String methodName,\n+                                        MethodType type, RuntimeType<?> componentType,\n+                                        int flags, int length) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, \"makeCopy\", MAKE_COPY_TYPE);\n+        if (length < 0) {\n+            factory = insertArguments(factory, 0, componentType, flags);\n+        } else {\n+            factory = insertArguments(factory, 0, componentType, flags, length);\n+        }\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array initialized to an enumerated list of\n+     * constant values. Intended for use with {@code invokedynamic} call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: no parameters, with\n+     *                      an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @param values        Initial values\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite constantEnumerated(Lookup lookup, String methodName,\n+                                              MethodType type, RuntimeType<?> componentType,\n+                                              int flags, Object... values) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        MethodHandle factory = LOOKUP.findStatic(ArrayCreation.class, \"makeCopy\", MAKE_COPY_TYPE);\n+        Object src = values;\n+        if (componentType.baseClass().isPrimitive()) {\n+            \/\/ unbox values\n+            src = Array.newInstance(componentType.baseClass(), values.length);\n+            for (int i = 0; i < values.length; i++) {\n+                Array.set(src, i, values[i]);\n+            }\n+        }\n+        factory = insertArguments(factory, 0, componentType, flags, values.length, src, 0);\n+        return new ConstantCallSite(factory.asType(type));\n+    }\n+\n+    \/**\n+     * Bootstrap method to create an array initialized to an enumerated list of\n+     * dynamically-evaluated values. Intended for use with {@code invokedynamic}\n+     * call sites.\n+     *\n+     * @param lookup        Ignored\n+     * @param methodName    Ignored\n+     * @param type          MethodType for the MethodHandle: a parameter for each\n+     *                      array component, with an array return type\n+     * @param componentType RuntimeType representing the array component type\n+     * @param flags         Kind of array to create (always 0 for now)\n+     * @return              a call site wrapping the array creation MethodHandle\n+     * @throws IllegalArgumentException if the bootstrap arguments are invalid\n+     *                                  or inconsistent\n+     * @throws NullPointerException if any argument is {@code null} or if any element\n+     *                              in the {@code getters} array is {@code null}\n+     * @throws Throwable if any exception is thrown during call site construction\n+     *\/\n+    public static CallSite dynamicEnumerated(Lookup lookup, String methodName,\n+                                             MethodType type, RuntimeType<?> componentType,\n+                                             int flags) throws Throwable {\n+        flags = flags | Modifier.STRICT;\n+        Class<?> ccls = componentType.baseClass();\n+        Class<?> acls = ccls.arrayType();\n+        int arity = type.parameterCount();\n+        MethodHandle binaryId = dropArguments(identity(acls), 1, ccls);\n+        \/\/ binaryId type: (acls, ccls)->acls\n+        MethodHandle alloc = LOOKUP.findStatic(ArrayCreation.class, \"makeLarval\", MAKE_LARVAL_TYPE);\n+        alloc = insertArguments(alloc, 0, componentType, flags, arity);\n+        MethodHandle result = alloc.asType(MethodType.methodType(acls));\n+        \/\/ result type: ()->acls\n+        for (int i = 0; i < arity; i++) {\n+            MethodHandle setter = arrayElementSetter(acls);\n+            setter = insertArguments(setter, 1, i);\n+            setter = foldArguments(binaryId, setter);\n+            \/\/ setter type: (acls, ccls)->acls\n+            result = collectArguments(setter, 0, result);\n+            \/\/ result type: (..., ccls)->acls\n+        }\n+        return new ConstantCallSite(result.asType(type));\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ArrayCreation.java","additions":493,"deletions":0,"binary":false,"changes":493,"status":"added"},{"patch":"@@ -166,0 +166,4 @@\n+            case '?', '!', '=' -> {\n+                sigp++;\n+                yield referenceTypeSig();\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,0 +129,7 @@\n+\n+    \/**\n+     * The modifier {@code implicit}\n+     * @since 21\n+     *\/\n+    IMPLICIT,\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import com.sun.tools.javac.util.StringUtils;\n@@ -135,0 +136,3 @@\n+    @Use({FlagTarget.CLASS})\n+    @NoToStringValue\n+    public static final int ACC_NON_ATOMIC = 1<<8;\n@@ -257,0 +261,8 @@\n+    \/** Flag is set for a class symbol if it defines one or more non-empty\n+     *  instance initializer block(s). This is relevant only for class symbols\n+     *  that originate from source types. For binary types the instance initializer\n+     *  blocks are \"normalized\" into the constructors.\n+     *\/\n+    @Use({FlagTarget.CLASS})\n+    public static final long HASINITBLOCK     = 1L<<32;\n+\n@@ -531,0 +543,6 @@\n+    \/**\n+     * Flag to indicate that a value class constructor is implicit\n+     *\/\n+    @Use({FlagTarget.METHOD})\n+    public static final long IMPLICIT    = 1L<<59;\n+\n@@ -570,1 +588,1 @@\n-        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS,\n+        ModifierFlags                     = ((long)StandardFlags & ~INTERFACE) | DEFAULT | SEALED | NON_SEALED | VALUE_CLASS | IMPLICIT,\n@@ -574,1 +592,2 @@\n-        ReceiverParamFlags                = PARAMETER;\n+        ReceiverParamFlags                = PARAMETER,\n+        ImplicitConstructorFlags          = PUBLIC | IMPLICIT;\n@@ -597,0 +616,1 @@\n+            if (0 != (flags & IMPLICIT))        modifiers.add(Modifier.IMPLICIT);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -283,0 +283,5 @@\n+        \/**\n+         * Warn about operations on null-restricted and nullable types.\n+         *\/\n+        NULL(\"null\"),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+            case NULL_RESTRICTED_TYPES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+        res.append(nullMarker(t));\n@@ -193,0 +194,4 @@\n+    private String nullMarker(Type t) {\n+        return t.getNullMarker().typeSuffix();\n+    }\n+\n@@ -235,0 +240,1 @@\n+            buf.append(nullMarker(t));\n@@ -238,0 +244,1 @@\n+            buf.append(nullMarker(t));\n@@ -288,1 +295,1 @@\n-        return s;\n+        return s + nullMarker(t);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -301,0 +301,1 @@\n+        NULL_RESTRICTED_TYPES(JDK23, Fragments.FeatureNullRestrictedTypes, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -359,0 +359,8 @@\n+        \/*if (isValueClassConst()) {\n+            \/\/ previously we had vnew methods which had a return type, not `void`, and we were attaching metadata to it\n+            \/\/ like nullness for example. Type `void` doesn't accept metadata so if we need to state that the result of\n+            \/\/ invoking a value class constructor is never null, we will need another way.\n+            if (((MethodType)t).restype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                ((MethodType)t).restype = ((MethodType)t).restype.addMetadata(new TypeMetadata.NullMarker(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL));\n+            }\n+        }*\/\n@@ -486,0 +494,6 @@\n+    \/** Is this symbol an implicit constructor?\n+     *\/\n+    public boolean isImplicitConstructor() {\n+        return isConstructor() && ((flags() & IMPLICIT) != 0);\n+    }\n+\n@@ -1347,0 +1361,2 @@\n+        private boolean hasImplicitConstructor = false;\n+\n@@ -1712,0 +1728,29 @@\n+\n+        public boolean hasImplicitConstructor() {\n+            if (hasImplicitConstructor) {\n+                return true;\n+            } else {\n+                if (getImplicitConstructor() != null) {\n+                    hasImplicitConstructor = true;\n+                }\n+                return hasImplicitConstructor;\n+            }\n+        }\n+\n+        public void implicitConstructorFound() {\n+            hasImplicitConstructor = true;\n+        }\n+\n+        private MethodSymbol getImplicitConstructor() {\n+            for (Symbol s : members().getSymbols(NON_RECURSIVE)) {\n+                switch (s.kind) {\n+                    case MTH:\n+                        if (s.isConstructor()) {\n+                            if (s.isImplicitConstructor()) {\n+                                return (MethodSymbol) s;\n+                            }\n+                        }\n+                }\n+            }\n+            return null;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -254,0 +254,2 @@\n+    public final Type looselyConsistentValueType;\n+    public final Type reflectArrayType;\n@@ -660,0 +662,3 @@\n+        \/\/ for value objects\n+        looselyConsistentValueType = enterClass(\"java.lang.LooselyConsistentValue\");\n+        reflectArrayType = enterClass(\"java.lang.reflect.Array\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -242,0 +243,4 @@\n+    public boolean hasImplicitConstructor() {\n+        return false;\n+    }\n+\n@@ -540,0 +545,1 @@\n+        sb.append(getNullMarker().typeSuffix());\n@@ -748,0 +754,18 @@\n+    \/\/ support for null-marked types\n+\n+    public Type asNullMarked(NullMarker nullMarker) {\n+        if (nullMarker == getNullMarker()) return this;\n+        Type base = dropMetadata(TypeMetadata.NullMarker.class);\n+        return (nullMarker == NullMarker.UNSPECIFIED) ?\n+                base :\n+                base.addMetadata(new TypeMetadata.NullMarker(nullMarker));\n+    }\n+\n+    public NullMarker getNullMarker() {\n+        TypeMetadata.NullMarker nm = getMetadata(TypeMetadata.NullMarker.class);\n+        return nm != null ?\n+                nm.nullMarker() : NullMarker.UNSPECIFIED;\n+    }\n+\n+    \/\/ end of support for null-marked types\n+\n@@ -1109,0 +1133,2 @@\n+            buf.append(getNullMarker().typeSuffix());\n+\n@@ -1118,1 +1144,2 @@\n-                if (sym.name.isEmpty() && (sym.flags() & COMPOUND) != 0) {\n+                \/\/ invoking sym.flags() below can provoke symbol completion\n+                if (sym.name.isEmpty() && (sym.flags_field & COMPOUND) != 0) {\n@@ -1190,0 +1217,5 @@\n+        @Override\n+        public boolean hasImplicitConstructor() {\n+            return tsym != null && tsym.kind == TYP && ((ClassSymbol)tsym).hasImplicitConstructor();\n+        }\n+\n@@ -1421,0 +1453,1 @@\n+                sb.append(t.getNullMarker().typeSuffix());\n@@ -2176,0 +2209,3 @@\n+                if (types.isParametric(qtype)) {\n+                    bound2 = bound2.asNullMarked(bound.getNullMarker());\n+                }\n@@ -2180,1 +2216,2 @@\n-                    if (types.isSameType(b, bound2)) return;\n+                    if (b.getNullMarker() == bound2.getNullMarker() &&\n+                            types.isSameType(b, bound2)) return;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression;\n+import com.sun.tools.javac.util.Assert;\n@@ -79,0 +81,5 @@\n+\n+    record NullMarker(JCNullableTypeExpression.NullMarker nullMarker) implements TypeMetadata {\n+        @Override\n+        public String toString() { return \"NULL_MARKER [ \" + nullMarker.typeSuffix() + \" ]\"; }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeMetadata.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import com.sun.tools.javac.code.Source.Feature;\n@@ -54,0 +55,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -106,0 +108,4 @@\n+    \/* are nullable and null-restricted types allowed? *\/\n+    private boolean allowNullRestrictedTypes;\n+    private boolean tvarUnspecifiedNullity;\n+\n@@ -131,0 +137,3 @@\n+        Preview preview = Preview.instance(context);\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -133,0 +142,1 @@\n+        tvarUnspecifiedNullity = options.isSet(\"tvarUnspecifiedNullity\");\n@@ -1029,0 +1039,1 @@\n+                boolean result;\n@@ -1030,1 +1041,1 @@\n-                    return isSameType(elemtype(t), elemtype(s));\n+                    result = isSameType(elemtype(t), elemtype(s));\n@@ -1032,1 +1043,4 @@\n-                    return isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n+                    result = isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);\n+                }\n+                if (result && allowNullRestrictedTypes && hasNarrowerNullability(s, t)) {\n+                    warn.warn(LintCategory.NULL);\n@@ -1034,1 +1048,2 @@\n-            } else if (isSubtype(t, s, capture)) {\n+                return result;\n+            } else if (isSubtype(t, s, capture, warn)) {\n@@ -1084,0 +1099,8 @@\n+    public boolean isSubtype(Type t, Type s, boolean capture, Warner warner) {\n+        try {\n+            pushWarner(warner);\n+            return isSubtype(t, s, capture);\n+        } finally {\n+            popWarner();\n+        }\n+    }\n@@ -1085,1 +1108,4 @@\n-        if (t.equalsIgnoreMetadata(s))\n+        if (t.equalsIgnoreMetadata(s)) {\n+            if (allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n+                warnStack.head.warn(LintCategory.NULL);\n+            }\n@@ -1087,0 +1113,1 @@\n+        }\n@@ -1127,1 +1154,4 @@\n-                 case BOT:\n+                 case BOT: {\n+                     if (isNonNullable(s)) {\n+                         return false;\n+                     }\n@@ -1129,2 +1159,3 @@\n-                         s.hasTag(BOT) || s.hasTag(CLASS) ||\n-                         s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                             s.hasTag(BOT) || s.hasTag(CLASS) ||\n+                             s.hasTag(ARRAY) || s.hasTag(TYPEVAR);\n+                 }\n@@ -1195,1 +1226,1 @@\n-                return sup.tsym == s.tsym\n+                boolean result = sup.tsym == s.tsym\n@@ -1200,0 +1231,4 @@\n+                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+                return result;\n@@ -1204,0 +1239,1 @@\n+                boolean result = false;\n@@ -1206,1 +1242,1 @@\n-                        return isSameType(t.elemtype, elemtype(s));\n+                        result = isSameType(t.elemtype, elemtype(s));\n@@ -1208,1 +1244,1 @@\n-                        return isSubtypeNoCapture(t.elemtype, elemtype(s));\n+                        result = isSubtypeNoCapture(t.elemtype, elemtype(s));\n@@ -1211,1 +1247,1 @@\n-                if (s.hasTag(CLASS)) {\n+                if (!result && s.hasTag(CLASS)) {\n@@ -1213,1 +1249,1 @@\n-                    return sname == names.java_lang_Object\n+                    result = sname == names.java_lang_Object\n@@ -1218,1 +1254,5 @@\n-                return false;\n+                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && hasNarrowerNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+\n+                return result;\n@@ -1359,1 +1399,4 @@\n-                if (t.equalsIgnoreMetadata(s))\n+                if (t.equalsIgnoreMetadata(s)) {\n+                    if (allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n+                        warnStack.head.warn(LintCategory.NULL);\n+                    }\n@@ -1361,0 +1404,1 @@\n+                }\n@@ -1429,1 +1473,1 @@\n-                return t.tsym == s.tsym\n+                boolean equal = t.tsym == s.tsym\n@@ -1432,0 +1476,4 @@\n+                if (equal && allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+                return equal;\n@@ -1438,8 +1486,13 @@\n-                if (t == s)\n-                    return true;\n-\n-                if (s.isPartial())\n-                    return visit(s, t);\n-\n-                return s.hasTag(ARRAY)\n-                    && containsTypeEquivalent(t.elemtype, elemtype(s));\n+                boolean result;\n+                if (t == s) {\n+                    result = true;\n+                } else if (s.isPartial()) {\n+                    result = visit(s, t);\n+                } else {\n+                    result = s.hasTag(ARRAY) &&\n+                            containsTypeEquivalent(t.elemtype, elemtype(s));\n+                }\n+                if (result && allowNullRestrictedTypes && warnStack.nonEmpty() && !hasSameNullability(s, t)) {\n+                    warnStack.head.warn(LintCategory.NULL);\n+                }\n+                return result;\n@@ -1769,1 +1822,1 @@\n-                if (s.hasTag(ERROR) || s.hasTag(BOT))\n+                if (s.hasTag(ERROR) || s.hasTag(BOT) && (!t.hasImplicitConstructor() || !isNonNullable(t)))\n@@ -2179,0 +2232,10 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"warn stack\">\n+    public void pushWarner(Warner warner) {\n+        warnStack = warnStack.prepend(warner);\n+    }\n+\n+    public void popWarner() {\n+        warnStack = warnStack.tail;\n+    }\n+    \/\/ <\/editor-fold>\n+\n@@ -2368,0 +2431,4 @@\n+                            } else if (baseParams.length() != ownerParams.length()) {\n+                                \/\/ rare type, recovery\n+                                return subst(sym.type, ownerParams,\n+                                        baseParams.map(ta -> ta.asNullMarked(NullMarker.UNSPECIFIED)));\n@@ -2369,1 +2436,9 @@\n-                                return subst(sym.type, ownerParams, baseParams);\n+                                ListBuffer<Type> newBaseParams = new ListBuffer<>();\n+                                for (Type tvar : ownerParams) {\n+                                    Type baseParam = isParametric(tvar) ?\n+                                            baseParams.head :\n+                                            baseParams.head.asNullMarked(NullMarker.UNSPECIFIED);\n+                                    newBaseParams.add(baseParam);\n+                                    baseParams = baseParams.tail;\n+                                }\n+                                return subst(sym.type, ownerParams, newBaseParams.toList());\n@@ -2466,1 +2541,1 @@\n-                            return s.dropMetadata(Annotations.class);\n+                            return s.dropMetadata(Annotations.class).dropMetadata(TypeMetadata.NullMarker.class);\n@@ -2511,1 +2586,7 @@\n-        };\n+\n+        @Override\n+        public Type visitArrayType(ArrayType t, Boolean aBoolean) {\n+            Type erased = super.visitArrayType(t, aBoolean);\n+            return combineMetadata(erased, t);\n+        }\n+    };\n@@ -2854,1 +2935,10 @@\n-        return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        return isSubSignature(t, s, noWarnings);\n+    }\n+\n+    public boolean isSubSignature(Type t, Type s, Warner warn) {\n+        try {\n+            warnStack = warnStack.prepend(warn);\n+            return hasSameArgs(t, s, true) || hasSameArgs(t, erasure(s), true);\n+        } finally {\n+            warnStack = warnStack.tail;\n+        }\n@@ -4039,0 +4129,1 @@\n+        NullMarker nullMarker = NullMarker.NOT_NULL;\n@@ -4043,0 +4134,3 @@\n+            if (t.getNullMarker().ordinal() > nullMarker.ordinal()) {\n+                nullMarker = t.getNullMarker();\n+            }\n@@ -4092,1 +4186,2 @@\n-            return new ArrayType(lub(elements), syms.arrayClass);\n+            return new ArrayType(lub(elements), syms.arrayClass)\n+                    .asNullMarked(nullMarker);\n@@ -4127,1 +4222,2 @@\n-            return compoundMin(candidates);\n+            return compoundMin(candidates)\n+                    .asNullMarked(nullMarker);\n@@ -4180,1 +4276,4 @@\n-        else if (t.isPrimitive() || s.isPrimitive())\n+\n+        final NullMarker nullMarker = t.getNullMarker().ordinal() < s.getNullMarker().ordinal() ?\n+                    t.getNullMarker() : s.getNullMarker();\n+        if (t.isPrimitive() || s.isPrimitive())\n@@ -4183,1 +4282,1 @@\n-            return t;\n+            return t.asNullMarked(nullMarker);\n@@ -4185,1 +4284,1 @@\n-            return s;\n+            return s.asNullMarked(nullMarker);\n@@ -4188,1 +4287,1 @@\n-        return glbFlattened(closure, t);\n+        return glbFlattened(closure, t).asNullMarked(nullMarker);\n@@ -5294,0 +5393,4 @@\n+            assembleSig(type, false);\n+        }\n+\n+        public void assembleSig(Type type, boolean includeNullMarkers) {\n@@ -5327,1 +5430,7 @@\n-                    assembleClassSig(type);\n+                    assembleClassSig(type, includeNullMarkers);\n+                    if (includeNullMarkers) {\n+                        NullMarker nullMarker = type.getNullMarker();\n+                        if (nullMarker != NullMarker.UNSPECIFIED) {\n+                            append(nullMarker.typeSuffix().charAt(0));\n+                        }\n+                    }\n@@ -5333,1 +5442,7 @@\n-                    assembleSig(at.elemtype);\n+                    assembleSig(at.elemtype, includeNullMarkers);\n+                    \/*if (includeNullMarkers) {   \/\/ there is no type in the VM for null-restricted arrays, for now\n+                        NullMarker nmArray = at.getNullMarker();\n+                        if (nmArray != NullMarker.UNSPECIFIED) {\n+                            append(nmArray.typeSuffix().charAt(0));\n+                        }\n+                    }*\/\n@@ -5353,1 +5468,1 @@\n-                            assembleSig(ta.type);\n+                            assembleSig(ta.type, includeNullMarkers);\n@@ -5357,1 +5472,1 @@\n-                            assembleSig(ta.type);\n+                            assembleSig(ta.type, includeNullMarkers);\n@@ -5373,0 +5488,10 @@\n+                    if (includeNullMarkers) {\n+                        if (Types.this.isDeclaredParametric(type)) {\n+                            append('=');\/\/ '*' is already used for wildcards\n+                        } else {\n+                            NullMarker nmTV = type.getNullMarker();\n+                            if (nmTV != NullMarker.UNSPECIFIED) {\n+                                append(nmTV.typeSuffix().charAt(0));\n+                            }\n+                        }\n+                    }\n@@ -5396,0 +5521,4 @@\n+            assembleClassSig(type, false);\n+        }\n+\n+        public void assembleClassSig(Type type, boolean includeNullMarkers) {\n@@ -5406,1 +5535,1 @@\n-                        : outer);\n+                        : outer, includeNullMarkers);\n@@ -5417,1 +5546,1 @@\n-                assembleSig(ct.getTypeArguments());\n+                assembleSig(ct.getTypeArguments(), includeNullMarkers);\n@@ -5423,0 +5552,4 @@\n+            assembleParamsSig(typarams, false);\n+        }\n+\n+        public void assembleParamsSig(List<Type> typarams, boolean includeNullMarkers) {\n@@ -5433,1 +5566,1 @@\n-                    assembleSig(l.head);\n+                    assembleSig(l.head, includeNullMarkers);\n@@ -5440,0 +5573,4 @@\n+            assembleSig(types, false);\n+        }\n+\n+        public void assembleSig(List<Type> types, boolean includeNullMarkers) {\n@@ -5441,1 +5578,1 @@\n-                assembleSig(ts.head);\n+                assembleSig(ts.head, includeNullMarkers);\n@@ -5472,0 +5609,45 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"nullability methods\">\n+\n+    public boolean isNullable(Type type) {\n+        return type.getNullMarker() == NullMarker.NULLABLE;\n+    }\n+\n+    public boolean isNonNullable(Type type) {\n+        return type.getNullMarker() == NullMarker.NOT_NULL;\n+    }\n+\n+    public boolean isParametric(Type type) {\n+        return type.getNullMarker() == NullMarker.PARAMETRIC ||\n+                (type.hasTag(TYPEVAR) && type.getNullMarker() == NullMarker.UNSPECIFIED && !tvarUnspecifiedNullity);\n+    }\n+\n+    public boolean isDeclaredParametric(Type type) {\n+        return type.getNullMarker() == NullMarker.PARAMETRIC;\n+    }\n+\n+    public boolean isNullUnspecified(Type type) {\n+        return type.getNullMarker() == NullMarker.UNSPECIFIED &&\n+                (!type.hasTag(TYPEVAR) || tvarUnspecifiedNullity);\n+    }\n+\n+    \/**\n+     * Do t and s have the same nullability?\n+     *\/\n+    public boolean hasSameNullability(Type t, Type s) {\n+        if (s == null || t == null || isNullUnspecified(t) || isNullUnspecified(s)) {\n+            return true;\n+        }\n+        return t.getNullMarker() == s.getNullMarker();\n+    }\n+\n+    \/**\n+     * Does t have narrower nullability than s?\n+     *\/\n+    public boolean hasNarrowerNullability(Type t, Type s) {\n+        if (s == null || t == null || isNullUnspecified(t) || isNullUnspecified(s)) {\n+            return false;\n+        }\n+        return t.getNullMarker().ordinal() < s.getNullMarker().ordinal();\n+    }\n+    \/\/ <\/editor-fold>\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":224,"deletions":42,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -193,0 +194,3 @@\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n+        allowNullRestrictedTypesForValueClassesOnly = options.isSet(\"allowNullRestrictedTypesForValueClassesOnly\");\n@@ -226,0 +230,8 @@\n+    \/** Are null-restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n+\n+    \/** Are null-restricted types allowed for value classes only\n+     *\/\n+    private final boolean allowNullRestrictedTypesForValueClassesOnly;\n+\n@@ -735,0 +747,4 @@\n+        if (allowNullRestrictedTypes && tree instanceof JCNullableTypeExpression nullableTypeExpression &&\n+                nullableTypeExpression.getNullMarker() != NullMarker.UNSPECIFIED) {\n+            result = tree.type = result.addMetadata(new TypeMetadata.NullMarker(nullableTypeExpression.getNullMarker()));\n+        }\n@@ -1168,0 +1184,8 @@\n+            if (allowNullRestrictedTypes && tree.sym.isImplicitConstructor()) {\n+                if (tree.body == null) {\n+                    tree.body = make.Block(0, List.nil());\n+                } else {\n+                    log.error(tree.pos(), Errors.ImplicitConstCantHaveBody);\n+                }\n+            }\n+\n@@ -1712,0 +1736,14 @@\n+            if (allowNullRestrictedTypes) {\n+                Type elemOrType = result;\n+                while (!elemOrType.hasTag(ERROR) && types.elemtype(elemOrType) != null) {\n+                    elemOrType = types.elemtype(elemOrType);\n+                }\n+                if (allowNullRestrictedTypesForValueClassesOnly &&\n+                        ((types.isNonNullable(result) || types.isNonNullable(elemOrType)) && (!elemOrType.isValueClass() || !elemOrType.hasImplicitConstructor()))) {\n+                    log.error(tree.pos(),\n+                            types.elemtype(result) == null?\n+                                    Errors.TypeCantBeNullRestricted(result) :\n+                                    Errors.TypeCantBeNullRestricted2(result)\n+                    );\n+                }\n+            }\n@@ -1822,0 +1860,3 @@\n+                if (tree.stats.size() > 0) {\n+                    env.info.scope.owner.flags_field |= HASINITBLOCK;\n+                }\n@@ -3306,1 +3347,1 @@\n-            if (tree.constructor != null && tree.constructor.kind == MTH)\n+            if (tree.constructor != null && tree.constructor.kind == MTH) {\n@@ -3308,0 +3349,4 @@\n+                if (allowNullRestrictedTypes && owntype.getMetadata(TypeMetadata.NullMarker.class) == null) {\n+                    owntype = owntype.addMetadata(new TypeMetadata.NullMarker(NullMarker.NOT_NULL)); \/\/ constructor invocations are always null restricted\n+                }\n+            }\n@@ -3508,0 +3553,1 @@\n+            List<NullMarker> nullMarkers = tree.nullMarkers.reverse();\n@@ -3510,1 +3556,3 @@\n-                owntype = new ArrayType(owntype, syms.arrayClass);\n+                owntype = new ArrayType(owntype, syms.arrayClass)\n+                        .asNullMarked(nullMarkers.head);\n+                nullMarkers = nullMarkers.tail;\n@@ -4797,0 +4845,10 @@\n+        \/\/ check nullness of site\n+        if (types.isNullable(site)) {\n+            chk.warnNullableTypes(tree.selected, LintWarnings.AccessingMemberOfNullable);\n+        }\n+\n+        if (types.isParametric(site)) {\n+            \/\/ see JDK-8339087\n+            \/\/chk.warnNullableTypes(tree.selected, Warnings.AccessingMemberOfParametric);\n+        }\n+\n@@ -5112,0 +5170,5 @@\n+                           \/* we shouldn't do a memberType invocation if symbol owner and site are the same\n+                            * this has been done in the context of nullness markers due to a loss of the nullness\n+                            * markers info when type variables are adapted\n+                            *\/\n+                           sym.owner.type != site &&\n@@ -5759,0 +5822,5 @@\n+            if (c.type.isValueClass()) {\n+                final Env<AttrContext> env = typeEnvs.get(c);\n+                if (allowNullRestrictedTypes && env != null && env.tree != null && env.tree.hasTag(CLASSDEF) && TreeInfo.getImplicitConstructor(((JCClassDecl)env.tree).defs) != null)\n+                    chk.checkNonCyclicMembership((JCClassDecl)env.tree);\n+            }\n@@ -5948,0 +6016,1 @@\n+                chk.checkConstraintsOfValueClassesWithImplicitConst((JCClassDecl) env.tree, c);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":71,"deletions":2,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.lang.model.type.TypeKind;\n@@ -172,0 +173,2 @@\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -209,0 +212,4 @@\n+    \/** Are null restricted types allowed\n+     *\/\n+    private final boolean allowNullRestrictedTypes;\n+\n@@ -264,0 +271,10 @@\n+    \/** Warn about operation with bang types.\n+     *  @param pos        Position to be used for error reporting.\n+     *  @param warnKey    A warning key.\n+     *\/\n+    public void warnNullableTypes(DiagnosticPosition pos, LintWarning warnKey) {\n+        if (allowNullRestrictedTypes) {\n+            log.warning(pos, warnKey);\n+        }\n+    }\n+\n@@ -597,1 +614,3 @@\n-            log.warning(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n+            if (!lint.isEnabled(LintCategory.NULL) || !types.hasNarrowerNullability(tree.clazz.type, tree.expr.type)) {\n+                log.warning(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n+            }\n@@ -623,1 +642,1 @@\n-    private boolean checkExtends(Type a, Type bound) {\n+    private boolean checkExtends(JCTree pos, Type a, Type bound) {\n@@ -628,1 +647,11 @@\n-             return types.isSubtype(a, bound);\n+             try {\n+                 if (pos != null) {\n+                     types.pushWarner(new NullnessWarner(pos));\n+                 }\n+                 return types.isSubtype(a, bound, true);\n+             } finally {\n+                 if (pos != null) {\n+                     types.popWarner();\n+                 }\n+             }\n+\n@@ -705,0 +734,24 @@\n+    void checkConstraintsOfValueClassesWithImplicitConst(JCClassDecl classDecl, ClassSymbol c) {\n+        if (allowNullRestrictedTypes) {\n+            JCMethodDecl implicitConstructor = TreeInfo.getImplicitConstructor(classDecl.defs);\n+            if (implicitConstructor != null) {\n+                Type encl = c.type.getEnclosingType();\n+                if (encl != null && encl.hasTag(CLASS)) {\n+                    log.error(classDecl.pos(), Errors.ValueClassWithImplicitCannotBeInner(c));\n+                }\n+                if ((c.flags() & HASINITBLOCK) != 0) {\n+                    log.error(classDecl.pos(), Errors.ValueClassWithImplicitDeclaresInitBlock(c));\n+                }\n+                for (Symbol s : c.members().getSymbols(NON_RECURSIVE)) {\n+                    switch (s.kind) {\n+                        case VAR:\n+                            if ((s.flags() & STATIC) == 0 & (s.flags() & HASINIT) != 0) {\n+                                log.error(classDecl.pos(), Errors.ValueClassWithImplicitInstanceFieldInitializer(c));\n+                            }\n+                            break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -1070,1 +1123,5 @@\n-        return firstIncompatibleTypeArg(t) == null;\n+        return checkValidGenericType(null, t);\n+    }\n+\n+    public boolean checkValidGenericType(JCTree pos, Type t) {\n+        return firstIncompatibleTypeArg(pos, t) == null;\n@@ -1073,1 +1130,1 @@\n-        private Type firstIncompatibleTypeArg(Type type) {\n+        private Type firstIncompatibleTypeArg(JCTree pos, Type type) {\n@@ -1110,1 +1167,1 @@\n-                        !checkExtends(actual, bounds.head)) {\n+                        !checkExtends(pos, actual, bounds.head)) {\n@@ -1183,0 +1240,1 @@\n+                boolean isNonNullableFieldOfNonValueClass = !sym.owner.type.isValueClass() && types.isNonNullable(sym.type);\n@@ -1186,0 +1244,3 @@\n+                } else if (isNonNullableFieldOfNonValueClass) {\n+                    implicit |= STRICT;\n+                    mask = ValueFieldFlags;\n@@ -1199,1 +1260,9 @@\n-                } else\n+                } else if ((flags & IMPLICIT) != 0) {\n+                    if ((flags & PUBLIC) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBePublic);\n+                    }\n+                    if ((sym.owner.flags_field & VALUE_CLASS) == 0) {\n+                        log.error(pos, Errors.ImplicitConstMustBeDeclaredInValueClass);\n+                    }\n+                    mask = ImplicitConstructorFlags;\n+                } else {\n@@ -1201,0 +1270,1 @@\n+                }\n@@ -1313,0 +1383,4 @@\n+                 checkDisjoint(pos, flags,\n+                        INTERFACE,\n+                        VALUE_CLASS)\n+                 &&\n@@ -1444,1 +1518,1 @@\n-                Type incompatibleArg = firstIncompatibleTypeArg(tree.type);\n+                Type incompatibleArg = firstIncompatibleTypeArg(tree, tree.type);\n@@ -1848,2 +1922,16 @@\n-        boolean resultTypesOK =\n-            types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);\n+        boolean resultTypesOK = false;\n+        try {\n+            types.pushWarner(overrideWarner);\n+            resultTypesOK = types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);\n+            if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+                warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), LintWarnings.OverridesWithDifferentNullness1);\n+            }\n+            overrideWarner.remove(LintCategory.NULL);\n+            \/\/ at this point we know this will be true but to gather the warnings\n+            types.isSubSignature(mt, ot, overrideWarner);\n+            if (overrideWarner.hasNonSilentLint(LintCategory.NULL)) {\n+                warnNullableTypes(TreeInfo.diagnosticPositionFor(m, tree), LintWarnings.OverridesWithDifferentNullness2);\n+            }\n+        } finally {\n+            types.popWarner();\n+        }\n@@ -2326,0 +2414,43 @@\n+    \/\/ A primitive class cannot contain a field of its own type either or indirectly.\n+    \/\/ TODO, update this method once we have null restricted types\n+    void checkNonCyclicMembership(JCClassDecl tree) {\n+        if (!tree.sym.type.hasImplicitConstructor()) {\n+            return;\n+        }\n+        Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+        try {\n+            tree.sym.flags_field |= LOCKED;\n+            for (List<? extends JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                if (l.head.hasTag(VARDEF)) {\n+                    JCVariableDecl field = (JCVariableDecl) l.head;\n+                    if (cyclePossible(field.sym)) {\n+                        checkNonCyclicMembership((ClassSymbol) field.type.tsym, field.pos());\n+                    }\n+                }\n+            }\n+        } finally {\n+            tree.sym.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {\n+        \/*\n+        if ((c.flags_field & LOCKED) != 0) {\n+            log.error(pos, Errors.CyclicPrimitiveClassMembership(c));\n+            return;\n+        }\n+        try {\n+            c.flags_field |= LOCKED;\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+        *\/\n+    }\n+        \/\/ where\n+        private boolean cyclePossible(VarSymbol symbol) {\n+            return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && types.isNonNullable(symbol.type);\n+        }\n+\n@@ -2582,0 +2713,13 @@\n+        boolean implementsLooselyConsistentValue = false;\n+        try {\n+            implementsLooselyConsistentValue = allowValueClasses && allowNullRestrictedTypes ? types.asSuper(c, syms.looselyConsistentValueType.tsym) != null : false;\n+        } catch (CompletionFailure cf) {\n+            \/\/ ignore\n+        }\n+        boolean cIsValue = (c.tsym.flags() & VALUE_CLASS) != 0;\n+        boolean cHasIdentity = (c.tsym.flags() & IDENTITY_TYPE) != 0;\n+        if (c.getKind() == TypeKind.DECLARED && implementsLooselyConsistentValue && !c.tsym.isAbstract()) {\n+            if (!cIsValue || !((ClassSymbol)c.tsym).hasImplicitConstructor()) {\n+                log.error(pos, Errors.CantImplementInterface(c.tsym));\n+            }\n+        }\n@@ -4401,0 +4545,22 @@\n+    private class NullnessWarner extends Warner {\n+        public NullnessWarner(DiagnosticPosition pos) {\n+            super(pos);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            if (allowNullRestrictedTypes) {\n+                boolean warned = this.warned;\n+                super.warn(lint);\n+                if (warned) return; \/\/ suppress redundant diagnostics\n+                switch (lint) {\n+                    case NULL:\n+                        Check.this.warnNullableTypes(pos(), LintWarnings.UncheckedNullnessConversion);\n+                        break;\n+                    default:\n+                        throw new AssertionError(\"Unexpected lint: \" + lint);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -4429,0 +4595,3 @@\n+                case NULL:\n+                    Check.this.warnNullableTypes(pos(), LintWarnings.UncheckedNullnessConversion);\n+                    break;\n@@ -4432,0 +4601,21 @@\n+            this.warned = true;\n+        }\n+    }\n+\n+    private class CastWarner extends ConversionWarner {\n+        public CastWarner(DiagnosticPosition pos, String key, Type found, Type expected) {\n+            super(pos, key, found, expected);\n+        }\n+\n+        @Override\n+        public void warn(LintCategory lint) {\n+            if (lint != LintCategory.NULL) {\n+                super.warn(lint);\n+            } else {\n+                boolean warned = this.warned;\n+                if (warned) return;\n+                if (types.isParametric(expected)) {\n+                    \/\/ not sure this is the right warning\n+                    Check.this.warnNullableTypes(pos(), LintWarnings.NarrowingNullnessConversion);\n+                }\n+            }\n@@ -4436,1 +4626,1 @@\n-        return new ConversionWarner(pos, \"unchecked.cast.to.type\", found, expected);\n+        return new CastWarner(pos, \"unchecked.cast.to.type\", found, expected);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":201,"deletions":11,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -1726,0 +1726,1 @@\n+        private JCMethodDecl currentMethod;\n@@ -1742,1 +1743,2 @@\n-                isFinalOrStrictUninitializedField(sym)));\n+                isFinalOrStrictUninitializedField(sym)) ||\n+                isUninitializedNonNullableField(sym));\n@@ -1752,0 +1754,14 @@\n+        boolean isUninitializedNonNullableOrParametricField(VarSymbol sym) {\n+            return sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                            classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                            (types.isNonNullable(sym.type) || types.isParametric(sym.type)));\n+        }\n+\n+        boolean isUninitializedNonNullableField(VarSymbol sym) {\n+            return sym.owner.kind == TYP &&\n+                    ((sym.flags() & (FINAL | HASINIT | PARAMETER)) == 0 &&\n+                            classDef.sym.isEnclosedBy((ClassSymbol)sym.owner) &&\n+                            types.isNonNullable(sym.type));\n+        }\n+\n@@ -1850,1 +1866,10 @@\n-                log.error(pos, errkey);\n+                if (isUninitializedNonNullableField(sym)) {\n+                    if (types.isNonNullable(sym.type)) {\n+                        log.error(pos, Errors.NonNullableShouldBeInitialized);\n+                    } else {\n+                        \/\/ see JDK-8339087\n+                        \/\/log.warning(pos, Warnings.ParametricShouldBeInitialized);\n+                    }\n+                } else {\n+                    log.error(pos, errkey);\n+                }\n@@ -2040,0 +2065,1 @@\n+            JCMethodDecl currentMethodPrev = currentMethod;\n@@ -2044,1 +2070,1 @@\n-\n+                currentMethod = tree;\n@@ -2100,1 +2126,1 @@\n-                            } else {\n+                            } else if (!tree.sym.isImplicitConstructor()) { \/\/ implicit constructors are special, ignore them\n@@ -2115,0 +2141,1 @@\n+                currentMethod = currentMethodPrev;\n@@ -2600,1 +2627,1 @@\n-                if (name == names._super) {\n+                if (name == names._super && !currentMethod.sym.isImplicitConstructor()) {\n@@ -2605,1 +2632,4 @@\n-                        if (allowValueClasses && (var.owner == classDef.sym && !var.isStatic() && (var.isStrict() || ((var.flags_field & RECORD) != 0)) && !isCompactOrGeneratedRecordConstructor)) {\n+                        boolean isInstanceRecordField = var.enclClass().isRecord() &&\n+                                (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n+                                var.owner.kind == TYP;\n+                        if (allowValueClasses && (var.owner == classDef.sym && !var.isStatic() && var.isStrict() && !isInstanceRecordField)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1465,1 +1465,4 @@\n-                return filterBounds(uv, inferenceContext).head;\n+                Infer infer = inferenceContext.infer;\n+                List<Type> eqbounds = filterBounds(uv, inferenceContext);\n+                return eqbounds.tail.tail == null  ?\n+                        eqbounds.head : infer.types.lub(eqbounds);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+    private final boolean allowNullRestrictedTypes;\n@@ -148,0 +149,2 @@\n+        this.allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -4294,0 +4297,2 @@\n+        \/\/ nullness info could be lost in the translation process, let's keep the original element type\n+        JCExpression originalElemType = tree.elemtype;\n@@ -4295,1 +4300,2 @@\n-        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail)\n+        int noOfDims = 0;\n+        for (List<JCExpression> t = tree.dims; t.tail != null; t = t.tail) {\n@@ -4297,0 +4303,2 @@\n+            noOfDims++;\n+        }\n@@ -4298,1 +4306,26 @@\n-        result = tree;\n+        if (!allowNullRestrictedTypes || tree.elemtype == null || !types.isNonNullable(originalElemType.type)) {\n+            result = tree;\n+        } else {\n+            Symbol elemClass = syms.getClassField(tree.elemtype.type, types);\n+            JCFieldAccess elemClassExpr = make.Select(make.Ident(tree.elemtype.type.tsym).setType(tree.elemtype.type), elemClass);\n+            MethodSymbol asNullRestrictedTypeMeth = lookupMethod(tree.pos(), names.asNullRestrictedType, syms.classType, List.nil());\n+            JCExpression asNullRestrictedTypeCall = make.Apply(\n+                        null,\n+                        make.Select(elemClassExpr, asNullRestrictedTypeMeth).setType(syms.classType), List.nil()).setType(syms.classType);\n+            List<JCExpression> dimsExp = tree.dims;\n+            if (noOfDims > 1) {\n+                JCNewArray dimsArr = make.NewArray(make.Type(syms.intType), List.nil(), tree.dims);\n+                dimsArr.type = types.makeArrayType(syms.intType);\n+                dimsExp = List.of(dimsArr);\n+            }\n+            MethodSymbol appyMeth = lookupMethod(tree.pos(), names.newInstance,\n+                syms.reflectArrayType, List.of(syms.classType, noOfDims == 1 ? syms.intType : types.makeArrayType(syms.intType)));\n+            JCExpression call =\n+                    make.Apply(\n+                            null,\n+                            make.Select(make.Ident(syms.reflectArrayType.tsym).setType(syms.reflectArrayType), appyMeth).setType(syms.objectType),\n+                            dimsExp.prepend(asNullRestrictedTypeCall))\n+                            .setType(syms.objectType);\n+            JCExpression cast = make.TypeCast(types.makeArrayType(tree.elemtype.type, noOfDims), call);\n+            result = cast;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -183,0 +184,21 @@\n+    JCExpression generateNullCheckIfNeeded(JCExpression tree) {\n+        if (expectedNullness == NullMarker.NOT_NULL && !types.isNonNullable(tree.type)) {\n+            return attr.makeNullCheck(tree);\n+        }\n+        return tree;\n+    }\n+\n+    \/** Translate method argument list, casting each argument\n+     *  to its corresponding type in a list of target types.\n+     *  @param _args               The method argument list.\n+     *  @param parameters          The list of target types.\n+     *  @param varargsElement      The erasure of the varargs element type,\n+     *                             or null if translating a non-varargs invocation\n+     *\/\n+    <T extends JCTree> List<T> translateArgs(List<T> _args,\n+                                             List<Type> parameters,\n+                                             Type varargsElement) {\n+        return translateArgs(_args, parameters, parameters.map(t -> NullMarker.UNSPECIFIED),\n+                varargsElement, NullMarker.UNSPECIFIED);\n+    }\n+\n@@ -185,4 +207,6 @@\n-     *  @param _args            The method argument list.\n-     *  @param parameters       The list of target types.\n-     *  @param varargsElement   The erasure of the varargs element type,\n-     *  or null if translating a non-varargs invocation\n+     *  @param _args                      The method argument list.\n+     *  @param parameters                 The list of target types (after erasure).\n+     *  @param paramsNullMarkers          The list of null markers of the target types\n+     *  @param varargsElement             The erasure of the varargs element type,\n+     *                                    or null if translating a non-varargs invocation\n+     *  @param varargsElementNullMarker   The null marker of the varargs element type\n@@ -192,1 +216,3 @@\n-                                           Type varargsElement) {\n+                                           List<NullMarker> paramsNullMarkers,\n+                                           Type varargsElement,\n+                                           NullMarker varargsElementNullMarker) {\n@@ -196,1 +222,1 @@\n-            args.head = translate(args.head, parameters.head);\n+            args.head = translate(args.head, parameters.head, paramsNullMarkers.head);\n@@ -199,0 +225,1 @@\n+            paramsNullMarkers = paramsNullMarkers.tail;\n@@ -204,1 +231,1 @@\n-                args.head = translate(args.head, varargsElement);\n+                args.head = translate(args.head, varargsElement, varargsElementNullMarker);\n@@ -208,1 +235,1 @@\n-            args.head = translate(args.head, parameter);\n+            args.head = translate(args.head, parameter, paramsNullMarkers.head);\n@@ -444,0 +471,2 @@\n+    private NullMarker expectedNullness = NullMarker.UNSPECIFIED;\n+\n@@ -447,0 +476,4 @@\n+        return translate(tree, pt, NullMarker.UNSPECIFIED);\n+    }\n+\n+    public <T extends JCTree> T translate(T tree, Type pt, NullMarker expectedNullness) {\n@@ -448,0 +481,1 @@\n+        NullMarker prevExpectedNullness = this.expectedNullness;\n@@ -450,0 +484,1 @@\n+            this.expectedNullness = expectedNullness;\n@@ -453,0 +488,1 @@\n+            this.expectedNullness = prevExpectedNullness;\n@@ -459,0 +495,4 @@\n+        return translate(trees, pt, NullMarker.UNSPECIFIED);\n+    }\n+\n+    public <T extends JCTree> List<T> translate(List<T> trees, Type pt, NullMarker expectedNullness) {\n@@ -460,0 +500,1 @@\n+        NullMarker prevExpectedNullness = this.expectedNullness;\n@@ -463,0 +504,1 @@\n+            this.expectedNullness = expectedNullness;\n@@ -466,0 +508,1 @@\n+            this.expectedNullness = prevExpectedNullness;\n@@ -495,1 +538,1 @@\n-        tree.init = translate(tree.init, tree.sym.erasure(types));\n+        tree.init = translate(tree.init, tree.sym.erasure(types), tree.type.getNullMarker());\n@@ -852,0 +895,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -882,0 +926,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -912,0 +957,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -931,0 +977,2 @@\n+        List<NullMarker> paramsNullMarkers = meth.type.getParameterTypes().map(t->t.getNullMarker());\n+        NullMarker varargsElementNullMarker = tree.varargsElement != null ? tree.varargsElement.getNullMarker() : null;\n@@ -935,1 +983,3 @@\n-        if (meth.name == names.init && meth.owner == syms.enumSym)\n+        if (meth.name == names.init && meth.owner == syms.enumSym) {\n+            \/\/ this is special case code only for j.l.Enum constructor and will effectively\n+            \/\/ set the argtypes to an empty list making the invocation to translateArgs a no-op\n@@ -937,0 +987,1 @@\n+        }\n@@ -944,1 +995,1 @@\n-        tree.args = translateArgs(tree.args, argtypes, tree.varargsElement);\n+        tree.args = translateArgs(tree.args, argtypes, paramsNullMarkers, tree.varargsElement, varargsElementNullMarker);\n@@ -949,0 +1000,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -970,0 +1022,1 @@\n+        NullMarker varargsElementNullMarker = tree.varargsElement != null ? tree.varargsElement.getNullMarker() : null;\n@@ -973,1 +1026,1 @@\n-            tree.args, argtypes, tree.varargsElement);\n+            tree.args, argtypes, tree.constructor.type.getParameterTypes().map(t->t.getNullMarker()), tree.varargsElement, varargsElementNullMarker);\n@@ -995,1 +1048,1 @@\n-        tree.expr = translate(tree.expr, pt);\n+        tree.expr = translate(tree.expr, pt, expectedNullness);\n@@ -1001,0 +1054,3 @@\n+        if (types.isNonNullable(tree.lhs.type) && !types.isNonNullable(tree.rhs.type)) {\n+            tree.rhs = attr.makeNullCheck(tree.rhs);\n+        }\n@@ -1005,0 +1061,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1037,0 +1094,3 @@\n+        if (types.isNonNullable(tree.clazz.type) && !types.isNonNullable(tree.expr.type)) {\n+            tree.expr = attr.makeNullCheck(tree.expr);\n+        }\n@@ -1059,0 +1119,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1079,0 +1140,1 @@\n+        result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1101,0 +1163,1 @@\n+            result = generateNullCheckIfNeeded((JCExpression)result);\n@@ -1123,1 +1186,2 @@\n-            result = retype(tree, tree.sym.erasure(types), pt);\n+            result = generateNullCheckIfNeeded(tree);\n+            result = retype((JCExpression) result, tree.sym.erasure(types), pt);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":78,"deletions":14,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -43,0 +44,1 @@\n+import com.sun.tools.javac.jvm.Target;\n@@ -59,0 +61,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.BiFunction;\n@@ -70,0 +71,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -582,0 +584,1 @@\n+        NullMarker nm = NullMarker.UNSPECIFIED;\n@@ -592,0 +595,1 @@\n+                Type result;\n@@ -595,1 +599,7 @@\n-                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata());\n+                        result = new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata());\n+                    } else {\n+                        result = new ClassType(outer, List.nil(), t, List.nil());\n+                    }\n+                    if (nm != NullMarker.UNSPECIFIED) {\n+                        result = result.asNullMarked(nm);\n+                        nm = NullMarker.UNSPECIFIED;\n@@ -597,1 +607,1 @@\n-                    return new ClassType(outer, List.nil(), t, List.nil());\n+                    return result;\n@@ -602,1 +612,5 @@\n-\n+            case '?': case '!' : case '=': {\n+                char nmChar = (char) c;\n+                nm = (nmChar == '=' ? NullMarker.PARAMETRIC : NullMarker.of(String.valueOf(nmChar)));\n+                continue;\n+            }\n@@ -672,0 +686,6 @@\n+                char currentCh = (char)signature[sigp];\n+                if (currentCh == '?' || currentCh == '!' || currentCh == '=' ) {\n+                    nm = (currentCh == '=' ? NullMarker.PARAMETRIC : NullMarker.of(String.valueOf(currentCh)));\n+                    outer = outer.asNullMarked(nm);\n+                    sigp++;\n+                }\n@@ -693,1 +713,1 @@\n-                    throw new AssertionError(signature[sigp-1]);\n+                    throw new AssertionError((char)signature[sigp-1]);\n@@ -1351,0 +1371,30 @@\n+            new AttributeReader(names.ImplicitCreation, V66, CLASS_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (((ClassSymbol)sym).hasImplicitConstructor()) { \/\/ there can only be one per class\n+                        throw badClassFile(\"attribute.must.be.unique\", names.ImplicitCreation);\n+                    }\n+                    if (sym.kind == TYP) {\n+                        nextChar();\n+                        ((ClassSymbol)sym).implicitConstructorFound();\n+                    }\n+                }\n+            },\n+            new AttributeReader(names.NullRestricted, V66, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind != VAR) {\n+                        throw badClassFile(\"attribute.only.applicable.to.fields\", names.NullRestricted);\n+                    }\n+                    if (sym.type.isPrimitive() || sym.type.hasTag(TypeTag.ARRAY)) {\n+                        throw badClassFile(\"attribute.not.applicable.to.field.type\", names.NullRestricted, sym.type);\n+                    }\n+                    \/\/ there is no point on setting the nullness or not has it will be set while parsing the signature\n+                }\n+            },\n@@ -2672,0 +2722,11 @@\n+        if (names.isInit(name) && ((flags & STATIC) != 0)) {\n+            flags &= ~STATIC;\n+            type = new MethodType(type.getParameterTypes(),\n+                    syms.voidType,\n+                    type.getThrownTypes(),\n+                    syms.methodClass);\n+            if (((ClassSymbol)currentOwner).hasImplicitConstructor() && type.getParameterTypes().size() == 0) {\n+                \/\/ this has to be the implicit constructor\n+                flags |= IMPLICIT;\n+            }\n+        }\n@@ -3294,0 +3355,2 @@\n+        \/\/ we need to do some checks now that the class has been loaded\n+        checkNonCyclicMembership(c);\n@@ -3585,0 +3648,51 @@\n+\n+    \/\/ A value class cannot contain a non-nullable instance field of its own type either directly or indirectly.\n+    void checkNonCyclicMembership(ClassSymbol csym) {\n+        if (!allowValueClasses || !csym.type.hasImplicitConstructor()) {\n+            \/\/ nothing to see here\n+            return;\n+        }\n+        Assert.check((csym.flags_field & LOCKED) == 0);\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol field : csym.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(field);\n+            }\n+            csym.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            csym.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembershipHelper(ClassSymbol c) {\n+        \/*if ((c.flags_field & LOCKED) != 0) {\n+            JavaFileObject prevSource = log.useSource(currentClassFile);\n+            try {\n+                log.error(CompilerProperties.Errors.CyclicPrimitiveClassMembership(c));\n+                return;\n+            } finally {\n+                log.useSource(prevSource);\n+            }\n+        }\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(fld);\n+            }\n+            c.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }*\/\n+    }\n+    \/\/ where\n+    private boolean cyclePossible(VarSymbol symbol) {\n+        return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && types.isNonNullable(symbol.type);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":118,"deletions":4,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -84,0 +85,4 @@\n+    \/** Switch: are null-restricted types allowed\n+     *\/\n+    private boolean allowNullRestrictedTypes;\n+\n@@ -144,0 +149,2 @@\n+    private final Symtab syms;\n+\n@@ -179,0 +186,1 @@\n+        syms = Symtab.instance(context);\n@@ -194,0 +202,2 @@\n+        allowNullRestrictedTypes = (!preview.isPreview(Source.Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Source.Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -368,0 +378,1 @@\n+             nullMarkersScanner.visit(sym.type, null) ||\n@@ -378,0 +389,3 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeNullRestrictedIfNeeded(sym);\n+        }\n@@ -381,0 +395,47 @@\n+    NullMarkersScanner nullMarkersScanner = new NullMarkersScanner();\n+    \/* we don't need to scan generic \/ parameterized types as we will be generating a signature for them anyways\n+     *\/\n+    class NullMarkersScanner extends Types.SimpleVisitor<Boolean, Void> {\n+\n+        @Override\n+        public Boolean visitType(Type t, Void ignore) {\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitClassType(ClassType t, Void ignore) {\n+            if (!t.isParameterized()) {\n+                if (t.getNullMarker() != NullMarker.UNSPECIFIED) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Boolean visitArrayType(ArrayType t, Void ignore) {\n+            if (t.getNullMarker() != NullMarker.UNSPECIFIED) {\n+                return true;\n+            }\n+            return visit(t.elemtype, ignore);\n+        }\n+\n+        @Override\n+        public Boolean visitMethodType(MethodType t, Void ignore) {\n+            for (Type arg : t.argtypes) {\n+                if (visit(arg, ignore)) {\n+                    return true;\n+                }\n+            }\n+            for (Type param : t.allparams()) {\n+                if (visit(param, ignore)) {\n+                    return true;\n+                }\n+            }\n+            if (visit(t.restype, ignore)) {\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n@@ -962,0 +1023,27 @@\n+    \/** Write \"ImplicitCreation\" attribute.\n+     *\/\n+    int writeImplicitCreationIfNeeded(ClassSymbol csym) {\n+        if (allowNullRestrictedTypes && csym.isValueClass() && csym.hasImplicitConstructor()) {\n+            int alenIdx = writeAttr(names.ImplicitCreation);\n+            int flags = \/*ACC_DEFAULT |*\/ (csym.isSubClass(syms.looselyConsistentValueType.tsym, types) ? ACC_NON_ATOMIC : 0);\n+            databuf.appendChar(flags);\n+            endAttr(alenIdx);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    \/** Write \"NullRestricted\" attribute.\n+     *\/\n+    int writeNullRestrictedIfNeeded(Symbol sym) {\n+        if (allowNullRestrictedTypes && sym.kind == VAR && types.isNonNullable(sym.type) && !sym.type.hasTag(ARRAY)) {\n+            int alenIdx = writeAttr(names.NullRestricted);\n+            endAttr(alenIdx);\n+            if (preview.isPreview(Source.Feature.VALUE_CLASSES)) {\n+                preview.markUsesPreview(null);\n+            }\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n@@ -1316,0 +1404,4 @@\n+                if (debugstackmap) System.out.print(\"object(\" + types.erasure(t).tsym + \")\");\n+                databuf.appendByte(7);\n+                databuf.appendChar(poolWriter.putClass(types.erasure(t)));\n+                break;\n@@ -1789,0 +1881,4 @@\n+        if (target.hasValueClasses()) {\n+            acount += writeImplicitCreationIfNeeded(c);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    private static final Object[] NO_STATIC_ARGS = new Object[0];\n@@ -437,0 +438,2 @@\n+        \/\/ initializers for non-nullable fields of non-value classes\n+        ListBuffer<JCStatement> initCodeNonNullableFields = new ListBuffer<>();\n@@ -474,1 +477,5 @@\n-                        initCode.append(init);\n+                        if (!vdef.sym.owner.isValueClass() && types.isNonNullable(vdef.sym.type)) {\n+                            initCodeNonNullableFields.append(init);\n+                        } else {\n+                            initCode.append(init);\n+                        }\n@@ -499,1 +506,1 @@\n-        if (initCode.length() != 0 || initBlocks.length() != 0) {\n+        if (initCode.length() != 0 || initCodeNonNullableFields.length() != 0 || initBlocks.length() != 0) {\n@@ -503,1 +510,1 @@\n-                normalizeMethod((JCMethodDecl)t, initCode.toList(), initBlocks.toList(), initTAlist);\n+                normalizeMethod((JCMethodDecl)t, initCode.toList(), initCodeNonNullableFields.toList(), initBlocks.toList(), initTAlist);\n@@ -566,1 +573,1 @@\n-    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<JCStatement> initBlocks,  List<TypeCompound> initTAs) {\n+    void normalizeMethod(JCMethodDecl md, List<JCStatement> initCode, List<JCStatement> initCodeNonNullableFields, List<JCStatement> initBlocks, List<TypeCompound> initTAs) {\n@@ -589,0 +596,3 @@\n+            } else if (!initCodeNonNullableFields.isEmpty()) {\n+                rewriteInitializersIfNeeded(md, initCodeNonNullableFields);\n+                TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCodeNonNullableFields.append(supercall).appendList(initCode)));\n@@ -1123,0 +1133,2 @@\n+                selfType = selfType.hasImplicitConstructor() ?\n+                        selfType.addMetadata(new TypeMetadata.NullMarker(JCNullableTypeExpression.NullMarker.NOT_NULL)) : selfType;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-            return putName(typeSig(s.type));\n+            return putName(typeSig(s.type, true));\n@@ -305,0 +305,9 @@\n+            assembleSig(type, false);\n+        }\n+\n+        \/**\n+         * Assemble signature of given type in string buffer.\n+         * Check for uninitialized types before calling the general case.\n+         *\/\n+        @Override\n+        public void assembleSig(Type type, boolean includeNullMarkers) {\n@@ -310,1 +319,1 @@\n-                    assembleSig(types.erasure(((UninitializedType)type).qtype));\n+                    assembleSig(types.erasure(((UninitializedType)type).qtype), includeNullMarkers);\n@@ -313,1 +322,1 @@\n-                    super.assembleSig(type);\n+                    super.assembleSig(type, includeNullMarkers);\n@@ -510,0 +519,4 @@\n+        return typeSig(type, false);\n+    }\n+\n+    private Name typeSig(Type type, boolean includeNullMarkers) {\n@@ -511,1 +524,1 @@\n-        signatureGen.assembleSig(type);\n+        signatureGen.assembleSig(type, includeNullMarkers);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolWriter.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -207,0 +208,2 @@\n+        this.allowNullRestrictedTypes = (!preview.isPreview(Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -233,0 +236,2 @@\n+        this.allowNullRestrictedTypes = (!preview.isPreview(Feature.NULL_RESTRICTED_TYPES) || preview.isEnabled()) &&\n+                Feature.NULL_RESTRICTED_TYPES.allowedInSource(source);\n@@ -279,0 +284,4 @@\n+    \/** Switch: are null-restricted types allowed?\n+     *\/\n+    boolean allowNullRestrictedTypes;\n+\n@@ -289,0 +298,1 @@\n+     *     mode |= NOQUES     : nullable types are not allowed\n@@ -296,0 +306,1 @@\n+    protected static final int NOQUES        = 1 << 6;\n@@ -314,1 +325,1 @@\n-        setMode((mode & NOLAMBDA) | EXPR);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | EXPR);\n@@ -318,1 +329,1 @@\n-        setMode((mode & NOLAMBDA) | TYPE);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | TYPE);\n@@ -1271,1 +1282,12 @@\n-                    JCExpression type = unannotatedType(false);\n+                    JCExpression type = unannotatedType(false, NOQUES | TYPE);\n+                    if (allowNullRestrictedTypes && token.kind == QUES) {\n+                        if (peekToken(IDENTIFIER, COMMA) || peekToken(IDENTIFIER, SEMI) ||\n+                                peekToken(IDENTIFIER, RPAREN) || peekToken(IDENTIFIER, INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        } else if (peekToken(COMMA) || peekToken(SEMI) ||\n+                                peekToken(RPAREN) || peekToken(QUES) || peekToken(INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        }\n+                    }\n@@ -1596,0 +1618,5 @@\n+                if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && (peekToken(LBRACKET) || peekToken(LT))) {\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                }\n@@ -1610,0 +1637,5 @@\n+                            Token nullMarker = null;\n+                            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                                nullMarker = token;\n+                                nextToken();\n+                            }\n@@ -1612,0 +1644,3 @@\n+                            if (nullMarker != null) {\n+                                setNullMarker(t, nullMarker);\n+                            }\n@@ -1855,1 +1890,6 @@\n-            if (token.kind == LBRACKET) {\n+            if (allowNullRestrictedTypes && isMode(TYPE) && typeArgs == null && EMOTIONAL_QUALIFIER.test(token.kind) &&\n+                    (t instanceof JCIdent || t instanceof JCFieldAccess || t instanceof JCArrayTypeTree)) {\n+                setNullMarker(t);\n+                selectTypeMode();\n+                nextToken();\n+            } else if (token.kind == LBRACKET) {\n@@ -1864,0 +1904,4 @@\n+                        if (allowNullRestrictedTypes && isMode(TYPE) && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                            setNullMarker(t);\n+                            nextToken();\n+                        }\n@@ -1942,0 +1986,17 @@\n+    void setNullMarker(JCExpression exp) {\n+        setNullMarker(exp, token);\n+    }\n+\n+    void setNullMarker(JCExpression exp, Token tk) {\n+        checkSourceLevel(Feature.NULL_RESTRICTED_TYPES);\n+        ((JCNullableTypeExpression)exp).setNullMarker(nullMarker(tk));\n+    }\n+\n+    NullMarker nullMarker(Token tk) {\n+        return tk.kind == QUES ?\n+                NullMarker.NULLABLE :\n+                tk.kind == BANG ?\n+                        NullMarker.NOT_NULL :\n+                        NullMarker.PARAMETRIC;\n+    }\n+\n@@ -2006,1 +2067,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n+    @SuppressWarnings({\"fallthrough\", \"unchecked\"})\n@@ -2074,0 +2135,15 @@\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, RPAREN, ARROW))) {\n+                        \/\/ Identifier, '!'\/'?', Identifier\/'_'\/'assert'\/'enum', ','\/')' -> explicit lambda\n+                        return ParensResult.EXPLICIT_LAMBDA;\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) {\n+                        \/\/ this must be a cast with emotional type\n+                        return ParensResult.CAST;\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LBRACKET)) ) {\n+                        \/\/ Identifier, '!'\/'?', '<'\/','\/'>' or\n+                        \/\/ Identifier, '!'\/'?', '[' -> it's a type, skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -2096,0 +2172,1 @@\n+                            (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER, RPAREN)) ||\n@@ -2098,0 +2175,1 @@\n+                        \/\/ '[', ']', '!', ')' -> cast\n@@ -2100,0 +2178,6 @@\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER)) {\n+                        \/\/consume the ']' and the '!' and skip\n+                        type = true;\n+                        lookahead++;\n+                        lookahead++;\n+                        break;\n@@ -2118,0 +2202,1 @@\n+                                (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) ||\n@@ -2177,0 +2262,4 @@\n+    protected Predicate<TokenKind> EMOTIONAL_QUALIFIER = t -> t == BANG || (t == QUES && !isMode(NOQUES)) || t == STAR;\n+    protected Predicate<TokenKind> GENERIC_TYPE_END = t -> t == GT || t == GTGT || t == GTGTGT;\n+    protected Predicate<TokenKind> INSTANCEOF_INFIX = t -> t == AMPAMP || t == BARBAR ||\n+                                                           t == EQEQ || t == BANGEQ;\n@@ -2540,0 +2629,5 @@\n+        Token nullMarker = null;\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            nullMarker = token;\n+            nextToken();\n+        }\n@@ -2542,0 +2636,3 @@\n+        if (nullMarker != null) {\n+            setNullMarker(t, nullMarker);\n+        }\n@@ -2639,0 +2736,4 @@\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            setNullMarker(t);\n+            nextToken();\n+        }\n@@ -2658,0 +2759,5 @@\n+            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                setNullMarker(t);\n+                nextToken();\n+            }\n+\n@@ -2754,0 +2860,1 @@\n+            ListBuffer<NullMarker> nullMarkers = new ListBuffer<>();\n@@ -2761,0 +2868,6 @@\n+            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                nullMarkers.add(nullMarker(token));\n+                nextToken();\n+            } else {\n+                nullMarkers.add(NullMarker.UNSPECIFIED);\n+            }\n@@ -2762,1 +2875,2 @@\n-                    || token.kind == MONKEYS_AT) {\n+                    || token.kind == MONKEYS_AT ||\n+                    (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind))) {\n@@ -2766,1 +2880,6 @@\n-                if (token.kind == RBRACKET) { \/\/ no dimension\n+                if (token.kind == RBRACKET) {\n+                    Token nullMarker = null;\n+                    if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                        nullMarker = token;\n+                        nextToken();\n+                    }\n@@ -2768,0 +2887,3 @@\n+                    if (nullMarker != null) {\n+                        setNullMarker(elemtype, nullMarker);\n+                    }\n@@ -2772,0 +2894,6 @@\n+                    if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                        nullMarkers.add(nullMarker(token));\n+                        nextToken();\n+                    } else {\n+                        nullMarkers.add(NullMarker.UNSPECIFIED);\n+                    }\n@@ -2782,1 +2910,1 @@\n-            JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));\n+            JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems, nullMarkers.toList()));\n@@ -2785,0 +2913,2 @@\n+            Assert.check(dims.length() == nullMarkers.length(), na);\n+\n@@ -3459,0 +3589,13 @@\n+                    } else if (typeDepth == 0 && allowNullRestrictedTypes &&\n+                            ((peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, ARROW) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COLON))) ) {\n+                        \/\/ this is a type test pattern\n+                        return PatternResult.PATTERN;\n+                    } else if ( allowNullRestrictedTypes &&\n+                            (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA)) ) {\n+                        \/\/ this is a type - skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -3473,0 +3616,2 @@\n+                case BANG:\n+                    if (allowNullRestrictedTypes && !peekToken(lookahead, LPAREN)) break;\n@@ -3659,0 +3804,4 @@\n+                if (isImplicitModifier()) {\n+                    flag = Flags.IMPLICIT;\n+                    break;\n+                }\n@@ -3929,0 +4078,7 @@\n+        if (name == names.implicit) {\n+            if (allowValueClasses) {\n+                return Source.JDK23;\n+            } else if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n@@ -5076,0 +5232,19 @@\n+    protected boolean isImplicitModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.implicit) {\n+            boolean isImplicitModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case MONKEYS_AT:\n+                case STATIC: case FINAL: case ABSTRACT: case NATIVE:\n+                case SYNCHRONIZED: case STRICTFP: case DEFAULT: case IDENTIFIER:\n+                    isImplicitModifier = true;\n+                    break;\n+            }\n+            if (isImplicitModifier) {\n+                checkSourceLevel(Feature.VALUE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":183,"deletions":8,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -3427,0 +3427,3 @@\n+compiler.misc.feature.null.restricted.types=\\\n+    nullable and null restricted types\n+\n@@ -4319,0 +4322,29 @@\n+# 0: symbol\n+compiler.err.value.class.with.implicit.cannot.be.inner=\\\n+    The value class {0} declares an implicit constructor. It cannot be an inner class.\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.declares.init.block=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    It cannot declare one or more non-empty instance initializer blocks\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.instance.field.initializer=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    And it defines an instance field with an initializer. This is disallowed.\n+\n+compiler.err.implicit.const.cant.have.body=\\\n+    implicit constructors cannot have a body\n+\n+compiler.err.implicit.const.must.be.public=\\\n+    implicit constructors must be public\n+\n+compiler.err.implicit.const.must.be.declared.in.value.class=\\\n+    only value classes can declare implicit constructors\n+\n+# 0: symbol\n+compiler.err.cant.implement.interface=\\\n+    class {0} cannot implement LooselyConsistentValue interface. Concrete classes implementing this interface must:\\n\\\n+     be value classes and declare an implicit constructor.\n+\n+\n@@ -4362,0 +4394,55 @@\n+\n+### null-restricted types\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    it must be a value class with an implicit constructor\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted.2=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    its element type must be a value class with an implicit constructor\n+\n+compiler.err.non.nullable.should.be.initialized=\\\n+    field of non-nullable type should be initialized\n+\n+# 0: name\n+compiler.misc.attribute.must.be.unique=\\\n+    attribute {0} must be unique\n+\n+# 0: name\n+compiler.misc.attribute.only.applicable.to.fields=\\\n+    attribute {0} is only applicable to fields\n+\n+# 0: name, 1: type\n+compiler.misc.attribute.not.applicable.to.field.type=\\\n+    attribute {0} is not applicable to {1}\n+\n+# lint: null\n+compiler.warn.narrowing.nullness.conversion=\\\n+    narrowing nullness conversion\n+\n+# lint: null\n+compiler.warn.unchecked.nullness.conversion=\\\n+    unchecked nullness conversion\n+\n+# lint: null\n+compiler.warn.parametric.should.be.initialized=\\\n+    field of parametric type should be initialized\n+\n+# lint: null\n+compiler.warn.accessing.member.of.nullable=\\\n+    accessing member of nullable type\n+\n+# lint: null\n+compiler.warn.accessing.member.of.parametric=\\\n+    accessing member of parametric type\n+\n+# lint: null\n+compiler.warn.overrides.with.different.nullness.1=\\\n+    overriding method''s return type does not match nullness of overridden method\n+\n+# lint: null\n+compiler.warn.overrides.with.different.nullness.2=\\\n+    overriding method''s parameter(s) type(s) do not match nullness of overridden method\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":87,"deletions":0,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -248,0 +248,3 @@\n+javac.opt.Xlint.desc.null=\\\n+    Warn about operations on null-restricted and nullable types.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -1975,0 +1976,1 @@\n+        public List<NullMarker> nullMarkers;\n@@ -1977,2 +1979,3 @@\n-                           List<JCExpression> dims,\n-                           List<JCExpression> elems)\n+                             List<JCExpression> dims,\n+                             List<JCExpression> elems,\n+                             List<NullMarker> nullMarkers)\n@@ -1984,0 +1987,1 @@\n+            this.nullMarkers = nullMarkers;\n@@ -2579,1 +2583,1 @@\n-    public static class JCFieldAccess extends JCExpression implements MemberSelectTree {\n+    public static class JCFieldAccess extends JCNullableTypeExpression implements MemberSelectTree {\n@@ -2716,1 +2720,1 @@\n-    public static class JCIdent extends JCExpression implements IdentifierTree {\n+    public static class JCIdent extends JCNullableTypeExpression implements IdentifierTree {\n@@ -2825,1 +2829,1 @@\n-    public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {\n+    public static class JCArrayTypeTree extends JCNullableTypeExpression implements ArrayTypeTree {\n@@ -2850,1 +2854,1 @@\n-    public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {\n+    public static class JCTypeApply extends JCNullableTypeExpression implements ParameterizedTypeTree {\n@@ -2908,0 +2912,45 @@\n+    \/**\n+     * A nullable type expression. Supported nullable expression types are: simple type names,\n+     * qualified type names, parameterized types and array types.\n+     *\/\n+\n+    public static abstract class JCNullableTypeExpression extends JCExpression {\n+        private NullMarker nullMarker = NullMarker.UNSPECIFIED;\n+\n+        public NullMarker getNullMarker() {\n+            return nullMarker;\n+        }\n+\n+        public JCNullableTypeExpression setNullMarker(NullMarker nullMarker) {\n+            this.nullMarker = nullMarker;\n+            return this;\n+        }\n+\n+        public enum NullMarker {\n+            NOT_NULL(\"!\"),\n+            NULLABLE(\"?\"),\n+            PARAMETRIC(\"*\"),\n+            UNSPECIFIED(\"\");\n+\n+            private final String typeSuffix;\n+\n+            NullMarker(String typeSuffix) {\n+                this.typeSuffix = typeSuffix;\n+            }\n+\n+            public String typeSuffix() {\n+                return typeSuffix;\n+            }\n+\n+            public static NullMarker of(String typeSuffix) {\n+                return switch (typeSuffix) {\n+                    case \"!\" -> NOT_NULL;\n+                    case \"?\" -> NULLABLE;\n+                    case \"*\" -> PARAMETRIC;\n+                    case \"\" -> UNSPECIFIED;\n+                    default -> throw new AssertionError(\"invalid type suffix \" + typeSuffix);\n+                };\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":55,"deletions":6,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+                if (!(tree instanceof JCArrayTypeTree) &&\n+                        tree instanceof JCNullableTypeExpression nullableType) {\n+                    print(nullableType.getNullMarker().typeSuffix());\n+                }\n@@ -1561,0 +1565,1 @@\n+                print(((JCArrayTypeTree)elem).getNullMarker().typeSuffix());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -327,1 +327,2 @@\n-        return M.at(t.pos).NewArray(elemtype, dims, elems);\n+        return M.at(t.pos).NewArray(elemtype, dims, elems,\n+                ((JCNewArray)node).nullMarkers);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -114,0 +114,6 @@\n+    public static JCMethodDecl getImplicitConstructor(List<JCTree> trees) {\n+        for (List<JCTree> l = trees; l.nonEmpty(); l = l.tail)\n+            if (isConstructor(l.head) && (((JCMethodDecl)l.head).mods.flags & IMPLICIT) != 0) return (JCMethodDecl) l.head;\n+        return null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -437,0 +438,9 @@\n+    public JCNewArray NewArray(JCExpression elemtype,\n+                               List<JCExpression> dims,\n+                               List<JCExpression> elems)\n+    {\n+        JCNewArray tree = new JCNewArray(elemtype, dims, elems, List.nil());\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n@@ -439,1 +449,2 @@\n-                             List<JCExpression> elems)\n+                             List<JCExpression> elems,\n+                             List<NullMarker> nullMarkers)\n@@ -441,1 +452,1 @@\n-        JCNewArray tree = new JCNewArray(elemtype, dims, elems);\n+        JCNewArray tree = new JCNewArray(elemtype, dims, elems, nullMarkers);\n@@ -891,1 +902,5 @@\n-        return tp.setType(t);\n+        tp.setType(t);\n+        TypeMetadata.NullMarker nm = t.getMetadata(TypeMetadata.NullMarker.class);\n+        return (nm != null && nm.nullMarker() != NullMarker.UNSPECIFIED && tp instanceof JCNullableTypeExpression) ?\n+            ((JCNullableTypeExpression)tp).setNullMarker(t.getMetadata(TypeMetadata.NullMarker.class).nullMarker()) :\n+            tp;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -173,0 +173,2 @@\n+    public final Name ImplicitCreation;\n+    public final Name NullRestricted;\n@@ -240,0 +242,5 @@\n+    \/\/ value classes\n+    public final Name implicit;\n+    public final Name newInstance;\n+    public final Name asNullRestrictedType;\n+\n@@ -371,0 +378,2 @@\n+        ImplicitCreation = fromString(\"ImplicitCreation\");\n+        NullRestricted = fromString(\"NullRestricted\");\n@@ -431,0 +440,5 @@\n+\n+        \/\/value classes\n+        implicit = fromString(\"implicit\");\n+        newInstance = fromString(\"newInstance\");\n+        asNullRestrictedType = fromString(\"asNullRestrictedType\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -83,0 +83,5 @@\n+    public void remove(LintCategory lint) {\n+        nonSilentLintSet.remove(lint);\n+        silentLintSet.remove(lint);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Warner.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -288,0 +288,6 @@\n+                void addValue(TypeElement e) {\n+                    if (e.getModifiers().contains(Modifier.VALUE)) {\n+                        list.add(\"value\");\n+                    }\n+                }\n+\n@@ -299,0 +305,1 @@\n+                    addValue(e);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,420 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class ArrayCreationInvoker version 67:0 {\n+\n+    const #1 = Dynamic REF_invokeStatic:java\/lang\/invoke\/ConstantBootstraps.primitiveClass\n+                   :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Class;\"\n+                   :I:\"Ljava\/lang\/Class;\";\n+\n+    public static Method constantFilled3S:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method constantFilled3I:\"()[I\" stack 1 {\n+         invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[I\"\n+                #1, int 0, int 3, int 3;\n+         areturn;\n+     }\n+\n+    public static Method constantFilled0S:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method constantFilled0I:\"()[I\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[I\"\n+                #1, int 0, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method constantFilledNS:\"(I)[Ljava\/lang\/String;\" stack 1 {\n+        iload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1, String \"c\";\n+        areturn;\n+    }\n+\n+    public static Method constantFilledNI:\"(I)[I\" stack 1 {\n+        iload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;IILjava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I)[I\"\n+                #1, int 0, int -1, int 3;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled3S:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled3I:\"(I)[I\" stack 1 {\n+        iload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I)[I\"\n+                #1, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled0S:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilled0I:\"(I)[I\" stack 1 {\n+        iload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I)[I\"\n+                #1, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilledNS:\"(ILjava\/lang\/String;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(ILjava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method dynamicFilledNI:\"(II)[I\" stack 2 {\n+        iload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicFilled\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(II)[I\"\n+                #1, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method computed3S:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method computed3I:\"(Ljava\/util\/function\/IntFunction;)[I\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[I\"\n+                #1, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method computed0S:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method computed0I:\"(Ljava\/util\/function\/IntFunction;)[I\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/util\/function\/IntFunction;)[I\"\n+                #1, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method computedNS:\"(ILjava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(ILjava\/util\/function\/IntFunction;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method computedNI:\"(ILjava\/util\/function\/IntFunction;)[I\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.computed\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(ILjava\/util\/function\/IntFunction;)[I\"\n+                #1, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method copied3S:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method copied3I:\"([I)[I\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([I)[I\"\n+                #1, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method copied0S:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method copied0I:\"([I)[I\" stack 1 {\n+        aload_0;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([I)[I\"\n+                #1, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method copiedNS:\"(I[Ljava\/lang\/Object;)[Ljava\/lang\/String;\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[Ljava\/lang\/Object;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method copiedNI:\"(I[I)[I\" stack 2 {\n+        iload_0;\n+        aload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.copied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[I)[I\"\n+                #1, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied3S:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied3I:\"([II)[I\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([II)[I\"\n+                #1, int 0, int 3;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied0S:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopied0I:\"([II)[I\" stack 2 {\n+        aload_0;\n+        iload_1;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"([II)[I\"\n+                #1, int 0, int 0;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopiedNS:\"(I[Ljava\/lang\/Object;I)[Ljava\/lang\/String;\" stack 3 {\n+        iload_0;\n+        aload_1;\n+        iload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[Ljava\/lang\/Object;I)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method offsetCopiedNI:\"(I[II)[I\" stack 3 {\n+        iload_0;\n+        aload_1;\n+        iload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.offsetCopied\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;II)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(I[II)[I\"\n+                #1, int 0, int -1;\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated3S:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0, String \"c1\", String \"c2\", String \"c3\";\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated3I:\"()[I\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[I\"\n+                #1, int 0, int 30, int 40, int 50;\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated0S:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0;\n+        areturn;\n+    }\n+\n+    public static Method constantEnumerated0I:\"()[I\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.constantEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[I\"\n+                #1, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated3S\n+            :\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+            stack 3 {\n+        aload_0;\n+        aload_1;\n+        aload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated3I:\"(III)[I\" stack 3 {\n+        iload_0;\n+        iload_1;\n+        iload_2;\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"(III)[I\"\n+                #1, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated0S:\"()[Ljava\/lang\/String;\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[Ljava\/lang\/String;\"\n+                class java\/lang\/String, int 0;\n+        areturn;\n+    }\n+\n+    public static Method dynamicEnumerated0I:\"()[I\" stack 1 {\n+        invokedynamic\n+            InvokeDynamic REF_invokeStatic:java\/lang\/runtime\/ArrayCreation.dynamicEnumerated\n+                :\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/reflect\/RuntimeType;I)Ljava\/lang\/invoke\/CallSite;\"\n+                :_:\"()[I\"\n+                #1, int 0;\n+        areturn;\n+    }\n+\n+ }\n","filename":"test\/jdk\/java\/lang\/runtime\/ArrayCreationInvoker.jasm","additions":420,"deletions":0,"binary":false,"changes":420,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @summary invokedynamic usage of java.lang.runtime.ArrayCreation bootstraps\n+ * @compile ArrayCreationInvoker.jasm\n+ * @run main ArrayCreationTest\n+ *\/\n+public class ArrayCreationTest {\n+\n+    public static void main(String... args) {\n+\n+        checkArray(ArrayCreationInvoker.constantFilled3S(),\n+                   new String[]{ \"c\", \"c\", \"c\" });\n+        checkArray(ArrayCreationInvoker.constantFilled3I(),\n+                   new int[]{ 3, 3, 3 });\n+        checkArray(ArrayCreationInvoker.constantFilled0S(),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.constantFilled0I(),\n+                   new int[]{ });\n+        checkArray(ArrayCreationInvoker.constantFilledNS(5),\n+                   new String[]{ \"c\", \"c\", \"c\", \"c\", \"c\" });\n+        checkArray(ArrayCreationInvoker.constantFilledNS(0),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.constantFilledNI(5),\n+                   new int[]{ 3, 3, 3, 3, 3 });\n+        checkArray(ArrayCreationInvoker.constantFilledNI(0),\n+                   new int[]{ });\n+\n+        checkArray(ArrayCreationInvoker.dynamicFilled3S(\"hi\"),\n+                   new String[]{ \"hi\", \"hi\", \"hi\" });\n+        checkArray(ArrayCreationInvoker.dynamicFilled3I(23),\n+                   new int[]{ 23, 23, 23 });\n+        checkArray(ArrayCreationInvoker.dynamicFilled0S(\"hi\"),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.dynamicFilled0I(23),\n+                   new int[]{ });\n+        checkArray(ArrayCreationInvoker.dynamicFilledNS(2, \"hi\"),\n+                   new String[]{ \"hi\", \"hi\" });\n+        checkArray(ArrayCreationInvoker.dynamicFilledNS(0, \"hi\"),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.dynamicFilledNI(2, 23),\n+                   new int[]{ 23, 23 });\n+        checkArray(ArrayCreationInvoker.dynamicFilledNI(0, 23),\n+                   new int[]{ });\n+\n+        checkArray(ArrayCreationInvoker.computed3S(i -> \"x\"+i),\n+                   new String[]{ \"x0\", \"x1\", \"x2\" });\n+        checkArray(ArrayCreationInvoker.computed3I(i -> i+5),\n+                   new int[]{ 5, 6, 7 });\n+        checkArray(ArrayCreationInvoker.computed0S(i -> \"y\"+i),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.computed0I(i -> i+6),\n+                   new int[]{ });\n+        checkArray(ArrayCreationInvoker.computedNS(5, i -> \"z\"+i),\n+                   new String[]{ \"z0\", \"z1\", \"z2\", \"z3\", \"z4\" });\n+        checkArray(ArrayCreationInvoker.computedNS(0, i -> \"w\"+i),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.computedNI(5, i -> i+7),\n+                   new int[]{ 7, 8, 9, 10, 11 });\n+        checkArray(ArrayCreationInvoker.computedNI(0, i -> i+8),\n+                   new int[]{ });\n+\n+        Object[] srcS = new Object[]{ \"a\", \"b\", \"c\", \"d\", \"e\" };\n+        int[] srcI = new int[]{ 1, 2, 3, 4, 5 };\n+\n+        checkArray(ArrayCreationInvoker.copied3S(srcS),\n+                   new String[]{ \"a\", \"b\", \"c\" });\n+        checkArray(ArrayCreationInvoker.copied3I(srcI),\n+                   new int[]{ 1, 2, 3 });\n+        checkArray(ArrayCreationInvoker.copied0S(srcS),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.copied0I(srcI),\n+                   new int[]{ });\n+        checkArray(ArrayCreationInvoker.copiedNS(4, srcS),\n+                   new String[]{ \"a\", \"b\", \"c\", \"d\" });\n+        checkArray(ArrayCreationInvoker.copiedNS(0, srcS),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.copiedNI(4, srcI),\n+                   new int[]{ 1, 2, 3, 4 });\n+        checkArray(ArrayCreationInvoker.copiedNI(0, srcI),\n+                   new int[]{ });\n+\n+        checkArray(ArrayCreationInvoker.offsetCopied3S(srcS, 0),\n+                   new String[]{ \"a\", \"b\", \"c\" });\n+        checkArray(ArrayCreationInvoker.offsetCopied3S(srcS, 2),\n+                   new String[]{ \"c\", \"d\", \"e\" });\n+        checkArray(ArrayCreationInvoker.offsetCopied3I(srcI, 0),\n+                   new int[]{ 1, 2, 3 });\n+        checkArray(ArrayCreationInvoker.offsetCopied3I(srcI, 2),\n+                   new int[]{ 3, 4, 5 });\n+        checkArray(ArrayCreationInvoker.offsetCopied0S(srcS, 0),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.offsetCopied0S(srcS, 2),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.offsetCopied0I(srcI, 0),\n+                   new int[]{ });\n+        checkArray(ArrayCreationInvoker.offsetCopied0I(srcI, 2),\n+                   new int[]{ });\n+        checkArray(ArrayCreationInvoker.offsetCopiedNS(4, srcS, 1),\n+                   new String[]{ \"b\", \"c\", \"d\", \"e\" });\n+        checkArray(ArrayCreationInvoker.offsetCopiedNS(0, srcS, 4),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.offsetCopiedNI(4, srcI, 1),\n+                   new int[]{ 2, 3, 4, 5 });\n+        checkArray(ArrayCreationInvoker.offsetCopiedNI(0, srcI, 4),\n+                   new int[]{ });\n+\n+        checkArray(ArrayCreationInvoker.constantEnumerated3S(),\n+                   new String[]{ \"c1\", \"c2\", \"c3\" });\n+        checkArray(ArrayCreationInvoker.constantEnumerated3I(),\n+                   new int[]{ 30, 40, 50 });\n+        checkArray(ArrayCreationInvoker.constantEnumerated0S(),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.constantEnumerated0I(),\n+                   new int[]{ });\n+\n+        checkArray(ArrayCreationInvoker.dynamicEnumerated3S(\"x\", \"y\", \"z\"),\n+                   new String[]{ \"x\", \"y\", \"z\" });\n+        checkArray(ArrayCreationInvoker.dynamicEnumerated3I(-12, 0, 583),\n+                   new int[]{ -12, 0, 583 });\n+        checkArray(ArrayCreationInvoker.dynamicEnumerated0S(),\n+                   new String[]{ });\n+        checkArray(ArrayCreationInvoker.dynamicEnumerated0I(),\n+                   new int[]{ });\n+    }\n+\n+    private static void checkArray(Object[] arr, Object[] expected) {\n+        if (!arr.getClass().equals(expected.getClass()) || !Arrays.equals(arr, expected)) {\n+            throw new AssertionError(\"Unexpected result: %s, expected %s\".formatted(\n+                                     Arrays.toString(arr), Arrays.toString(expected)));\n+        }\n+    }\n+\n+    private static void checkArray(int[] arr, int[] expected) {\n+        if (!Arrays.equals(arr, expected)) {\n+            throw new AssertionError(\"Unexpected result: %s, expected %s\".formatted(\n+                                     Arrays.toString(arr), Arrays.toString(expected)));\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/ArrayCreationTest.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -241,4 +241,2 @@\n-        checkOutput(\"pkg\/PrivateParent.html\", false,\n-                \"\"\"\n-                    <div class=\"type-signature\"><span class=\"modifiers\"> class <\/span><span class=\"el\\\n-                    ement-name type-name-label\">PrivateParent<\/span>\"\"\");\n+        checkOutput(\"pkg\/PrivateParent.html\", true,\n+                \"<div class=\\\"type-signature\\\"><span class=\\\"modifiers\\\">class <\/span><span class=\\\"element-name type-name-label\\\">PrivateParent<\/span>\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPrivateClasses\/TestPrivateClasses.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,0 +102,24 @@\n+\n+    @Test\n+    public void testImplicitConstModifiers(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                package p;\n+\n+                public value class ValueClassWithImplicitConst {\n+                    public implicit ValueClassWithImplicitConst();\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--enable-preview\", \"-source\", String.valueOf(Runtime.version().feature()),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/ValueClassWithImplicitConst.html\", true,\n+                \"\"\"\n+                <div class=\"member-signature\"><span class=\"modifiers\">public implicit<\/span>&nbsp;<span class=\"element-name\">ValueClassWithImplicitConst<\/span>()<\/div>\n+                \"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testValueClasses\/TestValueClasses.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+\n@@ -227,0 +228,10 @@\n+\n+#nullable types\n+compiler.misc.feature.null.restricted.types\n+compiler.warn.accessing.member.of.nullable\n+compiler.warn.narrowing.nullness.conversion\n+compiler.warn.accessing.member.of.parametric\n+compiler.warn.parametric.should.be.initialized\n+compiler.misc.attribute.must.be.unique                                   # bad class file\n+compiler.misc.attribute.not.applicable.to.field.type                     # bad class file\n+compiler.misc.attribute.only.applicable.to.fields                        # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.type.cant.be.null.restricted\n+\/\/ key: compiler.err.type.cant.be.null.restricted.2\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version} -XDallowNullRestrictedTypesForValueClassesOnly\n+\n+public class CantBeNonNullableType {\n+    String! s;\n+    String[]! sa;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantBeNonNullableType.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.cant.implement.interface\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class CantImplementInterface implements LooselyConsistentValue {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CantImplementInterface.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.implicit.const.cant.have.body\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+value class ImplicitConstructorWithBody {\n+    public implicit ImplicitConstructorWithBody() {}\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitConstructorWithBody.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.implicit.const.must.be.declared.in.value.class\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class ImplicitMustBeInValueClass {\n+    public implicit ImplicitMustBeInValueClass();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitMustBeInValueClass.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.implicit.const.must.be.public\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+value class ImplicitMustBePublic {\n+    implicit ImplicitMustBePublic();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ImplicitMustBePublic.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.non.nullable.should.be.initialized\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class NonNullableShouldBeInitialized {\n+    NonNullableShouldBeInitialized! field;\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NonNullableShouldBeInitialized.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.overrides.with.different.nullness.1\n+\/\/ key: compiler.warn.overrides.with.different.nullness.2\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:null\n+\n+class OverrideWithDifferentNullness {\n+    abstract class A {\n+        abstract String! lookup(String! arg);\n+    }\n+\n+    abstract class B extends A {\n+        abstract String? lookup(String? arg);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/OverrideWithDifferentNullness.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ReturnBeforeSuperclassInit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.unchecked.nullness.conversion\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:null\n+\n+class UncheckedNullnessConversion {\n+    void m(UncheckedNullnessConversion! s1, UncheckedNullnessConversion? s3) {\n+        s1 = s3;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UncheckedNullnessConversion.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.value.class.with.implicit.cannot.be.inner\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class ValueClassWithImplicitCannotBeInner {\n+    value class V {\n+        public implicit V();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueClassWithImplicitCannotBeInner.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.value.class.with.implicit.declares.init.block\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+value class ValueClassWithImplicitCantDeclareInitBlock {\n+    int i;\n+    {\n+        i = 0;\n+    }\n+    public implicit ValueClassWithImplicitCantDeclareInitBlock();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueClassWithImplicitCantDeclareInitBlock.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.value.class.with.implicit.instance.field.initializer\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+value class ValueClassWithImplicitCantHaveFieldInit {\n+    int i = 0;\n+    public implicit ValueClassWithImplicitCantHaveFieldInit ();\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ValueClassWithImplicitCantHaveFieldInit.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338766\n+ * @summary [lw5] remove option enableNullRestrictedTypes and make null-restricted types a preview feature\n+ * @library \/tools\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main NullRestrictedAttrTest\n+ * @ignore support for the NullRestricted attribute is missing in javap, class library etc\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.classfile.ClassFile;\n+\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+\n+public class NullRestrictedAttrTest extends TestRunner {\n+    ToolBox tb = new ToolBox();\n+\n+    public NullRestrictedAttrTest() {\n+        super(System.err);\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws Exception {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new NullRestrictedAttrTest().runTests();\n+    }\n+\n+    @Test\n+    public void testLoadableDescField(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                value class V {\n+                    public implicit V();\n+                }\n+                class Test {\n+                    V! v1;\n+                    void m(V! v) {\n+                        v1 = v;\n+                    }\n+                }\n+                \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        new toolbox.JavacTask(tb)\n+                .options(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature()))\n+                .outdir(classes)\n+                .files(findJavaFiles(src))\n+                .run()\n+                .writeAll();\n+        Path classFilePath = classes.resolve(\"Test.class\");\n+        ClassFile classFile = ClassFile.read(classFilePath.toFile());\n+        Assert.check(classFile.minor_version == 65535);\n+        Assert.check(classFile.attributes.get(\"NullRestricted\") != null);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictedAttrTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,973 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * NullabilityCompilationTests\n+ *\n+ * @test\n+ * @bug 8339357 8340027\n+ * @enablePreview\n+ * @summary compilation tests for bang types\n+ * @library \/lib\/combo \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @run junit NullabilityCompilationTests\n+ *\/\n+\n+import java.io.File;\n+import java.util.function.Consumer;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.tools.Diagnostic;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.reflect.AccessFlag;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.util.Assert;\n+\n+import org.junit.jupiter.api.Test;\n+import tools.javac.combo.CompilationTestCase;\n+\n+public class NullabilityCompilationTests extends CompilationTestCase {\n+    private static String[] PREVIEW_OPTIONS = {\n+            \"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())};\n+    private static String[] PREVIEW_PLUS_LINT_OPTIONS = {\n+            \"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature()),\n+            \"-Xlint:null\" };\n+\n+    public NullabilityCompilationTests() {\n+        setDefaultFilename(\"Test.java\");\n+    }\n+\n+    enum TestResult {\n+        COMPILE_OK,\n+        COMPILE_WITH_WARNING,\n+        ERROR\n+    }\n+\n+    void testHelper(String[] compilerOptions, String code) {\n+        testHelper(compilerOptions, \"\", 1, TestResult.COMPILE_OK, code, null);\n+    }\n+\n+    void testHelper(String[] compilerOptions, String code, Consumer<Diagnostic<?>> diagConsumer) {\n+        testHelper(compilerOptions, \"\", 1, TestResult.COMPILE_OK, code, diagConsumer);\n+    }\n+\n+    void testHelper(String[] compilerOptions, String diagsMessage, int diagsCount, TestResult testResult, String code,\n+                    Consumer<Diagnostic<?>> diagConsumer) {\n+        setCompileOptions(compilerOptions);\n+        try {\n+            if (testResult != TestResult.COMPILE_OK) {\n+                if (testResult == TestResult.COMPILE_WITH_WARNING) {\n+                    assertOKWithWarning(diagsMessage, diagsCount, code);\n+                } else {\n+                    assertFail(diagsMessage, code);\n+                }\n+            } else {\n+                if (diagConsumer == null) {\n+                    assertOK(code);\n+                } else {\n+                    assertOK(diagConsumer, code);\n+                }\n+            }\n+        } catch (Throwable t) {\n+            System.err.println(\"error while compiling code:\\n\" + code);\n+            throw t;\n+        }\n+    }\n+\n+    void testList(List<DiagAndCode> testList) {\n+        for (DiagAndCode diagAndCode : testList) {\n+            if (diagAndCode.result == Result.Clean) {\n+                testHelper(PREVIEW_PLUS_LINT_OPTIONS, diagAndCode.code);\n+            } else if (diagAndCode.result == Result.Warning) {\n+                testHelper(PREVIEW_PLUS_LINT_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.COMPILE_WITH_WARNING, diagAndCode.code, null);\n+                testHelper(PREVIEW_OPTIONS, diagAndCode.code,\n+                        d -> {\n+                            if (d.getKind() == Diagnostic.Kind.WARNING) {\n+                                \/\/ shouldn't issue any warnings if the -Xlint:null option is not passed\n+                                throw new AssertionError(\"unexpected warning for \" + diagAndCode.code);\n+                            }\n+                        });\n+            } else {\n+                testHelper(PREVIEW_OPTIONS, diagAndCode.diag, diagAndCode.diagsCount, TestResult.ERROR, diagAndCode.code, null);\n+            }\n+            if (diagAndCode.result != Result.Error) {\n+                testHelper(PREVIEW_OPTIONS, diagAndCode.code);\n+            }\n+        }\n+    }\n+\n+    enum Result { Warning, Error, Clean}\n+\n+    record DiagAndCode(String code, Result result, String diag, int diagsCount) {\n+        DiagAndCode(String code, Result result, String diag) {\n+            this(code, result, diag, 1);\n+        }\n+    }\n+\n+    @Test\n+    void testErrorNonNullableCantBeAssignedNull() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point! s = null;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    Foo! s = null;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[]! s = null;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    Foo[]! s = null;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    void m() {\n+                                        Supplier<? extends T> factory = nullFactory();\n+                                    }\n+                                    Supplier<? extends T!> nullFactory() { return () -> null; }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class MyList<T> {\n+                                    void add(T e) {}\n+                                }\n+                                class Test {\n+                                    void m(MyList<? super Point!> ls) {\n+                                        ls.add(null);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.prob.found.req\")\n+                )\n+        );\n+    }\n+\n+\n+    @Test\n+    void testErrorUninitialized() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    Foo! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    Foo[]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point![]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    Foo![]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point![]![]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    Foo![]![]! s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[]![] s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    Foo[]![] s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    Point[]![][] s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    Foo[]![][] s;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\")\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void testUncheckedNullnessConversions () {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    void m(Point! s1, Point? s3) {\n+                                        s1 = s3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo {\n+                                    void m(Object! s1, String s3) {\n+                                        s1 = s3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    void m(Point! s1, Point s3) {\n+                                        s3 = s1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo<T extends String!> {\n+                                    Foo<String?> f2;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo<T extends String!> {\n+                                    Foo<String> f2;\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo<T extends Object!> {\n+                                    Foo<String?> f2;\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Foo<T extends Object!> {\n+                                    Foo<String> f2;\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        \/\/ wildcards\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    void test(List<? extends Point!> ls1, List<? extends Point> ls3) {\n+                                        ls1 = ls3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                value class Point { public implicit Point(); }\n+                                class Foo {\n+                                    void test(List<? extends Point!> ls1, List<? extends Point?> ls3) {\n+                                        ls1 = ls3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends Object!> ls1, List<? extends String> ls3) {\n+                                        ls1 = ls3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends Object!> ls1, List<? extends String?> ls3) {\n+                                        ls1 = ls3;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static value class Atom {}\n+                                    static class Box<X> {}\n+                                    void test(Box<? extends Atom!> t1, Box<Atom> t2) {\n+                                        t1 = t2;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static value class Atom {}\n+                                    static class Box<X> {}\n+                                    void test(Box<? extends Atom!> t1, Box<Atom?> t2) {\n+                                        t1 = t2;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Wrapper<T> {}\n+                                class Test<T> {\n+                                    Wrapper<T> newWrapper() { return null; }\n+                                    void m() {\n+                                        Wrapper<T!> w = newWrapper();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Wrapper<T> {}\n+                                class Test<T> {\n+                                    Wrapper<T?> newWrapper() { return null; }\n+                                    void m() {\n+                                        Wrapper<T!> w = newWrapper();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String, String> f) {}\n+                                    void m(Function<String!, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String?, String> f) {}\n+                                    void m(Function<String!, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String!, String> f) {}\n+                                    void m(Function<String, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test {\n+                                    void plot(Function<String!, String> f) {}\n+                                    void m(Function<String?, String> gradient) {\n+                                        plot(gradient);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    void m() {\n+                                        Supplier<? extends T!> factory = nullFactory();\n+                                    }\n+                                    Supplier<? extends T> nullFactory() { return () -> null; }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Test<T> {\n+                                    Set<Map.Entry<String, T>> allEntries() { return null; }\n+                                    void m() {\n+                                        Set<Map.Entry<String, T!>> entries = allEntries();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.function.*;\n+                                class Test<T> {\n+                                    T field;\n+                                    void foo(Consumer<? super T!> action) {\n+                                        action.accept(field);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Test<T> {\n+                                    Set<Map.Entry<String, T!>> allEntries() { return null; }\n+                                    void m() {\n+                                        Set<Map.Entry<String, T>> entries = allEntries();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    class Box<X> {}\n+                                    static value class Point { public implicit Point(); }\n+                                    @SafeVarargs\n+                                    private <Z> Z make_box_uni(Z... bs) {\n+                                        return bs[0];\n+                                    }\n+                                    void test(Box<Point!> bref, Box<Point> bval) {\n+                                        Box<? extends Point!> res = make_box_uni(bref, bval);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    class Box<X> {}\n+                                    static value class Point { public implicit Point(); }\n+                                    @SafeVarargs\n+                                    private <Z> Z make_box_uni(Z... bs) {\n+                                        return bs[0];\n+                                    }\n+                                    void test(Box<Point!> bref, Box<Point?> bval) {\n+                                        Box<? extends Point!> res = make_box_uni(bref, bval);\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.unchecked.nullness.conversion\",\n+                                1),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends String!> ls1, List<? extends String> ls3) {\n+                                        ls3 = ls1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.util.*;\n+                                class Foo {\n+                                    void test(List<? extends String!> ls1, List<? extends Object> ls3) {\n+                                        ls3 = ls1;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void testNoWarnings() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                interface Shape {}\n+                                value class Point implements Shape { public implicit Point(); }\n+                                class Box<T> {}\n+                                class Test {\n+                                    void m(Box<Point!> lp) {\n+                                        foo(lp);\n+                                    }\n+                                    void foo(Box<? extends Shape> ls) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                interface Shape {}\n+                                value class Point implements Shape { public implicit Point(); }\n+                                class Box<T> {}\n+                                class Test {\n+                                    void m(Box<Shape> lp) {\n+                                        foo(lp);\n+                                    }\n+                                    void foo(Box<? super Point!> ls) {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class C<T> {\n+                                    T x = null;\n+                                    void m() {\n+                                        String r = new C<String>().x;\n+                                        Point p = new C<Point>().x;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class C<T> {\n+                                    T x = null;\n+                                    void set(T arg) { x = arg; }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point {}\n+                                class MyList<T> {\n+                                    static <E> MyList<E> of(E e1) {\n+                                        return null;\n+                                    }\n+                                }\n+                                class Test {\n+                                    void m() {\n+                                        MyList.of(new Point!());\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                class MyCollection<T> {}\n+                                class MyList<T> extends MyCollection<T!> {\n+                                    static <E> MyList<E> of(E e1) {\n+                                        return null;\n+                                    }\n+                                }\n+                                class Test {\n+                                    void m() {\n+                                        MyCollection<Point> mpc = MyList.of(new Point!());\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test<T> {\n+                                    T field;\n+                                    void foo(T t) {\n+                                        field = t;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        \/\/ we are testing that the compiler won't infer the arguments of\n+                                        \/\/ VarHandle::setVolatile as (Cell, String!)\n+                                        VALUE.setVolatile(this, \"\");\n+                                    }\n+                                    final void reset(String identity) {\n+                                        \/\/ if that were the case, see comment above, then this invocation would generate\n+                                        \/\/ a warning, VarHandle::setVolatile is a polymorphic signature method\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+\n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                import java.lang.invoke.*;\n+                                class Cell {\n+                                    final void reset() {\n+                                        VALUE.setVolatile(this, 0L);\n+                                    }\n+                                    final void reset(long identity) {\n+                                        VALUE.setVolatile(this, identity);\n+                                    }\n+\n+                                    private static final VarHandle VALUE;\n+                                    static {\n+                                        try {\n+                                            MethodHandles.Lookup l = MethodHandles.lookup();\n+                                            VALUE = l.findVarHandle(Cell.class, \"value\", long.class);\n+                                        } catch (ReflectiveOperationException e) {\n+                                            throw new ExceptionInInitializerError(e);\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Test {\n+                                    public implicit Test();\n+                                    void m(Test t1, Test[] t2, Test[][] t3, Test[][][] t4) {\n+                                        Test! l1 = (Test!) t1;\n+                                        Test![] l2 = (Test![]) t2;\n+                                        Test![][] l3 = (Test![][]) t3;\n+                                        Test![][][] l4 = (Test![][][]) t4;\n+\n+                                        Test[]! l5 = (Test[]!) t2;\n+                                        Test[][]! l6 = (Test[][]!) t3;\n+                                        Test[][][]! l7 = (Test[][][]!) t4;\n+\n+                                        Test[]![]! l8 = (Test[]![]!) t3;\n+                                        Test[]![]![]! l9 = (Test[]![]![]!) t4;\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void testOverridingWarnings() {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                abstract class A {\n+                                    abstract String! lookup(String arg);\n+                                }\n+\n+                                abstract class B extends A {\n+                                    abstract String? lookup(String arg);\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.overrides.with.different.nullness.1\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                value class Point { public implicit Point(); }\n+                                abstract class A {\n+                                    abstract String lookup(Point! arg);\n+                                }\n+\n+                                abstract class B extends A {\n+                                    abstract String lookup(Point? arg);\n+                                }\n+                                \"\"\",\n+                                Result.Warning,\n+                                \"compiler.warn.overrides.with.different.nullness.2\")\n+                )\n+        );\n+    }\n+\n+    @Test\n+    void testNonNullableFieldsAreStrict() throws Exception {\n+        testList(\n+                List.of(\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o;\n+                                    Test() {\n+                                        super();\n+                                        o = new Object();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o;\n+                                    Test() {\n+                                        o = new Object();\n+                                        super();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o = new Object();\n+                                    Test() {}\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    Object! o = new Object();\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        \/\/ static fields\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static Object! o;\n+                                }\n+                                \"\"\",\n+                                Result.Error,\n+                                \"compiler.err.non.nullable.should.be.initialized\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static Object! o = new Object();\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\"),\n+                        new DiagAndCode(\n+                                \"\"\"\n+                                class Test {\n+                                    static Object! o;\n+                                    static {\n+                                        o = new Object();\n+                                    }\n+                                }\n+                                \"\"\",\n+                                Result.Clean,\n+                                \"\")\n+                )\n+        );\n+\n+        for (String source : List.of(\n+                \"\"\"\n+                class Test {\n+                    Object! o = new Object();\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static Object! o = new Object();\n+                }\n+                \"\"\"\n+        )) {\n+            File dir = assertOK(true, source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                var classFile = ClassFile.of().parse(fileEntry.toPath());\n+                for (var field : classFile.fields()) {\n+                    if (!field.flags().has(AccessFlag.STATIC)) {\n+                        Set<AccessFlag> fieldFlags = field.flags().flags();\n+                        Assert.check(fieldFlags.size() == 1 && fieldFlags.contains(AccessFlag.STRICT_INIT));\n+                    } else {\n+                        Set<AccessFlag> fieldFlags = field.flags().flags();\n+                        Assert.check(fieldFlags.size() == 2 && fieldFlags.contains(AccessFlag.STRICT_INIT) && fieldFlags.contains(AccessFlag.STATIC));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityCompilationTests.java","additions":973,"deletions":0,"binary":false,"changes":973,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Smoke test for nullability inference\n+ * @enablePreview\n+ * @compile\/fail\/ref=NullabilityInferenceTest.out -XDrawDiagnostics NullabilityInferenceTest.java\n+ * @compile\/fail\/ref=NullabilityInferenceTest_parametric.out -XDrawDiagnostics -XDtvarUnspecifiedNullity NullabilityInferenceTest.java\n+ *\/\n+\n+import java.util.List;\n+\n+class Test {\n+    static class Box<T> { }\n+\n+    static <T> List<Box<T>> makeInvariant(Box<T>... boxes) { return null; }\n+    static <T> List<Box<T>> makeCovariant(Box<? extends T>... boxes) { return null; }\n+    static <T> List<Box<T>> makeContravariant(Box<? super T>... boxes) { return null; }\n+\n+    void testInvariant() {\n+        Box<String?> bs_null = null;\n+        Box<String!> bs_nonnull = null;\n+\n+        Integer i = null;\n+        i = (Integer)makeInvariant(bs_null, bs_nonnull); \/\/ List<Box<String?>>\n+        i = (Integer)makeInvariant(bs_nonnull, bs_null); \/\/ List<Box<String?>>\n+        i = (Integer)makeInvariant(bs_null, bs_null); \/\/ List<Box<String?>>\n+        i = (Integer)makeInvariant(bs_nonnull, bs_nonnull); \/\/ List<Box<String!>>\n+    }\n+\n+    void testCovariant() {\n+        Box<String?> bs_null = null;\n+        Box<String!> bs_nonnull = null;\n+\n+        Integer i = null;\n+        i = (Integer)makeCovariant(bs_null, bs_nonnull); \/\/ List<Box<String?>>\n+        i = (Integer)makeCovariant(bs_nonnull, bs_null); \/\/ List<Box<String?>>\n+        i = (Integer)makeCovariant(bs_null, bs_null); \/\/ List<Box<String?>>\n+        i = (Integer)makeCovariant(bs_nonnull, bs_nonnull); \/\/ List<Box<String!>>\n+    }\n+\n+    void testContravariant() {\n+        Box<String?> bs_null = null;\n+        Box<String!> bs_nonnull = null;\n+\n+        Integer i = null;\n+        i = (Integer)makeContravariant(bs_null, bs_nonnull); \/\/ List<Box<String!>>\n+        i = (Integer)makeContravariant(bs_nonnull, bs_null); \/\/ List<Box<String!>>\n+        i = (Integer)makeContravariant(bs_null, bs_null); \/\/ List<Box<String?>>\n+        i = (Integer)makeContravariant(bs_nonnull, bs_nonnull); \/\/ List<Box<String!>>\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityInferenceTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+NullabilityInferenceTest.java:23:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:24:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:25:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:26:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:34:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:35:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:36:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:37:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:45:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:46:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:47:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:48:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+- compiler.note.unchecked.filename: NullabilityInferenceTest.java\n+- compiler.note.unchecked.recompile\n+- compiler.note.preview.filename: NullabilityInferenceTest.java, DEFAULT\n+- compiler.note.preview.recompile\n+12 errors\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityInferenceTest.out","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+NullabilityInferenceTest.java:23:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:24:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:25:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:26:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:34:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:35:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:36:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:37:35: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:45:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:46:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:47:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+NullabilityInferenceTest.java:48:39: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.util.List<Test.Box<java.lang.String>>, java.lang.Integer)\n+- compiler.note.unchecked.filename: NullabilityInferenceTest.java\n+- compiler.note.unchecked.recompile\n+- compiler.note.preview.filename: NullabilityInferenceTest.java, DEFAULT\n+- compiler.note.preview.recompile\n+12 errors\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityInferenceTest_parametric.out","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @summary Smoke test for parsing of bang types\n+ * @compile NullabilityParsingBangTest.java\n+ *\/\n+\n+import java.util.function.*;\n+\n+class NullabilityParsingBangTest {\n+    static value class Point { public implicit Point(); }\n+    static value class Shape { public implicit Shape(); }\n+    \/\/ fields\n+    Point! o2 = new Point();\n+\n+    \/\/ method parameters\n+    void m2(Point! o) { }\n+\n+    \/\/ method returns\n+    Point! m2() { return new Point(); }\n+\n+    \/\/ locals\n+    void testLocals() {\n+        Point! o2;\n+    }\n+\n+    \/\/ generics - field\n+    Consumer<Point!> co2;\n+\n+    \/\/ generics - method param\n+    void m4(Consumer<Point!> co) { }\n+\n+    \/\/ generics - method return\n+    Consumer<Point!> m4() { return null; }\n+\n+    \/\/ generics - local\n+    void testGenericLocals() {\n+        Consumer<Point!> co2;\n+    }\n+\n+    \/\/ lambdas\n+    void testLambdas() {\n+        Consumer<Point!> co2 = (Point! co) -> {};\n+    }\n+\n+    void testGenericLambdas() {\n+        Consumer<Consumer<Point!>> co2 = (Consumer<Point!> co) -> {};\n+        Consumer<Function<Point!, Point!>> co3 = (Function<Point!, Point!> co) -> {};\n+        Consumer<Consumer<Consumer<Consumer<Point!>>>> co6 = (Consumer<Consumer<Consumer<Point!>>> co) -> {};\n+    }\n+\n+    \/\/ type test patterns\n+\n+    void testTypeTestPatterns(Object o) {\n+        switch (o) {\n+            case Point! i -> throw new AssertionError();\n+            case Shape! s -> throw new AssertionError();\n+            default -> throw new AssertionError();\n+        }\n+    }\n+\n+    sealed interface I<X> {}\n+    final class A implements I<Point> { }\n+\n+    void genericTypeTestPatterns(A o) {\n+        switch (o) {\n+            case I<Point!> i -> { }\n+        }\n+    }\n+\n+    sealed interface I2<X> {}\n+    final class A2 implements I2<I<Point>> { }\n+\n+    void genericTypeTestPatterns(A2 o) {\n+        switch (o) {\n+            case I2<I<Point!>> i -> { }\n+        }\n+    }\n+\n+    sealed interface I3<X> {}\n+    final class A3 implements I3<I2<I<Point>>> { }\n+\n+    void genericTypeTestPatterns(A3 o) {\n+        switch (o) {\n+            case I3<I2<I<Point!>>> i -> { }\n+        }\n+    }\n+\n+    \/\/ record patterns\n+\n+    record R(A a) { }\n+\n+    void genericRecordPatterns(R o) {\n+        switch (o) {\n+            case R!(I<Point!> i) -> { }\n+        }\n+    }\n+\n+    record R2(A2 a2) { }\n+\n+    void genericRecordPatterns(R2 o) {\n+        switch (o) {\n+            case R2!(I2<I<Point!>> i) -> { }\n+        }\n+    }\n+\n+    record R3(A3 a3) { }\n+\n+    void genericRecordPatterns(R3 o) {\n+        switch (o) {\n+            case R3!(I3<I2<I<Point!>>> i) -> { }\n+        }\n+    }\n+\n+    \/\/ instanceof\/cast\n+\n+    void testInstanceOf(Object o) {\n+        boolean r2 = o instanceof Point!;\n+    }\n+\n+    void testInstanceRecord(R r) {\n+        boolean r2 = r instanceof R(I<Point!> i);\n+    }\n+\n+    void testCast(Object o) {\n+        Point! s2 = (Point!)o;\n+    }\n+\n+    void testGenericCast(A a) {\n+        I<Point!> i2 = (I<Point!>)a;\n+    }\n+\n+    void testGenericCast2(A a) {\n+        I<Point!> i2 = (I<Point!>)a;\n+    }\n+\n+    \/\/ arrays\n+\n+    Point![]![]![]! oarr = {{{new Point()}}};\n+    Function<Point![]![]!, Function<Point![]![]!, Point![]![]!>>[][] garr;\n+\n+    void mBad1(Object o) {\n+        Point s1 = o instanceof Point ? (Point)o : null;\n+        Point s2 = o instanceof Point! ? (Point)o : null;\n+    }\n+\n+    void mBad2(Object o) {\n+        Point s1 = o instanceof Point ? null : null;\n+        Point s2 = o instanceof Point! ? null : null;\n+    }\n+\n+    void testPatternRule(Object o) {\n+        switch (o) {\n+            case Point! s -> { }\n+                default -> { }\n+        }\n+    }\n+\n+    void testPatternCol(Object o) {\n+        switch (o) {\n+            case Point! s: { }\n+            default: { }\n+        }\n+    }\n+\n+    void testInstanceOfAndInfix1(Object a, boolean b) {\n+        boolean x2 = a instanceof Point! && b;\n+    }\n+\n+    void testInstanceOfAndInfix2(Object a, boolean b) {\n+        boolean x2 = a instanceof Point! s && b;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityParsingBangTest.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @summary Smoke test for parsing of bang types\n+ * @compile NullabilityParsingQuesTest.java\n+ *\/\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+class NullabilityParsingQuesTest {\n+    static value class Point { public implicit Point(); }\n+    static value class Shape { public implicit Shape(); }\n+    \/\/ fields\n+    Point? o2;\n+\n+    \/\/ method parameters\n+    void m2(Point? o) { }\n+\n+    \/\/ method returns\n+    Point? m2() { return new Point(); }\n+\n+    \/\/ locals\n+    void testLocals() {\n+        Point? o2;\n+    }\n+\n+    \/\/ generics - field\n+    Consumer<Point?> co2;\n+\n+    \/\/ generics - method param\n+    void m4(Consumer<Point?> co) { }\n+\n+    \/\/ generics - method return\n+    Consumer<Point?> m4() { return null; }\n+\n+    \/\/ generics - local\n+    void testGenericLocals() {\n+        Consumer<Point?> co2;\n+    }\n+\n+    \/\/ lambdas\n+    void testLambdas() {\n+        Consumer<Point?> co2 = (Point? co) -> {};\n+    }\n+\n+    void testGenericLambdas() {\n+        Consumer<Consumer<Point?>> co2 = (Consumer<Point?> co) -> {};\n+        Consumer<Function<Point?, Point?>> co3 = (Function<Point?, Point?> co) -> {};\n+        Consumer<Consumer<Consumer<Consumer<Point?>>>> co6 = (Consumer<Consumer<Consumer<Point?>>> co) -> {};\n+    }\n+\n+    \/\/ type test patterns\n+\n+    void testTypeTestPatterns(Object o) {\n+        switch (o) {\n+            case Point? i -> throw new AssertionError();\n+            case Shape? s -> throw new AssertionError();\n+            default -> throw new AssertionError();\n+        }\n+    }\n+\n+    sealed interface I<X> {}\n+    final class A implements I<Point> { }\n+\n+    void genericTypeTestPatterns(A o) {\n+        switch (o) {\n+            case I<Point?> i -> { }\n+        }\n+    }\n+\n+    sealed interface I2<X> {}\n+    final class A2 implements I2<I<Point>> { }\n+\n+    void genericTypeTestPatterns(A2 o) {\n+        switch (o) {\n+            case I2<I<Point?>> i -> { }\n+        }\n+    }\n+\n+    sealed interface I3<X> {}\n+    final class A3 implements I3<I2<I<Point>>> { }\n+\n+    void genericTypeTestPatterns(A3 o) {\n+        switch (o) {\n+            case I3<I2<I<Point?>>> i -> { }\n+        }\n+    }\n+\n+    \/\/ record patterns\n+\n+    record R(A a) { }\n+\n+    void genericRecordPatterns(R o) {\n+        switch (o) {\n+            case R?(I<Point?> i) -> { }\n+        }\n+    }\n+\n+    record R2(A2 a2) { }\n+\n+    void genericRecordPatterns(R2 o) {\n+        switch (o) {\n+            case R2?(I2<I<Point?>> i) -> { }\n+        }\n+    }\n+\n+    record R3(A3 a3) { }\n+\n+    void genericRecordPatterns(R3 o) {\n+        switch (o) {\n+            case R3?(I3<I2<I<Point?>>> i) -> { }\n+        }\n+    }\n+\n+    \/\/ instanceof\/cast\n+\n+    void testInstanceOf(Object o) {\n+        boolean r2 = o instanceof Point?;\n+    }\n+\n+    void testInstanceRecord(R r) {\n+        boolean r2 = r instanceof R(I<Point?> i);\n+    }\n+\n+    void testCast(Object o) {\n+        Point? s2 = (Point?)o;\n+    }\n+\n+    void testGenericCast(A a) {\n+        I<Point?> i2 = (I<Point?>)a;\n+    }\n+\n+    void testGenericCast2(A a) {\n+        I<Point?> i2 = (I<Point?>)a;\n+    }\n+\n+    \/\/ arrays\n+\n+    Point?[]?[]?[]? oarr;\n+    Function<Point?[]?[]?, Function<Point?[]?[]?, Point?[]?[]?>>[][] garr;\n+\n+    void mBad1(Object o) {\n+        Point s1 = o instanceof Point ? (Point)o : null;\n+        Point s2 = o instanceof Point? ? (Point)o : null;\n+    }\n+\n+    void mBad2(Object o) {\n+        Point s1 = o instanceof Point ? null : null;\n+        Point s2 = o instanceof Point? ? null : null;\n+    }\n+\n+    void testPatternRule(Object o) {\n+        switch (o) {\n+            case Point? s -> { }\n+                default -> { }\n+        }\n+    }\n+\n+    void testPatternCol(Object o) {\n+        switch (o) {\n+            case Point? s: { }\n+            default: { }\n+        }\n+    }\n+\n+    void testInstanceOfAndInfix1(Object a, boolean b) {\n+        boolean x2 = a instanceof Point? && b;\n+    }\n+\n+    void testInstanceOfAndInfix2(Object a, boolean b) {\n+        boolean x2 = a instanceof Point? s && b;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityParsingQuesTest.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,516 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338910 8347754\n+ * @summary [lw5] enhance the Signature attribute to represent nullability\n+ * @library \/lib\/combo \/tools\/lib\n+ * @modules\n+ *     jdk.compiler\/com.sun.tools.javac.util\n+ *     jdk.compiler\/com.sun.tools.javac.api\n+ *     jdk.compiler\/com.sun.tools.javac.main\n+ *     jdk.compiler\/com.sun.tools.javac.code\n+ *     jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run junit NullabilitySignatureAttrTests\n+ * @ignore\n+ *\/\n+\n+import java.io.File;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import com.sun.tools.javac.util.Assert;\n+\n+import com.sun.tools.classfile.Attribute;\n+import com.sun.tools.classfile.Attributes;\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.classfile.Code_attribute;\n+import com.sun.tools.classfile.ConstantPool;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_Methodref_info;\n+import com.sun.tools.classfile.ImplicitCreation_attribute;\n+import com.sun.tools.classfile.NullRestricted_attribute;\n+import com.sun.tools.classfile.Field;\n+import com.sun.tools.classfile.Instruction;\n+import com.sun.tools.classfile.Method;\n+import com.sun.tools.classfile.Signature_attribute;\n+\n+import org.junit.jupiter.api.Test;\n+import tools.javac.combo.CompilationTestCase;\n+\n+import toolbox.*;\n+import toolbox.Task.*;\n+\n+public class NullabilitySignatureAttrTests extends CompilationTestCase {\n+    ToolBox tb = new ToolBox();\n+\n+    private static String[] PREVIEW_OPTIONS = {\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())};\n+\n+    public NullabilitySignatureAttrTests() {\n+        setDefaultFilename(\"Nullable.java\");\n+        setCompileOptions(PREVIEW_OPTIONS);\n+    }\n+\n+    record SignatureData(String source, String expectedSignature) {}\n+\n+    final List<SignatureData> signatureDataList = List.of(\n+            new SignatureData( \/\/ case 0\n+                    \"\"\"\n+                    class Test {\n+                        Test! t = new Test();\n+                    }\n+                    \"\"\",\n+                    \"LTest!;\"\n+            ),\n+            new SignatureData( \/\/ case 1\n+                    \"\"\"\n+                    class Test {\n+                        Test? t;\n+                    }\n+                    \"\"\",\n+                    \"LTest?;\"\n+            ),\n+            new SignatureData( \/\/ case 2\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Test {\n+                        List<Test!> t;\n+                    }\n+                    \"\"\",\n+                    \"Ljava\/util\/List<LTest!;>;\"\n+            ),\n+            new SignatureData( \/\/ case 3\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Test {\n+                        List<Test?> t;\n+                    }\n+                    \"\"\",\n+                    \"Ljava\/util\/List<LTest?;>;\"\n+            ),\n+            new SignatureData( \/\/ case 4\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Test {\n+                        List!<Test!> t = new ArrayList<>();\n+                    }\n+                    \"\"\",\n+                    \"Ljava\/util\/List<LTest!;>!;\"\n+            ),\n+            new SignatureData( \/\/ case 5\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Test {\n+                        List?<Test?> t;\n+                    }\n+                    \"\"\",\n+                    \"Ljava\/util\/List<LTest?;>?;\"\n+            ),\n+            new SignatureData( \/\/ case 6\n+                    \"\"\"\n+                    class Test<T> {\n+                        T! t = (T)new Object();\n+                    }\n+                    \"\"\",\n+                    \"TT!;\"\n+            ),\n+            new SignatureData( \/\/ case 7\n+                    \"\"\"\n+                    class Test<T> {\n+                        T? t;\n+                    }\n+                    \"\"\",\n+                    \"TT?;\"\n+            ),\n+            new SignatureData( \/\/ case 8\n+                    \"\"\"\n+                    class Test {\n+                        String[]? t;\n+                    }\n+                    \"\"\",\n+                    \"[Ljava\/lang\/String;\"\n+            ),\n+            new SignatureData( \/\/ case 9\n+                    \"\"\"\n+                    class Test {\n+                        String[]! t = {\"\"};\n+                    }\n+                    \"\"\",\n+                    \"[Ljava\/lang\/String;\"\n+            ),\n+            new SignatureData( \/\/ case 10\n+                    \"\"\"\n+                    class Test {\n+                        String![]? t;\n+                    }\n+                    \"\"\",\n+                    \"[Ljava\/lang\/String!;\"\n+            ),\n+            new SignatureData( \/\/ case 11\n+                    \"\"\"\n+                    class Test {\n+                        String?[]![]? t = {{\"\"}};\n+                    }\n+                    \"\"\",\n+                    \"[[Ljava\/lang\/String?;\"\n+            )\n+    );\n+\n+    @Test\n+    void testCheckFieldSignature() throws Exception {\n+        int testNo = 0;\n+        for (SignatureData sd : signatureDataList) {\n+            System.err.println(\"executing test at index \" + testNo++);\n+            File dir = assertOK(true, sd.source);\n+            for (final File fileEntry : dir.listFiles()) {\n+                ClassFile classFile = ClassFile.read(fileEntry);\n+                Field field = classFile.fields[0];\n+                Signature_attribute sa = (Signature_attribute)field.attributes.get(\"Signature\");\n+                System.err.println(sa.getSignature(classFile.constant_pool).toString());\n+                Assert.check(sa.getSignature(classFile.constant_pool).toString().equals(sd.expectedSignature));\n+            }\n+        }\n+    }\n+\n+    record SepCompilationData(String clientSrc, String serverSrc, List<String> sourceExpectedWarnings, List<String> sepCompExpectedWarnings) {}\n+    final List<SepCompilationData> sepCompilationDataList = List.of(\n+            new SepCompilationData(  \/\/ case 0\n+                    \"\"\"\n+                    class Client {\n+                        static Integer! a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        public static Integer? b;\n+                    }\n+                    \"\"\",\n+                    List.of(\"Client.java:2:31: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\"),\n+                    List.of(\"Client.java:2:31: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\")\n+            ),\n+            new SepCompilationData(  \/\/ case 1\n+                    \"\"\"\n+                    class Client {\n+                        static Integer! a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        public static Integer b;\n+                    }\n+                    \"\"\",\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData(  \/\/ case 2\n+                    \"\"\"\n+                    class Client {\n+                        static Integer! a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        public static Integer! b = 4;\n+                    }\n+                    \"\"\",\n+                    List.of(\"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData( \/\/ case 3\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Client {\n+                        static List!<String> a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Server {\n+                        public static List!<String> b = new ArrayList<>();\n+                    }\n+                    \"\"\",\n+                    List.of(\"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData( \/\/ case 4\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Client {\n+                        static List!<String> a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Server {\n+                        public static List?<String> b = new ArrayList<>();\n+                    }\n+                    \"\"\",\n+                    List.of(\"Client.java:3:36: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\"),\n+                    List.of(\"Client.java:3:36: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\")\n+            ),\n+            new SepCompilationData( \/\/ case 5\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Client {\n+                        static List!<String> a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    import java.util.*;\n+                    class Server {\n+                        public static List<String> b = new ArrayList<>();\n+                    }\n+                    \"\"\",\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData( \/\/ case 6\n+                    \"\"\"\n+                    class Client {\n+                        static Server!.Inner! a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        static class Inner {}\n+                        public static Server?.Inner? b = new Server.Inner();\n+                    }\n+                    \"\"\",\n+                    List.of(\"Client.java:2:37: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\"),\n+                    List.of(\"Client.java:2:37: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\")\n+            ),\n+            new SepCompilationData( \/\/ case 7\n+                    \"\"\"\n+                    class Client {\n+                        static String?[]![]? a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        public static String?[]?[]? b;\n+                    }\n+                    \"\"\",\n+                    List.of(\"Client.java:2:36: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",  \/\/ some information is lost\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData( \/\/ case 8\n+                    \"\"\"\n+                    class Client {\n+                        static String![]?[]? a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        public static String?[]?[]? b;\n+                    }\n+                    \"\"\",\n+                    List.of(\"Client.java:2:36: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\"),\n+                    List.of(\"Client.java:2:36: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\")\n+            ),\n+            new SepCompilationData( \/\/ case 9\n+                    \"\"\"\n+                    class Client {\n+                        static String?[]?[]! a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        public static String?[]?[]? b;\n+                    }\n+                    \"\"\",\n+                    List.of(\"Client.java:2:36: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData( \/\/ case 10\n+                    \"\"\"\n+                    class Client {\n+                        static String?[]?[]? a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        public static String?[]?[]? b;\n+                    }\n+                    \"\"\",\n+                    List.of(\"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\"),\n+                    List.of(\"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\")\n+            ),\n+            new SepCompilationData( \/\/ case 11\n+                    \"\"\"\n+                    import java.util.List;\n+                    class Client {\n+                        static List<? extends String!> a = Server.b;\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    import java.util.List;\n+                    class Server {\n+                        public static List<? extends String?> b;\n+                    }\n+                    \"\"\",\n+                    List.of(\"Client.java:3:46: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.plural: DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\"),\n+                    List.of(\"Client.java:3:46: compiler.warn.unchecked.nullness.conversion\",\n+                            \"- compiler.note.preview.filename: Client.java, DEFAULT\",\n+                            \"- compiler.note.preview.recompile\",\n+                            \"1 warning\")\n+            ),\n+            new SepCompilationData( \/\/ case 12\n+                    \"\"\"\n+                    import java.util.function.*;\n+                    class Client extends Vector<Byte>{\n+                        void foo(Server s, Unary op) {\n+                            int opc = 1;\n+                            s.unaryOp(getClass(), null, byte.class, this, null, UN_IMPL.find(op, opc, Client::unaryOperations));\n+                        }\n+                        interface Operator {}\n+                        interface Unary extends Operator {}\n+                        static class ImplCache<OP extends Operator,T> {\n+                            public ImplCache(Class<OP> whatKind, Class<? extends Vector<?>> whatVec) {}\n+                            public T find(OP op, int opc, IntFunction<T> supplier) {\n+                                return null;\n+                            }\n+                        }\n+                        static ImplCache<Unary, Server.UnaryOperation<Client, VectorMask<Byte>>>\n+                            UN_IMPL = new ImplCache<>(Unary.class, Client.class);\n+                        static Server.UnaryOperation<Client, VectorMask<Byte>> unaryOperations(int opc_) { return null; }\n+                    }\n+                    \"\"\",\n+                    \"\"\"\n+                    class Server {\n+                        <V extends Vector<E>,\n+                         M extends VectorMask<E>,\n+                         E>\n+                        V unaryOp(Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+                                  V v, M m,\n+                                  UnaryOperation<V, M> defaultImpl) {\n+                            return null;\n+                        }\n+                        public interface UnaryOperation<V extends Vector<?>,\n+                                                        M extends VectorMask<?>> {\n+                            V apply(V v, M m);\n+                        }\n+                    }\n+                    class Vector<V> {}\n+                    class VectorMask<VM> {}\n+                    \"\"\",\n+                    List.of(\"\"),\n+                    List.of(\"\")\n+            )\n+    );\n+\n+    @Test\n+    void testCheckSeparateComp() throws Exception {\n+        Path base = Paths.get(\".\");\n+        Path src = base.resolve(\"src\");\n+        tb.createDirectories(src);\n+        Path out = base.resolve(\"out\");\n+        tb.createDirectories(out);\n+        int testNo = 0;\n+        for (SepCompilationData scd : sepCompilationDataList) {\n+            System.err.println(\"executing test at index \" + testNo++);\n+            tb.writeJavaFiles(src, scd.serverSrc, scd.clientSrc);\n+            List<String> log = new JavacTask(tb)\n+                    .outdir(out)\n+                    .options(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature()),\n+                            \"-Xlint:null\", \"-XDrawDiagnostics\")\n+                    .files(tb.findJavaFiles(src))\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+            if (!scd.sourceExpectedWarnings.equals(log))\n+                throw new Exception(\"expected output not found: \" + log);\n+\n+            \/\/ now lets remove serverSrc's source and compile client's source using the class file version of serverSrc\n+            tb.deleteFiles(src.resolve(\"Server.java\"));\n+            log = new JavacTask(tb)\n+                    .outdir(out)\n+                    .options(\"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature()),\n+                            \"-Xlint:null\", \"-XDrawDiagnostics\", \"-cp\", \"out\")\n+                    .files(tb.findJavaFiles(src))\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.DIRECT);\n+            if (!scd.sepCompExpectedWarnings.equals(log))\n+                throw new Exception(\"expected output not found: \" + log);\n+\n+            \/\/ let's remove all the files in preparation for the next test\n+            tb.deleteFiles(src.resolve(\"Client.java\"));\n+            tb.deleteFiles(out.resolve(\"Client.class\"));\n+            tb.deleteFiles(out.resolve(\"Server.class\"));\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilitySignatureAttrTests.java","additions":516,"deletions":0,"binary":false,"changes":516,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Smoke test for nullability warnings\n+ * @enablePreview\n+ * @compile\/fail\/ref=NullabilityWarningsTest.out -XDrawDiagnostics -Werror -Xlint:null NullabilityWarningsTest.java\n+ * @compile\/fail\/ref=NullabilityWarningsTest_parametric.out -XDrawDiagnostics -Werror -Xlint:null -XDtvarUnspecifiedNullity NullabilityWarningsTest.java\n+ *\/\n+\n+public class NullabilityWarningsTest {\n+    static class Box<T> {\n+        T t;\n+        Box(T t) {\n+            this.t = t;\n+        }\n+        T get() { return t; }\n+        void set(T t) { this.t = t; }\n+    }\n+\n+    void test() {\n+        String? s_null = null;\n+        String! s_nonnull = \"\";\n+        String s_unknown = null;\n+        s_null = s_nonnull;\n+        s_nonnull = s_null; \/\/warn\n+        s_unknown = s_null;\n+        s_unknown = s_nonnull;\n+\n+        Box<String?> bs_null = null;\n+        Box<String!> bs_nonnull = null;\n+        Box<String> bs_unknown = null;\n+        bs_null = bs_nonnull; \/\/warn\n+        bs_nonnull = bs_null; \/\/warn\n+        bs_unknown = bs_null;\n+        bs_unknown = bs_nonnull;\n+\n+        Box<? super String?> bss_null = null;\n+        Box<? super String!> bss_nonnull = null;\n+        Box<? super String!> bss_unknown = null;\n+\n+        bss_nonnull = bss_null;\n+        bss_null = bss_nonnull; \/\/warn\n+        bss_unknown = bss_null;\n+        bss_unknown = bss_nonnull;\n+\n+        Box<? extends String?> bes_null = null;\n+        Box<? extends String!> bes_nonnull = null;\n+        Box<? extends String> bes_unknown = null;\n+\n+        bes_nonnull = bes_null; \/\/warn\n+        bes_null = bes_nonnull;\n+        bes_unknown = bes_null;\n+        bes_unknown = bes_nonnull;\n+    }\n+\n+    void testMember() {\n+        Box<String?> bs_null = null;\n+        Box<String!> bs_nonnull = null;\n+        Box<String> bs_unknown = null;\n+\n+        String s_unknown = bs_null.get();\n+        s_unknown = bs_nonnull.get();\n+        s_unknown = bs_unknown.get();\n+\n+        String? s_null = bs_null.get();\n+        s_null = bs_nonnull.get();\n+        s_null = bs_unknown.get();\n+\n+        String! s_nonnull = bs_null.get(); \/\/warn\n+        s_nonnull = bs_nonnull.get();\n+        s_nonnull = bs_unknown.get();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityWarningsTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+NullabilityWarningsTest.java:24:21: compiler.warn.unchecked.nullness.conversion\n+NullabilityWarningsTest.java:31:19: compiler.warn.unchecked.nullness.conversion\n+NullabilityWarningsTest.java:32:22: compiler.warn.unchecked.nullness.conversion\n+NullabilityWarningsTest.java:41:20: compiler.warn.unchecked.nullness.conversion\n+NullabilityWarningsTest.java:49:23: compiler.warn.unchecked.nullness.conversion\n+NullabilityWarningsTest.java:68:40: compiler.warn.unchecked.nullness.conversion\n+- compiler.err.warnings.and.werror\n+- compiler.note.preview.filename: NullabilityWarningsTest.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n+6 warnings\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityWarningsTest.out","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+NullabilityWarningsTest.java:24:21: compiler.warn.unchecked.nullness.conversion\n+NullabilityWarningsTest.java:31:19: compiler.warn.unchecked.nullness.conversion\n+NullabilityWarningsTest.java:32:22: compiler.warn.unchecked.nullness.conversion\n+NullabilityWarningsTest.java:41:20: compiler.warn.unchecked.nullness.conversion\n+NullabilityWarningsTest.java:49:23: compiler.warn.unchecked.nullness.conversion\n+- compiler.err.warnings.and.werror\n+- compiler.note.preview.filename: NullabilityWarningsTest.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n+5 warnings\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullabilityWarningsTest_parametric.out","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,371 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @summary test runtime null checks\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RuntimeNullChecks\n+ *\/\n+\n+import java.util.*;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.IntStream;\n+\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.util.Assert;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavaTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+\n+public class RuntimeNullChecks extends TestRunner {\n+    ToolBox tb;\n+\n+    RuntimeNullChecks() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        RuntimeNullChecks t = new RuntimeNullChecks();\n+        t.runTests();\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testRuntimeChecks(Path base) throws Exception {\n+        int i = 0;\n+        for (String code: new String[] {\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String! o = s; \/\/ NPE at runtime, variable initialization\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String! o;\n+                        o = s; \/\/ NPE at runtime, assignment, it doesn't stress the same code path as the case above\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\/\/\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String![] sr = new String![10];\n+                        sr[0] = s; \/\/ NPE at runtime, assignment\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static String id(String! arg) { return arg; }\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = id(s); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static String id(int i, String!... arg) { return \"\"; }\n+                    public static void main(String... args) {\n+                        String s1 = null;\n+                        String s2 = \"\";\n+                        Object o = id(1, s1, s2); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static String id(int i, String!... arg) { return \"\"; }\n+                    public static void main(String... args) {\n+                        String s1 = \"\";\n+                        String s2 = null;\n+                        Object o = id(1, s1, s2); \/\/ NPE at runtime, method invocation\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = (String!) s; \/\/ NPE, cast\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(Object! o) {}\n+                            T run() {\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) {\n+                        return action.run();\n+                    }\n+                    boolean isSystemProperty(String key, String value, String def, Object? o) {\n+                        return doPrivileged(\n+                            new Inner().new MyPrivilegedAction<Boolean>(o) {\n+                                @Override\n+                                public Boolean run() {\n+                                    return value.equals(System.getProperty(key, def));\n+                                }\n+                            });\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.isSystemProperty(\"1\", \"2\", \"3\", null);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(String s, Object!... o) {}\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n+                    boolean isSystemProperty(Inner inner, Object o) {\n+                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", o) {} );\n+                    }\n+                    void doTest() {\n+                        Inner inner = new Inner();\n+                        isSystemProperty(inner, null);\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.doTest();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(String s, Object!... o) {}\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n+                    boolean isSystemProperty(Inner inner, Object o) {\n+                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", o, o) {} );\n+                    }\n+                    void doTest() {\n+                        Inner inner = new Inner();\n+                        isSystemProperty(inner, null);\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.doTest();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(String s, Object!... o) {}\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) { return null; }\n+                    boolean isSystemProperty(Inner inner, Object o) {\n+                        return doPrivileged( inner.new MyPrivilegedAction<Boolean>(\"\", new Object(), o) {} );\n+                    }\n+                    void doTest() {\n+                        Inner inner = new Inner();\n+                        isSystemProperty(inner, null);\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.doTest();\n+                    }\n+                }\n+                \"\"\"\n+        }) {\n+            System.err.println(\"executing test \" + i++);\n+            testHelper(base, code, true, NullPointerException.class);\n+        }\n+\n+        \/\/ enums are a bit special as the NPE happens inside a static initializer and ExceptionInInitializerError is thrown\n+        testHelper(base,\n+                \"\"\"\n+                class Test {\n+                    static Object s = null;\n+                    enum E {\n+                        A(s);\n+                        E(Object! o) {}\n+                    }\n+                    public static void main(String... args) {\n+                        Test.E a = E.A;\n+                    }\n+                }\n+                \"\"\", true, ExceptionInInitializerError.class);\n+\n+        \/\/ similar test cases as above but without null markers, should trivially pass\n+        i = 0;\n+        for (String code: new String[] {\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String o = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String o;\n+                        o = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        String[] sr = new String[10];\n+                        sr[0] = s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    static String id(String arg) { return arg; }\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = id(s);\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    public static void main(String... args) {\n+                        String s = null;\n+                        Object o = (String) s;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        class MyPrivilegedAction<T> {\n+                            MyPrivilegedAction(Object o) {}\n+                            T run() {\n+                                return null;\n+                            }\n+                        }\n+                    }\n+                    public <T> T doPrivileged(Inner.MyPrivilegedAction<T> action) {\n+                        return action.run();\n+                    }\n+                    boolean isSystemProperty(String key, String value, String def, Object o) {\n+                        return doPrivileged(\n+                            new Inner().new MyPrivilegedAction<Boolean>(o) {\n+                                @Override\n+                                public Boolean run() {\n+                                    return value.equals(System.getProperty(key, def));\n+                                }\n+                            });\n+                    }\n+                    public static void main(String... args) {\n+                        Test test = new Test();\n+                        test.isSystemProperty(\"1\", \"2\", \"3\", null);\n+                    }\n+                }\n+                \"\"\"\n+        }) {\n+            System.err.println(\"executing test \" + i++);\n+            testHelper(base, code, false, null);\n+        }\n+    }\n+\n+    private static String[] PREVIEW_OPTIONS = {\n+            \"--enable-preview\", \"-source\", Integer.toString(Runtime.version().feature())};\n+\n+    private void testHelper(Path base, String testCode, boolean shouldFail, Class<?> expectedError) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path testSrc = src.resolve(\"Test\");\n+\n+        tb.writeJavaFiles(testSrc, testCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .options(PREVIEW_OPTIONS)\n+                .files(findJavaFiles(src))\n+                .run();\n+\n+        if (shouldFail) {\n+            \/\/ let's check that we get the expected error\n+            String output = new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .classArgs(\"Test\")\n+                    .vmOptions(\"--enable-preview\")\n+                    .run(Task.Expect.FAIL)\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.STDERR);\n+            if (!output.startsWith(\"Exception in thread \\\"main\\\" \" + expectedError.getName())) {\n+                throw new AssertionError(expectedError.getName() + \" expected\");\n+            }\n+        } else {\n+            new JavaTask(tb)\n+                    .classpath(out.toString())\n+                    .vmOptions(\"--enable-preview\")\n+                    .classArgs(\"Test\")\n+                    .run(Task.Expect.SUCCESS);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":371,"deletions":0,"binary":false,"changes":371,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @enablePreview\n+ * @summary Smoke test for nullable types in array types and array creation expressions\n+ * @compile\/fail\/ref=TestArrays.out -Xlint:null -Werror -XDrawDiagnostics TestArrays.java\n+ *\/\n+\n+public class TestArrays {\n+    void test1() {\n+        String! []?[]? arr_local = null;\n+        arr_local = new String! [3]? [4]?;\n+        arr_local = new String! [3]! [4]?;\n+        arr_local = new String! [3]? [4]!;\n+        arr_local = new String! [3]! [4]!;\n+    }\n+\n+    void test2() {\n+        String! []?[]! arr_local = null;\n+        arr_local = new String! [3]? [4]?; \/\/ warn\n+        arr_local = new String! [3]! [4]?; \/\/ warn\n+        arr_local = new String! [3]? [4]!;\n+        arr_local = new String! [3]! [4]!;\n+    }\n+\n+    void test3() {\n+        String! []![]? arr_local = new String! [0]![]?;\n+        arr_local = new String! [3]? [4]?; \/\/ warn\n+        arr_local = new String! [3]! [4]?;\n+        arr_local = new String! [3]? [4]!; \/\/ warn\n+        arr_local = new String! [3]! [4]!;\n+    }\n+\n+    void test4() {\n+        String! []![]! arr_local = new String! [0]![]!;\n+        arr_local = new String! [3]? [4]?; \/\/ warn\n+        arr_local = new String! [3]! [4]?; \/\/ warn\n+        arr_local = new String! [3]? [4]!; \/\/ warn\n+        arr_local = new String! [3]! [4]!;\n+    }\n+\n+    void test5() {\n+        String! []?[]? arr_local = null;\n+        arr_local = new String! [3]? []?;\n+        arr_local = new String! [3]! []?;\n+        arr_local = new String! [3]? []!;\n+        arr_local = new String! [3]! []!;\n+    }\n+\n+    void test6() {\n+        String! []?[]! arr_local = null;\n+        arr_local = new String! [3]? []?; \/\/ warn\n+        arr_local = new String! [3]! []?; \/\/ warn\n+        arr_local = new String! [3]? []!;\n+        arr_local = new String! [3]! []!;\n+    }\n+\n+    void test7() {\n+        String! []![]? arr_local = new String! [0]![]?;\n+        arr_local = new String! [3]? []?; \/\/ warn\n+        arr_local = new String! [3]! []?;\n+        arr_local = new String! [3]? []!; \/\/ warn\n+        arr_local = new String! [3]! []!;\n+    }\n+\n+    void test8() {\n+        String! []![]! arr_local = new String! [0]![]!;\n+        arr_local = new String! [3]? []?; \/\/ warn\n+        arr_local = new String! [3]! []?; \/\/ warn\n+        arr_local = new String! [3]? []!; \/\/ warn\n+        arr_local = new String! [3]! []!;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/TestArrays.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+TestArrays.java:19:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:20:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:27:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:29:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:35:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:36:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:37:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:51:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:52:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:59:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:61:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:67:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:68:21: compiler.warn.unchecked.nullness.conversion\n+TestArrays.java:69:21: compiler.warn.unchecked.nullness.conversion\n+- compiler.err.warnings.and.werror\n+- compiler.note.preview.filename: TestArrays.java, DEFAULT\n+- compiler.note.preview.recompile\n+1 error\n+14 warnings\n","filename":"test\/langtools\/tools\/javac\/nullability\/TestArrays.out","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -55,0 +55,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -168,1 +169,3 @@\n-            } else\n+            } else if (o instanceof NullMarker) {\n+                return;\n+            } else {\n@@ -170,0 +173,1 @@\n+            }\n","filename":"test\/langtools\/tools\/javac\/tree\/JavacTreeScannerTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -176,0 +177,2 @@\n+            } else if (o instanceof NullMarker) {\n+                return;\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceTreeScannerTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8209400 8215246\n+ * @summary Allow anonymous classes to be value types\n+ * @ignore 8316628\n+ *\/\n+\n+public class AnonymousValueType {\n+    public static void main(String[] args) {\n+        Object o = new value Comparable<String>() {\n+            int x = 10;\n+            @Override\n+            public int compareTo(String o) {\n+                return 0;\n+            }\n+        };\n+        if (!o.toString().equals(\"AnonymousValueType$1@\" + Integer.toHexString(o.hashCode())))\n+            throw new AssertionError(\"Broken\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/AnonymousValueType.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @enablePreview\n+ * @compile --enable-preview -source ${jdk.version} CanonicalCtorTest.java\n@@ -35,0 +35,2 @@\n+    public implicit CanonicalCtorTest();\n+\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/CanonicalCtorTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one ImplicitCreation attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile DuplicateImplicitCreationAttr.jcod\n+ * @compile\/fail\/ref=CheckImplicitCreationAttrIsUnique.out --enable-preview -source ${jdk.version} -XDrawDiagnostics CheckImplicitCreationAttrIsUnique.java\n+ *\/\n+\n+public class CheckImplicitCreationAttrIsUnique {\n+    void m() {\n+        DuplicateImplicitCreationAttr v = new DuplicateImplicitCreationAttr();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/implicit_creation_attr\/CheckImplicitCreationAttrIsUnique.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckImplicitCreationAttrIsUnique.java:13:9: compiler.err.cant.access: DuplicateImplicitCreationAttr, (compiler.misc.bad.class.file.header: DuplicateImplicitCreationAttr.class, (compiler.misc.attribute.must.be.unique: ImplicitCreation))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/implicit_creation_attr\/CheckImplicitCreationAttrIsUnique.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+class DuplicateImplicitCreationAttr {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"DuplicateImplicitCreationAttr\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LDuplicateImplicitCreationAttr;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"DuplicateImplicitCreationAttr.java\"; \/\/ #10\n+    Utf8 \"ImplicitCreation\"; \/\/ #11\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+    ;\n+    Attr(#11) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class DuplicateImplicitCreationAttr\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/implicit_creation_attr\/DuplicateImplicitCreationAttr.jcod","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,16 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile --enable-preview -source ${jdk.version} ValueClass.jcod DuplicateNullRestrictedAttr.jcod\n+ * @compile\/fail\/ref=CheckNullRestrictedAttrIsUnique.out --enable-preview -source ${jdk.version} -XDrawDiagnostics CheckNullRestrictedAttrIsUnique.java\n+ * @ignore\n+ *\/\n+\n+public class CheckNullRestrictedAttrIsUnique {\n+    void m() {\n+        DuplicateNullRestrictedAttr v = new DuplicateNullRestrictedAttr();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/CheckNullRestrictedAttrIsUnique.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckNullRestrictedAttrIsUnique.java:13:9: compiler.err.cant.access: DuplicateNullRestrictedAttr, (compiler.misc.bad.class.file.header: DuplicateNullRestrictedAttr.class, (compiler.misc.attribute.must.be.unique: NullRestricted))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/CheckNullRestrictedAttrIsUnique.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+class DuplicateNullRestrictedAttr {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"DuplicateNullRestrictedAttr\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"field\"; \/\/ #5\n+    Utf8 \"LValueClass;\"; \/\/ #6\n+    Utf8 \"NullRestricted\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #8\n+    Utf8 \"()LDuplicateNullRestrictedAttr;\"; \/\/ #9\n+    Utf8 \"Code\"; \/\/ #10\n+    Utf8 \"LineNumberTable\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"DuplicateNullRestrictedAttr.java\"; \/\/ #13\n+    Utf8 \"ImplicitCreation\"; \/\/ #14\n+    Utf8 \"Preload\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"ValueClass\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+        ;\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #8; \/\/ name_index\n+      #9; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#10) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#11) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+                4  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#14) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+    ;\n+    Attr(#15) { \/\/ Preload\n+      0x00010010;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class DuplicateNullRestrictedAttr\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/DuplicateNullRestrictedAttr.jcod","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+class ValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClass;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"DuplicateNullRestrictedAttr.java\"; \/\/ #10\n+    Utf8 \"ImplicitCreation\"; \/\/ #11\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/attr_is_unique\/ValueClass.jcod","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile --enable-preview -source ${jdk.version} NullRestrictedOnPrimitive.jcod\n+ * @compile\/fail\/ref=CheckFieldTypeTest.out --enable-preview -source ${jdk.version} -XDrawDiagnostics CheckFieldTypeTest.java\n+ *\/\n+\n+public class CheckFieldTypeTest {\n+    void m() {\n+        NullRestrictedOnPrimitive v = new NullRestrictedOnPrimitive();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckFieldTypeTest.java:13:9: compiler.err.cant.access: NullRestrictedOnPrimitive, (compiler.misc.bad.class.file.header: NullRestrictedOnPrimitive.class, (compiler.misc.attribute.not.applicable.to.field.type: NullRestricted, int))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile --enable-preview -source ${jdk.version} NullRestrictedOnArray.jcod\n+ * @compile\/fail\/ref=CheckFieldTypeTest2.out --enable-preview -source ${jdk.version} -XDrawDiagnostics CheckFieldTypeTest2.java\n+ *\/\n+\n+public class CheckFieldTypeTest2 {\n+    void m() {\n+        NullRestrictedOnArray v = new NullRestrictedOnArray();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest2.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CheckFieldTypeTest2.java:13:9: compiler.err.cant.access: NullRestrictedOnArray, (compiler.misc.bad.class.file.header: NullRestrictedOnArray.class, (compiler.misc.attribute.not.applicable.to.field.type: NullRestricted, java.lang.String[]))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/CheckFieldTypeTest2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+class NullRestrictedOnArray {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"NullRestrictedOnArray\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"arr\"; \/\/ #5\n+    Utf8 \"[Ljava\/lang\/String;\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()LNullRestrictedOnArray;\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"NullRestrictedOnArray.java\"; \/\/ #12\n+    Utf8 \"ImplicitCreation\"; \/\/ #13\n+    Utf8 \"NullRestricted\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnArray\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/NullRestrictedOnArray.jcod","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+class NullRestrictedOnPrimitive {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"NullRestrictedOnPrimitive\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"i\"; \/\/ #5\n+    Utf8 \"I\"; \/\/ #6\n+    Utf8 \"<vnew>\"; \/\/ #7\n+    Utf8 \"()LNullRestrictedOnPrimitive;\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"NullRestrictedOnPrimitive.java\"; \/\/ #12\n+    Utf8 \"ImplicitCreation\"; \/\/ #13\n+    Utf8 \"NullRestricted\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#14) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #7; \/\/ name_index\n+      #8; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  8;\n+                4  5;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnPrimitive\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/check_field_type\/NullRestrictedOnPrimitive.jcod","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @compile --enable-preview -source ${jdk.version} NullRestrictedOnMethod.jcod\n+ * @compile\/fail\/ref=NullRestrictedAttrOnlyOnFields.out --enable-preview -source ${jdk.version} -XDrawDiagnostics NullRestrictedAttrOnlyOnFields.java\n+ *\/\n+\n+public class NullRestrictedAttrOnlyOnFields {\n+    void m() {\n+        NullRestrictedOnMethod v = new NullRestrictedOnMethod();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/NullRestrictedAttrOnlyOnFields.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+NullRestrictedAttrOnlyOnFields.java:13:9: compiler.err.cant.access: NullRestrictedOnMethod, (compiler.misc.bad.class.file.header: NullRestrictedOnMethod.class, (compiler.misc.attribute.only.applicable.to.fields: NullRestricted))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/NullRestrictedAttrOnlyOnFields.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+class NullRestrictedOnMethod {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [20] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"NullRestrictedOnMethod\"; \/\/ #2     at 0x0D\n+    class #4; \/\/ #3     at 0x26\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x29\n+    Utf8 \"field\"; \/\/ #5     at 0x3C\n+    Utf8 \"LValueClass2;\"; \/\/ #6     at 0x44\n+    Utf8 \"NullRestricted\"; \/\/ #7     at 0x54\n+    Utf8 \"foo\"; \/\/ #8     at 0x65\n+    Utf8 \"()V\"; \/\/ #9     at 0x6B\n+    Utf8 \"Code\"; \/\/ #10     at 0x71\n+    Utf8 \"LineNumberTable\"; \/\/ #11     at 0x78\n+    Utf8 \"<vnew>\"; \/\/ #12     at 0x8A\n+    Utf8 \"()LNullRestrictedOnMethod;\"; \/\/ #13     at 0x93\n+    Utf8 \"SourceFile\"; \/\/ #14     at 0xB0\n+    Utf8 \"NullRestrictedOnMethod.java\"; \/\/ #15     at 0xBD\n+    Utf8 \"ImplicitCreation\"; \/\/ #16     at 0xDB\n+    Utf8 \"Preload\"; \/\/ #17     at 0xEE\n+    class #19; \/\/ #18     at 0xF8\n+    Utf8 \"ValueClass2\"; \/\/ #19     at 0xFB\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access [ ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [1] { \/\/ Fields\n+    {  \/\/ field at 0x0113\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index       : field\n+      #6; \/\/ descriptor_index : LValueClass2;\n+      [0] { \/\/ Attributes\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [2] { \/\/ Methods\n+    {  \/\/ method at 0x0123\n+      0x0000; \/\/ access\n+      #8; \/\/ name_index       : foo\n+      #9; \/\/ descriptor_index : ()V\n+      [1] { \/\/ Attributes\n+        Attr(#10, 25) { \/\/ Code at 0x012B\n+          0; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[1]{\n+            0xB1;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 6) { \/\/ LineNumberTable at 0x013E\n+              [1] { \/\/ line_number_table\n+                0  9; \/\/  at 0x014A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method at 0x014A\n+      0x0009; \/\/ access\n+      #12; \/\/ name_index       : <vnew>\n+      #13; \/\/ descriptor_index : ()LNullRestrictedOnMethod;\n+      [2] { \/\/ Attributes\n+        Attr(#10, 34) { \/\/ Code at 0x0152\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[6]{\n+            0xCB00014B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#11, 10) { \/\/ LineNumberTable at 0x016A\n+              [2] { \/\/ line_number_table\n+                0  7; \/\/  at 0x0176\n+                4  2; \/\/  at 0x017A\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#7, 0) { \/\/ NullRestricted at 0x011B\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [3] { \/\/ Attributes\n+    Attr(#14, 2) { \/\/ SourceFile at 0x017C\n+      #15;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#16, 2) { \/\/ ImplicitCreation at 0x0184\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+    ;\n+    Attr(#17, 4) { \/\/ Preload at 0x018C\n+      0x00010012;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnMethod\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/NullRestrictedOnMethod.jcod","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+class ValueClass2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [12] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1     at 0x0A\n+    Utf8 \"ValueClass2\"; \/\/ #2     at 0x0D\n+    class #4; \/\/ #3     at 0x1B\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4     at 0x1E\n+    Utf8 \"<vnew>\"; \/\/ #5     at 0x31\n+    Utf8 \"()LValueClass2;\"; \/\/ #6     at 0x3A\n+    Utf8 \"Code\"; \/\/ #7     at 0x4C\n+    Utf8 \"LineNumberTable\"; \/\/ #8     at 0x53\n+    Utf8 \"SourceFile\"; \/\/ #9     at 0x65\n+    Utf8 \"NullRestrictedOnMethod.java\"; \/\/ #10     at 0x72\n+    Utf8 \"ImplicitCreation\"; \/\/ #11     at 0x90\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access [ ACC_FINAL ]\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [1] { \/\/ Methods\n+    {  \/\/ method at 0xAF\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index       : <vnew>\n+      #6; \/\/ descriptor_index : ()LValueClass2;\n+      [1] { \/\/ Attributes\n+        Attr(#7, 34) { \/\/ Code at 0xB7\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[6]{\n+            0xCB00014B2AB0;\n+          }\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [1] { \/\/ Attributes\n+            Attr(#8, 10) { \/\/ LineNumberTable at 0xCF\n+              [2] { \/\/ line_number_table\n+                0  2; \/\/  at 0xDB\n+                4  1; \/\/  at 0xDF\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [2] { \/\/ Attributes\n+    Attr(#9, 2) { \/\/ SourceFile at 0xE1\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11, 2) { \/\/ ImplicitCreation at 0xE9\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass2\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/only_on_fields\/ValueClass2.jcod","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+\/* @test \/nodynamiccopyright\/\n+ * @summary [lw5] check that there can only be one NullRestricted attribute\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @library \/tools\/lib\n+ * @ignore\n+ * @compile ValueClass.jcod NullRestrictedOnValueClass.jcod\n+ * @compile\/fail\/ref=NullRestrictedAttrOnValueClassNoImplicitConst.out -XDrawDiagnostics NullRestrictedAttrOnValueClassNoImplicitConst.java\n+ *\/\n+\n+ \/* testing if a value class has an implicit constructor or not would imply loading the class if it is not loaded, this could provoke\n+  * altering the class loading order, not sure if this is worthy. Basically the assertion in the JVMS is:\n+  * `The descriptor_index of the field should name a value class that has an ImplicitCreation attribute with its ACC_DEFAULT flag is set`\n+  *\/\n+public class NullRestrictedAttrOnValueClassNoImplicitConst {\n+    void m() {\n+        NullRestrictedOnValueClass v = new NullRestrictedOnValueClass();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/NullRestrictedAttrOnValueClassNoImplicitConst.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/NullRestrictedAttrOnValueClassNoImplicitConst.out","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/langtools\/test\/TEST.ROOT","status":"copied"},{"patch":"@@ -0,0 +1,85 @@\n+class NullRestrictedOnValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"NullRestrictedOnValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"field\"; \/\/ #5\n+    Utf8 \"LValueClass;\"; \/\/ #6\n+    Utf8 \"NullRestricted\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #8\n+    Utf8 \"()LNullRestrictedOnValueClass;\"; \/\/ #9\n+    Utf8 \"Code\"; \/\/ #10\n+    Utf8 \"LineNumberTable\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"NullRestrictedOnValueClass.java\"; \/\/ #13\n+    Utf8 \"ImplicitCreation\"; \/\/ #14\n+    Utf8 \"Preload\"; \/\/ #15\n+    class #17; \/\/ #16\n+    Utf8 \"ValueClass\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #8; \/\/ name_index\n+      #9; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#10) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#11) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  7;\n+                4  2;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#14) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+    ;\n+    Attr(#15) { \/\/ Preload\n+      0x00010010;\n+    } \/\/ end Preload\n+  } \/\/ Attributes\n+} \/\/ end class NullRestrictedOnValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/NullRestrictedOnValueClass.jcod","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+class ValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"ValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<vnew>\"; \/\/ #5\n+    Utf8 \"()LValueClass;\"; \/\/ #6\n+    Utf8 \"Code\"; \/\/ #7\n+    Utf8 \"LineNumberTable\"; \/\/ #8\n+    Utf8 \"SourceFile\"; \/\/ #9\n+    Utf8 \"NullRestrictedOnValueClass.java\"; \/\/ #10\n+    Utf8 \"ImplicitCreation\"; \/\/ #11\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#8) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  2;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#9) { \/\/ SourceFile\n+      #10;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#11) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class ValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/classfile\/null_restricted_attr\/value_class_no_implicit_const\/ValueClass.jcod","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8314165\n+ * @summary check for illegal circularity at class loading time\n+ * @compile --enable-preview -source ${jdk.version} CyclicValueClass.jcod\n+ * @compile\/fail\/ref=CheckForCyclesAtClassLoadingTimeTest.out --enable-preview -source ${jdk.version} -XDrawDiagnostics CheckForCyclesAtClassLoadingTimeTest.java\n+ * @ignore\n+ *\/\n+class CheckForCyclesAtClassLoadingTimeTest {\n+    CyclicValueClass cyclicValueClass;\n+}\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CheckForCyclesAtClassLoadingTimeTest.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CyclicValueClass.class:-:-: compiler.err.cyclic.primitive.class.membership: CyclicValueClass\n+1 error\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CheckForCyclesAtClassLoadingTimeTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+class CyclicValueClass {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  66; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #2; \/\/ #1\n+    Utf8 \"CyclicValueClass\"; \/\/ #2\n+    class #4; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"cyclicField\"; \/\/ #5\n+    Utf8 \"LCyclicValueClass;\"; \/\/ #6\n+    Utf8 \"NullRestricted\"; \/\/ #7\n+    Utf8 \"<vnew>\"; \/\/ #8\n+    Utf8 \"()LCyclicValueClass;\"; \/\/ #9\n+    Utf8 \"Code\"; \/\/ #10\n+    Utf8 \"LineNumberTable\"; \/\/ #11\n+    Utf8 \"SourceFile\"; \/\/ #12\n+    Utf8 \"CyclicValueClass.java\"; \/\/ #13\n+    Utf8 \"ImplicitCreation\"; \/\/ #14\n+  } \/\/ Constant Pool\n+\n+  0x0050; \/\/ access\n+  #1;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0010; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#7) { \/\/ NullRestricted\n+        } \/\/ end NullRestricted\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #8; \/\/ name_index\n+      #9; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#10) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xCB00014B2AB0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#11) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+                4  1;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#12) { \/\/ SourceFile\n+      #13;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#14) { \/\/ ImplicitCreation\n+      0x0001;\n+    } \/\/ end ImplicitCreation\n+  } \/\/ Attributes\n+} \/\/ end class CyclicValueClass\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/cycles\/CyclicValueClass.jcod","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}