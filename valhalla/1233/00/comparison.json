{"files":[{"patch":"@@ -76,0 +76,1 @@\n+@SuppressWarnings(\"serial\")\n@@ -83,1 +84,0 @@\n-    \/\/ float16ToShortBits that normalizes NaNs, c.f. floatToIntBits vs floatToRawIntBits\n@@ -89,2 +89,0 @@\n-    \/\/ valueOf(BigDecimal) -- main implementation could be package private in BigDecimal\n-\n@@ -284,1 +282,1 @@\n-        if (value < -65_504L) {\n+        if (value <= -65_520L) {  \/\/ -(Float16.MAX_VALUE + Float16.ulp(Float16.MAX_VALUE) \/ 2)\n@@ -287,2 +285,2 @@\n-            if (value > 65_504L) {\n-                return NEGATIVE_INFINITY;\n+            if (value >= 65_520L) {  \/\/ Float16.MAX_VALUE + Float16.ulp(Float16.MAX_VALUE) \/ 2\n+                return POSITIVE_INFINITY;\n@@ -575,0 +573,39 @@\n+    \/**\n+     * Returns a representation of the specified floating-point value\n+     * according to the IEEE 754 floating-point \"binary16\" bit\n+     * layout.\n+     *\n+     * <p>Bit 15 (the bit that is selected by the mask\n+     * {@code 0x80000000}) represents the sign of the floating-point\n+     * number.\n+     * Bits 14-10 (the bits that are selected by the mask\n+     * {@code 0x7f800000}) represent the exponent.\n+     * Bits 9-0 (the bits that are selected by the mask\n+     * {@code 0x007fffff}) represent the significand (sometimes called\n+     * the mantissa) of the floating-point number.\n+     *\n+     * <p>If the argument is positive infinity, the result is\n+     * {@code 0x7C00}.\n+     *\n+     * <p>If the argument is negative infinity, the result is\n+     * {@code 0xfC00}.\n+     *\n+     * <p>If the argument is NaN, the result is {@code 0x7E00}.\n+     *\n+     * <p>In all cases, the result is a short that, when given to the\n+     * {@link #shortBitsToFloat16(short)} method, will produce a floating-point\n+     * value the same as the argument to {@code float16ToShortBits}\n+     * (except all NaN values are collapsed to a single\n+     * \"canonical\" NaN value).\n+     *\n+     * @param   f16   an IEEE 754 binary16 floating-point number.\n+     * @return the bits that represent the floating-point number.\n+     *\/\n+    \/\/@IntrinsicCandidate\n+    public static short float16ToShortBits(Float16 f16) {\n+        if (!isNaN(f16)) {\n+            return float16ToRawShortBits(f16);\n+        }\n+        return 0x7E00;\n+    }\n+\n@@ -858,1 +895,0 @@\n-     * @see Math#sqrt(float)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float16.java","additions":43,"deletions":7,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+        T_FLOAT16 = 5,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -409,3 +409,1 @@\n-        Object ia = Array.newInstance(laneType.elementType,\n-                                      laneCount);\n-        assert(ia.getClass() == laneType.arrayType);\n+        Object ia = Array.newInstance(laneType.elementType, laneCount);\n@@ -413,8 +411,18 @@\n-        for (int i = 0; i < laneCount; i++) {\n-            if ((byte)i == i)\n-                Array.setByte(ia, i, (byte)i);\n-            else if ((short)i == i)\n-                Array.setShort(ia, i, (short)i);\n-            else\n-                Array.setInt(ia, i, i);\n-            assert(Array.getDouble(ia, i) == i);\n+        assert(ia.getClass() == laneType.arrayType);\n+        if (elementType() == Float16.class) {\n+            Float16 [] f16arr = (Float16[])ia;\n+            for (int i = 0; i < laneCount; i++) {\n+                \/\/ Note: All the numbers in the range [0:2049) are directly\n+                \/\/ representable in FP16 format without the precision loss.\n+                f16arr[i] = Float16.valueOf((float)i);\n+            }\n+        } else {\n+            for (int i = 0; i < laneCount; i++) {\n+                if ((byte)i == i)\n+                    Array.setByte(ia, i, (byte)i);\n+                else if ((short)i == i)\n+                    Array.setShort(ia, i, (short)i);\n+                else\n+                    Array.setInt(ia, i, i);\n+                assert(Array.getDouble(ia, i) == i);\n+            }\n@@ -618,0 +626,2 @@\n+        case LaneType.SK_FLOAT16:\n+            s = HalffloatVector.species(shape); break;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -265,0 +265,9 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public HalffloatVector reinterpretAsHalffloats() {\n+        return (HalffloatVector) asVectorRaw(LaneType.FLOAT16);\n+    }\n+\n@@ -536,0 +545,2 @@\n+        case LaneType.SK_FLOAT16:\n+            return HalffloatVector.fromMemorySegment(rsp.check(Float16.class), ms, 0, bo, m.check(Float16.class)).check0(rsp);\n@@ -598,0 +609,7 @@\n+            case LaneType.SK_FLOAT16: {\n+                Float16[] a = new Float16[rlength];\n+                for (int i = 0; i < limit; i++) {\n+                    a[i] = Float16.valueOf(lanes[i]);\n+                }\n+                return HalffloatVector.fromArray(dsp.check(Float16.class), a, 0).check0(dsp);\n+            }\n@@ -648,0 +666,7 @@\n+            case LaneType.SK_FLOAT16: {\n+                Float16[] a = new Float16[rlength];\n+                for (int i = 0; i < limit; i++) {\n+                    a[i] = Float16.valueOf(lanes[i]);\n+                }\n+                return HalffloatVector.fromArray(dsp.check(Float16.class), a, 0).check0(dsp);\n+            }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        byte res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Byte128Mask.class, (Byte128Mask) m);  \/\/ specialized\n+        byte res = super.reduceLanesTemplate(op, Byte128Mask.class, (Byte128Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -685,1 +687,1 @@\n-                Byte128Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        byte res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Byte256Mask.class, (Byte256Mask) m);  \/\/ specialized\n+        byte res = super.reduceLanesTemplate(op, Byte256Mask.class, (Byte256Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -717,1 +719,1 @@\n-                Byte256Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        byte res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Byte512Mask.class, (Byte512Mask) m);  \/\/ specialized\n+        byte res = super.reduceLanesTemplate(op, Byte512Mask.class, (Byte512Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -781,1 +783,1 @@\n-                Byte512Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        byte res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Byte64Mask.class, (Byte64Mask) m);  \/\/ specialized\n+        byte res = super.reduceLanesTemplate(op, Byte64Mask.class, (Byte64Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -669,1 +671,1 @@\n-                Byte64Mask.class, byte.class, VLENGTH, offset, limit,\n+                Byte64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        byte res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialized\n+        byte res = super.reduceLanesTemplate(op, ByteMaxMask.class, (ByteMaxMask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -655,1 +657,1 @@\n-                ByteMaxMask.class, byte.class, VLENGTH, offset, limit,\n+                ByteMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2223,2 +2223,1 @@\n-                byte sc = (byte) scale_;\n-                return v.add(sc == 1 ? iota : iota.mul(sc));\n+                return v.add(scale_ == 1 ? iota : iota.mul((byte)scale_));\n@@ -2287,1 +2286,2 @@\n-        VectorMask<Byte> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(length() - origin))));\n+        byte pivotidx = (byte)(length() - origin);\n+        VectorMask<Byte> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2317,1 +2317,2 @@\n-        VectorMask<Byte> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((byte)(length() - origin))));\n+        byte pivotidx = (byte)(length() - origin);\n+        VectorMask<Byte> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2379,1 +2380,1 @@\n-                                                                  (broadcast((byte)(origin))));\n+                                                                  broadcast((byte)(origin)));\n@@ -2951,1 +2952,1 @@\n-            res[i] = (double) a[i];\n+            res[i] = ((double) a[i]);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        double res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -344,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op, Double128Mask.class, (Double128Mask) m);  \/\/ specialized\n+        double res = super.reduceLanesTemplate(op, Double128Mask.class, (Double128Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -646,1 +648,1 @@\n-                Double128Mask.class, double.class, VLENGTH, offset, limit,\n+                Double128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        double res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -344,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op, Double256Mask.class, (Double256Mask) m);  \/\/ specialized\n+        double res = super.reduceLanesTemplate(op, Double256Mask.class, (Double256Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -650,1 +652,1 @@\n-                Double256Mask.class, double.class, VLENGTH, offset, limit,\n+                Double256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        double res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -344,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op, Double512Mask.class, (Double512Mask) m);  \/\/ specialized\n+        double res = super.reduceLanesTemplate(op, Double512Mask.class, (Double512Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -658,1 +660,1 @@\n-                Double512Mask.class, double.class, VLENGTH, offset, limit,\n+                Double512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        double res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -344,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op, Double64Mask.class, (Double64Mask) m);  \/\/ specialized\n+        double res = super.reduceLanesTemplate(op, Double64Mask.class, (Double64Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -644,1 +646,1 @@\n-                Double64Mask.class, double.class, VLENGTH, offset, limit,\n+                Double64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        double res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -344,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialized\n+        double res = super.reduceLanesTemplate(op, DoubleMaxMask.class, (DoubleMaxMask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -643,1 +645,1 @@\n-                DoubleMaxMask.class, double.class, VLENGTH, offset, limit,\n+                DoubleMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n-        return  Double.doubleToRawLongBits(e);\n+        return Double.doubleToRawLongBits(e);\n@@ -1030,2 +1030,1 @@\n-            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) ->\n-                    v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n@@ -2065,2 +2064,1 @@\n-                double sc = (double) scale_;\n-                return v.add(sc == 1 ? iota : iota.mul(sc));\n+                return v.add(scale_ == 1 ? iota : iota.mul((double)scale_));\n@@ -2129,1 +2127,2 @@\n-        VectorMask<Double> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((double)(length() - origin))));\n+        double pivotidx = (double)(length() - origin);\n+        VectorMask<Double> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2159,1 +2158,2 @@\n-        VectorMask<Double> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((double)(length() - origin))));\n+        double pivotidx = (double)(length() - origin);\n+        VectorMask<Double> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2221,1 +2221,1 @@\n-                                                                  (broadcast((double)(origin))));\n+                                                                  broadcast((double)(origin)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        float res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -344,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op, Float128Mask.class, (Float128Mask) m);  \/\/ specialized\n+        float res = super.reduceLanesTemplate(op, Float128Mask.class, (Float128Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -650,1 +652,1 @@\n-                Float128Mask.class, float.class, VLENGTH, offset, limit,\n+                Float128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        float res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -344,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op, Float256Mask.class, (Float256Mask) m);  \/\/ specialized\n+        float res = super.reduceLanesTemplate(op, Float256Mask.class, (Float256Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -658,1 +660,1 @@\n-                Float256Mask.class, float.class, VLENGTH, offset, limit,\n+                Float256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        float res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -344,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op, Float512Mask.class, (Float512Mask) m);  \/\/ specialized\n+        float res = super.reduceLanesTemplate(op, Float512Mask.class, (Float512Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -674,1 +676,1 @@\n-                Float512Mask.class, float.class, VLENGTH, offset, limit,\n+                Float512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        float res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -344,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op, Float64Mask.class, (Float64Mask) m);  \/\/ specialized\n+        float res = super.reduceLanesTemplate(op, Float64Mask.class, (Float64Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -646,1 +648,1 @@\n-                Float64Mask.class, float.class, VLENGTH, offset, limit,\n+                Float64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,1 +337,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        float res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -344,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialized\n+        float res = super.reduceLanesTemplate(op, FloatMaxMask.class, (FloatMaxMask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -643,1 +645,1 @@\n-                FloatMaxMask.class, float.class, VLENGTH, offset, limit,\n+                FloatMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n-        return  Float.floatToRawIntBits(e);\n+        return Float.floatToRawIntBits(e);\n@@ -1030,2 +1030,1 @@\n-            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) ->\n-                    v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n@@ -2077,2 +2076,1 @@\n-                float sc = (float) scale_;\n-                return v.add(sc == 1 ? iota : iota.mul(sc));\n+                return v.add(scale_ == 1 ? iota : iota.mul((float)scale_));\n@@ -2141,1 +2139,2 @@\n-        VectorMask<Float> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((float)(length() - origin))));\n+        float pivotidx = (float)(length() - origin);\n+        VectorMask<Float> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2171,1 +2170,2 @@\n-        VectorMask<Float> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((float)(length() - origin))));\n+        float pivotidx = (float)(length() - origin);\n+        VectorMask<Float> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2233,1 +2233,1 @@\n-                                                                  (broadcast((float)(origin))));\n+                                                                  broadcast((float)(origin)));\n@@ -2773,1 +2773,1 @@\n-            res[i] = (double) a[i];\n+            res[i] = ((double) a[i]);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,917 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat128Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_128;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat128Vector> VCLASS = Halffloat128Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+    Halffloat128Vector(Float16[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat128Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat128Vector(Object v) {\n+        this((Float16[]) v);\n+    }\n+\n+    static final Halffloat128Vector ZERO = new Halffloat128Vector(new Float16[VLENGTH]);\n+    static final Halffloat128Vector IOTA = new Halffloat128Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return Float16.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    Float16[] vec() {\n+        return (Float16[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Vector broadcast(Float16 e) {\n+        return (Halffloat128Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Vector broadcast(long e) {\n+        return (Halffloat128Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat128Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle iotaShuffle() { return Halffloat128Shuffle.IOTA; }\n+\n+    @ForceInline\n+    Halffloat128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Halffloat128Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Halffloat128Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromBytes(byte[] reorder) { return new Halffloat128Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromArray(int[] indexes, int i) { return new Halffloat128Shuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat128Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat128Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector vectorFactory(Float16[] vec) {\n+        return new Halffloat128Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte128Vector asByteVectorRaw() {\n+        return (Byte128Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector uOp(FUnOp f) {\n+        return (Halffloat128Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat128Vector)\n+            super.uOpTemplate((Halffloat128Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat128Vector) super.bOpTemplate((Halffloat128Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat128Vector)\n+            super.bOpTemplate((Halffloat128Vector)v, (Halffloat128Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat128Vector)\n+            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat128Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat128Vector)\n+            super.tOpTemplate((Halffloat128Vector)v1, (Halffloat128Vector)v2,\n+                              (Halffloat128Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Float16 rOp(Float16 v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Unary op) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat128Vector) super.lanewiseTemplate(op, Halffloat128Mask.class, v1, v2, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat128Vector addIndex(int scale) {\n+        return (Halffloat128Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final Float16 reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Float16 reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        Float16 res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return res.longValue();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        Float16 res = super.reduceLanesTemplate(op, Halffloat128Mask.class, (Halffloat128Mask) m);  \/\/ specialized\n+        return res.longValue();\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Float16> toShuffle() {\n+        return super.toShuffleTemplate(Halffloat128Shuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask test(Test op) {\n+        return super.testTemplate(Halffloat128Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat128Mask.class, op, (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, Float16 s) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat128Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat128Mask.class, op, v, (Halffloat128Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.blendTemplate(Halffloat128Mask.class,\n+                                (Halffloat128Vector) v,\n+                                (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat128Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector slice(int origin) {\n+        return (Halffloat128Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat128Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.unsliceTemplate(Halffloat128Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector unslice(int origin) {\n+        return (Halffloat128Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    (Halffloat128Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    Halffloat128Mask.class,\n+                                    (Halffloat128Shuffle) shuffle,\n+                                    (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat128Vector)\n+            super.rearrangeTemplate(Halffloat128Shuffle.class,\n+                                    (Halffloat128Shuffle) s,\n+                                    (Halffloat128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.compressTemplate(Halffloat128Mask.class,\n+                                   (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.expandTemplate(Halffloat128Mask.class,\n+                                   (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat128Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat128Vector)\n+            super.selectFromTemplate((Halffloat128Vector) v,\n+                                     (Halffloat128Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public Float16 lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Float16.shortBitsToFloat16(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     Float16[] vecarr = vec.vec();\n+                     return (long)Float16.float16ToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat128Vector withLane(int i, Float16 e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat128Vector withLaneHelper(int i, Float16 e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Float16.float16ToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    Float16[] res = v.vec().clone();\n+                                    res[ix] = Float16.shortBitsToFloat16((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat128Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+        Halffloat128Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat128Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat128Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat128Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat128Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat128Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat128Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat128Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat128Vector toVector() {\n+            return (Halffloat128Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat128Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat128Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat128Mask.class, ETYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat128Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask compress() {\n+            return (Halffloat128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat128Vector.class, Halffloat128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat128Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat128Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat128Mask m = (Halffloat128Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat128Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat128Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat128Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat128Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat128Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat128Mask.class, Float16.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat128Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat128Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat128Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat128Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat128Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat128Mask  TRUE_MASK = new Halffloat128Mask(true);\n+        private static final Halffloat128Mask FALSE_MASK = new Halffloat128Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat128Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+        Halffloat128Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat128Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat128Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n+        }\n+\n+        public Halffloat128Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n+        }\n+\n+        @Override\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat128Shuffle IOTA = new Halffloat128Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat128Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Halffloat128Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Halffloat128Vector)(((AbstractShuffle<Float16>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Halffloat128Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat128Shuffle s = (Halffloat128Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            }\n+            return new Halffloat128Shuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(Float16[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(Float16[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat128Mask.class, ms, offset, (Halffloat128Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(Float16[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(Float16[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat128Mask.class, a, offset, (Halffloat128Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat128Mask.class, ms, offset, (Halffloat128Mask) m);\n+    }\n+\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat128Vector.java","additions":917,"deletions":0,"binary":false,"changes":917,"status":"added"},{"patch":"@@ -0,0 +1,933 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat256Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_256;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat256Vector> VCLASS = Halffloat256Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+    Halffloat256Vector(Float16[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat256Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat256Vector(Object v) {\n+        this((Float16[]) v);\n+    }\n+\n+    static final Halffloat256Vector ZERO = new Halffloat256Vector(new Float16[VLENGTH]);\n+    static final Halffloat256Vector IOTA = new Halffloat256Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return Float16.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    Float16[] vec() {\n+        return (Float16[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Vector broadcast(Float16 e) {\n+        return (Halffloat256Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Vector broadcast(long e) {\n+        return (Halffloat256Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat256Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle iotaShuffle() { return Halffloat256Shuffle.IOTA; }\n+\n+    @ForceInline\n+    Halffloat256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Halffloat256Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Halffloat256Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromBytes(byte[] reorder) { return new Halffloat256Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromArray(int[] indexes, int i) { return new Halffloat256Shuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat256Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat256Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector vectorFactory(Float16[] vec) {\n+        return new Halffloat256Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte256Vector asByteVectorRaw() {\n+        return (Byte256Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector uOp(FUnOp f) {\n+        return (Halffloat256Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat256Vector)\n+            super.uOpTemplate((Halffloat256Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat256Vector) super.bOpTemplate((Halffloat256Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat256Vector)\n+            super.bOpTemplate((Halffloat256Vector)v, (Halffloat256Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat256Vector)\n+            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat256Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat256Vector)\n+            super.tOpTemplate((Halffloat256Vector)v1, (Halffloat256Vector)v2,\n+                              (Halffloat256Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Float16 rOp(Float16 v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Unary op) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat256Vector) super.lanewiseTemplate(op, Halffloat256Mask.class, v1, v2, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat256Vector addIndex(int scale) {\n+        return (Halffloat256Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final Float16 reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Float16 reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        Float16 res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return res.longValue();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        Float16 res = super.reduceLanesTemplate(op, Halffloat256Mask.class, (Halffloat256Mask) m);  \/\/ specialized\n+        return res.longValue();\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Float16> toShuffle() {\n+        return super.toShuffleTemplate(Halffloat256Shuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask test(Test op) {\n+        return super.testTemplate(Halffloat256Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat256Mask.class, op, (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, Float16 s) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat256Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat256Mask.class, op, v, (Halffloat256Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.blendTemplate(Halffloat256Mask.class,\n+                                (Halffloat256Vector) v,\n+                                (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat256Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector slice(int origin) {\n+        return (Halffloat256Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat256Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.unsliceTemplate(Halffloat256Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector unslice(int origin) {\n+        return (Halffloat256Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    (Halffloat256Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    Halffloat256Mask.class,\n+                                    (Halffloat256Shuffle) shuffle,\n+                                    (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat256Vector)\n+            super.rearrangeTemplate(Halffloat256Shuffle.class,\n+                                    (Halffloat256Shuffle) s,\n+                                    (Halffloat256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.compressTemplate(Halffloat256Mask.class,\n+                                   (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.expandTemplate(Halffloat256Mask.class,\n+                                   (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat256Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat256Vector)\n+            super.selectFromTemplate((Halffloat256Vector) v,\n+                                     (Halffloat256Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public Float16 lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            case 8: bits = laneHelper(8); break;\n+            case 9: bits = laneHelper(9); break;\n+            case 10: bits = laneHelper(10); break;\n+            case 11: bits = laneHelper(11); break;\n+            case 12: bits = laneHelper(12); break;\n+            case 13: bits = laneHelper(13); break;\n+            case 14: bits = laneHelper(14); break;\n+            case 15: bits = laneHelper(15); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Float16.shortBitsToFloat16(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     Float16[] vecarr = vec.vec();\n+                     return (long)Float16.float16ToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat256Vector withLane(int i, Float16 e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            case 8: return withLaneHelper(8, e);\n+            case 9: return withLaneHelper(9, e);\n+            case 10: return withLaneHelper(10, e);\n+            case 11: return withLaneHelper(11, e);\n+            case 12: return withLaneHelper(12, e);\n+            case 13: return withLaneHelper(13, e);\n+            case 14: return withLaneHelper(14, e);\n+            case 15: return withLaneHelper(15, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat256Vector withLaneHelper(int i, Float16 e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Float16.float16ToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    Float16[] res = v.vec().clone();\n+                                    res[ix] = Float16.shortBitsToFloat16((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat256Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+        Halffloat256Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat256Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat256Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat256Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat256Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat256Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat256Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat256Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat256Vector toVector() {\n+            return (Halffloat256Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat256Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat256Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat256Mask.class, ETYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat256Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask compress() {\n+            return (Halffloat256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat256Vector.class, Halffloat256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat256Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat256Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat256Mask m = (Halffloat256Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat256Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat256Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat256Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat256Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat256Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat256Mask.class, Float16.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat256Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat256Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat256Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat256Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat256Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat256Mask  TRUE_MASK = new Halffloat256Mask(true);\n+        private static final Halffloat256Mask FALSE_MASK = new Halffloat256Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat256Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+        Halffloat256Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat256Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat256Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n+        }\n+\n+        public Halffloat256Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n+        }\n+\n+        @Override\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat256Shuffle IOTA = new Halffloat256Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat256Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Halffloat256Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Halffloat256Vector)(((AbstractShuffle<Float16>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Halffloat256Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat256Shuffle s = (Halffloat256Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            }\n+            return new Halffloat256Shuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(Float16[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(Float16[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat256Mask.class, ms, offset, (Halffloat256Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(Float16[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(Float16[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat256Mask.class, a, offset, (Halffloat256Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat256Mask.class, ms, offset, (Halffloat256Mask) m);\n+    }\n+\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat256Vector.java","additions":933,"deletions":0,"binary":false,"changes":933,"status":"added"},{"patch":"@@ -0,0 +1,933 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat512Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_512;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat512Vector> VCLASS = Halffloat512Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+    Halffloat512Vector(Float16[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat512Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat512Vector(Object v) {\n+        this((Float16[]) v);\n+    }\n+\n+    static final Halffloat512Vector ZERO = new Halffloat512Vector(new Float16[VLENGTH]);\n+    static final Halffloat512Vector IOTA = new Halffloat512Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return Float16.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    Float16[] vec() {\n+        return (Float16[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Vector broadcast(Float16 e) {\n+        return (Halffloat512Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Vector broadcast(long e) {\n+        return (Halffloat512Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat512Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle iotaShuffle() { return Halffloat512Shuffle.IOTA; }\n+\n+    @ForceInline\n+    Halffloat512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Halffloat512Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Halffloat512Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromBytes(byte[] reorder) { return new Halffloat512Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromArray(int[] indexes, int i) { return new Halffloat512Shuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat512Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat512Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector vectorFactory(Float16[] vec) {\n+        return new Halffloat512Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte512Vector asByteVectorRaw() {\n+        return (Byte512Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector uOp(FUnOp f) {\n+        return (Halffloat512Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat512Vector)\n+            super.uOpTemplate((Halffloat512Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat512Vector) super.bOpTemplate((Halffloat512Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat512Vector)\n+            super.bOpTemplate((Halffloat512Vector)v, (Halffloat512Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat512Vector)\n+            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat512Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat512Vector)\n+            super.tOpTemplate((Halffloat512Vector)v1, (Halffloat512Vector)v2,\n+                              (Halffloat512Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Float16 rOp(Float16 v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Unary op) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat512Vector) super.lanewiseTemplate(op, Halffloat512Mask.class, v1, v2, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat512Vector addIndex(int scale) {\n+        return (Halffloat512Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final Float16 reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Float16 reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        Float16 res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return res.longValue();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        Float16 res = super.reduceLanesTemplate(op, Halffloat512Mask.class, (Halffloat512Mask) m);  \/\/ specialized\n+        return res.longValue();\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Float16> toShuffle() {\n+        return super.toShuffleTemplate(Halffloat512Shuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask test(Test op) {\n+        return super.testTemplate(Halffloat512Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat512Mask.class, op, (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, Float16 s) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat512Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat512Mask.class, op, v, (Halffloat512Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.blendTemplate(Halffloat512Mask.class,\n+                                (Halffloat512Vector) v,\n+                                (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat512Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector slice(int origin) {\n+        return (Halffloat512Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat512Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.unsliceTemplate(Halffloat512Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector unslice(int origin) {\n+        return (Halffloat512Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    (Halffloat512Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    Halffloat512Mask.class,\n+                                    (Halffloat512Shuffle) shuffle,\n+                                    (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat512Vector)\n+            super.rearrangeTemplate(Halffloat512Shuffle.class,\n+                                    (Halffloat512Shuffle) s,\n+                                    (Halffloat512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.compressTemplate(Halffloat512Mask.class,\n+                                   (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.expandTemplate(Halffloat512Mask.class,\n+                                   (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat512Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat512Vector)\n+            super.selectFromTemplate((Halffloat512Vector) v,\n+                                     (Halffloat512Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public Float16 lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            case 4: bits = laneHelper(4); break;\n+            case 5: bits = laneHelper(5); break;\n+            case 6: bits = laneHelper(6); break;\n+            case 7: bits = laneHelper(7); break;\n+            case 8: bits = laneHelper(8); break;\n+            case 9: bits = laneHelper(9); break;\n+            case 10: bits = laneHelper(10); break;\n+            case 11: bits = laneHelper(11); break;\n+            case 12: bits = laneHelper(12); break;\n+            case 13: bits = laneHelper(13); break;\n+            case 14: bits = laneHelper(14); break;\n+            case 15: bits = laneHelper(15); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Float16.shortBitsToFloat16(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     Float16[] vecarr = vec.vec();\n+                     return (long)Float16.float16ToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat512Vector withLane(int i, Float16 e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            case 4: return withLaneHelper(4, e);\n+            case 5: return withLaneHelper(5, e);\n+            case 6: return withLaneHelper(6, e);\n+            case 7: return withLaneHelper(7, e);\n+            case 8: return withLaneHelper(8, e);\n+            case 9: return withLaneHelper(9, e);\n+            case 10: return withLaneHelper(10, e);\n+            case 11: return withLaneHelper(11, e);\n+            case 12: return withLaneHelper(12, e);\n+            case 13: return withLaneHelper(13, e);\n+            case 14: return withLaneHelper(14, e);\n+            case 15: return withLaneHelper(15, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat512Vector withLaneHelper(int i, Float16 e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Float16.float16ToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    Float16[] res = v.vec().clone();\n+                                    res[ix] = Float16.shortBitsToFloat16((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat512Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+        Halffloat512Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat512Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat512Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat512Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat512Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat512Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat512Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat512Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat512Vector toVector() {\n+            return (Halffloat512Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat512Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat512Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat512Mask.class, ETYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat512Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask compress() {\n+            return (Halffloat512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat512Vector.class, Halffloat512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat512Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat512Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat512Mask m = (Halffloat512Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat512Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat512Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat512Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat512Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat512Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat512Mask.class, Float16.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat512Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat512Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat512Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat512Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat512Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat512Mask  TRUE_MASK = new Halffloat512Mask(true);\n+        private static final Halffloat512Mask FALSE_MASK = new Halffloat512Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat512Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+        Halffloat512Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat512Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat512Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n+        }\n+\n+        public Halffloat512Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n+        }\n+\n+        @Override\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat512Shuffle IOTA = new Halffloat512Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat512Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Halffloat512Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Halffloat512Vector)(((AbstractShuffle<Float16>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Halffloat512Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat512Shuffle s = (Halffloat512Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            }\n+            return new Halffloat512Shuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(Float16[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(Float16[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat512Mask.class, ms, offset, (Halffloat512Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(Float16[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(Float16[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat512Mask.class, a, offset, (Halffloat512Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat512Mask.class, ms, offset, (Halffloat512Mask) m);\n+    }\n+\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat512Vector.java","additions":933,"deletions":0,"binary":false,"changes":933,"status":"added"},{"patch":"@@ -0,0 +1,909 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class Halffloat64Vector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_64;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<Halffloat64Vector> VCLASS = Halffloat64Vector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+    Halffloat64Vector(Float16[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as Halffloat64Vector::new,\n+    \/\/ stored into species.vectorFactory.\n+    Halffloat64Vector(Object v) {\n+        this((Float16[]) v);\n+    }\n+\n+    static final Halffloat64Vector ZERO = new Halffloat64Vector(new Float16[VLENGTH]);\n+    static final Halffloat64Vector IOTA = new Halffloat64Vector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return Float16.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    Float16[] vec() {\n+        return (Float16[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Vector broadcast(Float16 e) {\n+        return (Halffloat64Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Vector broadcast(long e) {\n+        return (Halffloat64Vector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Mask maskFromArray(boolean[] bits) {\n+        return new Halffloat64Mask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle iotaShuffle() { return Halffloat64Shuffle.IOTA; }\n+\n+    @ForceInline\n+    Halffloat64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (Halffloat64Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (Halffloat64Shuffle)VectorSupport.shuffleIota(ETYPE, Halffloat64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromBytes(byte[] reorder) { return new Halffloat64Shuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromArray(int[] indexes, int i) { return new Halffloat64Shuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    Halffloat64Shuffle shuffleFromOp(IntUnaryOperator fn) { return new Halffloat64Shuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector vectorFactory(Float16[] vec) {\n+        return new Halffloat64Vector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Byte64Vector asByteVectorRaw() {\n+        return (Byte64Vector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector uOp(FUnOp f) {\n+        return (Halffloat64Vector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (Halffloat64Vector)\n+            super.uOpTemplate((Halffloat64Mask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector bOp(Vector<Float16> v, FBinOp f) {\n+        return (Halffloat64Vector) super.bOpTemplate((Halffloat64Vector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (Halffloat64Vector)\n+            super.bOpTemplate((Halffloat64Vector)v, (Halffloat64Mask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (Halffloat64Vector)\n+            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Halffloat64Vector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (Halffloat64Vector)\n+            super.tOpTemplate((Halffloat64Vector)v1, (Halffloat64Vector)v2,\n+                              (Halffloat64Mask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Float16 rOp(Float16 v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Unary op) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Binary op, Vector<Float16> v) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (Halffloat64Vector) super.lanewiseTemplate(op, Halffloat64Mask.class, v1, v2, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    Halffloat64Vector addIndex(int scale) {\n+        return (Halffloat64Vector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final Float16 reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Float16 reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        Float16 res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return res.longValue();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        Float16 res = super.reduceLanesTemplate(op, Halffloat64Mask.class, (Halffloat64Mask) m);  \/\/ specialized\n+        return res.longValue();\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Float16> toShuffle() {\n+        return super.toShuffleTemplate(Halffloat64Shuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask test(Test op) {\n+        return super.testTemplate(Halffloat64Mask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(Halffloat64Mask.class, op, (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, Float16 s) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, long s) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Halffloat64Mask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(Halffloat64Mask.class, op, v, (Halffloat64Mask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.blendTemplate(Halffloat64Mask.class,\n+                                (Halffloat64Vector) v,\n+                                (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector slice(int origin, Vector<Float16> v) {\n+        return (Halffloat64Vector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector slice(int origin) {\n+        return (Halffloat64Vector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin, Vector<Float16> w, int part) {\n+        return (Halffloat64Vector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.unsliceTemplate(Halffloat64Mask.class,\n+                                  origin, w, part,\n+                                  (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector unslice(int origin) {\n+        return (Halffloat64Vector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Float16> s) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    (Halffloat64Shuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    Halffloat64Mask.class,\n+                                    (Halffloat64Shuffle) shuffle,\n+                                    (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (Halffloat64Vector)\n+            super.rearrangeTemplate(Halffloat64Shuffle.class,\n+                                    (Halffloat64Shuffle) s,\n+                                    (Halffloat64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector compress(VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.compressTemplate(Halffloat64Mask.class,\n+                                   (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector expand(VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.expandTemplate(Halffloat64Mask.class,\n+                                   (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Float16> v) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Halffloat64Vector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (Halffloat64Vector)\n+            super.selectFromTemplate((Halffloat64Vector) v,\n+                                     (Halffloat64Mask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public Float16 lane(int i) {\n+        short bits;\n+        switch(i) {\n+            case 0: bits = laneHelper(0); break;\n+            case 1: bits = laneHelper(1); break;\n+            case 2: bits = laneHelper(2); break;\n+            case 3: bits = laneHelper(3); break;\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return Float16.shortBitsToFloat16(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     Float16[] vecarr = vec.vec();\n+                     return (long)Float16.float16ToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public Halffloat64Vector withLane(int i, Float16 e) {\n+        switch(i) {\n+            case 0: return withLaneHelper(0, e);\n+            case 1: return withLaneHelper(1, e);\n+            case 2: return withLaneHelper(2, e);\n+            case 3: return withLaneHelper(3, e);\n+            default: throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+    }\n+\n+    public Halffloat64Vector withLaneHelper(int i, Float16 e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Float16.float16ToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    Float16[] res = v.vec().clone();\n+                                    res[ix] = Float16.shortBitsToFloat16((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class Halffloat64Mask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+        Halffloat64Mask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        Halffloat64Mask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        Halffloat64Mask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        Halffloat64Mask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new Halffloat64Mask(res);\n+        }\n+\n+        @Override\n+        Halffloat64Mask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((Halffloat64Mask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new Halffloat64Mask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        Halffloat64Vector toVector() {\n+            return (Halffloat64Vector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        Halffloat64Mask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (Halffloat64Mask) VectorSupport.indexPartiallyInUpperRange(\n+                Halffloat64Mask.class, ETYPE, VLENGTH, offset, limit,\n+                (o, l) -> (Halffloat64Mask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask compress() {\n+            return (Halffloat64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Halffloat64Vector.class, Halffloat64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, Halffloat64Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, Halffloat64Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Mask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            Halffloat64Mask m = (Halffloat64Mask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, Halffloat64Mask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Halffloat64Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Halffloat64Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Halffloat64Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, Halffloat64Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(Halffloat64Mask.class, Float16.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, Halffloat64Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((Halffloat64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, Halffloat64Mask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((Halffloat64Mask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static Halffloat64Mask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(Halffloat64Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final Halffloat64Mask  TRUE_MASK = new Halffloat64Mask(true);\n+        private static final Halffloat64Mask FALSE_MASK = new Halffloat64Mask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class Halffloat64Shuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+        Halffloat64Shuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat64Shuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public Halffloat64Shuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n+        }\n+\n+        public Halffloat64Shuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n+        }\n+\n+        @Override\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final Halffloat64Shuffle IOTA = new Halffloat64Shuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public Halffloat64Vector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Halffloat64Shuffle.class, this, VLENGTH,\n+                                                    (s) -> ((Halffloat64Vector)(((AbstractShuffle<Float16>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Halffloat64Shuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            Halffloat64Shuffle s = (Halffloat64Shuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            }\n+            return new Halffloat64Shuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(Float16[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(Float16[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(Halffloat64Mask.class, ms, offset, (Halffloat64Mask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(Float16[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(Float16[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(Halffloat64Mask.class, a, offset, (Halffloat64Mask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(Halffloat64Mask.class, ms, offset, (Halffloat64Mask) m);\n+    }\n+\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Halffloat64Vector.java","additions":909,"deletions":0,"binary":false,"changes":909,"status":"added"},{"patch":"@@ -0,0 +1,902 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+final class HalffloatMaxVector extends HalffloatVector {\n+    static final HalffloatSpecies VSPECIES =\n+        (HalffloatSpecies) HalffloatVector.SPECIES_MAX;\n+\n+    static final VectorShape VSHAPE =\n+        VSPECIES.vectorShape();\n+\n+    static final Class<HalffloatMaxVector> VCLASS = HalffloatMaxVector.class;\n+\n+    static final int VSIZE = VSPECIES.vectorBitSize();\n+\n+    static final int VLENGTH = VSPECIES.laneCount(); \/\/ used by the JVM\n+\n+    static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+    HalffloatMaxVector(Float16[] v) {\n+        super(v);\n+    }\n+\n+    \/\/ For compatibility as HalffloatMaxVector::new,\n+    \/\/ stored into species.vectorFactory.\n+    HalffloatMaxVector(Object v) {\n+        this((Float16[]) v);\n+    }\n+\n+    static final HalffloatMaxVector ZERO = new HalffloatMaxVector(new Float16[VLENGTH]);\n+    static final HalffloatMaxVector IOTA = new HalffloatMaxVector(VSPECIES.iotaArray());\n+\n+    static {\n+        \/\/ Warm up a few species caches.\n+        \/\/ If we do this too much we will\n+        \/\/ get NPEs from bootstrap circularity.\n+        VSPECIES.dummyVector();\n+        VSPECIES.withLanes(LaneType.BYTE);\n+    }\n+\n+    \/\/ Specialized extractors\n+\n+    @ForceInline\n+    final @Override\n+    public HalffloatSpecies vspecies() {\n+        \/\/ ISSUE:  This should probably be a @Stable\n+        \/\/ field inside AbstractVector, rather than\n+        \/\/ a megamorphic method.\n+        return VSPECIES;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public final Class<Float16> elementType() { return Float16.class; }\n+\n+    @ForceInline\n+    @Override\n+    public final int elementSize() { return Float16.SIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final VectorShape shape() { return VSHAPE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int length() { return VLENGTH; }\n+\n+    @ForceInline\n+    @Override\n+    public final int bitSize() { return VSIZE; }\n+\n+    @ForceInline\n+    @Override\n+    public final int byteSize() { return VSIZE \/ Byte.SIZE; }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final @Override\n+    Float16[] vec() {\n+        return (Float16[])getPayload();\n+    }\n+\n+    \/\/ Virtualized constructors\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxVector broadcast(Float16 e) {\n+        return (HalffloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxVector broadcast(long e) {\n+        return (HalffloatMaxVector) super.broadcastTemplate(e);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxMask maskFromArray(boolean[] bits) {\n+        return new HalffloatMaxMask(bits);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle iotaShuffle() { return HalffloatMaxShuffle.IOTA; }\n+\n+    @ForceInline\n+    HalffloatMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n+      if (wrap) {\n+        return (HalffloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, HalffloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n+      } else {\n+        return (HalffloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, HalffloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n+                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n+      }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromBytes(byte[] reorder) { return new HalffloatMaxShuffle(reorder); }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromArray(int[] indexes, int i) { return new HalffloatMaxShuffle(indexes, i); }\n+\n+    @Override\n+    @ForceInline\n+    HalffloatMaxShuffle shuffleFromOp(IntUnaryOperator fn) { return new HalffloatMaxShuffle(fn); }\n+\n+    \/\/ Make a vector of the same species but the given elements:\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector vectorFactory(Float16[] vec) {\n+        return new HalffloatMaxVector(vec);\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    ByteMaxVector asByteVectorRaw() {\n+        return (ByteMaxVector) super.asByteVectorRawTemplate();  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    AbstractVector<?> asVectorRaw(LaneType laneType) {\n+        return super.asVectorRawTemplate(laneType);  \/\/ specialize\n+    }\n+\n+    \/\/ Unary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector uOp(FUnOp f) {\n+        return (HalffloatMaxVector) super.uOpTemplate(f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector uOp(VectorMask<Float16> m, FUnOp f) {\n+        return (HalffloatMaxVector)\n+            super.uOpTemplate((HalffloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    \/\/ Binary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector bOp(Vector<Float16> v, FBinOp f) {\n+        return (HalffloatMaxVector) super.bOpTemplate((HalffloatMaxVector)v, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector bOp(Vector<Float16> v,\n+                     VectorMask<Float16> m, FBinOp f) {\n+        return (HalffloatMaxVector)\n+            super.bOpTemplate((HalffloatMaxVector)v, (HalffloatMaxMask)m,\n+                              f);  \/\/ specialize\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector tOp(Vector<Float16> v1, Vector<Float16> v2, FTriOp f) {\n+        return (HalffloatMaxVector)\n+            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,\n+                              f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    HalffloatMaxVector tOp(Vector<Float16> v1, Vector<Float16> v2,\n+                     VectorMask<Float16> m, FTriOp f) {\n+        return (HalffloatMaxVector)\n+            super.tOpTemplate((HalffloatMaxVector)v1, (HalffloatMaxVector)v2,\n+                              (HalffloatMaxMask)m, f);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    final @Override\n+    Float16 rOp(Float16 v, VectorMask<Float16> m, FBinOp f) {\n+        return super.rOpTemplate(v, m, f);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> convertShape(VectorOperators.Conversion<Float16,F> conv,\n+                           VectorSpecies<F> rsp, int part) {\n+        return super.convertShapeTemplate(conv, rsp, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final <F>\n+    Vector<F> reinterpretShape(VectorSpecies<F> toSpecies, int part) {\n+        return super.reinterpretShapeTemplate(toSpecies, part);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized algebraic operations:\n+\n+    \/\/ The following definition forces a specialized version of this\n+    \/\/ crucial method into the v-table of this class.  A call to add()\n+    \/\/ will inline to a call to lanewise(ADD,), at which point the JIT\n+    \/\/ intrinsic will have the opcode of ADD, plus all the metadata\n+    \/\/ for this particular class, enabling it to generate precise\n+    \/\/ code.\n+    \/\/\n+    \/\/ There is probably no benefit to the JIT to specialize the\n+    \/\/ masked or broadcast versions of the lanewise method.\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Unary op) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Unary op, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Binary op, Vector<Float16> v) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector lanewise(Binary op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, v1, v2);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector\n+    lanewise(Ternary op, Vector<Float16> v1, Vector<Float16> v2, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector) super.lanewiseTemplate(op, HalffloatMaxMask.class, v1, v2, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatMaxVector addIndex(int scale) {\n+        return (HalffloatMaxVector) super.addIndexTemplate(scale);  \/\/ specialize\n+    }\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    @Override\n+    @ForceInline\n+    public final Float16 reduceLanes(VectorOperators.Associative op) {\n+        return super.reduceLanesTemplate(op);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Float16 reduceLanes(VectorOperators.Associative op,\n+                                    VectorMask<Float16> m) {\n+        return super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialized\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op) {\n+        Float16 res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return res.longValue();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final long reduceLanesToLong(VectorOperators.Associative op,\n+                                        VectorMask<Float16> m) {\n+        Float16 res = super.reduceLanesTemplate(op, HalffloatMaxMask.class, (HalffloatMaxMask) m);  \/\/ specialized\n+        return res.longValue();\n+    }\n+\n+    @ForceInline\n+    public VectorShuffle<Float16> toShuffle() {\n+        return super.toShuffleTemplate(HalffloatMaxShuffle.class); \/\/ specialize\n+    }\n+\n+    \/\/ Specialized unary testing\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask test(Test op) {\n+        return super.testTemplate(HalffloatMaxMask.class, op);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask test(Test op, VectorMask<Float16> m) {\n+        return super.testTemplate(HalffloatMaxMask.class, op, (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    \/\/ Specialized comparisons\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, Vector<Float16> v) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, Float16 s) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, long s) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final HalffloatMaxMask compare(Comparison op, Vector<Float16> v, VectorMask<Float16> m) {\n+        return super.compareTemplate(HalffloatMaxMask.class, op, v, (HalffloatMaxMask) m);\n+    }\n+\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector blend(Vector<Float16> v, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.blendTemplate(HalffloatMaxMask.class,\n+                                (HalffloatMaxVector) v,\n+                                (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector slice(int origin, Vector<Float16> v) {\n+        return (HalffloatMaxVector) super.sliceTemplate(origin, v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector slice(int origin) {\n+        return (HalffloatMaxVector) super.sliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin, Vector<Float16> w, int part) {\n+        return (HalffloatMaxVector) super.unsliceTemplate(origin, w, part);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.unsliceTemplate(HalffloatMaxMask.class,\n+                                  origin, w, part,\n+                                  (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector unslice(int origin) {\n+        return (HalffloatMaxVector) super.unsliceTemplate(origin);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Float16> s) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    (HalffloatMaxShuffle) s);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Float16> shuffle,\n+                                  VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    HalffloatMaxMask.class,\n+                                    (HalffloatMaxShuffle) shuffle,\n+                                    (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector rearrange(VectorShuffle<Float16> s,\n+                                  Vector<Float16> v) {\n+        return (HalffloatMaxVector)\n+            super.rearrangeTemplate(HalffloatMaxShuffle.class,\n+                                    (HalffloatMaxShuffle) s,\n+                                    (HalffloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector compress(VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.compressTemplate(HalffloatMaxMask.class,\n+                                   (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector expand(VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.expandTemplate(HalffloatMaxMask.class,\n+                                   (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Float16> v) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public HalffloatMaxVector selectFrom(Vector<Float16> v,\n+                                   VectorMask<Float16> m) {\n+        return (HalffloatMaxVector)\n+            super.selectFromTemplate((HalffloatMaxVector) v,\n+                                     (HalffloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+\n+    @ForceInline\n+    @Override\n+    public Float16 lane(int i) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        short bits = laneHelper(i);\n+        return Float16.shortBitsToFloat16(bits);\n+    }\n+\n+    public short laneHelper(int i) {\n+        return (short) VectorSupport.extract(\n+                     VCLASS, ETYPE, VLENGTH,\n+                     this, i,\n+                     (vec, ix) -> {\n+                     Float16[] vecarr = vec.vec();\n+                     return (long)Float16.float16ToShortBits(vecarr[ix]);\n+                     });\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public HalffloatMaxVector withLane(int i, Float16 e) {\n+        if (i < 0 || i >= VLENGTH) {\n+            throw new IllegalArgumentException(\"Index \" + i + \" must be zero or positive, and less than \" + VLENGTH);\n+        }\n+        return withLaneHelper(i, e);\n+    }\n+\n+    public HalffloatMaxVector withLaneHelper(int i, Float16 e) {\n+        return VectorSupport.insert(\n+                                VCLASS, ETYPE, VLENGTH,\n+                                this, i, (long)Float16.float16ToShortBits(e),\n+                                (v, ix, bits) -> {\n+                                    Float16[] res = v.vec().clone();\n+                                    res[ix] = Float16.shortBitsToFloat16((short)bits);\n+                                    return v.vectorFactory(res);\n+                                });\n+    }\n+\n+    \/\/ Mask\n+\n+    static final class HalffloatMaxMask extends AbstractMask<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+        HalffloatMaxMask(boolean[] bits) {\n+            this(bits, 0);\n+        }\n+\n+        HalffloatMaxMask(boolean[] bits, int offset) {\n+            super(prepare(bits, offset));\n+        }\n+\n+        HalffloatMaxMask(boolean val) {\n+            super(prepare(val));\n+        }\n+\n+        private static boolean[] prepare(boolean[] bits, int offset) {\n+            boolean[] newBits = new boolean[VSPECIES.laneCount()];\n+            for (int i = 0; i < newBits.length; i++) {\n+                newBits[i] = bits[offset + i];\n+            }\n+            return newBits;\n+        }\n+\n+        private static boolean[] prepare(boolean val) {\n+            boolean[] bits = new boolean[VSPECIES.laneCount()];\n+            Arrays.fill(bits, val);\n+            return bits;\n+        }\n+\n+        @ForceInline\n+        final @Override\n+        public HalffloatSpecies vspecies() {\n+            \/\/ ISSUE:  This should probably be a @Stable\n+            \/\/ field inside AbstractMask, rather than\n+            \/\/ a megamorphic method.\n+            return VSPECIES;\n+        }\n+\n+        @ForceInline\n+        boolean[] getBits() {\n+            return (boolean[])getPayload();\n+        }\n+\n+        @Override\n+        HalffloatMaxMask uOp(MUnOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i]);\n+            }\n+            return new HalffloatMaxMask(res);\n+        }\n+\n+        @Override\n+        HalffloatMaxMask bOp(VectorMask<Float16> m, MBinOp f) {\n+            boolean[] res = new boolean[vspecies().laneCount()];\n+            boolean[] bits = getBits();\n+            boolean[] mbits = ((HalffloatMaxMask)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i, bits[i], mbits[i]);\n+            }\n+            return new HalffloatMaxMask(res);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public final\n+        HalffloatMaxVector toVector() {\n+            return (HalffloatMaxVector) super.toVectorTemplate();  \/\/ specialize\n+        }\n+\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+            boolean[] maskArray = toArray();\n+            return  dsp.maskFactory(maskArray).check(dsp);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n+\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                this.getClass(), ETYPE, VLENGTH,\n+                species.maskType(), species.elementType(), VLENGTH,\n+                this, species,\n+                (m, s) -> s.maskFactory(m.toArray()).check(s));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        \/*package-private*\/\n+        HalffloatMaxMask indexPartiallyInUpperRange(long offset, long limit) {\n+            return (HalffloatMaxMask) VectorSupport.indexPartiallyInUpperRange(\n+                HalffloatMaxMask.class, ETYPE, VLENGTH, offset, limit,\n+                (o, l) -> (HalffloatMaxMask) TRUE_MASK.indexPartiallyInRange(o, l));\n+        }\n+\n+        \/\/ Unary operations\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask not() {\n+            return xor(maskAll(true));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask compress() {\n+            return (HalffloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                HalffloatMaxVector.class, HalffloatMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+        }\n+\n+\n+        \/\/ Binary operations\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask and(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, HalffloatMaxMask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a & b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask or(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, HalffloatMaxMask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a | b));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxMask xor(VectorMask<Float16> mask) {\n+            Objects.requireNonNull(mask);\n+            HalffloatMaxMask m = (HalffloatMaxMask)mask;\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, HalffloatMaxMask.class, null, short.class, VLENGTH,\n+                                          this, m, null,\n+                                          (m1, m2, vm) -> m1.bOp(m2, (i, a, b) -> a ^ b));\n+        }\n+\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, HalffloatMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, HalffloatMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, HalffloatMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(m.getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public long toLong() {\n+            if (length() > Long.SIZE) {\n+                throw new UnsupportedOperationException(\"too many lanes for one long\");\n+            }\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, HalffloatMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> toLongHelper(m.getBits()));\n+        }\n+\n+        \/\/ laneIsSet\n+\n+        @Override\n+        @ForceInline\n+        public boolean laneIsSet(int i) {\n+            Objects.checkIndex(i, length());\n+            return VectorSupport.extract(HalffloatMaxMask.class, Float16.class, VLENGTH,\n+                                         this, i, (m, idx) -> (m.getBits()[idx] ? 1L : 0L)) == 1L;\n+        }\n+\n+        \/\/ Reductions\n+\n+        @Override\n+        @ForceInline\n+        public boolean anyTrue() {\n+            return VectorSupport.test(BT_ne, HalffloatMaxMask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> anyTrueHelper(((HalffloatMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public boolean allTrue() {\n+            return VectorSupport.test(BT_overflow, HalffloatMaxMask.class, short.class, VLENGTH,\n+                                         this, vspecies().maskAll(true),\n+                                         (m, __) -> allTrueHelper(((HalffloatMaxMask)m).getBits()));\n+        }\n+\n+        @ForceInline\n+        \/*package-private*\/\n+        static HalffloatMaxMask maskAll(boolean bit) {\n+            return VectorSupport.fromBitsCoerced(HalffloatMaxMask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+        }\n+        private static final HalffloatMaxMask  TRUE_MASK = new HalffloatMaxMask(true);\n+        private static final HalffloatMaxMask FALSE_MASK = new HalffloatMaxMask(false);\n+\n+    }\n+\n+    \/\/ Shuffle\n+\n+    static final class HalffloatMaxShuffle extends AbstractShuffle<Float16> {\n+        static final int VLENGTH = VSPECIES.laneCount();    \/\/ used by the JVM\n+        static final Class<Float16> ETYPE = Float16.class; \/\/ used by the JVM\n+\n+        HalffloatMaxShuffle(byte[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public HalffloatMaxShuffle(int[] reorder) {\n+            super(VLENGTH, reorder);\n+        }\n+\n+        public HalffloatMaxShuffle(int[] reorder, int i) {\n+            super(VLENGTH, reorder, i);\n+        }\n+\n+        public HalffloatMaxShuffle(IntUnaryOperator fn) {\n+            super(VLENGTH, fn);\n+        }\n+\n+        @Override\n+        public HalffloatSpecies vspecies() {\n+            return VSPECIES;\n+        }\n+\n+        static {\n+            \/\/ There must be enough bits in the shuffle lanes to encode\n+            \/\/ VLENGTH valid indexes and VLENGTH exceptional ones.\n+            assert(VLENGTH < Byte.MAX_VALUE);\n+            assert(Byte.MIN_VALUE <= -VLENGTH);\n+        }\n+        static final HalffloatMaxShuffle IOTA = new HalffloatMaxShuffle(IDENTITY);\n+\n+        @Override\n+        @ForceInline\n+        public HalffloatMaxVector toVector() {\n+            return VectorSupport.shuffleToVector(VCLASS, ETYPE, HalffloatMaxShuffle.class, this, VLENGTH,\n+                                                    (s) -> ((HalffloatMaxVector)(((AbstractShuffle<Float16>)(s)).toVectorTemplate())));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+            if (length() != species.laneCount())\n+                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+            int[] shuffleArray = toArray();\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public HalffloatMaxShuffle rearrange(VectorShuffle<Float16> shuffle) {\n+            HalffloatMaxShuffle s = (HalffloatMaxShuffle) shuffle;\n+            byte[] reorder1 = reorder();\n+            byte[] reorder2 = s.reorder();\n+            byte[] r = new byte[reorder1.length];\n+            for (int i = 0; i < reorder1.length; i++) {\n+                int ssi = reorder2[i];\n+                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            }\n+            return new HalffloatMaxShuffle(r);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Specialized low-level memory operations.\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(Float16[] a, int offset) {\n+        return super.fromArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromArray0(Float16[] a, int offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange) {\n+        return super.fromMemorySegment0Template(HalffloatMaxMask.class, ms, offset, (HalffloatMaxMask) m, offsetInRange);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(Float16[] a, int offset) {\n+        super.intoArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoArray0(Float16[] a, int offset, VectorMask<Float16> m) {\n+        super.intoArray0Template(HalffloatMaxMask.class, a, offset, (HalffloatMaxMask) m);\n+    }\n+\n+\n+\n+    @ForceInline\n+    @Override\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m) {\n+        super.intoMemorySegment0Template(HalffloatMaxMask.class, ms, offset, (HalffloatMaxMask) m);\n+    }\n+\n+\n+    \/\/ End of specialized low-level memory operations.\n+\n+    \/\/ ================================================\n+\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatMaxVector.java","additions":902,"deletions":0,"binary":false,"changes":902,"status":"added"},{"patch":"@@ -0,0 +1,3853 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.vector;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.vector.VectorSupport;\n+\n+import static jdk.internal.vm.vector.VectorSupport.*;\n+import static jdk.incubator.vector.VectorIntrinsics.*;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+\/**\n+ * A specialized {@link Vector} representing an ordered immutable sequence of\n+ * {@code Float16} values.\n+ *\/\n+@SuppressWarnings(\"cast\")  \/\/ warning: redundant cast\n+public abstract class HalffloatVector extends AbstractVector<Float16> {\n+\n+    HalffloatVector(Float16[] vec) {\n+        super(vec);\n+    }\n+\n+    static final int FORBID_OPCODE_KIND = VO_NOFP;\n+\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withByteAlignment(1);\n+\n+    @ForceInline\n+    static int opCode(Operator op) {\n+        return VectorOperators.opCode(op, VO_OPCODE_VALID, FORBID_OPCODE_KIND);\n+    }\n+    @ForceInline\n+    static int opCode(Operator op, int requireKind) {\n+        requireKind |= VO_OPCODE_VALID;\n+        return VectorOperators.opCode(op, requireKind, FORBID_OPCODE_KIND);\n+    }\n+    @ForceInline\n+    static boolean opKind(Operator op, int bit) {\n+        return VectorOperators.opKind(op, bit);\n+    }\n+\n+    \/\/ Virtualized factories and operators,\n+    \/\/ coded with portable definitions.\n+    \/\/ These are all @ForceInline in case\n+    \/\/ they need to be used performantly.\n+    \/\/ The various shape-specific subclasses\n+    \/\/ also specialize them by wrapping\n+    \/\/ them in a call like this:\n+    \/\/    return (Byte128Vector)\n+    \/\/       super.bOp((Byte128Vector) o);\n+    \/\/ The purpose of that is to forcibly inline\n+    \/\/ the generic definition from this file\n+    \/\/ into a sharply type- and size-specific\n+    \/\/ wrapper in the subclass file, so that\n+    \/\/ the JIT can specialize the code.\n+    \/\/ The code is only inlined and expanded\n+    \/\/ if it gets hot.  Think of it as a cheap\n+    \/\/ and lazy version of C++ templates.\n+\n+    \/\/ Virtualized getter\n+\n+    \/*package-private*\/\n+    abstract Float16[] vec();\n+\n+    \/\/ Virtualized constructors\n+\n+    \/**\n+     * Build a vector directly using my own constructor.\n+     * It is an error if the array is aliased elsewhere.\n+     *\/\n+    \/*package-private*\/\n+    abstract HalffloatVector vectorFactory(Float16[] vec);\n+\n+    \/**\n+     * Build a mask directly using my species.\n+     * It is an error if the array is aliased elsewhere.\n+     *\/\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    AbstractMask<Float16> maskFactory(boolean[] bits) {\n+        return vspecies().maskFactory(bits);\n+    }\n+\n+    \/\/ Constant loader (takes dummy as vector arg)\n+    interface FVOp {\n+        Float16 apply(int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector vOp(FVOp f) {\n+        Float16[] res = new Float16[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    @ForceInline\n+    final\n+    HalffloatVector vOp(VectorMask<Float16> m, FVOp f) {\n+        Float16[] res = new Float16[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Unary operator\n+\n+    \/*package-private*\/\n+    interface FUnOp {\n+        Float16 apply(int i, Float16 a);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector uOp(FUnOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector uOpTemplate(FUnOp f) {\n+        Float16[] vec = vec();\n+        Float16[] res = new Float16[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector uOp(VectorMask<Float16> m,\n+                             FUnOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector uOpTemplate(VectorMask<Float16> m,\n+                                     FUnOp f) {\n+        if (m == null) {\n+            return uOpTemplate(f);\n+        }\n+        Float16[] vec = vec();\n+        Float16[] res = new Float16[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec[i]) : vec[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Binary operator\n+\n+    \/*package-private*\/\n+    interface FBinOp {\n+        Float16 apply(int i, Float16 a, Float16 b);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector bOp(Vector<Float16> o,\n+                             FBinOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector bOpTemplate(Vector<Float16> o,\n+                                     FBinOp f) {\n+        Float16[] res = new Float16[length()];\n+        Float16[] vec1 = this.vec();\n+        Float16[] vec2 = ((HalffloatVector)o).vec();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec1[i], vec2[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector bOp(Vector<Float16> o,\n+                             VectorMask<Float16> m,\n+                             FBinOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector bOpTemplate(Vector<Float16> o,\n+                                     VectorMask<Float16> m,\n+                                     FBinOp f) {\n+        if (m == null) {\n+            return bOpTemplate(o, f);\n+        }\n+        Float16[] res = new Float16[length()];\n+        Float16[] vec1 = this.vec();\n+        Float16[] vec2 = ((HalffloatVector)o).vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i]) : vec1[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Ternary operator\n+\n+    \/*package-private*\/\n+    interface FTriOp {\n+        Float16 apply(int i, Float16 a, Float16 b, Float16 c);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector tOp(Vector<Float16> o1,\n+                             Vector<Float16> o2,\n+                             FTriOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector tOpTemplate(Vector<Float16> o1,\n+                                     Vector<Float16> o2,\n+                                     FTriOp f) {\n+        Float16[] res = new Float16[length()];\n+        Float16[] vec1 = this.vec();\n+        Float16[] vec2 = ((HalffloatVector)o1).vec();\n+        Float16[] vec3 = ((HalffloatVector)o2).vec();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(i, vec1[i], vec2[i], vec3[i]);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector tOp(Vector<Float16> o1,\n+                             Vector<Float16> o2,\n+                             VectorMask<Float16> m,\n+                             FTriOp f);\n+    @ForceInline\n+    final\n+    HalffloatVector tOpTemplate(Vector<Float16> o1,\n+                                     Vector<Float16> o2,\n+                                     VectorMask<Float16> m,\n+                                     FTriOp f) {\n+        if (m == null) {\n+            return tOpTemplate(o1, o2, f);\n+        }\n+        Float16[] res = new Float16[length()];\n+        Float16[] vec1 = this.vec();\n+        Float16[] vec2 = ((HalffloatVector)o1).vec();\n+        Float16[] vec3 = ((HalffloatVector)o2).vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = mbits[i] ? f.apply(i, vec1[i], vec2[i], vec3[i]) : vec1[i];\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/\/ Reduction operator\n+\n+    \/*package-private*\/\n+    abstract\n+    Float16 rOp(Float16 v, VectorMask<Float16> m, FBinOp f);\n+\n+    @ForceInline\n+    final\n+    Float16 rOpTemplate(Float16 v, VectorMask<Float16> m, FBinOp f) {\n+        if (m == null) {\n+            return rOpTemplate(v, f);\n+        }\n+        Float16[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            v = mbits[i] ? f.apply(i, v, vec[i]) : v;\n+        }\n+        return v;\n+    }\n+\n+    @ForceInline\n+    final\n+    Float16 rOpTemplate(Float16 v, FBinOp f) {\n+        Float16[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            v = f.apply(i, v, vec[i]);\n+        }\n+        return v;\n+    }\n+\n+    \/\/ Memory reference\n+\n+    \/*package-private*\/\n+    interface FLdOp<M> {\n+        Float16 apply(M memory, int offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> HalffloatVector ldOp(M memory, int offset,\n+                                  FLdOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        Float16[] res = new Float16[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> HalffloatVector ldOp(M memory, int offset,\n+                                  VectorMask<Float16> m,\n+                                  FLdOp<M> f) {\n+        \/\/Float16[] vec = vec();\n+        Float16[] res = new Float16[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    interface FLdLongOp {\n+        Float16 apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n+        \/\/dummy; no vec = vec();\n+        Float16[] res = new Float16[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                  VectorMask<Float16> m,\n+                                  FLdLongOp f) {\n+        \/\/Float16[] vec = vec();\n+        Float16[] res = new Float16[length()];\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static Float16 memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return Float16.valueOf(ms.get(ELEMENT_LAYOUT, o + i * 2L));\n+    }\n+\n+    interface FStOp<M> {\n+        void apply(M memory, int offset, int i, Float16 a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stOp(M memory, int offset,\n+                  FStOp<M> f) {\n+        Float16[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stOp(M memory, int offset,\n+                  VectorMask<Float16> m,\n+                  FStOp<M> f) {\n+        Float16[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, Float16 a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n+        Float16[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  VectorMask<Float16> m,\n+                  FStLongOp f) {\n+        Float16[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, Float16 e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 2L, e.shortValue());\n+    }\n+\n+    \/\/ Binary test\n+\n+    \/*package-private*\/\n+    interface FBinTest {\n+        boolean apply(int cond, int i, Float16 a, Float16 b);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    AbstractMask<Float16> bTest(int cond,\n+                                  Vector<Float16> o,\n+                                  FBinTest f) {\n+        Float16[] vec1 = vec();\n+        Float16[] vec2 = ((HalffloatVector)o).vec();\n+        boolean[] bits = new boolean[length()];\n+        for (int i = 0; i < length(); i++){\n+            bits[i] = f.apply(cond, i, vec1[i], vec2[i]);\n+        }\n+        return maskFactory(bits);\n+    }\n+\n+\n+    \/*package-private*\/\n+    @Override\n+    abstract HalffloatSpecies vspecies();\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static long toBits(Float16 e) {\n+        return Float16.float16ToRawShortBits(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    static Float16 fromBits(long bits) {\n+        return Float16.shortBitsToFloat16((short)bits);\n+    }\n+\n+    static HalffloatVector expandHelper(Vector<Float16> v, VectorMask<Float16> m) {\n+        VectorSpecies<Float16> vsp = m.vectorSpecies();\n+        HalffloatVector r  = (HalffloatVector) vsp.zero();\n+        HalffloatVector vi = (HalffloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static HalffloatVector compressHelper(Vector<Float16> v, VectorMask<Float16> m) {\n+        VectorSpecies<Float16> vsp = m.vectorSpecies();\n+        HalffloatVector r  = (HalffloatVector) vsp.zero();\n+        HalffloatVector vi = (HalffloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    \/\/ Static factories (other than memory operations)\n+\n+    \/\/ Note: A surprising behavior in javadoc\n+    \/\/ sometimes makes a lone \/** {@inheritDoc} *\/\n+    \/\/ comment drop the method altogether,\n+    \/\/ apparently if the method mentions an\n+    \/\/ parameter or return type of Vector<Float16>\n+    \/\/ instead of Vector<E> as originally specified.\n+    \/\/ Adding an empty HTML fragment appears to\n+    \/\/ nudge javadoc into providing the desired\n+    \/\/ inherited documentation.  We use the HTML\n+    \/\/ comment <!--workaround--> for this.\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * zero, the default primitive value.\n+     *\n+     * @param species species of the desired zero vector\n+     * @return a zero vector\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector zero(VectorSpecies<Float16> species) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), Float16.class, species.length(),\n+                        toBits(Float16.valueOf(0.0f)), MODE_BROADCAST, vsp,\n+                        ((bits_, s_) -> s_.rvOp(i -> bits_)));\n+    }\n+\n+    \/**\n+     * Returns a vector of the same species as this one\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * The contents of the current vector are discarded;\n+     * only the species is relevant to this operation.\n+     *\n+     * <p> This method returns the value of this expression:\n+     * {@code HalffloatVector.broadcast(this.species(), e)}.\n+     *\n+     * @apiNote\n+     * Unlike the similar method named {@code broadcast()}\n+     * in the supertype {@code Vector}, this method does not\n+     * need to validate its argument, and cannot throw\n+     * {@code IllegalArgumentException}.  This method is\n+     * therefore preferable to the supertype method.\n+     *\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @see #broadcast(VectorSpecies,long)\n+     * @see Vector#broadcast(long)\n+     * @see VectorSpecies#broadcast(long)\n+     *\/\n+    public abstract HalffloatVector broadcast(Float16 e);\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * @param species species of the desired vector\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @see #broadcast(long)\n+     * @see Vector#broadcast(long)\n+     * @see VectorSpecies#broadcast(long)\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector broadcast(VectorSpecies<Float16> species, Float16 e) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector broadcastTemplate(Float16 e) {\n+        HalffloatSpecies vsp = vspecies();\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #broadcast(Float16) the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.broadcast((Float16)e)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @Override\n+    public abstract HalffloatVector broadcast(long e);\n+\n+    \/**\n+     * Returns a vector of the given species\n+     * where all lane elements are set to\n+     * the primitive value {@code e}.\n+     *\n+     * The {@code long} value must be accurately representable\n+     * by the {@code ETYPE} of the vector species, so that\n+     * {@code e==(long)(ETYPE)e}.\n+     *\n+     * @param species species of the desired vector\n+     * @param e the value to broadcast\n+     * @return a vector where all lane elements are set to\n+     *         the primitive value {@code e}\n+     * @throws IllegalArgumentException\n+     *         if the given {@code long} value cannot\n+     *         be represented by the vector's {@code ETYPE}\n+     * @see #broadcast(VectorSpecies,Float16)\n+     * @see VectorSpecies#checkValue(long)\n+     *\/\n+    @ForceInline\n+    public static HalffloatVector broadcast(VectorSpecies<Float16> species, long e) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.broadcast(e);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector broadcastTemplate(long e) {\n+        return vspecies().broadcast(e);\n+    }\n+\n+    \/\/ Unary lanewise support\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Unary op);\n+\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Unary op) {\n+        if (opKind(op, VO_SPECIAL)) {\n+            if (op == ZOMO) {\n+                return blend(broadcast(-1), compare(NE, 0));\n+            }\n+        }\n+        int opc = opCode(op);\n+        return VectorSupport.unaryOp(\n+            opc, getClass(), null, Float16.class, length(),\n+            this, null,\n+            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Unary op,\n+                                  VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Unary op,\n+                                          Class<? extends VectorMask<Float16>> maskClass,\n+                                          VectorMask<Float16> m) {\n+        m.check(maskClass, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            if (op == ZOMO) {\n+                return blend(broadcast(-1), compare(NE, 0, m));\n+            }\n+        }\n+        int opc = opCode(op);\n+        return VectorSupport.unaryOp(\n+            opc, getClass(), maskClass, Float16.class, length(),\n+            this, m,\n+            UN_IMPL.find(op, opc, HalffloatVector::unaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Unary, UnaryOperation<HalffloatVector, VectorMask<Float16>>>\n+        UN_IMPL = new ImplCache<>(Unary.class, HalffloatVector.class);\n+\n+    private static UnaryOperation<HalffloatVector, VectorMask<Float16>> unaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_NEG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (Float16) Float16.valueOf(-a.floatValue()));\n+            case VECTOR_OP_ABS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (Float16) Float16.abs(a));\n+            case VECTOR_OP_SIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.sin(a.floatValue())));\n+            case VECTOR_OP_COS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.cos(a.floatValue())));\n+            case VECTOR_OP_TAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.tan(a.floatValue())));\n+            case VECTOR_OP_ASIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.asin(a.floatValue())));\n+            case VECTOR_OP_ACOS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.acos(a.floatValue())));\n+            case VECTOR_OP_ATAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.atan(a.floatValue())));\n+            case VECTOR_OP_EXP: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.exp(a.floatValue())));\n+            case VECTOR_OP_LOG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.log(a.floatValue())));\n+            case VECTOR_OP_LOG10: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.log10(a.floatValue())));\n+            case VECTOR_OP_SQRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.sqrt(a.floatValue())));\n+            case VECTOR_OP_CBRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.cbrt(a.floatValue())));\n+            case VECTOR_OP_SINH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.sinh(a.floatValue())));\n+            case VECTOR_OP_COSH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.cosh(a.floatValue())));\n+            case VECTOR_OP_TANH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.tanh(a.floatValue())));\n+            case VECTOR_OP_EXPM1: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.expm1(a.floatValue())));\n+            case VECTOR_OP_LOG1P: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.log1p(a.floatValue())));\n+            default: return null;\n+        }\n+    }\n+\n+    \/\/ Binary lanewise support\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Binary,Float16)\n+     * @see #lanewise(VectorOperators.Binary,Float16,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Vector<Float16> v);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Vector<Float16> v) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                VectorMask<Short> mask\n+                    = this.viewAsIntegralLanes().compare(EQ, (short) 0);\n+                return this.blend(that, mask.cast(vspecies()));\n+            }\n+        }\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), null, Float16.class, length(),\n+            this, that, null,\n+            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Binary,Float16,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Vector<Float16> v,\n+                                  VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Binary op,\n+                                          Class<? extends VectorMask<Float16>> maskClass,\n+                                          Vector<Float16> v, VectorMask<Float16> m) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        m.check(maskClass, this);\n+\n+        if (opKind(op, VO_SPECIAL )) {\n+            if (op == FIRST_NONZERO) {\n+                ShortVector bits = this.viewAsIntegralLanes();\n+                VectorMask<Short> mask\n+                    = bits.compare(EQ, (short) 0, m.cast(bits.vspecies()));\n+                return this.blend(that, mask.cast(vspecies()));\n+            }\n+        }\n+\n+        int opc = opCode(op);\n+        return VectorSupport.binaryOp(\n+            opc, getClass(), maskClass, Float16.class, length(),\n+            this, that, m,\n+            BIN_IMPL.find(op, opc, HalffloatVector::binaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Binary, BinaryOperation<HalffloatVector, VectorMask<Float16>>>\n+        BIN_IMPL = new ImplCache<>(Binary.class, HalffloatVector.class);\n+\n+    private static BinaryOperation<HalffloatVector, VectorMask<Float16>> binaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.add(a, b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.subtract(a, b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.multiply(a, b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.divide(a, b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.min(a, b));\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.valueOf(Math.atan2(a.floatValue(), b.floatValue())));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.valueOf(Math.pow(a.floatValue(), b.floatValue())));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.valueOf(Math.hypot(a.floatValue(), b.floatValue())));\n+            default: return null;\n+        }\n+    }\n+\n+    \/\/ FIXME: Maybe all of the public final methods in this file (the\n+    \/\/ simple ones that just call lanewise) should be pushed down to\n+    \/\/ the X-VectorBits template.  They can't optimize properly at\n+    \/\/ this level, and must rely on inlining.  Does it work?\n+    \/\/ (If it works, of course keep the code here.)\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the value of a broadcast scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e))}.\n+     *\n+     * @param op the operation used to process lane values\n+     * @param e the input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the two input vectors\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,Float16,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Float16 e) {\n+        return lanewise(op, broadcast(e));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the value of a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e), m)}.\n+     *\n+     * @param op the operation used to process lane values\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Binary,Float16)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  Float16 e,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #lanewise(VectorOperators.Binary,Float16)\n+     * the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.lanewise(op,(Float16)e)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  long e) {\n+        Float16 e1 = Float16.valueOf(e);\n+        if (e1.longValue() != e) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * When working with vector subtypes like {@code HalffloatVector},\n+     * {@linkplain #lanewise(VectorOperators.Binary,Float16,VectorMask)\n+     * the more strongly typed method}\n+     * is typically selected.  It can be explicitly selected\n+     * using a cast: {@code v.lanewise(op,(Float16)e,m)}.\n+     * The two expressions will produce numerically identical results.\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Binary op,\n+                                  long e, VectorMask<Float16> m) {\n+        Float16 e1 = Float16.valueOf(e);\n+        if (e1.longValue() != e) {\n+            vspecies().checkValue(e);  \/\/ for exception\n+        }\n+        return lanewise(op, e1, m);\n+    }\n+\n+\n+    \/\/ Ternary lanewise support\n+\n+    \/\/ Ternary operators come in eight variations:\n+    \/\/   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2])\n+    \/\/   lanewise(op, [broadcast(e1)|v1], [broadcast(e2)|v2], mask)\n+\n+    \/\/ It is annoying to support all of these variations of masking\n+    \/\/ and broadcast, but it would be more surprising not to continue\n+    \/\/ the obvious pattern started by unary and binary.\n+\n+   \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Float16,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Float16,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Float16)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Float16)\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Vector)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Ternary op,\n+                                                  Vector<Float16> v1,\n+                                                  Vector<Float16> v2);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,\n+                                          Vector<Float16> v1,\n+                                          Vector<Float16> v2) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        HalffloatVector tother = (HalffloatVector) v2;\n+        \/\/ It's a word: https:\/\/www.dictionary.com\/browse\/tother\n+        \/\/ See also Chapter 11 of Dickens, Our Mutual Friend:\n+        \/\/ \"Totherest Governor,\" replied Mr Riderhood...\n+        that.check(this);\n+        tother.check(this);\n+        int opc = opCode(op);\n+        return VectorSupport.ternaryOp(\n+            opc, getClass(), null, Float16.class, length(),\n+            this, that, tother, null,\n+            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Float16,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Float16,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Vector,VectorMask)\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector lanewise(VectorOperators.Ternary op,\n+                                  Vector<Float16> v1,\n+                                  Vector<Float16> v2,\n+                                  VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    HalffloatVector lanewiseTemplate(VectorOperators.Ternary op,\n+                                          Class<? extends VectorMask<Float16>> maskClass,\n+                                          Vector<Float16> v1,\n+                                          Vector<Float16> v2,\n+                                          VectorMask<Float16> m) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        HalffloatVector tother = (HalffloatVector) v2;\n+        \/\/ It's a word: https:\/\/www.dictionary.com\/browse\/tother\n+        \/\/ See also Chapter 11 of Dickens, Our Mutual Friend:\n+        \/\/ \"Totherest Governor,\" replied Mr Riderhood...\n+        that.check(this);\n+        tother.check(this);\n+        m.check(maskClass, this);\n+\n+        int opc = opCode(op);\n+        return VectorSupport.ternaryOp(\n+            opc, getClass(), maskClass, Float16.class, length(),\n+            this, that, tother, m,\n+            TERN_IMPL.find(op, opc, HalffloatVector::ternaryOperations));\n+    }\n+\n+    private static final\n+    ImplCache<Ternary, TernaryOperation<HalffloatVector, VectorMask<Float16>>>\n+        TERN_IMPL = new ImplCache<>(Ternary.class, HalffloatVector.class);\n+\n+    private static TernaryOperation<HalffloatVector, VectorMask<Float16>> ternaryOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) -> Float16.fma(a, b, c));\n+            default: return null;\n+        }\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of two broadcast scalars.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2))}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the first input scalar\n+     * @param e2 the second input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalars\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Float16,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,e2)\n+                                  Float16 e1,\n+                                  Float16 e2) {\n+        return lanewise(op, broadcast(e1), broadcast(e2));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of two broadcast scalars,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), this.broadcast(e2), m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the first input scalar\n+     * @param e2 the second input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vector and the scalars\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Float16)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,e2,m)\n+                                  Float16 e1,\n+                                  Float16 e2,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, broadcast(e1), broadcast(e2), m);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, v1, this.broadcast(e2))}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param v1 the other input vector\n+     * @param e2 the input scalar\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Float16)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Float16,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,v1,e2)\n+                                  Vector<Float16> v1,\n+                                  Float16 e2) {\n+        return lanewise(op, v1, broadcast(e2));\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, v1, this.broadcast(e2), m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param v1 the other input vector\n+     * @param e2 the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Float16,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Float16)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,v1,e2,m)\n+                                  Vector<Float16> v1,\n+                                  Float16 e2,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, v1, broadcast(e2), m);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar.\n+     *\n+     * This is a lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), v2)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the input scalar\n+     * @param v2 the other input vector\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,v2)\n+                                  Float16 e1,\n+                                  Vector<Float16> v2) {\n+        return lanewise(op, broadcast(e1), v2);\n+    }\n+\n+    \/**\n+     * Combines the lane values of this vector\n+     * with the values of another vector and a broadcast scalar,\n+     * with selection of lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise ternary operation which applies\n+     * the selected operation to each lane.\n+     * The return value will be equal to this expression:\n+     * {@code this.lanewise(op, this.broadcast(e1), v2, m)}.\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param e1 the input scalar\n+     * @param v2 the other input vector\n+     * @param m the mask controlling lane selection\n+     * @return the result of applying the operation lane-wise\n+     *         to the input vectors and the scalar\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Vector)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector lanewise(VectorOperators.Ternary op, \/\/(op,e1,v2,m)\n+                                  Float16 e1,\n+                                  Vector<Float16> v2,\n+                                  VectorMask<Float16> m) {\n+        return lanewise(op, broadcast(e1), v2, m);\n+    }\n+\n+    \/\/ (Thus endeth the Great and Mighty Ternary Ogdoad.)\n+    \/\/ https:\/\/en.wikipedia.org\/wiki\/Ogdoad\n+\n+    \/\/\/ FULL-SERVICE BINARY METHODS: ADD, SUB, MUL, DIV\n+    \/\/\n+    \/\/ These include masked and non-masked versions.\n+    \/\/ This subclass adds broadcast (masked or not).\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #add(Float16)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector add(Vector<Float16> v) {\n+        return lanewise(ADD, v);\n+    }\n+\n+    \/**\n+     * Adds this vector to the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive addition operation ({@code +}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Float16)\n+     *    lanewise}{@code (}{@link VectorOperators#ADD\n+     *    ADD}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of adding each lane of this vector to the scalar\n+     * @see #add(Vector)\n+     * @see #broadcast(Float16)\n+     * @see #add(Float16,VectorMask)\n+     * @see VectorOperators#ADD\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,Float16)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector add(Float16 e) {\n+        return lanewise(ADD, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #add(Float16,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector add(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(ADD, v, m);\n+    }\n+\n+    \/**\n+     * Adds this vector to the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive addition operation ({@code +}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Float16,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#ADD\n+     *    ADD}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of adding each lane of this vector to the scalar\n+     * @see #add(Vector,VectorMask)\n+     * @see #broadcast(Float16)\n+     * @see #add(Float16)\n+     * @see VectorOperators#ADD\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,Float16)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector add(Float16 e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(ADD, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #sub(Float16)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector sub(Vector<Float16> v) {\n+        return lanewise(SUB, v);\n+    }\n+\n+    \/**\n+     * Subtracts an input scalar from this vector.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive subtraction operation ({@code -}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Float16)\n+     *    lanewise}{@code (}{@link VectorOperators#SUB\n+     *    SUB}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of subtracting the scalar from each lane of this vector\n+     * @see #sub(Vector)\n+     * @see #broadcast(Float16)\n+     * @see #sub(Float16,VectorMask)\n+     * @see VectorOperators#SUB\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,Float16)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sub(Float16 e) {\n+        return lanewise(SUB, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #sub(Float16,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector sub(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(SUB, v, m);\n+    }\n+\n+    \/**\n+     * Subtracts an input scalar from this vector\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive subtraction operation ({@code -}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Float16,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#SUB\n+     *    SUB}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of subtracting the scalar from each lane of this vector\n+     * @see #sub(Vector,VectorMask)\n+     * @see #broadcast(Float16)\n+     * @see #sub(Float16)\n+     * @see VectorOperators#SUB\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,Float16)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sub(Float16 e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(SUB, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #mul(Float16)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector mul(Vector<Float16> v) {\n+        return lanewise(MUL, v);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive multiplication operation ({@code *}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Float16)\n+     *    lanewise}{@code (}{@link VectorOperators#MUL\n+     *    MUL}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #mul(Vector)\n+     * @see #broadcast(Float16)\n+     * @see #mul(Float16,VectorMask)\n+     * @see VectorOperators#MUL\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,Float16)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector mul(Float16 e) {\n+        return lanewise(MUL, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #mul(Float16,VectorMask)\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector mul(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(MUL, v, m);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive multiplication operation ({@code *}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Float16,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#MUL\n+     *    MUL}{@code , s, m)}.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of muling each lane of this vector to the scalar\n+     * @see #mul(Vector,VectorMask)\n+     * @see #broadcast(Float16)\n+     * @see #mul(Float16)\n+     * @see VectorOperators#MUL\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,Float16)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector mul(Float16 e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(MUL, e, m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector div(Vector<Float16> v) {\n+        return lanewise(DIV, v);\n+    }\n+\n+    \/**\n+     * Divides this vector by the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies\n+     * the primitive division operation ({@code \/}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Float16)\n+     *    lanewise}{@code (}{@link VectorOperators#DIV\n+     *    DIV}{@code , e)}.\n+     *\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\n+     * @param e the input scalar\n+     * @return the result of dividing each lane of this vector by the scalar\n+     * @see #div(Vector)\n+     * @see #broadcast(Float16)\n+     * @see #div(Float16,VectorMask)\n+     * @see VectorOperators#DIV\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,Float16)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector div(Float16 e) {\n+        return lanewise(DIV, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @see #div(Float16,VectorMask)\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector div(Vector<Float16> v,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(DIV, v, m);\n+    }\n+\n+    \/**\n+     * Divides this vector by the broadcast of an input scalar,\n+     * selecting lane elements controlled by a mask.\n+     *\n+     * This is a masked lane-wise binary operation which applies\n+     * the primitive division operation ({@code \/}) to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Float16,VectorMask)\n+     *    lanewise}{@code (}{@link VectorOperators#DIV\n+     *    DIV}{@code , s, m)}.\n+     *\n+     * @apiNote Because the underlying scalar operator is an IEEE\n+     * floating point number, division by zero in fact will\n+     * not throw an exception, but will yield a signed\n+     * infinity or NaN.\n+     *\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the result of dividing each lane of this vector by the scalar\n+     * @see #div(Vector,VectorMask)\n+     * @see #broadcast(Float16)\n+     * @see #div(Float16)\n+     * @see VectorOperators#DIV\n+     * @see #lanewise(VectorOperators.Binary,Vector)\n+     * @see #lanewise(VectorOperators.Binary,Float16)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector div(Float16 e,\n+                                          VectorMask<Float16> m) {\n+        return lanewise(DIV, e, m);\n+    }\n+\n+    \/\/\/ END OF FULL-SERVICE BINARY METHODS\n+\n+    \/\/\/ SECOND-TIER BINARY METHODS\n+    \/\/\n+    \/\/ There are no masked versions.\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector min(Vector<Float16> v) {\n+        return lanewise(MIN, v);\n+    }\n+\n+    \/\/ FIXME:  \"broadcast of an input scalar\" is really wordy.  Reduce?\n+    \/**\n+     * Computes the smaller of this vector and the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies the\n+     * operation {@code Math.min()} to each pair of\n+     * corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Float16)\n+     *    lanewise}{@code (}{@link VectorOperators#MIN\n+     *    MIN}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #min(Vector)\n+     * @see #broadcast(Float16)\n+     * @see VectorOperators#MIN\n+     * @see #lanewise(VectorOperators.Binary,Float16,VectorMask)\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector min(Float16 e) {\n+        return lanewise(MIN, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final HalffloatVector max(Vector<Float16> v) {\n+        return lanewise(MAX, v);\n+    }\n+\n+    \/**\n+     * Computes the larger of this vector and the broadcast of an input scalar.\n+     *\n+     * This is a lane-wise binary operation which applies the\n+     * operation {@code Math.max()} to each pair of\n+     * corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Float16)\n+     *    lanewise}{@code (}{@link VectorOperators#MAX\n+     *    MAX}{@code , e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result of multiplying this vector by the given scalar\n+     * @see #max(Vector)\n+     * @see #broadcast(Float16)\n+     * @see VectorOperators#MAX\n+     * @see #lanewise(VectorOperators.Binary,Float16,VectorMask)\n+     * @apiNote\n+     * For this method, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from, and less\n+     * than the default value (positive zero).\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector max(Float16 e) {\n+        return lanewise(MAX, e);\n+    }\n+\n+\n+    \/\/ common FP operator: pow\n+    \/**\n+     * Raises this vector to the power of a second input vector.\n+     *\n+     * This is a lane-wise binary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#pow Math.pow(a,b)}\n+     * to each pair of corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#POW\n+     *    POW}{@code , b)}.\n+     *\n+     * <p>\n+     * This is not a full-service named operation like\n+     * {@link #add(Vector) add}.  A masked version of\n+     * this operation is not directly available\n+     * but may be obtained via the masked version of\n+     * {@code lanewise}.\n+     *\n+     * @param b a vector exponent by which to raise this vector\n+     * @return the {@code b}-th power of this vector\n+     * @see #pow(Float16)\n+     * @see VectorOperators#POW\n+     * @see #lanewise(VectorOperators.Binary,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector pow(Vector<Float16> b) {\n+        return lanewise(POW, b);\n+    }\n+\n+    \/**\n+     * Raises this vector to a scalar power.\n+     *\n+     * This is a lane-wise binary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#pow Math.pow(a,b)}\n+     * to each pair of corresponding lane values.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Binary,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#POW\n+     *    POW}{@code , b)}.\n+     *\n+     * @param b a scalar exponent by which to raise this vector\n+     * @return the {@code b}-th power of this vector\n+     * @see #pow(Vector)\n+     * @see VectorOperators#POW\n+     * @see #lanewise(VectorOperators.Binary,Float16,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector pow(Float16 b) {\n+        return lanewise(POW, b);\n+    }\n+\n+    \/\/\/ UNARY METHODS\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector neg() {\n+        return lanewise(NEG);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector abs() {\n+        return lanewise(ABS);\n+    }\n+\n+\n+\n+    \/\/ sqrt\n+    \/**\n+     * Computes the square root of this vector.\n+     *\n+     * This is a lane-wise unary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Math#sqrt Math.sqrt(a)}\n+     * to each lane value.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Unary)\n+     *    lanewise}{@code (}{@link VectorOperators#SQRT\n+     *    SQRT}{@code )}.\n+     *\n+     * @return the square root of this vector\n+     * @see VectorOperators#SQRT\n+     * @see #lanewise(VectorOperators.Unary,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector sqrt() {\n+        return lanewise(SQRT);\n+    }\n+\n+    \/\/\/ COMPARISONS\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> eq(Vector<Float16> v) {\n+        return compare(EQ, v);\n+    }\n+\n+    \/**\n+     * Tests if this vector is equal to an input scalar.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the primitive equals operation ({@code ==}) to each lane.\n+     * The result is the same as {@code compare(VectorOperators.Comparison.EQ, e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the result mask of testing if this vector\n+     *         is equal to {@code e}\n+     * @see #compare(VectorOperators.Comparison,Float16)\n+     *\/\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> eq(Float16 e) {\n+        return compare(EQ, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> lt(Vector<Float16> v) {\n+        return compare(LT, v);\n+    }\n+\n+    \/**\n+     * Tests if this vector is less than an input scalar.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the primitive less than operation ({@code <}) to each lane.\n+     * The result is the same as {@code compare(VectorOperators.LT, e)}.\n+     *\n+     * @param e the input scalar\n+     * @return the mask result of testing if this vector\n+     *         is less than the input scalar\n+     * @see #compare(VectorOperators.Comparison,Float16)\n+     *\/\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> lt(Float16 e) {\n+        return compare(LT, e);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> test(VectorOperators.Test op);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M testTemplate(Class<M> maskType, Test op) {\n+        HalffloatSpecies vsp = vspecies();\n+        if (opKind(op, VO_SPECIAL)) {\n+            ShortVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Short> m;\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (short) 0);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (short) 0);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Short.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                short infbits = (short) toBits(Float16.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits);\n+                } else {\n+                    m = bits.compare(EQ, infbits);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> test(VectorOperators.Test op,\n+                                  VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        HalffloatSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            ShortVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Short> m = mask.cast(ShortVector.species(shape()));\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (short) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (short) 0, m);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Short.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                short infbits = (short) toBits(Float16.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, m);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, m);\n+                } else {\n+                    m = bits.compare(EQ, infbits, m);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> compare(VectorOperators.Comparison op, Vector<Float16> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, Vector<Float16> v) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        int opc = opCode(op);\n+        return VectorSupport.compare(\n+            opc, getClass(), maskType, Float16.class, length(),\n+            this, that, null,\n+            (cond, v0, v1, m1) -> {\n+                AbstractMask<Float16> m\n+                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                               -> compareWithOp(cond, a, b));\n+                @SuppressWarnings(\"unchecked\")\n+                M m2 = (M) m;\n+                return m2;\n+            });\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, Vector<Float16> v, M m) {\n+        HalffloatVector that = (HalffloatVector) v;\n+        that.check(this);\n+        m.check(maskType, this);\n+        int opc = opCode(op);\n+        return VectorSupport.compare(\n+            opc, getClass(), maskType, Float16.class, length(),\n+            this, that, m,\n+            (cond, v0, v1, m1) -> {\n+                AbstractMask<Float16> cmpM\n+                    = v0.bTest(cond, v1, (cond_, i, a, b)\n+                               -> compareWithOp(cond, a, b));\n+                @SuppressWarnings(\"unchecked\")\n+                M m2 = (M) cmpM.and(m1);\n+                return m2;\n+            });\n+    }\n+\n+    @ForceInline\n+    private static boolean compareWithOp(int cond, Float16 a, Float16 b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a.floatValue() < b.floatValue();\n+            case BT_le -> a.floatValue() <= b.floatValue();\n+            case BT_gt -> a.floatValue() > b.floatValue();\n+            case BT_ge -> a.floatValue() >= b.floatValue();\n+            default -> throw new AssertionError();\n+        };\n+    }\n+\n+    \/**\n+     * Tests this vector by comparing it with an input scalar,\n+     * according to the given comparison operation.\n+     *\n+     * This is a lane-wise binary test operation which applies\n+     * the comparison operation to each lane.\n+     * <p>\n+     * The result is the same as\n+     * {@code compare(op, broadcast(species(), e))}.\n+     * That is, the scalar may be regarded as broadcast to\n+     * a vector of the same species, and then compared\n+     * against the original vector, using the selected\n+     * comparison operation.\n+     *\n+     * @param op the operation used to compare lane values\n+     * @param e the input scalar\n+     * @return the mask result of testing lane-wise if this vector\n+     *         compares to the input, according to the selected\n+     *         comparison operator\n+     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector)\n+     * @see #eq(Float16)\n+     * @see #lt(Float16)\n+     *\/\n+    public abstract\n+    VectorMask<Float16> compare(Comparison op, Float16 e);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, Float16 e) {\n+        return compareTemplate(maskType, op, broadcast(e));\n+    }\n+\n+    \/**\n+     * Tests this vector by comparing it with an input scalar,\n+     * according to the given comparison operation,\n+     * in lanes selected by a mask.\n+     *\n+     * This is a masked lane-wise binary test operation which applies\n+     * to each pair of corresponding lane values.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code compare(op,s).and(m)}.\n+     *\n+     * @param op the operation used to compare lane values\n+     * @param e the input scalar\n+     * @param m the mask controlling lane selection\n+     * @return the mask result of testing lane-wise if this vector\n+     *         compares to the input, according to the selected\n+     *         comparison operator,\n+     *         and only in the lanes selected by the mask\n+     * @see HalffloatVector#compare(VectorOperators.Comparison,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final VectorMask<Float16> compare(VectorOperators.Comparison op,\n+                                               Float16 e,\n+                                               VectorMask<Float16> m) {\n+        return compare(op, broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    VectorMask<Float16> compare(Comparison op, long e);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    M compareTemplate(Class<M> maskType, Comparison op, long e) {\n+        return compareTemplate(maskType, op, broadcast(e));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    VectorMask<Float16> compare(Comparison op, long e, VectorMask<Float16> m) {\n+        return compare(op, broadcast(e), m);\n+    }\n+\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override public abstract\n+    HalffloatVector blend(Vector<Float16> v, VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector\n+    blendTemplate(Class<M> maskType, HalffloatVector v, M m) {\n+        v.check(this);\n+        return VectorSupport.blend(\n+            getClass(), maskType, Float16.class, length(),\n+            this, v, m,\n+            (v0, v1, m_) -> v0.bOp(v1, m_, (i, a, b) -> b));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override public abstract HalffloatVector addIndex(int scale);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector addIndexTemplate(int scale) {\n+        HalffloatSpecies vsp = vspecies();\n+        \/\/ make sure VLENGTH*scale doesn't overflow:\n+        vsp.checkScale(scale);\n+        return VectorSupport.indexVector(\n+            getClass(), Float16.class, length(),\n+            this, scale, vsp,\n+            (v, scale_, s)\n+            -> {\n+                \/\/ If the platform doesn't support an INDEX\n+                \/\/ instruction directly, load IOTA from memory\n+                \/\/ and multiply.\n+                HalffloatVector iota = s.iota();\n+                return v.add(scale_ == 1 ? iota : iota.mul(Float16.valueOf(scale_)));\n+            });\n+    }\n+\n+    \/**\n+     * Replaces selected lanes of this vector with\n+     * a scalar value\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which\n+     * selects each lane value from one or the other input.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code blend(broadcast(e),m)}.\n+     *\n+     * @param e the input scalar, containing the replacement lane value\n+     * @param m the mask controlling lane selection of the scalar\n+     * @return the result of blending the lane elements of this vector with\n+     *         the scalar value\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector blend(Float16 e,\n+                                            VectorMask<Float16> m) {\n+        return blend(broadcast(e), m);\n+    }\n+\n+    \/**\n+     * Replaces selected lanes of this vector with\n+     * a scalar value\n+     * under the control of a mask.\n+     *\n+     * This is a masked lane-wise binary operation which\n+     * selects each lane value from one or the other input.\n+     *\n+     * The returned result is equal to the expression\n+     * {@code blend(broadcast(e),m)}.\n+     *\n+     * @param e the input scalar, containing the replacement lane value\n+     * @param m the mask controlling lane selection of the scalar\n+     * @return the result of blending the lane elements of this vector with\n+     *         the scalar value\n+     *\/\n+    @ForceInline\n+    public final HalffloatVector blend(long e,\n+                                            VectorMask<Float16> m) {\n+        return blend(broadcast(e), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector slice(int origin, Vector<Float16> v1);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector sliceTemplate(int origin, Vector<Float16> v1) {\n+        HalffloatVector that = (HalffloatVector) v1;\n+        that.check(this);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Float16> iota = iotaShuffle();\n+        Float16 pivotidx = Float16.valueOf(length() - origin);\n+        VectorMask<Float16> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n+        iota = iotaShuffle(origin, 1, true);\n+        return that.rearrange(iota).blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    HalffloatVector slice(int origin,\n+                               Vector<Float16> w,\n+                               VectorMask<Float16> m) {\n+        return broadcast(0).blend(slice(origin, w), m);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector slice(int origin);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector sliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Float16> iota = iotaShuffle();\n+        Float16 pivotidx = Float16.valueOf(length() - origin);\n+        VectorMask<Float16> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n+        iota = iotaShuffle(origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin, Vector<Float16> w, int part);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector\n+    unsliceTemplate(int origin, Vector<Float16> w, int part) {\n+        HalffloatVector that = (HalffloatVector) w;\n+        that.check(this);\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Float16> iota = iotaShuffle();\n+        VectorMask<Float16> blendMask = iota.toVector().compare((part == 0) ? VectorOperators.GE : VectorOperators.LT,\n+                                                                  (broadcast(Float16.valueOf(origin))));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return that.blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector\n+    unsliceTemplate(Class<M> maskType, int origin, Vector<Float16> w, int part, M m) {\n+        HalffloatVector that = (HalffloatVector) w;\n+        that.check(this);\n+        HalffloatVector slice = that.sliceTemplate(origin, that);\n+        slice = slice.blendTemplate(maskType, this, m);\n+        return slice.unsliceTemplate(origin, w, part);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin, Vector<Float16> w, int part, VectorMask<Float16> m);\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector unslice(int origin);\n+\n+    \/*package-private*\/\n+    final\n+    @ForceInline\n+    HalffloatVector\n+    unsliceTemplate(int origin) {\n+        Objects.checkIndex(origin, length() + 1);\n+        VectorShuffle<Float16> iota = iotaShuffle();\n+        VectorMask<Float16> blendMask = iota.toVector().compare(VectorOperators.GE,\n+                                                                  broadcast(Float16.valueOf(origin)));\n+        iota = iotaShuffle(-origin, 1, true);\n+        return vspecies().zero().blend(this.rearrange(iota), blendMask);\n+    }\n+\n+    private ArrayIndexOutOfBoundsException\n+    wrongPartForSlice(int part) {\n+        String msg = String.format(\"bad part number %d for slice operation\",\n+                                   part);\n+        return new ArrayIndexOutOfBoundsException(msg);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Float16>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype, S shuffle) {\n+        shuffle.checkIndexes();\n+        return VectorSupport.rearrangeOp(\n+            getClass(), shuffletype, null, Float16.class, length(),\n+            this, shuffle, null,\n+            (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                int ei = s_.laneSource(i);\n+                return v1.lane(ei);\n+            }));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Float16> s,\n+                                   VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Float16>, M extends VectorMask<Float16>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype,\n+                                           Class<M> masktype,\n+                                           S shuffle,\n+                                           M m) {\n+\n+        m.check(masktype, this);\n+        VectorMask<Float16> valid = shuffle.laneIsValid();\n+        if (m.andNot(valid).anyTrue()) {\n+            shuffle.checkIndexes();\n+            throw new AssertionError();\n+        }\n+        return VectorSupport.rearrangeOp(\n+                   getClass(), shuffletype, masktype, Float16.class, length(),\n+                   this, shuffle, m,\n+                   (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                        int ei = s_.laneSource(i);\n+                        return ei < 0  || !m_.laneIsSet(i) ? Float16.valueOf(0) : v1.lane(ei);\n+                   }));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector rearrange(VectorShuffle<Float16> s,\n+                                   Vector<Float16> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <S extends VectorShuffle<Float16>>\n+    HalffloatVector rearrangeTemplate(Class<S> shuffletype,\n+                                           S shuffle,\n+                                           HalffloatVector v) {\n+        VectorMask<Float16> valid = shuffle.laneIsValid();\n+        @SuppressWarnings(\"unchecked\")\n+        S ws = (S) shuffle.wrapIndexes();\n+        HalffloatVector r0 =\n+            VectorSupport.rearrangeOp(\n+                getClass(), shuffletype, null, Float16.class, length(),\n+                this, ws, null,\n+                (v0, s_, m_) -> v0.uOp((i, a) -> {\n+                    int ei = s_.laneSource(i);\n+                    return v0.lane(ei);\n+                }));\n+        HalffloatVector r1 =\n+            VectorSupport.rearrangeOp(\n+                getClass(), shuffletype, null, Float16.class, length(),\n+                v, ws, null,\n+                (v1, s_, m_) -> v1.uOp((i, a) -> {\n+                    int ei = s_.laneSource(i);\n+                    return v1.lane(ei);\n+                }));\n+        return r1.blend(r0, valid);\n+    }\n+\n+    @ForceInline\n+    private final\n+    VectorShuffle<Float16> toShuffle0(HalffloatSpecies dsp) {\n+        Float16[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = a[i].intValue();\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Float16> toShuffleTemplate(Class<?> shuffleType) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), Float16.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     HalffloatVector::toShuffle0);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector compress(VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Float16>>\n+    HalffloatVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                        Float16.class, length(), this, m,\n+                                                        (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector expand(VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Float16>>\n+    HalffloatVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (HalffloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                        Float16.class, length(), this, m,\n+                                                        (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Float16> v);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector selectFromTemplate(HalffloatVector v) {\n+        return v.rearrange(this.toShuffle());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    HalffloatVector selectFrom(Vector<Float16> s, VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final HalffloatVector selectFromTemplate(HalffloatVector v,\n+                                                  AbstractMask<Float16> m) {\n+        return v.rearrange(this.toShuffle(), m);\n+    }\n+\n+    \/\/\/ Ternary operations\n+\n+\n+    \/**\n+     * Multiplies this vector by a second input vector, and sums\n+     * the result with a third.\n+     *\n+     * Extended precision is used for the intermediate result,\n+     * avoiding possible loss of precision from rounding once\n+     * for each of the two operations.\n+     * The result is numerically close to {@code this.mul(b).add(c)},\n+     * and is typically closer to the true mathematical result.\n+     *\n+     * This is a lane-wise ternary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Float16#fma(Float16,Float16,Float16) Float16.fma(a,b,c)}\n+     * to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#FMA\n+     *    FMA}{@code , b, c)}.\n+     *\n+     * @param b the second input vector, supplying multiplier values\n+     * @param c the third input vector, supplying addend values\n+     * @return the product of this vector and the second input vector\n+     *         summed with the third input vector, using extended precision\n+     *         for the intermediate result\n+     * @see #fma(Float16,Float16)\n+     * @see VectorOperators#FMA\n+     * @see #lanewise(VectorOperators.Ternary,Vector,Vector,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector fma(Vector<Float16> b, Vector<Float16> c) {\n+        return lanewise(FMA, b, c);\n+    }\n+\n+    \/**\n+     * Multiplies this vector by a scalar multiplier, and sums\n+     * the result with a scalar addend.\n+     *\n+     * Extended precision is used for the intermediate result,\n+     * avoiding possible loss of precision from rounding once\n+     * for each of the two operations.\n+     * The result is numerically close to {@code this.mul(b).add(c)},\n+     * and is typically closer to the true mathematical result.\n+     *\n+     * This is a lane-wise ternary operation which applies an operation\n+     * conforming to the specification of\n+     * {@link Float16#fma(Float16,Float16,Float16) Float16.fma(a,b,c)}\n+     * to each lane.\n+     *\n+     * This method is also equivalent to the expression\n+     * {@link #lanewise(VectorOperators.Ternary,Vector,Vector)\n+     *    lanewise}{@code (}{@link VectorOperators#FMA\n+     *    FMA}{@code , b, c)}.\n+     *\n+     * @param b the scalar multiplier\n+     * @param c the scalar addend\n+     * @return the product of this vector and the scalar multiplier\n+     *         summed with scalar addend, using extended precision\n+     *         for the intermediate result\n+     * @see #fma(Vector,Vector)\n+     * @see VectorOperators#FMA\n+     * @see #lanewise(VectorOperators.Ternary,Float16,Float16,VectorMask)\n+     *\/\n+    @ForceInline\n+    public final\n+    HalffloatVector fma(Float16 b, Float16 c) {\n+        return lanewise(FMA, b, c);\n+    }\n+\n+    \/\/ Don't bother with (Vector,Float16) and (Float16,Vector) overloadings.\n+\n+    \/\/ Type specific horizontal reductions\n+\n+    \/**\n+     * Returns a value accumulated from all the lanes of this vector.\n+     *\n+     * This is an associative cross-lane reduction operation which\n+     * applies the specified operation to all the lane elements.\n+     * <p>\n+     * A few reduction operations do not support arbitrary reordering\n+     * of their operands, yet are included here because of their\n+     * usefulness.\n+     * <ul>\n+     * <li>\n+     * In the case of {@code FIRST_NONZERO}, the reduction returns\n+     * the value from the lowest-numbered non-zero lane.\n+     * (As with {@code MAX} and {@code MIN}, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from\n+     * the default value, positive zero. So a first-nonzero lane reduction\n+     * might return {@code -0.0} even in the presence of non-zero\n+     * lane values.)\n+     * <li>\n+     * In the case of {@code ADD} and {@code MUL}, the\n+     * precise result will reflect the choice of an arbitrary order\n+     * of operations, which may even vary over time.\n+     * For further details see the section\n+     * <a href=\"VectorOperators.html#fp_assoc\">Operations on floating point vectors<\/a>.\n+     * <li>\n+     * All other reduction operations are fully commutative and\n+     * associative.  The implementation can choose any order of\n+     * processing, yet it will always produce the same result.\n+     * <\/ul>\n+     *\n+     * @param op the operation used to combine lane values\n+     * @return the accumulated result\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #reduceLanes(VectorOperators.Associative,VectorMask)\n+     * @see #add(Vector)\n+     * @see #mul(Vector)\n+     * @see #min(Vector)\n+     * @see #max(Vector)\n+     * @see VectorOperators#FIRST_NONZERO\n+     *\/\n+    public abstract Float16 reduceLanes(VectorOperators.Associative op);\n+\n+    \/**\n+     * Returns a value accumulated from selected lanes of this vector,\n+     * controlled by a mask.\n+     *\n+     * This is an associative cross-lane reduction operation which\n+     * applies the specified operation to the selected lane elements.\n+     * <p>\n+     * If no elements are selected, an operation-specific identity\n+     * value is returned.\n+     * <ul>\n+     * <li>\n+     * If the operation is\n+     *  {@code ADD}\n+     * or {@code FIRST_NONZERO},\n+     * then the identity value is positive zero, the default {@code Float16} value.\n+     * <li>\n+     * If the operation is {@code MUL},\n+     * then the identity value is one.\n+     * <li>\n+     * If the operation is {@code MAX},\n+     * then the identity value is {@code Float16.NEGATIVE_INFINITY}.\n+     * <li>\n+     * If the operation is {@code MIN},\n+     * then the identity value is {@code Float16.POSITIVE_INFINITY}.\n+     * <\/ul>\n+     * <p>\n+     * A few reduction operations do not support arbitrary reordering\n+     * of their operands, yet are included here because of their\n+     * usefulness.\n+     * <ul>\n+     * <li>\n+     * In the case of {@code FIRST_NONZERO}, the reduction returns\n+     * the value from the lowest-numbered non-zero lane.\n+     * (As with {@code MAX} and {@code MIN}, floating point negative\n+     * zero {@code -0.0} is treated as a value distinct from\n+     * the default value, positive zero. So a first-nonzero lane reduction\n+     * might return {@code -0.0} even in the presence of non-zero\n+     * lane values.)\n+     * <li>\n+     * In the case of {@code ADD} and {@code MUL}, the\n+     * precise result will reflect the choice of an arbitrary order\n+     * of operations, which may even vary over time.\n+     * For further details see the section\n+     * <a href=\"VectorOperators.html#fp_assoc\">Operations on floating point vectors<\/a>.\n+     * <li>\n+     * All other reduction operations are fully commutative and\n+     * associative.  The implementation can choose any order of\n+     * processing, yet it will always produce the same result.\n+     * <\/ul>\n+     *\n+     * @param op the operation used to combine lane values\n+     * @param m the mask controlling lane selection\n+     * @return the reduced result accumulated from the selected lane values\n+     * @throws UnsupportedOperationException if this vector does\n+     *         not support the requested operation\n+     * @see #reduceLanes(VectorOperators.Associative)\n+     *\/\n+    public abstract Float16 reduceLanes(VectorOperators.Associative op,\n+                                       VectorMask<Float16> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    Float16 reduceLanesTemplate(VectorOperators.Associative op,\n+                               Class<? extends VectorMask<Float16>> maskClass,\n+                               VectorMask<Float16> m) {\n+        m.check(maskClass, this);\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME:  The JIT should handle this.\n+            HalffloatVector v = broadcast(Float16.valueOf(0)).blend(this, m);\n+            return v.reduceLanesTemplate(op);\n+        }\n+        int opc = opCode(op);\n+        return fromBits(VectorSupport.reductionCoerced(\n+            opc, getClass(), maskClass, Float16.class, length(),\n+            this, m,\n+            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    Float16 reduceLanesTemplate(VectorOperators.Associative op) {\n+        if (op == FIRST_NONZERO) {\n+            \/\/ FIXME:  The JIT should handle this.\n+            VectorMask<Short> thisNZ\n+                = this.viewAsIntegralLanes().compare(NE, (short) 0);\n+            int ft = thisNZ.firstTrue();\n+            return ft < length() ? this.lane(ft) : Float16.valueOf(0);\n+        }\n+        int opc = opCode(op);\n+        return fromBits(VectorSupport.reductionCoerced(\n+            opc, getClass(), null, Float16.class, length(),\n+            this, null,\n+            REDUCE_IMPL.find(op, opc, HalffloatVector::reductionOperations)));\n+    }\n+\n+    private static final\n+    ImplCache<Associative, ReductionOperation<HalffloatVector, VectorMask<Float16>>>\n+        REDUCE_IMPL = new ImplCache<>(Associative.class, HalffloatVector.class);\n+\n+    private static ReductionOperation<HalffloatVector, VectorMask<Float16>> reductionOperations(int opc_) {\n+        switch (opc_) {\n+            case VECTOR_OP_ADD: return (v, m) ->\n+                    toBits(v.rOp(Float16.valueOf(0), m, (i, a, b) -> Float16.add(a, b)));\n+            case VECTOR_OP_MUL: return (v, m) ->\n+                    toBits(v.rOp(Float16.valueOf(0), m, (i, a, b) -> Float16.multiply(a, b)));\n+            case VECTOR_OP_MIN: return (v, m) ->\n+                    toBits(v.rOp(Float16.valueOf(0), m, (i, a, b) -> Float16.min(a, b)));\n+            case VECTOR_OP_MAX: return (v, m) ->\n+                    toBits(v.rOp(Float16.valueOf(0), m, (i, a, b) -> Float16.max(a, b)));\n+            default: return null;\n+        }\n+    }\n+\n+    private static final Float16 MIN_OR_INF = Float16.NEGATIVE_INFINITY;\n+    private static final Float16 MAX_OR_INF = Float16.POSITIVE_INFINITY;\n+\n+    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op);\n+    public @Override abstract long reduceLanesToLong(VectorOperators.Associative op,\n+                                                     VectorMask<Float16> m);\n+\n+    \/\/ Type specific accessors\n+\n+    \/**\n+     * Gets the lane element at lane index {@code i}\n+     *\n+     * @param i the lane index\n+     * @return the lane element at lane index {@code i}\n+     * @throws IllegalArgumentException if the index is out of range\n+     * ({@code < 0 || >= length()})\n+     *\/\n+    public abstract Float16 lane(int i);\n+\n+    \/**\n+     * Replaces the lane element of this vector at lane index {@code i} with\n+     * value {@code e}.\n+     *\n+     * This is a cross-lane operation and behaves as if it returns the result\n+     * of blending this vector with an input vector that is the result of\n+     * broadcasting {@code e} and a mask that has only one lane set at lane\n+     * index {@code i}.\n+     *\n+     * @param i the lane index of the lane element to be replaced\n+     * @param e the value to be placed\n+     * @return the result of replacing the lane element of this vector at lane\n+     * index {@code i} with value {@code e}.\n+     * @throws IllegalArgumentException if the index is out of range\n+     * ({@code < 0 || >= length()})\n+     *\/\n+    public abstract HalffloatVector withLane(int i, Float16 e);\n+\n+    \/\/ Memory load operations\n+\n+    \/**\n+     * Returns an array of type {@code Float16[]}\n+     * containing all the lane values.\n+     * The array length is the same as the vector length.\n+     * The array elements are stored in lane order.\n+     * <p>\n+     * This method behaves as if it stores\n+     * this vector into an allocated array\n+     * (using {@link #intoArray(Float16[], int) intoArray})\n+     * and returns the array as follows:\n+     * <pre>{@code\n+     *   Float16[] a = new Float16[this.length()];\n+     *   this.intoArray(a, 0);\n+     *   return a;\n+     * }<\/pre>\n+     *\n+     * @return an array containing the lane values of this vector\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final Float16[] toArray() {\n+        Float16[] a = new Float16[vspecies().laneCount()];\n+        intoArray(a, 0);\n+        return a;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final int[] toIntArray() {\n+        Float16[] a = toArray();\n+        int[] res = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            Float16 e = a[i];\n+            res[i] = (int) HalffloatSpecies.toIntegralChecked(e, true);\n+        }\n+        return res;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final long[] toLongArray() {\n+        Float16[] a = toArray();\n+        long[] res = new long[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Value range of integral casted Float16 value is a proper subset of\n+            \/\/ long value range.\n+            res[i] = a[i].longValue();\n+        }\n+        return res;\n+    }\n+\n+    \/** {@inheritDoc} <!--workaround-->\n+     * @implNote\n+     * When this method is used on used on vectors\n+     * of type {@code HalffloatVector},\n+     * there will be no loss of precision.\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final double[] toDoubleArray() {\n+        Float16[] a = toArray();\n+        double[] res = new double[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            res[i] = a[i].doubleValue();\n+        }\n+        return res;\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code Float16[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N} is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   Float16[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code Float16[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code Float16} (positive zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N} is placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   Float16[] a, int offset,\n+                                   VectorMask<Float16> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+            return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_IN_RANGE);\n+        }\n+\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.dummyVector().fromArray0(a, offset, m, OFFSET_OUT_OF_RANGE);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code Float16[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   Float16[] a, int offset,\n+                                   int[] indexMap, int mapOffset) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(n -> a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code Float16[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromArray(VectorSpecies<Float16> species,\n+                                   Float16[] a, int offset,\n+                                   int[] indexMap, int mapOffset,\n+                                   VectorMask<Float16> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.vOp(m, n -> a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromMemorySegment(VectorSpecies<Float16> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code Float16} (positive zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * Float16[] ar = new Float16[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_HALFFLOAT.withByteAlignment(1), n);\n+     *     }\n+     * }\n+     * HalffloatVector r = HalffloatVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n+     *\/\n+    @ForceInline\n+    public static\n+    HalffloatVector fromMemorySegment(VectorSpecies<Float16> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Float16> m) {\n+        HalffloatSpecies vsp = (HalffloatSpecies) species;\n+        if (VectorIntrinsics.indexInRange(offset, vsp.vectorByteSize(), ms.byteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_IN_RANGE).maybeSwap(bo);\n+        }\n+\n+        checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset, m, OFFSET_OUT_OF_RANGE).maybeSwap(bo);\n+    }\n+\n+    \/\/ Memory store operations\n+\n+    \/**\n+     * Stores this vector into an array of type {@code Float16[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code Float16[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(Float16[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, (int) off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code Float16[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code Float16[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(Float16[] a, int offset,\n+                   VectorMask<Float16> m) {\n+        if (m.allTrue()) {\n+            intoArray(a, offset);\n+        } else {\n+            HalffloatSpecies vsp = vspecies();\n+            if (!VectorIntrinsics.indexInRange(offset, vsp.length(), a.length)) {\n+                checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            }\n+            intoArray0(a, offset, m);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code Float16[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(Float16[] a, int offset,\n+                   int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code Float16[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N} is stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see HalffloatVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoArray(Float16[] a, int offset,\n+                   int[] indexMap, int mapOffset,\n+                   VectorMask<Float16> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = e;\n+             });\n+    }\n+\n+\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Float16> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            HalffloatSpecies vsp = vspecies();\n+            if (!VectorIntrinsics.indexInRange(offset, vsp.vectorByteSize(), ms.byteSize())) {\n+                checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());\n+            }\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Low-level memory operations.\n+    \/\/\n+    \/\/ Note that all of these operations *must* inline into a context\n+    \/\/ where the exact species of the involved vector is a\n+    \/\/ compile-time constant.  Otherwise, the intrinsic generation\n+    \/\/ will fail and performance will suffer.\n+    \/\/\n+    \/\/ In many cases this is achieved by re-deriving a version of the\n+    \/\/ method in each concrete subclass (per species).  The re-derived\n+    \/\/ method simply calls one of these generic methods, with exact\n+    \/\/ parameters for the controlling metadata, which is either a\n+    \/\/ typed vector or constant species instance.\n+\n+    \/\/ Unchecked loading operations in native byte order.\n+    \/\/ Caller is responsible for applying index checks, masking, and\n+    \/\/ byte swapping.\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(Float16[] a, int offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromArray0Template(Float16[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n+                                    (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n+    \/*package-private*\/\n+    abstract\n+    HalffloatVector fromArray0(Float16[] a, int offset, VectorMask<Float16> m, int offsetInRange);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector fromArray0Template(Class<M> maskClass, Float16[] a, int offset, M m, int offsetInRange) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        return VectorSupport.loadMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), false, m, offsetInRange,\n+            a, offset, vsp,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n+                                        (arr_, off_, i) -> arr_[off_ + i]));\n+    }\n+\n+\n+\n+\n+    abstract\n+    HalffloatVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    HalffloatVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (AbstractMemorySegmentImpl) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, HalffloatVector::memorySegmentGet);\n+                });\n+    }\n+\n+    abstract\n+    HalffloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float16> m, int offsetInRange);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    HalffloatVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m, int offsetInRange) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (AbstractMemorySegmentImpl) ms, offset, m, vsp, offsetInRange,\n+                (msp, off, s, vm) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, HalffloatVector::memorySegmentGet);\n+                });\n+    }\n+\n+    \/\/ Unchecked storing operations in native byte order.\n+    \/\/ Caller is responsible for applying index checks, masking, and\n+    \/\/ byte swapping.\n+\n+    abstract\n+    void intoArray0(Float16[] a, int offset);\n+    @ForceInline\n+    final\n+    void intoArray0Template(Float16[] a, int offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            this, a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, (int) off,\n+                      (arr_, off_, i, e) -> arr_[off_+i] = e));\n+    }\n+\n+    abstract\n+    void intoArray0(Float16[] a, int offset, VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    void intoArray0Template(Class<M> maskClass, Float16[] a, int offset, M m) {\n+        m.check(species());\n+        HalffloatSpecies vsp = vspecies();\n+        VectorSupport.storeMasked(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset), false,\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.stOp(arr, (int) off, vm,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = e));\n+    }\n+\n+\n+\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        HalffloatSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (AbstractMemorySegmentImpl) ms, offset,\n+                (msp, off, v) -> {\n+                    v.stLongOp((MemorySegment) msp, off, HalffloatVector::memorySegmentSet);\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Float16> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float16>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        HalffloatSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (AbstractMemorySegmentImpl) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    v.stLongOp((MemorySegment) msp, off, vm, HalffloatVector::memorySegmentSet);\n+                });\n+    }\n+\n+\n+    \/\/ End of low-level memory operations.\n+\n+    private static\n+    void checkMaskFromIndexSize(int offset,\n+                                HalffloatSpecies vsp,\n+                                VectorMask<Float16> m,\n+                                int scale,\n+                                int limit) {\n+        ((AbstractMask<Float16>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                HalffloatSpecies vsp,\n+                                VectorMask<Float16> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Float16>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n+    @ForceInline\n+    private void conditionalStoreNYI(int offset,\n+                                     HalffloatSpecies vsp,\n+                                     VectorMask<Float16> m,\n+                                     int scale,\n+                                     int limit) {\n+        if (offset < 0 || offset + vsp.laneCount() * scale > limit) {\n+            String msg =\n+                String.format(\"unimplemented: store @%d in [0..%d), %s in %s\",\n+                              offset, limit, m, vsp);\n+            throw new AssertionError(msg);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    final\n+    HalffloatVector maybeSwap(ByteOrder bo) {\n+        if (bo != NATIVE_ENDIAN) {\n+            return this.reinterpretAsBytes()\n+                .rearrange(swapBytesShuffle())\n+                .reinterpretAsHalffloats();\n+        }\n+        return this;\n+    }\n+\n+    static final int ARRAY_SHIFT =\n+        31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_OBJECT_INDEX_SCALE);\n+    static final long ARRAY_BASE =\n+        Unsafe.ARRAY_OBJECT_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long arrayAddress(Float16[] a, int index) {\n+        return ARRAY_BASE + (((long)index) << ARRAY_SHIFT);\n+    }\n+\n+\n+\n+    @ForceInline\n+    static long byteArrayAddress(byte[] a, int index) {\n+        return Unsafe.ARRAY_BYTE_BASE_OFFSET + index;\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/\/ Reinterpreting view methods:\n+    \/\/   lanewise reinterpret: viewAsXVector()\n+    \/\/   keep shape, redraw lanes: reinterpretAsEs()\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final ByteVector reinterpretAsBytes() {\n+         \/\/ Going to ByteVector, pay close attention to byte order.\n+         assert(REGISTER_ENDIAN == ByteOrder.LITTLE_ENDIAN);\n+         return asByteVectorRaw();\n+         \/\/return asByteVectorRaw().rearrange(swapBytesShuffle());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final ShortVector viewAsIntegralLanes() {\n+        LaneType ilt = LaneType.FLOAT16.asIntegral();\n+        return (ShortVector) asVectorRaw(ilt);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\n+     * @implNote This method always throws\n+     * {@code UnsupportedOperationException}, because there is no floating\n+     * point type of the same size as {@code Float16}.  The return type\n+     * of this method is arbitrarily designated as\n+     * {@code Vector<?>}.  Future versions of this API may change the return\n+     * type if additional floating point types become available.\n+     *\/\n+    @ForceInline\n+    @Override\n+    public final\n+    HalffloatVector\n+    viewAsFloatingLanes() {\n+        return this;\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/\/ Object methods: toString, equals, hashCode\n+    \/\/\n+    \/\/ Object methods are defined as if via Arrays.toString, etc.,\n+    \/\/ is applied to the array of elements.  Two equal vectors\n+    \/\/ are required to have equal species and equal lane values.\n+\n+    \/**\n+     * Returns a string representation of this vector, of the form\n+     * {@code \"[0,1,2...]\"}, reporting the lane values of this vector,\n+     * in lane order.\n+     *\n+     * The string is produced as if by a call to {@link\n+     * java.util.Arrays#toString(Float16[]) Arrays.toString()},\n+     * as appropriate to the {@code Float16} array returned by\n+     * {@link #toArray this.toArray()}.\n+     *\n+     * @return a string of the form {@code \"[0,1,2...]\"}\n+     * reporting the lane values of this vector\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    String toString() {\n+        \/\/ now that toArray is strongly typed, we can define this\n+        return Arrays.toString(toArray());\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    boolean equals(Object obj) {\n+        if (obj instanceof Vector) {\n+            Vector<?> that = (Vector<?>) obj;\n+            if (this.species().equals(that.species())) {\n+                return this.eq(that.check(this.species())).allTrue();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    int hashCode() {\n+        \/\/ now that toArray is strongly typed, we can define this\n+        return Objects.hash(species(), Arrays.hashCode(toArray()));\n+    }\n+\n+    \/\/ ================================================\n+\n+    \/\/ Species\n+\n+    \/**\n+     * Class representing {@link HalffloatVector}'s of the same {@link VectorShape VectorShape}.\n+     *\/\n+    \/*package-private*\/\n+    static final class HalffloatSpecies extends AbstractSpecies<Float16> {\n+        private HalffloatSpecies(VectorShape shape,\n+                Class<? extends HalffloatVector> vectorType,\n+                Class<? extends AbstractMask<Float16>> maskType,\n+                Function<Object, HalffloatVector> vectorFactory) {\n+            super(shape, LaneType.of(Float16.class),\n+                  vectorType, maskType,\n+                  vectorFactory);\n+            assert(this.elementSize() == Float16.SIZE);\n+        }\n+\n+        \/\/ Specializing overrides:\n+\n+        @Override\n+        @ForceInline\n+        public final Class<Float16> elementType() {\n+            return Float16.class;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        final Class<Float16> genericElementType() {\n+            return Float16.class;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        @ForceInline\n+        public final Class<? extends HalffloatVector> vectorType() {\n+            return (Class<? extends HalffloatVector>) vectorType;\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final long checkValue(long e) {\n+            longToElementBits(e);  \/\/ only for exception\n+            return e;\n+        }\n+\n+        \/*package-private*\/\n+        @Override\n+        @ForceInline\n+        final HalffloatVector broadcastBits(long bits) {\n+            return (HalffloatVector)\n+                VectorSupport.fromBitsCoerced(\n+                    vectorType, Float16.class, laneCount,\n+                    bits, MODE_BROADCAST, this,\n+                    (bits_, s_) -> s_.rvOp(i -> bits_));\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        final HalffloatVector broadcast(Float16 e) {\n+            return broadcastBits(toBits(e));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector broadcast(long e) {\n+            return broadcastBits(longToElementBits(e));\n+        }\n+\n+        \/*package-private*\/\n+        final @Override\n+        @ForceInline\n+        long longToElementBits(long value) {\n+            \/\/ Do the conversion, and then test it for failure.\n+            Float16 e = Float16.valueOf(value);\n+            if (e.longValue() != value) {\n+                throw badElementBits(value, e);\n+            }\n+            return toBits(e);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        static long toIntegralChecked(Float16 e, boolean convertToInt) {\n+            long value = convertToInt ? e.intValue() : e.longValue();\n+            if (value != e.longValue()) {\n+                throw badArrayBits(e, convertToInt, value);\n+            }\n+            return value;\n+        }\n+\n+        \/* this non-public one is for internal conversions *\/\n+        @Override\n+        @ForceInline\n+        final HalffloatVector fromIntValues(int[] values) {\n+            VectorIntrinsics.requireLength(values.length, laneCount);\n+            Float16[] va = new Float16[laneCount()];\n+            for (int i = 0; i < va.length; i++) {\n+                int lv = values[i];\n+                Float16 v = Float16.valueOf(lv);\n+                va[i] = v;\n+                if ( v.intValue() != lv) {\n+                    throw badElementBits(lv, v);\n+                }\n+            }\n+            return dummyVector().fromArray0(va, 0);\n+        }\n+\n+        \/\/ Virtual constructors\n+\n+        @ForceInline\n+        @Override final\n+        public HalffloatVector fromArray(Object a, int offset) {\n+            \/\/ User entry point\n+            \/\/ Defer only to the equivalent method on the vector class, using the same inputs\n+            return HalffloatVector\n+                .fromArray(this, (Float16[]) a, offset);\n+        }\n+\n+        @ForceInline\n+        @Override final\n+        public HalffloatVector fromMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n+            \/\/ User entry point\n+            \/\/ Defer only to the equivalent method on the vector class, using the same inputs\n+            return HalffloatVector\n+                .fromMemorySegment(this, ms, offset, bo);\n+        }\n+\n+        @ForceInline\n+        @Override final\n+        HalffloatVector dummyVector() {\n+            return (HalffloatVector) super.dummyVector();\n+        }\n+\n+        \/*package-private*\/\n+        final @Override\n+        @ForceInline\n+        HalffloatVector rvOp(RVOp f) {\n+            Float16[] res = new Float16[laneCount()];\n+            for (int i = 0; i < res.length; i++) {\n+                short bits = (short) f.apply(i);\n+                res[i] = fromBits(bits);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        HalffloatVector vOp(FVOp f) {\n+            Float16[] res = new Float16[laneCount()];\n+            for (int i = 0; i < res.length; i++) {\n+                res[i] = f.apply(i);\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        HalffloatVector vOp(VectorMask<Float16> m, FVOp f) {\n+            Float16[] res = new Float16[laneCount()];\n+            boolean[] mbits = ((AbstractMask<Float16>)m).getBits();\n+            for (int i = 0; i < res.length; i++) {\n+                if (mbits[i]) {\n+                    res[i] = f.apply(i);\n+                }\n+            }\n+            return dummyVector().vectorFactory(res);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> HalffloatVector ldOp(M memory, int offset,\n+                                      FLdOp<M> f) {\n+            return dummyVector().ldOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> HalffloatVector ldOp(M memory, int offset,\n+                                      VectorMask<Float16> m,\n+                                      FLdOp<M> f) {\n+            return dummyVector().ldOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        HalffloatVector ldLongOp(MemorySegment memory, long offset,\n+                                      VectorMask<Float16> m,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stOp(M memory, int offset, FStOp<M> f) {\n+            dummyVector().stOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stOp(M memory, int offset,\n+                      AbstractMask<Float16> m,\n+                      FStOp<M> f) {\n+            dummyVector().stOp(memory, offset, m, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset,\n+                      AbstractMask<Float16> m,\n+                      FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n+        \/\/ N.B. Make sure these constant vectors and\n+        \/\/ masks load up correctly into registers.\n+        \/\/\n+        \/\/ Also, see if we can avoid all that switching.\n+        \/\/ Could we cache both vectors and both masks in\n+        \/\/ this species object?\n+\n+        \/\/ Zero and iota vector access\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector zero() {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.ZERO;\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.ZERO;\n+                case 128: return Halffloat128Vector.ZERO;\n+                case 256: return Halffloat256Vector.ZERO;\n+                case 512: return Halffloat512Vector.ZERO;\n+            }\n+            throw new AssertionError();\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public final HalffloatVector iota() {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.IOTA;\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.IOTA;\n+                case 128: return Halffloat128Vector.IOTA;\n+                case 256: return Halffloat256Vector.IOTA;\n+                case 512: return Halffloat512Vector.IOTA;\n+            }\n+            throw new AssertionError();\n+        }\n+\n+        \/\/ Mask access\n+        @Override\n+        @ForceInline\n+        public final VectorMask<Float16> maskAll(boolean bit) {\n+            if ((Class<?>) vectorType() == HalffloatMaxVector.class)\n+                return HalffloatMaxVector.HalffloatMaxMask.maskAll(bit);\n+            switch (vectorBitSize()) {\n+                case 64: return Halffloat64Vector.Halffloat64Mask.maskAll(bit);\n+                case 128: return Halffloat128Vector.Halffloat128Mask.maskAll(bit);\n+                case 256: return Halffloat256Vector.Halffloat256Mask.maskAll(bit);\n+                case 512: return Halffloat512Vector.Halffloat512Mask.maskAll(bit);\n+            }\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    \/**\n+     * Finds a species for an element type of {@code Float16} and shape.\n+     *\n+     * @param s the shape\n+     * @return a species for an element type of {@code Float16} and shape\n+     * @throws IllegalArgumentException if no such species exists for the shape\n+     *\/\n+    static HalffloatSpecies species(VectorShape s) {\n+        Objects.requireNonNull(s);\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (HalffloatSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (HalffloatSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (HalffloatSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (HalffloatSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (HalffloatSpecies) SPECIES_MAX;\n+            default: throw new IllegalArgumentException(\"Bad shape: \" + s);\n+        }\n+    }\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_64_BIT VectorShape.S_64_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_64\n+        = new HalffloatSpecies(VectorShape.S_64_BIT,\n+                            Halffloat64Vector.class,\n+                            Halffloat64Vector.Halffloat64Mask.class,\n+                            Halffloat64Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_128_BIT VectorShape.S_128_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_128\n+        = new HalffloatSpecies(VectorShape.S_128_BIT,\n+                            Halffloat128Vector.class,\n+                            Halffloat128Vector.Halffloat128Mask.class,\n+                            Halffloat128Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_256_BIT VectorShape.S_256_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_256\n+        = new HalffloatSpecies(VectorShape.S_256_BIT,\n+                            Halffloat256Vector.class,\n+                            Halffloat256Vector.Halffloat256Mask.class,\n+                            Halffloat256Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_512_BIT VectorShape.S_512_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_512\n+        = new HalffloatSpecies(VectorShape.S_512_BIT,\n+                            Halffloat512Vector.class,\n+                            Halffloat512Vector.Halffloat512Mask.class,\n+                            Halffloat512Vector::new);\n+\n+    \/** Species representing {@link HalffloatVector}s of {@link VectorShape#S_Max_BIT VectorShape.S_Max_BIT}. *\/\n+    public static final VectorSpecies<Float16> SPECIES_MAX\n+        = new HalffloatSpecies(VectorShape.S_Max_BIT,\n+                            HalffloatMaxVector.class,\n+                            HalffloatMaxVector.HalffloatMaxMask.class,\n+                            HalffloatMaxVector::new);\n+\n+    \/**\n+     * Preferred species for {@link HalffloatVector}s.\n+     * A preferred species is a species of maximal bit-size for the platform.\n+     *\/\n+    public static final VectorSpecies<Float16> SPECIES_PREFERRED\n+        = (HalffloatSpecies) VectorSpecies.ofPreferred(Float16.class);\n+}\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatVector.java","additions":3853,"deletions":0,"binary":false,"changes":3853,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        int res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Int128Mask.class, (Int128Mask) m);  \/\/ specialized\n+        int res = super.reduceLanesTemplate(op, Int128Mask.class, (Int128Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -661,1 +663,1 @@\n-                Int128Mask.class, int.class, VLENGTH, offset, limit,\n+                Int128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        int res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Int256Mask.class, (Int256Mask) m);  \/\/ specialized\n+        int res = super.reduceLanesTemplate(op, Int256Mask.class, (Int256Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -669,1 +671,1 @@\n-                Int256Mask.class, int.class, VLENGTH, offset, limit,\n+                Int256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        int res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Int512Mask.class, (Int512Mask) m);  \/\/ specialized\n+        int res = super.reduceLanesTemplate(op, Int512Mask.class, (Int512Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -685,1 +687,1 @@\n-                Int512Mask.class, int.class, VLENGTH, offset, limit,\n+                Int512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        int res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Int64Mask.class, (Int64Mask) m);  \/\/ specialized\n+        int res = super.reduceLanesTemplate(op, Int64Mask.class, (Int64Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -657,1 +659,1 @@\n-                Int64Mask.class, int.class, VLENGTH, offset, limit,\n+                Int64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        int res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, IntMaxMask.class, (IntMaxMask) m);  \/\/ specialized\n+        int res = super.reduceLanesTemplate(op, IntMaxMask.class, (IntMaxMask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -655,1 +657,1 @@\n-                IntMaxMask.class, int.class, VLENGTH, offset, limit,\n+                IntMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2208,2 +2208,1 @@\n-                int sc = (int) scale_;\n-                return v.add(sc == 1 ? iota : iota.mul(sc));\n+                return v.add(scale_ == 1 ? iota : iota.mul((int)scale_));\n@@ -2272,1 +2271,2 @@\n-        VectorMask<Integer> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((int)(length() - origin))));\n+        int pivotidx = (int)(length() - origin);\n+        VectorMask<Integer> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2302,1 +2302,2 @@\n-        VectorMask<Integer> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((int)(length() - origin))));\n+        int pivotidx = (int)(length() - origin);\n+        VectorMask<Integer> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2364,1 +2365,1 @@\n-                                                                  (broadcast((int)(origin))));\n+                                                                  broadcast((int)(origin)));\n@@ -2929,1 +2930,1 @@\n-            res[i] = (double) a[i];\n+            res[i] = ((double) a[i]);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG);\n+    LONG(long.class, Long.class, long[].class, 'I', -1, Long.SIZE, T_LONG),\n+    FLOAT16(Float16.class, Float16.class, Float16[].class, 'F', 11, Float16.SIZE, T_FLOAT16);\n@@ -68,2 +69,2 @@\n-        this.typeChar = genericElementType.getSimpleName().charAt(0);\n-        assert(\"FDBSIL\".indexOf(typeChar) == ordinal()) : this;\n+        this.typeChar = genericElementType.getSimpleName().charAt(getElementTypeIndex(elementType));\n+        assert(\"FDBSILo\".indexOf(typeChar) == ordinal()) : this;\n@@ -75,1 +76,1 @@\n-        assert(\"....zcFDBSILoav..\".charAt(basicType) == typeChar);\n+        assert(\"....zoFDBSILSoav..\".charAt(basicType) == typeChar);\n@@ -111,0 +112,8 @@\n+    static int getElementTypeIndex(Class<?> elementType) {\n+        if (elementType == java.lang.Float16.class) {\n+            return 2;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n@@ -117,1 +126,1 @@\n-        int c0 = elementType.getName().charAt(0);\n+        int c0 = elementType.getSimpleName().charAt(getElementTypeIndex(elementType));\n@@ -187,1 +196,2 @@\n-        SK_LIMIT    = 7;\n+        SK_FLOAT16  = 7,\n+        SK_LIMIT    = 8;\n@@ -228,1 +238,1 @@\n-            int c0 = value.elementType.getName().charAt(0);\n+            int c0 = value.elementType.getSimpleName().charAt(getElementTypeIndex(value.elementType));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LaneType.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        long res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -352,1 +353,2 @@\n-        return (long) super.reduceLanesTemplate(op, Long128Mask.class, (Long128Mask) m);  \/\/ specialized\n+        long res = super.reduceLanesTemplate(op, Long128Mask.class, (Long128Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -647,1 +649,1 @@\n-                Long128Mask.class, long.class, VLENGTH, offset, limit,\n+                Long128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        long res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -352,1 +353,2 @@\n-        return (long) super.reduceLanesTemplate(op, Long256Mask.class, (Long256Mask) m);  \/\/ specialized\n+        long res = super.reduceLanesTemplate(op, Long256Mask.class, (Long256Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -651,1 +653,1 @@\n-                Long256Mask.class, long.class, VLENGTH, offset, limit,\n+                Long256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        long res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -352,1 +353,2 @@\n-        return (long) super.reduceLanesTemplate(op, Long512Mask.class, (Long512Mask) m);  \/\/ specialized\n+        long res = super.reduceLanesTemplate(op, Long512Mask.class, (Long512Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -659,1 +661,1 @@\n-                Long512Mask.class, long.class, VLENGTH, offset, limit,\n+                Long512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        long res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -352,1 +353,2 @@\n-        return (long) super.reduceLanesTemplate(op, Long64Mask.class, (Long64Mask) m);  \/\/ specialized\n+        long res = super.reduceLanesTemplate(op, Long64Mask.class, (Long64Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -645,1 +647,1 @@\n-                Long64Mask.class, long.class, VLENGTH, offset, limit,\n+                Long64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -345,1 +345,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        long res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -352,1 +353,2 @@\n-        return (long) super.reduceLanesTemplate(op, LongMaxMask.class, (LongMaxMask) m);  \/\/ specialized\n+        long res = super.reduceLanesTemplate(op, LongMaxMask.class, (LongMaxMask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -645,1 +647,1 @@\n-                LongMaxMask.class, long.class, VLENGTH, offset, limit,\n+                LongMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2095,2 +2095,1 @@\n-                long sc = (long) scale_;\n-                return v.add(sc == 1 ? iota : iota.mul(sc));\n+                return v.add(scale_ == 1 ? iota : iota.mul((long)scale_));\n@@ -2138,1 +2137,2 @@\n-        VectorMask<Long> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((long)(length() - origin))));\n+        long pivotidx = (long)(length() - origin);\n+        VectorMask<Long> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2168,1 +2168,2 @@\n-        VectorMask<Long> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((long)(length() - origin))));\n+        long pivotidx = (long)(length() - origin);\n+        VectorMask<Long> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2230,1 +2231,1 @@\n-                                                                  (broadcast((long)(origin))));\n+                                                                  broadcast((long)(origin)));\n@@ -2790,1 +2791,1 @@\n-            res[i] = (double) a[i];\n+            res[i] = ((double) a[i]);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        short res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Short128Mask.class, (Short128Mask) m);  \/\/ specialized\n+        short res = super.reduceLanesTemplate(op, Short128Mask.class, (Short128Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -669,1 +671,1 @@\n-                Short128Mask.class, short.class, VLENGTH, offset, limit,\n+                Short128Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        short res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Short256Mask.class, (Short256Mask) m);  \/\/ specialized\n+        short res = super.reduceLanesTemplate(op, Short256Mask.class, (Short256Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -685,1 +687,1 @@\n-                Short256Mask.class, short.class, VLENGTH, offset, limit,\n+                Short256Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        short res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Short512Mask.class, (Short512Mask) m);  \/\/ specialized\n+        short res = super.reduceLanesTemplate(op, Short512Mask.class, (Short512Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -717,1 +719,1 @@\n-                Short512Mask.class, short.class, VLENGTH, offset, limit,\n+                Short512Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        short res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, Short64Mask.class, (Short64Mask) m);  \/\/ specialized\n+        short res = super.reduceLanesTemplate(op, Short64Mask.class, (Short64Mask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -661,1 +663,1 @@\n-                Short64Mask.class, short.class, VLENGTH, offset, limit,\n+                Short64Mask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,1 +350,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        short res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return  (long) res;\n@@ -357,1 +358,2 @@\n-        return (long) super.reduceLanesTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialized\n+        short res = super.reduceLanesTemplate(op, ShortMaxMask.class, (ShortMaxMask) m);  \/\/ specialized\n+        return  (long) res;\n@@ -655,1 +657,1 @@\n-                ShortMaxMask.class, short.class, VLENGTH, offset, limit,\n+                ShortMaxMask.class, ETYPE, VLENGTH, offset, limit,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2224,2 +2224,1 @@\n-                short sc = (short) scale_;\n-                return v.add(sc == 1 ? iota : iota.mul(sc));\n+                return v.add(scale_ == 1 ? iota : iota.mul((short)scale_));\n@@ -2288,1 +2287,2 @@\n-        VectorMask<Short> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n+        short pivotidx = (short)(length() - origin);\n+        VectorMask<Short> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2318,1 +2318,2 @@\n-        VectorMask<Short> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast((short)(length() - origin))));\n+        short pivotidx = (short)(length() - origin);\n+        VectorMask<Short> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2380,1 +2381,1 @@\n-                                                                  (broadcast((short)(origin))));\n+                                                                  broadcast((short)(origin)));\n@@ -2952,1 +2953,1 @@\n-            res[i] = (double) a[i];\n+            res[i] = ((double) a[i]);\n@@ -4014,1 +4015,1 @@\n-    Vector<?>\n+    HalffloatVector\n@@ -4016,3 +4017,2 @@\n-        LaneType flt = LaneType.SHORT.asFloating();\n-        \/\/ asFloating() will throw UnsupportedOperationException for the unsupported type short\n-        throw new AssertionError(\"Cannot reach here\");\n+        LaneType flt = LaneType.FLOAT16.asFloating();\n+        return (HalffloatVector) asVectorRaw(flt);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3030,0 +3030,13 @@\n+    \/**\n+     * Reinterprets this vector as a vector of the same shape\n+     * and contents but a lane type of {@code Float16},\n+     * where the lanes are assembled from successive bytes\n+     * according to little-endian order.\n+     * It is a convenience method for the expression\n+     * {@code reinterpretShape(species().withLanes(Float16.class))}.\n+     * It may be considered an inverse to {@link Vector#reinterpretAsBytes()}.\n+     *\n+     * @return a {@code HalffloatVector} with the same shape and information content\n+     *\/\n+    public abstract HalffloatVector reinterpretAsHalffloats();\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -240,0 +240,8 @@\n+    private static Class<?> getEffectiveLaneType(Class<?> elementType) {\n+        if (elementType == Float16.class) {\n+            return short.class;\n+        } else {\n+            return elementType;\n+        }\n+    }\n+\n@@ -243,1 +251,1 @@\n-            Class<?> etype = type.elementType;\n+            Class<?> etype = getEffectiveLaneType(type.elementType);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShape.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * {@code $type$} values.\n+ * {@code $elemtype$} values.\n@@ -54,1 +54,1 @@\n-    $abstractvectortype$($type$[] vec) {\n+    $abstractvectortype$($elemtype$[] vec) {\n@@ -64,1 +64,1 @@\n-    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withByteAlignment(1);\n+    static final ValueLayout.Of{#if[FP16]?Short:$Elemtype$} ELEMENT_LAYOUT = ValueLayout.JAVA_{#if[FP16]?SHORT:$TYPE$}.withByteAlignment(1);\n@@ -101,1 +101,1 @@\n-    abstract $type$[] vec();\n+    abstract $elemtype$[] vec();\n@@ -110,1 +110,1 @@\n-    abstract $abstractvectortype$ vectorFactory($type$[] vec);\n+    abstract $abstractvectortype$ vectorFactory($elemtype$[] vec);\n@@ -125,1 +125,1 @@\n-        $type$ apply(int i);\n+        $elemtype$ apply(int i);\n@@ -132,1 +132,1 @@\n-        $type$[] res = new $type$[length()];\n+        $elemtype$[] res = new $elemtype$[length()];\n@@ -142,1 +142,1 @@\n-        $type$[] res = new $type$[length()];\n+        $elemtype$[] res = new $elemtype$[length()];\n@@ -156,1 +156,1 @@\n-        $type$ apply(int i, $type$ a);\n+        $elemtype$ apply(int i, $elemtype$ a);\n@@ -165,2 +165,2 @@\n-        $type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n+        $elemtype$[] vec = vec();\n+        $elemtype$[] res = new $elemtype$[length()];\n@@ -184,2 +184,2 @@\n-        $type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n+        $elemtype$[] vec = vec();\n+        $elemtype$[] res = new $elemtype$[length()];\n@@ -197,1 +197,1 @@\n-        $type$ apply(int i, $type$ a, $type$ b);\n+        $elemtype$ apply(int i, $elemtype$ a, $elemtype$ b);\n@@ -208,3 +208,3 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o).vec();\n+        $elemtype$[] res = new $elemtype$[length()];\n+        $elemtype$[] vec1 = this.vec();\n+        $elemtype$[] vec2 = (($abstractvectortype$)o).vec();\n@@ -230,3 +230,3 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o).vec();\n+        $elemtype$[] res = new $elemtype$[length()];\n+        $elemtype$[] vec1 = this.vec();\n+        $elemtype$[] vec2 = (($abstractvectortype$)o).vec();\n@@ -244,1 +244,1 @@\n-        $type$ apply(int i, $type$ a, $type$ b, $type$ c);\n+        $elemtype$ apply(int i, $elemtype$ a, $elemtype$ b, $elemtype$ c);\n@@ -257,4 +257,4 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o1).vec();\n-        $type$[] vec3 = (($abstractvectortype$)o2).vec();\n+        $elemtype$[] res = new $elemtype$[length()];\n+        $elemtype$[] vec1 = this.vec();\n+        $elemtype$[] vec2 = (($abstractvectortype$)o1).vec();\n+        $elemtype$[] vec3 = (($abstractvectortype$)o2).vec();\n@@ -282,4 +282,4 @@\n-        $type$[] res = new $type$[length()];\n-        $type$[] vec1 = this.vec();\n-        $type$[] vec2 = (($abstractvectortype$)o1).vec();\n-        $type$[] vec3 = (($abstractvectortype$)o2).vec();\n+        $elemtype$[] res = new $elemtype$[length()];\n+        $elemtype$[] vec1 = this.vec();\n+        $elemtype$[] vec2 = (($abstractvectortype$)o1).vec();\n+        $elemtype$[] vec3 = (($abstractvectortype$)o2).vec();\n@@ -297,1 +297,1 @@\n-    $type$ rOp($type$ v, VectorMask<$Boxtype$> m, FBinOp f);\n+    $elemtype$ rOp($elemtype$ v, VectorMask<$Boxtype$> m, FBinOp f);\n@@ -301,1 +301,1 @@\n-    $type$ rOpTemplate($type$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n+    $elemtype$ rOpTemplate($elemtype$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n@@ -305,1 +305,1 @@\n-        $type$[] vec = vec();\n+        $elemtype$[] vec = vec();\n@@ -315,2 +315,2 @@\n-    $type$ rOpTemplate($type$ v, FBinOp f) {\n-        $type$[] vec = vec();\n+    $elemtype$ rOpTemplate($elemtype$ v, FBinOp f) {\n+        $elemtype$[] vec = vec();\n@@ -327,1 +327,1 @@\n-        $type$ apply(M memory, int offset, int i);\n+        $elemtype$ apply(M memory, int offset, int i);\n@@ -336,1 +336,1 @@\n-        $type$[] res = new $type$[length()];\n+        $elemtype$[] res = new $elemtype$[length()];\n@@ -349,2 +349,2 @@\n-        \/\/$type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n+        \/\/$elemtype$[] vec = vec();\n+        $elemtype$[] res = new $elemtype$[length()];\n@@ -362,1 +362,1 @@\n-        $type$ apply(MemorySegment memory, long offset, int i);\n+        $elemtype$ apply(MemorySegment memory, long offset, int i);\n@@ -371,1 +371,1 @@\n-        $type$[] res = new $type$[length()];\n+        $elemtype$[] res = new $elemtype$[length()];\n@@ -384,2 +384,2 @@\n-        \/\/$type$[] vec = vec();\n-        $type$[] res = new $type$[length()];\n+        \/\/$elemtype$[] vec = vec();\n+        $elemtype$[] res = new $elemtype$[length()];\n@@ -395,2 +395,2 @@\n-    static $type$ memorySegmentGet(MemorySegment ms, long o, int i) {\n-        return ms.get(ELEMENT_LAYOUT, o + i * $sizeInBytes$L);\n+    static $elemtype$ memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return {#if[FP16]?Float16.valueOf(ms.get(ELEMENT_LAYOUT, o + i * $sizeInBytes$L)):ms.get(ELEMENT_LAYOUT, o + i * $sizeInBytes$L)};\n@@ -400,1 +400,1 @@\n-        void apply(M memory, int offset, int i, $type$ a);\n+        void apply(M memory, int offset, int i, $elemtype$ a);\n@@ -408,1 +408,1 @@\n-        $type$[] vec = vec();\n+        $elemtype$[] vec = vec();\n@@ -420,1 +420,1 @@\n-        $type$[] vec = vec();\n+        $elemtype$[] vec = vec();\n@@ -430,1 +430,1 @@\n-        void apply(MemorySegment memory, long offset, int i, $type$ a);\n+        void apply(MemorySegment memory, long offset, int i, $elemtype$ a);\n@@ -438,1 +438,1 @@\n-        $type$[] vec = vec();\n+        $elemtype$[] vec = vec();\n@@ -450,1 +450,1 @@\n-        $type$[] vec = vec();\n+        $elemtype$[] vec = vec();\n@@ -459,2 +459,2 @@\n-    static void memorySegmentSet(MemorySegment ms, long o, int i, $type$ e) {\n-        ms.set(ELEMENT_LAYOUT, o + i * $sizeInBytes$L, e);\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, $elemtype$ e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * $sizeInBytes$L, {#if[FP16]?e.shortValue():e});\n@@ -467,1 +467,1 @@\n-        boolean apply(int cond, int i, $type$ a, $type$ b);\n+        boolean apply(int cond, int i, $elemtype$ a, $elemtype$ b);\n@@ -476,2 +476,2 @@\n-        $type$[] vec1 = vec();\n-        $type$[] vec2 = (($abstractvectortype$)o).vec();\n+        $elemtype$[] vec1 = vec();\n+        $elemtype$[] vec2 = (($abstractvectortype$)o).vec();\n@@ -488,1 +488,1 @@\n-    static $type$ rotateLeft($type$ a, int n) {\n+    static $elemtype$ rotateLeft($elemtype$ a, int n) {\n@@ -492,1 +492,1 @@\n-        return ($type$)((((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) << (n & $Boxtype$.SIZE-1)) | (((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) >>> ($Boxtype$.SIZE - (n & $Boxtype$.SIZE-1))));\n+        return ($elemtype$)((((($elemtype$)a) & $Boxtype$.toUnsignedInt(($elemtype$)-1)) << (n & $Boxtype$.SIZE-1)) | (((($elemtype$)a) & $Boxtype$.toUnsignedInt(($elemtype$)-1)) >>> ($Boxtype$.SIZE - (n & $Boxtype$.SIZE-1))));\n@@ -498,1 +498,1 @@\n-    static $type$ rotateRight($type$ a, int n) {\n+    static $elemtype$ rotateRight($elemtype$ a, int n) {\n@@ -502,1 +502,1 @@\n-        return ($type$)((((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) >>> (n & $Boxtype$.SIZE-1)) | (((($type$)a) & $Boxtype$.toUnsignedInt(($type$)-1)) << ($Boxtype$.SIZE - (n & $Boxtype$.SIZE-1))));\n+        return ($elemtype$)((((($elemtype$)a) & $Boxtype$.toUnsignedInt(($elemtype$)-1)) >>> (n & $Boxtype$.SIZE-1)) | (((($elemtype$)a) & $Boxtype$.toUnsignedInt(($elemtype$)-1)) << ($Boxtype$.SIZE - (n & $Boxtype$.SIZE-1))));\n@@ -513,2 +513,2 @@\n-    static long toBits($type$ e) {\n-        return {#if[FP]? $Type$.$type$ToRaw$Bitstype$Bits(e): e};\n+    static long toBits($elemtype$ e) {\n+        return {#if[FP]?$Elemtype$.$fptype$ToRaw$Bitstype$Bits(e): e};\n@@ -519,2 +519,2 @@\n-    static $type$ fromBits(long bits) {\n-        return {#if[FP]?$Type$.$bitstype$BitsTo$Type$}(($bitstype$)bits);\n+    static $elemtype$ fromBits(long bits) {\n+        return {#if[FP]?$Elemtype$.$bitstype$BitsTo$Fptype$}(($bitstype$)bits);\n@@ -578,2 +578,2 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),\n-                        toBits(0.0f), MODE_BROADCAST, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $elemtype$.class, species.length(),\n+                        toBits({#if[FP16]?Float16.valueOf(0.0f):0.0f}), MODE_BROADCAST, vsp,\n@@ -582,1 +582,1 @@\n-        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $elemtype$.class, species.length(),\n@@ -613,1 +613,1 @@\n-    public abstract $abstractvectortype$ broadcast($type$ e);\n+    public abstract $abstractvectortype$ broadcast($elemtype$ e);\n@@ -629,1 +629,1 @@\n-    public static $abstractvectortype$ broadcast(VectorSpecies<$Boxtype$> species, $type$ e) {\n+    public static $abstractvectortype$ broadcast(VectorSpecies<$Boxtype$> species, $elemtype$ e) {\n@@ -636,1 +636,1 @@\n-    final $abstractvectortype$ broadcastTemplate($type$ e) {\n+    final $abstractvectortype$ broadcastTemplate($elemtype$ e) {\n@@ -646,1 +646,1 @@\n-     * {@linkplain #broadcast($type$) the more strongly typed method}\n+     * {@linkplain #broadcast($elemtype$) the more strongly typed method}\n@@ -648,1 +648,1 @@\n-     * using a cast: {@code v.broadcast(($type$)e)}.\n+     * using a cast: {@code v.broadcast(($elemtype$)e)}.\n@@ -670,1 +670,1 @@\n-     * @see #broadcast(VectorSpecies,$type$)\n+     * @see #broadcast(VectorSpecies,$elemtype$)\n@@ -709,1 +709,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $elemtype$.class, length(),\n@@ -739,1 +739,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $elemtype$.class, length(),\n@@ -751,1 +751,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) -a);\n+                    v0.uOp(m, (i, a) -> ($elemtype$) {#if[FP16]?Float16.valueOf(-a.floatValue()):-a});\n@@ -753,1 +753,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.abs(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) {#if[FP16]?Float16.abs(a):Math.abs(a)});\n@@ -757,1 +757,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.bitCount(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) $Boxtype$.bitCount(a));\n@@ -759,1 +759,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfTrailingZeros(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) $Boxtype$.numberOfTrailingZeros(a));\n@@ -761,1 +761,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfLeadingZeros(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) $Boxtype$.numberOfLeadingZeros(a));\n@@ -763,1 +763,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverse(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) $Boxtype$.reverse(a));\n@@ -766,1 +766,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) bitCount(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) bitCount(a));\n@@ -768,1 +768,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) numberOfTrailingZeros(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) numberOfTrailingZeros(a));\n@@ -770,1 +770,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) numberOfLeadingZeros(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) numberOfLeadingZeros(a));\n@@ -780,1 +780,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverseBytes(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) $Boxtype$.reverseBytes(a));\n@@ -785,0 +785,1 @@\n+#if[!FP16]\n@@ -786,1 +787,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.sin(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.sin(a));\n@@ -788,1 +789,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.cos(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.cos(a));\n@@ -790,1 +791,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.tan(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.tan(a));\n@@ -792,1 +793,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.asin(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.asin(a));\n@@ -794,1 +795,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.acos(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.acos(a));\n@@ -796,1 +797,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.atan(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.atan(a));\n@@ -798,1 +799,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.exp(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.exp(a));\n@@ -800,1 +801,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.log(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.log(a));\n@@ -802,1 +803,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.log10(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.log10(a));\n@@ -804,1 +805,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.sqrt(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.sqrt(a));\n@@ -806,1 +807,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.cbrt(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.cbrt(a));\n@@ -808,1 +809,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.sinh(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.sinh(a));\n@@ -810,1 +811,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.cosh(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.cosh(a));\n@@ -812,1 +813,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.tanh(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.tanh(a));\n@@ -814,1 +815,1 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.expm1(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.expm1(a));\n@@ -816,1 +817,35 @@\n-                    v0.uOp(m, (i, a) -> ($type$) Math.log1p(a));\n+                    v0.uOp(m, (i, a) -> ($elemtype$) Math.log1p(a));\n+#else[!FP16]\n+            case VECTOR_OP_SIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.sin(a.floatValue())));\n+            case VECTOR_OP_COS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.cos(a.floatValue())));\n+            case VECTOR_OP_TAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.tan(a.floatValue())));\n+            case VECTOR_OP_ASIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.asin(a.floatValue())));\n+            case VECTOR_OP_ACOS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.acos(a.floatValue())));\n+            case VECTOR_OP_ATAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.atan(a.floatValue())));\n+            case VECTOR_OP_EXP: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.exp(a.floatValue())));\n+            case VECTOR_OP_LOG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.log(a.floatValue())));\n+            case VECTOR_OP_LOG10: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.log10(a.floatValue())));\n+            case VECTOR_OP_SQRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.sqrt(a.floatValue())));\n+            case VECTOR_OP_CBRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.cbrt(a.floatValue())));\n+            case VECTOR_OP_SINH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.sinh(a.floatValue())));\n+            case VECTOR_OP_COSH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.cosh(a.floatValue())));\n+            case VECTOR_OP_TANH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.tanh(a.floatValue())));\n+            case VECTOR_OP_EXPM1: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.expm1(a.floatValue())));\n+            case VECTOR_OP_LOG1P: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Float16.valueOf(Math.log1p(a.floatValue())));\n+#end[!FP16]\n@@ -826,2 +861,2 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$)\n-     * @see #lanewise(VectorOperators.Binary,$type$,VectorMask)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$,VectorMask)\n@@ -859,1 +894,1 @@\n-                VectorMask<$Boxtype$> eqz = that.eq(($type$) 0);\n+                VectorMask<$Boxtype$> eqz = that.eq(($elemtype$) 0);\n@@ -869,1 +904,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $elemtype$.class, length(),\n@@ -876,1 +911,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$,VectorMask)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$,VectorMask)\n@@ -901,1 +936,1 @@\n-                    = this.compare(EQ, ($type$) 0, m);\n+                    = this.compare(EQ, ($elemtype$) 0, m);\n@@ -918,1 +953,1 @@\n-                VectorMask<$Boxtype$> eqz = that.eq(($type$)0);\n+                VectorMask<$Boxtype$> eqz = that.eq(($elemtype$)0);\n@@ -930,1 +965,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $elemtype$.class, length(),\n@@ -941,0 +976,14 @@\n+#if[FP16]\n+            case VECTOR_OP_ADD: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.add(a, b));\n+            case VECTOR_OP_SUB: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.subtract(a, b));\n+            case VECTOR_OP_MUL: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.multiply(a, b));\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.divide(a, b));\n+            case VECTOR_OP_MAX: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.max(a, b));\n+            case VECTOR_OP_MIN: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.min(a, b));\n+#else[FP16]\n@@ -942,1 +991,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a + b));\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$)(a + b));\n@@ -944,1 +993,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a - b));\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$)(a - b));\n@@ -946,1 +995,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a * b));\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$)(a * b));\n@@ -948,1 +997,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a \/ b));\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$)(a \/ b));\n@@ -950,1 +999,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.max(a, b));\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$)Math.max(a, b));\n@@ -952,1 +1001,2 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)Math.min(a, b));\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$)Math.min(a, b));\n+#end[FP16]\n@@ -955,1 +1005,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a & b));\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$)(a & b));\n@@ -957,1 +1007,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a | b));\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$)(a | b));\n@@ -959,1 +1009,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$)(a ^ b));\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$)(a ^ b));\n@@ -961,1 +1011,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> ($type$)(a << n));\n+                    v0.bOp(v1, vm, (i, a, n) -> ($elemtype$)(a << n));\n@@ -963,1 +1013,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> ($type$)(a >> n));\n+                    v0.bOp(v1, vm, (i, a, n) -> ($elemtype$)(a >> n));\n@@ -965,1 +1015,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n+                    v0.bOp(v1, vm, (i, a, n) -> ($elemtype$)((a & LSHR_SETUP_MASK) >>> n));\n@@ -978,0 +1028,1 @@\n+#if[!FP16]\n@@ -981,1 +1032,8 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.atan2(a, b));\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$) Math.atan2(a, b));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$) Math.pow(a, b));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> ($elemtype$) Math.hypot(a, b));\n+#else[!FP16]\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.valueOf(Math.atan2(a.floatValue(), b.floatValue())));\n@@ -983,1 +1041,1 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.pow(a, b));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.valueOf(Math.pow(a.floatValue(), b.floatValue())));\n@@ -985,1 +1043,2 @@\n-                    v0.bOp(v1, vm, (i, a, b) -> ($type$) Math.hypot(a, b));\n+                    v0.bOp(v1, vm, (i, a, b) -> Float16.valueOf(Math.hypot(a.floatValue(), b.floatValue())));\n+#end[!FP16]\n@@ -1013,1 +1072,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$,VectorMask)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$,VectorMask)\n@@ -1018,1 +1077,1 @@\n-                                  $type$ e) {\n+                                  $elemtype$ e) {\n@@ -1020,1 +1079,1 @@\n-        if (opKind(op, VO_SHIFT) && ($type$)(int)e == e) {\n+        if (opKind(op, VO_SHIFT) && ($elemtype$)(int)e == e) {\n@@ -1024,1 +1083,1 @@\n-            op = AND; e = ($type$) ~e;\n+            op = AND; e = ($elemtype$) ~e;\n@@ -1048,1 +1107,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1053,1 +1112,1 @@\n-                                  $type$ e,\n+                                  $elemtype$ e,\n@@ -1056,1 +1115,1 @@\n-        if (opKind(op, VO_SHIFT) && ($type$)(int)e == e) {\n+        if (opKind(op, VO_SHIFT) && ($elemtype$)(int)e == e) {\n@@ -1060,1 +1119,1 @@\n-            op = AND; e = ($type$) ~e;\n+            op = AND; e = ($elemtype$) ~e;\n@@ -1071,1 +1130,1 @@\n-     * {@linkplain #lanewise(VectorOperators.Binary,$type$)\n+     * {@linkplain #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1074,1 +1133,1 @@\n-     * using a cast: {@code v.lanewise(op,($type$)e)}.\n+     * using a cast: {@code v.lanewise(op,($elemtype$)e)}.\n@@ -1081,1 +1140,1 @@\n-        $type$ e1 = ($type$) e;\n+        $elemtype$ e1 = {#if[FP16]?Float16.valueOf(e):($elemtype$) e};\n@@ -1087,1 +1146,1 @@\n-        if ((long)e1 != e) {\n+        if ({#if[FP16]?e1.longValue():(long)e1} != e) {\n@@ -1098,1 +1157,1 @@\n-     * {@linkplain #lanewise(VectorOperators.Binary,$type$,VectorMask)\n+     * {@linkplain #lanewise(VectorOperators.Binary,$elemtype$,VectorMask)\n@@ -1101,1 +1160,1 @@\n-     * using a cast: {@code v.lanewise(op,($type$)e,m)}.\n+     * using a cast: {@code v.lanewise(op,($elemtype$)e,m)}.\n@@ -1108,1 +1167,1 @@\n-        $type$ e1 = ($type$) e;\n+        $elemtype$ e1 = {#if[FP16]?Float16.valueOf(e):($elemtype$) e};\n@@ -1114,1 +1173,1 @@\n-        if ((long)e1 != e) {\n+        if ({#if[FP16]?e1.longValue():(long)e1} != e) {\n@@ -1137,1 +1196,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $elemtype$.class, length(),\n@@ -1158,1 +1217,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $elemtype$.class, length(),\n@@ -1170,1 +1229,1 @@\n-                    v.uOp(m, (i, a) -> ($type$)(a << n));\n+                    v.uOp(m, (i, a) -> ($elemtype$)(a << n));\n@@ -1172,1 +1231,1 @@\n-                    v.uOp(m, (i, a) -> ($type$)(a >> n));\n+                    v.uOp(m, (i, a) -> ($elemtype$)(a >> n));\n@@ -1174,1 +1233,1 @@\n-                    v.uOp(m, (i, a) -> ($type$)((a & LSHR_SETUP_MASK) >>> n));\n+                    v.uOp(m, (i, a) -> ($elemtype$)((a & LSHR_SETUP_MASK) >>> n));\n@@ -1193,1 +1252,1 @@\n-    private static final $type$ LSHR_SETUP_MASK = -1;\n+    private static final $elemtype$ LSHR_SETUP_MASK = -1;\n@@ -1209,6 +1268,6 @@\n-     * @see #lanewise(VectorOperators.Ternary,$type$,$type$,VectorMask)\n-     * @see #lanewise(VectorOperators.Ternary,Vector,$type$,VectorMask)\n-     * @see #lanewise(VectorOperators.Ternary,$type$,Vector,VectorMask)\n-     * @see #lanewise(VectorOperators.Ternary,$type$,$type$)\n-     * @see #lanewise(VectorOperators.Ternary,Vector,$type$)\n-     * @see #lanewise(VectorOperators.Ternary,$type$,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,$elemtype$,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,$elemtype$,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,$elemtype$)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,$elemtype$)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,Vector)\n@@ -1242,1 +1301,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $elemtype$.class, length(),\n@@ -1249,3 +1308,3 @@\n-     * @see #lanewise(VectorOperators.Ternary,$type$,$type$,VectorMask)\n-     * @see #lanewise(VectorOperators.Ternary,Vector,$type$,VectorMask)\n-     * @see #lanewise(VectorOperators.Ternary,$type$,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,$elemtype$,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,$elemtype$,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,Vector,VectorMask)\n@@ -1284,1 +1343,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $elemtype$.class, length(),\n@@ -1296,2 +1355,1 @@\n-            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) ->\n-                    v0.tOp(v1_, v2_, m, (i, a, b, c) -> Math.fma(a, b, c));\n+            case VECTOR_OP_FMA: return (v0, v1_, v2_, m) -> v0.tOp(v1_, v2_, m, (i, a, b, c) -> {#if[FP16]?Float16.fma(a, b, c):Math.fma(a, b, c)});\n@@ -1320,1 +1378,1 @@\n-     * @see #lanewise(VectorOperators.Ternary,$type$,$type$,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,$elemtype$,VectorMask)\n@@ -1325,2 +1383,2 @@\n-                                  $type$ e1,\n-                                  $type$ e2) {\n+                                  $elemtype$ e1,\n+                                  $elemtype$ e2) {\n@@ -1349,1 +1407,1 @@\n-     * @see #lanewise(VectorOperators.Ternary,$type$,$type$)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,$elemtype$)\n@@ -1354,2 +1412,2 @@\n-                                  $type$ e1,\n-                                  $type$ e2,\n+                                  $elemtype$ e1,\n+                                  $elemtype$ e2,\n@@ -1376,2 +1434,2 @@\n-     * @see #lanewise(VectorOperators.Ternary,$type$,$type$)\n-     * @see #lanewise(VectorOperators.Ternary,Vector,$type$,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,$elemtype$)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,$elemtype$,VectorMask)\n@@ -1383,1 +1441,1 @@\n-                                  $type$ e2) {\n+                                  $elemtype$ e2) {\n@@ -1406,2 +1464,2 @@\n-     * @see #lanewise(VectorOperators.Ternary,$type$,$type$,VectorMask)\n-     * @see #lanewise(VectorOperators.Ternary,Vector,$type$)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,$elemtype$,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,$elemtype$)\n@@ -1413,1 +1471,1 @@\n-                                  $type$ e2,\n+                                  $elemtype$ e2,\n@@ -1435,1 +1493,1 @@\n-     * @see #lanewise(VectorOperators.Ternary,$type$,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,Vector,VectorMask)\n@@ -1440,1 +1498,1 @@\n-                                  $type$ e1,\n+                                  $elemtype$ e1,\n@@ -1464,1 +1522,1 @@\n-     * @see #lanewise(VectorOperators.Ternary,$type$,Vector)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,Vector)\n@@ -1469,1 +1527,1 @@\n-                                  $type$ e1,\n+                                  $elemtype$ e1,\n@@ -1485,1 +1543,1 @@\n-     * @see #add($type$)\n+     * @see #add($elemtype$)\n@@ -1500,1 +1558,1 @@\n-     * {@link #lanewise(VectorOperators.Binary,$type$)\n+     * {@link #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1507,2 +1565,2 @@\n-     * @see #broadcast($type$)\n-     * @see #add($type$,VectorMask)\n+     * @see #broadcast($elemtype$)\n+     * @see #add($elemtype$,VectorMask)\n@@ -1511,1 +1569,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1515,1 +1573,1 @@\n-    $abstractvectortype$ add($type$ e) {\n+    $abstractvectortype$ add($elemtype$ e) {\n@@ -1521,1 +1579,1 @@\n-     * @see #add($type$,VectorMask)\n+     * @see #add($elemtype$,VectorMask)\n@@ -1538,1 +1596,1 @@\n-     * {@link #lanewise(VectorOperators.Binary,$type$,VectorMask)\n+     * {@link #lanewise(VectorOperators.Binary,$elemtype$,VectorMask)\n@@ -1546,2 +1604,2 @@\n-     * @see #broadcast($type$)\n-     * @see #add($type$)\n+     * @see #broadcast($elemtype$)\n+     * @see #add($elemtype$)\n@@ -1550,1 +1608,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1553,1 +1611,1 @@\n-    public final $abstractvectortype$ add($type$ e,\n+    public final $abstractvectortype$ add($elemtype$ e,\n@@ -1560,1 +1618,1 @@\n-     * @see #sub($type$)\n+     * @see #sub($elemtype$)\n@@ -1575,1 +1633,1 @@\n-     * {@link #lanewise(VectorOperators.Binary,$type$)\n+     * {@link #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1582,2 +1640,2 @@\n-     * @see #broadcast($type$)\n-     * @see #sub($type$,VectorMask)\n+     * @see #broadcast($elemtype$)\n+     * @see #sub($elemtype$,VectorMask)\n@@ -1586,1 +1644,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1589,1 +1647,1 @@\n-    public final $abstractvectortype$ sub($type$ e) {\n+    public final $abstractvectortype$ sub($elemtype$ e) {\n@@ -1595,1 +1653,1 @@\n-     * @see #sub($type$,VectorMask)\n+     * @see #sub($elemtype$,VectorMask)\n@@ -1612,1 +1670,1 @@\n-     * {@link #lanewise(VectorOperators.Binary,$type$,VectorMask)\n+     * {@link #lanewise(VectorOperators.Binary,$elemtype$,VectorMask)\n@@ -1620,2 +1678,2 @@\n-     * @see #broadcast($type$)\n-     * @see #sub($type$)\n+     * @see #broadcast($elemtype$)\n+     * @see #sub($elemtype$)\n@@ -1624,1 +1682,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1627,1 +1685,1 @@\n-    public final $abstractvectortype$ sub($type$ e,\n+    public final $abstractvectortype$ sub($elemtype$ e,\n@@ -1634,1 +1692,1 @@\n-     * @see #mul($type$)\n+     * @see #mul($elemtype$)\n@@ -1649,1 +1707,1 @@\n-     * {@link #lanewise(VectorOperators.Binary,$type$)\n+     * {@link #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1656,2 +1714,2 @@\n-     * @see #broadcast($type$)\n-     * @see #mul($type$,VectorMask)\n+     * @see #broadcast($elemtype$)\n+     * @see #mul($elemtype$,VectorMask)\n@@ -1660,1 +1718,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1663,1 +1721,1 @@\n-    public final $abstractvectortype$ mul($type$ e) {\n+    public final $abstractvectortype$ mul($elemtype$ e) {\n@@ -1669,1 +1727,1 @@\n-     * @see #mul($type$,VectorMask)\n+     * @see #mul($elemtype$,VectorMask)\n@@ -1686,1 +1744,1 @@\n-     * {@link #lanewise(VectorOperators.Binary,$type$,VectorMask)\n+     * {@link #lanewise(VectorOperators.Binary,$elemtype$,VectorMask)\n@@ -1694,2 +1752,2 @@\n-     * @see #broadcast($type$)\n-     * @see #mul($type$)\n+     * @see #broadcast($elemtype$)\n+     * @see #mul($elemtype$)\n@@ -1698,1 +1756,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1701,1 +1759,1 @@\n-    public final $abstractvectortype$ mul($type$ e,\n+    public final $abstractvectortype$ mul($elemtype$ e,\n@@ -1731,1 +1789,1 @@\n-     * {@link #lanewise(VectorOperators.Binary,$type$)\n+     * {@link #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1748,2 +1806,2 @@\n-     * @see #broadcast($type$)\n-     * @see #div($type$,VectorMask)\n+     * @see #broadcast($elemtype$)\n+     * @see #div($elemtype$,VectorMask)\n@@ -1752,1 +1810,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1755,1 +1813,1 @@\n-    public final $abstractvectortype$ div($type$ e) {\n+    public final $abstractvectortype$ div($elemtype$ e) {\n@@ -1761,1 +1819,1 @@\n-     * @see #div($type$,VectorMask)\n+     * @see #div($elemtype$,VectorMask)\n@@ -1787,1 +1845,1 @@\n-     * {@link #lanewise(VectorOperators.Binary,$type$,VectorMask)\n+     * {@link #lanewise(VectorOperators.Binary,$elemtype$,VectorMask)\n@@ -1805,2 +1863,2 @@\n-     * @see #broadcast($type$)\n-     * @see #div($type$)\n+     * @see #broadcast($elemtype$)\n+     * @see #div($elemtype$)\n@@ -1809,1 +1867,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1812,1 +1870,1 @@\n-    public final $abstractvectortype$ div($type$ e,\n+    public final $abstractvectortype$ div($elemtype$ e,\n@@ -1847,1 +1905,1 @@\n-     * {@link #lanewise(VectorOperators.Binary,$type$)\n+     * {@link #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1854,1 +1912,1 @@\n-     * @see #broadcast($type$)\n+     * @see #broadcast($elemtype$)\n@@ -1856,1 +1914,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$,VectorMask)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$,VectorMask)\n@@ -1865,1 +1923,1 @@\n-    public final $abstractvectortype$ min($type$ e) {\n+    public final $abstractvectortype$ min($elemtype$ e) {\n@@ -1892,1 +1950,1 @@\n-     * {@link #lanewise(VectorOperators.Binary,$type$)\n+     * {@link #lanewise(VectorOperators.Binary,$elemtype$)\n@@ -1899,1 +1957,1 @@\n-     * @see #broadcast($type$)\n+     * @see #broadcast($elemtype$)\n@@ -1901,1 +1959,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$,VectorMask)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$,VectorMask)\n@@ -1910,1 +1968,1 @@\n-    public final $abstractvectortype$ max($type$ e) {\n+    public final $abstractvectortype$ max($elemtype$ e) {\n@@ -1938,1 +1996,1 @@\n-     * @see #and($type$)\n+     * @see #and($elemtype$)\n@@ -1969,1 +2027,1 @@\n-    public final $abstractvectortype$ and($type$ e) {\n+    public final $abstractvectortype$ and($elemtype$ e) {\n@@ -1995,1 +2053,1 @@\n-     * @see #or($type$)\n+     * @see #or($elemtype$)\n@@ -2026,1 +2084,1 @@\n-    public final $abstractvectortype$ or($type$ e) {\n+    public final $abstractvectortype$ or($elemtype$ e) {\n@@ -2062,1 +2120,1 @@\n-     * @see #pow($type$)\n+     * @see #pow($elemtype$)\n@@ -2094,1 +2152,1 @@\n-     * @see #lanewise(VectorOperators.Binary,$type$,VectorMask)\n+     * @see #lanewise(VectorOperators.Binary,$elemtype$,VectorMask)\n@@ -2097,1 +2155,1 @@\n-    public final $abstractvectortype$ pow($type$ b) {\n+    public final $abstractvectortype$ pow($elemtype$ b) {\n@@ -2126,1 +2184,1 @@\n-    static int bitCount($type$ a) {\n+    static int bitCount($elemtype$ a) {\n@@ -2137,1 +2195,1 @@\n-    static int numberOfTrailingZeros($type$ a) {\n+    static int numberOfTrailingZeros($elemtype$ a) {\n@@ -2148,1 +2206,1 @@\n-    static int numberOfLeadingZeros($type$ a) {\n+    static int numberOfLeadingZeros($elemtype$ a) {\n@@ -2156,1 +2214,1 @@\n-    static $type$ reverse($type$ a) {\n+    static $elemtype$ reverse($elemtype$ a) {\n@@ -2160,4 +2218,4 @@\n-        $type$ b = rotateLeft(a, 8);\n-        b = ($type$) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n-        b = ($type$) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n-        b = ($type$) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        $elemtype$ b = rotateLeft(a, 8);\n+        b = ($elemtype$) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = ($elemtype$) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = ($elemtype$) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n@@ -2165,3 +2223,3 @@\n-        $type$ b = rotateLeft(a, 4);\n-        b = ($type$) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n-        b = ($type$) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        $elemtype$ b = rotateLeft(a, 4);\n+        b = ($elemtype$) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = ($elemtype$) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n@@ -2260,1 +2318,1 @@\n-     * @see #compare(VectorOperators.Comparison,$type$)\n+     * @see #compare(VectorOperators.Comparison,$elemtype$)\n@@ -2264,1 +2322,1 @@\n-    VectorMask<$Boxtype$> eq($type$ e) {\n+    VectorMask<$Boxtype$> eq($elemtype$ e) {\n@@ -2288,1 +2346,1 @@\n-     * @see #compare(VectorOperators.Comparison,$type$)\n+     * @see #compare(VectorOperators.Comparison,$elemtype$)\n@@ -2292,1 +2350,1 @@\n-    VectorMask<$Boxtype$> lt($type$ e) {\n+    VectorMask<$Boxtype$> lt($elemtype$ e) {\n@@ -2416,1 +2474,1 @@\n-            opc, getClass(), maskType, $type$.class, length(),\n+            opc, getClass(), maskType, $elemtype$.class, length(),\n@@ -2438,1 +2496,1 @@\n-            opc, getClass(), maskType, $type$.class, length(),\n+            opc, getClass(), maskType, $elemtype$.class, length(),\n@@ -2451,1 +2509,1 @@\n-    private static boolean compareWithOp(int cond, $type$ a, $type$ b) {\n+    private static boolean compareWithOp(int cond, $elemtype$ a, $elemtype$ b) {\n@@ -2455,4 +2513,4 @@\n-            case BT_lt -> a < b;\n-            case BT_le -> a <= b;\n-            case BT_gt -> a > b;\n-            case BT_ge -> a >= b;\n+            case BT_lt -> {#if[FP16]?a.floatValue() < b.floatValue():a < b};\n+            case BT_le -> {#if[FP16]?a.floatValue() <= b.floatValue():a <= b};\n+            case BT_gt -> {#if[FP16]?a.floatValue() > b.floatValue():a > b};\n+            case BT_ge -> {#if[FP16]?a.floatValue() >= b.floatValue():a >= b};\n@@ -2489,2 +2547,2 @@\n-     * @see #eq($type$)\n-     * @see #lt($type$)\n+     * @see #eq($elemtype$)\n+     * @see #lt($elemtype$)\n@@ -2493,1 +2551,1 @@\n-    VectorMask<$Boxtype$> compare(Comparison op, $type$ e);\n+    VectorMask<$Boxtype$> compare(Comparison op, $elemtype$ e);\n@@ -2499,1 +2557,1 @@\n-    M compareTemplate(Class<M> maskType, Comparison op, $type$ e) {\n+    M compareTemplate(Class<M> maskType, Comparison op, $elemtype$ e) {\n@@ -2525,1 +2583,1 @@\n-                                               $type$ e,\n+                                               $elemtype$ e,\n@@ -2573,1 +2631,1 @@\n-            getClass(), maskType, $type$.class, length(),\n+            getClass(), maskType, $elemtype$.class, length(),\n@@ -2590,1 +2648,1 @@\n-            getClass(), $type$.class, length(),\n+            getClass(), $elemtype$.class, length(),\n@@ -2598,2 +2656,1 @@\n-                $type$ sc = ($type$) scale_;\n-                return v.add(sc == 1 ? iota : iota.mul(sc));\n+                return v.add(scale_ == 1 ? iota : iota.mul({#if[FP16]?Float16.valueOf(scale_):($elemtype$)scale_}));\n@@ -2620,1 +2677,1 @@\n-    public final $abstractvectortype$ blend($type$ e,\n+    public final $abstractvectortype$ blend($elemtype$ e,\n@@ -2664,1 +2721,2 @@\n-        VectorMask<$Boxtype$> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(length() - origin))));\n+        $elemtype$ pivotidx = {#if[FP16]?Float16.valueOf(length() - origin):($elemtype$)(length() - origin)};\n+        VectorMask<$Boxtype$> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2694,1 +2752,2 @@\n-        VectorMask<$Boxtype$> blendMask = iota.toVector().compare(VectorOperators.LT, (broadcast(($type$)(length() - origin))));\n+        $elemtype$ pivotidx = {#if[FP16]?Float16.valueOf(length() - origin):($elemtype$)(length() - origin)};\n+        VectorMask<$Boxtype$> blendMask = iota.toVector().compare(VectorOperators.LT, broadcast(pivotidx));\n@@ -2716,1 +2775,1 @@\n-                                                                  (broadcast(($type$)(origin))));\n+                                                                  (broadcast({#if[FP16]?Float16.valueOf(origin):($elemtype$)(origin)})));\n@@ -2756,1 +2815,1 @@\n-                                                                  (broadcast(($type$)(origin))));\n+                                                                  broadcast({#if[FP16]?Float16.valueOf(origin):($elemtype$)(origin)}));\n@@ -2782,1 +2841,1 @@\n-            getClass(), shuffletype, null, $type$.class, length(),\n+            getClass(), shuffletype, null, $elemtype$.class, length(),\n@@ -2814,1 +2873,1 @@\n-                   getClass(), shuffletype, masktype, $type$.class, length(),\n+                   getClass(), shuffletype, masktype, $elemtype$.class, length(),\n@@ -2818,1 +2877,1 @@\n-                        return ei < 0  || !m_.laneIsSet(i) ? 0 : v1.lane(ei);\n+                        return ei < 0  || !m_.laneIsSet(i) ? {#if[FP16]?Float16.valueOf(0):0} : v1.lane(ei);\n@@ -2842,1 +2901,1 @@\n-                getClass(), shuffletype, null, $type$.class, length(),\n+                getClass(), shuffletype, null, $elemtype$.class, length(),\n@@ -2850,1 +2909,1 @@\n-                getClass(), shuffletype, null, $type$.class, length(),\n+                getClass(), shuffletype, null, $elemtype$.class, length(),\n@@ -2862,1 +2921,1 @@\n-        $type$[] a = toArray();\n+        $elemtype$[] a = toArray();\n@@ -2865,1 +2924,1 @@\n-            sa[i] = (int) a[i];\n+            sa[i] = {#if[FP16]?a[i].intValue():(int) a[i]};\n@@ -2876,1 +2935,1 @@\n-                                     getClass(), $type$.class, length(),\n+                                     getClass(), $elemtype$.class, length(),\n@@ -2897,1 +2956,1 @@\n-                                                        $type$.class, length(), this, m,\n+                                                        $elemtype$.class, length(), this, m,\n@@ -2916,1 +2975,1 @@\n-                                                        $type$.class, length(), this, m,\n+                                                        $elemtype$.class, length(), this, m,\n@@ -2968,3 +3027,3 @@\n-     * @see #bitwiseBlend($type$,$type$)\n-     * @see #bitwiseBlend($type$,Vector)\n-     * @see #bitwiseBlend(Vector,$type$)\n+     * @see #bitwiseBlend($elemtype$,$elemtype$)\n+     * @see #bitwiseBlend($elemtype$,Vector)\n+     * @see #bitwiseBlend(Vector,$elemtype$)\n@@ -2999,1 +3058,1 @@\n-     * @see #lanewise(VectorOperators.Ternary,$type$,$type$,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,$elemtype$,VectorMask)\n@@ -3003,1 +3062,1 @@\n-    $abstractvectortype$ bitwiseBlend($type$ bits, $type$ mask) {\n+    $abstractvectortype$ bitwiseBlend($elemtype$ bits, $elemtype$ mask) {\n@@ -3026,1 +3085,1 @@\n-     * @see #lanewise(VectorOperators.Ternary,$type$,Vector,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,Vector,VectorMask)\n@@ -3030,1 +3089,1 @@\n-    $abstractvectortype$ bitwiseBlend($type$ bits, Vector<$Boxtype$> mask) {\n+    $abstractvectortype$ bitwiseBlend($elemtype$ bits, Vector<$Boxtype$> mask) {\n@@ -3053,1 +3112,1 @@\n-     * @see #lanewise(VectorOperators.Ternary,Vector,$type$,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,Vector,$elemtype$,VectorMask)\n@@ -3057,1 +3116,1 @@\n-    $abstractvectortype$ bitwiseBlend(Vector<$Boxtype$> bits, $type$ mask) {\n+    $abstractvectortype$ bitwiseBlend(Vector<$Boxtype$> bits, $elemtype$ mask) {\n@@ -3075,1 +3134,1 @@\n-     * {@link Math#fma($type$,$type$,$type$) Math.fma(a,b,c)}\n+     * {@link {#if[FP16]?Float16:Math}#fma($elemtype$,$elemtype$,$elemtype$) {#if[FP16]?Float16:Math}.fma(a,b,c)}\n@@ -3094,1 +3153,1 @@\n-     * @see #fma($type$,$type$)\n+     * @see #fma($elemtype$,$elemtype$)\n@@ -3116,1 +3175,1 @@\n-     * {@link Math#fma($type$,$type$,$type$) Math.fma(a,b,c)}\n+     * {@link {#if[FP16]?Float16:Math}#fma($elemtype$,$elemtype$,$elemtype$) {#if[FP16]?Float16:Math}.fma(a,b,c)}\n@@ -3137,1 +3196,1 @@\n-     * @see #lanewise(VectorOperators.Ternary,$type$,$type$,VectorMask)\n+     * @see #lanewise(VectorOperators.Ternary,$elemtype$,$elemtype$,VectorMask)\n@@ -3141,1 +3200,1 @@\n-    $abstractvectortype$ fma($type$ b, $type$ c) {\n+    $abstractvectortype$ fma($elemtype$ b, $elemtype$ c) {\n@@ -3145,1 +3204,1 @@\n-    \/\/ Don't bother with (Vector,$type$) and ($type$,Vector) overloadings.\n+    \/\/ Don't bother with (Vector,$elemtype$) and ($elemtype$,Vector) overloadings.\n@@ -3198,1 +3257,1 @@\n-    public abstract $type$ reduceLanes(VectorOperators.Associative op);\n+    public abstract $elemtype$ reduceLanes(VectorOperators.Associative op);\n@@ -3218,1 +3277,1 @@\n-     * then the identity value is {#if[FP]?positive }zero, the default {@code $type$} value.\n+     * then the identity value is {#if[FP]?positive }zero, the default {@code $elemtype$} value.\n@@ -3276,1 +3335,1 @@\n-    public abstract $type$ reduceLanes(VectorOperators.Associative op,\n+    public abstract $elemtype$ reduceLanes(VectorOperators.Associative op,\n@@ -3282,1 +3341,1 @@\n-    $type$ reduceLanesTemplate(VectorOperators.Associative op,\n+    $elemtype$ reduceLanesTemplate(VectorOperators.Associative op,\n@@ -3288,1 +3347,1 @@\n-            $abstractvectortype$ v = broadcast(($type$) 0).blend(this, m);\n+            $abstractvectortype$ v = broadcast({#if[FP16]?Float16.valueOf(0):($elemtype$) 0}).blend(this, m);\n@@ -3293,1 +3352,1 @@\n-            opc, getClass(), maskClass, $type$.class, length(),\n+            opc, getClass(), maskClass, $elemtype$.class, length(),\n@@ -3301,1 +3360,1 @@\n-    $type$ reduceLanesTemplate(VectorOperators.Associative op) {\n+    $elemtype$ reduceLanesTemplate(VectorOperators.Associative op) {\n@@ -3307,1 +3366,1 @@\n-            return ft < length() ? this.lane(ft) : ($type$) 0;\n+            return ft < length() ? this.lane(ft) : {#if[FP16]?Float16.valueOf(0):($elemtype$) 0};\n@@ -3311,1 +3370,1 @@\n-            opc, getClass(), null, $type$.class, length(),\n+            opc, getClass(), null, $elemtype$.class, length(),\n@@ -3322,0 +3381,1 @@\n+#if[FP16]\n@@ -3323,1 +3383,1 @@\n-                    toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a + b)));\n+                    toBits(v.rOp(Float16.valueOf(0), m, (i, a, b) -> Float16.add(a, b)));\n@@ -3325,1 +3385,1 @@\n-                    toBits(v.rOp(($type$)1, m, (i, a, b) -> ($type$)(a * b)));\n+                    toBits(v.rOp(Float16.valueOf(0), m, (i, a, b) -> Float16.multiply(a, b)));\n@@ -3327,1 +3387,1 @@\n-                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> ($type$) Math.min(a, b)));\n+                    toBits(v.rOp(Float16.valueOf(0), m, (i, a, b) -> Float16.min(a, b)));\n@@ -3329,1 +3389,11 @@\n-                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> ($type$) Math.max(a, b)));\n+                    toBits(v.rOp(Float16.valueOf(0), m, (i, a, b) -> Float16.max(a, b)));\n+#else[FP16]\n+            case VECTOR_OP_ADD: return (v, m) ->\n+                    toBits(v.rOp(($elemtype$)0, m, (i, a, b) -> ($elemtype$)(a + b)));\n+            case VECTOR_OP_MUL: return (v, m) ->\n+                    toBits(v.rOp(($elemtype$)1, m, (i, a, b) -> ($elemtype$)(a * b)));\n+            case VECTOR_OP_MIN: return (v, m) ->\n+                    toBits(v.rOp(MAX_OR_INF, m, (i, a, b) -> ($elemtype$) Math.min(a, b)));\n+            case VECTOR_OP_MAX: return (v, m) ->\n+                    toBits(v.rOp(MIN_OR_INF, m, (i, a, b) -> ($elemtype$) Math.max(a, b)));\n+#end[FP16]\n@@ -3332,1 +3402,1 @@\n-                    toBits(v.rOp(($type$)-1, m, (i, a, b) -> ($type$)(a & b)));\n+                    toBits(v.rOp(($elemtype$)-1, m, (i, a, b) -> ($elemtype$)(a & b)));\n@@ -3334,1 +3404,1 @@\n-                    toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a | b)));\n+                    toBits(v.rOp(($elemtype$)0, m, (i, a, b) -> ($elemtype$)(a | b)));\n@@ -3336,1 +3406,1 @@\n-                    toBits(v.rOp(($type$)0, m, (i, a, b) -> ($type$)(a ^ b)));\n+                    toBits(v.rOp(($elemtype$)0, m, (i, a, b) -> ($elemtype$)(a ^ b)));\n@@ -3343,2 +3413,2 @@\n-    private static final $type$ MIN_OR_INF = $Boxtype$.NEGATIVE_INFINITY;\n-    private static final $type$ MAX_OR_INF = $Boxtype$.POSITIVE_INFINITY;\n+    private static final $elemtype$ MIN_OR_INF = $Boxtype$.NEGATIVE_INFINITY;\n+    private static final $elemtype$ MAX_OR_INF = $Boxtype$.POSITIVE_INFINITY;\n@@ -3346,2 +3416,2 @@\n-    private static final $type$ MIN_OR_INF = $Boxtype$.MIN_VALUE;\n-    private static final $type$ MAX_OR_INF = $Boxtype$.MAX_VALUE;\n+    private static final $elemtype$ MIN_OR_INF = $Boxtype$.MIN_VALUE;\n+    private static final $elemtype$ MAX_OR_INF = $Boxtype$.MAX_VALUE;\n@@ -3364,1 +3434,1 @@\n-    public abstract $type$ lane(int i);\n+    public abstract $elemtype$ lane(int i);\n@@ -3382,1 +3452,1 @@\n-    public abstract $abstractvectortype$ withLane(int i, $type$ e);\n+    public abstract $abstractvectortype$ withLane(int i, $elemtype$ e);\n@@ -3387,1 +3457,1 @@\n-     * Returns an array of type {@code $type$[]}\n+     * Returns an array of type {@code $elemtype$[]}\n@@ -3394,1 +3464,1 @@\n-     * (using {@link #intoArray($type$[], int) intoArray})\n+     * (using {@link #intoArray($elemtype$[], int) intoArray})\n@@ -3397,1 +3467,1 @@\n-     *   $type$[] a = new $type$[this.length()];\n+     *   $elemtype$[] a = new $elemtype$[this.length()];\n@@ -3406,2 +3476,2 @@\n-    public final $type$[] toArray() {\n-        $type$[] a = new $type$[vspecies().laneCount()];\n+    public final $elemtype$[] toArray() {\n+        $elemtype$[] a = new $elemtype$[vspecies().laneCount()];\n@@ -3441,1 +3511,1 @@\n-        $type$[] a = toArray();\n+        $elemtype$[] a = toArray();\n@@ -3444,1 +3514,1 @@\n-            $type$ e = a[i];\n+            $elemtype$ e = a[i];\n@@ -3478,1 +3548,1 @@\n-        $type$[] a = toArray();\n+        $elemtype$[] a = toArray();\n@@ -3481,1 +3551,6 @@\n-            $type$ e = a[i];\n+#if[FP16]\n+            \/\/ Value range of integral casted Float16 value is a proper subset of\n+            \/\/ long value range.\n+            res[i] = a[i].longValue();\n+#else[FP16]\n+            $elemtype$ e = a[i];\n@@ -3483,0 +3558,1 @@\n+#end[FP16]\n@@ -3519,1 +3595,1 @@\n-        $type$[] a = toArray();\n+        $elemtype$[] a = toArray();\n@@ -3522,1 +3598,1 @@\n-            res[i] = (double) a[i];\n+            res[i] = {#if[FP16]?a[i].doubleValue():((double) a[i])};\n@@ -3529,1 +3605,1 @@\n-     * Loads a vector from an array of type {@code $type$[]}\n+     * Loads a vector from an array of type {@code $elemtype$[]}\n@@ -3546,1 +3622,1 @@\n-                                   $type$[] a, int offset) {\n+                                   $elemtype$[] a, int offset) {\n@@ -3553,1 +3629,1 @@\n-     * Loads a vector from an array of type {@code $type$[]}\n+     * Loads a vector from an array of type {@code $elemtype$[]}\n@@ -3556,1 +3632,1 @@\n-     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * value of {@code $elemtype$} ({#if[FP]?positive }zero).\n@@ -3576,1 +3652,1 @@\n-                                   $type$[] a, int offset,\n+                                   $elemtype$[] a, int offset,\n@@ -3589,1 +3665,1 @@\n-     * {@code $type$[]},\n+     * {@code $elemtype$[]},\n@@ -3622,1 +3698,1 @@\n-                                   $type$[] a, int offset,\n+                                   $elemtype$[] a, int offset,\n@@ -3631,1 +3707,1 @@\n-                                   $type$[] a, int offset,\n+                                   $elemtype$[] a, int offset,\n@@ -3672,1 +3748,1 @@\n-            vectorType, null, $type$.class, vsp.laneCount(),\n+            vectorType, null, $elemtype$.class, vsp.laneCount(),\n@@ -3683,1 +3759,1 @@\n-     * {@code $type$[]},\n+     * {@code $elemtype$[]},\n@@ -3721,1 +3797,1 @@\n-                                   $type$[] a, int offset,\n+                                   $elemtype$[] a, int offset,\n@@ -3731,1 +3807,1 @@\n-                                   $type$[] a, int offset,\n+                                   $elemtype$[] a, int offset,\n@@ -3774,1 +3850,1 @@\n-     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * value of {@code $elemtype$} ({#if[FP]?positive }zero).\n@@ -3929,1 +4005,1 @@\n-     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * value of {@code $elemtype$} ({#if[FP]?positive }zero).\n@@ -4099,1 +4175,1 @@\n-     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * value of {@code $elemtype$} ({#if[FP]?positive }zero).\n@@ -4108,1 +4184,1 @@\n-     * $type$[] ar = new $type$[species.length()];\n+     * $elemtype$[] ar = new $elemtype$[species.length()];\n@@ -4161,1 +4237,1 @@\n-     * Stores this vector into an array of type {@code $type$[]}\n+     * Stores this vector into an array of type {@code $elemtype$[]}\n@@ -4168,1 +4244,1 @@\n-     * @param a the array, of type {@code $type$[]}\n+     * @param a the array, of type {@code $elemtype$[]}\n@@ -4176,1 +4252,1 @@\n-    void intoArray($type$[] a, int offset) {\n+    void intoArray($elemtype$[] a, int offset) {\n@@ -4190,1 +4266,1 @@\n-     * Stores this vector into an array of type {@code $type$[]}\n+     * Stores this vector into an array of type {@code $elemtype$[]}\n@@ -4205,1 +4281,1 @@\n-     * @param a the array, of type {@code $type$[]}\n+     * @param a the array, of type {@code $elemtype$[]}\n@@ -4215,1 +4291,1 @@\n-    void intoArray($type$[] a, int offset,\n+    void intoArray($elemtype$[] a, int offset,\n@@ -4229,1 +4305,1 @@\n-     * Scatters this vector into an array of type {@code $type$[]}\n+     * Scatters this vector into an array of type {@code $elemtype$[]}\n@@ -4257,1 +4333,1 @@\n-    void intoArray($type$[] a, int offset,\n+    void intoArray($elemtype$[] a, int offset,\n@@ -4268,1 +4344,1 @@\n-    void intoArray($type$[] a, int offset,\n+    void intoArray($elemtype$[] a, int offset,\n@@ -4321,1 +4397,1 @@\n-     * Scatters this vector into an array of type {@code $type$[]},\n+     * Scatters this vector into an array of type {@code $elemtype$[]},\n@@ -4353,1 +4429,1 @@\n-    void intoArray($type$[] a, int offset,\n+    void intoArray($elemtype$[] a, int offset,\n@@ -4365,1 +4441,1 @@\n-    void intoArray($type$[] a, int offset,\n+    void intoArray($elemtype$[] a, int offset,\n@@ -4766,1 +4842,1 @@\n-    $abstractvectortype$ fromArray0($type$[] a, int offset);\n+    $abstractvectortype$ fromArray0($elemtype$[] a, int offset);\n@@ -4769,1 +4845,1 @@\n-    $abstractvectortype$ fromArray0Template($type$[] a, int offset) {\n+    $abstractvectortype$ fromArray0Template($elemtype$[] a, int offset) {\n@@ -4781,1 +4857,1 @@\n-    $abstractvectortype$ fromArray0($type$[] a, int offset, VectorMask<$Boxtype$> m, int offsetInRange);\n+    $abstractvectortype$ fromArray0($elemtype$[] a, int offset, VectorMask<$Boxtype$> m, int offsetInRange);\n@@ -4785,1 +4861,1 @@\n-    $abstractvectortype$ fromArray0Template(Class<M> maskClass, $type$[] a, int offset, M m, int offsetInRange) {\n+    $abstractvectortype$ fromArray0Template(Class<M> maskClass, $elemtype$[] a, int offset, M m, int offsetInRange) {\n@@ -4799,1 +4875,1 @@\n-    $abstractvectortype$ fromArray0($type$[] a, int offset,\n+    $abstractvectortype$ fromArray0($elemtype$[] a, int offset,\n@@ -4805,1 +4881,1 @@\n-    $abstractvectortype$ fromArray0Template(Class<M> maskClass, $type$[] a, int offset,\n+    $abstractvectortype$ fromArray0Template(Class<M> maskClass, $elemtype$[] a, int offset,\n@@ -4848,1 +4924,1 @@\n-            vectorType, maskClass, $type$.class, vsp.laneCount(),\n+            vectorType, maskClass, $elemtype$.class, vsp.laneCount(),\n@@ -4960,1 +5036,1 @@\n-    void intoArray0($type$[] a, int offset);\n+    void intoArray0($elemtype$[] a, int offset);\n@@ -4963,1 +5039,1 @@\n-    void intoArray0Template($type$[] a, int offset) {\n+    void intoArray0Template($elemtype$[] a, int offset) {\n@@ -4975,1 +5051,1 @@\n-    void intoArray0($type$[] a, int offset, VectorMask<$Boxtype$> m);\n+    void intoArray0($elemtype$[] a, int offset, VectorMask<$Boxtype$> m);\n@@ -4979,1 +5055,1 @@\n-    void intoArray0Template(Class<M> maskClass, $type$[] a, int offset, M m) {\n+    void intoArray0Template(Class<M> maskClass, $elemtype$[] a, int offset, M m) {\n@@ -4993,1 +5069,1 @@\n-    void intoArray0($type$[] a, int offset,\n+    void intoArray0($elemtype$[] a, int offset,\n@@ -4999,1 +5075,1 @@\n-    void intoArray0Template(Class<M> maskClass, $type$[] a, int offset,\n+    void intoArray0Template(Class<M> maskClass, $elemtype$[] a, int offset,\n@@ -5175,1 +5251,1 @@\n-        31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_$TYPE$_INDEX_SCALE);\n+        31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_{#if[FP16]?OBJECT:$TYPE$}_INDEX_SCALE);\n@@ -5177,1 +5253,1 @@\n-        Unsafe.ARRAY_$TYPE$_BASE_OFFSET;\n+        Unsafe.ARRAY_{#if[FP16]?OBJECT:$TYPE$}_BASE_OFFSET;\n@@ -5180,1 +5256,1 @@\n-    static long arrayAddress($type$[] a, int index) {\n+    static long arrayAddress($elemtype$[] a, int index) {\n@@ -5244,1 +5320,1 @@\n-        LaneType ilt = LaneType.$TYPE$.asIntegral();\n+        LaneType ilt = LaneType.{#if[FP16]?FLOAT16:$TYPE$}.asIntegral();\n@@ -5255,1 +5331,1 @@\n-     * point type of the same size as {@code $type$}.  The return type\n+     * point type of the same size as {@code $elemtype$}.  The return type\n@@ -5264,1 +5340,5 @@\n-    {#if[byteOrShort]?Vector<?>:$Fptype$Vector}\n+#if[FP]\n+    $Type$Vector\n+#else[FP]\n+    {#if[byte]?Vector<?>:$Boxfptype$Vector}\n+#end[FP]\n@@ -5269,5 +5349,5 @@\n-        LaneType flt = LaneType.$TYPE$.asFloating();\n-#if[!byteOrShort]\n-        return ($Fptype$Vector) asVectorRaw(flt);\n-#else[!byteOrShort]\n-        \/\/ asFloating() will throw UnsupportedOperationException for the unsupported type $type$\n+        LaneType flt = {#if[short]?LaneType.FLOAT16.asFloating():LaneType.$TYPE$.asFloating()};\n+#if[!byte]\n+        return ($Boxfptype$Vector) asVectorRaw(flt);\n+#else[!byte]\n+        \/\/ asFloating() will throw UnsupportedOperationException for the unsupported type $elemtype$\n@@ -5275,1 +5355,1 @@\n-#end[!byteOrShort]\n+#end[!byte]\n@@ -5293,2 +5373,2 @@\n-     * java.util.Arrays#toString($type$[]) Arrays.toString()},\n-     * as appropriate to the {@code $type$} array returned by\n+     * java.util.Arrays#toString($elemtype$[]) Arrays.toString()},\n+     * as appropriate to the {@code $elemtype$} array returned by\n@@ -5348,1 +5428,1 @@\n-            super(shape, LaneType.of($type$.class),\n+            super(shape, LaneType.of($elemtype$.class),\n@@ -5359,1 +5439,1 @@\n-            return $type$.class;\n+            return $elemtype$.class;\n@@ -5388,1 +5468,1 @@\n-                    vectorType, $type$.class, laneCount,\n+                    vectorType, $elemtype$.class, laneCount,\n@@ -5395,1 +5475,1 @@\n-        {#if[long]?public }final $abstractvectortype$ broadcast($type$ e) {\n+        {#if[long]?public }final $abstractvectortype$ broadcast($elemtype$ e) {\n@@ -5416,2 +5496,2 @@\n-            $type$ e = ($type$) value;\n-            if ((long) e != value) {\n+            $elemtype$ e = {#if[FP16]?Float16.valueOf(value):($elemtype$) value};\n+            if ({#if[FP16]?e.longValue():(long) e} != value) {\n@@ -5426,1 +5506,7 @@\n-        static long toIntegralChecked($type$ e, boolean convertToInt) {\n+        static long toIntegralChecked($elemtype$ e, boolean convertToInt) {\n+#if[FP16]\n+            long value = convertToInt ? e.intValue() : e.longValue();\n+            if (value != e.longValue()) {\n+                throw badArrayBits(e, convertToInt, value);\n+            }\n+#else[FP16]\n@@ -5428,1 +5514,1 @@\n-            if (($type$) value != e) {\n+            if (($elemtype$) value != e) {\n@@ -5431,0 +5517,1 @@\n+#end[FP16]\n@@ -5439,1 +5526,1 @@\n-            $type$[] va = new $type$[laneCount()];\n+            $elemtype$[] va = new $elemtype$[laneCount()];\n@@ -5442,1 +5529,8 @@\n-                $type$ v = ($type$) lv;\n+#if[FP16]\n+                $elemtype$ v = Float16.valueOf(lv);\n+                va[i] = v;\n+                if ( v.intValue() != lv) {\n+                    throw badElementBits(lv, v);\n+                }\n+#else[FP16]\n+                $elemtype$ v = ($elemtype$) lv;\n@@ -5447,0 +5541,1 @@\n+#end[FP16]\n@@ -5459,1 +5554,1 @@\n-                .fromArray(this, ($type$[]) a, offset);\n+                .fromArray(this, ($elemtype$[]) a, offset);\n@@ -5481,1 +5576,1 @@\n-            $type$[] res = new $type$[laneCount()];\n+            $elemtype$[] res = new $elemtype$[laneCount()];\n@@ -5490,1 +5585,1 @@\n-            $type$[] res = new $type$[laneCount()];\n+            $elemtype$[] res = new $elemtype$[laneCount()];\n@@ -5498,1 +5593,1 @@\n-            $type$[] res = new $type$[laneCount()];\n+            $elemtype$[] res = new $elemtype$[laneCount()];\n@@ -5619,1 +5714,1 @@\n-     * Finds a species for an element type of {@code $type$} and shape.\n+     * Finds a species for an element type of {@code $elemtype$} and shape.\n@@ -5622,1 +5717,1 @@\n-     * @return a species for an element type of {@code $type$} and shape\n+     * @return a species for an element type of {@code $elemtype$} and shape\n@@ -5677,1 +5772,1 @@\n-        = ($Type$Species) VectorSpecies.ofPreferred($type$.class);\n+        = ($Type$Species) VectorSpecies.ofPreferred($elemtype$.class);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":497,"deletions":402,"binary":false,"changes":899,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+    static final Class<$Boxtype$> ETYPE = $elemtype$.class; \/\/ used by the JVM\n@@ -57,1 +57,1 @@\n-    $vectortype$($type$[] v) {\n+    $vectortype$($elemtype$[] v) {\n@@ -64,1 +64,1 @@\n-        this(($type$[]) v);\n+        this(($elemtype$[]) v);\n@@ -67,1 +67,1 @@\n-    static final $vectortype$ ZERO = new $vectortype$(new $type$[VLENGTH]);\n+    static final $vectortype$ ZERO = new $vectortype$(new $elemtype$[VLENGTH]);\n@@ -91,1 +91,1 @@\n-    public final Class<$Boxtype$> elementType() { return $type$.class; }\n+    public final Class<$Boxtype$> elementType() { return $elemtype$.class; }\n@@ -116,2 +116,2 @@\n-    $type$[] vec() {\n-        return ($type$[])getPayload();\n+    $elemtype$[] vec() {\n+        return ($elemtype$[])getPayload();\n@@ -124,1 +124,1 @@\n-    public final $vectortype$ broadcast($type$ e) {\n+    public final $vectortype$ broadcast($elemtype$ e) {\n@@ -172,1 +172,1 @@\n-    $vectortype$ vectorFactory($type$[] vec) {\n+    $vectortype$ vectorFactory($elemtype$[] vec) {\n@@ -241,1 +241,1 @@\n-    $type$ rOp($type$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n+    $elemtype$ rOp($elemtype$ v, VectorMask<$Boxtype$> m, FBinOp f) {\n@@ -340,1 +340,1 @@\n-    public final $type$ reduceLanes(VectorOperators.Associative op) {\n+    public final $elemtype$ reduceLanes(VectorOperators.Associative op) {\n@@ -346,1 +346,1 @@\n-    public final $type$ reduceLanes(VectorOperators.Associative op,\n+    public final $elemtype$ reduceLanes(VectorOperators.Associative op,\n@@ -354,1 +354,2 @@\n-        return (long) super.reduceLanesTemplate(op);  \/\/ specialized\n+        $elemtype$ res = super.reduceLanesTemplate(op);  \/\/ specialized\n+        return {#if[FP16]?res.longValue(): (long) res};\n@@ -361,1 +362,2 @@\n-        return (long) super.reduceLanesTemplate(op, $masktype$.class, ($masktype$) m);  \/\/ specialized\n+        $elemtype$ res = super.reduceLanesTemplate(op, $masktype$.class, ($masktype$) m);  \/\/ specialized\n+        return {#if[FP16]?res.longValue(): (long) res};\n@@ -393,1 +395,1 @@\n-    public final $masktype$ compare(Comparison op, $type$ s) {\n+    public final $masktype$ compare(Comparison op, $elemtype$ s) {\n@@ -519,1 +521,1 @@\n-    public $type$ lane(int i) {\n+    public $elemtype$ lane(int i) {\n@@ -555,1 +557,1 @@\n-        return $Type$.$bitstype$BitsTo$Fptype$(bits);\n+        return $Elemtype$.$bitstype$BitsTo{#if[FP16]?Float16:$Fptype$}(bits);\n@@ -563,2 +565,2 @@\n-                     $type$[] vecarr = vec.vec();\n-                     return (long)$Type$.$type$To$Bitstype$Bits(vecarr[ix]);\n+                     $elemtype$[] vecarr = vec.vec();\n+                     return (long)$Elemtype$.{#if[FP16]?float16:$elemtype$}To$Bitstype$Bits(vecarr[ix]);\n@@ -570,1 +572,1 @@\n-    public $vectortype$ withLane(int i, $type$ e) {\n+    public $vectortype$ withLane(int i, $elemtype$ e) {\n@@ -607,1 +609,1 @@\n-    public $vectortype$ withLaneHelper(int i, $type$ e) {\n+    public $vectortype$ withLaneHelper(int i, $elemtype$ e) {\n@@ -610,1 +612,1 @@\n-                                this, i, (long)$Type$.$type$To$Bitstype$Bits(e),\n+                                this, i, (long)$Elemtype$.{#if[FP16]?float16:$elemtype$}To$Bitstype$Bits(e),\n@@ -612,2 +614,2 @@\n-                                    $type$[] res = v.vec().clone();\n-                                    res[ix] = $Type$.$bitstype$BitsTo$Type$(($bitstype$)bits);\n+                                    $elemtype$[] res = v.vec().clone();\n+                                    res[ix] = $Elemtype$.$bitstype$BitsTo$Elemtype$(($bitstype$)bits);\n@@ -620,1 +622,1 @@\n-    public $type$ lane(int i) {\n+    public $elemtype$ lane(int i) {\n@@ -709,2 +711,2 @@\n-    public $type$ laneHelper(int i) {\n-        return ($type$) VectorSupport.extract(\n+    public $elemtype$ laneHelper(int i) {\n+        return ($elemtype$) VectorSupport.extract(\n@@ -714,1 +716,1 @@\n-                                    $type$[] vecarr = vec.vec();\n+                                    $elemtype$[] vecarr = vec.vec();\n@@ -721,1 +723,1 @@\n-    public $vectortype$ withLane(int i, $type$ e) {\n+    public $vectortype$ withLane(int i, $elemtype$ e) {\n@@ -810,1 +812,1 @@\n-    public $vectortype$ withLaneHelper(int i, $type$ e) {\n+    public $vectortype$ withLaneHelper(int i, $elemtype$ e) {\n@@ -815,2 +817,2 @@\n-                                    $type$[] res = v.vec().clone();\n-                                    res[ix] = ($type$)bits;\n+                                    $elemtype$[] res = v.vec().clone();\n+                                    res[ix] = ($elemtype$)bits;\n@@ -826,1 +828,1 @@\n-        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+        static final Class<$Boxtype$> ETYPE = $elemtype$.class; \/\/ used by the JVM\n@@ -928,1 +930,1 @@\n-                $masktype$.class, $type$.class, VLENGTH, offset, limit,\n+                $masktype$.class, ETYPE, VLENGTH, offset, limit,\n@@ -945,0 +947,3 @@\n+#if[FP16]\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, Float.floatToFloat16(m1.trueCount())));\n+#else[FP16]\n@@ -946,0 +951,1 @@\n+#end[FP16]\n@@ -956,1 +962,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_AND, $masktype$.class, null, $maskbitstype$.class, VLENGTH,\n@@ -966,1 +972,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_OR, $masktype$.class, null, $maskbitstype$.class, VLENGTH,\n@@ -976,1 +982,1 @@\n-            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $bitstype$.class, VLENGTH,\n+            return VectorSupport.binaryOp(VECTOR_OP_XOR, $masktype$.class, null, $maskbitstype$.class, VLENGTH,\n@@ -986,1 +992,1 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $maskbitstype$.class, VLENGTH, this,\n@@ -993,1 +999,1 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $maskbitstype$.class, VLENGTH, this,\n@@ -1000,1 +1006,1 @@\n-            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+            return (int) VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $maskbitstype$.class, VLENGTH, this,\n@@ -1010,1 +1016,1 @@\n-            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TOLONG, $masktype$.class, $maskbitstype$.class, VLENGTH, this,\n@@ -1020,1 +1026,1 @@\n-            return VectorSupport.extract($masktype$.class, $type$.class, VLENGTH,\n+            return VectorSupport.extract($masktype$.class, $elemtype$.class, VLENGTH,\n@@ -1029,1 +1035,1 @@\n-            return VectorSupport.test(BT_ne, $masktype$.class, $bitstype$.class, VLENGTH,\n+            return VectorSupport.test(BT_ne, $masktype$.class, $maskbitstype$.class, VLENGTH,\n@@ -1037,1 +1043,1 @@\n-            return VectorSupport.test(BT_overflow, $masktype$.class, $bitstype$.class, VLENGTH,\n+            return VectorSupport.test(BT_overflow, $masktype$.class, $maskbitstype$.class, VLENGTH,\n@@ -1045,1 +1051,1 @@\n-            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, VLENGTH,\n+            return VectorSupport.fromBitsCoerced($masktype$.class, $maskbitstype$.class, VLENGTH,\n@@ -1073,1 +1079,1 @@\n-        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+        static final Class<$Boxtype$> ETYPE = $elemtype$.class; \/\/ used by the JVM\n@@ -1143,1 +1149,1 @@\n-    $abstractvectortype$ fromArray0($type$[] a, int offset) {\n+    $abstractvectortype$ fromArray0($elemtype$[] a, int offset) {\n@@ -1150,1 +1156,1 @@\n-    $abstractvectortype$ fromArray0($type$[] a, int offset, VectorMask<$Boxtype$> m, int offsetInRange) {\n+    $abstractvectortype$ fromArray0($elemtype$[] a, int offset, VectorMask<$Boxtype$> m, int offsetInRange) {\n@@ -1158,1 +1164,1 @@\n-    $abstractvectortype$ fromArray0($type$[] a, int offset, int[] indexMap, int mapOffset, VectorMask<$Boxtype$> m) {\n+    $abstractvectortype$ fromArray0($elemtype$[] a, int offset, int[] indexMap, int mapOffset, VectorMask<$Boxtype$> m) {\n@@ -1212,1 +1218,1 @@\n-    void intoArray0($type$[] a, int offset) {\n+    void intoArray0($elemtype$[] a, int offset) {\n@@ -1219,1 +1225,1 @@\n-    void intoArray0($type$[] a, int offset, VectorMask<$Boxtype$> m) {\n+    void intoArray0($elemtype$[] a, int offset, VectorMask<$Boxtype$> m) {\n@@ -1227,1 +1233,1 @@\n-    void intoArray0($type$[] a, int offset, int[] indexMap, int mapOffset, VectorMask<$Boxtype$> m) {\n+    void intoArray0($elemtype$[] a, int offset, int[] indexMap, int mapOffset, VectorMask<$Boxtype$> m) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":59,"deletions":53,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-for type in byte short int long float double\n+for type in byte short int long float double Halffloat\n@@ -58,0 +58,1 @@\n+\n@@ -60,0 +61,1 @@\n+\n@@ -69,0 +71,1 @@\n+  maskbitstype=$type\n@@ -75,0 +78,4 @@\n+  elemtype=$type\n+  Elemtype=$Type\n+  FPtype=$type\n+\n@@ -76,2 +83,2 @@\n-  case $type in\n-    byte)\n+  case $Type in\n+    Byte)\n@@ -82,1 +89,4 @@\n-    short)\n+    Short)\n+      fptype=float16\n+      Fptype=Float16\n+      Boxfptype=Halffloat\n@@ -87,1 +97,1 @@\n-    int)\n+    Int)\n@@ -97,1 +107,1 @@\n-    long)\n+    Long)\n@@ -104,1 +114,1 @@\n-    float)\n+    Float)\n@@ -107,0 +117,1 @@\n+      maskbitstype=int\n@@ -111,0 +122,1 @@\n+      FPtype=FP32\n@@ -112,1 +124,1 @@\n-    double)\n+    Double)\n@@ -115,0 +127,1 @@\n+      maskbitstype=long\n@@ -119,0 +132,16 @@\n+      FPtype=FP64\n+      ;;\n+    Halffloat)\n+      kind=FP\n+      bitstype=short\n+      maskbitstype=short\n+      Bitstype=Short\n+      Boxbitstype=Short\n+      sizeInBytes=2\n+      Boxtype=Float16\n+      elemtype=Float16\n+      Elemtype=Float16\n+      FPtype=FP16\n+      fptype=float16\n+      Fptype=Float16\n+      args=\"$args -KbyteOrShort -KshortOrFP -KshortOrHalffloat\"\n@@ -122,2 +151,2 @@\n-  args=\"$args -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n-  args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype\"\n+  args=\"$args -K$FPtype -K$kind -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype\"\n+  args=\"$args -Dbitstype=$bitstype -Dmaskbitstype=$maskbitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype\"\n@@ -126,0 +155,1 @@\n+  args=\"$args -Delemtype=$elemtype -DElemtype=$Elemtype\"\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/gen-src.sh","additions":40,"deletions":10,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1385,1 +1385,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1387,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1385,1 +1385,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1387,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1385,1 +1385,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1387,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1385,1 +1385,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1387,1 +1387,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1390,1 +1390,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test\n@@ -1392,1 +1392,6 @@\n-        SPECIES.zero().viewAsFloatingLanes();\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1753,1 +1753,1 @@\n-#if[byteOrShort]\n+#if[byte]\n@@ -1759,1 +1759,1 @@\n-#else[byteOrShort]\n+#else[byte]\n@@ -1770,1 +1770,1 @@\n-#end[byteOrShort]\n+#end[byte]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}