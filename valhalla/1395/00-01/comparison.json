{"files":[{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8351362\n+ * @summary Unit Test for StrictCompiler super rewrite\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.test.lib.value.StrictCompiler --deferSuperCall StrictCompilerSuperTest.java\n+ * @run junit StrictCompilerSuperTest\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Opcode;\n+import java.util.ArrayList;\n+\n+import jdk.test.lib.value.Strict;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+\n+class StrictCompilerSuperTest {\n+    @Test\n+    void testReflectRewrittenRecord() throws Throwable {\n+        for (var field : Rec.class.getDeclaredFields()) {\n+            assertEquals(ACC_PRIVATE | ACC_STRICT | ACC_FINAL, field.getModifiers(), () -> \"For field: \" + field.getName());\n+        }\n+    }\n+\n+    @Test\n+    void testRewrittenStrictAccessInClassFile() throws Throwable {\n+        ClassModel cm;\n+        try (var in = StrictCompilerSuperTest.class.getResourceAsStream(\"\/StrictCompilerSuperTest$Rec.class\")) {\n+            cm = ClassFile.of().parse(in.readAllBytes());\n+        }\n+        for (var f : cm.fields()) {\n+            assertEquals(ACC_PRIVATE | ACC_STRICT | ACC_FINAL, f.flags().flagsMask(), () -> \"Field \" + f);\n+        }\n+    }\n+\n+    @Test\n+    void testRewrittenCtorBytecode() throws Throwable {\n+        ClassModel cm;\n+        try (var in = StrictCompilerSuperTest.class.getResourceAsStream(\"\/StrictCompilerSuperTest$Rec.class\")) {\n+            cm = ClassFile.of().parse(in.readAllBytes());\n+        }\n+        var ctor = cm.methods().stream().filter(m -> m.methodName().equalsString(INIT_NAME)).findFirst().orElseThrow();\n+        var insts = new ArrayList<Instruction>();\n+        ctor.findAttribute(Attributes.code()).orElseThrow().forEach(ce -> {\n+            if (ce instanceof Instruction inst) {\n+                insts.add(inst);\n+            }\n+        });\n+        assertSame(Opcode.RETURN, insts.getLast().opcode());\n+        assertSame(Opcode.INVOKESPECIAL, insts.get(insts.size() - 2).opcode());\n+    }\n+\n+    record Rec(@Strict int a, @Strict long b) {}\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/StrictCompilerSuperTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-        for (var field : One.class.getDeclaredFields()) {\n+        for (var field : StrictTarget.class.getDeclaredFields()) {\n@@ -47,1 +47,0 @@\n-}\n@@ -49,5 +48,5 @@\n-class One {\n-    @Strict\n-    final int a;\n-    @Strict\n-    final Object b;\n+    static final class StrictTarget {\n+        @Strict\n+        final int a;\n+        @Strict\n+        final Object b;\n@@ -55,4 +54,5 @@\n-    One() {\n-        this.a = 1;\n-        this.b = 2392352234L;\n-        super();\n+        StrictTarget() {\n+            this.a = 1;\n+            this.b = 2392352234L;\n+            super();\n+        }\n","filename":"test\/lib-test\/jdk\/test\/lib\/StrictCompilerTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.classfile.instruction.FieldInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.classfile.instruction.ReturnInstruction;\n@@ -34,0 +38,1 @@\n+import java.util.HashSet;\n@@ -36,0 +41,1 @@\n+import java.util.Set;\n@@ -39,1 +45,2 @@\n-import static java.lang.classfile.ClassFile.ACC_STRICT;\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n@@ -58,1 +65,3 @@\n-        List<String> opts = new ArrayList<>();\n+        List<String> javacOpts = new ArrayList<>();\n+        boolean encounteredSeparator = false;\n+        boolean deferSuperCall = false;\n@@ -60,0 +69,4 @@\n+            if (encounteredSeparator) {\n+                javacOpts.add(a);\n+                continue;\n+            }\n@@ -64,2 +77,6 @@\n-            } else {\n-                opts.add(a);\n+                continue;\n+            }\n+            switch (a) {\n+                case \"--\" -> encounteredSeparator = true;\n+                case \"--deferSuperCall\" -> deferSuperCall = true;\n+                default -> throw new IllegalArgumentException(\"Unknown option \" + a);\n@@ -68,3 +85,3 @@\n-        if (!opts.contains(\"--source\")) {\n-            opts.add(\"--source\");\n-            opts.add(String.valueOf(Runtime.version().feature()));\n+        if (!javacOpts.contains(\"--source\")) {\n+            javacOpts.add(\"--source\");\n+            javacOpts.add(String.valueOf(Runtime.version().feature()));\n@@ -72,2 +89,2 @@\n-        if (!opts.contains(\"--enable-preview\")) {\n-            opts.add(\"--enable-preview\");\n+        if (!javacOpts.contains(\"--enable-preview\")) {\n+            javacOpts.add(\"--enable-preview\");\n@@ -75,1 +92,2 @@\n-        var classes = InMemoryJavaCompiler.compile(ins, opts.toArray(String[]::new));\n+        System.out.println(javacOpts);\n+        var classes = InMemoryJavaCompiler.compile(ins, javacOpts.toArray(String[]::new));\n@@ -78,1 +96,22 @@\n-            dumpClass(entry.getKey(), entry.getValue());\n+            if (deferSuperCall) {\n+                fixSuperAndDumpClass(entry.getKey(), entry.getValue());\n+            } else {\n+                dumpClass(entry.getKey(), entry.getValue());\n+            }\n+        }\n+    }\n+\n+    private static void fixSuperAndDumpClass(String name, byte[] rawBytes) throws IOException {\n+        var cm = ClassFile.of().parse(rawBytes);\n+        record FieldKey(Utf8Entry name, Utf8Entry type) {}\n+        Set<FieldKey> strictFinals = new HashSet<>();\n+        for (var f : cm.fields()) {\n+            var rvaa = f.findAttribute(Attributes.runtimeVisibleAnnotations());\n+            if (rvaa.isPresent()) {\n+                for (var anno : rvaa.get().annotations()) {\n+                    var descString = anno.className();\n+                    if (descString.equalsString(CD_Strict.descriptorString())) {\n+                        strictFinals.add(new FieldKey(f.fieldName(), f.fieldType()));\n+                    }\n+                }\n+            }\n@@ -80,0 +119,71 @@\n+\n+        var thisClass = cm.thisClass();\n+        var superName = cm.superclass().orElseThrow().name();\n+\n+        var rewritten = ClassFile.of().transformClass(cm, (clb, cle) -> {\n+            cond:\n+            if (cle instanceof MethodModel mm\n+                    && mm.methodName().equalsString(INIT_NAME)) {\n+                var code = mm.findAttribute(Attributes.code()).orElseThrow();\n+                var elements = code.elementList();\n+                int len = elements.size();\n+                int superCallPos = -1;\n+                int returnPos = -1;\n+                boolean deferSuperCall = false;\n+                for (int i = 0; i < len; i++) {\n+                    var e = elements.get(i);\n+                    if (superCallPos == -1) {\n+                        if (e instanceof InvokeInstruction inv &&\n+                                inv.opcode() == Opcode.INVOKESPECIAL &&\n+                                inv.method().name().equalsString(INIT_NAME) &&\n+                                inv.method().type().equalsString(\"()V\") &&\n+                                inv.owner().name().equals(superName)) {\n+                            \/\/ Assume we are calling on uninitializedThis...\n+                            superCallPos = i;\n+                        }\n+                    } else if (!deferSuperCall) {\n+                        if (e instanceof FieldInstruction ins &&\n+                                ins.opcode() == Opcode.PUTFIELD &&\n+                                ins.owner().equals(thisClass) &&\n+                                strictFinals.contains(new FieldKey(ins.name(), ins.type()))) {\n+                            deferSuperCall = true;\n+                        }\n+                    }\n+                    if (e instanceof ReturnInstruction inst && inst.opcode() == Opcode.RETURN) {\n+                        if (returnPos != -1) {\n+                            throw new IllegalArgumentException(\"Control flow too complex\");\n+                        } else {\n+                            returnPos = i;\n+                        }\n+                    }\n+                }\n+                if (elements.reversed().stream()\n+                        .<Instruction>mapMulti((e, sink) -> {\n+                            if (e instanceof Instruction i) {\n+                                sink.accept(i);\n+                            }\n+                        })\n+                        .findFirst()\n+                        .orElseThrow()\n+                        .opcode() != Opcode.RETURN) {\n+                    throw new IllegalArgumentException(\"Control flow too complex\");\n+                }\n+                if (!deferSuperCall) {\n+                    break cond;\n+                }\n+                var suppliedElements = new ArrayList<>(elements);\n+                var foundLoad = suppliedElements.remove(superCallPos - 1);\n+                var foundSuperCall = suppliedElements.remove(superCallPos - 1);\n+                var foundReturnInst = suppliedElements.remove(returnPos - 2);\n+                suppliedElements.add(foundLoad);\n+                suppliedElements.add(foundSuperCall);\n+                suppliedElements.add(foundReturnInst);\n+                clb.withMethod(INIT_NAME, mm.methodTypeSymbol(), mm.flags().flagsMask(), mb -> mb\n+                        .transform(mm, MethodTransform.dropping(ce -> ce instanceof CodeModel))\n+                        .withCode(suppliedElements::forEach));\n+                return;\n+            }\n+            clb.with(cle);\n+        });\n+\n+        dumpClass(name, rewritten);\n@@ -118,0 +228,3 @@\n+        \/\/ Force preview\n+        transformed[4] = (byte) 0xFF;\n+        transformed[5] = (byte) 0xFF;\n","filename":"test\/lib\/jdk\/test\/lib\/value\/StrictCompiler.java","additions":124,"deletions":11,"binary":false,"changes":135,"status":"modified"}]}