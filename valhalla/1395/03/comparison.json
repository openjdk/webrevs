{"files":[{"patch":"@@ -35,1 +35,1 @@\n-@Retention(RetentionPolicy.SOURCE)\n+@Retention(RetentionPolicy.RUNTIME)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/annotation\/Strict.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n- * @compile --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED -XDgenerateAssertUnsetFieldsFrame -XDnoLocalProxyVars StrictFinalInstanceFieldsTest.java\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm jdk.test.lib.value.StrictCompiler StrictFinalInstanceFieldsTest.java -- -XDnoLocalProxyVars\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictFinalInstanceFieldsTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8351362\n+ * @summary Unit Test for StrictCompiler super rewrite\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm jdk.test.lib.value.StrictCompiler --deferSuperCall StrictCompilerSuperTest.java\n+ * @run junit StrictCompilerSuperTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Opcode;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.vm.annotation.Strict;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+\n+class StrictCompilerSuperTest {\n+    static Stream<Class<?>> testClasses() {\n+        return Stream.of(Rec.class, Exp.class, Inner.class);\n+    }\n+\n+    static Stream<ClassModel> testClassModels() {\n+        return testClasses().map(cls -> {\n+            try (var in = StrictCompilerSuperTest.class.getResourceAsStream(\"\/\" + cls.getName() + \".class\")) {\n+                return ClassFile.of().parse(in.readAllBytes());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        });\n+    }\n+\n+    @MethodSource(\"testClasses\")\n+    @ParameterizedTest\n+    void testReflectRewrittenRecord(Class<?> cls) throws Throwable {\n+        for (var field : cls.getDeclaredFields()) {\n+            if (Modifier.isStatic(field.getModifiers()) || field.isSynthetic())\n+                continue;\n+            assertEquals(ACC_PRIVATE | ACC_STRICT | ACC_FINAL, field.getModifiers(), () -> \"For field: \" + field.getName());\n+        }\n+    }\n+\n+    @MethodSource(\"testClassModels\")\n+    @ParameterizedTest\n+    void testRewrittenStrictAccessInClassFile(ClassModel cm) throws Throwable {\n+        for (var f : cm.fields()) {\n+            if (f.flags().has(AccessFlag.STATIC) || f.flags().has(AccessFlag.SYNTHETIC))\n+                continue;\n+            assertEquals(ACC_PRIVATE | ACC_STRICT | ACC_FINAL, f.flags().flagsMask(), () -> \"Field \" + f);\n+        }\n+    }\n+\n+    @MethodSource(\"testClassModels\")\n+    @ParameterizedTest\n+    void testRewrittenCtorBytecode(ClassModel cm) throws Throwable {\n+        var ctor = cm.methods().stream().filter(m -> m.methodName().equalsString(INIT_NAME)).findFirst().orElseThrow();\n+        var insts = new ArrayList<Instruction>();\n+        ctor.findAttribute(Attributes.code()).orElseThrow().forEach(ce -> {\n+            if (ce instanceof Instruction inst) {\n+                insts.add(inst);\n+            }\n+        });\n+        assertSame(Opcode.RETURN, insts.getLast().opcode());\n+        assertSame(Opcode.INVOKESPECIAL, insts.get(insts.size() - 2).opcode());\n+    }\n+\n+    record Rec(@Strict int a, @Strict long b) {\n+        static final String NOISE = \"noise\";\n+    }\n+\n+    static class Exp {\n+        private @Strict final int a;\n+        private @Strict final long b;\n+\n+        Exp(int a, long b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+    }\n+\n+    class Inner {\n+        private @Strict final int a;\n+        private @Strict final long b;\n+\n+        Inner(int a, long b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return a + \" \" + StrictCompilerSuperTest.this + \" \" + b;\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/StrictCompilerSuperTest.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8351362\n+ * @summary Unit Test for StrictCompiler\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm jdk.test.lib.value.StrictCompiler StrictCompilerTest.java\n+ * @run junit StrictCompilerTest\n+ *\/\n+\n+import jdk.internal.vm.annotation.Strict;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.ACC_FINAL;\n+import static java.lang.classfile.ClassFile.ACC_STRICT;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class StrictCompilerTest {\n+    @Test\n+    void testReflectMyself() throws Throwable {\n+        for (var field : StrictTarget.class.getDeclaredFields()) {\n+            assertEquals(ACC_STRICT | ACC_FINAL, field.getModifiers(), () -> field.getName());\n+        }\n+    }\n+\n+    static final class StrictTarget {\n+        @Strict\n+        final int a;\n+        @Strict\n+        final Object b;\n+\n+        StrictTarget() {\n+            this.a = 1;\n+            this.b = 2392352234L;\n+            super();\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/StrictCompilerTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -219,1 +219,5 @@\n-        Collection<JavaFileObject> sourceFiles = new LinkedList<JavaFileObject>();\n+        return compile(inputMap, new String[0]);\n+    }\n+\n+    public static Map<String, byte[]> compile(Map<String, ? extends CharSequence> inputMap, String... options) {\n+        Collection<JavaFileObject> sourceFiles = new ArrayList<>();\n@@ -228,1 +232,1 @@\n-        Boolean exitCode = compiler.getTask(writer, fileManager, null, null, null, sourceFiles).call();\n+        Boolean exitCode = compiler.getTask(writer, fileManager, null, Arrays.asList(options), null, sourceFiles).call();\n","filename":"test\/lib\/jdk\/test\/lib\/compiler\/InMemoryJavaCompiler.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.value;\n+\n+import java.io.IOException;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.classfile.instruction.FieldInstruction;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.classfile.instruction.ReturnInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+\n+\/**\n+ * Compile a java file with InMemoryJavaCompiler, and then modify the resulting\n+ * class file to include strict modifier and null restriction attributes.\n+ *\/\n+public final class StrictCompiler {\n+    public static final String TEST_SRC = System.getProperty(\"test.src\", \"\").trim();\n+    public static final String TEST_CLASSES = System.getProperty(\"test.classes\", \"\").trim();\n+    private static final ClassDesc CD_Strict = ClassDesc.of(\"jdk.internal.vm.annotation.Strict\");\n+    \/\/ NR will stay in jdk.internal for now until we expose as a more formal feature\n+    private static final ClassDesc CD_NullRestricted = ClassDesc.of(\"jdk.internal.vm.annotation.NullRestricted\");\n+\n+    \/**\n+     * @param args source and destination\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    public static void main(String[] args) throws IOException {\n+        Map<String, String> ins = new HashMap<>();\n+        List<String> javacOpts = new ArrayList<>();\n+        boolean encounteredSeparator = false;\n+        boolean deferSuperCall = false;\n+        for (var a : args) {\n+            if (encounteredSeparator) {\n+                javacOpts.add(a);\n+                continue;\n+            }\n+            if (a.endsWith(\".java\")) {\n+                String className = a.substring(0, a.length() - 5);\n+                Path src = Path.of(TEST_SRC, a);\n+                ins.put(className, Files.readString(src));\n+                continue;\n+            }\n+            switch (a) {\n+                case \"--\" -> encounteredSeparator = true;\n+                case \"--deferSuperCall\" -> deferSuperCall = true;\n+                default -> throw new IllegalArgumentException(\"Unknown option \" + a);\n+            }\n+        }\n+        if (!javacOpts.contains(\"--source\")) {\n+            javacOpts.add(\"--source\");\n+            javacOpts.add(String.valueOf(Runtime.version().feature()));\n+        }\n+        if (!javacOpts.contains(\"--enable-preview\")) {\n+            javacOpts.add(\"--enable-preview\");\n+        }\n+        if (!javacOpts.contains(\"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\")) {\n+            javacOpts.add(\"--add-exports\");\n+            javacOpts.add(\"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\");\n+        }\n+        System.out.println(javacOpts);\n+        var classes = InMemoryJavaCompiler.compile(ins, javacOpts.toArray(String[]::new));\n+        Files.createDirectories(Path.of(TEST_CLASSES));\n+        for (var entry : classes.entrySet()) {\n+            if (deferSuperCall) {\n+                fixSuperAndDumpClass(entry.getKey(), entry.getValue());\n+            } else {\n+                dumpClass(entry.getKey(), entry.getValue());\n+            }\n+        }\n+    }\n+\n+    private static void fixSuperAndDumpClass(String name, byte[] rawBytes) throws IOException {\n+        var cm = ClassFile.of().parse(rawBytes);\n+        record FieldKey(Utf8Entry name, Utf8Entry type) {}\n+        Set<FieldKey> strictInstances = new HashSet<>();\n+        for (var f : cm.fields()) {\n+            if (f.flags().has(AccessFlag.STATIC))\n+                continue;\n+            var rvaa = f.findAttribute(Attributes.runtimeVisibleAnnotations());\n+            if (rvaa.isPresent()) {\n+                for (var anno : rvaa.get().annotations()) {\n+                    var descString = anno.className();\n+                    if (descString.equalsString(CD_Strict.descriptorString())) {\n+                        strictInstances.add(new FieldKey(f.fieldName(), f.fieldType()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        var thisClass = cm.thisClass();\n+        var superName = cm.superclass().orElseThrow().name();\n+\n+        var rewritten = ClassFile.of().transformClass(cm, (clb, cle) -> {\n+            cond:\n+            if (cle instanceof MethodModel mm\n+                    && mm.methodName().equalsString(INIT_NAME)) {\n+                var code = mm.findAttribute(Attributes.code()).orElseThrow();\n+                var elements = code.elementList();\n+                int len = elements.size();\n+                int superCallPos = -1;\n+                int returnPos = -1;\n+                boolean deferSuperCall = false;\n+                for (int i = 0; i < len; i++) {\n+                    var e = elements.get(i);\n+                    if (superCallPos == -1) {\n+                        if (e instanceof InvokeInstruction inv &&\n+                                inv.opcode() == Opcode.INVOKESPECIAL &&\n+                                inv.method().name().equalsString(INIT_NAME) &&\n+                                inv.method().type().equalsString(\"()V\") &&\n+                                inv.owner().name().equals(superName)) {\n+                            \/\/ Assume we are calling on uninitializedThis...\n+                            superCallPos = i;\n+                        }\n+                    } else if (!deferSuperCall) {\n+                        if (e instanceof FieldInstruction ins &&\n+                                ins.opcode() == Opcode.PUTFIELD &&\n+                                ins.owner().equals(thisClass) &&\n+                                strictInstances.contains(new FieldKey(ins.name(), ins.type()))) {\n+                            deferSuperCall = true;\n+                        }\n+                    }\n+                    if (e instanceof ReturnInstruction inst && inst.opcode() == Opcode.RETURN) {\n+                        if (returnPos != -1) {\n+                            throw new IllegalArgumentException(\"Control flow too complex\");\n+                        } else {\n+                            returnPos = i;\n+                        }\n+                    }\n+                }\n+                if (elements.reversed().stream()\n+                        .<Instruction>mapMulti((e, sink) -> {\n+                            if (e instanceof Instruction i) {\n+                                sink.accept(i);\n+                            }\n+                        })\n+                        .findFirst()\n+                        .orElseThrow()\n+                        .opcode() != Opcode.RETURN) {\n+                    throw new IllegalArgumentException(\"Control flow too complex\");\n+                }\n+                if (!deferSuperCall) {\n+                    break cond;\n+                }\n+                var suppliedElements = new ArrayList<>(elements);\n+                var foundLoad = suppliedElements.remove(superCallPos - 1);\n+                var foundSuperCall = suppliedElements.remove(superCallPos - 1);\n+                var foundReturnInst = suppliedElements.remove(returnPos - 2);\n+                suppliedElements.add(foundLoad);\n+                suppliedElements.add(foundSuperCall);\n+                suppliedElements.add(foundReturnInst);\n+                clb.withMethod(INIT_NAME, mm.methodTypeSymbol(), mm.flags().flagsMask(), mb -> mb\n+                        .transform(mm, MethodTransform.dropping(ce -> ce instanceof CodeModel))\n+                        .withCode(suppliedElements::forEach));\n+                return;\n+            }\n+            clb.with(cle);\n+        });\n+\n+        dumpClass(name, rewritten);\n+    }\n+\n+    private static void dumpClass(String name, byte[] rawBytes) throws IOException {\n+        var cm = ClassFile.of().parse(rawBytes);\n+        var transformed = ClassFile.of().transformClass(cm, ClassTransform.transformingFields(FieldTransform.ofStateful(() -> new FieldTransform() {\n+            int oldAccessFlags;\n+            boolean nullRestricted;\n+            boolean strict;\n+\n+            @Override\n+            public void accept(FieldBuilder builder, FieldElement element) {\n+                if (element instanceof AccessFlags af) {\n+                    oldAccessFlags = af.flagsMask();\n+                    return;\n+                }\n+                builder.with(element);\n+                if (element instanceof RuntimeVisibleAnnotationsAttribute rvaa) {\n+                    for (var anno : rvaa.annotations()) {\n+                        var descString = anno.className();\n+                        if (descString.equalsString(CD_Strict.descriptorString())) {\n+                            strict = true;\n+                        } else if (descString.equalsString(CD_NullRestricted.descriptorString())) {\n+                            nullRestricted = true;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void atEnd(FieldBuilder builder) {\n+                if (strict) {\n+                    oldAccessFlags |= ACC_STRICT;\n+                }\n+                builder.withFlags(oldAccessFlags);\n+                assert !nullRestricted || strict : name;\n+            }\n+        })));\n+\n+        \/\/ Force preview\n+        transformed[4] = (byte) 0xFF;\n+        transformed[5] = (byte) 0xFF;\n+        Path dst = Path.of(TEST_CLASSES, name + \".class\");\n+        Files.write(dst, transformed);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/value\/StrictCompiler.java","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"}]}