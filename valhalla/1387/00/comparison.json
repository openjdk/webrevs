{"files":[{"patch":"@@ -1101,0 +1101,9 @@\n+static Node* see_through_inline_type(PhaseValues* phase, const MemNode* load, Node* base, int offset) {\n+  if (!load->is_mismatched_access() && base != nullptr && base->is_InlineType() && offset > oopDesc::klass_offset_in_bytes()) {\n+    Node* value = base->as_InlineType()->field_value_by_offset(offset, true);\n+    assert(value != nullptr, \"must see some value\");\n+    return value;\n+  }\n+\n+  return nullptr;\n+}\n@@ -1113,0 +1122,10 @@\n+\n+  \/\/ Try to see through an InlineTypeNode\n+  \/\/ LoadN is special because the input is not compressed\n+  if (Opcode() != Op_LoadN) {\n+    Node* value = see_through_inline_type(phase, this, ld_base, ld_off);\n+    if (value != nullptr) {\n+      return value;\n+    }\n+  }\n+\n@@ -1286,17 +1305,0 @@\n-  \/\/ Loading from an InlineType? The InlineType has the values of\n-  \/\/ all fields as input. Look for the field with matching offset.\n-  Node* addr = in(Address);\n-  intptr_t offset;\n-  Node* base = AddPNode::Ideal_base_and_offset(addr, phase, offset);\n-  if (!is_mismatched_access() && base != nullptr && base->is_InlineType() && offset > oopDesc::klass_offset_in_bytes()) {\n-    Node* value = base->as_InlineType()->field_value_by_offset((int)offset, true);\n-    if (value != nullptr) {\n-      if (Opcode() == Op_LoadN) {\n-        \/\/ Encode oop value if we are loading a narrow oop\n-        assert(!phase->type(value)->isa_narrowoop(), \"should already be decoded\");\n-        value = phase->transform(new EncodePNode(value, bottom_type()));\n-      }\n-      return value;\n-    }\n-  }\n-\n@@ -2433,0 +2435,13 @@\n+Node* LoadNNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Loading from an InlineType, find the input and make an EncodeP\n+  Node* addr = in(Address);\n+  intptr_t offset;\n+  Node* base = AddPNode::Ideal_base_and_offset(addr, phase, offset);\n+  Node* value = see_through_inline_type(phase, this, base, offset);\n+  if (value != nullptr) {\n+    return new EncodePNode(value, type());\n+  }\n+\n+  return LoadNode::Ideal(phase, can_reshape);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":32,"deletions":17,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -520,0 +520,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}