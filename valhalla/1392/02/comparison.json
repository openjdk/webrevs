{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -34,0 +35,1 @@\n+import java.util.HashSet;\n@@ -39,0 +41,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.ACC_STRICT;\n@@ -49,0 +53,3 @@\n+    private WritableField.UnsetField[] strictInstanceFields; \/\/ do not modify array contents\n+    private ClassModel lastStrictCheckClass; \/\/ buf writer has short life, so do not need weak here\n+    private boolean lastStrictCheckResult;\n@@ -70,0 +77,27 @@\n+    public boolean strictFieldsMatch(ClassModel cm) {\n+        \/\/ We have a cache because this check will be called multiple times\n+        \/\/ if a MethodModel is sent wholesale\n+        if (lastStrictCheckClass == cm) {\n+            return lastStrictCheckResult;\n+        }\n+\n+        var result = doStrictFieldsMatchCheck(cm);\n+        lastStrictCheckClass = cm;\n+        lastStrictCheckResult = result;\n+        return result;\n+    }\n+\n+    private boolean doStrictFieldsMatchCheck(ClassModel cm) {\n+        \/\/ TODO only check for preview class files? cache the check results on buf?\n+        \/\/ UTF8 Entry can be used as equality objects\n+        var checks = new HashSet<>(Arrays.asList(getStrictInstanceFields()));\n+        for (var f : cm.fields()) {\n+            if ((f.flags().flagsMask() & (ACC_STATIC | ACC_STRICT)) == ACC_STRICT) {\n+                if (!checks.remove(new WritableField.UnsetField(f.fieldName(), f.fieldType()))) {\n+                    return false; \/\/ Field mismatch!\n+                }\n+            }\n+        }\n+        return checks.isEmpty();\n+    }\n+\n@@ -82,0 +116,10 @@\n+\n+    public WritableField.UnsetField[] getStrictInstanceFields() {\n+        assert strictInstanceFields != null : \"should access only after setter call in DirectClassBuilder\";\n+        return strictInstanceFields;\n+    }\n+\n+    public void setStrictInstanceFields(WritableField.UnsetField[] strictInstanceFields) {\n+        this.strictInstanceFields = strictInstanceFields;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -144,1 +144,2 @@\n-        if (buf.canWriteDirect(classReader)) {\n+        var methodInfo = (MethodInfo) enclosingMethod;\n+        if (Util.canSkipMethodInflation(classReader, methodInfo, buf)) {\n@@ -148,1 +149,1 @@\n-            DirectCodeBuilder.build((MethodInfo) enclosingMethod,\n+            DirectCodeBuilder.build(methodInfo,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+    static final WritableField[] EMPTY_WRITABLE_FIELD_ARRAY = {};\n@@ -49,1 +50,1 @@\n-    private Util.Writable[] fields = EMPTY_WRITABLE_ARRAY;\n+    private WritableField[] fields = EMPTY_WRITABLE_FIELD_ARRAY;\n@@ -132,1 +133,1 @@\n-    ClassBuilder withField(Util.Writable field) {\n+    ClassBuilder withField(WritableField field) {\n@@ -171,1 +172,0 @@\n-\n@@ -198,0 +198,2 @@\n+        var strictInstanceFields = WritableField.filterStrictInstanceFields(constantPool, fields, fieldsCount);\n+        tail.setStrictInstanceFields(strictInstanceFields);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n@@ -368,1 +369,1 @@\n-                boolean codeMatch = dcb.original != null && codeAndExceptionsMatch(codeLength);\n+                boolean codeMatch = dcb.codeAndExceptionsMatch(codeLength, buf);\n@@ -446,1 +447,1 @@\n-    private boolean codeAndExceptionsMatch(int codeLength) {\n+    private boolean codeAndExceptionsMatch(int codeLength, BufWriterImpl buf) {\n@@ -456,0 +457,16 @@\n+\n+            if (codeAttributesMatch) {\n+                var thisIsConstructor = methodInfo.methodName().equalsString(INIT_NAME);\n+                var originalIsConstructor = cai.enclosingMethod.methodName().equalsString(INIT_NAME);\n+                if (thisIsConstructor || originalIsConstructor) {\n+                    if (thisIsConstructor != originalIsConstructor) {\n+                        codeAttributesMatch = false;\n+                    }\n+                }\n+\n+                if (codeAttributesMatch && thisIsConstructor) {\n+                    if (!buf.strictFieldsMatch(cai.classReader.getContainedClass())) {\n+                        codeAttributesMatch = false;\n+                    }\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-        implements TerminalFieldBuilder, Util.Writable {\n+        implements TerminalFieldBuilder, WritableField {\n@@ -87,0 +87,16 @@\n+\n+    \/\/ These values must only be accessed after the field is definitely configured\n+    @Override\n+    public Utf8Entry fieldName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public Utf8Entry fieldType() {\n+        return desc;\n+    }\n+\n+    @Override\n+    public int fieldFlags() {\n+        return flags;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-        implements FieldModel, Util.Writable {\n+        implements FieldModel, WritableField {\n@@ -56,1 +56,1 @@\n-        return new AccessFlagsImpl(AccessFlag.Location.FIELD, reader.readU2(startPos));\n+        return new AccessFlagsImpl(AccessFlag.Location.FIELD, fieldFlags());\n@@ -77,0 +77,5 @@\n+    @Override\n+    public int fieldFlags() {\n+        return reader.readU2(startPos);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,1 @@\n-        if (buf.canWriteDirect(reader)) {\n+        if (Util.canSkipMethodInflation(reader, this, buf)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    private static final int\n+    static final int\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,6 +33,1 @@\n-import java.lang.classfile.constantpool.ClassEntry;\n-import java.lang.classfile.constantpool.ConstantDynamicEntry;\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-import java.lang.classfile.constantpool.InvokeDynamicEntry;\n-import java.lang.classfile.constantpool.MemberRefEntry;\n-import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.classfile.constantpool.*;\n@@ -47,0 +42,1 @@\n+import jdk.internal.classfile.impl.WritableField.UnsetField;\n@@ -160,0 +156,1 @@\n+                buf.getStrictInstanceFields(),\n@@ -201,0 +198,1 @@\n+    private final UnsetField[] strictFieldsToPut; \/\/ exact-sized, do not modify this copy!\n@@ -232,0 +230,1 @@\n+                     UnsetField[] strictFields,\n@@ -246,0 +245,5 @@\n+        if (OBJECT_INITIALIZER_NAME.equals(methodName)) {\n+            this.strictFieldsToPut = strictFields;\n+        } else {\n+            this.strictFieldsToPut = UnsetField.EMPTY_ARRAY;\n+        }\n@@ -394,0 +398,1 @@\n+                int countPos = b.size();\n@@ -395,0 +400,1 @@\n+                int extraFrameCount = 0;\n@@ -396,1 +402,1 @@\n-                prevFrame.setLocalsFromArg(methodName, methodDesc, isStatic, thisType);\n+                prevFrame.setLocalsFromArg(methodName, methodDesc, isStatic, thisType, strictFieldsToPut);\n@@ -401,1 +407,1 @@\n-                    fr.writeTo(b, prevFrame, cp);\n+                    extraFrameCount += fr.writeTo(b, prevFrame, cp);\n@@ -404,0 +410,7 @@\n+                if (extraFrameCount > 0) {\n+                    int size = framesCount + extraFrameCount;\n+                    if (size != (char) size) {\n+                        throw generatorError(\"Too many frames: \" + size);\n+                    }\n+                    b.patchU2(countPos, size);\n+                }\n@@ -420,1 +433,1 @@\n-        currentFrame.setLocalsFromArg(methodName, methodDesc, isStatic, thisType);\n+        currentFrame.setLocalsFromArg(methodName, methodDesc, isStatic, thisType, strictFieldsToPut);\n@@ -422,1 +435,0 @@\n-        currentFrame.flags = 0;\n@@ -765,1 +777,2 @@\n-        var desc = Util.fieldTypeSymbol(cp.entryByIndex(bcs.getIndexU2(), MemberRefEntry.class).type());\n+        var nameAndType = cp.entryByIndex(bcs.getIndexU2(), MemberRefEntry.class).nameAndType();\n+        var desc = Util.fieldTypeSymbol(nameAndType.type());\n@@ -778,0 +791,3 @@\n+                if (strictFieldsToPut.length > 0) {\n+                    currentFrame.putStrictField(nameAndType);\n+                }\n@@ -801,0 +817,1 @@\n+                    \/\/ trust the unset fields are right by this stage...\n@@ -802,0 +819,3 @@\n+                    \/\/ need to clear for this-invoking constructors\n+                    currentFrame.unsetFieldsSize = 0;\n+                    currentFrame.unsetFields = UnsetField.EMPTY_ARRAY;\n@@ -944,1 +964,1 @@\n-        int localsSize, stackSize;\n+        int localsSize, stackSize, unsetFieldsSize;\n@@ -953,0 +973,1 @@\n+        private UnsetField[] unsetFields = UnsetField.EMPTY_ARRAY; \/\/ ordered set structure, modifiable oversized array\n@@ -1029,1 +1050,2 @@\n-                flags = 0;\n+                flags &= ~FLAG_THIS_UNINIT;\n+                assert flags == 0 : flags;\n@@ -1046,0 +1068,18 @@\n+        void putStrictField(NameAndTypeEntry nat) {\n+            int shift = 0;\n+            var array = unsetFields;\n+            for (int i = 0; i < unsetFieldsSize; i++) {\n+                var f = array[i];\n+                if (f.name().equals(nat.name()) && f.type().equals(nat.type())) {\n+                    shift++;\n+                } else if (shift != 0) {\n+                    array[i - shift] = array[i];\n+                    array[i] = null;\n+                }\n+            }\n+            if (shift > 1) {\n+                throw generatorError(nat + \"; discovered \" + shift);\n+            }\n+            unsetFieldsSize -= shift;\n+        }\n+\n@@ -1064,1 +1104,1 @@\n-        void setLocalsFromArg(String name, MethodTypeDesc methodDesc, boolean isStatic, Type thisKlass) {\n+        void setLocalsFromArg(String name, MethodTypeDesc methodDesc, boolean isStatic, Type thisKlass, UnsetField[] strictFieldsToPut) {\n@@ -1072,0 +1112,3 @@\n+                    int strictFieldCount = strictFieldsToPut.length;\n+                    this.unsetFields = UnsetField.copyArray(strictFieldsToPut, strictFieldCount);\n+                    this.unsetFieldsSize = strictFieldCount;\n@@ -1073,1 +1116,1 @@\n-                    flags |= FLAG_THIS_UNINIT;\n+                    this.flags = FLAG_THIS_UNINIT;\n@@ -1075,0 +1118,2 @@\n+                    this.unsetFields = UnsetField.EMPTY_ARRAY;\n+                    this.unsetFieldsSize = 0;\n@@ -1076,0 +1121,1 @@\n+                    this.flags = 0;\n@@ -1119,0 +1165,1 @@\n+            int myUnsetFieldsSize = this.unsetFieldsSize;\n@@ -1126,0 +1173,2 @@\n+                target.unsetFields = UnsetField.copyArray(this.unsetFields, myUnsetFieldsSize);\n+                target.unsetFieldsSize = myUnsetFieldsSize;\n@@ -1144,0 +1193,3 @@\n+                if (UnsetField.mismatches(unsetFields, unsetFieldsSize, target.unsetFields, target.unsetFieldsSize)) {\n+                    throw generatorError(\"Unset fields size mismatch\");\n+                }\n@@ -1224,1 +1276,12 @@\n-        void writeTo(BufWriterImpl out, Frame prevFrame, ConstantPoolBuilder cp) {\n+        int writeTo(BufWriterImpl out, Frame prevFrame, ConstantPoolBuilder cp) {\n+            int extraFrames = 0;\n+            if (unsetFieldsSize != prevFrame.unsetFieldsSize) {\n+                \/\/ Emit unset_fields frame\n+                out.writeU1U2(StackMapDecoder.ASSERT_UNSET_FIELDS, unsetFieldsSize);\n+                var array = unsetFields;\n+                for (int i = 0; i < unsetFieldsSize; i++) {\n+                    var f = array[i];\n+                    out.writeIndex(cp.nameAndTypeEntry(f.name(), f.type()));\n+                }\n+                extraFrames++;\n+            }\n@@ -1238,1 +1301,1 @@\n-                    return;\n+                    return extraFrames;\n@@ -1247,1 +1310,1 @@\n-                return;\n+                return extraFrames;\n@@ -1254,0 +1317,1 @@\n+            return extraFrames;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":83,"deletions":19,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n@@ -306,0 +307,11 @@\n+    public static boolean canSkipMethodInflation(ClassReader cr, MethodInfo method, BufWriterImpl buf) {\n+        if (!buf.canWriteDirect(cr)) {\n+            return false;\n+        }\n+        if (method.methodName().equalsString(INIT_NAME) &&\n+                !buf.strictFieldsMatch(((ClassReaderImpl) cr).getContainedClass())) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl;\n+\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.util.Arrays;\n+\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.ACC_STRICT;\n+\n+\/**\n+ * An interface to obtain field properties for direct class builders.\n+ * Required to filter strict instance fields for stack map generation.\n+ * Public for benchmark access.\n+ *\/\n+public sealed interface WritableField extends Util.Writable\n+        permits FieldImpl, DirectFieldBuilder {\n+    Utf8Entry fieldName();\n+    Utf8Entry fieldType();\n+    int fieldFlags();\n+\n+    static WritableField.UnsetField[] filterStrictInstanceFields(ConstantPoolBuilder cpb, WritableField[] array, int count) {\n+        \/\/ assume there's no toctou for trusted incoming array\n+        int size = 0;\n+        for (int i = 0; i < count; i++) {\n+            var field = array[i];\n+            if ((field.fieldFlags() & (ACC_STATIC | ACC_STRICT)) == ACC_STRICT) {\n+                size++;\n+            }\n+        }\n+        if (size == 0)\n+            return UnsetField.EMPTY_ARRAY;\n+        UnsetField[] ret = new UnsetField[size];\n+        int j = 0;\n+        for (int i = 0; i < count; i++) {\n+            var field = array[i];\n+            if ((field.fieldFlags() & (ACC_STATIC | ACC_STRICT)) == ACC_STRICT) {\n+                ret[j++] = new UnsetField(AbstractPoolEntry.maybeClone(cpb, field.fieldName()),\n+                        AbstractPoolEntry.maybeClone(cpb, field.fieldType()));\n+            }\n+        }\n+        assert j == size : \"toctou: \" + j + \" != \" + size;\n+        return ret;\n+    }\n+\n+    \/\/ The captured information of unset fields, pool entries localized to class writing context\n+    \/\/ avoid creating NAT until we need to write the fields to stack maps\n+    record UnsetField(Utf8Entry name, Utf8Entry type) {\n+        public static final UnsetField[] EMPTY_ARRAY = new UnsetField[0];\n+\n+        public static UnsetField[] copyArray(UnsetField[] incoming, int resultLen) {\n+            assert resultLen <= incoming.length : resultLen + \" > \" + incoming.length;\n+            return resultLen == 0 ? EMPTY_ARRAY : Arrays.copyOf(incoming, resultLen, UnsetField[].class);\n+        }\n+\n+        public static boolean mismatches(UnsetField[] one, int sizeOne, UnsetField[] two, int sizeTwo) {\n+            if (sizeOne != sizeTwo)\n+                return true;\n+            for (int i = 0; i < sizeOne; i++) {\n+                if (!one[i].equals(two[i])) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/WritableField.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.ByteCodeLoader\n+ * @run junit\/othervm -Xverify StrictClassFileGenerationTest\n+ *\/\n+\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.List;\n+\n+import jdk.test.lib.ByteCodeLoader;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class StrictClassFileGenerationTest {\n+    @Test\n+    void basicBranchTest() throws Throwable {\n+        var className = \"Test\";\n+        var classDesc = ClassDesc.of(className);\n+        var classBytes = ClassFile.of().build(classDesc, clb -> clb\n+                .withField(\"fs\", CD_int, ACC_STRICT)\n+                .withField(\"fsf\", CD_int, ACC_STRICT | ACC_FINAL)\n+                .withMethodBody(INIT_NAME, MTD_void, 0, cob -> cob\n+                        .aload(0)\n+                        .iconst_5()\n+                        .putfield(classDesc, \"fs\", CD_int)\n+                        .aload(0)\n+                        .iconst_0()\n+                        .ifThenElse(thb -> thb\n+                                .iconst_3()\n+                                .putfield(classDesc, \"fsf\", CD_int), elb -> elb\n+                                .iconst_2()\n+                                .putfield(classDesc, \"fsf\", CD_int))\n+                        .aload(0)\n+                        .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                        .return_()));\n+        var clazz = ByteCodeLoader.load(className, classBytes); \/\/ sanity check to pass verification\n+        var classModel = ClassFile.of().parse(classBytes);\n+        var ctorModel = classModel.methods().getFirst();\n+        var stackMaps = ctorModel.code().orElseThrow().findAttribute(Attributes.stackMapTable()).orElseThrow();\n+        assertEquals(2 * 2, stackMaps.entries().size()); \/\/ if -> else, then -> end of if + asserts\n+        var elseAssertFrame = stackMaps.entries().get(0); \/\/ else jump from if\n+        assertEquals(246, elseAssertFrame.frameType());\n+        assertEquals(List.of(ConstantPoolBuilder.of().nameAndTypeEntry(\"fsf\", CD_int)), elseAssertFrame.unsetFields());\n+        var mergedAssertFrame = stackMaps.entries().get(2); \/\/ then jump to join else\n+        assertEquals(246, mergedAssertFrame.frameType());\n+        assertEquals(List.of(), mergedAssertFrame.unsetFields());\n+    }\n+\n+    @Test\n+    void skipUnnecessaryUnsetFramesTest() throws Throwable {\n+        var className = \"Test\";\n+        var classDesc = ClassDesc.of(className);\n+        var classBytes = ClassFile.of().build(classDesc, clb -> clb\n+                .withField(\"fPlain\", CD_char, ACC_PRIVATE)\n+                .withField(\"fs\", CD_int, ACC_STRICT)\n+                .withField(\"fsf\", CD_int, ACC_STRICT | ACC_FINAL)\n+                .withMethodBody(INIT_NAME, MTD_void, 0, cob -> cob\n+                        .aload(0)\n+                        .iconst_5()\n+                        .putfield(classDesc, \"fs\", CD_int)\n+                        .aload(0)\n+                        .iconst_0()\n+                        .ifThenElse(thb -> thb\n+                                .iconst_3()\n+                                .putfield(classDesc, \"fPlain\", CD_int), elb -> elb\n+                                .iconst_2()\n+                                .putfield(classDesc, \"fPlain\", CD_int))\n+                        .aload(0)\n+                        .iconst_5()\n+                        .putfield(classDesc, \"fsf\", CD_int)\n+                        .aload(0)\n+                        .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                        .return_()));\n+        var clazz = ByteCodeLoader.load(className, classBytes); \/\/ sanity check to pass verification\n+        var classModel = ClassFile.of().parse(classBytes);\n+        var ctorModel = classModel.methods().getFirst();\n+        var stackMaps = ctorModel.code().orElseThrow().findAttribute(Attributes.stackMapTable()).orElseThrow();\n+        assertEquals(2 + 1, stackMaps.entries().size()); \/\/ if -> else, then -> end of if, just one assert\n+        var assertFrame = stackMaps.entries().get(0); \/\/ else jump from if\n+        assertEquals(246, assertFrame.frameType());\n+        assertEquals(List.of(ConstantPoolBuilder.of().nameAndTypeEntry(\"fsf\", CD_int)), assertFrame.unsetFields());\n+    }\n+\n+    @Test\n+    void clearUnsetAfterThisConstructorCallTest() throws Throwable {\n+        var className = \"Test\";\n+        var classDesc = ClassDesc.of(className);\n+        var fullArgsCtorDesc = MethodTypeDesc.of(CD_void, CD_int, CD_int);\n+        var classBytes = ClassFile.of().build(classDesc, clb -> clb\n+                .withField(\"fPlain\", CD_int, ACC_PRIVATE)\n+                .withField(\"fs\", CD_int, ACC_STRICT)\n+                .withField(\"fsf\", CD_int, ACC_STRICT | ACC_FINAL)\n+                \/\/ record-style ctor\n+                .withMethodBody(INIT_NAME, fullArgsCtorDesc, 0, cob -> cob\n+                        .aload(0)\n+                        .iload(1)\n+                        .putfield(classDesc, \"fs\", CD_int)\n+                        .aload(0)\n+                        .iload(2)\n+                        .putfield(classDesc, \"fsf\", CD_int)\n+                        .aload(0)\n+                        .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                        .return_())\n+                \/\/ delegates to the other ctor\n+                .withMethodBody(INIT_NAME, MTD_void, 0, cob -> cob\n+                        .aload(0)\n+                        .iconst_5()\n+                        .iconst_0()\n+                        .invokespecial(classDesc, INIT_NAME, fullArgsCtorDesc)\n+                        .aload(0)\n+                        .iconst_1()\n+                        .ifThenElse(thb -> thb\n+                                .iconst_3()\n+                                .putfield(classDesc, \"fPlain\", CD_int), elb -> elb\n+                                .iconst_2()\n+                                .putfield(classDesc, \"fPlain\", CD_int))\n+                        .return_()));\n+        var clazz = ByteCodeLoader.load(className, classBytes); \/\/ sanity check to pass verification\n+        var classModel = ClassFile.of().parse(classBytes);\n+        var ctorModel = classModel.methods().stream()\n+                .filter(m -> m.methodType().equalsString(MTD_void.descriptorString()))\n+                .findFirst().orElseThrow();\n+        var stackMaps = ctorModel.code().orElseThrow().findAttribute(Attributes.stackMapTable()).orElseThrow();\n+        assertEquals(2 + 1, stackMaps.entries().size()); \/\/ assert empty, if -> else, then -> end of if\n+        var assertFrame = stackMaps.entries().get(0); \/\/ assert empty for if -> else\n+        assertEquals(246, assertFrame.frameType());\n+        assertEquals(List.of(), assertFrame.unsetFields());\n+    }\n+\n+    @Test\n+    void failOnUnsetConflictTest() throws Throwable {\n+        var className = \"Test\";\n+        var classDesc = ClassDesc.of(className);\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(classDesc, clb -> clb\n+                .withField(\"fs0\", CD_int, ACC_STRICT)\n+                .withField(\"fs1\", CD_int, ACC_STRICT | ACC_FINAL)\n+                .withMethodBody(INIT_NAME, MTD_void, 0, cob -> cob\n+                        .aload(0)\n+                        .iconst_0()\n+                        .ifThenElse(thb -> thb\n+                                .iconst_3()\n+                                .putfield(classDesc, \"fs0\", CD_int), elb -> elb\n+                                .iconst_2()\n+                                .putfield(classDesc, \"fs1\", CD_int))\n+                        .aload(0)\n+                        .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                        .return_())));\n+    }\n+\n+    @Test\n+    void basicTransformToStrictTest() throws Throwable {\n+        var className = \"Test\";\n+        var classDesc = ClassDesc.of(className);\n+        var classBytes = ClassFile.of().build(classDesc, clb -> clb\n+                .withField(\"fs\", CD_int, 0)\n+                .withField(\"fsf\", CD_int, ACC_FINAL)\n+                .withMethodBody(INIT_NAME, MTD_void, 0, cob -> cob\n+                        .aload(0)\n+                        .iconst_5()\n+                        .putfield(classDesc, \"fs\", CD_int)\n+                        .aload(0)\n+                        .iconst_0()\n+                        .ifThenElse(thb -> thb\n+                                .iconst_3()\n+                                .putfield(classDesc, \"fsf\", CD_int), elb -> elb\n+                                .iconst_2()\n+                                .putfield(classDesc, \"fsf\", CD_int))\n+                        .aload(0)\n+                        .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                        .return_()));\n+\n+        classBytes = ClassFile.of().transformClass(ClassFile.of().parse(classBytes), ClassTransform.transformingFields((fb, fe) -> {\n+            if (fe instanceof AccessFlags acc) {\n+                fb.withFlags(acc.flagsMask() | ACC_STRICT);\n+            } else {\n+                fb.with(fe);\n+            }\n+        }));\n+\n+        var clazz = ByteCodeLoader.load(className, classBytes); \/\/ sanity check to pass verification\n+        var classModel = ClassFile.of().parse(classBytes);\n+        var ctorModel = classModel.methods().getFirst();\n+        var stackMaps = ctorModel.code().orElseThrow().findAttribute(Attributes.stackMapTable()).orElseThrow();\n+        assertEquals(2 * 2, stackMaps.entries().size()); \/\/ if -> else, then -> end of if + asserts\n+        var elseAssertFrame = stackMaps.entries().get(0); \/\/ else jump from if\n+        assertEquals(246, elseAssertFrame.frameType());\n+        assertEquals(List.of(ConstantPoolBuilder.of().nameAndTypeEntry(\"fsf\", CD_int)), elseAssertFrame.unsetFields());\n+        var mergedAssertFrame = stackMaps.entries().get(2); \/\/ then jump to join else\n+        assertEquals(246, mergedAssertFrame.frameType());\n+        assertEquals(List.of(), mergedAssertFrame.unsetFields());\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/StrictClassFileGenerationTest.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.internal.classfile.impl.WritableField;\n@@ -113,0 +114,1 @@\n+                WritableField.UnsetField.EMPTY_ARRAY,\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/CodeAttributeTools.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}