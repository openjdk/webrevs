{"files":[{"patch":"@@ -91,1 +91,1 @@\n-        \/\/ TODO only check for preview class files? cache the check results on buf?\n+        \/\/ TODO only check for preview class files?\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -817,1 +817,5 @@\n-                    \/\/ trust the unset fields are right by this stage...\n+                    var owner = cp.entryByIndex(index, MemberRefEntry.class).owner();\n+                    if (!owner.name().equalsString(((ClassOrInterfaceDescImpl) thisType.sym).internalName())\n+                            && currentFrame.unsetFieldsSize != 0) {\n+                        throw generatorError(\"Unset fields mismatch\");\n+                    }\n@@ -819,1 +823,0 @@\n-                    \/\/ need to clear for this-invoking constructors\n@@ -973,1 +976,1 @@\n-        private UnsetField[] unsetFields = UnsetField.EMPTY_ARRAY; \/\/ ordered set structure, modifiable oversized array\n+        private UnsetField[] unsetFields = UnsetField.EMPTY_ARRAY; \/\/ sorted, modifiable oversized array\n@@ -1158,0 +1161,2 @@\n+            unsetFieldsSize = src.unsetFieldsSize;\n+            unsetFields = UnsetField.copyArray(src.unsetFields, src.unsetFieldsSize);\n@@ -1193,2 +1198,2 @@\n-                if (UnsetField.mismatches(unsetFields, unsetFieldsSize, target.unsetFields, target.unsetFieldsSize)) {\n-                    throw generatorError(\"Unset fields size mismatch\");\n+                if (myUnsetFieldsSize != 0) {\n+                    mergeUnsetFields(target);\n@@ -1252,0 +1257,45 @@\n+        \/\/ Merge this frame's unset fields into the target frame\n+        private void mergeUnsetFields(Frame target) {\n+            int myUnsetSize = unsetFieldsSize;\n+            int targetUnsetSize = target.unsetFieldsSize;\n+            var myUnsets = unsetFields;\n+            var targetUnsets = target.unsetFields;\n+            if (!UnsetField.mismatches(myUnsets, myUnsetSize, targetUnsets, targetUnsetSize)) {\n+                return; \/\/ no merge\n+            }\n+            \/\/ merge sort\n+            var merged = new UnsetField[StackMapGenerator.this.strictFieldsToPut.length];\n+            int mergedSize = 0;\n+            int i = 0;\n+            int j = 0;\n+            while (i < myUnsetSize && j < targetUnsetSize) {\n+                var myCandidate = myUnsets[i];\n+                var targetCandidate = targetUnsets[j];\n+                var cmp = myCandidate.compareTo(targetCandidate);\n+                if (cmp == 0) {\n+                    merged[mergedSize++] = myCandidate;\n+                    i++;\n+                    j++;\n+                } else if (cmp < 0) {\n+                    merged[mergedSize++] = myCandidate;\n+                    i++;\n+                } else {\n+                    merged[mergedSize++] = targetCandidate;\n+                    j++;\n+                }\n+            }\n+            if (i < myUnsetSize) {\n+                int len = myUnsetSize - i;\n+                System.arraycopy(myUnsets, i, merged, mergedSize, len);\n+                mergedSize += len;\n+            } else if (j < targetUnsetSize) {\n+                int len = targetUnsetSize - j;\n+                System.arraycopy(targetUnsets, j, merged, mergedSize, len);\n+                mergedSize += len;\n+            }\n+\n+            target.unsetFieldsSize = mergedSize;\n+            target.unsetFields = merged;\n+            target.dirty = true;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":55,"deletions":5,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.classfile.constantpool.ConstantPool;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -264,0 +266,8 @@\n+    public static boolean checkConstantPoolsCompatible(ConstantPool one, ConstantPool two) {\n+        if (one.equals(two))\n+            return true;\n+        if (one instanceof ConstantPoolBuilder cpb && cpb.canWriteDirect(two))\n+            return true;\n+        return two instanceof ConstantPoolBuilder cpb && cpb.canWriteDirect(one);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.constantpool.ConstantPool;\n@@ -66,0 +67,1 @@\n+        Arrays.sort(ret);\n@@ -71,1 +73,4 @@\n-    record UnsetField(Utf8Entry name, Utf8Entry type) {\n+    record UnsetField(Utf8Entry name, Utf8Entry type) implements Comparable<UnsetField> {\n+        public UnsetField {\n+            assert Util.checkConstantPoolsCompatible(name.constantPool(), type.constantPool());\n+        }\n@@ -89,0 +94,10 @@\n+\n+        \/\/ Warning: inconsistent with equals (which uses UTF8 object equality)\n+        @Override\n+        public int compareTo(UnsetField o) {\n+            assert Util.checkConstantPoolsCompatible(name.constantPool(), o.name.constantPool());\n+            var ret = Integer.compare(name.index(), o.name.index());\n+            if (ret != 0)\n+                return ret;\n+            return Integer.compare(type.index(), o.type.index());\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/WritableField.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -166,1 +166,34 @@\n-    void failOnUnsetConflictTest() throws Throwable {\n+    void allowMultiAssignTest() throws Throwable {\n+        var className = \"Test\";\n+        var classDesc = ClassDesc.of(className);\n+        var classBytes = ClassFile.of().build(classDesc, clb -> clb\n+                .withField(\"fs\", CD_int, ACC_STRICT)\n+                .withField(\"fsf\", CD_int, ACC_STRICT | ACC_FINAL)\n+                .withMethodBody(INIT_NAME, MTD_void, 0, cob -> cob\n+                        .aload(0)\n+                        .iconst_1()\n+                        .ifThenElse(thb -> thb\n+                                .iconst_3()\n+                                .putfield(classDesc, \"fs\", CD_int), elb -> elb\n+                                \/\/ frame 0\n+                                .iconst_2()\n+                                .putfield(classDesc, \"fsf\", CD_int))\n+                        \/\/ frame 1\n+                        .aload(0)\n+                        .iconst_5()\n+                        .putfield(classDesc, \"fs\", CD_int)\n+                        .aload(0)\n+                        .loadConstant(12)\n+                        .putfield(classDesc, \"fsf\", CD_int)\n+                        .aload(0)\n+                        .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                        .return_()));\n+        var clazz = ByteCodeLoader.load(className, classBytes); \/\/ sanity check to pass verification\n+        var classModel = ClassFile.of().parse(classBytes);\n+        var ctorModel = classModel.methods().getFirst();\n+        var stackMaps = ctorModel.code().orElseThrow().findAttribute(Attributes.stackMapTable()).orElseThrow();\n+        assertEquals(2, stackMaps.entries().size(), () -> stackMaps.entries().toString()); \/\/ no assert frames\n+    }\n+\n+    @Test\n+    void failOnUnsetNotClearTest() throws Throwable {\n","filename":"test\/jdk\/jdk\/classfile\/StrictStackMapsTest.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"}]}