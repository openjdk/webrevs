{"files":[{"patch":"@@ -144,1 +144,2 @@\n-        if (buf.canWriteDirect(classReader)) {\n+        var methodInfo = (MethodInfo) enclosingMethod;\n+        if (Util.methodBytesContextCompatible(classReader, methodInfo, buf)) {\n@@ -148,1 +149,1 @@\n-            DirectCodeBuilder.build((MethodInfo) enclosingMethod,\n+            DirectCodeBuilder.build(methodInfo,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n@@ -368,1 +369,1 @@\n-                boolean codeMatch = dcb.original != null && codeAndExceptionsMatch(codeLength);\n+                boolean codeMatch = dcb.codeAndExceptionsMatch(codeLength, buf);\n@@ -446,1 +447,1 @@\n-    private boolean codeAndExceptionsMatch(int codeLength) {\n+    private boolean codeAndExceptionsMatch(int codeLength, BufWriterImpl buf) {\n@@ -456,0 +457,16 @@\n+\n+            if (codeAttributesMatch) {\n+                var thisIsConstructor = methodInfo.methodName().equalsString(INIT_NAME);\n+                var originalIsConstructor = cai.enclosingMethod.methodName().equalsString(INIT_NAME);\n+                if (thisIsConstructor || originalIsConstructor) {\n+                    if (thisIsConstructor != originalIsConstructor) {\n+                        codeAttributesMatch = false;\n+                    }\n+                }\n+\n+                if (codeAttributesMatch && thisIsConstructor) {\n+                    if (!Util.strictFieldsMatch(cai.classReader.getContainedClass(), buf)) {\n+                        codeAttributesMatch = false;\n+                    }\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-        if (buf.canWriteDirect(reader)) {\n+        if (Util.methodBytesContextCompatible(reader, this, buf)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Arrays;\n@@ -40,0 +41,1 @@\n+import java.util.HashSet;\n@@ -50,0 +52,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STRICT;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n@@ -306,0 +310,25 @@\n+    public static boolean methodBytesContextCompatible(ClassReader cr, MethodInfo method, BufWriterImpl buf) {\n+        if (!buf.canWriteDirect(cr)) {\n+            return false;\n+        }\n+        if (method.methodName().equalsString(INIT_NAME) &&\n+                !strictFieldsMatch(((ClassReaderImpl) cr).getContainedClass(), buf)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public static boolean strictFieldsMatch(ClassModel cm, BufWriterImpl buf) {\n+        \/\/ TODO only check for preview class files? cache the check results on buf?\n+        \/\/ UTF8 Entry can be used as equality objects\n+        var checks = new HashSet<>(Arrays.asList(buf.getStrictInstanceFields()));\n+        for (var f : cm.fields()) {\n+            if ((f.flags().flagsMask() & (ACC_STATIC | ACC_STRICT)) == ACC_STRICT) {\n+                if (!checks.remove(new WritableField.UnsetField(f.fieldName(), f.fieldType()))) {\n+                    return false; \/\/ Field mismatch!\n+                }\n+            }\n+        }\n+        return checks.isEmpty();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.classfile.AccessFlags;\n@@ -34,0 +35,1 @@\n+import java.lang.classfile.ClassTransform;\n@@ -182,0 +184,43 @@\n+\n+    @Test\n+    void basicTransformToStrictTest() throws Throwable {\n+        var className = \"Test\";\n+        var classDesc = ClassDesc.of(className);\n+        var classBytes = ClassFile.of().build(classDesc, clb -> clb\n+                .withField(\"fs\", CD_int, 0)\n+                .withField(\"fsf\", CD_int, ACC_FINAL)\n+                .withMethodBody(INIT_NAME, MTD_void, 0, cob -> cob\n+                        .aload(0)\n+                        .iconst_5()\n+                        .putfield(classDesc, \"fs\", CD_int)\n+                        .aload(0)\n+                        .iconst_0()\n+                        .ifThenElse(thb -> thb\n+                                .iconst_3()\n+                                .putfield(classDesc, \"fsf\", CD_int), elb -> elb\n+                                .iconst_2()\n+                                .putfield(classDesc, \"fsf\", CD_int))\n+                        .aload(0)\n+                        .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                        .return_()));\n+\n+        classBytes = ClassFile.of().transformClass(ClassFile.of().parse(classBytes), ClassTransform.transformingFields((fb, fe) -> {\n+            if (fe instanceof AccessFlags acc) {\n+                fb.withFlags(acc.flagsMask() | ACC_STRICT);\n+            } else {\n+                fb.with(fe);\n+            }\n+        }));\n+\n+        var clazz = ByteCodeLoader.load(className, classBytes); \/\/ sanity check to pass verification\n+        var classModel = ClassFile.of().parse(classBytes);\n+        var ctorModel = classModel.methods().getFirst();\n+        var stackMaps = ctorModel.code().orElseThrow().findAttribute(Attributes.stackMapTable()).orElseThrow();\n+        assertEquals(2 * 2, stackMaps.entries().size()); \/\/ if -> else, then -> end of if + asserts\n+        var elseAssertFrame = stackMaps.entries().get(0); \/\/ else jump from if\n+        assertEquals(246, elseAssertFrame.frameType());\n+        assertEquals(List.of(ConstantPoolBuilder.of().nameAndTypeEntry(\"fsf\", CD_int)), elseAssertFrame.unsetFields());\n+        var mergedAssertFrame = stackMaps.entries().get(2); \/\/ then jump to join else\n+        assertEquals(246, mergedAssertFrame.frameType());\n+        assertEquals(List.of(), mergedAssertFrame.unsetFields());\n+    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/StrictClassFileGenerationTest.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"}]}