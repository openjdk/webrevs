{"files":[{"patch":"@@ -7598,0 +7598,1 @@\n+  block_comment(\"spin_wait {\");\n@@ -7616,0 +7617,1 @@\n+  block_comment(\"}\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -443,1 +443,0 @@\n-#ifndef PRODUCT\n@@ -460,1 +459,0 @@\n-#endif\n@@ -1025,2 +1023,0 @@\n-  } else if (FLAG_IS_DEFAULT(UseAPX)) {\n-    FLAG_SET_DEFAULT(UseAPX, apx_supported ? true : false);\n@@ -1484,10 +1480,0 @@\n-      if (supports_sse4_2()) {\n-        if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {\n-          FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);\n-        }\n-      } else {\n-        if (UseSSE42Intrinsics && !FLAG_IS_DEFAULT(UseAESIntrinsics)) {\n-          warning(\"SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.\");\n-        }\n-        FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);\n-      }\n@@ -1538,10 +1524,0 @@\n-    if (supports_sse4_2()) {\n-      if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {\n-        FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);\n-      }\n-    } else {\n-      if (UseSSE42Intrinsics && !FLAG_IS_DEFAULT(UseAESIntrinsics)) {\n-        warning(\"SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.\");\n-      }\n-      FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);\n-    }\n@@ -1636,10 +1612,0 @@\n-      if (supports_sse4_2()) {\n-        if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {\n-          FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);\n-        }\n-      } else {\n-        if (UseSSE42Intrinsics && !FLAG_IS_DEFAULT(UseAESIntrinsics)) {\n-          warning(\"SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.\");\n-        }\n-        FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);\n-      }\n@@ -1706,1 +1672,10 @@\n-\n+  if (supports_sse4_2()) {\n+    if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);\n+    }\n+  } else {\n+    if (UseSSE42Intrinsics && !FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {\n+      warning(\"SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.\");\n+    }\n+    FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);\n+  }\n@@ -3154,3 +3129,0 @@\n-  \/\/ Enable APX support for product builds after\n-  \/\/ completion of planned features listed in JDK-8329030.\n-#if !defined(PRODUCT)\n@@ -3162,3 +3134,0 @@\n-#else\n-  return false;\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":10,"deletions":41,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  #define TIME_LINEAR_SCAN(timer_name)  TraceTime _block_timer(\"\", _total_timer.timer(LinearScanTimers::timer_name), TimeLinearScan || TimeEachLinearScan, Verbose);\n+  #define TIME_LINEAR_SCAN(timer_name)  TraceTime _block_timer(\"\", _total_timer.timer(LinearScanTimers::timer_name), TimeLinearScan, Verbose);\n@@ -3019,2 +3019,0 @@\n-  NOT_PRODUCT(_total_timer.begin_method());\n-\n@@ -3075,1 +3073,0 @@\n-  NOT_PRODUCT(_total_timer.end_method(this));\n@@ -6730,39 +6727,0 @@\n-void LinearScanTimers::begin_method() {\n-  if (TimeEachLinearScan) {\n-    \/\/ reset all timers to measure only current method\n-    for (int i = 0; i < number_of_timers; i++) {\n-      timer(i)->reset();\n-    }\n-  }\n-}\n-\n-void LinearScanTimers::end_method(LinearScan* allocator) {\n-  if (TimeEachLinearScan) {\n-\n-    double c = timer(timer_do_nothing)->seconds();\n-    double total = 0;\n-    for (int i = 1; i < number_of_timers; i++) {\n-      total += timer(i)->seconds() - c;\n-    }\n-\n-    if (total >= 0.0005) {\n-      \/\/ print all information in one line for automatic processing\n-      tty->print(\"@\"); allocator->compilation()->method()->print_name();\n-\n-      tty->print(\"@ %d \", allocator->compilation()->method()->code_size());\n-      tty->print(\"@ %d \", allocator->block_at(allocator->block_count() - 1)->last_lir_instruction_id() \/ 2);\n-      tty->print(\"@ %d \", allocator->block_count());\n-      tty->print(\"@ %d \", allocator->num_virtual_regs());\n-      tty->print(\"@ %d \", allocator->interval_count());\n-      tty->print(\"@ %d \", allocator->_num_calls);\n-      tty->print(\"@ %d \", allocator->num_loops());\n-\n-      tty->print(\"@ %6.6f \", total);\n-      for (int i = 1; i < number_of_timers; i++) {\n-        tty->print(\"@ %4.1f \", ((timer(i)->seconds() - c) \/ total) * 100);\n-      }\n-      tty->cr();\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -215,3 +215,0 @@\n-  develop(bool, TimeEachLinearScan, false,                                  \\\n-          \"print detailed timing of each LinearScan run\")                   \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -481,1 +481,1 @@\n-      aot_log_info(aot)(\"Specified %s not found (%s)\", CDSConfig::type_of_archive_being_loaded(), _archive_name);\n+      MetaspaceShared::report_loading_error(\"Specified %s not found (%s)\", CDSConfig::type_of_archive_being_loaded(), _archive_name);\n@@ -1294,2 +1294,2 @@\n-      aot_log_info(aot)(\"Failed to read %s shared space into reserved space at \" INTPTR_FORMAT,\n-                    shared_region_name[i], p2i(requested_addr));\n+      MetaspaceShared::report_loading_error(\"Failed to read %s shared space into reserved space at \" INTPTR_FORMAT,\n+                                            shared_region_name[i], p2i(requested_addr));\n@@ -1308,2 +1308,2 @@\n-      aot_log_info(aot)(\"Unable to map %s shared space at \" INTPTR_FORMAT,\n-                    shared_region_name[i], p2i(requested_addr));\n+      MetaspaceShared::report_loading_error(\"Unable to map %s shared space at \" INTPTR_FORMAT,\n+                                            shared_region_name[i], p2i(requested_addr));\n@@ -1374,2 +1374,2 @@\n-      aot_log_info(aot)(\"Failed to read aot code shared space into reserved space at \" INTPTR_FORMAT,\n-                    p2i(requested_base));\n+      MetaspaceShared::report_loading_error(\"Failed to read aot code shared space into reserved space at \" INTPTR_FORMAT,\n+                                            p2i(requested_base));\n@@ -1387,1 +1387,1 @@\n-    aot_log_info(aot)(\"failed to map aot code region\");\n+    MetaspaceShared::report_loading_error(\"failed to map aot code region\");\n@@ -1763,3 +1763,3 @@\n-      aot_log_info(aot)(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n-                    INTPTR_FORMAT \", size = %zu bytes\",\n-                    p2i(addr), _mapped_heap_memregion.byte_size());\n+      MetaspaceShared::report_loading_error(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n+                                            INTPTR_FORMAT \", size = %zu bytes\",\n+                                            p2i(addr), _mapped_heap_memregion.byte_size());\n@@ -2001,3 +2001,3 @@\n-    aot_log_info(aot)(\"The %s's ObjectAlignmentInBytes of %d\"\n-                  \" does not equal the current ObjectAlignmentInBytes of %d.\",\n-                  file_type, _obj_alignment, ObjectAlignmentInBytes);\n+    MetaspaceShared::report_loading_error(\"The %s's ObjectAlignmentInBytes of %d\"\n+                                          \" does not equal the current ObjectAlignmentInBytes of %d.\",\n+                                          file_type, _obj_alignment, ObjectAlignmentInBytes);\n@@ -2007,4 +2007,4 @@\n-    aot_log_info(aot)(\"The %s's CompactStrings setting (%s)\"\n-                  \" does not equal the current CompactStrings setting (%s).\", file_type,\n-                  _compact_strings ? \"enabled\" : \"disabled\",\n-                  CompactStrings   ? \"enabled\" : \"disabled\");\n+    MetaspaceShared::report_loading_error(\"The %s's CompactStrings setting (%s)\"\n+                                          \" does not equal the current CompactStrings setting (%s).\", file_type,\n+                                          _compact_strings ? \"enabled\" : \"disabled\",\n+                                          CompactStrings   ? \"enabled\" : \"disabled\");\n@@ -2094,2 +2094,3 @@\n-      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used when the \"\n-                     \"java.system.class.loader property is specified.\", CDSConfig::type_of_archive_being_loaded());\n+      MetaspaceShared::report_loading_error(\"%s has aot-linked classes. It cannot be used when the \"\n+                                            \"java.system.class.loader property is specified.\",\n+                                            CDSConfig::type_of_archive_being_loaded());\n@@ -2107,4 +2108,4 @@\n-    aot_log_info(aot)(\"The %s's BytecodeVerificationLocal setting (%s)\"\n-                               \" does not equal the current BytecodeVerificationLocal setting (%s).\", file_type,\n-                               _verify_local ? \"enabled\" : \"disabled\",\n-                               BytecodeVerificationLocal ? \"enabled\" : \"disabled\");\n+    MetaspaceShared::report_loading_error(\"The %s's BytecodeVerificationLocal setting (%s)\"\n+                                          \" does not equal the current BytecodeVerificationLocal setting (%s).\", file_type,\n+                                          _verify_local ? \"enabled\" : \"disabled\",\n+                                          BytecodeVerificationLocal ? \"enabled\" : \"disabled\");\n@@ -2131,2 +2132,2 @@\n-    aot_log_warning(aot)(\"The setting of the AllowArchivingWithJavaAgent is different \"\n-                               \"from the setting in the %s.\", file_type);\n+    MetaspaceShared::report_loading_error(\"The setting of the AllowArchivingWithJavaAgent is different \"\n+                                          \"from the setting in the %s.\", file_type);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":27,"deletions":26,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -100,4 +100,0 @@\n-  template <bool keep_alive>\n-  friend class ClassLoaderDataGraphIteratorBase;\n-  friend class ClassLoaderDataGraphKlassIteratorStatic;\n-  friend class ClassLoaderDataGraphMetaspaceIterator;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -735,7 +735,1 @@\n-      ik->clean_weak_instanceklass_links();\n-\n-      \/\/ JVMTI RedefineClasses creates previous versions that are not in\n-      \/\/ the class hierarchy, so process them here.\n-      while ((ik = ik->previous_versions()) != nullptr) {\n-        ik->clean_weak_instanceklass_links();\n-      }\n+      clean_weak_instanceklass_links(ik);\n@@ -746,0 +740,9 @@\n+void Klass::clean_weak_instanceklass_links(InstanceKlass* ik) {\n+  ik->clean_weak_instanceklass_links();\n+  \/\/ JVMTI RedefineClasses creates previous versions that are not in\n+  \/\/ the class hierarchy, so process them here.\n+  while ((ik = ik->previous_versions()) != nullptr) {\n+    ik->clean_weak_instanceklass_links();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -770,0 +770,1 @@\n+  \/\/ Clean out unnecessary weak klass links from the whole klass hierarchy.\n@@ -771,3 +772,2 @@\n-  static void clean_subklass_tree() {\n-    clean_weak_klass_links(\/*unloading_occurred*\/ true , \/* clean_alive_klasses *\/ false);\n-  }\n+  \/\/ Clean out unnecessary weak klass links from the given InstanceKlass.\n+  static void clean_weak_instanceklass_links(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1183,32 +1183,36 @@\n-      InstanceKlass* method_holder = target->method_holder();\n-      InstanceKlass* interf = interface_method->method_holder();\n-      HandleMark hm(THREAD);\n-      Handle method_holder_loader(THREAD, method_holder->class_loader());\n-      Handle interface_loader(THREAD, interf->class_loader());\n-\n-      if (method_holder_loader() != interface_loader()) {\n-        ResourceMark rm(THREAD);\n-        Symbol* failed_type_symbol =\n-          SystemDictionary::check_signature_loaders(target->signature(),\n-                                                    _klass,\n-                                                    method_holder_loader,\n-                                                    interface_loader,\n-                                                    true);\n-        if (failed_type_symbol != nullptr) {\n-          stringStream ss;\n-          ss.print(\"loader constraint violation in interface itable\"\n-                   \" initialization for class %s: when selecting method '\",\n-                   _klass->external_name());\n-          interface_method->print_external_name(&ss),\n-          ss.print(\"' the class loader %s for super interface %s, and the class\"\n-                   \" loader %s of the selected method's %s, %s have\"\n-                   \" different Class objects for the type %s used in the signature (%s; %s)\",\n-                   interf->class_loader_data()->loader_name_and_id(),\n-                   interf->external_name(),\n-                   method_holder->class_loader_data()->loader_name_and_id(),\n-                   method_holder->external_kind(),\n-                   method_holder->external_name(),\n-                   failed_type_symbol->as_klass_external_name(),\n-                   interf->class_in_module_of_loader(false, true),\n-                   method_holder->class_in_module_of_loader(false, true));\n-          THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n+      \/\/ Do not check loader constraints for overpass methods because overpass\n+      \/\/ methods are created by the jvm to throw exceptions.\n+      if (!target->is_overpass()) {\n+        InstanceKlass* method_holder = target->method_holder();\n+        InstanceKlass* interf = interface_method->method_holder();\n+        HandleMark hm(THREAD);\n+        Handle method_holder_loader(THREAD, method_holder->class_loader());\n+        Handle interface_loader(THREAD, interf->class_loader());\n+\n+        if (method_holder_loader() != interface_loader()) {\n+          ResourceMark rm(THREAD);\n+          Symbol* failed_type_symbol =\n+            SystemDictionary::check_signature_loaders(target->signature(),\n+                                                      _klass,\n+                                                      method_holder_loader,\n+                                                      interface_loader,\n+                                                      true);\n+          if (failed_type_symbol != nullptr) {\n+            stringStream ss;\n+            ss.print(\"loader constraint violation in interface itable\"\n+                     \" initialization for class %s: when selecting method '\",\n+                     _klass->external_name());\n+            interface_method->print_external_name(&ss),\n+              ss.print(\"' the class loader %s for super interface %s, and the class\"\n+                       \" loader %s of the selected method's %s, %s have\"\n+                       \" different Class objects for the type %s used in the signature (%s; %s)\",\n+                       interf->class_loader_data()->loader_name_and_id(),\n+                       interf->external_name(),\n+                       method_holder->class_loader_data()->loader_name_and_id(),\n+                       method_holder->external_kind(),\n+                       method_holder->external_name(),\n+                       failed_type_symbol->as_klass_external_name(),\n+                       interf->class_in_module_of_loader(false, true),\n+                       method_holder->class_in_module_of_loader(false, true));\n+            THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n+          }\n@@ -1336,3 +1340,1 @@\n-    if (target == nullptr || !target->is_public() || target->is_abstract() || target->is_overpass()) {\n-      assert(target == nullptr || !target->is_overpass() || target->is_public(),\n-             \"Non-public overpass method!\");\n+    if (target == nullptr || !target->is_public() || target->is_abstract()) {\n@@ -1340,1 +1342,1 @@\n-      if (!(target == nullptr) && !target->is_public()) {\n+      if (target != nullptr && !target->is_public()) {\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":38,"deletions":36,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1930,1 +1930,1 @@\n-  Mutex* lock = Atomic::load(&_extra_data_lock);\n+  Mutex* lock = Atomic::load_acquire(&_extra_data_lock);\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,0 +268,4 @@\n+  product(uint, IFGEdgesLimit, 10000000, DIAGNOSTIC,                        \\\n+          \"Maximum allowed edges in the interference graphs\")               \\\n+          range(0, max_juint)                                               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -332,0 +332,1 @@\n+  friend class LibraryCallKit;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -432,0 +432,3 @@\n+  if (C->failing()) {\n+    return;\n+  }\n@@ -475,0 +478,3 @@\n+  if (C->failing()) {\n+    return;\n+  }\n@@ -516,0 +522,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n@@ -599,0 +608,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3346,1 +3346,4 @@\n-  assert(OptimizePtrCompare, \"sanity\");\n+  const TypeInt* UNKNOWN = TypeInt::CC;    \/\/ [-1, 0,1]\n+  if (!OptimizePtrCompare) {\n+    return UNKNOWN;\n+  }\n@@ -3349,1 +3352,0 @@\n-  const TypeInt* UNKNOWN = TypeInt::CC;    \/\/ [-1, 0,1]\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  assert(jvms->map() == kit.map(), \"Out of sync JVM state\");\n@@ -1748,2 +1749,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state(this);\n@@ -1755,2 +1755,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -1759,1 +1757,1 @@\n-  destruct_map_clone(old_map);\n+  old_state.discard();\n@@ -2403,0 +2401,41 @@\n+LibraryCallKit::SavedState::SavedState(LibraryCallKit* kit) :\n+  _kit(kit),\n+  _sp(kit->sp()),\n+  _jvms(kit->jvms()),\n+  _map(kit->clone_map()),\n+  _discarded(false)\n+{\n+  for (DUIterator_Fast imax, i = kit->control()->fast_outs(imax); i < imax; i++) {\n+    Node* out = kit->control()->fast_out(i);\n+    if (out->is_CFG()) {\n+      _ctrl_succ.push(out);\n+    }\n+  }\n+}\n+\n+LibraryCallKit::SavedState::~SavedState() {\n+  if (_discarded) {\n+    _kit->destruct_map_clone(_map);\n+    return;\n+  }\n+  _kit->jvms()->set_map(_map);\n+  _kit->jvms()->set_sp(_sp);\n+  _map->set_jvms(_kit->jvms());\n+  _kit->set_map(_map);\n+  _kit->set_sp(_sp);\n+  for (DUIterator_Fast imax, i = _kit->control()->fast_outs(imax); i < imax; i++) {\n+    Node* out = _kit->control()->fast_out(i);\n+    if (out->is_CFG() && out->in(0) == _kit->control() && out != _kit->map() && !_ctrl_succ.member(out)) {\n+      _kit->_gvn.hash_delete(out);\n+      out->set_req(0, _kit->C->top());\n+      _kit->C->record_for_igvn(out);\n+      --i; --imax;\n+      _kit->_gvn.hash_find_insert(out);\n+    }\n+  }\n+}\n+\n+void LibraryCallKit::SavedState::discard() {\n+  _discarded = true;\n+}\n+\n@@ -2513,2 +2552,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state(this);\n@@ -2523,2 +2561,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n@@ -2542,2 +2578,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -2553,2 +2587,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -2601,2 +2633,0 @@\n-      set_map(old_map);\n-      set_sp(old_sp);\n@@ -2626,2 +2656,0 @@\n-        set_map(old_map);\n-        set_sp(old_sp);\n@@ -2633,2 +2661,2 @@\n-  destruct_map_clone(old_map);\n-  assert(!mismatched || is_flat || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n+  old_state.discard();\n+  assert(!mismatched || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n@@ -3119,2 +3147,1 @@\n-  uint old_sp = sp();\n-  SafePointNode* old_map = clone_map();\n+  SavedState old_state(this);\n@@ -3129,2 +3156,0 @@\n-    set_map(old_map);\n-    set_sp(old_sp);\n@@ -3134,1 +3159,1 @@\n-  destruct_map_clone(old_map);\n+  old_state.discard();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":49,"deletions":24,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -141,0 +141,23 @@\n+  \/* When an intrinsic makes changes before bailing out, it's necessary to restore the graph\n+   * as it was. See JDK-8359344 for what can happen wrong. It's also not always possible to\n+   * bailout before making changes because the bailing out decision might depend on new nodes\n+   * (their types, for instance).\n+   *\n+   * So, if an intrinsic might cause this situation, one must start by saving the state in a\n+   * SavedState by constructing it, and the state will be restored on destruction. If the\n+   * intrinsic is not bailing out, one need to call discard to prevent restoring the old state.\n+   *\/\n+  class SavedState {\n+    LibraryCallKit* _kit;\n+    uint _sp;\n+    JVMState* _jvms;\n+    SafePointNode* _map;\n+    Unique_Node_List _ctrl_succ;\n+    bool _discarded;\n+\n+  public:\n+    SavedState(LibraryCallKit*);\n+    ~SavedState();\n+    void discard();\n+  };\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -749,1 +749,1 @@\n-  \/\/ Convert one iteration loop into normal code.\n+  \/\/ Convert one-iteration loop into normal code.\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4521,0 +4521,1 @@\n+  C->print_method(PHASE_BEFORE_DUPLICATE_LOOP_BACKEDGE, 4, head);\n@@ -4611,0 +4612,2 @@\n+  C->print_method(PHASE_AFTER_DUPLICATE_LOOP_BACKEDGE, 4, outer_head);\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -89,8 +89,3 @@\n-Node* PhaseMacroExpand::opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path) {\n-  Node* cmp;\n-  if (mask != 0) {\n-    Node* and_node = transform_later(new AndXNode(word, MakeConX(mask)));\n-    cmp = transform_later(new CmpXNode(and_node, MakeConX(bits)));\n-  } else {\n-    cmp = word;\n-  }\n+\n+Node* PhaseMacroExpand::opt_bits_test(Node* ctrl, Node* region, int edge, Node* word) {\n+  Node* cmp = word;\n@@ -107,4 +102,0 @@\n-  if (return_fast_path) {\n-    region->init_req(edge, slow_taken); \/\/ Capture slow-control\n-    return fast_taken;\n-  } else {\n@@ -113,1 +104,0 @@\n-  }\n@@ -2515,1 +2505,1 @@\n-  slow_path = opt_bits_test(ctrl, region, 2, flock, 0, 0);\n+  slow_path = opt_bits_test(ctrl, region, 2, flock);\n@@ -2576,1 +2566,1 @@\n-  Node *slow_path = opt_bits_test(ctrl, region, 2, funlock, 0, 0);\n+  Node *slow_path = opt_bits_test(ctrl, region, 2, funlock);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-  Node* opt_bits_test(Node* ctrl, Node* region, int edge, Node* word, int mask, int bits, bool return_fast_path = false);\n+  Node* opt_bits_test(Node* ctrl, Node* region, int edge, Node* word);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1821,1 +1821,2 @@\n-\n+  \/\/ The hash of a node should not change, this would indicate different inputs\n+  uint old_hash = n->hash();\n@@ -1835,0 +1836,10 @@\n+    if (old_hash != n->hash()) {\n+      stringStream ss; \/\/ Print as a block without tty lock.\n+      ss.cr();\n+      ss.print_cr(\"Ideal optimization did not make progress but node hash changed.\");\n+      ss.print_cr(\"  old_hash = %d, hash = %d\", old_hash, n->hash());\n+      n->dump_bfs(1, nullptr, \"\", &ss);\n+      tty->print_cr(\"%s\", ss.as_string());\n+      return true;\n+    }\n+\n@@ -2894,0 +2905,1 @@\n+  push_bool_with_cmpu_and_mask(worklist, use);\n@@ -2940,0 +2952,51 @@\n+\/\/ Look for the following shape, which can be optimized by BoolNode::Value_cmpu_and_mask() (i.e. corresponds to case\n+\/\/ (1b): \"(m & x) <u (m + 1))\".\n+\/\/ If any of the inputs on the level (%%) change, we need to revisit Bool because we could have prematurely found that\n+\/\/ the Bool is constant (i.e. case (1b) can be applied) which could become invalid with new type information during CCP.\n+\/\/\n+\/\/  m    x  m    1  (%%)\n+\/\/   \\  \/    \\  \/\n+\/\/   AndI    AddI\n+\/\/      \\    \/\n+\/\/       CmpU\n+\/\/        |\n+\/\/       Bool\n+\/\/\n+void PhaseCCP::push_bool_with_cmpu_and_mask(Unique_Node_List& worklist, const Node* use) const {\n+  uint use_op = use->Opcode();\n+  if (use_op != Op_AndI && (use_op != Op_AddI || use->in(2)->find_int_con(0) != 1)) {\n+    \/\/ Not \"m & x\" or \"m + 1\"\n+    return;\n+  }\n+  for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+    Node* cmpu = use->fast_out(i);\n+    if (cmpu->Opcode() == Op_CmpU) {\n+      push_bool_matching_case1b(worklist, cmpu);\n+    }\n+  }\n+}\n+\n+\/\/ Push any Bool below 'cmpu' that matches case (1b) of BoolNode::Value_cmpu_and_mask().\n+void PhaseCCP::push_bool_matching_case1b(Unique_Node_List& worklist, const Node* cmpu) const {\n+  assert(cmpu->Opcode() == Op_CmpU, \"must be\");\n+  for (DUIterator_Fast imax, i = cmpu->fast_outs(imax); i < imax; i++) {\n+    Node* bol = cmpu->fast_out(i);\n+    if (!bol->is_Bool() || bol->as_Bool()->_test._test != BoolTest::lt) {\n+      \/\/ Not a Bool with \"<u\"\n+      continue;\n+    }\n+    Node* andI = cmpu->in(1);\n+    Node* addI = cmpu->in(2);\n+    if (andI->Opcode() != Op_AndI || addI->Opcode() != Op_AddI || addI->in(2)->find_int_con(0) != 1) {\n+      \/\/ Not \"m & x\" and \"m + 1\"\n+      continue;\n+    }\n+\n+    Node* m = addI->in(1);\n+    if (m == andI->in(1) || m == andI->in(2)) {\n+      \/\/ Is \"m\" shared? Matched (1b) and thus we revisit Bool.\n+      push_if_not_bottom_type(worklist, bol);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -644,0 +644,2 @@\n+  void push_bool_with_cmpu_and_mask(Unique_Node_List& worklist, const Node* use) const;\n+  void push_bool_matching_case1b(Unique_Node_List& worklist, const Node* cmpu) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,0 +78,8 @@\n+  flags(BEFORE_POST_LOOP,               \"Before Post Loop\") \\\n+  flags(AFTER_POST_LOOP,                \"After Post Loop\") \\\n+  flags(BEFORE_REMOVE_EMPTY_LOOP,       \"Before Remove Empty Loop\") \\\n+  flags(AFTER_REMOVE_EMPTY_LOOP,        \"After Remove Empty Loop\") \\\n+  flags(BEFORE_ONE_ITERATION_LOOP,      \"Before Replace One-Iteration Loop\") \\\n+  flags(AFTER_ONE_ITERATION_LOOP,       \"After Replace One-Iteration Loop\") \\\n+  flags(BEFORE_DUPLICATE_LOOP_BACKEDGE, \"Before Duplicate Loop Backedge\") \\\n+  flags(AFTER_DUPLICATE_LOOP_BACKEDGE,  \"After Duplicate Loop Backedge\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1984,1 +1984,1 @@\n-        if (rhs_m_type->_lo > -1 || rhs_m_type->_hi < -1) {\n+        if (rhs_m_type != nullptr && (rhs_m_type->_lo > -1 || rhs_m_type->_hi < -1)) {\n@@ -2002,0 +2002,4 @@\n+  const Type* input_type = phase->type(in(1));\n+  if (input_type == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -2007,1 +2011,1 @@\n-  return _test.cc2logical( phase->type( in(1) ) );\n+  return _test.cc2logical(input_type);\n@@ -2122,4 +2126,6 @@\n-    case Op_ReverseBytesS:  return TypeInt::make(byteswap(checked_cast<jshort>(con->is_int()->get_con())));\n-    case Op_ReverseBytesUS: return TypeInt::make(byteswap(checked_cast<jchar>(con->is_int()->get_con())));\n-    case Op_ReverseBytesI:  return TypeInt::make(byteswap(checked_cast<jint>(con->is_int()->get_con())));\n-    case Op_ReverseBytesL:  return TypeLong::make(byteswap(checked_cast<jlong>(con->is_long()->get_con())));\n+    \/\/ It is valid in bytecode to load any int and pass it to a method that expects a smaller type (i.e., short, char).\n+    \/\/ Let's cast the value to match the Java behavior.\n+    case Op_ReverseBytesS:  return TypeInt::make(byteswap(static_cast<jshort>(con->is_int()->get_con())));\n+    case Op_ReverseBytesUS: return TypeInt::make(byteswap(static_cast<jchar>(con->is_int()->get_con())));\n+    case Op_ReverseBytesI:  return TypeInt::make(byteswap(con->is_int()->get_con()));\n+    case Op_ReverseBytesL:  return TypeLong::make(byteswap(con->is_long()->get_con()));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -628,0 +628,11 @@\n+  do_stub(preuniverse, atomic_add)                                      \\\n+  do_entry(preuniverse, atomic_add, atomic_add_entry, atomic_add_entry) \\\n+  do_stub(preuniverse, atomic_xchg)                                     \\\n+  do_entry(preuniverse, atomic_xchg, atomic_xchg_entry,                 \\\n+           atomic_xchg_entry)                                           \\\n+  do_stub(preuniverse, atomic_cmpxchg)                                  \\\n+  do_entry(preuniverse, atomic_cmpxchg, atomic_cmpxchg_entry,           \\\n+           atomic_cmpxchg_entry)                                        \\\n+  do_stub(preuniverse, atomic_cmpxchg_long)                             \\\n+  do_entry(preuniverse, atomic_cmpxchg_long, atomic_cmpxchg_long_entry, \\\n+           atomic_cmpxchg_long_entry)                                   \\\n@@ -650,10 +661,0 @@\n-  do_stub(initial, atomic_add)                                          \\\n-  do_entry(initial, atomic_add, atomic_add_entry, atomic_add_entry)     \\\n-  do_stub(initial, atomic_xchg)                                         \\\n-  do_entry(initial, atomic_xchg, atomic_xchg_entry, atomic_xchg_entry)  \\\n-  do_stub(initial, atomic_cmpxchg)                                      \\\n-  do_entry(initial, atomic_cmpxchg, atomic_cmpxchg_entry,               \\\n-           atomic_cmpxchg_entry)                                        \\\n-  do_stub(initial, atomic_cmpxchg_long)                                 \\\n-  do_entry(initial, atomic_cmpxchg_long, atomic_cmpxchg_long_entry,     \\\n-           atomic_cmpxchg_long_entry)                                   \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-    \/\/\/ @since 25\n+    \/\/\/ @since 26\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -445,0 +445,1 @@\n+    \/\/ Null checks entry\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -210,1 +210,0 @@\n-                handlersSize++;\n@@ -566,0 +565,1 @@\n+        int targetBci = labelToBci(target); \/\/ implicit null check\n@@ -567,1 +567,0 @@\n-        int targetBci = labelToBci(target);\n@@ -590,0 +589,1 @@\n+        Objects.requireNonNull(target); \/\/ before any write\n@@ -637,0 +637,11 @@\n+        cases = new ArrayList<>(cases); \/\/ cases may be untrusted\n+        for (var each : cases) {\n+            Objects.requireNonNull(each); \/\/ single null case may exist\n+        }\n+        cases.sort(new Comparator<>() {\n+            @Override\n+            public int compare(SwitchCase c1, SwitchCase c2) {\n+                return Integer.compare(c1.caseValue(), c2.caseValue());\n+            }\n+        });\n+        \/\/ validation end\n@@ -644,7 +655,0 @@\n-        cases = new ArrayList<>(cases);\n-        cases.sort(new Comparator<>() {\n-            @Override\n-            public int compare(SwitchCase c1, SwitchCase c2) {\n-                return Integer.compare(c1.caseValue(), c2.caseValue());\n-            }\n-        });\n@@ -659,0 +663,5 @@\n+        var caseMap = new HashMap<Integer, Label>(cases.size()); \/\/ cases may be untrusted\n+        for (var c : cases) {\n+            caseMap.put(c.caseValue(), c.target());\n+        }\n+        \/\/ validation end\n@@ -666,4 +675,0 @@\n-        var caseMap = new HashMap<Integer, Label>(cases.size());\n-        for (var c : cases) {\n-            caseMap.put(c.caseValue(), c.target());\n-        }\n@@ -948,0 +953,1 @@\n+            Util.checkKind(opcode, Opcode.Kind.INVOKE);\n@@ -979,1 +985,2 @@\n-        bytecodesBufWriter.writeIndex(opcode.bytecode(), ref);\n+        Util.checkKind(opcode, Opcode.Kind.FIELD_ACCESS);\n+        writeFieldAccess(opcode, ref);\n@@ -997,0 +1004,1 @@\n+        Util.checkKind(op, Opcode.Kind.BRANCH);\n@@ -1660,0 +1668,2 @@\n+        Objects.requireNonNull(defaultTarget);\n+        \/\/ check cases when we sort them\n@@ -1819,0 +1829,1 @@\n+        BytecodeHelpers.validateMultiArrayDimensions(dims);\n@@ -1865,0 +1876,2 @@\n+        Objects.requireNonNull(defaultTarget);\n+        \/\/ check cases when we write them\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":27,"deletions":14,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -2252,2 +2251,5 @@\n-     * Return the base type of t or any of its outer types that starts\n-     * with the given symbol.  If none exists, return null.\n+     *  This method returns the first type in a sequence (starting at `t`) that is\n+     *  a subclass of `sym`. The next type in the sequence is obtained by calling\n+     *  `getEnclosingType()` on the previous type in the sequence. Note, this is\n+     *  typically used to compute the implicit qualifier in a method\/field access\n+     *  expression. Example:\n@@ -2255,2 +2257,13 @@\n-     * @param t a type\n-     * @param sym a symbol\n+     *  static class Sup<F> { public F f; }\n+     *   class Outer {\n+     *    static class Sub extends Sup<String> {\n+     *        class I {\n+     *          void test() {\n+     *              String f2 = f; \/\/ Sup<String>::f\n+     *          }\n+     *        }\n+     *    }\n+     *  }\n+     *\n+     *  @param t a type\n+     *  @param sym a symbol\n@@ -2259,16 +2272,5 @@\n-        switch (t.getTag()) {\n-        case CLASS:\n-            do {\n-                Type s = asSuper(t, sym);\n-                if (s != null) return s;\n-                t = t.getEnclosingType();\n-            } while (t.hasTag(CLASS));\n-            return null;\n-        case ARRAY:\n-            return isSubtype(t, sym.type) ? sym.type : null;\n-        case TYPEVAR:\n-            return asSuper(t, sym);\n-        case ERROR:\n-            return t;\n-        default:\n-            return null;\n+        Type t1 = t;\n+        while (!t1.hasTag(NONE)) {\n+            Type s = asSuper(t1, sym);\n+            if (s != null) return s;\n+            t1 = t1.getEnclosingType();\n@@ -2276,0 +2278,1 @@\n+        return null;\n@@ -2279,2 +2282,13 @@\n-     * Return the base type of t or any of its enclosing types that\n-     * starts with the given symbol.  If none exists, return null.\n+     * This method returns the first type in a sequence (starting at `t`) that is\n+     * a subclass of `sym`. The next type in the sequence is obtained by obtaining\n+     * innermost lexically enclosing class type of the previous type in the sequence.\n+     * Note, this is typically used to compute the implicit qualifier in\n+     * a type expression. Example:\n+     *\n+     * class A<T> { class B { } }\n+     *\n+     * class C extends A<String> {\n+     *   static class D {\n+     *      B b; \/\/ A<String>.B\n+     *   }\n+     * }\n@@ -2286,19 +2300,7 @@\n-        switch (t.getTag()) {\n-        case CLASS:\n-            do {\n-                Type s = asSuper(t, sym);\n-                if (s != null) return s;\n-                Type outer = t.getEnclosingType();\n-                t = (outer.hasTag(CLASS)) ? outer :\n-                    (t.tsym.owner.enclClass() != null) ? t.tsym.owner.enclClass().type :\n-                    Type.noType;\n-            } while (t.hasTag(CLASS));\n-            return null;\n-        case ARRAY:\n-            return isSubtype(t, sym.type) ? sym.type : null;\n-        case TYPEVAR:\n-            return asSuper(t, sym);\n-        case ERROR:\n-            return t;\n-        default:\n-            return null;\n+        Type t1 = t;\n+        while (!t1.hasTag(NONE)) {\n+            Type s = asSuper(t1, sym);\n+            if (s != null) return s;\n+            t1 = (t1.tsym.owner.enclClass() != null)\n+                    ? t1.tsym.owner.enclClass().type\n+                    : noType;\n@@ -2306,0 +2308,1 @@\n+        return null;\n@@ -4530,1 +4533,1 @@\n-        List<Type> commonSupers = superClosure(to, erasure(from));\n+        List<Type> commonSupers = supertypeClosure(to, erasure(from));\n@@ -4588,1 +4591,1 @@\n-    private List<Type> superClosure(Type t, Type s) {\n+    private List<Type> supertypeClosure(Type t, Type s) {\n@@ -4594,1 +4597,1 @@\n-                cl = union(cl, superClosure(l.head, s));\n+                cl = union(cl, supertypeClosure(l.head, s));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":48,"deletions":45,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -4948,5 +4948,2 @@\n-                    else if (ownOuter.hasTag(CLASS) && site != ownOuter) {\n-                        Type normOuter = site;\n-                        if (normOuter.hasTag(CLASS)) {\n-                            normOuter = types.asEnclosingSuper(site, ownOuter.tsym);\n-                        }\n+                    else if ((ownOuter.hasTag(CLASS) || ownOuter.hasTag(TYPEVAR)) && site != ownOuter) {\n+                        Type normOuter = types.asEnclosingSuper(site, ownOuter.tsym);\n@@ -5338,2 +5335,2 @@\n-                        if (site.hasTag(CLASS))\n-                            site = types.asOuterSuper(site, clazzOuter.tsym);\n+                        if (site.hasTag(CLASS) || site.hasTag(TYPEVAR))\n+                            site = types.asEnclosingSuper(site, clazzOuter.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3867,1 +3867,1 @@\n-                log.mandatoryWarning(pos, Warnings.SunProprietary(s));\n+                log.warning(pos, Warnings.SunProprietary(s));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1972,0 +1972,1 @@\n+# flags: strict\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-compiler\/onSpinWait\/TestOnSpinWaitAArch64.java 8360936 linux-aarch64,macosx-aarch64\n+compiler\/debug\/TestStressBailout.java 8361752 generic-all\n@@ -202,0 +202,2 @@\n+serviceability\/sa\/ClhsdbThreadContext.java        8356704 windows-x64\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,5 +103,5 @@\n-    private static final String START = \"(\\\\d+(\\\\s){2}(\";\n-    private static final String MID = \".*)+(\\\\s){2}===.*\";\n-    private static final String END = \")\";\n-    private static final String STORE_OF_CLASS_POSTFIX = \"( \\\\([^\\\\)]+\\\\))?(:|\\\\+)\\\\S* \\\\*\" + END;\n-    private static final String LOAD_OF_CLASS_POSTFIX = \"( \\\\([^\\\\)]+\\\\))?(:|\\\\+)\\\\S* \\\\*\" + END;\n+    public static final String START = \"(\\\\d+(\\\\s){2}(\";\n+    public static final String MID = \".*)+(\\\\s){2}===.*\";\n+    public static final String END = \")\";\n+    public static final String STORE_OF_CLASS_POSTFIX = \"( \\\\([^\\\\)]+\\\\))?(:|\\\\+)\\\\S* \\\\*\" + END;\n+    public static final String LOAD_OF_CLASS_POSTFIX = \"( \\\\([^\\\\)]+\\\\))?(:|\\\\+)\\\\S* \\\\*\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -128,0 +128,6 @@\n+        runCheck(\n+                BadFailOnConstraint.create(AllocInstance.class, \"allocNested()\", 1),\n+                BadFailOnConstraint.create(AllocInstance.class, \"allocNested()\", 2),\n+                BadFailOnConstraint.create(AllocInstance.class, \"allocNested()\", 3)\n+        );\n+\n@@ -975,0 +981,7 @@\n+\n+    static class Nested {}\n+    @Test\n+    @IR(failOn = {IRNode.ALLOC_OF, \"Nested\"})\n+    @IR(failOn = {IRNode.ALLOC_OF, \"AllocInstance\\\\$Nested\"})\n+    @IR(failOn = {IRNode.ALLOC_OF, \"AllocInst\\\\w+\\\\$Nested\"})\n+    public Nested allocNested() { return new Nested(); }\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+java\/awt\/Frame\/BogusFocusableWindowState\/BogusFocusableWindowState.java 8361521 linux-all\n@@ -855,1 +856,0 @@\n-tools\/sincechecker\/modules\/java.base\/JavaBaseCheckSince.java 8358627 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}