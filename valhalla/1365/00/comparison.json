{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-import test.java.lang.invoke.lib.OldInstructionHelper;\n-\n+import test.java.lang.invoke.lib.InstructionHelper;\n@@ -35,1 +34,0 @@\n-import jdk.experimental.bytecode.TypeTag;\n@@ -51,1 +49,1 @@\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n@@ -56,1 +54,1 @@\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n@@ -1096,1 +1094,1 @@\n-    private static final MethodHandle setArrayElementNull = OldInstructionHelper.loadCode(MethodHandles.lookup(),\n+    private static final MethodHandle setArrayElementNull = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n@@ -1101,2 +1099,2 @@\n-            aload_1().\n-            iload_2().\n+            aload(1).\n+            iload(2).\n@@ -1436,1 +1434,1 @@\n-    private static final MethodHandle setArrayElementIncompatible = OldInstructionHelper.loadCode(MethodHandles.lookup(),\n+    private static final MethodHandle setArrayElementIncompatible = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n@@ -1441,3 +1439,3 @@\n-            aload_1().\n-            iload_2().\n-            aload_3().\n+            aload(1).\n+            iload(2).\n+            aload(3).\n@@ -4063,1 +4061,1 @@\n-    private static final MethodHandle setArrayElementIncompatibleRef = OldInstructionHelper.loadCode(MethodHandles.lookup(),\n+    private static final MethodHandle setArrayElementIncompatibleRef = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n@@ -4068,3 +4066,3 @@\n-            aload_1().\n-            iload_2().\n-            aload_3().\n+            aload(1).\n+            iload(2).\n+            aload(3).\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-import jdk.experimental.bytecode.TypeTag;\n-import test.java.lang.invoke.lib.OldInstructionHelper;\n+import test.java.lang.invoke.lib.InstructionHelper;\n@@ -50,1 +49,1 @@\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n@@ -55,1 +54,1 @@\n- * @build jdk.experimental.bytecode.BasicClassBuilder test.java.lang.invoke.lib.OldInstructionHelper\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n@@ -2581,1 +2580,1 @@\n-    private static final MethodHandle refCheckCast = OldInstructionHelper.loadCode(MethodHandles.lookup(),\n+    private static final MethodHandle refCheckCast = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n@@ -2586,3 +2585,3 @@\n-            aload_1().\n-            checkcast(MyValue2.class).\n-            return_(TypeTag.A);\n+            aload(1).\n+            checkcast(MyValue2.class.describeConstable().orElseThrow()).\n+            areturn();\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.experimental.bytecode.TypeTag;\n@@ -35,1 +34,0 @@\n-import jdk.internal.value.ValueClass;\n@@ -44,1 +42,1 @@\n- * @library \/test\/lib \/test\/jdk\/lib\/testlibrary\/bytecode \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueClasses.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,369 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package test.java.lang.invoke.lib;\n-\n-import jdk.experimental.bytecode.BasicClassBuilder;\n-import jdk.experimental.bytecode.BasicTypeHelper;\n-import jdk.experimental.bytecode.BytePoolHelper;\n-import jdk.experimental.bytecode.ClassBuilder;\n-import jdk.experimental.bytecode.CodeBuilder;\n-import jdk.experimental.bytecode.Flag;\n-import jdk.experimental.bytecode.MethodBuilder;\n-import jdk.experimental.bytecode.PoolHelper;\n-import jdk.experimental.bytecode.TypedCodeBuilder;\n-import jdk.experimental.bytecode.TypeHelper;\n-import jdk.experimental.bytecode.TypeTag;\n-\n-import java.io.FileOutputStream;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.Iterator;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-import static java.lang.invoke.MethodType.fromMethodDescriptorString;\n-import static java.lang.invoke.MethodType.methodType;\n-\n-\/**\n- * 8308778: Temporarily keep the old bytecode API, but needs removing when Valhalla support is added to classfile API\n- *\/\n-public class OldInstructionHelper {\n-\n-    static final BasicTypeHelper BTH = new BasicTypeHelper();\n-\n-    static final AtomicInteger COUNT = new AtomicInteger();\n-\n-    static String generateClassNameFromLookupClass(MethodHandles.Lookup l) {\n-        return l.lookupClass().getCanonicalName().replace('.', '\/') + \"$Code_\" + COUNT.getAndIncrement();\n-    }\n-\n-    static BasicClassBuilder classBuilder(MethodHandles.Lookup l) {\n-        String className = generateClassNameFromLookupClass(l);\n-        return new BasicClassBuilder(className, 55, 0)\n-                .withSuperclass(\"java\/lang\/Object\")\n-                .withMethod(\"<init>\", \"()V\", M ->\n-                        M.withFlags(Flag.ACC_PUBLIC)\n-                                .withCode(TypedCodeBuilder::new, C ->\n-                                        C.aload_0().invokespecial(\"java\/lang\/Object\", \"<init>\", \"()V\", false).return_()\n-                                ));\n-    }\n-\n-    public static MethodHandle invokedynamic(MethodHandles.Lookup l,\n-                                      String name, MethodType type,\n-                                      String bsmMethodName, MethodType bsmType,\n-                                      Consumer<PoolHelper.StaticArgListBuilder<String, String, byte[]>> staticArgs) throws Exception {\n-        byte[] byteArray = classBuilder(l)\n-                .withMethod(\"m\", type.toMethodDescriptorString(), M ->\n-                        M.withFlags(Flag.ACC_PUBLIC, Flag.ACC_STATIC)\n-                                .withCode(TypedCodeBuilder::new,\n-                                          C -> {\n-                                              for (int i = 0; i < type.parameterCount(); i++) {\n-                                                  C.load(BTH.tag(cref(type.parameterType(i))), i);\n-                                              }\n-                                              C.invokedynamic(name, type.toMethodDescriptorString(),\n-                                                              csym(l.lookupClass()), bsmMethodName, bsmType.toMethodDescriptorString(),\n-                                                              staticArgs);\n-                                              C.return_(BTH.tag(cref(type.returnType())));\n-                                          }\n-                                ))\n-                .build();\n-        Class<?> gc = l.defineClass(byteArray);\n-        return l.findStatic(gc, \"m\", type);\n-    }\n-\n-    public static MethodHandle ldcMethodHandle(MethodHandles.Lookup l,\n-                                        int refKind, Class<?> owner, String name, MethodType type) throws Exception {\n-        return ldc(l, MethodHandle.class,\n-                   P -> P.putHandle(refKind, csym(owner), name, type.toMethodDescriptorString()));\n-    }\n-\n-    public static MethodHandle ldcDynamicConstant(MethodHandles.Lookup l,\n-                                                  String name, Class<?> type,\n-                                                  String bsmMethodName, MethodType bsmType,\n-                                                  Consumer<PoolHelper.StaticArgListBuilder<String, String, byte[]>> staticArgs) throws Exception {\n-        return ldcDynamicConstant(l, name, type, l.lookupClass(), bsmMethodName, bsmType, staticArgs);\n-    }\n-\n-    public static MethodHandle ldcDynamicConstant(MethodHandles.Lookup l,\n-                                                  String name, Class<?> type,\n-                                                  Class<?> bsmClass, String bsmMethodName, MethodType bsmType,\n-                                                  Consumer<PoolHelper.StaticArgListBuilder<String, String, byte[]>> staticArgs) throws Exception {\n-        return ldcDynamicConstant(l, name, cref(type), csym(bsmClass), bsmMethodName, bsmType.toMethodDescriptorString(), staticArgs);\n-    }\n-\n-    public static MethodHandle ldcDynamicConstant(MethodHandles.Lookup l,\n-                                                  String name, String type,\n-                                                  String bsmMethodName, String bsmType,\n-                                                  Consumer<PoolHelper.StaticArgListBuilder<String, String, byte[]>> staticArgs) throws Exception {\n-        return ldcDynamicConstant(l, name, type, csym(l.lookupClass()), bsmMethodName, bsmType, staticArgs);\n-    }\n-\n-    public static MethodHandle ldcDynamicConstant(MethodHandles.Lookup l,\n-                                                  String name, String type,\n-                                                  String bsmClass, String bsmMethodName, String bsmType,\n-                                                  Consumer<PoolHelper.StaticArgListBuilder<String, String, byte[]>> staticArgs) throws Exception {\n-        return ldc(l, type,\n-                   P -> P.putDynamicConstant(name, type,\n-                                             bsmClass, bsmMethodName, bsmType,\n-                                             staticArgs));\n-    }\n-\n-    public static MethodHandle ldc(MethodHandles.Lookup l,\n-                            Class<?> type,\n-                            Function<PoolHelper<String, String, byte[]>, Integer> poolFunc) throws Exception {\n-        return ldc(l, cref(type), poolFunc);\n-    }\n-\n-    public static MethodHandle ldc(MethodHandles.Lookup l,\n-                                   String type,\n-                                   Function<PoolHelper<String, String, byte[]>, Integer> poolFunc) throws Exception {\n-        String methodType = \"()\" + type;\n-        byte[] byteArray = classBuilder(l)\n-                .withMethod(\"m\", \"()\" + type, M ->\n-                        M.withFlags(Flag.ACC_PUBLIC, Flag.ACC_STATIC)\n-                                .withCode(TypedCodeBuilder::new,\n-                                          C -> {\n-                                              C.ldc(null, (P, v) -> poolFunc.apply(P));\n-                                              C.return_(BTH.tag(type));\n-                                          }\n-                                ))\n-                .build();\n-        Class<?> gc = l.defineClass(byteArray);\n-        return l.findStatic(gc, \"m\", fromMethodDescriptorString(methodType, l.lookupClass().getClassLoader()));\n-    }\n-\n-    public static String csym(Class<?> c) {\n-        return c.getCanonicalName().replace('.', '\/');\n-    }\n-\n-    public static String cref(Class<?> c) {\n-        return methodType(c).toMethodDescriptorString().substring(2);\n-    }\n-\n-\n-    \/\/ loadCode(MethodHandles.Lookup, String, MethodType, Consumer<? super MethodHandleCodeBuilder<?>>) et al...\n-\n-    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n-        String className = generateClassNameFromLookupClass(lookup);\n-        return loadCode(lookup, className, methodName, type, builder);\n-    }\n-\n-    public static MethodHandle loadCode(MethodHandles.Lookup lookup, String className, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n-        String descriptor = type.toMethodDescriptorString();\n-        return loadCode(lookup, className, methodName, descriptor, MethodHandleCodeBuilder::new,\n-                    clazz -> {\n-                        try {\n-                            return lookup.findStatic(clazz, methodName, MethodType.fromMethodDescriptorString(descriptor, lookup.lookupClass().getClassLoader()));\n-                        } catch (ReflectiveOperationException ex) {\n-                            throw new IllegalStateException(ex);\n-                        }\n-                    },\n-                    builder);\n-    }\n-\n-    \/\/ Helper method to load code built with \"buildCode()\"\n-    public static MethodHandle loadCodeBytes(MethodHandles.Lookup lookup, String methodName, MethodType type, byte[] byteCode) {\n-        try {\n-            Class<?> clazz = lookup.defineClass(byteCode);\n-            return lookup.findStatic(clazz, methodName, type);\n-        } catch (Throwable t) {\n-            throw new RuntimeException(\"Failed to loadCodeBytes \\\"\" + methodName + \"\\\"\", t);\n-        }\n-    }\n-\n-\n-    private static <Z, C extends CodeBuilder<Class<?>, String, byte[], ?>> Z loadCode(\n-            MethodHandles.Lookup lookup, String className, String methodName, String type,\n-            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,\n-            Function<Class<?>, Z> resFunc, Consumer<? super C> builder) {\n-        try {\n-            byte[] byteArray = buildCode(lookup, className, methodName, type, builderFunc, builder);\n-            Class<?> clazz = lookup.defineClass(byteArray);\n-            return resFunc.apply(clazz);\n-        } catch (Throwable e) {\n-             throw new IllegalStateException(e);\n-        }\n-    }\n-\n-    public static byte[] buildCode(MethodHandles.Lookup lookup, String methodName, MethodType type, Consumer<? super MethodHandleCodeBuilder<?>> builder) {\n-        String className = generateClassNameFromLookupClass(lookup);\n-        return buildCode(lookup, className, methodName, type.toMethodDescriptorString(), MethodHandleCodeBuilder::new, builder);\n-    }\n-\n-    public static <C extends CodeBuilder<Class<?>, String, byte[], ?>> byte[] buildCode(\n-        MethodHandles.Lookup lookup, String className, String methodName, String type,\n-            Function<MethodBuilder<Class<?>, String, byte[]>, ? extends C> builderFunc,\n-            Consumer<? super C> builder) {\n-\n-                return new IsolatedMethodBuilder(className, lookup)\n-                    .withSuperclass(Object.class)\n-                    .withMajorVersion(66)\n-                    .withMinorVersion(0)\n-                    .withFlags(Flag.ACC_PUBLIC, Flag.ACC_IDENTITY)\n-                    .withMethod(methodName, type, M ->\n-                        M.withFlags(Flag.ACC_STATIC, Flag.ACC_PUBLIC)\n-                            .withCode(builderFunc, builder)).build();\n-\n-    }\n-\n-    private static class IsolatedMethodBuilder extends ClassBuilder<Class<?>, String, IsolatedMethodBuilder> {\n-\n-        private static final Class<?> THIS_CLASS = new Object() { }.getClass();\n-\n-        private IsolatedMethodBuilder(String clazz, MethodHandles.Lookup lookup) {\n-            super(new IsolatedMethodPoolHelper(clazz),\n-                  new IsolatedMethodTypeHelper(lookup));\n-            withThisClass(THIS_CLASS);\n-        }\n-\n-        public Class<?> thisClass() {\n-            return THIS_CLASS;\n-        }\n-\n-        static String classToInternalName(Class<?> c) {\n-            if (c.isArray()) {\n-                return c.descriptorString();\n-            }\n-            return c.getName().replace('.', '\/');\n-        }\n-\n-        private static class IsolatedMethodTypeHelper implements TypeHelper<Class<?>, String> {\n-\n-            BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n-            MethodHandles.Lookup lookup;\n-\n-            private IsolatedMethodTypeHelper(MethodHandles.Lookup lookup) {\n-                this.lookup = lookup;\n-            }\n-\n-            @Override\n-            public String elemtype(String s) {\n-                return basicTypeHelper.elemtype(s);\n-            }\n-\n-            @Override\n-            public String arrayOf(String s) {\n-                return basicTypeHelper.arrayOf(s);\n-            }\n-\n-            @Override\n-            public Iterator<String> parameterTypes(String s) {\n-                return basicTypeHelper.parameterTypes(s);\n-            }\n-\n-            @Override\n-            public String fromTag(TypeTag tag) {\n-                return basicTypeHelper.fromTag(tag);\n-            }\n-\n-            @Override\n-            public String returnType(String s) {\n-                return basicTypeHelper.returnType(s);\n-            }\n-\n-            @Override\n-            public String type(Class<?> aClass) {\n-                return aClass.descriptorString();\n-            }\n-\n-            @Override\n-            public Class<?> symbol(String desc) {\n-                try {\n-                    if (desc.startsWith(\"[\")) {\n-                        return Class.forName(desc.replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n-                    } else {\n-                        return Class.forName(basicTypeHelper.symbol(desc).replaceAll(\"\/\", \".\"), true, lookup.lookupClass().getClassLoader());\n-                    }\n-                } catch (ReflectiveOperationException ex) {\n-                    throw new AssertionError(ex);\n-                }\n-            }\n-\n-            @Override\n-            public TypeTag tag(String s) {\n-                return basicTypeHelper.tag(s);\n-            }\n-\n-            @Override\n-            public Class<?> symbolFrom(String s) {\n-                return symbol(s);\n-            }\n-\n-            @Override\n-            public String commonSupertype(String t1, String t2) {\n-                return basicTypeHelper.commonSupertype(t1, t2);\n-            }\n-\n-            @Override\n-            public String nullType() {\n-                return basicTypeHelper.nullType();\n-            }\n-        }\n-\n-        private static class IsolatedMethodPoolHelper extends BytePoolHelper<Class<?>, String> {\n-            final String clazz;\n-\n-            private IsolatedMethodPoolHelper(String clazz) {\n-                super(c -> from(c, clazz), s->s);\n-                this.clazz = clazz;\n-            }\n-\n-            static String from(Class<?> c, String clazz) {\n-                return c == THIS_CLASS ? clazz.replace('.', '\/')\n-                                       : classToInternalName(c);\n-            }\n-        }\n-\n-        @Override\n-        public byte[] build() {\n-            return super.build();\n-        }\n-    }\n-\n-    public static class MethodHandleCodeBuilder<T extends MethodHandleCodeBuilder<T>> extends TypedCodeBuilder<Class<?>, String, byte[], T> {\n-\n-        BasicTypeHelper basicTypeHelper = new BasicTypeHelper();\n-\n-        public MethodHandleCodeBuilder(jdk.experimental.bytecode.MethodBuilder<Class<?>, String, byte[]> methodBuilder) {\n-            super(methodBuilder);\n-        }\n-\n-        TypeTag getTagType(String s) {\n-            return basicTypeHelper.tag(s);\n-        }\n-\n-        public T ifcmp(String s, CondKind cond, CharSequence label) {\n-            return super.ifcmp(getTagType(s), cond, label);\n-        }\n-\n-        public T return_(String s) {\n-            return super.return_(getTagType(s));\n-        }\n-    }\n-\n-\n-\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/common\/test\/java\/lang\/invoke\/lib\/OldInstructionHelper.java","additions":0,"deletions":369,"binary":false,"changes":369,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-\/**\n- * Base builder.\n- *\n- * @param <S> the type of the symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <E> the type of pool entries\n- * @param <D> the type of this builder\n- *\/\n-public class AbstractBuilder<S, T, E, D extends AbstractBuilder<S, T, E, D>> {\n-    \/**\n-     * The helper to build the constant pool.\n-     *\/\n-    protected final PoolHelper<S, T, E> poolHelper;\n-\n-    \/**\n-     * The helper to use to manipulate type descriptors.\n-     *\/\n-    protected final TypeHelper<S, T> typeHelper;\n-\n-    \/**\n-     * Create a builder.\n-     *\n-     * @param poolHelper the helper to build the constant pool\n-     * @param typeHelper the helper to use to manipulate type descriptors\n-     *\/\n-    AbstractBuilder(PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        this.poolHelper = poolHelper;\n-        this.typeHelper = typeHelper;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    D thisBuilder() {\n-        return (D) this;\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/AbstractBuilder.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,338 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.function.Consumer;\n-import java.util.function.ToIntBiFunction;\n-\n-public class AnnotationsBuilder<S, T, E> extends AbstractBuilder<S, T, E, AnnotationsBuilder<S, T, E>> {\n-\n-    GrowableByteBuffer annoAttribute;\n-    int nannos;\n-\n-    AnnotationsBuilder(PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(poolHelper, typeHelper);\n-        this.annoAttribute = new GrowableByteBuffer();\n-        annoAttribute.writeChar(0);\n-    }\n-\n-    public enum Kind {\n-        RUNTIME_VISIBLE,\n-        RUNTIME_INVISIBLE;\n-    }\n-\n-    enum Tag {\n-        B('B'),\n-        C('C'),\n-        D('D'),\n-        F('F'),\n-        I('I'),\n-        J('J'),\n-        S('S'),\n-        Z('Z'),\n-        STRING('s'),\n-        ENUM('e'),\n-        CLASS('c'),\n-        ANNO('@'),\n-        ARRAY('[');\n-\n-        char tagChar;\n-\n-        Tag(char tagChar) {\n-            this.tagChar = tagChar;\n-        }\n-    }\n-\n-    AnnotationsBuilder<S, T, E> withAnnotation(T annoType, Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-        annoAttribute.writeChar(poolHelper.putType(annoType));\n-        int offset = annoAttribute.offset;\n-        annoAttribute.writeChar(0);\n-        if (annotationBuilder != null) {\n-            AnnotationElementBuilder _builder = new AnnotationElementBuilder();\n-            int nelems = _builder.withElements(annotationBuilder);\n-            patchCharAt(offset, nelems);\n-        }\n-        nannos++;\n-        return this;\n-    }\n-\n-    byte[] build() {\n-        patchCharAt(0, nannos);\n-        return annoAttribute.bytes();\n-    }\n-\n-    private void patchCharAt(int offset, int newChar) {\n-        int prevOffset = annoAttribute.offset;\n-        try {\n-            annoAttribute.offset = offset;\n-            annoAttribute.writeChar(newChar);\n-        } finally {\n-            annoAttribute.offset = prevOffset;\n-        }\n-    }\n-\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    static Consumer NO_BUILDER =\n-            new Consumer() {\n-                @Override\n-                public void accept(Object o) {\n-                    \/\/do nothing\n-                }\n-            };\n-\n-    public class AnnotationElementBuilder {\n-\n-        int nelems;\n-\n-        public AnnotationElementBuilder withString(String name, String s) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writeStringValue(s);\n-            return this;\n-        }\n-\n-        private void writeStringValue(String s) {\n-            annoAttribute.writeByte(Tag.STRING.tagChar);\n-            annoAttribute.writeChar(poolHelper.putUtf8(s));\n-            nelems++;\n-        }\n-\n-        public AnnotationElementBuilder withClass(String name, T s) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writeClassValue(s);\n-            return this;\n-        }\n-\n-        private void writeClassValue(T s) {\n-            annoAttribute.writeByte(Tag.CLASS.tagChar);\n-            annoAttribute.writeChar(poolHelper.putType(s));\n-            nelems++;\n-        }\n-\n-        public AnnotationElementBuilder withEnum(String name, T enumType, int constant) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writeEnumValue(enumType, constant);\n-            return this;\n-        }\n-\n-        private void writeEnumValue(T enumType, int constant) {\n-            annoAttribute.writeByte(Tag.ENUM.tagChar);\n-            annoAttribute.writeChar(poolHelper.putType(enumType));\n-            annoAttribute.writeChar(constant);\n-            nelems++;\n-        }\n-\n-        public AnnotationElementBuilder withAnnotation(String name, T annoType, Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writeAnnotationValue(annoType, annotationBuilder);\n-            return this;\n-        }\n-\n-        private void writeAnnotationValue(T annoType, Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-            annoAttribute.writeByte(Tag.ANNO.tagChar);\n-            annoAttribute.writeChar(poolHelper.putType(annoType));\n-            int offset = annoAttribute.offset;\n-            annoAttribute.writeChar(0);\n-            int nelems = withNestedElements(annotationBuilder);\n-            patchCharAt(offset, nelems);\n-            this.nelems++;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, char c) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.C, (int)c, PoolHelper::putInt);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, short s) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.S, (int)s, PoolHelper::putInt);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, byte b) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.B, (int)b, PoolHelper::putInt);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, int i) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.I, i, PoolHelper::putInt);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, float f) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.F, f, PoolHelper::putFloat);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, long l) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.J, l, PoolHelper::putLong);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, double d) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.D, d, PoolHelper::putDouble);\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitive(String name, boolean b) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            writePrimitiveValue(Tag.Z, b ? 1 : 0, PoolHelper::putInt);\n-            return this;\n-        }\n-\n-        private <Z> void writePrimitiveValue(Tag tag, Z value, ToIntBiFunction<PoolHelper<S, T, E>, Z> poolFunc) {\n-            annoAttribute.writeByte(tag.tagChar);\n-            annoAttribute.writeChar(poolFunc.applyAsInt(poolHelper, value));\n-            nelems++;\n-        }\n-\n-        AnnotationElementBuilder withStrings(String name, String... ss) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(ss.length);\n-            for (String s : ss) {\n-                writeStringValue(s);\n-            }\n-            return this;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        AnnotationElementBuilder withClasses(String name, T... cc) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(cc.length);\n-            for (T c : cc) {\n-                writeClassValue(c);\n-            }\n-            return this;\n-        }\n-\n-        AnnotationElementBuilder withEnums(String name, T enumType, int... constants) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(constants.length);\n-            for (int c : constants) {\n-                writeEnumValue(enumType, c);\n-            }\n-            return this;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public AnnotationElementBuilder withAnnotations(String name, T annoType, Consumer<? super AnnotationElementBuilder>... annotationBuilders) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(annotationBuilders.length);\n-            for (Consumer<? super AnnotationElementBuilder> annotationBuilder : annotationBuilders) {\n-                writeAnnotationValue(annoType, annotationBuilder);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, char... cc) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(cc.length);\n-            for (char c : cc) {\n-                writePrimitiveValue(Tag.C, (int)c, PoolHelper::putInt);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, short... ss) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(ss.length);\n-            for (short s : ss) {\n-                writePrimitiveValue(Tag.S, (int)s, PoolHelper::putInt);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, byte... bb) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(bb.length);\n-            for (byte b : bb) {\n-                writePrimitiveValue(Tag.B, (int)b, PoolHelper::putInt);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, int... ii) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(ii.length);\n-            for (int i : ii) {\n-                writePrimitiveValue(Tag.I, i,  PoolHelper::putInt);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, float... ff) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(ff.length);\n-            for (float f : ff) {\n-                writePrimitiveValue(Tag.F, f, PoolHelper::putFloat);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, long... ll) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(ll.length);\n-            for (long l : ll) {\n-                writePrimitiveValue(Tag.J, l, PoolHelper::putLong);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, double... dd) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(dd.length);\n-            for (double d : dd) {\n-                writePrimitiveValue(Tag.D, d, PoolHelper::putDouble);\n-            }\n-            return this;\n-        }\n-\n-        public AnnotationElementBuilder withPrimitives(String name, boolean... bb) {\n-            annoAttribute.writeChar(poolHelper.putUtf8(name));\n-            annoAttribute.writeChar(bb.length);\n-            for (boolean b : bb) {\n-                writePrimitiveValue(Tag.Z, b ? 1 : 0, PoolHelper::putInt);\n-            }\n-            return this;\n-        }\n-\n-        int withNestedElements(Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-            return withElements(new AnnotationElementBuilder(), annotationBuilder);\n-        }\n-\n-        int withElements(Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-            return withElements(this, annotationBuilder);\n-        }\n-\n-        private int withElements(AnnotationElementBuilder builder, Consumer<? super AnnotationElementBuilder> annotationBuilder) {\n-            annotationBuilder.accept(builder);\n-            return builder.nelems;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/AnnotationsBuilder.java","additions":0,"deletions":338,"binary":false,"changes":338,"status":"deleted"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-\/**\n- * Base builder for attribute containing class file entities.\n- *\n- * @param <S> the type of the symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <E> the type of pool entries\n- * @param <D> the type of this builder\n- *\/\n- public class AttributeBuilder<S, T, E, D extends AttributeBuilder<S, T, E, D>>\n-        extends AbstractBuilder<S, T, E, D> {\n-\n-     \/**\n-      * The number of attributes.\n-      *\/\n-    protected int nattrs;\n-\n-    \/**\n-     * The attributes represented as bytes.\n-     *\/\n-    protected GrowableByteBuffer attributes = new GrowableByteBuffer();\n-\n-    \/**\n-     * Create an attribute builder.\n-     *\n-     * @param poolHelper the helper to build the constant pool\n-     * @param typeHelper the helper to use to manipulate type descriptors\n-     *\/\n-    public AttributeBuilder(PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(poolHelper, typeHelper);\n-    }\n-\n-    \/**\n-     * Add a class file Attribute.  Defined as:\n-     * <pre>\n-     * {@code   attribute_info {\n-     *     u2 attribute_name_index;\n-     *     u4 attribute_length;\n-     *     u1 info[attribute_length];\n-     *   }}\n-     * <\/pre>\n-     *\n-     * @param name the attribute name\n-     * @param bytes the bytes of the attribute info\n-     * @return this builder, for chained calls\n-     *\/\n-    public D withAttribute(CharSequence name, byte[] bytes) {\n-        attributes.writeChar(poolHelper.putUtf8(name));\n-        attributes.writeInt(bytes.length);\n-        attributes.writeBytes(bytes);\n-        nattrs++;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Add a class file Attribute, using a writer.  Defined as:\n-     * <pre>\n-     * {@code   attribute_info {\n-     *     u2 attribute_name_index;\n-     *     u4 attribute_length;\n-     *     u1 info[attribute_length];\n-     *   }}\n-     * <\/pre>\n-     *\n-     * @param <Z> the type of the object representing the attribute\n-     * @param name the attribute name\n-     * @param attr the representation of the attribute\n-     * @param attrWriter the writer which transform the attribute representation into bytes\n-     * @return this builder, for chained calls\n-     *\/\n-    public <Z> D withAttribute(CharSequence name, Z attr, AttributeWriter<S, T, E, Z> attrWriter) {\n-        attributes.writeChar(poolHelper.putUtf8(name));\n-        int offset = attributes.offset;\n-        attributes.writeInt(0);\n-        attrWriter.write(attr, poolHelper, attributes);\n-        int len = attributes.offset - offset - 4;\n-        attributes.withOffset(offset, buf -> buf.writeInt(len));\n-        nattrs++;\n-        return thisBuilder();\n-    }\n-\n-     \/**\n-      * Writer for transforming attribute representations to bytes\n-      *\n-      * @param <S> the type of symbol representation\n-      * @param <T> the type of type descriptors representation\n-      * @param <E> the type of pool entries\n-      * @param <A> the type of the object representing the attribute\n-      *\/\n-    public interface AttributeWriter<S, T, E, A> {\n-\n-        \/**\n-         * Write an attribute representation into a byte buffer.\n-         *\n-         * @param attr the representation of the attribute\n-         * @param poolHelper the constant pool helper\n-         * @param buf the buffer to collect the bytes\n-         *\/\n-        void write(A attr, PoolHelper<S, T, E> poolHelper, GrowableByteBuffer buf);\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/AttributeBuilder.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-public class BasicClassBuilder extends ClassBuilder<String, String, BasicClassBuilder> {\n-\n-    public BasicClassBuilder(String thisClass, int majorVersion, int minorVersion) {\n-        this();\n-        withMinorVersion(minorVersion);\n-        withMajorVersion(majorVersion);\n-        withThisClass(thisClass);\n-    }\n-\n-    public BasicClassBuilder(BytePoolHelper<String, String> poolHelper, TypeHelper<String, String> typeHelper) {\n-        super(poolHelper, typeHelper);\n-    }\n-\n-    public BasicClassBuilder() {\n-        super(new BytePoolHelper<>(s->s, s->s), new BasicTypeHelper());\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/BasicClassBuilder.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,182 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.Iterator;\n-\n-\/**\n- * Helper to create and manipulate type descriptors, where type descriptors\n- * are represented as JVM type descriptor strings and symbols are represented\n- * as name strings\n- *\/\n-public class BasicTypeHelper implements TypeHelper<String, String> {\n-\n-    @Override\n-    public String elemtype(String s) {\n-        if (!s.startsWith(\"[\")) {\n-            throw new IllegalStateException();\n-        }\n-        return s.substring(1);\n-    }\n-\n-    @Override\n-    public String arrayOf(String s) {\n-        return \"[\" + s;\n-    }\n-\n-    @Override\n-    public String type(String s) {\n-        return \"L\" + s + \";\";\n-    }\n-\n-\n-    @Override\n-    public TypeTag tag(String s) {\n-        switch (s.charAt(0)) {\n-            case '[':\n-            case 'L':\n-                return TypeTag.A;\n-            case 'B':\n-            case 'C':\n-            case 'Z':\n-            case 'S':\n-            case 'I':\n-                return TypeTag.I;\n-            case 'F':\n-                return TypeTag.F;\n-            case 'J':\n-                return TypeTag.J;\n-            case 'D':\n-                return TypeTag.D;\n-            case 'V':\n-                return TypeTag.V;\n-            default:\n-                if (s == nullType()) {\n-                    return TypeTag.A;\n-                }\n-                throw new IllegalStateException(\"Bad type: \" + s);\n-        }\n-    }\n-\n-    @Override\n-    public String nullType() {\n-        \/\/ Needed in TypedCodeBuilder; ACONST_NULL pushes a 'null' onto the stack,\n-        \/\/ and stack maps handle null differently\n-        return \"<null>\";\n-    }\n-\n-    @Override\n-    public String commonSupertype(String t1, String t2) {\n-        if (t1.equals(t2)) {\n-            return t1;\n-        } else {\n-            try {\n-                Class<?> c1 = from(t1);\n-                Class<?> c2 = from(t2);\n-                if (c1.isAssignableFrom(c2)) {\n-                    return t1;\n-                } else if (c2.isAssignableFrom(c1)) {\n-                    return t2;\n-                } else {\n-                    return \"Ljava\/lang\/Object;\";\n-                }\n-            } catch (Exception e) {\n-                return null;\n-            }\n-        }\n-    }\n-\n-    public Class<?> from(String desc) throws ReflectiveOperationException {\n-        if (desc.startsWith(\"[\")) {\n-            return Class.forName(desc.replaceAll(\"\/\", \".\"));\n-        } else {\n-            return Class.forName(symbol(desc).replaceAll(\"\/\", \".\"));\n-        }\n-    }\n-\n-    @Override\n-    public Iterator<String> parameterTypes(String s) {\n-        \/\/TODO: gracefully non-method types\n-        return new Iterator<String>() {\n-            int ch = 1;\n-\n-            @Override\n-            public boolean hasNext() {\n-                return s.charAt(ch) != ')';\n-            }\n-\n-            @Override\n-            public String next() {\n-                char curr = s.charAt(ch);\n-                switch (curr) {\n-                    case 'C':\n-                    case 'B':\n-                    case 'S':\n-                    case 'I':\n-                    case 'J':\n-                    case 'F':\n-                    case 'D':\n-                    case 'Z':\n-                        ch++;\n-                        return String.valueOf(curr);\n-                    case '[':\n-                        ch++;\n-                        return \"[\" + next();\n-                    case 'L':\n-                        StringBuilder builder = new StringBuilder();\n-                        while (curr != ';') {\n-                            builder.append(curr);\n-                            curr = s.charAt(++ch);\n-                        }\n-                        builder.append(';');\n-                        ch++;\n-                        return builder.toString();\n-                    default:\n-                        throw new AssertionError(\"cannot parse string: \" + s);\n-                }\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public String symbolFrom(String s) {\n-        return s;\n-    }\n-\n-    @Override\n-    public String fromTag(TypeTag tag) {\n-        return tag.name();\n-    }\n-\n-    @Override\n-    public String symbol(String type) {\n-        return (type.startsWith(\"L\") || type.startsWith(\"Q\")) ? type.substring(1, type.length() - 1) : type;\n-    }\n-\n-    @Override\n-    public String returnType(String s) {\n-        return s.substring(s.indexOf(')') + 1, s.length());\n-    }\n-\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/BasicTypeHelper.java","additions":0,"deletions":182,"binary":false,"changes":182,"status":"deleted"},{"patch":"@@ -1,758 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.lang.invoke.MethodHandleInfo;\n-import java.lang.invoke.MethodType;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.ToIntBiFunction;\n-\n-\/**\n- * A helper for building and tracking constant pools whose entries are\n- * represented as byte arrays.\n- *\n- * @param <S> the type of the symbol representation\n- * @param <T> the type of type descriptors representation\n- *\/\n-public class BytePoolHelper<S, T> implements PoolHelper<S, T, byte[]> {\n-\n-    GrowableByteBuffer pool = new GrowableByteBuffer();\n-    GrowableByteBuffer bsm_attr = new GrowableByteBuffer();\n-    \/\/Map<PoolKey, PoolKey> indicesMap = new HashMap<>();\n-    int currentIndex = 1;\n-    int currentBsmIndex = 0;\n-\n-    KeyMap<PoolKey> entries = new KeyMap<>();\n-    KeyMap<BsmKey> bootstraps = new KeyMap<>();\n-    PoolKey key = new PoolKey();\n-    BsmKey bsmKey = new BsmKey();\n-\n-    Function<S, String> symbolToString;\n-    Function<T, String> typeToString;\n-\n-    public BytePoolHelper(Function<S, String> symbolToString, Function<T, String> typeToString) {\n-        this.symbolToString = symbolToString;\n-        this.typeToString = typeToString;\n-    }\n-\n-    static class KeyMap<K extends AbstractKey<K>> {\n-\n-        @SuppressWarnings(\"unchecked\")\n-        K[] table = (K[])new AbstractKey<?>[0x10];\n-        int nelems;\n-\n-        public void enter(K e) {\n-            if (nelems * 3 >= (table.length - 1) * 2)\n-                dble();\n-            int hash = getIndex(e);\n-            K old = table[hash];\n-            if (old == null) {\n-                nelems++;\n-            }\n-            e.next = old;\n-            table[hash] = e;\n-        }\n-\n-        protected K lookup(K other) {\n-            K e = table[getIndex(other)];\n-            while (e != null && !e.equals(other))\n-                e = e.next;\n-            return e;\n-        }\n-\n-        \/**\n-         * Look for slot in the table.\n-         * We use open addressing with double hashing.\n-         *\/\n-        int getIndex(K e) {\n-            int hashMask = table.length - 1;\n-            int h = e.hashCode();\n-            int i = h & hashMask;\n-            \/\/ The expression below is always odd, so it is guaranteed\n-            \/\/ to be mutually prime with table.length, a power of 2.\n-            int x = hashMask - ((h + (h >> 16)) << 1);\n-            for (; ; ) {\n-                K e2 = table[i];\n-                if (e2 == null)\n-                    return i;\n-                else if (e.hash == e2.hash)\n-                    return i;\n-                i = (i + x) & hashMask;\n-            }\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        private void dble() {\n-            K[] oldtable = table;\n-            table = (K[])new AbstractKey<?>[oldtable.length * 2];\n-            int n = 0;\n-            for (int i = oldtable.length; --i >= 0; ) {\n-                K e = oldtable[i];\n-                if (e != null) {\n-                    table[getIndex(e)] = e;\n-                    n++;\n-                }\n-            }\n-            \/\/ We don't need to update nelems for shared inherited scopes,\n-            \/\/ since that gets handled by leave().\n-            nelems = n;\n-        }\n-    }\n-\n-    public static abstract class AbstractKey<K extends AbstractKey<K>> {\n-        int hash;\n-        int index = -1;\n-        K next;\n-\n-        abstract K dup();\n-\n-        public abstract boolean equals(Object o);\n-\n-        @Override\n-        public int hashCode() {\n-            return hash;\n-        }\n-\n-        void at(int index) {\n-            this.index = index;\n-        }\n-    }\n-\n-    public static class PoolKey extends AbstractKey<PoolKey> {\n-        PoolTag tag;\n-        Object o1;\n-        Object o2;\n-        Object o3;\n-        Object o4;\n-        int size = -1;\n-\n-        void setUtf8(CharSequence s) {\n-            tag = PoolTag.CONSTANT_UTF8;\n-            o1 = s;\n-            size = 1;\n-            hash = tag.tag | (s.hashCode() << 1);\n-        }\n-\n-        void setClass(String clazz) {\n-            tag = PoolTag.CONSTANT_CLASS;\n-            o1 = clazz;\n-            size = 1;\n-            hash = tag.tag | (clazz.hashCode() << 1);\n-        }\n-\n-        void setNameAndType(CharSequence name, String type) {\n-            tag = PoolTag.CONSTANT_NAMEANDTYPE;\n-            o1 = name;\n-            o2 = type;\n-            size = 2;\n-            hash = tag.tag | ((name.hashCode() | type.hashCode()) << 1);\n-        }\n-\n-        void setMemberRef(PoolTag poolTag, String owner, CharSequence name, String type) {\n-            tag = poolTag;\n-            o1 = owner;\n-            o2 = name;\n-            o3 = type;\n-            size = 3;\n-            hash = tag.tag | ((owner.hashCode() | name.hashCode() | type.hashCode()) << 1);\n-        }\n-\n-        void setInvokeDynamic(int bsmIndex, CharSequence name, String type) {\n-            tag = PoolTag.CONSTANT_INVOKEDYNAMIC;\n-            o1 = bsmIndex;\n-            o2 = name;\n-            o3 = type;\n-            size = 3;\n-            hash = tag.tag | ((bsmIndex | name.hashCode() | type.hashCode()) << 1);\n-        }\n-\n-        void setDynamicConstant(int bsmIndex, CharSequence name, String type) {\n-            tag = PoolTag.CONSTANT_DYNAMIC;\n-            o1 = bsmIndex;\n-            o2 = name;\n-            o3 = type;\n-            size = 3;\n-            hash = tag.tag | ((bsmIndex | name.hashCode() | type.hashCode()) << 1);\n-        }\n-\n-        void setString(String s) {\n-            tag = PoolTag.CONSTANT_STRING;\n-            o1 = s;\n-            size = 1;\n-            hash = tag.tag | (s.hashCode() << 1);\n-        }\n-\n-        void setInteger(Integer i) {\n-            tag = PoolTag.CONSTANT_INTEGER;\n-            o1 = i;\n-            size = 1;\n-            hash = tag.tag | (i.hashCode() << 1);\n-        }\n-\n-        void setFloat(Float f) {\n-            tag = PoolTag.CONSTANT_FLOAT;\n-            o1 = f;\n-            size = 1;\n-            hash = tag.tag | (f.hashCode() << 1);\n-        }\n-\n-        void setLong(Long l) {\n-            tag = PoolTag.CONSTANT_LONG;\n-            o1 = l;\n-            size = 1;\n-            hash = tag.tag | (l.hashCode() << 1);\n-        }\n-\n-        void setDouble(Double d) {\n-            tag = PoolTag.CONSTANT_DOUBLE;\n-            o1 = d;\n-            size = 1;\n-            hash = tag.tag | (d.hashCode() << 1);\n-        }\n-\n-        void setMethodType(String type) {\n-            tag = PoolTag.CONSTANT_METHODTYPE;\n-            o1 = type;\n-            size = 1;\n-            hash = tag.tag | (type.hashCode() << 1);\n-        }\n-\n-        void setMethodHandle(int bsmKind, String owner, CharSequence name, String type) {\n-            tag = PoolTag.CONSTANT_METHODHANDLE;\n-            o1 = bsmKind;\n-            o2 = owner;\n-            o3 = name;\n-            o4 = type;\n-            size = 4;\n-            hash = tag.tag | (bsmKind | owner.hashCode() | name.hashCode() | type.hashCode() << 1);\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            PoolKey that = (PoolKey) obj;\n-            if (tag != that.tag) return false;\n-            switch (size) {\n-                case 1:\n-                    if (!o1.equals(that.o1)) {\n-                        return false;\n-                    }\n-                    break;\n-                case 2:\n-                    if (!o2.equals(that.o2) || !o1.equals(that.o1)) {\n-                        return false;\n-                    }\n-                    break;\n-                case 3:\n-                    if (!o3.equals(that.o3) || !o2.equals(that.o2) || !o1.equals(that.o1)) {\n-                        return false;\n-                    }\n-                    break;\n-                case 4:\n-                    if (!o4.equals(that.o4) || !o3.equals(that.o3) || !o2.equals(that.o2) || !o1.equals(that.o1)) {\n-                        return false;\n-                    }\n-                    break;\n-            }\n-            return true;\n-        }\n-\n-        PoolKey dup() {\n-            PoolKey poolKey = new PoolKey();\n-            poolKey.tag = tag;\n-            poolKey.size = size;\n-            poolKey.hash = hash;\n-            poolKey.o1 = o1;\n-            poolKey.o2 = o2;\n-            poolKey.o3 = o3;\n-            poolKey.o4 = o4;\n-            return poolKey;\n-        }\n-    }\n-\n-    static class BsmKey extends AbstractKey<BsmKey> {\n-        String bsmClass;\n-        CharSequence bsmName;\n-        String bsmType;\n-        List<Integer> bsmArgs;\n-\n-        void set(String bsmClass, CharSequence bsmName, String bsmType, List<Integer> bsmArgs) {\n-            this.bsmClass = bsmClass;\n-            this.bsmName = bsmName;\n-            this.bsmType = bsmType;\n-            this.bsmArgs = bsmArgs;\n-            hash = bsmClass.hashCode() | bsmName.hashCode() | bsmType.hashCode() | Objects.hash(bsmArgs);\n-        }\n-\n-        BsmKey dup() {\n-            BsmKey bsmKey = new BsmKey();\n-            bsmKey.bsmClass = bsmClass;\n-            bsmKey.bsmName = bsmName;\n-            bsmKey.bsmType = bsmType;\n-            bsmKey.bsmArgs = bsmArgs;\n-            bsmKey.hash = hash;\n-            return bsmKey;\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (obj instanceof BsmKey) {\n-                BsmKey that = (BsmKey)obj;\n-                return Objects.equals(bsmClass, that.bsmClass) &&\n-                        Objects.equals(bsmName, that.bsmName) &&\n-                        Objects.equals(bsmType, that.bsmType) &&\n-                        Objects.deepEquals(bsmArgs, that.bsmArgs);\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public int putClass(S symbol) {\n-        return putClassInternal(symbolToString.apply(symbol));\n-    }\n-\n-    @Override\n-    public int putInlineClass(S symbol) {\n-        return putClassInternal(\"Q\" + symbolToString.apply(symbol) + \";\");\n-    }\n-\n-    private int putClassInternal(String symbol) {\n-        key.setClass(symbol);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int utf8_idx = putUtf8(symbol);\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_CLASS.tag);\n-            pool.writeChar(utf8_idx);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putFieldRef(S owner, CharSequence name, T type) {\n-        return putMemberRef(PoolTag.CONSTANT_FIELDREF, owner, name, type);\n-    }\n-\n-    @Override\n-    public int putMethodRef(S owner, CharSequence name, T type, boolean isInterface) {\n-        return putMemberRef(isInterface ? PoolTag.CONSTANT_INTERFACEMETHODREF : PoolTag.CONSTANT_METHODREF,\n-                owner, name, type);\n-    }\n-\n-    int putMemberRef(PoolTag poolTag, S owner, CharSequence name, T type) {\n-        return putMemberRefInternal(poolTag, symbolToString.apply(owner), name, typeToString.apply(type));\n-    }\n-\n-    int putMemberRefInternal(PoolTag poolTag, String owner, CharSequence name, String type) {\n-        key.setMemberRef(poolTag, owner, name, type);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int owner_idx = putClassInternal(owner);\n-            int nameAndType_idx = putNameAndType(name, type);\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(poolTag.tag);\n-            pool.writeChar(owner_idx);\n-            pool.writeChar(nameAndType_idx);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putInt(int i) {\n-        key.setInteger(i);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_INTEGER.tag);\n-            pool.writeInt(i);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putFloat(float f) {\n-        key.setFloat(f);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_FLOAT.tag);\n-            pool.writeFloat(f);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putLong(long l) {\n-        key.setLong(l);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_LONG.tag);\n-            pool.writeLong(l);\n-            currentIndex++;\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putDouble(double d) {\n-        key.setDouble(d);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_DOUBLE.tag);\n-            pool.writeDouble(d);\n-            currentIndex++;\n-        }\n-        return poolKey.index;\n-    }\n-\n-\n-    @Override\n-    public int putInvokeDynamic(CharSequence invokedName, T invokedType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-        return putInvokeDynamicInternal(invokedName, typeToString.apply(invokedType), symbolToString.apply(bsmClass), bsmName, typeToString.apply(bsmType), staticArgs);\n-    }\n-\n-    @Override\n-    public int putDynamicConstant(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-        return putDynamicConstantInternal(constName, typeToString.apply(constType), symbolToString.apply(bsmClass), bsmName, typeToString.apply(bsmType), staticArgs);\n-    }\n-\n-    private int putInvokeDynamicInternal(CharSequence invokedName, String invokedType, String bsmClass, CharSequence bsmName, String bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-        int bsmIndex = putBsmInternal(bsmClass, bsmName, bsmType, staticArgs);\n-        key.setInvokeDynamic(bsmIndex, invokedName, invokedType);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int nameAndType_idx = putNameAndType(invokedName, invokedType);\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_INVOKEDYNAMIC.tag);\n-            pool.writeChar(bsmIndex);\n-            pool.writeChar(nameAndType_idx);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    private int putDynamicConstantInternal(CharSequence constName, String constType, String bsmClass, CharSequence bsmName, String bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-        int bsmIndex = putBsmInternal(bsmClass, bsmName, bsmType, staticArgs);\n-        key.setDynamicConstant(bsmIndex, constName, constType);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int nameAndType_idx = putNameAndType(constName, constType);\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_DYNAMIC.tag);\n-            pool.writeChar(bsmIndex);\n-            pool.writeChar(nameAndType_idx);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    private int putBsmInternal(String bsmClass, CharSequence bsmName, String bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-        ByteStaticArgListBuilder staticArgsBuilder = new ByteStaticArgListBuilder();\n-        staticArgs.accept(staticArgsBuilder);\n-        List<Integer> static_idxs = staticArgsBuilder.indexes;\n-        bsmKey.set(bsmClass, bsmName, bsmType, static_idxs);\n-        BsmKey poolKey = bootstraps.lookup(bsmKey);\n-        if (poolKey == null) {\n-            poolKey = bsmKey.dup();\n-            \/\/ TODO the BSM could be a static method on an interface\n-            int bsm_ref = putHandleInternal(MethodHandleInfo.REF_invokeStatic, bsmClass, bsmName, bsmType, false);\n-            poolKey.at(currentBsmIndex++);\n-            bootstraps.enter(poolKey);\n-            bsm_attr.writeChar(bsm_ref);\n-            bsm_attr.writeChar(static_idxs.size());\n-            for (int i : static_idxs) {\n-                bsm_attr.writeChar(i);\n-            }\n-        }\n-        return poolKey.index;\n-    }\n-    \/\/where\n-        class ByteStaticArgListBuilder implements StaticArgListBuilder<S, T, byte[]> {\n-\n-            List<Integer> indexes = new ArrayList<>();\n-\n-            public ByteStaticArgListBuilder add(int i) {\n-                indexes.add(putInt(i));\n-                return this;\n-            }\n-            public ByteStaticArgListBuilder add(float f) {\n-                indexes.add(putFloat(f));\n-                return this;\n-            }\n-            public ByteStaticArgListBuilder add(long l) {\n-                indexes.add(putLong(l));\n-                return this;\n-            }\n-            public ByteStaticArgListBuilder add(double d) {\n-                indexes.add(putDouble(d));\n-                return this;\n-            }\n-            public ByteStaticArgListBuilder add(String s) {\n-                indexes.add(putString(s));\n-                return this;\n-            }\n-            @Override\n-            public StaticArgListBuilder<S, T, byte[]> add(int refKind, S owner, CharSequence name, T type) {\n-                indexes.add(putHandle(refKind, owner, name, type));\n-                return this;\n-            }\n-            public <Z> ByteStaticArgListBuilder add(Z z, ToIntBiFunction<PoolHelper<S, T, byte[]>, Z> poolFunc) {\n-                indexes.add(poolFunc.applyAsInt(BytePoolHelper.this, z));\n-                return this;\n-            }\n-            public ByteStaticArgListBuilder add(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, byte[]>> staticArgs) {\n-                indexes.add(putDynamicConstant(constName, constType, bsmClass, bsmName, bsmType, staticArgs));\n-                return this;\n-            }\n-        }\n-\n-    @Override\n-    public int putMethodType(T s) {\n-        return putMethodTypeInternal(typeToString.apply(s));\n-    }\n-\n-    private int putMethodTypeInternal(String s) {\n-        key.setMethodType(s);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int desc_idx = putUtf8(s);\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_METHODTYPE.tag);\n-            pool.writeChar(desc_idx);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int putHandle(int refKind, S owner, CharSequence name, T type) {\n-        return putHandleInternal(refKind, symbolToString.apply(owner), name, typeToString.apply(type), false);\n-    }\n-\n-    @Override\n-    public int putHandle(int refKind, S owner, CharSequence name, T type, boolean isInterface) {\n-        return putHandleInternal(refKind, symbolToString.apply(owner), name, typeToString.apply(type), isInterface);\n-    }\n-\n-    private int putHandleInternal(int refKind, String owner, CharSequence name, String type, boolean isInterface) {\n-        key.setMethodHandle(refKind, owner, name, type);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int ref_idx = putMemberRefInternal(fromKind(refKind, isInterface), owner, name, type);\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_METHODHANDLE.tag);\n-            pool.writeByte(refKind);\n-            pool.writeChar(ref_idx);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    PoolTag fromKind(int bsmKind, boolean isInterface) {\n-        switch (bsmKind) {\n-            case 1: \/\/ REF_getField\n-            case 2: \/\/ REF_getStatic\n-            case 3: \/\/ REF_putField\n-            case 4: \/\/ REF_putStatic\n-                return PoolTag.CONSTANT_FIELDREF;\n-            case 5: \/\/ REF_invokeVirtual\n-            case 6: \/\/ REF_invokeStatic\n-            case 7: \/\/ REF_invokeSpecial\n-            case 8: \/\/ REF_newInvokeSpecial\n-            case 9: \/\/ REF_invokeInterface\n-                return isInterface ? PoolTag.CONSTANT_INTERFACEMETHODREF : PoolTag.CONSTANT_METHODREF;\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    @Override\n-    public int putType(T s) {\n-        return putUtf8(typeToString.apply(s));\n-    }\n-\n-    public int putUtf8(CharSequence s) {\n-        key.setUtf8(s);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_UTF8.tag);\n-            putUTF8Internal(s);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    \/**\n-     * Puts an UTF8 string into this byte vector. The byte vector is\n-     * automatically enlarged if necessary.\n-     *\n-     * @param s a String whose UTF8 encoded length must be less than 65536.\n-     * @return this byte vector.\n-     *\/\n-    void putUTF8Internal(final CharSequence s) {\n-        int charLength = s.length();\n-        if (charLength > 65535) {\n-            throw new IllegalArgumentException();\n-        }\n-        \/\/ optimistic algorithm: instead of computing the byte length and then\n-        \/\/ serializing the string (which requires two loops), we assume the byte\n-        \/\/ length is equal to char length (which is the most frequent case), and\n-        \/\/ we start serializing the string right away. During the serialization,\n-        \/\/ if we find that this assumption is wrong, we continue with the\n-        \/\/ general method.\n-        pool.writeChar(charLength);\n-        for (int i = 0; i < charLength; ++i) {\n-            char c = s.charAt(i);\n-            if (c >= '\\001' && c <= '\\177') {\n-                pool.writeByte((byte) c);\n-            } else {\n-                encodeUTF8(s, i, 65535);\n-                break;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Puts an UTF8 string into this byte vector. The byte vector is\n-     * automatically enlarged if necessary. The string length is encoded in two\n-     * bytes before the encoded characters, if there is space for that (i.e. if\n-     * this.length - i - 2 >= 0).\n-     *\n-     * @param s             the String to encode.\n-     * @param i             the index of the first character to encode. The previous\n-     *                      characters are supposed to have already been encoded, using\n-     *                      only one byte per character.\n-     * @param maxByteLength the maximum byte length of the encoded string, including the\n-     *                      already encoded characters.\n-     * @return this byte vector.\n-     *\/\n-    void encodeUTF8(final CharSequence s, int i, int maxByteLength) {\n-        int charLength = s.length();\n-        int byteLength = i;\n-        char c;\n-        for (int j = i; j < charLength; ++j) {\n-            c = s.charAt(j);\n-            if (c >= '\\001' && c <= '\\177') {\n-                byteLength++;\n-            } else if (c > '\\u07FF') {\n-                byteLength += 3;\n-            } else {\n-                byteLength += 2;\n-            }\n-        }\n-        if (byteLength > maxByteLength) {\n-            throw new IllegalArgumentException();\n-        }\n-        int byteLengthFinal = byteLength;\n-        pool.withOffset(pool.offset - i - 2, buf -> buf.writeChar(byteLengthFinal));\n-        for (int j = i; j < charLength; ++j) {\n-            c = s.charAt(j);\n-            if (c >= '\\001' && c <= '\\177') {\n-                pool.writeChar((byte) c);\n-            } else if (c > '\\u07FF') {\n-                pool.writeChar((byte) (0xE0 | c >> 12 & 0xF));\n-                pool.writeChar((byte) (0x80 | c >> 6 & 0x3F));\n-                pool.writeChar((byte) (0x80 | c & 0x3F));\n-            } else {\n-                pool.writeChar((byte) (0xC0 | c >> 6 & 0x1F));\n-                pool.writeChar((byte) (0x80 | c & 0x3F));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public int putString(String s) {\n-        key.setString(s);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int utf8_index = putUtf8(s);\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_STRING.tag);\n-            pool.writeChar(utf8_index);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    int putNameAndType(CharSequence name, String type) {\n-        key.setNameAndType(name, type);\n-        PoolKey poolKey = entries.lookup(key);\n-        if (poolKey == null) {\n-            poolKey = key.dup();\n-            int name_idx = putUtf8(name);\n-            int type_idx = putUtf8(type);\n-            poolKey.at(currentIndex++);\n-            entries.enter(poolKey);\n-            pool.writeByte(PoolTag.CONSTANT_NAMEANDTYPE.tag);\n-            pool.writeChar(name_idx);\n-            pool.writeChar(type_idx);\n-        }\n-        return poolKey.index;\n-    }\n-\n-    @Override\n-    public int size() {\n-        return currentIndex - 1;\n-    }\n-\n-    @Override\n-    public byte[] entries() {\n-        return pool.bytes();\n-    }\n-\n-    <Z extends ClassBuilder<S, T, Z>> void addAttributes(ClassBuilder<S , T, Z> cb) {\n-        if (currentBsmIndex > 0) {\n-            GrowableByteBuffer bsmAttrBuf = new GrowableByteBuffer();\n-            bsmAttrBuf.writeChar(currentBsmIndex);\n-            bsmAttrBuf.writeBytes(bsm_attr);\n-            cb.withAttribute(\"BootstrapMethods\", bsmAttrBuf.bytes());\n-        }\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/BytePoolHelper.java","additions":0,"deletions":758,"binary":false,"changes":758,"status":"deleted"},{"patch":"@@ -1,240 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.function.Consumer;\n-\n-\/**\n- * Base class builder. The base of higher level class builders.\n- *\n- * @param <S> the type of symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <C> the type of this builder\n- *\/\n-public class ClassBuilder<S, T, C extends ClassBuilder<S, T, C>>\n-        extends DeclBuilder<S, T, byte[], C> {\n-\n-    \/**\n-     * The helper to use to manipulate type descriptors.\n-     *\/\n-    protected TypeHelper<S, T> typeHelper;\n-\n-    \/**\n-     * The symbol for the class being built.\n-     *\/\n-    protected S thisClass;\n-\n-    \/**\n-     * The super-interfaces of the class being built..\n-     *\/\n-    protected GrowableByteBuffer interfaces = new GrowableByteBuffer();\n-\n-    \/**\n-     * The fields of the class being built.\n-     *\/\n-    protected GrowableByteBuffer fields = new GrowableByteBuffer();\n-\n-    \/**\n-     * The methods of the class being built.\n-     *\/\n-    protected GrowableByteBuffer methods = new GrowableByteBuffer();\n-\n-    int majorVersion;\n-    int minorVersion;\n-    int flags;\n-    int superclass;\n-    int nmethods, nfields, ninterfaces;\n-\n-    \/**\n-     * Create a class builder.\n-     *\n-     * @param poolHelper the helper to build the constant pool\n-     * @param typeHelper the helper to use to manipulate type descriptors\n-     *\/\n-    public ClassBuilder(BytePoolHelper<S, T> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(poolHelper, typeHelper);\n-        this.typeHelper = typeHelper;\n-    }\n-\n-    \/**\n-     * Set the minor class file version.\n-     *\n-     * @param minorVersion the minor version number\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withMinorVersion(int minorVersion) {\n-        this.minorVersion = minorVersion;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Set the major class file version.\n-     *\n-     * @param majorVersion the major version number\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withMajorVersion(int majorVersion) {\n-        this.majorVersion = majorVersion;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Set the class symbol\n-     *\n-     * @param thisClass the class symbol\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withThisClass(S thisClass) {\n-        this.thisClass = thisClass;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Set the class access flags\n-     *\n-     * @param flags an array of {@code Flag}\n-     * @return this builder, for chained calls\n-     *\/\n-    @Override\n-    public C withFlags(Flag... flags) {\n-        for (Flag f : flags) {\n-            this.flags |= f.flag;\n-        }\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Set the superclass\n-     *\n-     * @param sup the superclass symbol\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withSuperclass(S sup) {\n-        this.superclass = poolHelper.putClass(sup);\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Add a super interface.\n-     *\n-     * @param sup an interface symbol\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withSuperinterface(S sup) {\n-        this.interfaces.writeChar(poolHelper.putClass(sup));\n-        ninterfaces++;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Add a field.\n-     *\n-     * @param name the name of the field\n-     * @param type the type descriptor of the field\n-     * @return this builder, for chained calls\n-     *\/\n-    public final C withField(CharSequence name, T type) {\n-        return withField(name, type, FB -> {\n-        });\n-    }\n-\n-    \/**\n-     * Add a field.\n-     *\n-     * @param name the name of the field\n-     * @param type the type descriptor of the field\n-     * @param fieldConfig access to the {@code FieldBuilder} to allow clients to\n-     * adjust flags, annotations and bytecode attributes on the field declaration\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withField(CharSequence name, T type, Consumer<? super FieldBuilder<S, T, byte[]>> fieldConfig) {\n-        FieldBuilder<S, T, byte[]> F = new FieldBuilder<>(name, type, poolHelper, typeHelper);\n-        fieldConfig.accept(F);\n-        F.build(fields);\n-        nfields++;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Add a method\n-     *\n-     * @param name the name of the method\n-     * @param type the type descriptor of the method\n-     * @return this builder, for chained calls\n-     *\/\n-    public final C withMethod(CharSequence name, T type) {\n-        return withMethod(name, type, MB -> {\n-        });\n-    }\n-\n-    \/**\n-     * Add a method\n-     *\n-     * @param name the name of the method\n-     * @param type the type descriptor of the method\n-     * @param methodConfig access to the {@code MethodBuilder} to allow clients to\n-     * adjust flags, annotations and bytecode attributes on the method declaration\n-     * @return this builder, for chained calls\n-     *\/\n-    public C withMethod(CharSequence name, T type, Consumer<? super MethodBuilder<S, T, byte[]>> methodConfig) {\n-        MethodBuilder<S, T, byte[]> M = new MethodBuilder<>(thisClass, name, type, poolHelper, typeHelper);\n-        methodConfig.accept(M);\n-        M.build(methods);\n-        nmethods++;\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Build the constant pool into a byte array.\n-     *\n-     * @return a representation of this constant pool as a byte array\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public byte[] build() {\n-        ((BytePoolHelper<S, T>)poolHelper).addAttributes(this);\n-        addAnnotations();\n-        int thisClassIdx = poolHelper.putClass(thisClass);\n-        byte[] poolBytes = poolHelper.entries();\n-        GrowableByteBuffer buf = new GrowableByteBuffer();\n-        buf.writeInt(0xCAFEBABE);\n-        buf.writeChar(minorVersion);\n-        buf.writeChar(majorVersion);\n-        buf.writeChar(poolHelper.size() + 1);\n-        buf.writeBytes(poolBytes);\n-        buf.writeChar(flags);\n-        buf.writeChar(thisClassIdx);\n-        buf.writeChar(superclass);\n-        buf.writeChar(ninterfaces);\n-        if (ninterfaces > 0) {\n-            buf.writeBytes(interfaces);\n-        }\n-        buf.writeChar(nfields);\n-        buf.writeBytes(fields);\n-        buf.writeChar(nmethods);\n-        buf.writeBytes(methods);\n-        buf.writeChar(nattrs);\n-        buf.writeBytes(attributes);\n-        return buf.bytes();\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/ClassBuilder.java","additions":0,"deletions":240,"binary":false,"changes":240,"status":"deleted"},{"patch":"@@ -1,1218 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import jdk.experimental.bytecode.PoolHelper.StaticArgListBuilder;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.function.BiFunction;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.ToIntFunction;\n-\n-\/**\n- * Builder for class file code attributes. A code attribute is defined:\n- * <pre>\n- * {@code\n- * Code_attribute {\n- *    u2 attribute_name_index;\n- *    u4 attribute_length;\n- *    u2 max_stack;\n- *    u2 max_locals;\n- *    u4 code_length;\n- *    u1 code[code_length];\n- *    u2 exception_table_length;\n- *    {   u2 start_pc;\n- *        u2 end_pc;\n- *        u2 handler_pc;\n- *        u2 catch_type;\n- *    } exception_table[exception_table_length];\n- *    u2 attributes_count;\n- *    attribute_info attributes[attributes_count];\n- * } }\n- * <\/pre>\n- *\n- * @param <S> the type of symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <E> the type of pool entries\n- * @param <C> the type of this code builder\n- *\/\n-public class CodeBuilder<S, T, E, C extends CodeBuilder<S, T, E, C>> extends AttributeBuilder<S, T, E, C> {\n-\n-    protected GrowableByteBuffer code = new GrowableByteBuffer();\n-    GrowableByteBuffer catchers = new GrowableByteBuffer();\n-    GrowableByteBuffer stackmaps = new GrowableByteBuffer();\n-    MethodBuilder<S, T, E> methodBuilder;\n-    int ncatchers;\n-    int stacksize = -1;\n-    int localsize = -1;\n-    int nstackmaps = 0;\n-\n-    public enum JumpMode {\n-        NARROW,\n-        WIDE;\n-    }\n-\n-    CodeBuilder(MethodBuilder<S, T, E> methodBuilder) {\n-        super(methodBuilder.poolHelper, methodBuilder.typeHelper);\n-        this.methodBuilder = methodBuilder;\n-    }\n-\n-    public C getstatic(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.GETSTATIC, type);\n-        code.writeChar(poolHelper.putFieldRef(owner, name, type));\n-        return thisBuilder();\n-    }\n-\n-    public C putstatic(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.PUTSTATIC, type);\n-        code.writeChar(poolHelper.putFieldRef(owner, name, type));\n-        return thisBuilder();\n-    }\n-\n-    public C getfield(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.GETFIELD, type);\n-        code.writeChar(poolHelper.putFieldRef(owner, name, type));\n-        return thisBuilder();\n-    }\n-\n-    public C putfield(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.PUTFIELD, type);\n-        code.writeChar(poolHelper.putFieldRef(owner, name, type));\n-        return thisBuilder();\n-    }\n-\n-    public C withfield(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.WITHFIELD, type);\n-        code.writeChar(poolHelper.putFieldRef(owner, name, type));\n-        return thisBuilder();\n-    }\n-\n-    public C invokevirtual(S owner, CharSequence name, T type, boolean isInterface) {\n-        emitOp(Opcode.INVOKEVIRTUAL, type);\n-        code.writeChar(poolHelper.putMethodRef(owner, name, type, isInterface));\n-        return thisBuilder();\n-    }\n-\n-    public C invokespecial(S owner, CharSequence name, T type, boolean isInterface) {\n-        emitOp(Opcode.INVOKESPECIAL, type);\n-        code.writeChar(poolHelper.putMethodRef(owner, name, type, isInterface));\n-        return thisBuilder();\n-    }\n-\n-    public C invokestatic(S owner, CharSequence name, T type, boolean isInterface) {\n-        emitOp(Opcode.INVOKESTATIC, type);\n-        code.writeChar(poolHelper.putMethodRef(owner, name, type, isInterface));\n-        return thisBuilder();\n-    }\n-\n-    public C invokeinterface(S owner, CharSequence name, T type) {\n-        emitOp(Opcode.INVOKEINTERFACE, type);\n-        code.writeChar(poolHelper.putMethodRef(owner, name, type, true));\n-        int nargs = 1;\n-        Iterator<T> it = typeHelper.parameterTypes(type);\n-        while (it.hasNext()) {\n-            nargs += typeHelper.tag(it.next()).width;\n-        }\n-        code.writeByte(nargs);\n-        code.writeByte(0);\n-        return thisBuilder();\n-    }\n-\n-    public C invokedynamic(CharSequence invokedName, T invokedType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgs) {\n-        emitOp(Opcode.INVOKEDYNAMIC, invokedType);\n-        code.writeChar(poolHelper.putInvokeDynamic(invokedName, invokedType, bsmClass, bsmName, bsmType, staticArgs));\n-        code.writeChar(0); \/\/padding\n-        return thisBuilder();\n-    }\n-\n-    public C new_(S clazz) {\n-        emitOp(Opcode.NEW, clazz);\n-        code.writeChar(poolHelper.putClass(clazz));\n-        return thisBuilder();\n-    }\n-\n-    public C aconst_init(S clazz) {\n-        emitOp(Opcode.ACONST_INIT, clazz);\n-        code.writeChar(poolHelper.putClass(clazz));\n-        return thisBuilder();\n-    }\n-\n-    public C newarray(TypeTag tag) {\n-        emitOp(Opcode.NEWARRAY, tag);\n-        int newarraycode = tag.newarraycode;\n-        if (newarraycode == -1) {\n-            throw new IllegalStateException(\"Bad tag \" + tag);\n-        }\n-        code.writeByte(newarraycode);\n-        return thisBuilder();\n-    }\n-\n-    public C anewarray(S array) {\n-        emitOp(Opcode.ANEWARRAY, array);\n-        int poolIdx = poolHelper.putClass(array);\n-        code.writeChar(poolIdx);\n-        return thisBuilder();\n-    }\n-\n-    public C checkcast(S target) {\n-        emitOp(Opcode.CHECKCAST);\n-        int poolIdx = poolHelper.putClass(target);\n-        code.writeChar(poolIdx);\n-        return thisBuilder();\n-    }\n-\n-    public C instanceof_(S target) {\n-        emitOp(Opcode.INSTANCEOF);\n-        int poolIdx = poolHelper.putClass(target);\n-        code.writeChar(poolIdx);\n-        return thisBuilder();\n-    }\n-\n-    public C multianewarray(S array, byte dims) {\n-        emitOp(Opcode.MULTIANEWARRAY, new Object[]{array, dims});\n-        code.writeChar(poolHelper.putClass(array)).writeByte(dims);\n-        return thisBuilder();\n-    }\n-\n-    public C ldc(int i) {\n-        return ldc(pool -> pool.putInt(i), false);\n-    }\n-\n-    public C ldc(long l) {\n-        return ldc(pool -> pool.putLong(l), true);\n-    }\n-\n-    public C ldc(float f) {\n-        return ldc(pool -> pool.putFloat(f), false);\n-    }\n-\n-    public C ldc(double d) {\n-        return ldc(pool -> pool.putDouble(d), true);\n-    }\n-\n-    public C ldc(String s) {\n-        return ldc(pool -> pool.putString(s), false);\n-    }\n-\n-    public C ldc(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgs) {\n-        boolean fat = typeHelper.tag(constType).width() == 2;\n-        return ldc(pool -> pool.putDynamicConstant(constName, constType, bsmClass, bsmName, bsmType, staticArgs), fat);\n-    }\n-\n-    public <Z> C ldc(Z z, BiFunction<PoolHelper<S, T, E>, Z, Integer> poolFunc) {\n-        return ldc(pool -> poolFunc.apply(pool, z), false);\n-    }\n-\n-    protected C ldc(ToIntFunction<PoolHelper<S, T, E>> indexFunc, boolean fat) {\n-        \/\/ @@@ This should probably be abstract\n-        int index = indexFunc.applyAsInt(poolHelper);\n-        return ldc(index, null, fat);\n-    }\n-\n-    protected final C ldc(int index, T type, boolean fat) {\n-        if (fat) {\n-            emitOp(Opcode.LDC2_W, type);\n-            code.writeChar(index);\n-        } else if (index > 63) {\n-            emitOp(Opcode.LDC_W, type);\n-            code.writeChar(index);\n-        } else {\n-            emitOp(Opcode.LDC, type);\n-            code.writeByte(index);\n-        }\n-        return thisBuilder();\n-    }\n-\n-    \/\/other non-CP dependent opcodes\n-    public C areturn() {\n-        return emitOp(Opcode.ARETURN);\n-    }\n-\n-    public C ireturn() {\n-        return emitOp(Opcode.IRETURN);\n-    }\n-\n-    public C freturn() {\n-        return emitOp(Opcode.FRETURN);\n-    }\n-\n-    public C lreturn() {\n-        return emitOp(Opcode.LRETURN);\n-    }\n-\n-    public C dreturn() {\n-        return emitOp(Opcode.DRETURN);\n-    }\n-\n-    public C return_() {\n-        return emitOp(Opcode.RETURN);\n-    }\n-\n-    protected C emitWideIfNeeded(Opcode opcode, int n) {\n-        boolean wide = n > Byte.MAX_VALUE;\n-        if (wide) {\n-            wide();\n-        }\n-        emitOp(opcode, n);\n-        if (wide) {\n-            code.writeChar(n);\n-        } else {\n-            code.writeByte(n);\n-        }\n-        return thisBuilder();\n-    }\n-\n-    protected C emitWideIfNeeded(Opcode opcode, int n, int v) {\n-        boolean wide = n > Byte.MAX_VALUE || v > Byte.MAX_VALUE;\n-        if (wide) {\n-            wide();\n-        }\n-        emitOp(opcode, n);\n-        if (wide) {\n-            code.writeChar(n).writeChar(v);\n-        } else {\n-            code.writeByte(n).writeByte(v);\n-        }\n-        return thisBuilder();\n-    }\n-\n-    public C aload(int i) {\n-        return emitWideIfNeeded(Opcode.ALOAD, i);\n-    }\n-\n-    public C iload(int i) {\n-        return emitWideIfNeeded(Opcode.ILOAD, i);\n-    }\n-\n-    public C fload(int i) {\n-        return emitWideIfNeeded(Opcode.FLOAD, i);\n-    }\n-\n-    public C lload(int i) {\n-        return emitWideIfNeeded(Opcode.LLOAD, i);\n-    }\n-\n-    public C dload(int i) {\n-        return emitWideIfNeeded(Opcode.DLOAD, i);\n-    }\n-\n-    public C aload_0() {\n-        return emitOp(Opcode.ALOAD_0);\n-    }\n-\n-    public C iload_0() {\n-        return emitOp(Opcode.ILOAD_0);\n-    }\n-\n-    public C fload_0() {\n-        return emitOp(Opcode.FLOAD_0);\n-    }\n-\n-    public C lload_0() {\n-        return emitOp(Opcode.LLOAD_0);\n-    }\n-\n-    public C dload_0() {\n-        return emitOp(Opcode.DLOAD_0);\n-    }\n-\n-    public C aload_1() {\n-        return emitOp(Opcode.ALOAD_1);\n-    }\n-\n-    public C iload_1() {\n-        return emitOp(Opcode.ILOAD_1);\n-    }\n-\n-    public C fload_1() {\n-        return emitOp(Opcode.FLOAD_1);\n-    }\n-\n-    public C lload_1() {\n-        return emitOp(Opcode.LLOAD_1);\n-    }\n-\n-    public C dload_1() {\n-        return emitOp(Opcode.DLOAD_1);\n-    }\n-\n-    public C aload_2() {\n-        return emitOp(Opcode.ALOAD_2);\n-    }\n-\n-    public C iload_2() {\n-        return emitOp(Opcode.ILOAD_2);\n-    }\n-\n-    public C fload_2() {\n-        return emitOp(Opcode.FLOAD_2);\n-    }\n-\n-    public C lload_2() {\n-        return emitOp(Opcode.LLOAD_2);\n-    }\n-\n-    public C dload_2() {\n-        return emitOp(Opcode.DLOAD_2);\n-    }\n-\n-    public C aload_3() {\n-        return emitOp(Opcode.ALOAD_3);\n-    }\n-\n-    public C iload_3() {\n-        return emitOp(Opcode.ILOAD_3);\n-    }\n-\n-    public C fload_3() {\n-        return emitOp(Opcode.FLOAD_3);\n-    }\n-\n-    public C lload_3() {\n-        return emitOp(Opcode.LLOAD_3);\n-    }\n-\n-    public C dload_3() {\n-        return emitOp(Opcode.DLOAD_3);\n-    }\n-\n-    public C astore(int i) {\n-        return emitWideIfNeeded(Opcode.ASTORE, i);\n-    }\n-\n-    public C istore(int i) {\n-        return emitWideIfNeeded(Opcode.ISTORE, i);\n-    }\n-\n-    public C fstore(int i) {\n-        return emitWideIfNeeded(Opcode.FSTORE, i);\n-    }\n-\n-    public C lstore(int i) {\n-        return emitWideIfNeeded(Opcode.LSTORE, i);\n-    }\n-\n-    public C dstore(int i) {\n-        return emitWideIfNeeded(Opcode.DSTORE, i);\n-    }\n-\n-    public C astore_0() {\n-        return emitOp(Opcode.ASTORE_0);\n-    }\n-\n-    public C istore_0() {\n-        return emitOp(Opcode.ISTORE_0);\n-    }\n-\n-    public C fstore_0() {\n-        return emitOp(Opcode.FSTORE_0);\n-    }\n-\n-    public C lstore_0() {\n-        return emitOp(Opcode.LSTORE_0);\n-    }\n-\n-    public C dstore_0() {\n-        return emitOp(Opcode.DSTORE_0);\n-    }\n-\n-    public C astore_1() {\n-        return emitOp(Opcode.ASTORE_1);\n-    }\n-\n-    public C istore_1() {\n-        return emitOp(Opcode.ISTORE_1);\n-    }\n-\n-    public C fstore_1() {\n-        return emitOp(Opcode.FSTORE_1);\n-    }\n-\n-    public C lstore_1() {\n-        return emitOp(Opcode.LSTORE_1);\n-    }\n-\n-    public C dstore_1() {\n-        return emitOp(Opcode.DSTORE_1);\n-    }\n-\n-    public C astore_2() {\n-        return emitOp(Opcode.ASTORE_2);\n-    }\n-\n-    public C istore_2() {\n-        return emitOp(Opcode.ISTORE_2);\n-    }\n-\n-    public C fstore_2() {\n-        return emitOp(Opcode.FSTORE_2);\n-    }\n-\n-    public C lstore_2() {\n-        return emitOp(Opcode.LSTORE_2);\n-    }\n-\n-    public C dstore_2() {\n-        return emitOp(Opcode.DSTORE_2);\n-    }\n-\n-    public C astore_3() {\n-        return emitOp(Opcode.ASTORE_3);\n-    }\n-\n-    public C istore_3() {\n-        return emitOp(Opcode.ISTORE_3);\n-    }\n-\n-    public C fstore_3() {\n-        return emitOp(Opcode.FSTORE_3);\n-    }\n-\n-    public C lstore_3() {\n-        return emitOp(Opcode.LSTORE_3);\n-    }\n-\n-    public C dstore_3() {\n-        return emitOp(Opcode.DSTORE_3);\n-    }\n-\n-    \/\/...\n-\n-    public C iaload() {\n-        return emitOp(Opcode.IALOAD);\n-    }\n-\n-    public C laload() {\n-        return emitOp(Opcode.LALOAD);\n-    }\n-\n-    public C faload() {\n-        return emitOp(Opcode.FALOAD);\n-    }\n-\n-    public C daload() {\n-        return emitOp(Opcode.DALOAD);\n-    }\n-\n-    public C aaload() {\n-        return emitOp(Opcode.AALOAD);\n-    }\n-\n-    public C baload() {\n-        return emitOp(Opcode.BALOAD);\n-    }\n-\n-    public C caload() {\n-        return emitOp(Opcode.CALOAD);\n-    }\n-\n-    public C saload() {\n-        return emitOp(Opcode.SALOAD);\n-    }\n-\n-    public C iastore() {\n-        return emitOp(Opcode.IASTORE);\n-    }\n-\n-    public C lastore() {\n-        return emitOp(Opcode.LASTORE);\n-    }\n-\n-    public C fastore() {\n-        return emitOp(Opcode.FASTORE);\n-    }\n-\n-    public C dastore() {\n-        return emitOp(Opcode.DASTORE);\n-    }\n-\n-    public C aastore() {\n-        return emitOp(Opcode.AASTORE);\n-    }\n-\n-    public C bastore() {\n-        return emitOp(Opcode.BASTORE);\n-    }\n-\n-    public C castore() {\n-        return emitOp(Opcode.CASTORE);\n-    }\n-\n-    public C sastore() {\n-        return emitOp(Opcode.SASTORE);\n-    }\n-\n-    public C nop() {\n-        return emitOp(Opcode.NOP);\n-    }\n-\n-    public C aconst_null() {\n-        return emitOp(Opcode.ACONST_NULL);\n-    }\n-\n-    public C iconst_0() {\n-        return emitOp(Opcode.ICONST_0);\n-    }\n-\n-    public C iconst_1() {\n-        return emitOp(Opcode.ICONST_1);\n-    }\n-\n-    public C iconst_2() {\n-        return emitOp(Opcode.ICONST_2);\n-    }\n-\n-    public C iconst_3() {\n-        return emitOp(Opcode.ICONST_3);\n-    }\n-\n-    public C iconst_4() {\n-        return emitOp(Opcode.ICONST_4);\n-    }\n-\n-    public C iconst_5() {\n-        return emitOp(Opcode.ICONST_5);\n-    }\n-\n-    public C iconst_m1() {\n-        return emitOp(Opcode.ICONST_M1);\n-    }\n-\n-    public C lconst_0() {\n-        return emitOp(Opcode.LCONST_0);\n-    }\n-\n-    public C lconst_1() {\n-        return emitOp(Opcode.LCONST_1);\n-    }\n-\n-    public C fconst_0() {\n-        return emitOp(Opcode.FCONST_0);\n-    }\n-\n-    public C fconst_1() {\n-        return emitOp(Opcode.FCONST_1);\n-    }\n-\n-    public C fconst_2() {\n-        return emitOp(Opcode.FCONST_2);\n-    }\n-\n-    public C dconst_0() {\n-        return emitOp(Opcode.DCONST_0);\n-    }\n-\n-    public C dconst_1() {\n-        return emitOp(Opcode.DCONST_1);\n-    }\n-\n-    public C sipush(int s) {\n-        emitOp(Opcode.SIPUSH);\n-        code.writeChar(s);\n-        return thisBuilder();\n-    }\n-\n-    public C bipush(int b) {\n-        emitOp(Opcode.BIPUSH);\n-        code.writeByte(b);\n-        return thisBuilder();\n-    }\n-\n-    public C pop() {\n-        return emitOp(Opcode.POP);\n-    }\n-\n-    public C pop2() {\n-        return emitOp(Opcode.POP2);\n-    }\n-\n-    public C dup() {\n-        return emitOp(Opcode.DUP);\n-    }\n-\n-    public C dup_x1() {\n-        return emitOp(Opcode.DUP_X1);\n-    }\n-\n-    public C dup_x2() {\n-        return emitOp(Opcode.DUP_X2);\n-    }\n-\n-    public C dup2() {\n-        return emitOp(Opcode.DUP2);\n-    }\n-\n-    public C dup2_x1() {\n-        return emitOp(Opcode.DUP2_X1);\n-    }\n-\n-    public C dup2_x2() {\n-        return emitOp(Opcode.DUP2_X2);\n-    }\n-\n-    public C swap() {\n-        return emitOp(Opcode.SWAP);\n-    }\n-\n-    public C iadd() {\n-        return emitOp(Opcode.IADD);\n-    }\n-\n-    public C ladd() {\n-        return emitOp(Opcode.LADD);\n-    }\n-\n-    public C fadd() {\n-        return emitOp(Opcode.FADD);\n-    }\n-\n-    public C dadd() {\n-        return emitOp(Opcode.DADD);\n-    }\n-\n-    public C isub() {\n-        return emitOp(Opcode.ISUB);\n-    }\n-\n-    public C lsub() {\n-        return emitOp(Opcode.LSUB);\n-    }\n-\n-    public C fsub() {\n-        return emitOp(Opcode.FSUB);\n-    }\n-\n-    public C dsub() {\n-        return emitOp(Opcode.DSUB);\n-    }\n-\n-    public C imul() {\n-        return emitOp(Opcode.IMUL);\n-    }\n-\n-    public C lmul() {\n-        return emitOp(Opcode.LMUL);\n-    }\n-\n-    public C fmul() {\n-        return emitOp(Opcode.FMUL);\n-    }\n-\n-    public C dmul() {\n-        return emitOp(Opcode.DMUL);\n-    }\n-\n-    public C idiv() {\n-        return emitOp(Opcode.IDIV);\n-    }\n-\n-    public C ldiv() {\n-        return emitOp(Opcode.LDIV);\n-    }\n-\n-    public C fdiv() {\n-        return emitOp(Opcode.FDIV);\n-    }\n-\n-    public C ddiv() {\n-        return emitOp(Opcode.DDIV);\n-    }\n-\n-    public C irem() {\n-        return emitOp(Opcode.IREM);\n-    }\n-\n-    public C lrem() {\n-        return emitOp(Opcode.LREM);\n-    }\n-\n-    public C frem() {\n-        return emitOp(Opcode.FREM);\n-    }\n-\n-    public C drem() {\n-        return emitOp(Opcode.DREM);\n-    }\n-\n-    public C ineg() {\n-        return emitOp(Opcode.INEG);\n-    }\n-\n-    public C lneg() {\n-        return emitOp(Opcode.LNEG);\n-    }\n-\n-    public C fneg() {\n-        return emitOp(Opcode.FNEG);\n-    }\n-\n-    public C dneg() {\n-        return emitOp(Opcode.DNEG);\n-    }\n-\n-    public C ishl() {\n-        return emitOp(Opcode.ISHL);\n-    }\n-\n-    public C lshl() {\n-        return emitOp(Opcode.LSHL);\n-    }\n-\n-    public C ishr() {\n-        return emitOp(Opcode.ISHR);\n-    }\n-\n-    public C lshr() {\n-        return emitOp(Opcode.LSHR);\n-    }\n-\n-    public C iushr() {\n-        return emitOp(Opcode.IUSHR);\n-    }\n-\n-    public C lushr() {\n-        return emitOp(Opcode.LUSHR);\n-    }\n-\n-    public C iand() {\n-        return emitOp(Opcode.IAND);\n-    }\n-\n-    public C land() {\n-        return emitOp(Opcode.LAND);\n-    }\n-\n-    public C ior() {\n-        return emitOp(Opcode.IOR);\n-    }\n-\n-    public C lor() {\n-        return emitOp(Opcode.LOR);\n-    }\n-\n-    public C ixor() {\n-        return emitOp(Opcode.IXOR);\n-    }\n-\n-    public C lxor() {\n-        return emitOp(Opcode.LXOR);\n-    }\n-\n-    public C iinc(int index, int val) {\n-        return emitWideIfNeeded(Opcode.IINC, index, val);\n-    }\n-\n-    public C i2l() {\n-        return emitOp(Opcode.I2L);\n-    }\n-\n-    public C i2f() {\n-        return emitOp(Opcode.I2F);\n-    }\n-\n-    public C i2d() {\n-        return emitOp(Opcode.I2D);\n-    }\n-\n-    public C l2i() {\n-        return emitOp(Opcode.L2I);\n-    }\n-\n-    public C l2f() {\n-        return emitOp(Opcode.L2F);\n-    }\n-\n-    public C l2d() {\n-        return emitOp(Opcode.L2D);\n-    }\n-\n-    public C f2i() {\n-        return emitOp(Opcode.F2I);\n-    }\n-\n-    public C f2l() {\n-        return emitOp(Opcode.F2L);\n-    }\n-\n-    public C f2d() {\n-        return emitOp(Opcode.F2D);\n-    }\n-\n-    public C d2i() {\n-        return emitOp(Opcode.D2I);\n-    }\n-\n-    public C d2l() {\n-        return emitOp(Opcode.D2L);\n-    }\n-\n-    public C d2f() {\n-        return emitOp(Opcode.D2F);\n-    }\n-\n-    public C i2b() {\n-        return emitOp(Opcode.I2B);\n-    }\n-\n-    public C i2c() {\n-        return emitOp(Opcode.I2C);\n-    }\n-\n-    public C i2s() {\n-        return emitOp(Opcode.I2S);\n-    }\n-\n-    public C lcmp() {\n-        return emitOp(Opcode.LCMP);\n-    }\n-\n-    public C fcmpl() {\n-        return emitOp(Opcode.FCMPL);\n-    }\n-\n-    public C fcmpg() {\n-        return emitOp(Opcode.FCMPG);\n-    }\n-\n-    public C dcmpl() {\n-        return emitOp(Opcode.DCMPL);\n-    }\n-\n-    public C dcmpg() {\n-        return emitOp(Opcode.DCMPG);\n-    }\n-\n-    public C ifeq(short target) {\n-        return emitNarrowJumpOp(Opcode.IFEQ, target);\n-    }\n-\n-    public C ifne(short target) {\n-        return emitNarrowJumpOp(Opcode.IFNE, target);\n-    }\n-\n-    public C iflt(short target) {\n-        return emitNarrowJumpOp(Opcode.IFLT, target);\n-    }\n-\n-    public C ifge(short target) {\n-        return emitNarrowJumpOp(Opcode.IFGE, target);\n-    }\n-\n-    public C ifgt(short target) {\n-        return emitNarrowJumpOp(Opcode.IFGT, target);\n-    }\n-\n-    public C ifle(short target) {\n-        return emitNarrowJumpOp(Opcode.IFLE, target);\n-    }\n-\n-    public C if_icmpeq(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPEQ, target);\n-    }\n-\n-    public C if_icmpne(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPNE, target);\n-    }\n-\n-    public C if_icmplt(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPLT, target);\n-    }\n-\n-    public C if_icmpge(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPGE, target);\n-    }\n-\n-    public C if_icmpgt(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPGT, target);\n-    }\n-\n-    public C if_icmple(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ICMPLE, target);\n-    }\n-\n-    public C if_acmpeq(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ACMPEQ, target);\n-    }\n-\n-    public C if_acmpne(short target) {\n-        return emitNarrowJumpOp(Opcode.IF_ACMPNE, target);\n-    }\n-\n-    public C goto_(short target) {\n-        return emitNarrowJumpOp(Opcode.GOTO_, target);\n-    }\n-\n-    public C jsr(short target) {\n-        return emitNarrowJumpOp(Opcode.JSR, target);\n-    }\n-\n-    public C ret(int index) {\n-        return emitWideIfNeeded(Opcode.RET, index);\n-    }\n-\n-    public C tableswitch(int low, int high, int defaultTarget, int... targets) {\n-        if (high - low + 1 != targets.length) throw new IllegalStateException(\"Bad targets length\");\n-        emitOp(Opcode.TABLESWITCH);\n-        \/\/padding\n-        int start = code.offset;\n-        if ((start % 4) != 0) {\n-            \/\/add padding\n-            for (int i = 0; i < 4 - (start % 4); i++) {\n-                code.writeByte(0);\n-            }\n-        }\n-        code.writeInt(defaultTarget)\n-                .writeInt(low)\n-                .writeInt(high);\n-        for (int target : targets) {\n-            code.writeInt(target);\n-        }\n-        return thisBuilder();\n-    }\n-\n-    public C lookupswitch(int defaultTarget, int... npairs) {\n-        if (npairs.length % 2 != 0) throw new IllegalStateException(\"Bad npairs length\");\n-        emitOp(Opcode.LOOKUPSWITCH);\n-        \/\/padding\n-        int start = code.offset;\n-        for (int i = 0; i < (4 - (start % 4)); i++) {\n-            code.writeByte(0);\n-        }\n-        code.writeInt(defaultTarget)\n-                .writeInt(npairs.length \/ 2);\n-        for (int i = 0; i < npairs.length; i += 2) {\n-            code.writeInt(npairs[i]);\n-            code.writeInt(npairs[i + 1]);\n-        }\n-        return thisBuilder();\n-    }\n-\n-    public C arraylength() {\n-        return emitOp(Opcode.ARRAYLENGTH);\n-    }\n-\n-    public C athrow() {\n-        return emitOp(Opcode.ATHROW);\n-    }\n-\n-    public C monitorenter() {\n-        return emitOp(Opcode.MONITORENTER);\n-    }\n-\n-    public C monitorexit() {\n-        return emitOp(Opcode.MONITOREXIT);\n-    }\n-\n-    public C wide() {\n-        return emitOp(Opcode.WIDE);\n-    }\n-\n-    public C if_null(short offset) {\n-        return emitNarrowJumpOp(Opcode.IF_NULL, offset);\n-    }\n-\n-    public C if_nonnull(short offset) {\n-        return emitNarrowJumpOp(Opcode.IF_NONNULL, offset);\n-    }\n-\n-    public C goto_w(int target) {\n-        return emitWideJumpOp(Opcode.GOTO_W, target);\n-    }\n-\n-    public C jsr_w(int target) {\n-        return emitWideJumpOp(Opcode.JSR_W, target);\n-    }\n-\n-    public C withCatch(S type, int start, int end, int offset) {\n-        catchers.writeChar(start);\n-        catchers.writeChar(end);\n-        catchers.writeChar(offset);\n-        catchers.writeChar(type != null ? poolHelper.putClass(type) : 0);\n-        ncatchers++;\n-        return thisBuilder();\n-    }\n-\n-    public C withLocalSize(int localsize) {\n-        this.localsize = localsize;\n-        return thisBuilder();\n-    }\n-\n-    public C withStackSize(int stacksize) {\n-        this.stacksize = stacksize;\n-        return thisBuilder();\n-    }\n-\n-    protected int localsize() {\n-        return localsize;\n-    }\n-\n-    void build(GrowableByteBuffer buf) {\n-        buf.writeChar(stacksize); \/\/max stack size\n-        buf.writeChar(localsize()); \/\/max locals\n-        buf.writeInt(code.offset);\n-        buf.writeBytes(code);\n-        buf.writeChar(ncatchers);\n-        buf.writeBytes(catchers);\n-        buf.writeChar(nattrs); \/\/attributes\n-        buf.writeBytes(attributes);\n-    }\n-\n-    byte[] build() {\n-        GrowableByteBuffer buf = new GrowableByteBuffer();\n-        build(buf);\n-        return buf.bytes();\n-    }\n-\n-    protected C emitNarrowJumpOp(Opcode opcode, short target) {\n-        emitOp(opcode);\n-        emitOffset(code, JumpMode.NARROW, target);\n-        return thisBuilder();\n-    }\n-\n-    protected C emitWideJumpOp(Opcode opcode, int target) {\n-        emitOp(opcode);\n-        emitOffset(code, JumpMode.WIDE, target);\n-        return thisBuilder();\n-    }\n-\n-    protected C emitOp(Opcode opcode) {\n-        return emitOp(opcode, null);\n-    }\n-\n-    protected C emitOp(Opcode opcode, Object optPoolValue) {\n-        code.writeByte(opcode.code);\n-        return thisBuilder();\n-    }\n-\n-    protected void emitOffset(GrowableByteBuffer buf, JumpMode jumpMode, int offset) {\n-        if (jumpMode == JumpMode.NARROW) {\n-            buf.writeChar((short) offset);\n-        } else {\n-            buf.writeInt(offset);\n-        }\n-    }\n-\n-    int offset() {\n-        return code.offset;\n-    }\n-\n-    \/*** stackmap support ***\/\n-\n-    \/**\n-     * The tags and constants used in compressed stackmap.\n-     *\/\n-    static final int SAME_FRAME_SIZE = 64;\n-    static final int SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247;\n-    static final int SAME_FRAME_EXTENDED = 251;\n-    static final int FULL_FRAME = 255;\n-    static final int MAX_LOCAL_LENGTH_DIFF = 4;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void writeStackMapType(T t) {\n-        if (t == null) {\n-            stackmaps.writeByte(0);\n-        } else {\n-            switch (typeHelper.tag(t)) {\n-                case B:\n-                case C:\n-                case S:\n-                case I:\n-                case Z:\n-                    stackmaps.writeByte(1);\n-                    break;\n-                case F:\n-                    stackmaps.writeByte(2);\n-                    break;\n-                case D:\n-                    stackmaps.writeByte(3);\n-                    break;\n-                case J:\n-                    stackmaps.writeByte(4);\n-                    break;\n-                case A:\n-                    if (t == typeHelper.nullType()) {\n-                        stackmaps.writeByte(5); \/\/null\n-                    } else {\n-                        \/\/TODO: uninit this, top?\n-                        stackmaps.writeByte(7);\n-                        stackmaps.writeChar(poolHelper.putClass(typeHelper.symbol(t)));\n-                    }\n-                    break;\n-                default:\n-                    throw new IllegalStateException(\"Bad type\");\n-            }\n-        }\n-    }\n-\n-    public void sameFrame(int offsetDelta) {\n-        int frameType = (offsetDelta < SAME_FRAME_SIZE) ?\n-                offsetDelta : SAME_FRAME_EXTENDED;\n-        stackmaps.writeByte(frameType);\n-        if (frameType == SAME_FRAME_EXTENDED) {\n-            stackmaps.writeChar(offsetDelta);\n-        }\n-    }\n-\n-    public void sameLocals1StackItemFrame(int offsetDelta, T stackItem) {\n-        int frameType = (offsetDelta < SAME_FRAME_SIZE) ?\n-                (SAME_FRAME_SIZE + offsetDelta) : SAME_LOCALS_1_STACK_ITEM_EXTENDED;\n-        stackmaps.writeByte(frameType);\n-        if (frameType == SAME_LOCALS_1_STACK_ITEM_EXTENDED) {\n-            stackmaps.writeChar(offsetDelta);\n-        }\n-        writeStackMapType(stackItem);\n-    }\n-\n-    public void appendFrame(int offsetDelta, int prevLocalsSize, List<T> locals) {\n-        int frameType = SAME_FRAME_EXTENDED + (locals.size() - prevLocalsSize);\n-        stackmaps.writeByte(frameType);\n-        stackmaps.writeChar(offsetDelta);\n-        for (int i = prevLocalsSize; i < locals.size(); i++) {\n-            writeStackMapType(locals.get(i));\n-        }\n-    }\n-\n-    public void chopFrame(int offsetDelta, int droppedVars) {\n-        int frameType = SAME_FRAME_EXTENDED - droppedVars;\n-        stackmaps.writeByte(frameType);\n-        stackmaps.writeChar(offsetDelta);\n-    }\n-\n-    public void fullFrame(int offsetDelta, List<T> locals, List<T> stackItems) {\n-        stackmaps.writeByte(FULL_FRAME);\n-        stackmaps.writeChar(offsetDelta);\n-        stackmaps.writeChar(locals.size());\n-        for (T local : locals) {\n-            writeStackMapType(local);\n-        }\n-\n-        stackmaps.writeChar(stackItems.size());\n-        for (T stackType : stackItems) {\n-            writeStackMapType(stackType);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/CodeBuilder.java","additions":0,"deletions":1218,"binary":false,"changes":1218,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.function.Consumer;\n-\n-\/**\n- * Declaration (class, class member, ...) builder.\n- *\n- * @param <S> the type of symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <E> the type of pool entries\n- * @param <D> the type of this builder\n- *\/\n-public class DeclBuilder<S, T, E, D extends DeclBuilder<S, T, E, D>>\n-        extends AttributeBuilder<S, T, E, D> {\n-\n-    \/**\n-     * The access flags of the declaration, as bit flags.\n-     *\/\n-    protected int flags;\n-\n-    AnnotationsBuilder<S, T, E> runtimeInvisibleAnnotations;\n-    AnnotationsBuilder<S, T, E> runtimeVisibleAnnotations;\n-\n-    \/**\n-     * Create a declaration builder,\n-     *\n-     * @param poolHelper the helper to build the constant pool\n-     * @param typeHelper the helper to use to manipulate type descriptors\n-     *\/\n-    DeclBuilder(PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(poolHelper, typeHelper);\n-    }\n-\n-    \/**\n-     * Specify the class file flags for this declaration.\n-     *\n-     * @param flags the flags as {@code Flag} objects\n-     * @return this builder, for chained calls\n-     *\/\n-    public D withFlags(Flag... flags) {\n-        for (Flag f : flags) {\n-            this.flags |= f.flag;\n-        }\n-        return thisBuilder();\n-    }\n-\n-    \/**\n-     * Specify, via bits, the class file flags for this declaration.\n-     *\n-     * @param flags the flags as bit settings\n-     * @return this builder, for chained calls\n-     *\/\n-    public D withFlags(int flags) {\n-        withFlags(Flag.parse(flags));\n-        return thisBuilder();\n-    }\n-\n-    public D withAnnotation(AnnotationsBuilder.Kind kind, T annoType) {\n-        getAnnotations(kind).withAnnotation(annoType, null);\n-        return thisBuilder();\n-    }\n-\n-    public D withAnnotation(AnnotationsBuilder.Kind kind, T annoType, Consumer<? super AnnotationsBuilder<S, T, E>.AnnotationElementBuilder> annotations) {\n-        getAnnotations(kind).withAnnotation(annoType, annotations);\n-        return thisBuilder();\n-    }\n-\n-    private AnnotationsBuilder<S, T, E> getAnnotations(AnnotationsBuilder.Kind kind) {\n-        switch (kind) {\n-            case RUNTIME_INVISIBLE:\n-                if (runtimeInvisibleAnnotations == null) {\n-                    runtimeInvisibleAnnotations = new AnnotationsBuilder<>(poolHelper, typeHelper);\n-                }\n-                return runtimeInvisibleAnnotations;\n-            case RUNTIME_VISIBLE:\n-                if (runtimeVisibleAnnotations == null) {\n-                    runtimeVisibleAnnotations = new AnnotationsBuilder<>(poolHelper, typeHelper);\n-                }\n-                return runtimeVisibleAnnotations;\n-        }\n-        throw new IllegalStateException();\n-    }\n-\n-    void addAnnotations() {\n-        if (runtimeVisibleAnnotations != null) {\n-            withAttribute(\"RuntimeVisibleAnnotations\", runtimeVisibleAnnotations.build());\n-        }\n-        if (runtimeInvisibleAnnotations != null) {\n-            withAttribute(\"RuntimeInvisibleAnnotations\", runtimeVisibleAnnotations.build());\n-        }\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/DeclBuilder.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-\/**\n- * Field builder.\n- *\n- * @param <S> the type of symbol representation\n- * @param <T> the type of type descriptor representation\n- * @param <E> the type of pool entries\n- *\/\n-public class FieldBuilder<S, T, E> extends MemberBuilder<S, T, E, FieldBuilder<S, T, E>> {\n-    public FieldBuilder(CharSequence name, T type, PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(name, type, poolHelper, typeHelper);\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/FieldBuilder.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.EnumSet;\n-\n-public enum Flag {\n-    ACC_PUBLIC(0x0001),\n-    ACC_PROTECTED(0x0004),\n-    ACC_PRIVATE(0x0002),\n-    ACC_IDENTITY(0x0020),\n-    ACC_INTERFACE(0x0200),\n-    ACC_ENUM(0x4000),\n-    ACC_ANNOTATION(0x2000),\n-    ACC_SUPER(0x0020),\n-    ACC_ABSTRACT(0x0400),\n-    ACC_VOLATILE(0x0040),\n-    ACC_TRANSIENT(0x0080),\n-    ACC_SYNTHETIC(0x1000),\n-    ACC_STATIC(0x0008),\n-    ACC_FINAL(0x0010),\n-    ACC_SYNCHRONIZED(0x0020),\n-    ACC_BRIDGE(0x0040),\n-    ACC_VARARGS(0x0080),\n-    ACC_NATIVE(0x0100),\n-    ACC_INLINE(0x0100),\n-    ACC_STRICT(0x0800);\n-\n-    public int flag;\n-\n-    Flag(int flag) {\n-        this.flag = flag;\n-    }\n-\n-    static Flag[] parse(int flagsMask) {\n-        EnumSet<Flag> flags = EnumSet.noneOf(Flag.class);\n-        for (Flag f : Flag.values()) {\n-            if ((f.flag & flagsMask) != 0) {\n-                flags.add(f);\n-            }\n-        }\n-        return flags.stream().toArray(Flag[]::new);\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/Flag.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.function.Consumer;\n-\n-public class GrowableByteBuffer {\n-\n-    public GrowableByteBuffer() {\n-    }\n-\n-    byte[] elems = new byte[64];\n-    int offset = 0;\n-\n-    public GrowableByteBuffer writeByte(int b) {\n-        return writeBytes(1, b);\n-    }\n-\n-    public GrowableByteBuffer writeChar(int x) {\n-        return writeBytes(2, x);\n-    }\n-\n-    public GrowableByteBuffer writeInt(int x) {\n-        return writeBytes(4, x);\n-    }\n-\n-    public GrowableByteBuffer writeFloat(float x) {\n-        return writeInt(Float.floatToIntBits(x));\n-    }\n-\n-    public GrowableByteBuffer writeLong(long x) {\n-        return writeBytes(8, x);\n-    }\n-\n-    public GrowableByteBuffer writeDouble(double x) {\n-        writeLong(Double.doubleToLongBits(x));\n-        return this;\n-    }\n-\n-    public GrowableByteBuffer writeBytes(byte[] barr) {\n-        expandIfNeeded(barr.length);\n-        System.arraycopy(barr, 0, elems, offset, barr.length);\n-        offset += barr.length;\n-        return this;\n-    }\n-\n-    public GrowableByteBuffer writeBytes(GrowableByteBuffer bb) {\n-        expandIfNeeded(bb.offset);\n-        System.arraycopy(bb.elems, 0, elems, offset, bb.offset);\n-        offset += bb.offset;\n-        return this;\n-    }\n-\n-    public GrowableByteBuffer withOffset(int offset, Consumer<GrowableByteBuffer> actions) {\n-        int prevOffset = this.offset;\n-        this.offset = offset;\n-        actions.accept(this);\n-        this.offset = prevOffset;\n-        return this;\n-    }\n-\n-    private GrowableByteBuffer writeBytes(int size, long x) {\n-        expandIfNeeded(size);\n-        for (int i = 0; i < size; i++) {\n-            elems[offset++] = (byte) ((x >> 8 * (size - i - 1)) & 0xFF);\n-        }\n-        return this;\n-    }\n-\n-    void expandIfNeeded(int increment) {\n-        if (offset + increment > elems.length) {\n-            int newsize = elems.length * 2;\n-            while (offset + increment > newsize) {\n-                newsize *= 2;\n-            }\n-            byte[] newelems = new byte[newsize];\n-            System.arraycopy(elems, 0, newelems, 0, offset);\n-            elems = newelems;\n-        }\n-    }\n-\n-    public byte[] bytes() {\n-        byte[] bytes = new byte[offset];\n-        System.arraycopy(elems, 0, bytes, 0, offset);\n-        return bytes;\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/GrowableByteBuffer.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,688 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.TreeMap;\n-import java.util.function.Consumer;\n-\n-public class MacroCodeBuilder<S, T, E, C extends MacroCodeBuilder<S, T, E, C>> extends CodeBuilder<S, T, E, C> {\n-\n-    JumpMode jumpMode = JumpMode.NARROW;\n-\n-    Map<CharSequence, Integer> labels = new HashMap<>();\n-    List<PendingJump> pendingJumps = new LinkedList<>();\n-\n-    class PendingJump {\n-        CharSequence label;\n-        int pc;\n-\n-        PendingJump(CharSequence label, int pc) {\n-            this.label = label;\n-            this.pc = pc;\n-        }\n-\n-        boolean resolve(CharSequence label, int offset) {\n-            if (this.label.equals(label)) {\n-                \/\/patch offset\n-                code.withOffset(pc + 1, buf -> emitOffset(buf, jumpMode, offset - pc));\n-                return true;\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    public enum InvocationKind {\n-        INVOKESTATIC,\n-        INVOKEVIRTUAL,\n-        INVOKESPECIAL,\n-        INVOKEINTERFACE;\n-    }\n-\n-    public enum FieldAccessKind {\n-        STATIC,\n-        INSTANCE;\n-    }\n-\n-    public enum CondKind {\n-        EQ(0),\n-        NE(1),\n-        LT(2),\n-        GE(3),\n-        GT(4),\n-        LE(5);\n-\n-        int offset;\n-\n-        CondKind(int offset) {\n-            this.offset = offset;\n-        }\n-\n-        public CondKind negate() {\n-            switch (this) {\n-                case EQ:\n-                    return NE;\n-                case NE:\n-                    return EQ;\n-                case LT:\n-                    return GE;\n-                case GE:\n-                    return LT;\n-                case GT:\n-                    return LE;\n-                case LE:\n-                    return GT;\n-                default:\n-                    throw new IllegalStateException(\"Unknown cond\");\n-            }\n-        }\n-    }\n-\n-    static class WideJumpException extends RuntimeException {\n-        static final long serialVersionUID = 42L;\n-    }\n-\n-    public MacroCodeBuilder(MethodBuilder<S, T, E> methodBuilder) {\n-        super(methodBuilder);\n-    }\n-\n-    public C load(TypeTag type, int n) {\n-        switch (n) {\n-            case 0:\n-                return emitOp(Opcode.ILOAD_0.at(type, 4));\n-            case 1:\n-                return emitOp(Opcode.ILOAD_1.at(type, 4));\n-            case 2:\n-                return emitOp(Opcode.ILOAD_2.at(type, 4));\n-            case 3:\n-                return emitOp(Opcode.ILOAD_3.at(type, 4));\n-            default:\n-                return emitWideIfNeeded(Opcode.ILOAD.at(type), n);\n-        }\n-    }\n-\n-    public C store(TypeTag type, int n) {\n-        switch (n) {\n-            case 0:\n-                return emitOp(Opcode.ISTORE_0.at(type, 4));\n-            case 1:\n-                return emitOp(Opcode.ISTORE_1.at(type, 4));\n-            case 2:\n-                return emitOp(Opcode.ISTORE_2.at(type, 4));\n-            case 3:\n-                return emitOp(Opcode.ISTORE_3.at(type, 4));\n-            default:\n-                return emitWideIfNeeded(Opcode.ISTORE.at(type), n);\n-        }\n-    }\n-\n-    public C arrayload(TypeTag type) {\n-        return emitOp(Opcode.IALOAD.at(type));\n-    }\n-\n-    public C arraystore(TypeTag type, int n) {\n-        return emitOp(Opcode.IASTORE.at(type));\n-    }\n-\n-    public C const_(int i) {\n-        switch (i) {\n-            case -1:\n-                return iconst_m1();\n-            case 0:\n-                return iconst_0();\n-            case 1:\n-                return iconst_1();\n-            case 2:\n-                return iconst_2();\n-            case 3:\n-                return iconst_3();\n-            case 4:\n-                return iconst_4();\n-            case 5:\n-                return iconst_5();\n-            default:\n-                if (i > 0 && i <= Byte.MAX_VALUE) {\n-                    return bipush(i);\n-                } else if (i >= Short.MIN_VALUE && i <= Short.MAX_VALUE) {\n-                    return sipush(i);\n-                } else {\n-                    return ldc(i);\n-                }\n-        }\n-    }\n-\n-    public C const_(long l) {\n-        if (l == 0) {\n-            return lconst_0();\n-        } else if (l == 1) {\n-            return lconst_1();\n-        } else {\n-            return ldc(l);\n-        }\n-    }\n-\n-    public C const_(float f) {\n-        if (f == 0) {\n-            return fconst_0();\n-        } else if (f == 1) {\n-            return fconst_1();\n-        } else if (f == 2) {\n-            return fconst_2();\n-        } else {\n-            return ldc(f);\n-        }\n-    }\n-\n-    public C const_(double d) {\n-        if (d == 0) {\n-            return dconst_0();\n-        } else if (d == 1) {\n-            return dconst_1();\n-        } else {\n-            return ldc(d);\n-        }\n-    }\n-\n-    public C getfield(FieldAccessKind fak, S owner, CharSequence name, T type) {\n-        switch (fak) {\n-            case INSTANCE:\n-                return getfield(owner, name, type);\n-            case STATIC:\n-                return getstatic(owner, name, type);\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    public C putfield(FieldAccessKind fak, S owner, CharSequence name, T type) {\n-        switch (fak) {\n-            case INSTANCE:\n-                return putfield(owner, name, type);\n-            case STATIC:\n-                return putstatic(owner, name, type);\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    public C invoke(InvocationKind ik, S owner, CharSequence name, T type, boolean isInterface) {\n-        switch (ik) {\n-            case INVOKESTATIC:\n-                return invokestatic(owner, name, type, isInterface);\n-            case INVOKEVIRTUAL:\n-                return invokevirtual(owner, name, type, isInterface);\n-            case INVOKESPECIAL:\n-                return invokespecial(owner, name, type, isInterface);\n-            case INVOKEINTERFACE:\n-                if (!isInterface) throw new AssertionError();\n-                return invokeinterface(owner, name, type);\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    public C add(TypeTag type) {\n-        return emitOp(Opcode.IADD.at(type));\n-    }\n-\n-    public C sub(TypeTag type) {\n-        return emitOp(Opcode.ISUB.at(type));\n-    }\n-\n-    public C mul(TypeTag type) {\n-        return emitOp(Opcode.IMUL.at(type));\n-    }\n-\n-    public C div(TypeTag type) {\n-        return emitOp(Opcode.IDIV.at(type));\n-    }\n-\n-    public C rem(TypeTag type) {\n-        return emitOp(Opcode.IREM.at(type));\n-    }\n-\n-    public C neg(TypeTag type) {\n-        return emitOp(Opcode.INEG.at(type));\n-    }\n-\n-    public C shl(TypeTag type) {\n-        return emitOp(Opcode.ISHL.at(type));\n-    }\n-\n-    public C shr(TypeTag type) {\n-        return emitOp(Opcode.ISHR.at(type));\n-    }\n-\n-    public C ushr(TypeTag type) {\n-        return emitOp(Opcode.ISHR.at(type));\n-    }\n-\n-    public C and(TypeTag type) {\n-        return emitOp(Opcode.IAND.at(type));\n-    }\n-\n-    public C or(TypeTag type) {\n-        return emitOp(Opcode.IOR.at(type));\n-    }\n-\n-    public C xor(TypeTag type) {\n-        return emitOp(Opcode.IXOR.at(type));\n-    }\n-\n-    public C return_(TypeTag type) {\n-        switch (type) {\n-            case V:\n-            case Q:\n-                return return_();\n-            default:\n-                return emitOp(Opcode.IRETURN.at(type));\n-        }\n-    }\n-\n-    public C conv(TypeTag from, TypeTag to) {\n-        switch (from) {\n-            case B:\n-            case C:\n-            case S:\n-                switch (to) {\n-                    case J:\n-                        return i2l();\n-                    case F:\n-                        return i2f();\n-                    case D:\n-                        return i2d();\n-                }\n-                break;\n-            case I:\n-                switch (to) {\n-                    case J:\n-                        return i2l();\n-                    case F:\n-                        return i2f();\n-                    case D:\n-                        return i2d();\n-                    case B:\n-                        return i2b();\n-                    case C:\n-                        return i2c();\n-                    case S:\n-                        return i2s();\n-                }\n-                break;\n-            case J:\n-                switch (to) {\n-                    case I:\n-                        return l2i();\n-                    case F:\n-                        return l2f();\n-                    case D:\n-                        return l2d();\n-                }\n-                break;\n-            case F:\n-                switch (to) {\n-                    case I:\n-                        return f2i();\n-                    case J:\n-                        return f2l();\n-                    case D:\n-                        return f2d();\n-                }\n-                break;\n-            case D:\n-                switch (to) {\n-                    case I:\n-                        return d2i();\n-                    case J:\n-                        return d2l();\n-                    case F:\n-                        return d2f();\n-                }\n-                break;\n-        }\n-        \/\/no conversion is necessary - do nothing!\n-        return thisBuilder();\n-    }\n-\n-    public C if_null(CharSequence label) {\n-        return emitCondJump(Opcode.IF_NULL, Opcode.IF_NONNULL, label);\n-    }\n-\n-    public C if_nonnull(CharSequence label) {\n-        return emitCondJump(Opcode.IF_NONNULL, Opcode.IF_NULL, label);\n-    }\n-\n-    public C ifcmp(TypeTag type, CondKind cond, CharSequence label) {\n-        switch (type) {\n-            case I:\n-                return emitCondJump(Opcode.IF_ICMPEQ, cond, label);\n-            case A:\n-                return emitCondJump(Opcode.IF_ACMPEQ, cond, label);\n-            case J:\n-                return lcmp().emitCondJump(Opcode.IFEQ, cond, label);\n-            case D:\n-                return dcmpg().emitCondJump(Opcode.IFEQ, cond, label);\n-            case F:\n-                return fcmpg().emitCondJump(Opcode.IFEQ, cond, label);\n-            default:\n-                throw new IllegalArgumentException(\"Bad cmp type\");\n-        }\n-    }\n-\n-    public C goto_(CharSequence label) {\n-        emitOp(jumpMode == JumpMode.NARROW ? Opcode.GOTO_ : Opcode.GOTO_W);\n-        emitOffset(code, jumpMode, labelOffset(label));\n-        return thisBuilder();\n-    }\n-\n-    protected int labelOffset(CharSequence label) {\n-        int pc = code.offset - 1;\n-        Integer labelPc = labels.get(label);\n-        if (labelPc == null) {\n-            addPendingJump(label, pc);\n-        }\n-        return labelPc == null ? 0 : (labelPc - pc);\n-    }\n-\n-    public C label(CharSequence s) {\n-        int pc = code.offset;\n-        Object old = labels.put(s, pc);\n-        if (old != null) {\n-            throw new IllegalStateException(\"label already exists\");\n-        }\n-        resolveJumps(s, pc);\n-        return thisBuilder();\n-    }\n-\n-    \/\/FIXME: address this jumpy mess - i.e. offset and state update work against each other!\n-    public C emitCondJump(Opcode opcode, CondKind ck, CharSequence label) {\n-        return emitCondJump(opcode.at(ck), opcode.at(ck.negate()), label);\n-    }\n-\n-    public C emitCondJump(Opcode pos, Opcode neg, CharSequence label) {\n-        if (jumpMode == JumpMode.NARROW) {\n-            emitOp(pos);\n-            emitOffset(code, jumpMode, labelOffset(label));\n-        } else {\n-            emitOp(neg);\n-            emitOffset(code, JumpMode.NARROW, 8);\n-            goto_w(labelOffset(label));\n-        }\n-        return thisBuilder();\n-    }\n-\n-    void addPendingJump(CharSequence label, int pc) {\n-        pendingJumps.add(new PendingJump(label, pc));\n-    }\n-\n-    void resolveJumps(CharSequence label, int pc) {\n-        Iterator<PendingJump> jumpsIt = pendingJumps.iterator();\n-        while (jumpsIt.hasNext()) {\n-            PendingJump jump = jumpsIt.next();\n-            if (jump.resolve(label, pc)) {\n-                jumpsIt.remove();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected void emitOffset(GrowableByteBuffer buf, JumpMode jumpMode, int offset) {\n-        if (jumpMode == JumpMode.NARROW && (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE)) {\n-            throw new WideJumpException();\n-        }\n-        super.emitOffset(buf, jumpMode, offset);\n-    }\n-\n-    public C jsr(CharSequence label) {\n-        emitOp(jumpMode == JumpMode.NARROW ? Opcode.JSR : Opcode.JSR_W);\n-        emitOffset(code, jumpMode, labelOffset(label));\n-        return thisBuilder();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public C withTry(Consumer<? super C> tryBlock, Consumer<? super CatchBuilder> catchBlocks) {\n-        int start = code.offset;\n-        tryBlock.accept((C) this);\n-        int end = code.offset;\n-        CatchBuilder catchBuilder = makeCatchBuilder(start, end);\n-        catchBlocks.accept(catchBuilder);\n-        catchBuilder.build();\n-        return thisBuilder();\n-    }\n-\n-    void clear() {\n-        code.offset = 0;\n-        catchers.offset = 0;\n-        ncatchers = 0;\n-        labels.clear();\n-        pendingJumps = null;\n-    }\n-\n-    protected CatchBuilder makeCatchBuilder(int start, int end) {\n-        return new CatchBuilder(start, end);\n-    }\n-\n-    public class CatchBuilder {\n-        int start, end;\n-\n-        String endLabel = labelName();\n-\n-        Map<S, Consumer<? super C>> catchers = new LinkedHashMap<>();\n-        public Consumer<? super C> finalizer;\n-        List<Integer> pendingGaps = new ArrayList<>();\n-\n-        public CatchBuilder(int start, int end) {\n-            this.start = start;\n-            this.end = end;\n-        }\n-\n-        public CatchBuilder withCatch(S exc, Consumer<? super C> catcher) {\n-            catchers.put(exc, catcher);\n-            return this;\n-        }\n-\n-        public CatchBuilder withFinally(Consumer<? super C> finalizer) {\n-            this.finalizer = finalizer;\n-            return this;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        void build() {\n-            if (finalizer != null) {\n-                finalizer.accept((C) MacroCodeBuilder.this);\n-            }\n-            goto_(endLabel);\n-            for (Map.Entry<S, Consumer<? super C>> catcher_entry : catchers.entrySet()) {\n-                emitCatch(catcher_entry.getKey(), catcher_entry.getValue());\n-            }\n-            if (finalizer != null) {\n-                emitFinalizer();\n-            }\n-            resolveJumps(endLabel, code.offset);\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        protected void emitCatch(S exc, Consumer<? super C> catcher) {\n-            int offset = code.offset;\n-            MacroCodeBuilder.this.withCatch(exc, start, end, offset);\n-            catcher.accept((C) MacroCodeBuilder.this);\n-            if (finalizer != null) {\n-                int startFinalizer = code.offset;\n-                finalizer.accept((C) MacroCodeBuilder.this);\n-                pendingGaps.add(startFinalizer);\n-                pendingGaps.add(code.offset);\n-            }\n-            goto_(endLabel);\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        protected void emitFinalizer() {\n-            int offset = code.offset;\n-            pop();\n-            for (int i = 0; i < pendingGaps.size(); i += 2) {\n-                MacroCodeBuilder.this.withCatch(null, pendingGaps.get(i), pendingGaps.get(i + 1), offset);\n-            }\n-            MacroCodeBuilder.this.withCatch(null, start, end, offset);\n-            finalizer.accept((C) MacroCodeBuilder.this);\n-        }\n-\n-\/\/        @SuppressWarnings(\"unchecked\")\n-\/\/        CatchBuilder withCatch(S exc, Consumer<? super C> catcher) {\n-\/\/            int offset = code.offset;\n-\/\/            MacroCodeBuilder.this.withCatch(exc, start, end, offset);\n-\/\/            catcher.accept((C)MacroCodeBuilder.this);\n-\/\/            return this;\n-\/\/        }\n-\/\/\n-\/\/        @SuppressWarnings(\"unchecked\")\n-\/\/        CatchBuilder withFinally(Consumer<? super C> catcher) {\n-\/\/            int offset = code.offset;\n-\/\/            MacroCodeBuilder.this.withCatch(null, start, end, offset);\n-\/\/            catcher.accept((C)MacroCodeBuilder.this);\n-\/\/            return this;\n-\/\/        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public C switch_(Consumer<? super SwitchBuilder> consumer) {\n-        int start = code.offset;\n-        SwitchBuilder sb = makeSwitchBuilder();\n-        consumer.accept(sb);\n-        int nlabels = sb.cases.size();\n-        switch (sb.switchCode()) {\n-            case LOOKUPSWITCH: {\n-                int[] lookupOffsets = new int[nlabels * 2];\n-                int i = 0;\n-                for (Integer v : sb.cases.keySet()) {\n-                    lookupOffsets[i] = v;\n-                    i += 2;\n-                }\n-                lookupswitch(0, lookupOffsets);\n-                \/\/backpatch lookup\n-                int curr = code.offset - (8 * nlabels) - 8;\n-                int defaultOffset = code.offset - start;\n-                code.withOffset(curr, buf -> emitOffset(buf, JumpMode.WIDE, defaultOffset));\n-                sb.defaultCase.accept((C) this);\n-                curr += 12;\n-                for (Consumer<? super C> case_ : sb.cases.values()) {\n-                    int offset = code.offset;\n-                    code.withOffset(curr, buf -> emitOffset(buf, JumpMode.WIDE, offset - start));\n-                    case_.accept((C) this);\n-                    curr += 8;\n-                }\n-                break;\n-            }\n-            case TABLESWITCH: {\n-                int[] tableOffsets = new int[sb.hi - sb.lo + 1];\n-                tableswitch(sb.lo, sb.hi, 0, tableOffsets);\n-                \/\/backpatch table\n-                int curr = code.offset - (4 * tableOffsets.length) - 12;\n-                int defaultOffset = code.offset - start;\n-                code.withOffset(curr, buf -> emitOffset(buf, JumpMode.WIDE, defaultOffset));\n-                sb.defaultCase.accept((C) this);\n-                curr += 12;\n-                int lastCasePc = -1;\n-                for (int i = sb.lo; i <= sb.hi; i++) {\n-                    Consumer<? super C> case_ = sb.cases.get(i);\n-                    if (case_ != null) {\n-                        lastCasePc = code.offset;\n-                        case_.accept((C) this);\n-                    }\n-                    int offset = lastCasePc - start;\n-                    code.withOffset(curr, buf -> emitOffset(buf, JumpMode.WIDE, offset));\n-                    curr += 4;\n-                }\n-            }\n-        }\n-        resolveJumps(sb.endLabel, code.offset);\n-        return thisBuilder();\n-    }\n-\n-    private static int labelCount = 0;\n-\n-    String labelName() {\n-        return \"label\" + labelCount++;\n-    }\n-\n-    protected SwitchBuilder makeSwitchBuilder() {\n-        return new SwitchBuilder();\n-    }\n-\n-    public class SwitchBuilder {\n-        Map<Integer, Consumer<? super C>> cases = new TreeMap<>();\n-        int lo = Integer.MAX_VALUE;\n-        int hi = Integer.MIN_VALUE;\n-        String endLabel = labelName();\n-\n-        public Consumer<? super C> defaultCase;\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public SwitchBuilder withCase(int value, Consumer<? super C> case_, boolean fallthrough) {\n-            if (value > hi) {\n-                hi = value;\n-            }\n-            if (value < lo) {\n-                lo = value;\n-            }\n-            if (!fallthrough) {\n-                Consumer<? super C> prevCase = case_;\n-                case_ = C -> {\n-                    prevCase.accept(C);\n-                    C.goto_(endLabel);\n-                };\n-            }\n-            cases.put(value, case_);\n-            return this;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        public SwitchBuilder withDefault(Consumer<? super C> defaultCase) {\n-            if (this.defaultCase != null) {\n-                throw new IllegalStateException(\"default already set\");\n-            }\n-            this.defaultCase = defaultCase;\n-            return this;\n-        }\n-\n-        Opcode switchCode() {\n-            int nlabels = cases.size();\n-            \/\/ Determine whether to issue a tableswitch or a lookupswitch\n-            \/\/ instruction.\n-            long table_space_cost = 4 + ((long) hi - lo + 1); \/\/ words\n-            long lookup_space_cost = 3 + 2 * (long) nlabels;\n-            return\n-                    nlabels > 0 &&\n-                            table_space_cost <= lookup_space_cost\n-                            ?\n-                            Opcode.TABLESWITCH : Opcode.LOOKUPSWITCH;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/MacroCodeBuilder.java","additions":0,"deletions":688,"binary":false,"changes":688,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-\/**\n- * Class member builder.\n- *\n- * @param <S> the type of symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <E> the type of pool entries\n- * @param <M> the type of this builder\n- *\/\n-public class MemberBuilder<S, T, E, M extends MemberBuilder<S, T, E, M>> extends DeclBuilder<S, T, E, M> {\n-\n-    CharSequence name;\n-    T desc;\n-\n-    \/**\n-     * Create a member builder.\n-     *\n-     * @param name the name of the class member\n-     * @param type the type descriptor of the class member\n-     * @param poolHelper the helper to build the constant pool\n-     * @param typeHelper the helper to use to manipulate type descriptors\n-     *\/\n-    MemberBuilder(CharSequence name, T type, PoolHelper<S, T, E> poolHelper, TypeHelper<S, T> typeHelper) {\n-        super(poolHelper, typeHelper);\n-        this.name = name;\n-        this.desc = type;\n-    }\n-\n-    \/**\n-     * Build the member.\n-     *\n-     * @param buf the {@code GrowableByteBuffer} to build the member into\n-     *\/\n-    protected void build(GrowableByteBuffer buf) {\n-        addAnnotations();\n-        buf.writeChar(flags);\n-        buf.writeChar(poolHelper.putUtf8(name));\n-        buf.writeChar(poolHelper.putType(desc));\n-        buf.writeChar(nattrs);\n-        buf.writeBytes(attributes);\n-    }\n-\n-    \/**\n-     * Build the member.\n-     *\n-     * @return a byte array representation of the member\n-     *\/\n-    protected byte[] build() {\n-        GrowableByteBuffer buf = new GrowableByteBuffer();\n-        addAnnotations();\n-        build(buf);\n-        return buf.bytes();\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/MemberBuilder.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,156 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import jdk.experimental.bytecode.CodeBuilder.JumpMode;\n-\n-import java.util.Iterator;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n-public class MethodBuilder<S, T, E> extends MemberBuilder<S, T, E, MethodBuilder<S, T, E>> {\n-\n-    S thisClass;\n-    ParameterAnnotationsBuilder runtimeVisibleParameterAnnotations;\n-    ParameterAnnotationsBuilder runtimeInvisibleParameterAnnotations;\n-\n-    public MethodBuilder(S thisClass, CharSequence name, T type, PoolHelper<S, T, E> pool, TypeHelper<S, T> typeHelper) {\n-        super(name, type, pool, typeHelper);\n-        this.thisClass = thisClass;\n-    }\n-\n-    public <C extends CodeBuilder<S, T, E, ?>> MethodBuilder<S, T, E> withCode(Function<? super MethodBuilder<S, T, E>, ? extends C> func,\n-                                                                               Consumer<? super C> code) {\n-        C codeBuilder = func.apply(this);\n-        int start = attributes.offset;\n-        try {\n-            code.accept(codeBuilder);\n-        } catch (MacroCodeBuilder.WideJumpException ex) {\n-            \/\/wide jumps! Redo the code\n-            ((MacroCodeBuilder<S, T, E, ?>) codeBuilder).jumpMode = JumpMode.WIDE;\n-            ((MacroCodeBuilder<S, T, E, ?>) codeBuilder).clear();\n-            code.accept(codeBuilder);\n-        }\n-\n-        attributes.writeChar(poolHelper.putUtf8(\"Code\"));\n-        attributes.writeInt(0);\n-        codeBuilder.build(attributes);\n-        int length = attributes.offset - start;\n-        \/\/avoid using lambda here\n-        int prevOffset = attributes.offset;\n-        try {\n-            attributes.offset = start + 2;\n-            attributes.writeInt(length - 6);\n-        } finally {\n-            attributes.offset = prevOffset;\n-        }\n-        nattrs++;\n-        return this;\n-    }\n-\n-    public MethodBuilder<S, T, E> withCode(Consumer<? super CodeBuilder<S, T, E, ?>> code) {\n-        return withCode(CodeBuilder::new, code);\n-    }\n-\n-    @SuppressWarnings({\"varargs\", \"unchecked\"})\n-    public MethodBuilder<S, T, E> withExceptions(S... exceptions) {\n-        attributes.writeChar(poolHelper.putUtf8(\"Exceptions\"));\n-        attributes.writeInt(2 + (2 * exceptions.length));\n-        attributes.writeChar(exceptions.length);\n-        for (S exception : exceptions) {\n-            attributes.writeChar(poolHelper.putClass(exception));\n-        }\n-        nattrs++;\n-        return this;\n-    }\n-\n-    public MethodBuilder<S, T, E> withParameterAnnotation(AnnotationsBuilder.Kind kind, int nparam, T annoType) {\n-        getParameterAnnotations(kind).builders[nparam].withAnnotation(annoType, null);\n-        return this;\n-    }\n-\n-    public MethodBuilder<S, T, E> withParameterAnnotation(AnnotationsBuilder.Kind kind, int nparam, T annoType, Consumer<? super AnnotationsBuilder<S, T, E>.AnnotationElementBuilder> annotations) {\n-        getParameterAnnotations(kind).builders[nparam].withAnnotation(annoType, annotations);\n-        return this;\n-    }\n-\n-    private ParameterAnnotationsBuilder getParameterAnnotations(AnnotationsBuilder.Kind kind) {\n-        switch (kind) {\n-            case RUNTIME_INVISIBLE:\n-                if (runtimeInvisibleParameterAnnotations == null) {\n-                    runtimeInvisibleParameterAnnotations = new ParameterAnnotationsBuilder();\n-                }\n-                return runtimeInvisibleParameterAnnotations;\n-            case RUNTIME_VISIBLE:\n-                if (runtimeVisibleParameterAnnotations == null) {\n-                    runtimeVisibleParameterAnnotations = new ParameterAnnotationsBuilder();\n-                }\n-                return runtimeVisibleParameterAnnotations;\n-        }\n-        throw new IllegalStateException();\n-    }\n-\n-    class ParameterAnnotationsBuilder {\n-\n-        GrowableByteBuffer parameterAnnos = new GrowableByteBuffer();\n-\n-        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-        AnnotationsBuilder<S, T, E>[] builders = new AnnotationsBuilder[nparams()];\n-\n-        ParameterAnnotationsBuilder() {\n-            for (int i = 0; i < builders.length; i++) {\n-                builders[i] = new AnnotationsBuilder<>(poolHelper, typeHelper);\n-            }\n-        }\n-\n-        byte[] build() {\n-            parameterAnnos.writeByte(builders.length);\n-            for (AnnotationsBuilder<S, T, E> builder : builders) {\n-                parameterAnnos.writeBytes(builder.build());\n-            }\n-            return parameterAnnos.bytes();\n-        }\n-\n-        int nparams() {\n-            Iterator<T> paramsIt = typeHelper.parameterTypes(desc);\n-            int nparams = 0;\n-            while (paramsIt.hasNext()) {\n-                paramsIt.next();\n-                nparams++;\n-            }\n-            return nparams;\n-        }\n-    }\n-\n-    @Override\n-    void addAnnotations() {\n-        super.addAnnotations();\n-        if (runtimeInvisibleParameterAnnotations != null) {\n-            withAttribute(\"RuntimeInvisibleParameterAnnotations\", runtimeInvisibleParameterAnnotations.build());\n-        }\n-        if (runtimeVisibleParameterAnnotations != null) {\n-            withAttribute(\"RuntimeVisibleParameterAnnotations\", runtimeVisibleParameterAnnotations.build());\n-        }\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/MethodBuilder.java","additions":0,"deletions":156,"binary":false,"changes":156,"status":"deleted"},{"patch":"@@ -1,258 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import jdk.experimental.bytecode.MacroCodeBuilder.CondKind;\n-\n-public enum Opcode {\n-\n-    NOP(0),\n-    ACONST_NULL(1),\n-    ICONST_M1(2),\n-    ICONST_0(3),\n-    ICONST_1(4),\n-    ICONST_2(5),\n-    ICONST_3(6),\n-    ICONST_4(7),\n-    ICONST_5(8),\n-    LCONST_0(9),\n-    LCONST_1(10),\n-    FCONST_0(11),\n-    FCONST_1(12),\n-    FCONST_2(13),\n-    DCONST_0(14),\n-    DCONST_1(15),\n-    BIPUSH(16),\n-    SIPUSH(17),\n-    LDC(18),\n-    LDC_W(19),\n-    LDC2_W(20),\n-    ILOAD(21),\n-    LLOAD(22),\n-    FLOAD(23),\n-    DLOAD(24),\n-    ALOAD(25),\n-    ILOAD_0(26),\n-    ILOAD_1(27),\n-    ILOAD_2(28),\n-    ILOAD_3(29),\n-    LLOAD_0(30),\n-    LLOAD_1(31),\n-    LLOAD_2(32),\n-    LLOAD_3(33),\n-    FLOAD_0(34),\n-    FLOAD_1(35),\n-    FLOAD_2(36),\n-    FLOAD_3(37),\n-    DLOAD_0(38),\n-    DLOAD_1(39),\n-    DLOAD_2(40),\n-    DLOAD_3(41),\n-    ALOAD_0(42),\n-    ALOAD_1(43),\n-    ALOAD_2(44),\n-    ALOAD_3(45),\n-    IALOAD(46),\n-    LALOAD(47),\n-    FALOAD(48),\n-    DALOAD(49),\n-    AALOAD(50),\n-    BALOAD(51),\n-    CALOAD(52),\n-    SALOAD(53),\n-    ISTORE(54),\n-    LSTORE(55),\n-    FSTORE(56),\n-    DSTORE(57),\n-    ASTORE(58),\n-    ISTORE_0(59),\n-    ISTORE_1(60),\n-    ISTORE_2(61),\n-    ISTORE_3(62),\n-    LSTORE_0(63),\n-    LSTORE_1(64),\n-    LSTORE_2(65),\n-    LSTORE_3(66),\n-    FSTORE_0(67),\n-    FSTORE_1(68),\n-    FSTORE_2(69),\n-    FSTORE_3(70),\n-    DSTORE_0(71),\n-    DSTORE_1(72),\n-    DSTORE_2(73),\n-    DSTORE_3(74),\n-    ASTORE_0(75),\n-    ASTORE_1(76),\n-    ASTORE_2(77),\n-    ASTORE_3(78),\n-    IASTORE(79),\n-    LASTORE(80),\n-    FASTORE(81),\n-    DASTORE(82),\n-    AASTORE(83),\n-    BASTORE(84),\n-    CASTORE(85),\n-    SASTORE(86),\n-    POP(87),\n-    POP2(88),\n-    DUP(89),\n-    DUP_X1(90),\n-    DUP_X2(91),\n-    DUP2(92),\n-    DUP2_X1(93),\n-    DUP2_X2(94),\n-    SWAP(95),\n-    IADD(96),\n-    LADD(97),\n-    FADD(98),\n-    DADD(99),\n-    ISUB(100),\n-    LSUB(101),\n-    FSUB(102),\n-    DSUB(103),\n-    IMUL(104),\n-    LMUL(105),\n-    FMUL(106),\n-    DMUL(107),\n-    IDIV(108),\n-    LDIV(109),\n-    FDIV(110),\n-    DDIV(111),\n-    IREM(112),\n-    LREM(113),\n-    FREM(114),\n-    DREM(115),\n-    INEG(116),\n-    LNEG(117),\n-    FNEG(118),\n-    DNEG(119),\n-    ISHL(120),\n-    LSHL(121),\n-    ISHR(122),\n-    LSHR(123),\n-    IUSHR(124),\n-    LUSHR(125),\n-    IAND(126),\n-    LAND(127),\n-    IOR(128),\n-    LOR(129),\n-    IXOR(130),\n-    LXOR(131),\n-    IINC(132),\n-    I2L(133),\n-    I2F(134),\n-    I2D(135),\n-    L2I(136),\n-    L2F(137),\n-    L2D(138),\n-    F2I(139),\n-    F2L(140),\n-    F2D(141),\n-    D2I(142),\n-    D2L(143),\n-    D2F(144),\n-    I2B(145),\n-    I2C(146),\n-    I2S(147),\n-    LCMP(148),\n-    FCMPL(149),\n-    FCMPG(150),\n-    DCMPL(151),\n-    DCMPG(152),\n-    IFEQ(153),\n-    IFNE(154),\n-    IFLT(155),\n-    IFGE(156),\n-    IFGT(157),\n-    IFLE(158),\n-    IF_ICMPEQ(159),\n-    IF_ICMPNE(160),\n-    IF_ICMPLT(161),\n-    IF_ICMPGE(162),\n-    IF_ICMPGT(163),\n-    IF_ICMPLE(164),\n-    IF_ACMPEQ(165),\n-    IF_ACMPNE(166),\n-    GOTO_(167),\n-    JSR(168),\n-    RET(169),\n-    TABLESWITCH(170),\n-    LOOKUPSWITCH(171),\n-    IRETURN(172),\n-    LRETURN(173),\n-    FRETURN(174),\n-    DRETURN(175),\n-    ARETURN(176),\n-    RETURN(177),\n-    GETSTATIC(178),\n-    PUTSTATIC(179),\n-    GETFIELD(180),\n-    PUTFIELD(181),\n-    INVOKEVIRTUAL(182),\n-    INVOKESPECIAL(183),\n-    INVOKESTATIC(184),\n-    INVOKEINTERFACE(185),\n-    INVOKEDYNAMIC(186),\n-    NEW(187),\n-    NEWARRAY(188),\n-    ANEWARRAY(189),\n-    ARRAYLENGTH(190),\n-    ATHROW(191),\n-    CHECKCAST(192),\n-    INSTANCEOF(193),\n-    MONITORENTER(194),\n-    MONITOREXIT(195),\n-    WIDE(196),\n-    MULTIANEWARRAY(197),\n-    IF_NULL(198),\n-    IF_NONNULL(199),\n-    GOTO_W(200),\n-    JSR_W(201),\n-    ACONST_INIT(203),\n-    WITHFIELD(204);\n-\n-\n-    int code;\n-\n-    Opcode(int code) {\n-        this.code = code;\n-    }\n-\n-    protected Opcode at(TypeTag type) {\n-        return at(type, 1);\n-    }\n-\n-    protected Opcode at(CondKind cond) {\n-        return at(cond.offset, 1);\n-    }\n-\n-    protected Opcode at(TypeTag type, int multiplier) {\n-        return at(type.offset, multiplier);\n-    }\n-\n-    private Opcode at(int offset, int multiplier) {\n-        if (offset < 0) throw new AssertionError();\n-        return Opcode.values()[code + (multiplier * offset)];\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/Opcode.java","additions":0,"deletions":258,"binary":false,"changes":258,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.function.Consumer;\n-import java.util.function.ToIntBiFunction;\n-\n-\/**\n- * An interface for building and tracking constant pools.\n- *\n- * @param <S> the type of the symbol representation\n- * @param <T> the type of type descriptors representation\n- * @param <E> the type of pool entries\n- *\/\n-public interface PoolHelper<S, T, E> {\n-    int putClass(S symbol);\n-\n-    int putInlineClass(S symbol);\n-\n-    int putFieldRef(S owner, CharSequence name, T type);\n-\n-    int putMethodRef(S owner, CharSequence name, T type, boolean isInterface);\n-\n-    int putUtf8(CharSequence s);\n-\n-    int putInt(int i);\n-\n-    int putFloat(float f);\n-\n-    int putLong(long l);\n-\n-    int putDouble(double d);\n-\n-    int putString(String s);\n-\n-    int putType(T t);\n-\n-    int putMethodType(T t);\n-\n-    int putHandle(int refKind, S owner, CharSequence name, T type);\n-\n-    int putHandle(int refKind, S owner, CharSequence name, T type, boolean isInterface);\n-\n-    int putInvokeDynamic(CharSequence invokedName, T invokedType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgs);\n-\n-    int putDynamicConstant(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgs);\n-\n-    int size();\n-\n-    E entries();\n-\n-    interface StaticArgListBuilder<S, T, E> {\n-        StaticArgListBuilder<S, T, E> add(int i);\n-        StaticArgListBuilder<S, T, E> add(float f);\n-        StaticArgListBuilder<S, T, E> add(long l);\n-        StaticArgListBuilder<S, T, E> add(double d);\n-        StaticArgListBuilder<S, T, E> add(String s);\n-        StaticArgListBuilder<S, T, E> add(int refKind, S owner, CharSequence name, T type);\n-        <Z> StaticArgListBuilder<S, T, E> add(Z z, ToIntBiFunction<PoolHelper<S, T, E>, Z> poolFunc);\n-        StaticArgListBuilder<S, T, E> add(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgList);\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/PoolHelper.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-public enum PoolTag {\n-    CONSTANT_UTF8(1),\n-    CONSTANT_UNICODE(2),\n-    CONSTANT_INTEGER(3),\n-    CONSTANT_FLOAT(4),\n-    CONSTANT_LONG(5),\n-    CONSTANT_DOUBLE(6),\n-    CONSTANT_CLASS(7),\n-    CONSTANT_STRING(8),\n-    CONSTANT_FIELDREF(9),\n-    CONSTANT_METHODREF(10),\n-    CONSTANT_INTERFACEMETHODREF(11),\n-    CONSTANT_NAMEANDTYPE(12),\n-    CONSTANT_METHODHANDLE(15),\n-    CONSTANT_METHODTYPE(16),\n-    CONSTANT_DYNAMIC(17),\n-    CONSTANT_INVOKEDYNAMIC(18);\n-\n-    public final int tag;\n-\n-    PoolTag(int tag) {\n-        this.tag = tag;\n-    }\n-\n-    static PoolTag from(int tag) {\n-        return values()[tag - 1];\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/PoolTag.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-public interface Type {\n-    TypeTag getTag();\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/Type.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.Iterator;\n-\n-\/**\n- * Helper to create and manipulate type descriptors of T.\n- *\n- * @param <S> the type of symbols\n- * @param <T> the type of type descriptors\n- *\/\n-public interface TypeHelper<S, T> {\n-    \/**\n-     * Return the type descriptor of an element given the type\n-     * descriptor of an array.\n-     *\n-     * @param t the type descriptor of the array\n-     * @return the element type\n-     *\/\n-    T elemtype(T t);\n-\n-    \/**\n-     * Return the type descriptor of an array given the type descriptor\n-     * of an element.\n-     *\n-     * @param t the type descriptor of the element\n-     * @return the type descriptor of the array\n-     *\/\n-    T arrayOf(T t);\n-\n-    \/**\n-     * Return an iterator over the type descriptors of the parameters of a\n-     * method.\n-       *\n-     * @param t the method type descriptor\n-     * @return an iterator over the type descriptors of the parameters\n-     *\/\n-    Iterator<T> parameterTypes(T t);\n-\n-    \/**\n-     * Return the type descriptor of a {@code TypeTag}.\n-     *\n-     * @param tag the {@code TypeTag} of a primitive type\n-     * @return the type descriptor of the primitive type\n-     *\/\n-    T fromTag(TypeTag tag);\n-\n-    \/**\n-     * Return the return type descriptor of a method.\n-     *\n-     * @param t the method type descriptor\n-     * @return the return type descriptor\n-     *\/\n-    T returnType(T t);\n-\n-    \/**\n-     * Return the type descriptor for a symbol.\n-     *\n-     * @param s the symbol\n-     * @return the type descriptor\n-     *\/\n-    T type(S s);\n-\n-    \/**\n-     * Return the symbol corresponding to a type descriptor.\n-     *\n-     * @param type the type descriptor\n-     * @return the symbol\n-     *\/\n-    S symbol(T type);\n-\n-    \/**\n-     * Return the {@code TypeTag} corresponding to a type descriptor.  Reference\n-     * types return {@code TypeTag.A}.\n-     *\n-     * @param t a type descriptor\n-     * @return the corresponding {@code TypeTag}\n-     *\/\n-    TypeTag tag(T t);\n-\n-    \/**\n-     * Return the symbol corresponding to a JVM type descriptor string.\n-     *\n-     * @param s a JVM type descriptor string\n-     * @return the corresponding symbol\n-     *\/\n-    S symbolFrom(String s);\n-\n-    \/**\n-     * Return the common supertype descriptor of two type descriptors.\n-     *\n-     * @param t1 a type descriptor\n-     * @param t2 a type descriptor\n-     * @return the common supertype descriptor\n-     *\/\n-    T commonSupertype(T t1, T t2);\n-\n-    \/**\n-     * Return the type descriptor for the null type.\n-     *\n-     * @return the type descriptor for the null type\n-     *\/\n-    T nullType();\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/TypeHelper.java","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-public enum TypeTag implements Type {\n-    \/**\n-     * byte\n-     *\/\n-    B(\"B\", 0, 1, 8),\n-    \/**\n-     * short\n-     *\/\n-    S(\"S\", 0, 1, 9),\n-    \/**\n-     * int\n-     *\/\n-    I(\"I\", 0, 1, 10),\n-    \/**\n-     * float\n-     *\/\n-    F(\"F\", 2, 1, 6),\n-    \/**\n-     * long\n-     *\/\n-    J(\"J\", 1, 2, 11),\n-    \/**\n-     * double\n-     *\/\n-    D(\"D\", 3, 2, 7),\n-    \/**\n-     * Reference type\n-     *\/\n-    A(\"A\", 4, 1, -1),\n-    \/**\n-     * char\n-     *\/\n-    C(\"C\", 0, 1, 5),\n-    \/**\n-     * boolean\n-     *\/\n-    Z(\"Z\", 0, 1, 4),\n-    \/**\n-     * void\n-     *\/\n-    V(\"V\", -1, -1, -1),\n-    \/**\n-     * Value type\n-     *\/\n-    Q(\"Q\", -1, 1, -1);\n-\n-    String typeStr;\n-    int offset;\n-    int width;\n-    int newarraycode;\n-\n-    TypeTag(String typeStr, int offset, int width, int newarraycode) {\n-        this.typeStr = typeStr;\n-        this.offset = offset;\n-        this.width = width;\n-        this.newarraycode = newarraycode;\n-    }\n-\n-    static TypeTag commonSupertype(TypeTag t1, TypeTag t2) {\n-        if (t1.isIntegral() && t2.isIntegral()) {\n-            int p1 = t1.ordinal();\n-            int p2 = t2.ordinal();\n-            return (p1 <= p2) ? t2 : t1;\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    public int width() {\n-        return width;\n-    }\n-\n-    boolean isIntegral() {\n-        switch (this) {\n-            case B:\n-            case S:\n-            case I:\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    public TypeTag getTag() {\n-        return this;\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/TypeTag.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,1133 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.experimental.bytecode;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Vector;\n-import java.util.function.Consumer;\n-import java.util.function.Supplier;\n-import java.util.function.ToIntFunction;\n-\n-public class TypedCodeBuilder<S, T, E, C extends TypedCodeBuilder<S, T, E, C>> extends MacroCodeBuilder<S, T, E, C> {\n-\n-    State lastStackMapState;\n-    int lastStackMapPc = -1;\n-    Map<CharSequence, LocalVarInfo> lvarOffsets = new HashMap<>();\n-    protected State state;\n-    int depth = 0;\n-    int currLocalOffset = 0;\n-\n-    class StatefulPendingJump extends PendingJump {\n-\n-        State state;\n-\n-        StatefulPendingJump(CharSequence label, int pc, State state) {\n-            super(label, pc);\n-            this.state = state;\n-        }\n-\n-        @Override\n-        boolean resolve(CharSequence label, int pc) {\n-            boolean b = super.resolve(label, pc);\n-            if (b) {\n-                TypedCodeBuilder.this.state = TypedCodeBuilder.this.state.merge(state);\n-            }\n-            return b;\n-        }\n-    }\n-\n-    class LocalVarInfo {\n-        CharSequence name;\n-        int offset;\n-        int depth;\n-        TypeTag type;\n-\n-        LocalVarInfo(CharSequence name, int offset, int depth, TypeTag type) {\n-            this.name = name;\n-            this.offset = offset;\n-            this.depth = depth;\n-            this.type = type;\n-        }\n-    }\n-\n-    public TypedCodeBuilder(MethodBuilder<S, T, E> methodBuilder) {\n-        super(methodBuilder);\n-        T t = methodBuilder.desc;\n-        state = new State();\n-        if ((methodBuilder.flags & Flag.ACC_STATIC.flag) == 0) {\n-            T clazz = typeHelper.type(methodBuilder.thisClass);\n-            state.load(clazz, currLocalOffset++); \/\/TODO: uninit??\n-        }\n-        Iterator<T> paramsIt = typeHelper.parameterTypes(t);\n-        while (paramsIt.hasNext()) {\n-            T p = paramsIt.next();\n-            state.load(p, currLocalOffset);\n-            currLocalOffset += typeHelper.tag(p).width;\n-        }\n-        lastStackMapState = state.dup();\n-        stacksize = state.stack.size();\n-        localsize = state.locals.size();\n-    }\n-\n-    @Override\n-    protected C emitOp(Opcode opcode, Object optPoolValue) {\n-        updateState(opcode, optPoolValue);\n-        return super.emitOp(opcode, optPoolValue);\n-    }\n-\n-    @Override\n-    protected SwitchBuilder makeSwitchBuilder() {\n-        return new TypedSwitchBuilder();\n-    }\n-\n-    class TypedSwitchBuilder extends SwitchBuilder {\n-\n-        @Override\n-        public SwitchBuilder withCase(int value, Consumer<? super C> case_, boolean fallthrough) {\n-            super.withCase(value, c -> {\n-                withLocalScope(() -> {\n-                    State prevState = state;\n-                    state = prevState.dup();\n-                    emitStackMap(c.offset());\n-                    case_.accept(c);\n-                    state = prevState;\n-                });\n-            }, fallthrough);\n-            return this;\n-        }\n-\n-        @Override\n-        public SwitchBuilder withDefault(Consumer<? super C> defaultCase) {\n-            super.withDefault(c -> {\n-                withLocalScope(() -> {\n-                    State prevState = state;\n-                    state = prevState.dup();\n-                    emitStackMap(c.offset());\n-                    defaultCase.accept(c);\n-                    state = prevState;\n-                });\n-            });\n-            return this;\n-        }\n-    }\n-\n-    public class State {\n-        public final ArrayList<T> stack;\n-        public final Vector<T> locals;\n-        boolean alive;\n-\n-        State(ArrayList<T> stack, Vector<T> locals) {\n-            this.stack = stack;\n-            this.locals = locals;\n-        }\n-\n-        State() {\n-            this(new ArrayList<>(), new Vector<>());\n-        }\n-\n-        void push(TypeTag tag) {\n-            switch (tag) {\n-                case A:\n-                case V:\n-                    throw new IllegalStateException(\"Bad type tag\");\n-                default:\n-                    push(typeHelper.fromTag(tag));\n-            }\n-        }\n-\n-        void push(T t) {\n-            stack.add(t);\n-            if (width(t) == 2) {\n-                stack.add(null);\n-            }\n-            if (stack.size() > stacksize) {\n-                stacksize = stack.size();\n-            }\n-        }\n-\n-        T peek() {\n-            return stack.get(stack.size() - 1);\n-        }\n-\n-        T tosType() {\n-            T tos = peek();\n-            if (tos == null) {\n-                \/\/double slot\n-                tos = stack.get(stack.size() - 2);\n-            }\n-            return tos;\n-        }\n-\n-        T popInternal() {\n-            return stack.remove(stack.size() - 1);\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        T pop() {\n-            if (stack.size() == 0 || peek() == null) throw new IllegalStateException();\n-            return popInternal();\n-        }\n-\n-        T pop2() {\n-            T o = stack.get(stack.size() - 2);\n-            TypeTag t = typeHelper.tag(o);\n-            if (t.width != 2) throw new IllegalStateException();\n-            popInternal();\n-            popInternal();\n-            return o;\n-        }\n-\n-        T pop(TypeTag t) {\n-            return (t.width() == 2) ?\n-                pop2() : pop();\n-        }\n-\n-        void load(TypeTag tag, int index) {\n-            if (tag == TypeTag.A) throw new IllegalStateException(\"Bad type tag\");\n-            load(typeHelper.fromTag(tag), index);\n-        }\n-\n-        void load(T t, int index) {\n-            ensureDefined(index);\n-            locals.set(index, t);\n-            if (width(t) == 2) {\n-                locals.add(null);\n-            }\n-            if (locals.size() > localsize) {\n-                localsize = locals.size();\n-            }\n-        }\n-\n-        void ensureDefined(int index) {\n-            if (index >= locals.size()) {\n-                locals.setSize(index + 1);\n-            }\n-        }\n-\n-        State dup() {\n-            State newState = new State(new ArrayList<>(stack), new Vector<>(locals));\n-            return newState;\n-        }\n-\n-        State merge(State that) {\n-            if (!alive) { return that; }\n-            if (that.stack.size() != stack.size()) {\n-                throw new IllegalStateException(\"Bad stack size at merge point\");\n-            }\n-            for (int i = 0; i < stack.size(); i++) {\n-                T t1 = stack.get(i);\n-                T t2 = that.stack.get(i);\n-                stack.set(i, merge(t1, t2, \"Bad stack type at merge point\"));\n-            }\n-            int nlocals = locals.size() > that.locals.size() ? that.locals.size() : locals.size();\n-            for (int i = 0; i < nlocals; i++) {\n-                T t1 = locals.get(i);\n-                T t2 = that.locals.get(i);\n-                locals.set(i, merge(t1, t2, \"Bad local type at merge point\"));\n-            }\n-            if (locals.size() > nlocals) {\n-                for (int i = nlocals; i < locals.size(); i++) {\n-                    locals.remove(i);\n-                }\n-            }\n-            return this;\n-        }\n-\n-        T merge(T t1, T t2, String msg) {\n-            if (t1 == null && t2 == null) {\n-                return t1;\n-            }\n-            T res;\n-            TypeTag tag1 = typeHelper.tag(t1);\n-            TypeTag tag2 = typeHelper.tag(t2);\n-            if (tag1 != TypeTag.A && tag2 != TypeTag.A &&\n-                    tag1 != TypeTag.Q && tag2 != TypeTag.Q) {\n-                res = typeHelper.fromTag(TypeTag.commonSupertype(tag1, tag2));\n-            } else if (t1 == typeHelper.nullType()) {\n-                res = t2;\n-            } else if (t2 == typeHelper.nullType()) {\n-                res = t1;\n-            } else {\n-                res = typeHelper.commonSupertype(t1, t2);\n-            }\n-            if (res == null) {\n-                throw new IllegalStateException(msg);\n-            }\n-            return res;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\"[locals = %s, stack = %s]\", locals, stack);\n-        }\n-    }\n-\n-    int width(T o) {\n-        return o == typeHelper.nullType() ?\n-                TypeTag.A.width() :\n-                typeHelper.tag(o).width;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public void updateState(Opcode op, Object optValue) {\n-        switch (op) {\n-            case AALOAD:\n-                state.pop();\n-                state.push(typeHelper.elemtype(state.pop()));\n-                break;\n-            case GOTO_:\n-                state.alive = false;\n-                break;\n-            case NOP:\n-            case IINC:\n-            case INEG:\n-            case LNEG:\n-            case FNEG:\n-            case DNEG:\n-                break;\n-            case ACONST_NULL:\n-                state.push(typeHelper.nullType());\n-                break;\n-            case ICONST_M1:\n-            case ICONST_0:\n-            case ICONST_1:\n-            case ICONST_2:\n-            case ICONST_3:\n-            case ICONST_4:\n-            case ICONST_5:\n-                state.push(TypeTag.I);\n-                break;\n-            case LCONST_0:\n-            case LCONST_1:\n-                state.push(TypeTag.J);\n-                break;\n-            case FCONST_0:\n-            case FCONST_1:\n-            case FCONST_2:\n-                state.push(TypeTag.F);\n-                break;\n-            case DCONST_0:\n-            case DCONST_1:\n-                state.push(TypeTag.D);\n-                break;\n-            case ILOAD_0:\n-            case FLOAD_0:\n-            case ALOAD_0:\n-            case LLOAD_0:\n-            case DLOAD_0:\n-                state.push(state.locals.get(0));\n-                break;\n-            case ILOAD_1:\n-            case FLOAD_1:\n-            case ALOAD_1:\n-            case LLOAD_1:\n-            case DLOAD_1:\n-                state.push(state.locals.get(1));\n-                break;\n-            case ILOAD_2:\n-            case FLOAD_2:\n-            case ALOAD_2:\n-            case LLOAD_2:\n-            case DLOAD_2:\n-                state.push(state.locals.get(2));\n-                break;\n-            case ILOAD_3:\n-            case FLOAD_3:\n-            case ALOAD_3:\n-            case LLOAD_3:\n-            case DLOAD_3:\n-                state.push(state.locals.get(3));\n-                break;\n-            case ILOAD:\n-            case FLOAD:\n-            case ALOAD:\n-            case LLOAD:\n-            case DLOAD:\n-                state.push(state.locals.get((Integer) optValue));\n-                break;\n-            case IALOAD:\n-            case BALOAD:\n-            case CALOAD:\n-            case SALOAD:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.I);\n-                break;\n-            case LALOAD:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.J);\n-                break;\n-            case FALOAD:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.F);\n-                break;\n-            case DALOAD:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.D);\n-                break;\n-            case ISTORE_0:\n-            case FSTORE_0:\n-            case ASTORE_0:\n-                state.load(state.pop(), 0);\n-                break;\n-            case ISTORE_1:\n-            case FSTORE_1:\n-            case ASTORE_1:\n-                state.load(state.pop(), 1);\n-                break;\n-            case ISTORE_2:\n-            case FSTORE_2:\n-            case ASTORE_2:\n-                state.load(state.pop(), 2);\n-                break;\n-            case ISTORE_3:\n-            case FSTORE_3:\n-            case ASTORE_3:\n-                state.load(state.pop(), 3);\n-                break;\n-            case ISTORE:\n-            case FSTORE:\n-            case ASTORE:\n-                state.load(state.pop(), (int) optValue);\n-                break;\n-            case LSTORE_0:\n-            case DSTORE_0:\n-                state.load(state.pop2(), 0);\n-                break;\n-            case LSTORE_1:\n-            case DSTORE_1:\n-                state.load(state.pop2(), 1);\n-                break;\n-            case LSTORE_2:\n-            case DSTORE_2:\n-                state.load(state.pop2(), 2);\n-                break;\n-            case LSTORE_3:\n-            case DSTORE_3:\n-                state.load(state.pop2(), 3);\n-                break;\n-            case LSTORE:\n-            case DSTORE:\n-                state.load(state.pop2(), (int) optValue);\n-                break;\n-            case POP:\n-            case LSHR:\n-            case LSHL:\n-            case LUSHR:\n-                state.pop();\n-                break;\n-            case ARETURN:\n-            case IRETURN:\n-            case FRETURN:\n-                state.pop();\n-                break;\n-            case ATHROW:\n-                state.pop();\n-                break;\n-            case POP2:\n-                state.pop2();\n-                break;\n-            case LRETURN:\n-            case DRETURN:\n-                state.pop2();\n-                break;\n-            case DUP:\n-                state.push(state.peek());\n-                break;\n-            case RETURN:\n-                break;\n-            case ARRAYLENGTH:\n-                state.pop();\n-                state.push(TypeTag.I);\n-                break;\n-            case ISUB:\n-            case IADD:\n-            case IMUL:\n-            case IDIV:\n-            case IREM:\n-            case ISHL:\n-            case ISHR:\n-            case IUSHR:\n-            case IAND:\n-            case IOR:\n-            case IXOR:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.I);\n-                break;\n-            case AASTORE:\n-                state.pop();\n-                state.pop();\n-                state.pop();\n-                break;\n-            case LAND:\n-            case LOR:\n-            case LXOR:\n-            case LREM:\n-            case LDIV:\n-            case LMUL:\n-            case LSUB:\n-            case LADD:\n-                state.pop2();\n-                state.pop2();\n-                state.push(TypeTag.J);\n-                break;\n-            case LCMP:\n-                state.pop2();\n-                state.pop2();\n-                state.push(TypeTag.I);\n-                break;\n-            case L2I:\n-                state.pop2();\n-                state.push(TypeTag.I);\n-                break;\n-            case I2L:\n-                state.pop();\n-                state.push(TypeTag.J);\n-                break;\n-            case I2F:\n-                state.pop();\n-                state.push(TypeTag.F);\n-                break;\n-            case I2D:\n-                state.pop();\n-                state.push(TypeTag.D);\n-                break;\n-            case L2F:\n-                state.pop2();\n-                state.push(TypeTag.F);\n-                break;\n-            case L2D:\n-                state.pop2();\n-                state.push(TypeTag.D);\n-                break;\n-            case F2I:\n-                state.pop();\n-                state.push(TypeTag.I);\n-                break;\n-            case F2L:\n-                state.pop();\n-                state.push(TypeTag.J);\n-                break;\n-            case F2D:\n-                state.pop();\n-                state.push(TypeTag.D);\n-                break;\n-            case D2I:\n-                state.pop2();\n-                state.push(TypeTag.I);\n-                break;\n-            case D2L:\n-                state.pop2();\n-                state.push(TypeTag.J);\n-                break;\n-            case D2F:\n-                state.pop2();\n-                state.push(TypeTag.F);\n-                break;\n-            case TABLESWITCH:\n-            case LOOKUPSWITCH:\n-                state.pop();\n-                break;\n-            case DUP_X1: {\n-                T val1 = state.pop();\n-                T val2 = state.pop();\n-                state.push(val1);\n-                state.push(val2);\n-                state.push(val1);\n-                break;\n-            }\n-            case BASTORE:\n-                state.pop();\n-                state.pop();\n-                state.pop();\n-                break;\n-            case I2B:\n-            case I2C:\n-            case I2S:\n-                break;\n-            case FMUL:\n-            case FADD:\n-            case FSUB:\n-            case FDIV:\n-            case FREM:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.F);\n-                break;\n-            case CASTORE:\n-            case IASTORE:\n-            case FASTORE:\n-            case SASTORE:\n-                state.pop();\n-                state.pop();\n-                state.pop();\n-                break;\n-            case LASTORE:\n-            case DASTORE:\n-                state.pop2();\n-                state.pop();\n-                state.pop();\n-                break;\n-            case DUP2:\n-                if (state.peek() != null) {\n-                    \/\/form 1\n-                    T value1 = state.pop();\n-                    T value2 = state.pop();\n-                    state.push(value2);\n-                    state.push(value1);\n-                    state.push(value2);\n-                    state.push(value1);\n-                } else {\n-                    \/\/form 2\n-                    T value = state.pop2();\n-                    state.push(value);\n-                    state.push(value);\n-                }\n-                break;\n-            case DUP2_X1:\n-                if (state.peek() != null) {\n-                    T value1 = state.pop();\n-                    T value2 = state.pop();\n-                    T value3 = state.pop();\n-                    state.push(value2);\n-                    state.push(value1);\n-                    state.push(value3);\n-                    state.push(value2);\n-                    state.push(value1);\n-                } else {\n-                    T value1 = state.pop2();\n-                    T value2 = state.pop();\n-                    state.push(value1);\n-                    state.push(value2);\n-                    state.push(value1);\n-                }\n-                break;\n-            case DUP2_X2:\n-                if (state.peek() != null) {\n-                    T value1 = state.pop();\n-                    T value2 = state.pop();\n-                    if (state.peek() != null) {\n-                        \/\/ form 1\n-                        T value3 = state.pop();\n-                        T value4 = state.pop();\n-                        state.push(value2);\n-                        state.push(value1);\n-                        state.push(value4);\n-                        state.push(value3);\n-                        state.push(value2);\n-                        state.push(value1);\n-                    } else {\n-                        \/\/ form 3\n-                        T value3 = state.pop2();\n-                        state.push(value2);\n-                        state.push(value1);\n-                        state.push(value3);\n-                        state.push(value2);\n-                        state.push(value1);\n-                    }\n-                } else {\n-                    T value1 = state.pop2();\n-                    if (state.peek() != null) {\n-                        \/\/ form 2\n-                        T value2 = state.pop();\n-                        T value3 = state.pop();\n-                        state.push(value1);\n-                        state.push(value3);\n-                        state.push(value2);\n-                        state.push(value1);\n-                    } else {\n-                        \/\/ form 4\n-                        T value2 = state.pop2();\n-                        state.push(value1);\n-                        state.push(value2);\n-                        state.push(value1);\n-                    }\n-                }\n-                break;\n-            case DUP_X2: {\n-                T value1 = state.pop();\n-                if (state.peek() != null) {\n-                    \/\/ form 1\n-                    T value2 = state.pop();\n-                    T value3 = state.pop();\n-                    state.push(value1);\n-                    state.push(value3);\n-                    state.push(value2);\n-                    state.push(value1);\n-                } else {\n-                    \/\/ form 2\n-                    T value2 = state.pop2();\n-                    state.push(value1);\n-                    state.push(value2);\n-                    state.push(value1);\n-                }\n-            }\n-            break;\n-            case FCMPL:\n-            case FCMPG:\n-                state.pop();\n-                state.pop();\n-                state.push(TypeTag.I);\n-                break;\n-            case DCMPL:\n-            case DCMPG:\n-                state.pop2();\n-                state.pop2();\n-                state.push(TypeTag.I);\n-                break;\n-            case SWAP: {\n-                T value1 = state.pop();\n-                T value2 = state.pop();\n-                state.push(value1);\n-                state.push(value2);\n-                break;\n-            }\n-            case DADD:\n-            case DSUB:\n-            case DMUL:\n-            case DDIV:\n-            case DREM:\n-                state.pop2();\n-                state.pop2();\n-                state.push(TypeTag.D);\n-                break;\n-            case RET:\n-                break;\n-            case WIDE:\n-                \/\/ must be handled by the caller.\n-                return;\n-            case MONITORENTER:\n-            case MONITOREXIT:\n-                state.pop();\n-                break;\n-            case NEW:\n-            case ACONST_INIT:\n-                state.push(typeHelper.type((S) optValue));\n-                break;\n-            case NEWARRAY:\n-                state.pop();\n-                state.push(typeHelper.arrayOf(typeHelper.fromTag((TypeTag) optValue)));\n-                break;\n-            case ANEWARRAY:\n-                state.pop();\n-                state.push(typeHelper.arrayOf(typeHelper.arrayOf(typeHelper.type((S)optValue))));\n-                break;\n-            case MULTIANEWARRAY:\n-                for (int i = 0; i < (byte) ((Object[]) optValue)[1]; i++) {\n-                    state.pop();\n-                }\n-                state.push(typeHelper.type((S) ((Object[]) optValue)[0]));\n-                break;\n-            case INVOKEINTERFACE:\n-            case INVOKEVIRTUAL:\n-            case INVOKESPECIAL:\n-            case INVOKESTATIC:\n-            case INVOKEDYNAMIC:\n-                processInvoke(op, (T) optValue);\n-                break;\n-            case GETSTATIC:\n-                state.push((T) optValue);\n-                break;\n-            case GETFIELD:\n-                state.pop();\n-                state.push((T) optValue);\n-                break;\n-            case PUTSTATIC: {\n-                TypeTag tag = typeHelper.tag((T) optValue);\n-                if (tag.width == 1) {\n-                    state.pop();\n-                } else {\n-                    state.pop2();\n-                }\n-                break;\n-            }\n-            case PUTFIELD: {\n-                TypeTag tag = typeHelper.tag((T) optValue);\n-                if (tag.width == 1) {\n-                    state.pop();\n-                } else {\n-                    state.pop2();\n-                }\n-                state.pop();\n-                break;\n-            }\n-            case WITHFIELD: {\n-                TypeTag tag = typeHelper.tag((T) optValue);\n-                if (tag.width == 1) {\n-                    state.pop();\n-                } else {\n-                    state.pop2();\n-                }\n-                break;\n-            }\n-            case BIPUSH:\n-            case SIPUSH:\n-                state.push(TypeTag.I);\n-                break;\n-            case LDC:\n-            case LDC_W:\n-            case LDC2_W:\n-                state.push((T)optValue);\n-                break;\n-            case IF_ACMPEQ:\n-            case IF_ICMPEQ:\n-            case IF_ACMPNE:\n-            case IF_ICMPGE:\n-            case IF_ICMPGT:\n-            case IF_ICMPLE:\n-            case IF_ICMPLT:\n-            case IF_ICMPNE:\n-                state.pop();\n-                state.pop();\n-                break;\n-            case IF_NONNULL:\n-            case IF_NULL:\n-            case IFEQ:\n-            case IFGE:\n-            case IFGT:\n-            case IFLE:\n-            case IFLT:\n-            case IFNE:\n-                state.pop();\n-                break;\n-            case INSTANCEOF:\n-                state.pop();\n-                state.push(TypeTag.Z);\n-                break;\n-            case CHECKCAST:\n-                break;\n-\n-            default:\n-                throw new UnsupportedOperationException(\"Unsupported opcode: \" + op);\n-        }\n-    }\n-\n-    void processInvoke(Opcode opcode, T invokedType) {\n-        Iterator<T> paramsIt = typeHelper.parameterTypes(invokedType);\n-        while (paramsIt.hasNext()) {\n-            T t = paramsIt.next();\n-            TypeTag tag = typeHelper.tag(t);\n-            if (tag.width == 2) {\n-                state.popInternal();\n-                state.popInternal();\n-            } else {\n-                state.popInternal();\n-            }\n-        }\n-        if (opcode != Opcode.INVOKESTATIC && opcode != Opcode.INVOKEDYNAMIC) {\n-            state.pop(); \/\/receiver\n-        }\n-        T retType = typeHelper.returnType(invokedType);\n-        TypeTag retTag = typeHelper.tag(retType);\n-        if (retTag != TypeTag.V)\n-            state.push(retType);\n-    }\n-\n-    @Override\n-    protected C ldc(ToIntFunction<PoolHelper<S, T, E>> indexFunc, boolean fat) {\n-        LdcPoolHelper ldcPoolHelper = new LdcPoolHelper();\n-        int index = indexFunc.applyAsInt(ldcPoolHelper);\n-        fat = typeHelper.tag(ldcPoolHelper.type).width() == 2;\n-        return super.ldc(index, ldcPoolHelper.type, fat);\n-    }\n-    \/\/where\n-        class LdcPoolHelper implements PoolHelper<S, T, E> {\n-\n-            T type;\n-\n-            @Override\n-            public int putClass(S symbol) {\n-                type = typeHelper.type(symbol);\n-                return poolHelper.putClass(symbol);\n-            }\n-\n-            @Override\n-            public int putInlineClass(S symbol) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int putInt(int i) {\n-                type = typeHelper.fromTag(TypeTag.I);\n-                return poolHelper.putInt(i);\n-            }\n-\n-            @Override\n-            public int putFloat(float f) {\n-                type = typeHelper.fromTag(TypeTag.F);\n-                return poolHelper.putFloat(f);\n-            }\n-\n-            @Override\n-            public int putLong(long l) {\n-                type = typeHelper.fromTag(TypeTag.J);\n-                return poolHelper.putLong(l);\n-            }\n-\n-            @Override\n-            public int putDouble(double d) {\n-                type = typeHelper.fromTag(TypeTag.D);\n-                return poolHelper.putDouble(d);\n-            }\n-\n-            @Override\n-            public int putString(String s) {\n-                type = typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/String\"));\n-                return poolHelper.putString(s);\n-            }\n-\n-            @Override\n-            public int putDynamicConstant(CharSequence constName, T constType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgs) {\n-                type = constType;\n-                return poolHelper.putDynamicConstant(constName, constType, bsmClass, bsmName, bsmType, staticArgs);\n-            }\n-\n-            @Override\n-            public int putFieldRef(S owner, CharSequence name, T type) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int putMethodRef(S owner, CharSequence name, T type, boolean isInterface) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int putUtf8(CharSequence s) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int putType(T t) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int putMethodType(T t) {\n-                type = typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/invoke\/MethodType\"));\n-                return poolHelper.putMethodType(t);\n-            }\n-\n-            @Override\n-            public int putHandle(int refKind, S owner, CharSequence name, T t) {\n-                type = typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/invoke\/MethodHandle\"));\n-                return poolHelper.putHandle(refKind, owner, name, t);\n-            }\n-\n-            @Override\n-            public int putHandle(int refKind, S owner, CharSequence name, T t, boolean isInterface) {\n-                type = typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/invoke\/MethodHandle\"));\n-                return poolHelper.putHandle(refKind, owner, name, t, isInterface);\n-            }\n-\n-            @Override\n-            public int putInvokeDynamic(CharSequence invokedName, T invokedType, S bsmClass, CharSequence bsmName, T bsmType, Consumer<StaticArgListBuilder<S, T, E>> staticArgs) {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public int size() {\n-                throw new IllegalStateException();\n-            }\n-\n-            @Override\n-            public E entries() {\n-                throw new IllegalStateException();\n-            }\n-    }\n-\n-    public C load(int index) {\n-        return load(typeHelper.tag(state.locals.get(index)), index);\n-    }\n-\n-    public C store(int index) {\n-        return store(typeHelper.tag(state.tosType()), index);\n-    }\n-\n-    @Override\n-    public C withLocalSize(int localsize) {\n-        throw new IllegalStateException(\"Local size automatically computed\");\n-    }\n-\n-    @Override\n-    public C withStackSize(int stacksize) {\n-        throw new IllegalStateException(\"Stack size automatically computed\");\n-    }\n-\n-    public C withLocal(CharSequence name, T type) {\n-        int offset = currLocalOffset;\n-        TypeTag tag = typeHelper.tag(type);\n-        lvarOffsets.put(name, new LocalVarInfo(name, offset, depth, tag));\n-        state.load(type, offset);\n-        currLocalOffset += tag.width;\n-        return thisBuilder();\n-    }\n-\n-    public C load(CharSequence local) {\n-        return load(lvarOffsets.get(local).offset);\n-    }\n-\n-    public C store(CharSequence local) {\n-        return store(lvarOffsets.get(local).offset);\n-    }\n-\n-    @Override\n-    public C withTry(Consumer<? super C> tryBlock, Consumer<? super CatchBuilder> catchBlocks) {\n-        return super.withTry(c -> {\n-            withLocalScope(() -> {\n-                tryBlock.accept(c);\n-            });\n-        }, catchBlocks);\n-    }\n-\n-    @Override\n-    protected CatchBuilder makeCatchBuilder(int start, int end) {\n-        return new TypedCatchBuilder(start, end);\n-    }\n-\n-    class TypedCatchBuilder extends CatchBuilder {\n-\n-        State initialState = state.dup();\n-\n-        TypedCatchBuilder(int start, int end) {\n-            super(start, end);\n-        }\n-\n-        @Override\n-        protected void emitCatch(S exc, Consumer<? super C> catcher) {\n-            withLocalScope(() -> {\n-                state.push(typeHelper.type(exc));\n-                emitStackMap(code.offset);\n-                super.emitCatch(exc, catcher);\n-                state = initialState;\n-            });\n-        }\n-\n-        @Override\n-        protected void emitFinalizer() {\n-            withLocalScope(() -> {\n-                state.push(typeHelper.type(typeHelper.symbolFrom(\"java\/lang\/Throwable\")));\n-                emitStackMap(code.offset);\n-                super.emitFinalizer();\n-            });\n-        }\n-    }\n-\n-    protected void withLocalScope(Runnable runnable) {\n-        int prevDepth = depth;\n-        try {\n-            depth++;\n-            runnable.run();\n-        } finally {\n-            Iterator<Entry<CharSequence, LocalVarInfo>> lvarIt = lvarOffsets.entrySet().iterator();\n-            while (lvarIt.hasNext()) {\n-                LocalVarInfo lvi = lvarIt.next().getValue();\n-                if (lvi.depth == depth) {\n-                    int width = lvi.type.width;\n-                    currLocalOffset -= width;\n-                    lvarIt.remove();\n-                }\n-            }\n-            depth = prevDepth;\n-        }\n-    }\n-\n-    @Override\n-    void addPendingJump(CharSequence label, int pc) {\n-        pendingJumps.add(new StatefulPendingJump(label, pc, state.dup()));\n-    }\n-\n-    @Override\n-    void resolveJumps(CharSequence label, int pc) {\n-        super.resolveJumps(label, pc);\n-        emitStackMap(pc);\n-    }\n-\n-    \/\/TODO: optimize stackmap generation by avoiding intermediate classes\n-    protected void emitStackMap(int pc) {\n-        \/\/stack map generation\n-        if (pc > lastStackMapPc) {\n-            writeStackMapFrame(pc);\n-            lastStackMapState = state.dup();\n-            lastStackMapPc = pc;\n-            nstackmaps++;\n-        }\n-    }\n-\n-    @Override\n-    void build(GrowableByteBuffer buf) {\n-        if (stacksize == -1) {\n-            throw new IllegalStateException(\"Bad stack size\");\n-        }\n-        if (localsize == -1) {\n-            throw new IllegalStateException(\"Bad locals size\");\n-        }\n-        if (nstackmaps > 0) {\n-            GrowableByteBuffer stackmapsAttr = new GrowableByteBuffer();\n-            stackmapsAttr.writeChar(nstackmaps);\n-            stackmapsAttr.writeBytes(stackmaps);\n-            withAttribute(\"StackMapTable\", stackmapsAttr.bytes());\n-        }\n-        super.build(buf);\n-    }\n-\n-    \/**\n-     * Compare this frame with the previous frame and produce\n-     * an entry of compressed stack map frame.\n-     *\/\n-    void writeStackMapFrame(int pc) {\n-        List<T> locals = state.locals;\n-        List<T> stack = state.stack;\n-        List<T> prev_locals = lastStackMapState.locals;\n-        int offset_delta = lastStackMapPc == -1 ? pc : pc - lastStackMapPc - 1;\n-        if (stack.size() == 1) {\n-            if (locals.size() == prev_locals.size() && prev_locals.equals(locals)) {\n-                sameLocals1StackItemFrame(offset_delta, stack.get(stack.size() - 1));\n-                return;\n-            }\n-        } else if (stack.size() == 0) {\n-            int diff_length = prev_locals.size() - locals.size();\n-            if (diff_length == 0) {\n-                sameFrame(offset_delta);\n-                return;\n-            } else if (-MAX_LOCAL_LENGTH_DIFF < diff_length && diff_length < 0) {\n-                appendFrame(offset_delta, prev_locals.size(), locals);\n-                return;\n-            } else if (0 < diff_length && diff_length < MAX_LOCAL_LENGTH_DIFF) {\n-                chopFrame(offset_delta, diff_length);\n-                return;\n-            }\n-        }\n-        fullFrame(offset_delta, locals, stack);\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/bytecode\/jdk\/experimental\/bytecode\/TypedCodeBuilder.java","additions":0,"deletions":1133,"binary":false,"changes":1133,"status":"deleted"}]}