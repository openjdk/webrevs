{"files":[{"patch":"@@ -2757,2 +2757,5 @@\n-    address ucm_common_error_exit       =  generate_unsafecopy_common_error_exit();\n-    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n+    \/\/ generate the common exit first so later stubs can rely on it if\n+    \/\/ they want an UnsafeMemoryAccess exit non-local to the stub\n+    StubRoutines::_unsafecopy_common_exit = generate_unsafecopy_common_error_exit();\n+    \/\/ register the stub as the default exit with class UnsafeMemoryAccess\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(StubRoutines::_unsafecopy_common_exit);\n@@ -11853,2 +11856,0 @@\n-      \/\/ set table address before stub generation which use it\n-      StubRoutines::_crc_table_adr = (address)StubRoutines::aarch64::_crc_table;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4181,2 +4181,0 @@\n-    \/\/ set table address before stub generation which use it\n-    StubRoutines::_crc_table_adr = (address)StubRoutines::x86::_crc_table;\n@@ -4188,2 +4186,0 @@\n-    StubRoutines::x86::generate_CRC32C_table(supports_clmul);\n-    StubRoutines::_crc32c_table_addr = (address)StubRoutines::x86::_crc32c_table;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -508,3 +508,0 @@\n-  if (AOTClassInitializer::is_runtime_setup_required(ik)) {\n-    ik->set_is_runtime_setup_required();\n-  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1613,2 +1613,1 @@\n-      const address encoding_base = (address)mapped_base_address;\n-      const address klass_range_start = encoding_base + prot_zone_size;\n+      const address klass_range_start = (address)mapped_base_address;\n@@ -1625,1 +1624,1 @@\n-          encoding_base, ArchiveBuilder::precomputed_narrow_klass_shift() \/\/ precomputed encoding, see ArchiveBuilder\n+          klass_range_start, ArchiveBuilder::precomputed_narrow_klass_shift() \/\/ precomputed encoding, see ArchiveBuilder\n@@ -1627,0 +1626,1 @@\n+        assert(CompressedKlassPointers::base() == klass_range_start, \"must be\");\n@@ -1630,0 +1630,6 @@\n+        assert(CompressedKlassPointers::base() == nullptr ||\n+               CompressedKlassPointers::base() == klass_range_start, \"must be\");\n+      }\n+      \/\/ Establish protection zone, but only if we need one\n+      if (CompressedKlassPointers::base() == klass_range_start) {\n+        CompressedKlassPointers::establish_protection_zone(klass_range_start, prot_zone_size);\n@@ -1631,1 +1637,0 @@\n-      CompressedKlassPointers::establish_protection_zone(encoding_base, prot_zone_size);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -949,0 +949,2 @@\n+    _jdk_internal_vm_annotation_AOTSafeClassInitializer,\n+    _method_AOTRuntimeSetup,\n@@ -984,0 +986,2 @@\n+\n+  bool has_aot_runtime_setup() const { return has_annotation(_method_AOTRuntimeSetup); }\n@@ -1965,0 +1969,10 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_AOTSafeClassInitializer_signature): {\n+      if (_location != _in_class)   break;  \/\/ only allow for classes\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _jdk_internal_vm_annotation_AOTSafeClassInitializer;\n+    }\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_AOTRuntimeSetup_signature): {\n+      if (_location != _in_method)  break;  \/\/ only allow for methods\n+      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _method_AOTRuntimeSetup;\n+    }\n@@ -2044,0 +2058,3 @@\n+  if (has_annotation(_jdk_internal_vm_annotation_AOTSafeClassInitializer)) {\n+    ik->set_has_aot_safe_initializer();\n+  }\n@@ -2741,0 +2758,7 @@\n+  if (parsed_annotations.has_aot_runtime_setup()) {\n+    if (name != vmSymbols::runtimeSetup() || signature != vmSymbols::void_method_signature() ||\n+        !access_flags.is_private() || !access_flags.is_static()) {\n+      classfile_parse_error(\"@AOTRuntimeSetup method must be declared private static void runtimeSetup() for class %s\", CHECK_NULL);\n+    }\n+    _has_aot_runtime_setup_method = true;\n+  }\n@@ -4139,0 +4163,9 @@\n+\n+  \/\/ Propagate the AOT runtimeSetup method discovery\n+  if (_has_aot_runtime_setup_method) {\n+    ik->set_is_runtime_setup_required();\n+    if (log_is_enabled(Info, aot, init)) {\n+      ResourceMark rm;\n+      log_info(aot, init)(\"Found @AOTRuntimeSetup class %s\", ik->external_name());\n+    }\n+  }\n@@ -5375,1 +5408,1 @@\n-  if (_parsed_annotations->has_any_annotations()) {\n+  if (_parsed_annotations->has_any_annotations())\n@@ -5377,0 +5410,39 @@\n+\n+  \/\/ AOT-related checks.\n+  \/\/ Note we cannot check this in general due to instrumentation or module patching\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    \/\/ Check the aot initialization safe status.\n+    \/\/ @AOTSafeClassInitializer is used only to support ahead-of-time initialization of classes\n+    \/\/ in the AOT assembly phase.\n+    if (ik->has_aot_safe_initializer()) {\n+      \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n+      \/\/   - all super classes must be included\n+      \/\/   - all super interfaces that have <clinit> must be included.\n+      \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n+      \/\/ ik's <clinit>.\n+      if (_super_klass != nullptr) {\n+        guarantee_property(_super_klass->has_aot_safe_initializer(),\n+                           \"Missing @AOTSafeClassInitializer in superclass %s for class %s\",\n+                           _super_klass->external_name(),\n+                           CHECK);\n+      }\n+\n+      int len = _local_interfaces->length();\n+      for (int i = 0; i < len; i++) {\n+        InstanceKlass* intf = _local_interfaces->at(i);\n+        guarantee_property(intf->class_initializer() == nullptr || intf->has_aot_safe_initializer(),\n+                           \"Missing @AOTSafeClassInitializer in superinterface %s for class %s\",\n+                           intf->external_name(),\n+                           CHECK);\n+      }\n+\n+      if (log_is_enabled(Info, aot, init)) {\n+        ResourceMark rm;\n+        log_info(aot, init)(\"Found @AOTSafeClassInitializer class %s\", ik->external_name());\n+      }\n+    } else {\n+      \/\/ @AOTRuntimeSetup only meaningful in @AOTClassInitializer\n+      guarantee_property(!ik->is_runtime_setup_required(),\n+                         \"@AOTRuntimeSetup meaningless in non-@AOTSafeClassInitializer class %s\",\n+                         CHECK);\n+    }\n@@ -5602,0 +5674,1 @@\n+  _has_aot_runtime_setup_method(false),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":74,"deletions":1,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+  bool _has_aot_runtime_setup_method;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -768,0 +768,1 @@\n+  template(jdk_internal_vm_annotation_AOTSafeClassInitializer_signature, \"Ljdk\/internal\/vm\/annotation\/AOTSafeClassInitializer;\")\\\n@@ -770,0 +771,1 @@\n+  template(jdk_internal_vm_annotation_AOTRuntimeSetup_signature, \"Ljdk\/internal\/vm\/annotation\/AOTRuntimeSetup;\")  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -663,1 +663,0 @@\n-  \/\/ Increment the invocation count\n@@ -838,2 +837,2 @@\n-  \/\/ Check if all live objs are larger than old-gen.\n-  const bool is_old_gen_overflowing = (total_live_words > old_space->capacity_in_words());\n+  \/\/ Check if all live objs are too much for old-gen.\n+  const bool is_old_gen_too_full = (total_live_words >= old_space->capacity_in_words());\n@@ -851,1 +850,1 @@\n-  if (is_max_on_system_gc || is_old_gen_overflowing || is_interval_ended || is_region_full) {\n+  if (is_max_on_system_gc || is_old_gen_too_full || is_interval_ended || is_region_full) {\n@@ -885,0 +884,8 @@\n+    {\n+      GCTraceTime(Info, gc, phases) tm(\"Summary Phase: expand\", &_gc_timer);\n+      \/\/ Try to expand old-gen in order to fit all live objs and waste.\n+      size_t target_capacity_bytes = total_live_words * HeapWordSize\n+                                   + old_space->capacity_in_bytes() * (MarkSweepDeadRatio \/ 100);\n+      ParallelScavengeHeap::heap()->old_gen()->try_expand_till_size(target_capacity_bytes);\n+    }\n+\n@@ -995,1 +1002,0 @@\n-  PSYoungGen* young_gen = heap->young_gen();\n@@ -1061,2 +1067,1 @@\n-    \/\/ Let the size policy know we're done\n-    size_policy->major_collection_end(old_gen->used_in_bytes(), gc_cause);\n+    size_policy->major_collection_end();\n@@ -1064,60 +1069,1 @@\n-    if (UseAdaptiveSizePolicy) {\n-      log_debug(gc, ergo)(\"AdaptiveSizeStart: collection: %d \", heap->total_collections());\n-      log_trace(gc, ergo)(\"old_gen_capacity: %zu young_gen_capacity: %zu\",\n-                          old_gen->capacity_in_bytes(), young_gen->capacity_in_bytes());\n-\n-      \/\/ Don't check if the size_policy is ready here.  Let\n-      \/\/ the size_policy check that internally.\n-      if (UseAdaptiveGenerationSizePolicyAtMajorCollection &&\n-          AdaptiveSizePolicy::should_update_promo_stats(gc_cause)) {\n-        \/\/ Swap the survivor spaces if from_space is empty. The\n-        \/\/ resize_young_gen() called below is normally used after\n-        \/\/ a successful young GC and swapping of survivor spaces;\n-        \/\/ otherwise, it will fail to resize the young gen with\n-        \/\/ the current implementation.\n-        if (young_gen->from_space()->is_empty()) {\n-          young_gen->from_space()->clear(SpaceDecorator::Mangle);\n-          young_gen->swap_spaces();\n-        }\n-\n-        \/\/ Calculate optimal free space amounts\n-        assert(young_gen->max_gen_size() >\n-          young_gen->from_space()->capacity_in_bytes() +\n-          young_gen->to_space()->capacity_in_bytes(),\n-          \"Sizes of space in young gen are out-of-bounds\");\n-\n-        size_t young_live = young_gen->used_in_bytes();\n-        size_t eden_live = young_gen->eden_space()->used_in_bytes();\n-        size_t old_live = old_gen->used_in_bytes();\n-        size_t cur_eden = young_gen->eden_space()->capacity_in_bytes();\n-        size_t max_old_gen_size = old_gen->max_gen_size();\n-        size_t max_eden_size = young_gen->max_gen_size() -\n-          young_gen->from_space()->capacity_in_bytes() -\n-          young_gen->to_space()->capacity_in_bytes();\n-\n-        \/\/ Used for diagnostics\n-        size_policy->clear_generation_free_space_flags();\n-\n-        size_policy->compute_generations_free_space(young_live,\n-                                                    eden_live,\n-                                                    old_live,\n-                                                    cur_eden,\n-                                                    max_old_gen_size,\n-                                                    max_eden_size,\n-                                                    true \/* full gc*\/);\n-\n-        size_policy->check_gc_overhead_limit(eden_live,\n-                                             max_old_gen_size,\n-                                             max_eden_size,\n-                                             true \/* full gc*\/,\n-                                             gc_cause,\n-                                             heap->soft_ref_policy());\n-\n-        size_policy->decay_supplemental_growth(true \/* full gc*\/);\n-\n-        heap->resize_old_gen(\n-          size_policy->calculated_old_free_size_in_bytes());\n-\n-        heap->resize_young_gen(size_policy->calculated_eden_size_in_bytes(),\n-                               size_policy->calculated_survivor_size_in_bytes());\n-      }\n+    size_policy->sample_old_gen_used_bytes(MAX2(pre_gc_values.old_gen_used(), old_gen->used_in_bytes()));\n@@ -1125,8 +1071,2 @@\n-      log_debug(gc, ergo)(\"AdaptiveSizeStop: collection: %d \", heap->total_collections());\n-    }\n-\n-    if (UsePerfData) {\n-      PSGCAdaptivePolicyCounters* const counters = heap->gc_policy_counters();\n-      counters->update_counters();\n-      counters->update_old_capacity(old_gen->capacity_in_bytes());\n-      counters->update_young_capacity(young_gen->capacity_in_bytes());\n+    if (UseAdaptiveSizePolicy) {\n+      heap->resize_after_full_gc();\n@@ -1151,0 +1091,2 @@\n+\n+    size_policy->record_gc_pause_end_instant();\n@@ -1153,0 +1095,2 @@\n+  heap->gc_epilogue(true);\n+\n@@ -1160,2 +1104,0 @@\n-  AdaptiveSizePolicyOutput::print(size_policy, heap->total_collections());\n-\n@@ -1587,0 +1529,1 @@\n+          \/\/ Empty space\n@@ -1591,1 +1534,0 @@\n-\n@@ -1635,1 +1577,1 @@\n-  HeapWord* old_dense_prefix_addr = dense_prefix(SpaceId(old_space_id));\n+  HeapWord* const old_dense_prefix_addr = dense_prefix(SpaceId(old_space_id));\n@@ -1728,1 +1670,1 @@\n-  for (unsigned int id = to_space_id; id + 1 > old_space_id; --id) {\n+  for (unsigned int id = last_space_id - 1; id + 1 > old_space_id; --id) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":22,"deletions":80,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+  _young_gen_has_alloc_failure = false;\n@@ -255,1 +256,1 @@\n-  if (_young_gen_is_full) {\n+  if (_young_gen_is_full || _young_gen_has_alloc_failure) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -210,0 +210,3 @@\n+        if (new_obj == nullptr && !_young_gen_is_full && !_young_gen_has_alloc_failure) {\n+          _young_gen_has_alloc_failure = true;\n+        }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"gc\/shared\/oopStorageSet.inline.hpp\"\n@@ -69,0 +70,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -487,7 +489,16 @@\n-    CLDClosure* weak_cld_closure = ClassUnloading ? nullptr : &follow_cld_closure;\n-    MarkingNMethodClosure mark_code_closure(&follow_root_closure, !NMethodToOopClosure::FixRelocations, true);\n-    gch->process_roots(SerialHeap::SO_None,\n-                       &follow_root_closure,\n-                       &follow_cld_closure,\n-                       weak_cld_closure,\n-                       &mark_code_closure);\n+    MarkingNMethodClosure mark_code_closure(&follow_root_closure,\n+                                            !NMethodToOopClosure::FixRelocations,\n+                                            true);\n+\n+    \/\/ Start tracing from roots, there are 3 kinds of roots in full-gc.\n+    \/\/\n+    \/\/ 1. CLD. This method internally takes care of whether class loading is\n+    \/\/ enabled or not, applying the closure to both strong and weak or only\n+    \/\/ strong CLDs.\n+    ClassLoaderDataGraph::always_strong_cld_do(&follow_cld_closure);\n+\n+    \/\/ 2. Threads stack frames and active nmethods in them.\n+    Threads::oops_do(&follow_root_closure, &mark_code_closure);\n+\n+    \/\/ 3. VM internal roots.\n+    OopStorageSet::strong_oops_do(&follow_root_closure);\n@@ -721,6 +732,12 @@\n-    NMethodToOopClosure code_closure(&adjust_pointer_closure, NMethodToOopClosure::FixRelocations);\n-    gch->process_roots(SerialHeap::SO_AllCodeCache,\n-                       &adjust_pointer_closure,\n-                       &adjust_cld_closure,\n-                       &adjust_cld_closure,\n-                       &code_closure);\n+    \/\/ Remap strong and weak roots in adjust phase.\n+    \/\/ 1. All (strong and weak) CLDs.\n+    ClassLoaderDataGraph::cld_do(&adjust_cld_closure);\n+\n+    \/\/ 2. Threads stack frames. No need to visit on-stack nmethods, because all\n+    \/\/ nmethods are visited in one go via CodeCache::nmethods_do.\n+    Threads::oops_do(&adjust_pointer_closure, nullptr);\n+    NMethodToOopClosure nmethod_cl(&adjust_pointer_closure, NMethodToOopClosure::FixRelocations);\n+    CodeCache::nmethods_do(&nmethod_cl);\n+\n+    \/\/ 3. VM internal roots\n+    OopStorageSet::strong_oops_do(&adjust_pointer_closure);\n@@ -728,0 +745,1 @@\n+    \/\/ 4. VM internal weak roots\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+  static_field(CompilerToVM::Data,             crc_table_addr,                         address)                                      \\\n@@ -420,2 +421,0 @@\n-  static_field(StubRoutines,                _crc_table_adr,                                   address)                               \\\n-  static_field(StubRoutines,                _crc32c_table_addr,                               address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -915,0 +915,1 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n@@ -918,0 +919,1 @@\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n@@ -956,0 +958,1 @@\n+  assert(is_aligned(heap_size, alignment), \"precondition\");\n@@ -957,1 +960,1 @@\n-  size_t total_reserved = align_up(heap_size, alignment);\n+  size_t total_reserved = heap_size;\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -865,0 +865,8 @@\n+  \/\/ Indicates presence of @AOTSafeClassInitializer. Also see AOTClassInitializer for more details.\n+  bool has_aot_safe_initializer() const { return _misc_flags.has_aot_safe_initializer(); }\n+  void set_has_aot_safe_initializer()   { _misc_flags.set_has_aot_safe_initializer(true); }\n+\n+  \/\/ Indicates @AOTRuntimeSetup private static void runtimeSetup() presence.\n+  bool is_runtime_setup_required() const { return _misc_flags.is_runtime_setup_required(); }\n+  void set_is_runtime_setup_required()   { _misc_flags.set_is_runtime_setup_required(true); }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,6 +57,8 @@\n-    flag(has_inline_type_fields             , 1 << 14) \/* has inline fields and related embedded section is not empty *\/ \\\n-    flag(is_empty_inline_type               , 1 << 15) \/* empty inline type (*) *\/ \\\n-    flag(is_naturally_atomic                , 1 << 16) \/* loaded\/stored in one instruction*\/ \\\n-    flag(must_be_atomic                     , 1 << 17) \/* doesn't allow tearing *\/ \\\n-    flag(has_loosely_consistent_annotation  , 1 << 18) \/* the class has the LooselyConsistentValue annotation WARNING: it doesn't automatically mean that the class allows tearing *\/ \\\n-    flag(has_strict_static_fields           , 1 << 19) \/* True if strict static fields declared *\/ \\\n+    flag(has_aot_safe_initializer           , 1 << 14) \/* has @AOTSafeClassInitializer annotation *\/ \\\n+    flag(is_runtime_setup_required          , 1 << 15) \/* has a runtimeSetup method to be called *\/ \\\n+    flag(has_inline_type_fields             , 1 << 16) \/* has inline fields and related embedded section is not empty *\/ \\\n+    flag(is_empty_inline_type               , 1 << 17) \/* empty inline type (*) *\/ \\\n+    flag(is_naturally_atomic                , 1 << 18) \/* loaded\/stored in one instruction*\/ \\\n+    flag(must_be_atomic                     , 1 << 19) \/* doesn't allow tearing *\/ \\\n+    flag(has_loosely_consistent_annotation  , 1 << 20) \/* the class has the LooselyConsistentValue annotation WARNING: it doesn't automatically mean that the class allows tearing *\/ \\\n+    flag(has_strict_static_fields           , 1 << 21) \/* True if strict static fields declared *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -193,3 +193,0 @@\n-    \/\/ If this class has been aot-inititalized, do we need to call its runtimeSetup()\n-    \/\/ method during the production run?\n-    _is_runtime_setup_required             = 1 << 7,\n@@ -387,9 +384,0 @@\n-  void set_is_runtime_setup_required() {\n-    assert(has_aot_initialized_mirror(), \"sanity\");\n-    CDS_ONLY(_shared_class_flags |= _is_runtime_setup_required;)\n-  }\n-  bool is_runtime_setup_required() const {\n-    CDS_ONLY(return (_shared_class_flags & _is_runtime_setup_required) != 0;)\n-    NOT_CDS(return false;)\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -64,0 +64,20 @@\n+Symbol* ObjArrayKlass::create_element_klass_array_name(JavaThread* current, Klass* element_klass) {\n+  ResourceMark rm(current);\n+  char* name_str = element_klass->name()->as_C_string();\n+  int len = element_klass->name()->utf8_length();\n+  char* new_str = NEW_RESOURCE_ARRAY_IN_THREAD(current, char, len + 4);\n+  int idx = 0;\n+  new_str[idx++] = JVM_SIGNATURE_ARRAY;\n+  if (element_klass->is_instance_klass()) { \/\/ it could be an array or simple type\n+    new_str[idx++] = JVM_SIGNATURE_CLASS;\n+  }\n+  memcpy(&new_str[idx], name_str, len * sizeof(char));\n+  idx += len;\n+  if (element_klass->is_instance_klass()) {\n+    new_str[idx++] = JVM_SIGNATURE_ENDCLASS;\n+  }\n+  new_str[idx] = '\\0';\n+  return SymbolTable::new_symbol(new_str);\n+}\n+\n+\n@@ -90,1 +110,1 @@\n-  Symbol* name = ArrayKlass::create_element_klass_array_name(element_klass, CHECK_NULL);\n+  Symbol* name = create_element_klass_array_name(THREAD, element_klass);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -57,0 +57,5 @@\n+\n+ protected:\n+  \/\/ Create array_name for element klass\n+  static Symbol* create_element_klass_array_name(JavaThread* current, Klass* element_klass);\n+\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+  inline narrowKlass narrow_klass() const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -144,0 +144,11 @@\n+narrowKlass oopDesc::narrow_klass() const {\n+  switch (ObjLayout::klass_mode()) {\n+    case ObjLayout::Compact:\n+      return mark().narrow_klass();\n+    case ObjLayout::Compressed:\n+      return _metadata._compressed_klass;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2593,0 +2593,18 @@\n+  \/\/ Check for redundant conversion patterns:\n+  \/\/ ConvD2L->ConvL2D->ConvD2L\n+  \/\/ ConvF2I->ConvI2F->ConvF2I\n+  \/\/ ConvF2L->ConvL2F->ConvF2L\n+  \/\/ ConvI2F->ConvF2I->ConvI2F\n+  \/\/ Note: there may be other 3-nodes conversion chains that would require to be added here, but these\n+  \/\/ are the only ones that are known to trigger missed optimizations otherwise\n+  if ((n->Opcode() == Op_ConvD2L && use_op == Op_ConvL2D) ||\n+      (n->Opcode() == Op_ConvF2I && use_op == Op_ConvI2F) ||\n+      (n->Opcode() == Op_ConvF2L && use_op == Op_ConvL2F) ||\n+      (n->Opcode() == Op_ConvI2F && use_op == Op_ConvF2I)) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == n->Opcode()) {\n+        worklist.push(u);\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -1177,1 +1180,0 @@\n-      JFR_ONLY(k_new_method->copy_trace_flags(k_old_method->trace_flags());)\n@@ -4458,1 +4460,1 @@\n-  JFR_ONLY(ON_KLASS_REDEFINITION(the_class, current);)\n+  JFR_ONLY(Jfr::on_klass_redefinition(the_class, scratch_class);)\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+#include \"utilities\/vmError.hpp\"\n@@ -2839,0 +2840,8 @@\n+WB_ENTRY(void, WB_ControlledCrash(JNIEnv* env, jobject o, jint how))\n+#ifdef ASSERT\n+  VMError::controlled_crash(how);\n+#else\n+  THROW_MSG(vmSymbols::java_lang_UnsupportedOperationException(), \"Only available in debug builds\");\n+#endif\n+WB_END\n+\n@@ -3136,1 +3145,2 @@\n-  {CC\"isStatic\", CC\"()Z\",                             (void*)&WB_IsStaticallyLinked}\n+  {CC\"isStatic\", CC\"()Z\",                             (void*)&WB_IsStaticallyLinked},\n+  {CC\"controlledCrash\",CC\"(I)V\",                      (void*)&WB_ControlledCrash},\n@@ -3139,1 +3149,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -566,0 +566,17 @@\n+  { \"AdaptiveSizeMajorGCDecayTimeScale\",                JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"AdaptiveSizePolicyInitializingSteps\",              JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"AdaptiveSizePolicyOutputInterval\",                 JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"AdaptiveSizeThroughPutPolicy\",                     JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"AdaptiveTimeWeight\",                               JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"PausePadding\",                                     JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"SurvivorPadding\",                                  JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"TenuredGenerationSizeIncrement\",                   JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"TenuredGenerationSizeSupplement\",                  JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"TenuredGenerationSizeSupplementDecay\",             JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"UseAdaptiveGenerationSizePolicyAtMajorCollection\", JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"UseAdaptiveGenerationSizePolicyAtMinorCollection\", JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"UseAdaptiveSizeDecayMajorGCCost\",                  JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"UseAdaptiveSizePolicyFootprintGoal\",               JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"UseAdaptiveSizePolicyWithSystemGC\",                JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+  { \"UsePSAdaptiveSurvivorSizePolicy\",                  JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+\n@@ -1592,1 +1609,1 @@\n-          aot_log_info(aot)(\"UseCompressedOops and UseCompressedClassPointers have been disabled due to\"\n+          aot_log_info(aot)(\"UseCompressedOops disabled due to\"\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -621,3 +621,0 @@\n-  product(bool, VerifyAdapterCalls, trueInDebug, DIAGNOSTIC,                \\\n-          \"Verify that i2c\/c2i adapters are called properly\")               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -644,1 +644,1 @@\n-#define STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                      \\\n+#define STUBGEN_INITIAL_BLOBS_DO(do_blob, end_blob,                     \\\n@@ -664,1 +664,0 @@\n-  do_entry(initial, updateBytesCRC32, crc_table_adr, crc_table_addr)    \\\n@@ -668,2 +667,0 @@\n-  do_entry(initial, updateBytesCRC32C, crc32c_table_addr,               \\\n-           crc32c_table_addr)                                           \\\n@@ -899,0 +896,3 @@\n+  do_stub(final, unsafecopy_common)                                     \\\n+  do_entry(final, unsafecopy_common, unsafecopy_common_exit,            \\\n+           unsafecopy_common_exit)                                      \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -139,0 +139,29 @@\n+\/\/ Used to retrieve mark regions that lie within a generated stub so\n+\/\/ they can be saved along with the stub and used to reinit the table\n+\/\/ when the stub is reloaded.\n+\n+void UnsafeMemoryAccess::collect_entries(address range_start, address range_end, GrowableArray<address>& entries)\n+{\n+  for (int i = 0; i < _table_length; i++) {\n+    UnsafeMemoryAccess& e = _table[i];\n+    assert((e._start_pc != nullptr &&\n+            e._end_pc != nullptr &&\n+            e._error_exit_pc != nullptr),\n+           \"search for entries found incomplete table entry\");\n+    if (e._start_pc >= range_start && e._end_pc <= range_end) {\n+      assert(((e._error_exit_pc >= range_start &&\n+               e._error_exit_pc <= range_end) ||\n+              e._error_exit_pc == _common_exit_stub_pc),\n+             \"unexpected error exit pc\");\n+      entries.append(e._start_pc);\n+      entries.append(e._end_pc);\n+      \/\/ only return an exit pc when it is within the range of the stub\n+      if (e._error_exit_pc != _common_exit_stub_pc) {\n+        entries.append(e._error_exit_pc);\n+      } else {\n+        \/\/ an address outside the stub must be the common exit stub address\n+        entries.append(nullptr);\n+      }\n+    }\n+  }\n+}\n@@ -152,1 +181,1 @@\n-      return nullptr;\n+    return nullptr;\n@@ -166,1 +195,3 @@\n-  assert(code_size == 0 || buffer.insts_remaining() > 200, \"increase %s\", assert_msg);\n+  assert(code_size == 0 || buffer.insts_remaining() > 200,\n+         \"increase %s, code_size: %d, used: %d, free: %d\",\n+         assert_msg, code_size, buffer.total_content_size(), buffer.insts_remaining());\n@@ -175,0 +206,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -143,0 +144,4 @@\n+  \/\/ Append to entries arrray start, end and exit pcs of all table\n+  \/\/ entries that identify a sub-interval of range (range_start,\n+  \/\/ range_end). Append nullptr if the exit pc is not in the range.\n+  static void collect_entries(address range_start, address range_end, GrowableArray<address>& entries);\n@@ -310,0 +315,6 @@\n+  \/\/ These methods is implemented in architecture-specific code.\n+  \/\/ Any table that is returned must be allocated once-only in\n+  \/\/ foreign memory (or C heap) rather generated in the code cache.\n+  static address crc_table_addr();\n+  static address crc32c_table_addr();\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n@@ -35,1 +35,1 @@\n-#include \"compiler\/compiler_globals.hpp\"\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -40,1 +40,1 @@\n-#include \"memory\/metaspaceUtils.hpp\"\n+#include \"memory\/metaspaceUtils.hpp\"\n@@ -58,1 +58,1 @@\n-#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n@@ -72,1 +72,1 @@\n-#include \"os_posix.hpp\"\n+#include \"os_posix.hpp\"\n@@ -75,0 +75,1 @@\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/method.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"oops\/method.hpp\"\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -44,2 +46,0 @@\n-#include \"oops\/flatArrayKlass.hpp\"\n-#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -59,0 +59,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -62,1 +63,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"utilities\/copy.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/copy.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\/\/ Get constants like JVM_T_CHAR and JVM_SIGNATURE_INT, before pulling in <jvm.h>.\n+#include \"classfile_constants.h\"\n@@ -33,3 +35,0 @@\n-\/\/ Get constants like JVM_T_CHAR and JVM_SIGNATURE_INT, before pulling in <jvm.h>.\n-#include \"classfile_constants.h\"\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"memory\/iterator.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import java.lang.reflect.Proxy;\n@@ -86,0 +85,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -218,0 +219,1 @@\n+@AOTSafeClassInitializer\n@@ -233,1 +235,3 @@\n-    \/\/ Called from JVM when loading an AOT cache\n+    \/\/\/ No significant static final fields; [#resetArchivedStates()] handles\n+    \/\/\/ prevents storing [#reflectionFactory] into AOT image.\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -49,0 +50,1 @@\n+@AOTSafeClassInitializer \/\/ for hierarchy checks\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -53,0 +54,1 @@\n+@AOTSafeClassInitializer\n@@ -475,0 +477,1 @@\n+    @AOTSafeClassInitializer\n@@ -1075,0 +1078,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -30,0 +31,1 @@\n+import java.lang.classfile.Annotation;\n@@ -31,0 +33,1 @@\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -71,0 +74,1 @@\n+    static final Annotation AOT_SAFE_ANNOTATION = Annotation.of(AOTSafeClassInitializer.class.describeConstable().orElseThrow());\n@@ -585,0 +589,1 @@\n+               .with(RuntimeVisibleAnnotationsAttribute.of(AOT_SAFE_ANNOTATION))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -125,0 +126,1 @@\n+@AOTSafeClassInitializer\n@@ -1059,0 +1061,1 @@\n+    @AOTSafeClassInitializer\n@@ -1755,0 +1758,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -75,0 +77,1 @@\n+@AOTSafeClassInitializer\n@@ -161,0 +164,1 @@\n+    @AOTSafeClassInitializer\n@@ -456,0 +460,1 @@\n+    @AOTSafeClassInitializer\n@@ -678,0 +683,1 @@\n+    @AOTSafeClassInitializer\n@@ -713,0 +719,1 @@\n+    @AOTSafeClassInitializer\n@@ -1038,0 +1045,1 @@\n+    @AOTSafeClassInitializer\n@@ -1146,0 +1154,1 @@\n+        @AOTSafeClassInitializer\n@@ -1288,0 +1297,1 @@\n+    @AOTSafeClassInitializer\n@@ -1351,0 +1361,1 @@\n+    @AOTSafeClassInitializer\n@@ -1531,1 +1542,1 @@\n-    \/\/ Also called from JVM when loading an AOT cache\n+    @AOTRuntimeSetup\n@@ -1791,0 +1802,1 @@\n+    @AOTSafeClassInitializer\n@@ -2118,0 +2130,1 @@\n+    @AOTSafeClassInitializer\n@@ -2147,0 +2160,1 @@\n+    @AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -86,0 +87,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -827,0 +827,1 @@\n+\/\/            System.out.println(\"import jdk.internal.vm.annotation.AOTSafeClassInitializer;\");\n@@ -833,0 +834,1 @@\n+\/\/            System.out.println(\"@AOTSafeClassInitializer\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -54,1 +56,1 @@\n-\n+@AOTSafeClassInitializer\n@@ -305,1 +307,1 @@\n-    \/\/ Also called from JVM when loading an AOT cache\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -267,0 +269,1 @@\n+@AOTSafeClassInitializer\n@@ -606,1 +609,1 @@\n-    \/\/ Called from JVM when loading an AOT cache.\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -56,1 +58,1 @@\n-\n+@AOTSafeClassInitializer\n@@ -64,1 +66,3 @@\n-    \/\/ Called from JVM when loading an AOT cache\n+    \/\/\/ BASE_OFFSET, INDEX_SCALE, and ADDRESS_SIZE fields are equivalent if the\n+    \/\/\/ AOT initialized heap is reused, so just register natives\n+    @AOTRuntimeSetup\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-gc\/g1\/humongousObjects\/objectGraphTest\/TestObjectGraphAfterGC.java 8156755 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -633,0 +633,15 @@\n+    public static final String CMP_LT_MASK = PREFIX + \"CMP_LT_MASK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_LT_MASK, \"CmpLTMask\");\n+    }\n+\n+    public static final String ROUND_F = PREFIX + \"ROUND_F\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROUND_F, \"RoundF\");\n+    }\n+\n+    public static final String ROUND_D = PREFIX + \"ROUND_D\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ROUND_D, \"RoundD\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -563,0 +563,2 @@\n+com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreads.java     8364314 generic-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -868,0 +868,3 @@\n+\n+  \/\/ Force a controlled crash (debug builds only)\n+  public native void controlledCrash(int how);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}