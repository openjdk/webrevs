{"files":[{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.javac.PreviewFeature.Feature;\n+\n+\/**\n+ * NullRestrictedType represents a null-restricted type such as\n+ * {@code String!}.\n+ *\n+ * <p>Instances of classes that implement this interface must implement\n+ * an equals() method that equates any two null rrestricted type instances that\n+ * share the same base type.\n+ *\/\n+@PreviewFeature(feature = Feature.VALUE_OBJECTS, reflective = true)\n+public interface NullRestrictedType extends Type {\n+    \/**\n+     * {@return the {@code Type} object representing the type to which the null-restriction has\n+     * been applied}\n+     *\/\n+    Type getBaseType();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/NullRestrictedType.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.NullRestrictedType;\n@@ -108,0 +109,4 @@\n+    public NullRestrictedType makeNullRestrictedType(Type baseType) {\n+        return NullRestrictedTypeImpl.make(baseType);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/factory\/CoreReflectionFactory.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.NullRestrictedType;\n@@ -62,0 +63,8 @@\n+\n+    \/**\n+     * {@return an instance of the {@code NullRestrictedType} interface\n+     * that corresponds to a null restricted projection of a given base type}\n+     * @param baseType the base type\n+     *\/\n+    NullRestrictedType makeNullRestrictedType(Type baseType);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/factory\/GenericsFactory.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -453,0 +453,1 @@\n+     *     NullRestrictedType\n@@ -467,0 +468,3 @@\n+        case '!':\n+            return parseNullRestrictedTypeSignature();\n+\n@@ -505,0 +509,7 @@\n+    private NullRestrictedTypeSignature parseNullRestrictedTypeSignature() {\n+        advance();\n+        FieldTypeSignature restrictedType = parseFieldTypeSignature();\n+        return NullRestrictedTypeSignature.make(restrictedType);\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/parser\/SignatureParser.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.reflect.generics.reflectiveObjects;\n+\n+import java.lang.reflect.NullRestrictedType;\n+import java.lang.reflect.Type;\n+import java.util.Objects;\n+\n+\/** Implementing class for NullRestrictedType interface. *\/\n+\n+public class NullRestrictedTypeImpl implements NullRestrictedType {\n+    private final Type baseType;\n+\n+    private NullRestrictedTypeImpl(Type baseType) {\n+        this.baseType = baseType;\n+        checkNonRestricted(baseType);\n+    }\n+\n+    private void checkNonRestricted(Type type) {\n+        if (type instanceof NullRestrictedType) {\n+            throw new IllegalArgumentException(\"Already a null-rrestricted type\");\n+        }\n+    }\n+\n+    \/**\n+     * Static factory. Given a type, creates a null-restricted type\n+     * @param baseType the type to which the null restriction is applied\n+     * @throws IllegalArgumentException if {@code baseType} is a null-restricted type\n+     *\/\n+    public static NullRestrictedTypeImpl make(Type baseType) {\n+        return new NullRestrictedTypeImpl(baseType);\n+    }\n+\n+    @Override\n+    public Type getBaseType() {\n+        return baseType;\n+    }\n+\n+    \/*\n+     * From the JavaDoc for java.lang.reflect.NullRestrictedType\n+     * \"Instances of classes that implement this interface must implement\n+     * an equals() method that equates any two null rrestricted type instances that\n+     * share the same base type.\"\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o)\n+            return true;\n+        return o instanceof NullRestrictedType that &&\n+                Objects.equals(baseType, that.getBaseType());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return\n+            Objects.hashCode(baseType) ^ 17;\n+    }\n+\n+    public String toString() {\n+        return baseType.getTypeName() + \"!\";\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/reflectiveObjects\/NullRestrictedTypeImpl.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.reflect.generics.tree;\n+\n+import sun.reflect.generics.visitor.TypeTreeVisitor;\n+\n+public class NullRestrictedTypeSignature implements TypeSignature {\n+    private final FieldTypeSignature baseType;\n+\n+    private NullRestrictedTypeSignature(FieldTypeSignature baseType) {\n+        this.baseType = baseType;\n+    }\n+\n+    public static NullRestrictedTypeSignature make(FieldTypeSignature ft) {\n+        return new NullRestrictedTypeSignature(ft);\n+    }\n+\n+    public FieldTypeSignature getBaseType(){return baseType;}\n+\n+    public void accept(TypeTreeVisitor<?> v){\n+        v.visitNullRestrictedTypeSignature(this);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/tree\/NullRestrictedTypeSignature.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -82,0 +82,7 @@\n+    @Override\n+    public void visitNullRestrictedTypeSignature(NullRestrictedTypeSignature nt) {\n+        nt.getBaseType().accept(this);\n+        Type baseType = resultType;\n+        resultType = getFactory().makeNullRestrictedType(baseType);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/visitor\/Reifier.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+    void visitNullRestrictedTypeSignature(NullRestrictedTypeSignature nt);\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/visitor\/TypeTreeVisitor.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.io.UncheckedIOException;\n@@ -44,0 +45,4 @@\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+import java.util.Optional;\n@@ -197,0 +202,25 @@\n+    \/**\n+     * Parse, analyze, perform code generation for the sources associated with this task and finally\n+     * executes them\n+     *\/\n+    public void execute(Consumer<ExecutionTask> c) {\n+        generate(generationResult -> {\n+            try {\n+                if (generationResult.hasErrors()) {\n+                    \/\/ we have nothing else to do\n+                    return;\n+                }\n+                Iterable<? extends JavaFileObject> jfoIterable = generationResult.get();\n+                java.util.List<URL> urlList = new ArrayList<>();\n+                for (JavaFileObject jfo : jfoIterable) {\n+                    String urlStr = jfo.toUri().toURL().toString();\n+                    urlStr = urlStr.substring(0, urlStr.length() - jfo.getName().length());\n+                    urlList.add(new URL(urlStr));\n+                }\n+                c.accept(new ExecutionTask(new URLClassLoader(urlList.toArray(new URL[urlList.size()]))));\n+            } catch (IOException ex) {\n+                throw new AssertionError(ex);\n+            }\n+        });\n+    }\n+\n@@ -245,6 +275,1 @@\n-            Assert.check(className != null, \"class name value is null, impossible to proceed\");\n-            try {\n-                c = classLoader.loadClass(className);\n-            } catch (Throwable t) {\n-                throw new IllegalStateException(t);\n-            }\n+            load(className);\n@@ -279,0 +304,9 @@\n+\n+        public Class<?> load(String className) {\n+            Assert.check(className != null, \"class name value is null, impossible to proceed\");\n+            try {\n+                return classLoader.loadClass(className);\n+            } catch (Throwable t) {\n+                throw new IllegalStateException(t);\n+            }\n+        }\n","filename":"test\/langtools\/tools\/javac\/lib\/combo\/ComboTask.java","additions":40,"deletions":6,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for null restriction parsing\n+ * @library \/tools\/javac\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build combo.ComboTestHelper\n+\n+ * @run main NullRestrictionReflectiveTest\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask.ExecutionTask;\n+import combo.ComboTestHelper;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+public class NullRestrictionReflectiveTest extends ComboInstance<NullRestrictionReflectiveTest> {\n+\n+    enum TypeKind implements ComboParameter {\n+        NN_STRING(\"java.lang.String!\"),\n+        NN_STRING_ARR(\"java.lang.String[]!\"),\n+        NN_STRING_ARR_ARR(\"java.lang.String[][]!\"),\n+        NN_LIST_STRING(\"java.util.List<java.lang.String>!\"),\n+        NN_TVAR(\"X!\"),\n+        NN_TVAR_ARR(\"X[]!\"),\n+        NN_TVAR_ARR_ARR(\"T[][]!\"),\n+        NN_LIST_TVAR(\"java.util.List<X>!\");\n+\n+        final String typeString;\n+\n+        TypeKind(String typeString) {\n+            this.typeString = typeString;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            return typeString;\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<NullRestrictionReflectiveTest>()\n+                .withDimension(\"TYPE\", (x, tk) -> x.tk = tk, TypeKind.values())\n+                .run(NullRestrictionReflectiveTest::new);\n+    }\n+\n+    TypeKind tk;\n+\n+    static final String TEMPLATE = \"\"\"\n+            import java.util.List;\n+\n+            class Test<X> {\n+\n+                <Z> Z init() { return null; }\n+\n+                #{TYPE} fld = init();\n+\n+                #{TYPE} meth(#{TYPE} arg) {\n+                    return init();\n+                }\n+            }\n+            \"\"\";\n+\n+    @Override\n+    public void doWork() throws IOException {\n+        newCompilationTask()\n+                .withOptions(List.of(\"--enable-preview\", \"--release\", \"26\"))\n+                .withSourceFromTemplate(TEMPLATE)\n+                .execute(this::check);\n+    }\n+\n+    void check(ExecutionTask executionTask) {\n+        try {\n+            Class<?> testClass = executionTask.load(\"Test\");\n+\n+            \/\/ check field type\n+            Field testField = testClass.getDeclaredField(\"fld\");\n+            checkType(testField.getGenericType());\n+\n+            \/\/ check method arguments and return type\n+            Method testMethod = testClass.getDeclaredMethod(\"meth\");\n+            checkType(testMethod.getGenericReturnType());\n+            checkType(testMethod.getGenericParameterTypes()[0]);\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    void checkType(Type type) {\n+        if (!type.getTypeName().equals(tk.typeString)) {\n+            fail(\"Type mismatch detected:\\n\" +\n+                    \"\\nFound type: \" + type.getTypeName() +\n+                    \"\\nExpected error: \" + tk.typeString);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/nullability\/NullRestrictionReflectiveTest.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"}]}