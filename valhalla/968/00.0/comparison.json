{"files":[{"patch":"@@ -1509,0 +1509,2 @@\n+\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += libNativeException.c\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1727,2 +1727,2 @@\n-    st->print(\"ldr zr, [lr]\\n\\t\");\n-    st->print(\"pacia  lr, rfp\\n\\t\");\n+    st->print(\"ldr  zr, [lr]\\n\\t\");\n+    st->print(\"paciaz\\n\\t\");\n@@ -1814,2 +1814,2 @@\n-    st->print(\"autia lr, rfp\\n\\t\");\n-    st->print(\"ldr zr, [lr]\\n\\t\");\n+    st->print(\"autiaz\\n\\t\");\n+    st->print(\"ldr  zr, [lr]\\n\\t\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-    __ authenticate_return_address(exception_pc, rscratch1);\n+    __ authenticate_return_address(exception_pc);\n@@ -437,1 +437,1 @@\n-  __ protect_return_address(exception_pc, rscratch1);\n+  __ protect_return_address(exception_pc);\n@@ -453,1 +453,1 @@\n-  __ protect_return_address(r0, rscratch1);\n+  __ protect_return_address(r0);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,2 +142,1 @@\n-      sender_pc = pauth_strip_verifiable((address) this->fp()[return_addr_offset], (address)saved_fp);\n-\n+      sender_pc = pauth_strip_verifiable((address) this->fp()[return_addr_offset]);\n@@ -160,1 +159,3 @@\n-      sender_pc = pauth_strip_verifiable((address) *(sender_sp-1), (address)saved_fp);\n+      \/\/ Note: PAC authentication may fail in case broken frame is passed in.\n+      \/\/ Just strip it for now.\n+      sender_pc = pauth_strip_pointer((address) *(sender_sp - 1));\n@@ -282,3 +283,2 @@\n-  address signing_sp = (((address*) sp())[-2]);\n-  address signed_pc = pauth_sign_return_address(pc, (address)signing_sp);\n-  address pc_old = pauth_strip_verifiable(*pc_addr, (address)signing_sp);\n+  address signed_pc = pauth_sign_return_address(pc);\n+  address pc_old = pauth_strip_verifiable(*pc_addr);\n@@ -348,1 +348,1 @@\n-  BasicObjectLock* result = (BasicObjectLock*) at(interpreter_frame_monitor_block_top_offset);\n+  BasicObjectLock* result = (BasicObjectLock*) at_relative(interpreter_frame_monitor_block_top_offset);\n@@ -356,1 +356,4 @@\n-  *((BasicObjectLock**)addr_at(interpreter_frame_monitor_block_top_offset)) = value;\n+  assert(is_interpreted_frame(), \"interpreted frame expected\");\n+  \/\/ set relativized monitor_block_top\n+  ptr_at_put(interpreter_frame_monitor_block_top_offset, (intptr_t*)value - fp());\n+  assert(at_absolute(interpreter_frame_monitor_block_top_offset) <= interpreter_frame_monitor_block_top_offset, \"\");\n@@ -482,2 +485,3 @@\n-  \/\/ For ROP protection, Interpreter will have signed the sender_pc, but there is no requirement to authenticate it here.\n-  address sender_pc = pauth_strip_verifiable(sender_pc_maybe_signed(), (address)link());\n+  \/\/ For ROP protection, Interpreter will have signed the sender_pc,\n+  \/\/ but there is no requirement to authenticate it here.\n+  address sender_pc = pauth_strip_verifiable(sender_pc_maybe_signed());\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -157,1 +157,4 @@\n-inline frame::frame(intptr_t* sp) : frame(sp, sp, *(intptr_t**)(sp - frame::sender_sp_offset), *(address*)(sp - 1)) {}\n+inline frame::frame(intptr_t* sp)\n+  : frame(sp, sp,\n+          *(intptr_t**)(sp - frame::sender_sp_offset),\n+          pauth_strip_verifiable(*(address*)(sp - 1))) {}\n@@ -422,1 +425,1 @@\n-   address sender_pc_copy = pauth_strip_verifiable((address) *(l_sender_sp-1), (address) *(l_sender_sp-2));\n+   address sender_pc_copy = pauth_strip_verifiable((address) *(l_sender_sp-1));\n@@ -432,3 +435,4 @@\n-  \/\/ the return_address is always the word on the stack\n-  \/\/ For ROP protection, C1\/C2 will have signed the sender_pc, but there is no requirement to authenticate it here.\n-  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp-1), (address) *(l_sender_sp-2));\n+  \/\/ The return_address is always the word on the stack.\n+  \/\/ For ROP protection, C1\/C2 will have signed the sender_pc,\n+  \/\/ but there is no requirement to authenticate it here.\n+  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp - 1));\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -703,2 +703,4 @@\n-    ldr(c_rarg1, monitor_block_top); \/\/ points to current entry, starting\n-                                     \/\/ with top-most entry\n+    ldr(c_rarg1, monitor_block_top); \/\/ derelativize pointer\n+    lea(c_rarg1, Address(rfp, c_rarg1, Address::lsl(Interpreter::logStackElementSize)));\n+    \/\/ c_rarg1 points to current entry, starting with top-most entry\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -201,1 +201,2 @@\n-    ldr(esp, Address(rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize));\n+    ldr(rscratch1, Address(rfp, frame::interpreter_frame_monitor_block_top_offset * wordSize));\n+    lea(esp, Address(rfp, rscratch1, Address::lsl(LogBytesPerWord)));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6885,1 +6885,1 @@\n-\/\/ Uses the FP as the modifier.\n+\/\/ Uses value zero as the modifier.\n@@ -6890,4 +6890,1 @@\n-    \/\/ The standard convention for C code is to use paciasp, which uses SP as the modifier. This\n-    \/\/ works because in C code, FP and SP match on function entry. In the JDK, SP and FP may not\n-    \/\/ match, so instead explicitly use the FP.\n-    pacia(lr, rfp);\n+    paciaz();\n@@ -6899,2 +6896,1 @@\n-\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n-\/\/ the current FP.\n+\/\/ Uses value zero as the modifier.\n@@ -6902,1 +6898,1 @@\n-void MacroAssembler::protect_return_address(Register return_reg, Register temp_reg) {\n+void MacroAssembler::protect_return_address(Register return_reg) {\n@@ -6904,3 +6900,1 @@\n-    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n-    ldr(temp_reg, Address(rfp));\n-    pacia(return_reg, temp_reg);\n+    paciza(return_reg);\n@@ -6912,0 +6906,1 @@\n+\/\/ Uses value zero as the modifier.\n@@ -6913,1 +6908,1 @@\n-void MacroAssembler::authenticate_return_address(Register return_reg) {\n+void MacroAssembler::authenticate_return_address() {\n@@ -6915,2 +6910,2 @@\n-    autia(return_reg, rfp);\n-    check_return_address(return_reg);\n+    autiaz();\n+    check_return_address();\n@@ -6922,2 +6917,1 @@\n-\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n-\/\/ the current FP.\n+\/\/ Uses value zero as the modifier.\n@@ -6925,1 +6919,1 @@\n-void MacroAssembler::authenticate_return_address(Register return_reg, Register temp_reg) {\n+void MacroAssembler::authenticate_return_address(Register return_reg) {\n@@ -6927,3 +6921,1 @@\n-    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n-    ldr(temp_reg, Address(rfp));\n-    autia(return_reg, temp_reg);\n+    autiza(return_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -756,3 +756,3 @@\n-  void protect_return_address(Register return_reg, Register temp_reg);\n-  void authenticate_return_address(Register return_reg = lr);\n-  void authenticate_return_address(Register return_reg, Register temp_reg);\n+  void protect_return_address(Register return_reg);\n+  void authenticate_return_address();\n+  void authenticate_return_address(Register return_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -475,1 +475,1 @@\n-  __ authenticate_return_address(c_rarg1, rscratch1);\n+  __ authenticate_return_address(c_rarg1);\n@@ -1458,0 +1458,1 @@\n+      __ authenticate_return_address(c_rarg1);\n@@ -2629,1 +2630,1 @@\n-  __ protect_return_address(r3, rscratch1);\n+  __ protect_return_address(r3);\n@@ -2735,3 +2736,1 @@\n-  __ ldp(rfp, lr, __ post(sp, 2 * wordSize));\n-  __ authenticate_return_address();\n-  \/\/ LR should now be the return address to the caller (3)\n+  __ ldp(rfp, zr, __ post(sp, 2 * wordSize));\n@@ -2952,3 +2951,1 @@\n-  __ ldp(rfp, lr, __ post(sp, 2 * wordSize));\n-  __ authenticate_return_address();\n-  \/\/ LR should now be the return address to the caller (3) frame\n+  __ ldp(rfp, zr, __ post(sp, 2 * wordSize));\n@@ -3100,1 +3097,1 @@\n-    __ protect_return_address(r20, rscratch1);\n+    __ protect_return_address(r20);\n@@ -3141,1 +3138,1 @@\n-    __ authenticate_return_address(r20, rscratch1);\n+    __ authenticate_return_address(r20);\n@@ -3156,1 +3153,1 @@\n-    __ protect_return_address(r20, rscratch1);\n+    __ protect_return_address(r20);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -7038,0 +7038,1 @@\n+      __ authenticate_return_address(c_rarg1);\n@@ -7039,1 +7040,2 @@\n-      __ mov(r19, r0); \/\/ save return value contaning the exception oop in callee-saved R19\n+      \/\/ save return value containing the exception oop in callee-saved R19\n+      __ mov(r19, r0);\n@@ -7049,1 +7051,1 @@\n-      __ mov(r0, r19); \/\/ restore return value contaning the exception oop\n+      __ mov(r0, r19); \/\/ restore return value containing the exception oop\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -373,0 +373,1 @@\n+    __ lea(rscratch1, Address(rfp, rscratch1, Address::lsl(Interpreter::logStackElementSize)));\n@@ -826,1 +827,4 @@\n-  __ str(esp, monitor_block_top);  \/\/ set new monitor block top\n+  __ sub(rscratch1, esp, rfp);\n+  __ asr(rscratch1, rscratch1, Interpreter::logStackElementSize);\n+  __ str(rscratch1, monitor_block_top);  \/\/ set new monitor block top\n+\n@@ -847,1 +851,2 @@\n-    __ stp(esp, zr, Address(__ pre(sp, -14 * wordSize)));\n+    __ mov(rscratch1, frame::interpreter_frame_initial_sp_offset);\n+    __ stp(rscratch1, zr, Address(__ pre(sp, -14 * wordSize)));\n@@ -854,1 +859,2 @@\n-    __ stp(esp, rbcp, Address(__ pre(sp, -12 * wordSize)));\n+    __ mov(rscratch1, frame::interpreter_frame_initial_sp_offset);\n+    __ stp(rscratch1, rbcp, Address(__ pre(sp, -12 * wordSize)));\n@@ -1268,0 +1274,1 @@\n+    __ lea(rscratch1, Address(rfp, rscratch1, Address::lsl(Interpreter::logStackElementSize)));\n@@ -1720,0 +1727,1 @@\n+    __ lea(rscratch1, Address(rfp, rscratch1, Address::lsl(Interpreter::logStackElementSize)));\n@@ -1843,1 +1851,1 @@\n-    __ authenticate_return_address(c_rarg1, rscratch1);\n+    __ authenticate_return_address(c_rarg1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4161,2 +4161,4 @@\n-    __ ldr(c_rarg3, monitor_block_top); \/\/ points to current entry,\n-                                        \/\/ starting with top-most entry\n+    __ ldr(c_rarg3, monitor_block_top); \/\/ derelativize pointer\n+    __ lea(c_rarg3, Address(rfp, c_rarg3, Address::lsl(Interpreter::logStackElementSize)));\n+    \/\/ c_rarg3 points to current entry, starting with top-most entry\n+\n@@ -4201,1 +4203,4 @@\n-    __ ldr(c_rarg1, monitor_block_bot);   \/\/ c_rarg1: old expression stack bottom\n+    __ ldr(c_rarg1, monitor_block_bot);   \/\/ derelativize pointer\n+    __ lea(c_rarg1, Address(rfp, c_rarg1, Address::lsl(Interpreter::logStackElementSize)));\n+    \/\/ c_rarg1 points to the old expression stack bottom\n+\n@@ -4205,1 +4210,3 @@\n-    __ str(c_rarg1, monitor_block_bot);   \/\/ set new monitor block bottom\n+    __ sub(rscratch1, c_rarg1, rfp);      \/\/ relativize pointer\n+    __ asr(rscratch1, rscratch1, Interpreter::logStackElementSize);\n+    __ str(rscratch1, monitor_block_bot);  \/\/ set new monitor block bottom\n@@ -4279,2 +4286,4 @@\n-    __ ldr(c_rarg1, monitor_block_top); \/\/ points to current entry,\n-                                        \/\/ starting with top-most entry\n+    __ ldr(c_rarg1, monitor_block_top); \/\/ derelativize pointer\n+    __ lea(c_rarg1, Address(rfp, c_rarg1, Address::lsl(Interpreter::logStackElementSize)));\n+    \/\/ c_rarg1 points to current entry, starting with top-most entry\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2385,2 +2385,0 @@\n-  __ cmpdi(CCR0, obj, 0);\n-\n@@ -2398,1 +2396,0 @@\n-    __ bne(CCR0, not_null);\n@@ -2401,0 +2398,2 @@\n+    __ cmpdi(CCR0, obj, 0);\n+    __ bne(CCR0, not_null);\n@@ -2406,0 +2405,10 @@\n+\n+    Label update_done;\n+    Register recv = klass_RInfo;\n+    __ load_klass(recv, obj);\n+    type_profile_helper(mdo, mdo_offset_bias, md, data, recv, Rtmp1, &update_done);\n+    const int slot_offset = md->byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias;\n+    __ ld(Rtmp1, slot_offset, mdo);\n+    __ addi(Rtmp1, Rtmp1, DataLayout::counter_increment);\n+    __ std(Rtmp1, slot_offset, mdo);\n+    __ bind(update_done);\n@@ -2407,0 +2416,1 @@\n+    __ cmpdi(CCR0, obj, 0);\n@@ -2419,4 +2429,0 @@\n-  Label profile_cast_failure, failure_restore_obj, profile_cast_success;\n-  Label *failure_target = should_profile ? &profile_cast_failure : failure;\n-  Label *success_target = should_profile ? &profile_cast_success : success;\n-\n@@ -2426,7 +2432,2 @@\n-    if (should_profile) {\n-      __ bne(CCR0, *failure_target);\n-      \/\/ Fall through to success case.\n-    } else {\n-      __ beq(CCR0, *success);\n-      \/\/ Fall through to failure case.\n-    }\n+    __ beq(CCR0, *success);\n+    \/\/ Fall through to failure case.\n@@ -2440,2 +2441,2 @@\n-      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, (need_slow_path ? success_target : nullptr),\n-                                       failure_target, nullptr, RegisterOrConstant(k->super_check_offset()));\n+      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, (need_slow_path ? success : nullptr),\n+                                       failure, nullptr, RegisterOrConstant(k->super_check_offset()));\n@@ -2444,1 +2445,1 @@\n-      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, failure_target);\n+      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success, failure);\n@@ -2447,1 +2448,1 @@\n-      if (!should_profile) { __ b(*success); }\n+      __ b(*success);\n@@ -2456,1 +2457,0 @@\n-      bool keep_klass_RInfo_alive = (obj == original_klass_RInfo) && should_profile;\n@@ -2465,12 +2465,3 @@\n-      if (keep_obj_alive) {\n-        if (keep_klass_RInfo_alive) { __ mr(R0, obj); }\n-        __ mr(obj, dst);\n-      }\n-      if (should_profile) {\n-        __ bne(CCR0, *failure_target);\n-        if (keep_klass_RInfo_alive) { __ mr(klass_RInfo, keep_obj_alive ? R0 : obj); }\n-        \/\/ Fall through to success case.\n-      } else {\n-        __ beq(CCR0, *success);\n-        \/\/ Fall through to failure case.\n-      }\n+      if (keep_obj_alive) { __ mr(obj, dst); }\n+      __ beq(CCR0, *success);\n+      \/\/ Fall through to failure case.\n@@ -2480,18 +2471,0 @@\n-  if (should_profile) {\n-    Register mdo = k_RInfo, recv = klass_RInfo;\n-    assert_different_registers(mdo, recv, Rtmp1);\n-    __ bind(profile_cast_success);\n-    metadata2reg(md->constant_encoding(), mdo);\n-    __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);\n-    type_profile_helper(mdo, mdo_offset_bias, md, data, recv, Rtmp1, success);\n-    __ b(*success);\n-\n-    \/\/ Cast failure case.\n-    __ bind(profile_cast_failure);\n-    metadata2reg(md->constant_encoding(), mdo);\n-    __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);\n-    __ ld(Rtmp1, md->byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);\n-    __ addi(Rtmp1, Rtmp1, -DataLayout::counter_increment);\n-    __ std(Rtmp1, md->byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);\n-  }\n-\n@@ -2523,3 +2496,2 @@\n-    Label profile_cast_success, failure, done;\n-    Label *success_target = should_profile ? &profile_cast_success : &done;\n-    __ cmpdi(CCR0, value, 0);\n+    Label done;\n+\n@@ -2529,1 +2501,0 @@\n-      __ bne(CCR0, not_null);\n@@ -2534,0 +2505,2 @@\n+      __ cmpdi(CCR0, value, 0);\n+      __ bne(CCR0, not_null);\n@@ -2539,0 +2512,10 @@\n+\n+      Label update_done;\n+      Register recv = klass_RInfo;\n+      __ load_klass(recv, value);\n+      type_profile_helper(mdo, mdo_offset_bias, md, data, recv, Rtmp1, &update_done);\n+      const int slot_offset = md->byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias;\n+      __ ld(Rtmp1, slot_offset, mdo);\n+      __ addi(Rtmp1, Rtmp1, DataLayout::counter_increment);\n+      __ std(Rtmp1, slot_offset, mdo);\n+      __ bind(update_done);\n@@ -2540,0 +2523,1 @@\n+      __ cmpdi(CCR0, value, 0);\n@@ -2550,0 +2534,2 @@\n+    Label failure;\n+\n@@ -2553,1 +2539,1 @@\n-    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, &failure, nullptr);\n+    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, &done, &failure, nullptr);\n@@ -2561,15 +2547,1 @@\n-    if (!should_profile) {\n-      __ beq(CCR0, done);\n-      __ bind(failure);\n-    } else {\n-      __ bne(CCR0, failure);\n-      \/\/ Fall through to the success case.\n-\n-      Register mdo  = klass_RInfo, recv = k_RInfo, tmp1 = Rtmp1;\n-      assert_different_registers(value, mdo, recv, tmp1);\n-      __ bind(profile_cast_success);\n-      metadata2reg(md->constant_encoding(), mdo);\n-      __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);\n-      __ load_klass(recv, value);\n-      type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &done);\n-      __ b(done);\n+    __ beq(CCR0, done);\n@@ -2577,9 +2549,1 @@\n-      \/\/ Cast failure case.\n-      __ bind(failure);\n-      metadata2reg(md->constant_encoding(), mdo);\n-      __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);\n-      Address data_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);\n-      __ ld(tmp1, md->byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);\n-      __ addi(tmp1, tmp1, -DataLayout::counter_increment);\n-      __ std(tmp1, md->byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);\n-    }\n+    __ bind(failure);\n@@ -2587,0 +2551,1 @@\n+    __ align(32, 12);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":43,"deletions":78,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -586,1 +586,0 @@\n-  profile_typecheck_failed(Rtmp1, Rtmp2);\n@@ -1537,1 +1536,1 @@\n-  record_klass_in_profile(Rreceiver, Rscratch1, Rscratch2, true);\n+  record_klass_in_profile(Rreceiver, Rscratch1, Rscratch2);\n@@ -1557,1 +1556,1 @@\n-      record_klass_in_profile(Rklass, Rscratch1, Rscratch2, false);\n+      record_klass_in_profile(Rklass, Rscratch1, Rscratch2);\n@@ -1567,18 +1566,0 @@\n-void InterpreterMacroAssembler::profile_typecheck_failed(Register Rscratch1, Register Rscratch2) {\n-  if (ProfileInterpreter && TypeProfileCasts) {\n-    Label profile_continue;\n-\n-    \/\/ If no method data exists, go to profile_continue.\n-    test_method_data_pointer(profile_continue);\n-\n-    int count_offset = in_bytes(CounterData::count_offset());\n-    \/\/ Back up the address, since we have already bumped the mdp.\n-    count_offset -= in_bytes(VirtualCallData::virtual_call_data_size());\n-\n-    \/\/ *Decrement* the counter. We expect to see zero or small negatives.\n-    increment_mdp_data_at(count_offset, Rscratch1, Rscratch2, true);\n-\n-    bind (profile_continue);\n-  }\n-}\n-\n@@ -1690,2 +1671,1 @@\n-                                                        Register Rscratch1, Register Rscratch2,\n-                                                        bool is_virtual_call) {\n+                                                        Register Rscratch1, Register Rscratch2) {\n@@ -1696,1 +1676,1 @@\n-  record_klass_in_profile_helper(Rreceiver, Rscratch1, Rscratch2, 0, done, is_virtual_call);\n+  record_klass_in_profile_helper(Rreceiver, Rscratch1, Rscratch2, 0, done);\n@@ -1702,1 +1682,1 @@\n-                                        int start_row, Label& done, bool is_virtual_call) {\n+                                        int start_row, Label& done) {\n@@ -1704,3 +1684,1 @@\n-    if (is_virtual_call) {\n-      increment_mdp_data_at(in_bytes(CounterData::count_offset()), scratch1, scratch2);\n-    }\n+    increment_mdp_data_at(in_bytes(CounterData::count_offset()), scratch1, scratch2);\n@@ -1738,13 +1716,8 @@\n-        if (is_virtual_call) {\n-          \/\/ Scratch1 contains test_out from test_mdp_data_at.\n-          cmpdi(CCR0, scratch1, 0);\n-          beq(CCR0, found_null);\n-          \/\/ Receiver did not match any saved receiver and there is no empty row for it.\n-          \/\/ Increment total counter to indicate polymorphic case.\n-          increment_mdp_data_at(in_bytes(CounterData::count_offset()), scratch1, scratch2);\n-          b(done);\n-          bind(found_null);\n-        } else {\n-          cmpdi(CCR0, scratch1, 0);\n-          bne(CCR0, done);\n-        }\n+        \/\/ Scratch1 contains test_out from test_mdp_data_at.\n+        cmpdi(CCR0, scratch1, 0);\n+        beq(CCR0, found_null);\n+        \/\/ Receiver did not match any saved receiver and there is no empty row for it.\n+        \/\/ Increment total counter to indicate polymorphic case.\n+        increment_mdp_data_at(in_bytes(CounterData::count_offset()), scratch1, scratch2);\n+        b(done);\n+        bind(found_null);\n@@ -1758,1 +1731,1 @@\n-      record_klass_in_profile_helper(receiver, scratch1, scratch2, start_row + 1, done, is_virtual_call);\n+      record_klass_in_profile_helper(receiver, scratch1, scratch2, start_row + 1, done);\n@@ -2247,1 +2220,3 @@\n-  std(R26_monitor, _ijava_state_neg(monitors), scratch);\n+  subf(R0, scratch, R26_monitor);\n+  sradi(R0, R0, Interpreter::logStackElementSize);\n+  std(R0, _ijava_state_neg(monitors), scratch);\n@@ -2278,0 +2253,3 @@\n+    \/\/ Derelativize monitors\n+    sldi(R26_monitor, R26_monitor, Interpreter::logStackElementSize);\n+    add(R26_monitor, R26_monitor, scratch);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":21,"deletions":43,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -987,1 +987,1 @@\n-\/\/   monitor - Address of the BasicObjectLock to be used for locking,\n+\/\/   monitor (Z_R10) - Address of the BasicObjectLock to be used for locking,\n@@ -989,1 +989,2 @@\n-\/\/   object  - Address of the object to be locked.\n+\/\/   object  (Z_R11, Z_R2) - Address of the object to be locked.\n+\/\/  templateTable (monitorenter) is using Z_R2 for object\n@@ -997,1 +998,1 @@\n-  \/\/ template code:\n+  \/\/ template code: (for LM_LEGACY)\n@@ -1011,1 +1012,3 @@\n-  const Register displaced_header = Z_ARG5;\n+  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n+\n+  const Register header           = Z_ARG5;\n@@ -1014,0 +1017,1 @@\n+  const Register tmp              = Z_R1_scratch;\n@@ -1015,2 +1019,1 @@\n-  NearLabel done;\n-  NearLabel slow_case;\n+  NearLabel done, slow_case;\n@@ -1018,1 +1021,1 @@\n-  \/\/ markWord displaced_header = obj->mark().set_unlocked();\n+  \/\/ markWord header = obj->mark().set_unlocked();\n@@ -1020,2 +1023,2 @@\n-  \/\/ Load markWord from object into displaced_header.\n-  z_lg(displaced_header, oopDesc::mark_offset_in_bytes(), object);\n+  \/\/ Load markWord from object into header.\n+  z_lg(header, hdr_offset, object);\n@@ -1024,2 +1027,2 @@\n-    load_klass(Z_R1_scratch, object);\n-    testbit(Address(Z_R1_scratch, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    load_klass(tmp, object);\n+    testbit(Address(tmp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n@@ -1029,2 +1032,3 @@\n-  \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-  z_oill(displaced_header, markWord::unlocked_value);\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    lightweight_lock(object, \/* mark word *\/ header, tmp, slow_case);\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -1032,1 +1036,3 @@\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n+    \/\/ Set header to be (markWord of object | UNLOCK_VALUE).\n+    \/\/ This will not change anything if it was unlocked before.\n+    z_oill(header, markWord::unlocked_value);\n@@ -1034,3 +1040,3 @@\n-  \/\/ Initialize the box (Must happen before we update the object mark!).\n-  z_stg(displaced_header, in_bytes(BasicObjectLock::lock_offset()) +\n-                          BasicLock::displaced_header_offset_in_bytes(), monitor);\n+    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n+    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n+    const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n@@ -1038,1 +1044,2 @@\n-  \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n+    \/\/ Initialize the box (Must happen before we update the object mark!).\n+    z_stg(header, mark_offset, monitor);\n@@ -1040,2 +1047,1 @@\n-  \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-  add2reg(object_mark_addr, oopDesc::mark_offset_in_bytes(), object);\n+    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n@@ -1043,2 +1049,2 @@\n-  z_csg(displaced_header, monitor, 0, object_mark_addr);\n-  assert(current_header==displaced_header, \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n+    \/\/ not necessary, use offset in instruction directly.\n+    \/\/ add2reg(object_mark_addr, hdr_offset, object);\n@@ -1046,1 +1052,4 @@\n-  z_bre(done);\n+    \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n+    z_csg(header, monitor, hdr_offset, object);\n+    assert(current_header == header,\n+           \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n@@ -1048,3 +1057,1 @@\n-  \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-  \/\/   \/\/ Simple recursive case.\n-  \/\/   monitor->lock()->set_displaced_header(nullptr);\n+    z_bre(done);\n@@ -1052,1 +1059,3 @@\n-  \/\/ We did not see an unlocked object so try the fast recursive case.\n+    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n+    \/\/   \/\/ Simple recursive case.\n+    \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -1054,3 +1063,1 @@\n-  \/\/ Check if owner is self by comparing the value in the markWord of object\n-  \/\/ (current_header) with the stack pointer.\n-  z_sgr(current_header, Z_SP);\n+    \/\/ We did not see an unlocked object so try the fast recursive case.\n@@ -1058,1 +1065,3 @@\n-  assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n+    \/\/ Check if owner is self by comparing the value in the markWord of object\n+    \/\/ (current_header) with the stack pointer.\n+    z_sgr(current_header, Z_SP);\n@@ -1060,4 +1069,1 @@\n-  \/\/ The prior sequence \"LGR, NGR, LTGR\" can be done better\n-  \/\/ (Z_R1 is temp and not used after here).\n-  load_const_optimized(Z_R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-  z_ngr(Z_R0, current_header); \/\/ AND sets CC (result eq\/ne 0)\n+    assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n@@ -1065,7 +1071,4 @@\n-  \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-  \/\/ header indicating it is a recursive lock and be done.\n-  z_brne(slow_case);\n-  z_release();  \/\/ Membar unnecessary on zarch AND because the above csg does a sync before and after.\n-  z_stg(Z_R0\/*==0!*\/, in_bytes(BasicObjectLock::lock_offset()) +\n-                      BasicLock::displaced_header_offset_in_bytes(), monitor);\n-  z_bru(done);\n+    \/\/ The prior sequence \"LGR, NGR, LTGR\" can be done better\n+    \/\/ (Z_R1 is temp and not used after here).\n+    load_const_optimized(Z_R0, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n+    z_ngr(Z_R0, current_header); \/\/ AND sets CC (result eq\/ne 0)\n@@ -1073,0 +1076,7 @@\n+    \/\/ If condition is true we are done and hence we can store 0 in the displaced\n+    \/\/ header indicating it is a recursive lock and be done.\n+    z_brne(slow_case);\n+    z_release();  \/\/ Member unnecessary on zarch AND because the above csg does a sync before and after.\n+    z_stg(Z_R0\/*==0!*\/, mark_offset, monitor);\n+  }\n+  z_bru(done);\n@@ -1080,2 +1090,10 @@\n-  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ for lightweight locking we need to use monitorenter_obj, see interpreterRuntime.cpp\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n+            object);\n+  } else {\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            monitor);\n+  }\n@@ -1102,1 +1120,1 @@\n-  \/\/ template code:\n+  \/\/ template code: (for LM_LEGACY):\n@@ -1115,2 +1133,4 @@\n-  const Register displaced_header = Z_ARG4;\n-  const Register current_header   = Z_R1;\n+  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n+\n+  const Register header         = Z_ARG4;\n+  const Register current_header = Z_R1_scratch;\n@@ -1118,1 +1138,1 @@\n-  Label done;\n+  Label done, slow_case;\n@@ -1128,1 +1148,1 @@\n-  assert_different_registers(monitor, object, displaced_header, current_header);\n+  assert_different_registers(monitor, object, header, current_header);\n@@ -1134,1 +1154,3 @@\n-  clear_mem(obj_entry, sizeof(oop));\n+  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n+  const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n+  const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n@@ -1136,5 +1158,6 @@\n-  \/\/ Test first if we are in the fast recursive case.\n-  MacroAssembler::load_and_test_long(displaced_header,\n-                                     Address(monitor, in_bytes(BasicObjectLock::lock_offset()) +\n-                                                      BasicLock::displaced_header_offset_in_bytes()));\n-  z_bre(done); \/\/ displaced_header == 0 -> goto done\n+  clear_mem(obj_entry, sizeof(oop));\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Test first if we are in the fast recursive case.\n+    MacroAssembler::load_and_test_long(header, Address(monitor, mark_offset));\n+    z_bre(done); \/\/ header == 0 -> goto done\n+  }\n@@ -1147,0 +1170,9 @@\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n+    \/\/ must handle it.\n+\n+    Register tmp = current_header;\n+\n+    \/\/ First check for lock-stack underflow.\n+    z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+    compareU32_and_branch(tmp, (unsigned)LockStack::start_offset(), Assembler::bcondNotHigh, slow_case);\n@@ -1148,2 +1180,4 @@\n-  \/\/ The markword is expected to be at offset 0.\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"unlock_object: review code below\");\n+    \/\/ Then check if the top of the lock-stack matches the unlocked object.\n+    z_aghi(tmp, -oopSize);\n+    z_lg(tmp, Address(Z_thread, tmp));\n+    compare64_and_branch(tmp, object, Assembler::bcondNotEqual, slow_case);\n@@ -1151,6 +1185,20 @@\n-  \/\/ We have the displaced header in displaced_header. If the lock is still\n-  \/\/ lightweight, it will contain the monitor address and we'll store the\n-  \/\/ displaced header back into the object's mark word.\n-  z_lgr(current_header, monitor);\n-  z_csg(current_header, displaced_header, 0, object);\n-  z_bre(done);\n+    z_lg(header, Address(object, hdr_offset));\n+    z_lgr(tmp, header);\n+    z_nill(tmp, markWord::monitor_value);\n+    z_brne(slow_case);\n+\n+    lightweight_unlock(object, header, tmp, slow_case);\n+\n+    z_bru(done);\n+  } else {\n+    \/\/ The markword is expected to be at offset 0.\n+    \/\/ This is not required on s390, at least not here.\n+    assert(hdr_offset == 0, \"unlock_object: review code below\");\n+\n+    \/\/ We have the displaced header in header. If the lock is still\n+    \/\/ lightweight, it will contain the monitor address and we'll store the\n+    \/\/ displaced header back into the object's mark word.\n+    z_lgr(current_header, monitor);\n+    z_csg(current_header, header, hdr_offset, object);\n+    z_bre(done);\n+  }\n@@ -1164,0 +1212,1 @@\n+  bind(slow_case);\n@@ -2224,1 +2273,1 @@\n-    unimplemented(\"verfiyFPU\");\n+    unimplemented(\"verifyFPU\");\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":113,"deletions":64,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -345,1 +345,1 @@\n-  BasicObjectLock* result = (BasicObjectLock*) at(interpreter_frame_monitor_block_top_offset);\n+  BasicObjectLock* result = (BasicObjectLock*) at_relative(interpreter_frame_monitor_block_top_offset);\n@@ -353,1 +353,4 @@\n-  *((BasicObjectLock**)addr_at(interpreter_frame_monitor_block_top_offset)) = value;\n+  assert(is_interpreted_frame(), \"interpreted frame expected\");\n+  \/\/ set relativized monitor_block_top\n+  ptr_at_put(interpreter_frame_monitor_block_top_offset, (intptr_t*)value - fp());\n+  assert(at_absolute(interpreter_frame_monitor_block_top_offset) <= interpreter_frame_monitor_block_top_offset, \"\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1093,2 +1093,4 @@\n-    movptr(rmon, monitor_block_top); \/\/ points to current entry, starting\n-                                  \/\/ with top-most entry\n+    movptr(rmon, monitor_block_top); \/\/ derelativize pointer\n+    lea(rmon, Address(rbp, rmon, Address::times_ptr));\n+    \/\/ c_rarg1 points to current entry, starting with top-most entry\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -180,1 +180,2 @@\n-    movptr(rsp, Address(rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize));\n+    movptr(rcx, Address(rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize));\n+    lea(rsp, Address(rbp, rcx, Address::times_ptr));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -90,3 +90,4 @@\n-    __ lea(rax, Address(rbp,\n-                        frame::interpreter_frame_monitor_block_top_offset *\n-                        wordSize));\n+    __ movptr(rax, Address(rbp,\n+                           frame::interpreter_frame_monitor_block_top_offset *\n+                           wordSize));\n+    __ lea(rax, Address(rbp, rax, Address::times_ptr));\n@@ -617,1 +618,1 @@\n-  __ movptr(monitor_block_top, rsp);  \/\/ set new monitor block top\n+  __ subptr(monitor_block_top, entry_size \/ wordSize); \/\/ set new monitor block top\n@@ -673,2 +674,2 @@\n-  __ push(0); \/\/ reserve word for pointer to expression stack bottom\n-  __ movptr(Address(rsp, 0), rsp); \/\/ set expression stack bottom\n+  \/\/ initialize relativized pointer to expression stack bottom\n+  __ push(frame::interpreter_frame_initial_sp_offset);\n@@ -913,0 +914,1 @@\n+    __ lea(rax, Address(rbp, rax, Address::times_ptr));\n@@ -1467,0 +1469,1 @@\n+    __ lea(rax, Address(rbp, rax, Address::times_ptr));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4670,2 +4670,4 @@\n-    __ movptr(rtop, monitor_block_top); \/\/ points to current entry,\n-                                        \/\/ starting with top-most entry\n+    __ movptr(rtop, monitor_block_top); \/\/ derelativize pointer\n+    __ lea(rtop, Address(rbp, rtop, Address::times_ptr));\n+    \/\/ rtop points to current entry, starting with top-most entry\n+\n@@ -4703,0 +4705,1 @@\n+    __ lea(rmon, Address(rbp, rmon, Address::times_ptr));\n@@ -4706,1 +4709,1 @@\n-    __ movptr(monitor_block_bot, rmon); \/\/ set new monitor block bottom\n+    __ subptr(monitor_block_bot, entry_size \/ wordSize); \/\/ set new monitor block bottom\n@@ -4779,2 +4782,4 @@\n-    __ movptr(rtop, monitor_block_top); \/\/ points to current entry,\n-                                        \/\/ starting with top-most entry\n+    __ movptr(rtop, monitor_block_top); \/\/ derelativize pointer\n+    __ lea(rtop, Address(rbp, rtop, Address::times_ptr));\n+    \/\/ rtop points to current entry, starting with top-most entry\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -85,2 +85,1 @@\n-  void print_action_queue(outputStream* st) {\n-    SeenThread* seen = this;\n+  static void print_action_queue(SeenThread* seen, outputStream* st) {\n@@ -340,1 +339,1 @@\n-  loadInstanceThreadQ()->print_action_queue(st);\n+  SeenThread::print_action_queue(loadInstanceThreadQ(), st);\n@@ -343,1 +342,1 @@\n-  superThreadQ()->print_action_queue(st);\n+  SeenThread::print_action_queue(superThreadQ(), st);\n@@ -346,1 +345,1 @@\n-  defineThreadQ()->print_action_queue(st);\n+  SeenThread::print_action_queue(defineThreadQ(), st);\n@@ -349,1 +348,1 @@\n-  inlineTypeFieldQ()->print_action_queue(st);\n+  SeenThread::print_action_queue(inlineTypeFieldQ(), st);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1604,0 +1604,2 @@\n+    \/\/ Remove this InstanceKlass from the LoaderConstraintTable if added.\n+    LoaderConstraintTable::remove_failed_loaded_klass(k, class_loader_data(class_loader));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,2 +177,4 @@\n-  FREE_C_HEAP_ARRAY(unsigned char, _oop_maps);\n-  _oop_maps = nullptr;\n+  if (_oop_maps != nullptr) {\n+    delete _oop_maps;\n+    _oop_maps = nullptr;\n+  }\n@@ -193,1 +195,0 @@\n-\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -122,5 +122,0 @@\n-\n- ~CodeBlob() {\n-    _asm_remarks.clear();\n-    _dbg_strings.clear();\n-  }\n@@ -135,0 +130,3 @@\n+\n+  void operator delete(void* p) { }\n+\n@@ -139,0 +137,4 @@\n+  virtual ~CodeBlob() {\n+    assert(_oop_maps == nullptr, \"Not flushed\");\n+  }\n+\n@@ -410,4 +412,0 @@\n-  \/\/ This ordinary operator delete is needed even though not used, so the\n-  \/\/ below two-argument operator delete will be treated as a placement\n-  \/\/ delete rather than an ordinary sized delete; see C++14 3.7.4.2\/p2.\n-  void operator delete(void* p);\n@@ -526,4 +524,0 @@\n-  \/\/ This ordinary operator delete is needed even though not used, so the\n-  \/\/ below two-argument operator delete will be treated as a placement\n-  \/\/ delete rather than an ordinary sized delete; see C++14 3.7.4.2\/p2.\n-  void operator delete(void* p);\n@@ -566,4 +560,0 @@\n-  \/\/ This ordinary operator delete is needed even though not used, so the\n-  \/\/ below two-argument operator delete will be treated as a placement\n-  \/\/ delete rather than an ordinary sized delete; see C++14 3.7.4.2\/p2.\n-  void operator delete(void* p);\n@@ -784,4 +774,0 @@\n-  \/\/ This ordinary operator delete is needed even though not used, so the\n-  \/\/ below two-argument operator delete will be treated as a placement\n-  \/\/ delete rather than an ordinary sized delete; see C++14 3.7.4.2\/p2.\n-  void operator delete(void* p);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":7,"deletions":21,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -233,2 +233,4 @@\n-        tty->print_cr(\"Decoding VtableStub (%s) %s[%d]@\" INTX_FORMAT, caller_is_c1 ? \"c1\" : \"full opt\",\n-                      is_vtable_stub? \"vtbl\": \"itbl\", vtable_index, p2i(VtableStub::receiver_location()));\n+        tty->print_cr(\"Decoding VtableStub (%s) %s[%d]@\" PTR_FORMAT \" [\" PTR_FORMAT \", \" PTR_FORMAT \"] (\" SIZE_FORMAT \" bytes)\",\n+                      caller_is_c1 ? \"c1\" : \"full opt\",\n+                      is_vtable_stub? \"vtbl\": \"itbl\", vtable_index, p2i(VtableStub::receiver_location()),\n+                      p2i(s->code_begin()), p2i(s->code_end()), pointer_delta(s->code_end(), s->code_begin(), 1));\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1773,0 +1773,9 @@\n+void CompileBroker::free_buffer_blob_if_allocated(CompilerThread* thread) {\n+  BufferBlob* blob = thread->get_buffer_blob();\n+  if (blob != nullptr) {\n+    blob->flush();\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    CodeCache::free(blob);\n+  }\n+}\n+\n@@ -1779,5 +1788,1 @@\n-  \/\/ Free buffer blob, if allocated\n-  if (thread->get_buffer_blob() != nullptr) {\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-    CodeCache::free(thread->get_buffer_blob());\n-  }\n+  free_buffer_blob_if_allocated(thread);\n@@ -1922,5 +1927,1 @@\n-          \/\/ Free buffer blob, if allocated\n-          if (thread->get_buffer_blob() != nullptr) {\n-            MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-            CodeCache::free(thread->get_buffer_blob());\n-          }\n+          free_buffer_blob_if_allocated(thread);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -875,0 +875,3 @@\n+void ImmutableOopMapSet::operator delete(void* p) {\n+  FREE_C_HEAP_ARRAY(unsigned char, p);\n+}\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -682,0 +682,7 @@\n+  if (is_array) {\n+    \/\/ Ensure the array payload size is rounded up to the next BytesPerLong\n+    \/\/ multiple when converting to double-words. This is necessary because array\n+    \/\/ size does not include object alignment padding, so it might not be a\n+    \/\/ multiple of BytesPerLong for sub-long element types.\n+    payload_size = kit->gvn().transform(new AddXNode(payload_size, kit->MakeConX(BytesPerLong - 1)));\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-                  jint frame_count, jint start_index, jobjectArray frames);\n+                  jint buffer_size, jint start_index, jobjectArray frames);\n@@ -265,1 +265,1 @@\n-                  jint frame_count, jint start_index,\n+                  jint last_batch_count, jint buffer_size, jint start_index,\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -410,0 +410,2 @@\n+  assert(from->has_valid_mask(),\n+    \"Cannot copy entry with an invalid mask\");\n@@ -615,1 +617,3 @@\n-  entry->resource_copy(tmp);\n+  if (tmp->has_valid_mask()) {\n+    entry->resource_copy(tmp);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -773,3 +774,5 @@\n-  for (int i = 0; i < cp->resolved_indy_entries_length(); i++) {\n-    if (cp->resolved_indy_entry_at(i)->constant_pool_index() == index) {\n-      indy_index = i;\n+  if (is_indy) {\n+    for (int i = 0; i < cp->resolved_indy_entries_length(); i++) {\n+      if (cp->resolved_indy_entry_at(i)->constant_pool_index() == index) {\n+        indy_index = i;\n+      }\n@@ -841,0 +844,5 @@\n+C2V_VMENTRY_0(jint, bootstrapArgumentIndexAt, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint cpi, jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n+  return cp->bootstrap_argument_index_at(cpi, index);\n+C2V_END\n+\n@@ -2515,1 +2523,1 @@\n-}\n+C2V_END\n@@ -2780,1 +2788,1 @@\n-}\n+C2V_END\n@@ -2793,1 +2801,1 @@\n-}\n+C2V_END\n@@ -2799,1 +2807,1 @@\n-}\n+C2V_END\n@@ -2815,1 +2823,1 @@\n-}\n+C2V_END\n@@ -2831,1 +2839,1 @@\n-}\n+C2V_END\n@@ -2853,1 +2861,1 @@\n-}\n+C2V_END\n@@ -2967,1 +2975,1 @@\n-}\n+C2V_END\n@@ -2978,1 +2986,1 @@\n-}\n+C2V_END\n@@ -2982,1 +2990,1 @@\n-}\n+C2V_END\n@@ -2990,1 +2998,1 @@\n-}\n+C2V_END\n@@ -3002,1 +3010,1 @@\n-}\n+C2V_END\n@@ -3006,1 +3014,1 @@\n-}\n+C2V_END\n@@ -3016,1 +3024,1 @@\n-}\n+C2V_END\n@@ -3023,1 +3031,1 @@\n-}\n+C2V_END\n@@ -3033,1 +3041,1 @@\n-}\n+C2V_END\n@@ -3043,1 +3051,1 @@\n-}\n+C2V_END\n@@ -3052,1 +3060,1 @@\n-}\n+C2V_END\n@@ -3064,1 +3072,1 @@\n-}\n+C2V_END\n@@ -3076,1 +3084,43 @@\n-}\n+C2V_END\n+\n+C2V_VMENTRY(void, getOopMapAt, (JNIEnv* env, jobject, ARGUMENT_PAIR(method),\n+                 jint bci, jlongArray oop_map_handle))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n+  if (bci < 0 || bci >= method->code_size()) {\n+    JVMCI_THROW_MSG(IllegalArgumentException,\n+                err_msg(\"bci %d is out of bounds [0 .. %d)\", bci, method->code_size()));\n+  }\n+  InterpreterOopMap mask;\n+  OopMapCache::compute_one_oop_map(method, bci, &mask);\n+  if (!mask.has_valid_mask()) {\n+    JVMCI_THROW_MSG(IllegalArgumentException, err_msg(\"bci %d is not valid\", bci));\n+  }\n+  if (mask.number_of_entries() == 0) {\n+    return;\n+  }\n+\n+  int nslots = method->max_locals() + method->max_stack();\n+  int nwords = ((nslots - 1) \/ 64) + 1;\n+  JVMCIPrimitiveArray oop_map = JVMCIENV->wrap(oop_map_handle);\n+  int oop_map_len = JVMCIENV->get_length(oop_map);\n+  if (nwords > oop_map_len) {\n+    JVMCI_THROW_MSG(IllegalArgumentException,\n+                err_msg(\"oop map too short: %d > %d\", nwords, oop_map_len));\n+  }\n+\n+  jlong* oop_map_buf = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, jlong, nwords);\n+  if (oop_map_buf == nullptr) {\n+    JVMCI_THROW_MSG(InternalError, err_msg(\"could not allocate %d longs\", nwords));\n+  }\n+  for (int i = 0; i < nwords; i++) {\n+    oop_map_buf[i] = 0L;\n+  }\n+\n+  BitMapView oop_map_view = BitMapView((BitMap::bm_word_t*) oop_map_buf, nwords * BitsPerLong);\n+  for (int i = 0; i < nslots; i++) {\n+    if (mask.is_oop(i)) {\n+      oop_map_view.set_bit(i);\n+    }\n+  }\n+  JVMCIENV->copy_longs_from((jlong*)oop_map_buf, oop_map, 0, nwords);\n+C2V_END\n@@ -3137,0 +3187,1 @@\n+  {CC \"bootstrapArgumentIndexAt\",                     CC \"(\" HS_CONSTANT_POOL2 \"II)I\",                                                      FN_PTR(bootstrapArgumentIndexAt)},\n@@ -3235,0 +3286,1 @@\n+  {CC \"getOopMapAt\",                                  CC \"(\" HS_METHOD2 \"I[J)V\",                                                            FN_PTR(getOopMapAt)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":75,"deletions":23,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -1344,0 +1344,10 @@\n+  \/\/ Some classes are pre-resolved (like Throwable) which may lead to\n+  \/\/ consider it as a different entry. We then revert them back temporarily\n+  \/\/ to ensure proper comparison.\n+  if (t1 == JVM_CONSTANT_Class) {\n+    t1 = JVM_CONSTANT_UnresolvedClass;\n+  }\n+  if (t2 == JVM_CONSTANT_Class) {\n+    t2 = JVM_CONSTANT_UnresolvedClass;\n+  }\n+\n@@ -1355,9 +1365,0 @@\n-  case JVM_CONSTANT_Class:\n-  {\n-    Klass* k1 = resolved_klass_at(index1);\n-    Klass* k2 = cp2->resolved_klass_at(index2);\n-    if (k1 == k2) {\n-      return true;\n-    }\n-  } break;\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -828,0 +828,2 @@\n+  bool debug_logging_enabled = log_is_enabled(Debug, class, init);\n+\n@@ -830,0 +832,5 @@\n+    if (debug_logging_enabled) {\n+      ResourceMark rm(current);\n+      log_debug(class, init)(\"Thread \\\"%s\\\" waiting for linking of %s by thread \\\"%s\\\"\",\n+                             current->name(), external_name(), init_thread_name());\n+    }\n@@ -835,0 +842,5 @@\n+    if (debug_logging_enabled) {\n+      ResourceMark rm(current);\n+      log_debug(class, init)(\"Thread \\\"%s\\\" recursively linking %s\",\n+                             current->name(), external_name());\n+    }\n@@ -840,0 +852,5 @@\n+    if (debug_logging_enabled) {\n+      ResourceMark rm(current);\n+      log_debug(class, init)(\"Thread \\\"%s\\\" linking %s\",\n+                             current->name(), external_name());\n+    }\n@@ -842,0 +859,6 @@\n+  } else {\n+    if (debug_logging_enabled) {\n+      ResourceMark rm(current);\n+      log_debug(class, init)(\"Thread \\\"%s\\\" found %s already linked\",\n+                             current->name(), external_name());\n+      }\n@@ -1223,0 +1246,2 @@\n+  bool debug_logging_enabled = log_is_enabled(Debug, class, init);\n+\n@@ -1226,1 +1251,1 @@\n-    MonitorLocker ml(THREAD, _init_monitor);\n+    MonitorLocker ml(jt, _init_monitor);\n@@ -1230,0 +1255,6 @@\n+      if (debug_logging_enabled) {\n+        ResourceMark rm(jt);\n+        log_debug(class, init)(\"Thread \\\"%s\\\" waiting for initialization of %s by thread \\\"%s\\\"\",\n+                               jt->name(), external_name(), init_thread_name());\n+      }\n+\n@@ -1238,0 +1269,5 @@\n+      if (debug_logging_enabled) {\n+        ResourceMark rm(jt);\n+        log_debug(class, init)(\"Thread \\\"%s\\\" recursively initializing %s\",\n+                               jt->name(), external_name());\n+      }\n@@ -1244,0 +1280,5 @@\n+      if (debug_logging_enabled) {\n+        ResourceMark rm(jt);\n+        log_debug(class, init)(\"Thread \\\"%s\\\" found %s already initialized\",\n+                               jt->name(), external_name());\n+      }\n@@ -1250,0 +1291,5 @@\n+      if (debug_logging_enabled) {\n+        ResourceMark rm(jt);\n+        log_debug(class, init)(\"Thread \\\"%s\\\" found %s is in error state\",\n+                               jt->name(), external_name());\n+      }\n@@ -1256,0 +1302,5 @@\n+      if (debug_logging_enabled) {\n+        ResourceMark rm(jt);\n+        log_debug(class, init)(\"Thread \\\"%s\\\" is initializing %s\",\n+                               jt->name(), external_name());\n+      }\n@@ -1789,1 +1840,3 @@\n-    ls.print_cr(\"%s (\" PTR_FORMAT \")\", h_method() == nullptr ? \"(no method)\" : \"\", p2i(this));\n+    ls.print_cr(\"%s (\" PTR_FORMAT \") by thread \\\"%s\\\"\",\n+                h_method() == nullptr ? \"(no method)\" : \"\", p2i(this),\n+                THREAD->name());\n@@ -4706,1 +4759,0 @@\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":55,"deletions":3,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -560,0 +560,8 @@\n+\n+  JavaThread* init_thread()  { return Atomic::load(&_init_thread); }\n+  \/\/ We can safely access the name as long as we hold the _init_monitor.\n+  const char* init_thread_name() {\n+    assert(_init_monitor->owned_by_self(), \"Must hold _init_monitor here\");\n+    return init_thread()->name_raw();\n+  }\n+\n@@ -569,1 +577,1 @@\n-  bool is_init_thread(JavaThread *thread)  { return thread == Atomic::load(&_init_thread); }\n+  bool is_init_thread(JavaThread *thread)  { return thread == init_thread(); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-\n@@ -468,5 +467,3 @@\n-  st->print(\"'\");\n-  for (int i = 0; i < utf8_length(); i++) {\n-    st->print(\"%c\", char_at(i));\n-  }\n-  st->print(\"'\");\n+  st->print_raw(\"'\", 1);\n+  st->print_raw((const char*)base(), utf8_length());\n+  st->print_raw(\"'\", 1);\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -143,4 +143,6 @@\n-      \/\/ length input to ArrayCopyNode is constant, length of input\n-      \/\/ array must be too.\n-\n-      assert((get_length_if_constant(phase) == -1) != ary_src->size()->is_con() ||\n+      \/\/ length of the input array is constant, ArrayCopyNode::Length\n+      \/\/ must be too. Note that the opposite does not need to hold,\n+      \/\/ because different input array lengths (e.g. int arrays with\n+      \/\/ 3 or 4 elements) might lead to the same length input\n+      \/\/ (e.g. 2 double-words).\n+      assert(!ary_src->size()->is_con() || (get_length_if_constant(phase) >= 0) ||\n@@ -149,1 +151,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+  if (_dependency == UnconditionalDependency) {\n+    return this;\n+  }\n@@ -47,4 +50,1 @@\n-  if (_dependency != RegularDependency) {\n-    return this;\n-  }\n-  return phase->type(in(1))->higher_equal_speculative(_type) ? in(1) : this;\n+  return higher_equal_types(phase, in(1)) ? in(1) : this;\n@@ -124,0 +124,4 @@\n+uint ConstraintCastNode::hash() const {\n+  return TypeNode::hash() + (int)_dependency + (_extra_types != nullptr ? _extra_types->hash() : 0);\n+}\n+\n@@ -125,1 +129,11 @@\n-  return TypeNode::cmp(n) && ((ConstraintCastNode&)n)._dependency == _dependency;\n+  if (!TypeNode::cmp(n)) {\n+    return false;\n+  }\n+  ConstraintCastNode& cast = (ConstraintCastNode&) n;\n+  if (cast._dependency != _dependency) {\n+    return false;\n+  }\n+  if (_extra_types == nullptr || cast._extra_types == nullptr) {\n+    return _extra_types == cast._extra_types;\n+  }\n+  return _extra_types->eq(cast._extra_types);\n@@ -132,1 +146,2 @@\n-Node* ConstraintCastNode::make_cast(int opcode, Node* c, Node *n, const Type *t, DependencyType dependency) {\n+Node* ConstraintCastNode::make_cast(int opcode, Node* c, Node* n, const Type* t, DependencyType dependency,\n+                                    const TypeTuple* extra_types) {\n@@ -135,1 +150,1 @@\n-    Node* cast = new CastIINode(n, t, dependency);\n+    Node* cast = new CastIINode(n, t, dependency, false, extra_types);\n@@ -140,1 +155,1 @@\n-    Node* cast = new CastLLNode(n, t, dependency);\n+    Node* cast = new CastLLNode(n, t, dependency, extra_types);\n@@ -145,1 +160,1 @@\n-    Node* cast = new CastPPNode(n, t, dependency);\n+    Node* cast = new CastPPNode(n, t, dependency, extra_types);\n@@ -150,1 +165,1 @@\n-    Node* cast = new CastFFNode(n, t, dependency);\n+    Node* cast = new CastFFNode(n, t, dependency, extra_types);\n@@ -155,1 +170,1 @@\n-    Node* cast = new CastDDNode(n, t, dependency);\n+    Node* cast = new CastDDNode(n, t, dependency, extra_types);\n@@ -160,1 +175,1 @@\n-    Node* cast = new CastVVNode(n, t, dependency);\n+    Node* cast = new CastVVNode(n, t, dependency, extra_types);\n@@ -164,1 +179,1 @@\n-  case Op_CheckCastPP: return new CheckCastPPNode(c, n, t, dependency);\n+  case Op_CheckCastPP: return new CheckCastPPNode(c, n, t, dependency, extra_types);\n@@ -174,1 +189,1 @@\n-    return make_cast(Op_CastII, c, n, t, dependency);\n+    return make_cast(Op_CastII, c, n, t, dependency, nullptr);\n@@ -177,1 +192,1 @@\n-    return make_cast(Op_CastLL, c, n, t, dependency);\n+    return make_cast(Op_CastLL, c, n, t, dependency, nullptr);\n@@ -210,1 +225,1 @@\n-        u->bottom_type()->higher_equal(type())) {\n+        higher_equal_types(gvn, u)) {\n@@ -226,0 +241,15 @@\n+bool ConstraintCastNode::higher_equal_types(PhaseGVN* phase, const Node* other) const {\n+  const Type* t = phase->type(other);\n+  if (!t->higher_equal_speculative(type())) {\n+    return false;\n+  }\n+  if (_extra_types != nullptr) {\n+    for (uint i = 0; i < _extra_types->cnt(); ++i) {\n+      if (!t->higher_equal_speculative(_extra_types->field_at(i))) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -229,0 +259,4 @@\n+  if (_extra_types != nullptr) {\n+    st->print(\" extra types: \");\n+    _extra_types->dump_on(st);\n+  }\n@@ -583,1 +617,2 @@\n-Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency) {\n+Node* ConstraintCastNode::make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+                                             const TypeTuple* types) {\n@@ -586,1 +621,1 @@\n-    cast = make_cast(Op_CastII, c, in, type, dependency);\n+    cast = make_cast(Op_CastII, c, in, type, dependency, types);\n@@ -588,1 +623,1 @@\n-    cast = make_cast(Op_CastLL, c, in, type, dependency);\n+    cast = make_cast(Op_CastLL, c, in, type, dependency, types);\n@@ -590,1 +625,1 @@\n-    cast = make_cast(Op_CastFF, c, in, type, dependency);\n+    cast = make_cast(Op_CastFF, c, in, type, dependency, types);\n@@ -592,1 +627,1 @@\n-    cast = make_cast(Op_CastDD, c, in, type, dependency);\n+    cast = make_cast(Op_CastDD, c, in, type, dependency, types);\n@@ -594,1 +629,1 @@\n-    cast = make_cast(Op_CastVV, c, in, type, dependency);\n+    cast = make_cast(Op_CastVV, c, in, type, dependency, types);\n@@ -596,1 +631,1 @@\n-    cast = make_cast(Op_CastPP, c, in, type, dependency);\n+    cast = make_cast(Op_CastPP, c, in, type, dependency, types);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":58,"deletions":23,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  virtual uint hash() const;    \/\/ Check the type\n@@ -48,0 +49,7 @@\n+  private:\n+  \/\/ PhiNode::Ideal() transforms a Phi that merges a single uncasted value into a single cast pinned at the region.\n+  \/\/ The types of cast nodes eliminated as a consequence of this transformation are collected and stored here so the\n+  \/\/ type dependencies carried by the cast are known. The cast can then be eliminated if the type of its input is\n+  \/\/ narrower (or equal) than all the types it carries.\n+  const TypeTuple* _extra_types;\n+\n@@ -49,2 +57,3 @@\n-  ConstraintCastNode(Node *n, const Type *t, DependencyType dependency)\n-    : TypeNode(t,2), _dependency(dependency) {\n+  ConstraintCastNode(Node* n, const Type* t, ConstraintCastNode::DependencyType dependency,\n+                     const TypeTuple* extra_types)\n+          : TypeNode(t,2), _dependency(dependency), _extra_types(extra_types) {\n@@ -62,1 +71,1 @@\n-  static Node* make_cast(int opcode, Node* c, Node *n, const Type *t, DependencyType dependency);\n+  static Node* make_cast(int opcode, Node* c, Node* n, const Type* t, DependencyType dependency, const TypeTuple* extra_types);\n@@ -69,1 +78,2 @@\n-  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency);\n+  static Node* make_cast_for_type(Node* c, Node* in, const Type* type, DependencyType dependency,\n+                                  const TypeTuple* types);\n@@ -94,0 +104,10 @@\n+\n+  bool higher_equal_types(PhaseGVN* phase, const Node* other) const;\n+\n+  int extra_types_count() const {\n+    return _extra_types == nullptr ? 0 : _extra_types->cnt();\n+  }\n+\n+  const Type* extra_type_at(int i) const {\n+    return _extra_types->field_at(i);\n+  }\n@@ -106,2 +126,2 @@\n-  CastIINode(Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false)\n-    : ConstraintCastNode(n, t, dependency), _range_check_dependency(range_check_dependency) {\n+  CastIINode(Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n+    : ConstraintCastNode(n, t, dependency, types), _range_check_dependency(range_check_dependency) {\n@@ -111,1 +131,1 @@\n-    : ConstraintCastNode(n, t, dependency), _range_check_dependency(range_check_dependency) {\n+    : ConstraintCastNode(n, t, dependency, nullptr), _range_check_dependency(range_check_dependency) {\n@@ -137,1 +157,1 @@\n-    : ConstraintCastNode(n, t, dependency) {\n+    : ConstraintCastNode(n, t, dependency, nullptr) {\n@@ -141,2 +161,2 @@\n-  CastLLNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n-          : ConstraintCastNode(n, t, dependency){\n+  CastLLNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(n, t, dependency, types) {\n@@ -154,2 +174,2 @@\n-  CastFFNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n-          : ConstraintCastNode(n, t, dependency){\n+  CastFFNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(n, t, dependency, types) {\n@@ -164,2 +184,2 @@\n-  CastDDNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n-          : ConstraintCastNode(n, t, dependency){\n+  CastDDNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(n, t, dependency, types) {\n@@ -174,2 +194,2 @@\n-  CastVVNode(Node* n, const Type* t, DependencyType dependency = RegularDependency)\n-          : ConstraintCastNode(n, t, dependency){\n+  CastVVNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(n, t, dependency, types) {\n@@ -187,2 +207,2 @@\n-  CastPPNode (Node *n, const Type *t, DependencyType dependency = RegularDependency)\n-    : ConstraintCastNode(n, t, dependency) {\n+  CastPPNode (Node *n, const Type *t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+    : ConstraintCastNode(n, t, dependency, types) {\n@@ -198,2 +218,2 @@\n-  CheckCastPPNode(Node *c, Node *n, const Type *t, DependencyType dependency = RegularDependency)\n-    : ConstraintCastNode(n, t, dependency) {\n+  CheckCastPPNode(Node *c, Node *n, const Type *t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+    : ConstraintCastNode(n, t, dependency, types) {\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":40,"deletions":20,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2192,0 +2192,1 @@\n+      const TypeTuple* extra_types = collect_types(phase);\n@@ -2195,1 +2196,2 @@\n-          cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency);\n+          cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency,\n+                                               extra_types);\n@@ -2205,1 +2207,2 @@\n-            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, TypePtr::NOTNULL, ConstraintCastNode::StrongDependency);\n+            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, TypePtr::NOTNULL,\n+                                                 ConstraintCastNode::StrongDependency, extra_types);\n@@ -2217,1 +2220,2 @@\n-            cast = ConstraintCastNode::make_cast(Op_CheckCastPP, r, n, phi_type, ConstraintCastNode::StrongDependency);\n+            cast = ConstraintCastNode::make_cast(Op_CheckCastPP, r, n, phi_type, ConstraintCastNode::StrongDependency,\n+                                                 extra_types);\n@@ -2220,1 +2224,2 @@\n-            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency);\n+            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency,\n+                                                 extra_types);\n@@ -2224,1 +2229,1 @@\n-        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type, ConstraintCastNode::StrongDependency);\n+        cast = ConstraintCastNode::make_cast_for_type(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n@@ -2694,0 +2699,46 @@\n+static int compare_types(const Type* const& e1, const Type* const& e2) {\n+  return (intptr_t)e1 - (intptr_t)e2;\n+}\n+\n+\/\/ Collect types at casts that are going to be eliminated at that Phi and store them in a TypeTuple.\n+\/\/ Sort the types using an arbitrary order so a list of some types always hashes to the same TypeTuple (and TypeTuple\n+\/\/ pointer comparison is enough to tell if 2 list of types are the same or not)\n+const TypeTuple* PhiNode::collect_types(PhaseGVN* phase) const {\n+  const Node* region = in(0);\n+  const Type* phi_type = bottom_type();\n+  ResourceMark rm;\n+  GrowableArray<const Type*> types;\n+  for (uint i = 1; i < req(); i++) {\n+    if (region->in(i) == nullptr || phase->type(region->in(i)) == Type::TOP) {\n+      continue;\n+    }\n+    Node* in = Node::in(i);\n+    const Type* t = phase->type(in);\n+    if (in == nullptr || in == this || t == Type::TOP) {\n+      continue;\n+    }\n+    if (t != phi_type && t->higher_equal_speculative(phi_type)) {\n+      types.insert_sorted<compare_types>(t);\n+    }\n+    while (in != nullptr && in->is_ConstraintCast()) {\n+      Node* next = in->in(1);\n+      if (phase->type(next)->isa_rawptr() && phase->type(in)->isa_oopptr()) {\n+        break;\n+      }\n+      ConstraintCastNode* cast = in->as_ConstraintCast();\n+      for (int j = 0; j < cast->extra_types_count(); ++j) {\n+        const Type* extra_t = cast->extra_type_at(j);\n+        if (extra_t != phi_type && extra_t->higher_equal_speculative(phi_type)) {\n+          types.insert_sorted<compare_types>(extra_t);\n+        }\n+      }\n+      in = next;\n+    }\n+  }\n+  const Type **flds = (const Type **)(phase->C->type_arena()->AmallocWords(types.length()*sizeof(Type*)));\n+  for (int i = 0; i < types.length(); ++i) {\n+    flds[i] = types.at(i);\n+  }\n+  return TypeTuple::make(types.length(), flds);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":56,"deletions":5,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -273,0 +273,2 @@\n+\n+  const TypeTuple* collect_types(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5679,1 +5679,1 @@\n-bool Compile::should_print_igv(int level) {\n+bool Compile::should_print_igv(const int level) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4152,1 +4152,4 @@\n-\/\/ See comments on new_instance for the meaning of the other arguments.\n+\/\/ The optional arguments are for specialized use by intrinsics:\n+\/\/  - If 'return_size_val', report the non-padded array size (sum of header size\n+\/\/    and array body) to the caller.\n+\/\/  - deoptimize_on_exception controls how Java exceptions are handled (rethrow vs deoptimize)\n@@ -4203,1 +4206,0 @@\n-  int   header_size_min  = arrayOopDesc::base_offset_in_bytes(T_BYTE);\n@@ -4212,0 +4214,1 @@\n+    int header_size_min = arrayOopDesc::base_offset_in_bytes(T_BYTE);\n@@ -4213,2 +4216,1 @@\n-    header_size_min = hsize;\n-    header_size = intcon(hsize + round_mask);\n+    header_size = intcon(hsize);\n@@ -4218,4 +4220,2 @@\n-    Node* hsize = _gvn.transform( new URShiftINode(layout_val, hss) );\n-    hsize       = _gvn.transform( new AndINode(hsize, hsm) );\n-    Node* mask  = intcon(round_mask);\n-    header_size = _gvn.transform( new AddINode(hsize, mask) );\n+    header_size = _gvn.transform(new URShiftINode(layout_val, hss));\n+    header_size = _gvn.transform(new AndINode(header_size, hsm));\n@@ -4273,4 +4273,4 @@\n-  \/\/ Combine header size (plus rounding) and body size.  Then round down.\n-  \/\/ This computation cannot overflow, because it is used only in two\n-  \/\/ places, one where the length is sharply limited, and the other\n-  \/\/ after a successful allocation.\n+  \/\/ Combine header size and body size for the array copy part, then align (if\n+  \/\/ necessary) for the allocation part. This computation cannot overflow,\n+  \/\/ because it is used only in two places, one where the length is sharply\n+  \/\/ limited, and the other after a successful allocation.\n@@ -4278,6 +4278,2 @@\n-  if (elem_shift != nullptr)\n-    abody     = _gvn.transform( new LShiftXNode(lengthx, elem_shift) );\n-  Node* size  = _gvn.transform( new AddXNode(headerx, abody) );\n-  if (round_mask != 0) {\n-    Node* mask = MakeConX(~round_mask);\n-    size       = _gvn.transform( new AndXNode(size, mask) );\n+  if (elem_shift != nullptr) {\n+    abody = _gvn.transform(new LShiftXNode(lengthx, elem_shift));\n@@ -4285,1 +4281,1 @@\n-  \/\/ else if round_mask == 0, the size computation is self-rounding\n+  Node* non_rounded_size = _gvn.transform(new AddXNode(headerx, abody));\n@@ -4289,1 +4285,1 @@\n-    (*return_size_val) = size;\n+    (*return_size_val) = non_rounded_size;\n@@ -4292,0 +4288,9 @@\n+  Node* size = non_rounded_size;\n+  if (round_mask != 0) {\n+    Node* mask1 = MakeConX(round_mask);\n+    size = _gvn.transform(new AddXNode(size, mask1));\n+    Node* mask2 = MakeConX(~round_mask);\n+    size = _gvn.transform(new AndXNode(size, mask2));\n+  }\n+  \/\/ else if round_mask == 0, the size computation is self-rounding\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":25,"deletions":20,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -3100,0 +3100,1 @@\n+  Node* vt_oop = _gvn.transform(must_be_not_null(argument(0), true)); \/\/ VirtualThread this argument\n@@ -3108,0 +3109,1 @@\n+    sync_kit(ideal);\n@@ -3110,3 +3112,0 @@\n-    Node* vt_oop = _gvn.transform(must_be_not_null(argument(0), true)); \/\/ VirtualThread this argument\n-\n-    sync_kit(ideal);\n@@ -3117,1 +3116,0 @@\n-    Node* vt_oop = _gvn.transform(argument(0)); \/\/ this argument - VirtualThread oop\n@@ -5400,2 +5398,2 @@\n-        Node* obj_size  = nullptr;\n-        Node* alloc_obj = new_array(obj_klass, obj_length, 0, &obj_size, \/*deoptimize_on_exception=*\/true);\n+        Node* array_size = nullptr; \/\/ Size of the array without object alignment padding.\n+        Node* alloc_obj = new_array(obj_klass, obj_length, 0, &array_size, \/*deoptimize_on_exception=*\/true);\n@@ -5434,1 +5432,1 @@\n-          copy_to_clone(obj, alloc_obj, obj_size, true);\n+          copy_to_clone(obj, alloc_obj, array_size, true);\n@@ -5471,1 +5469,1 @@\n-      Node* obj_size  = nullptr;\n+      Node* obj_size = nullptr; \/\/ Total object size, including object alignment padding.\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1553,1 +1553,1 @@\n-  void sink_use( Node *use, Node *post_loop );\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1904,1 +1904,2 @@\n-                cast = ConstraintCastNode::make_cast_for_type(x_ctrl, in, in_t, ConstraintCastNode::UnconditionalDependency);\n+                cast = ConstraintCastNode::make_cast_for_type(x_ctrl, in, in_t,\n+                                                              ConstraintCastNode::UnconditionalDependency, nullptr);\n@@ -2248,11 +2249,0 @@\n-\/\/------------------------------sink_use---------------------------------------\n-\/\/ If 'use' was in the loop-exit block, it now needs to be sunk\n-\/\/ below the post-loop merge point.\n-void PhaseIdealLoop::sink_use( Node *use, Node *post_loop ) {\n-  if (!use->is_CFG() && get_ctrl(use) == post_loop->in(2)) {\n-    set_ctrl(use, post_loop);\n-    for (DUIterator j = use->outs(); use->has_out(j); j++)\n-      sink_use(use->out(j), post_loop);\n-  }\n-}\n-\n@@ -2325,1 +2315,1 @@\n-      Node *cfg = prev->_idx >= new_counter\n+      Node* cfg = (prev->_idx >= new_counter && prev->is_Region())\n@@ -2349,1 +2339,1 @@\n-        cfg = cfg->_idx >= new_counter ? cfg->in(2) : idom(cfg);\n+        cfg = (cfg->_idx >= new_counter && cfg->is_Region()) ? cfg->in(2) : idom(cfg);\n@@ -2407,4 +2397,0 @@\n-\n-      \/\/ If 'use' was in the loop-exit block, it now needs to be sunk\n-      \/\/ below the post-loop merge point.\n-      sink_use( use, prev );\n@@ -2777,2 +2763,0 @@\n-        \/\/ Map the old use to the new merge point\n-        old_new.map( use->_idx, r );\n@@ -2814,0 +2798,9 @@\n+        assert(use->is_Proj(), \"loop exit should be projection\");\n+        \/\/ lazy_replace() below moves all nodes that are:\n+        \/\/ - control dependent on the loop exit or\n+        \/\/ - have control set to the loop exit\n+        \/\/ below the post-loop merge point. lazy_replace() takes a dead control as first input. To make it\n+        \/\/ possible to use it, the loop exit projection is cloned and becomes the new exit projection. The initial one\n+        \/\/ becomes dead and is \"replaced\" by the region.\n+        Node* use_clone = use->clone();\n+        register_control(use_clone, use_loop, idom(use), dom_depth(use));\n@@ -2816,1 +2809,1 @@\n-        r->set_req(2,    use);\n+        r->set_req(2, use_clone);\n@@ -2820,0 +2813,3 @@\n+        lazy_replace(use, r);\n+        \/\/ Map the (cloned) old use to the new merge point\n+        old_new.map(use_clone->_idx, r);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -3534,1 +3534,2 @@\n-  if (C->should_print_igv(1)) {\n+  constexpr int perBytecode = 5;\n+  if (C->should_print_igv(perBytecode)) {\n@@ -3540,1 +3541,1 @@\n-    printer->print_method(buffer, 5);\n+    printer->print_method(buffer, perBytecode);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1572,4 +1572,1 @@\n-  \/\/ This needs authenticating, but to do that here requires the fp of the previous frame.\n-  \/\/ A better way of doing it would be authenticate in the caller by adding a\n-  \/\/ AuthPAuthNode and using it in GraphKit::gen_stub. For now, just strip it.\n-  AARCH64_PORT_ONLY(ret_pc = pauth_strip_pointer(ret_pc));\n+  AARCH64_PORT_ONLY(ret_pc = pauth_strip_verifiable(ret_pc));\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -586,1 +586,1 @@\n-                                     jint frame_count, jint start_index, jobjectArray frames))\n+                                     jint buffer_size, jint start_index, jobjectArray frames))\n@@ -600,2 +600,1 @@\n-  int limit = start_index + frame_count;\n-  if (frames_array_h->length() < limit) {\n+  if (frames_array_h->length() < buffer_size) {\n@@ -606,1 +605,1 @@\n-                               frame_count, start_index, frames_array_h, CHECK_NULL);\n+                               buffer_size, start_index, frames_array_h, CHECK_NULL);\n@@ -612,1 +611,1 @@\n-                                  jint frame_count, jint start_index,\n+                                  jint last_batch_count, jint buffer_size, jint start_index,\n@@ -620,2 +619,1 @@\n-  int limit = start_index+frame_count;\n-  if (frames_array_h->length() < limit) {\n+  if (frames_array_h->length() < buffer_size) {\n@@ -626,1 +624,1 @@\n-  return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,\n+  return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, last_batch_count, buffer_size,\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1307,29 +1307,0 @@\n-\/\/ Returns true if the current mismatch is due to a resolved\/unresolved\n-\/\/ class pair. Otherwise, returns false.\n-bool VM_RedefineClasses::is_unresolved_class_mismatch(const constantPoolHandle& cp1,\n-       int index1, const constantPoolHandle& cp2, int index2) {\n-\n-  jbyte t1 = cp1->tag_at(index1).value();\n-  if (t1 != JVM_CONSTANT_Class && t1 != JVM_CONSTANT_UnresolvedClass) {\n-    return false;  \/\/ wrong entry type; not our special case\n-  }\n-\n-  jbyte t2 = cp2->tag_at(index2).value();\n-  if (t2 != JVM_CONSTANT_Class && t2 != JVM_CONSTANT_UnresolvedClass) {\n-    return false;  \/\/ wrong entry type; not our special case\n-  }\n-\n-  if (t1 == t2) {\n-    return false;  \/\/ not a mismatch; not our special case\n-  }\n-\n-  char *s1 = cp1->klass_name_at(index1)->as_C_string();\n-  char *s2 = cp2->klass_name_at(index2)->as_C_string();\n-  if (strcmp(s1, s2) != 0) {\n-    return false;  \/\/ strings don't match; not our special case\n-  }\n-\n-  return true;  \/\/ made it through the gauntlet; this is our special case\n-} \/\/ end is_unresolved_class_mismatch()\n-\n-\n@@ -1725,8 +1696,0 @@\n-      } else if (is_unresolved_class_mismatch(scratch_cp, scratch_i,\n-                                              *merge_cp_p, scratch_i)) {\n-        \/\/ The mismatch in compare_entry_to() above is because of a\n-        \/\/ resolved versus unresolved class entry at the same index\n-        \/\/ with the same string value. Since Pass 0 reverted any\n-        \/\/ class entries to unresolved class entries in *merge_cp_p,\n-        \/\/ we go with the unresolved class entry.\n-        continue;\n@@ -1746,7 +1709,0 @@\n-      \/\/ The find_matching_entry() call above could fail to find a match\n-      \/\/ due to a resolved versus unresolved class or string entry situation\n-      \/\/ like we solved above with the is_unresolved_*_mismatch() calls.\n-      \/\/ However, we would have to call is_unresolved_*_mismatch() over\n-      \/\/ all of *merge_cp_p (potentially) and that doesn't seem to be\n-      \/\/ worth the time.\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -441,2 +441,0 @@\n-  bool is_unresolved_class_mismatch(const constantPoolHandle& cp1, int index1,\n-    const constantPoolHandle& cp2, int index2);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1916,2 +1916,5 @@\n-\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64)\n+  \/\/ Valhalla missing LM_LIGHTWEIGHT support just now\n+  if (EnableValhalla && LockingMode != LM_LEGACY) {\n+    FLAG_SET_CMDLINE(LockingMode, LM_LEGACY);\n+  }\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64) && !defined(S390)\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1909,4 +1909,0 @@\n-  product(size_t, ArrayAllocatorMallocLimit, SIZE_MAX, EXPERIMENTAL,        \\\n-          \"Allocation less than this value will be allocated \"              \\\n-          \"using malloc. Larger allocations will use mmap.\")                \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1592,0 +1592,7 @@\n+\/\/ Like name() but doesn't include the protection check. This must only be\n+\/\/ called when it is known to be safe, even though the protection check can't tell\n+\/\/ that e.g. when this thread is the init_thread() - see instanceKlass.cpp.\n+const char* JavaThread::name_raw() const  {\n+  return get_thread_name_string();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -908,0 +908,1 @@\n+  const char* name_raw() const;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+ * @sealedGraph\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.BitSet;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-runtime\/ErrorHandling\/TestDwarf.java 8305489 linux-all\n+runtime\/ErrorHandling\/TestDwarf.java#checkDecoder 8305489 linux-all\n@@ -145,0 +145,1 @@\n+serviceability\/jvmti\/RedefineClasses\/RedefineLeakThrowable.java 8316658 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -560,0 +560,1 @@\n+  -serviceability\/jvmti\/RedefineClasses\/RedefineLeakThrowable.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -416,0 +416,1 @@\n+java\/awt\/font\/Rotate\/RotatedTextTest.java 8219641 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}