{"files":[{"patch":"@@ -491,1 +491,15 @@\n-      __ test_oop_is_not_inline_type(r0, rscratch2, skip);\n+      Label not_null;\n+      __ cbnz(r0, not_null);\n+      \/\/ Returned value is null, zero all return registers because they may belong to oop fields\n+      __ mov(j_rarg1, zr);\n+      __ mov(j_rarg2, zr);\n+      __ mov(j_rarg3, zr);\n+      __ mov(j_rarg4, zr);\n+      __ mov(j_rarg5, zr);\n+      __ mov(j_rarg6, zr);\n+      __ mov(j_rarg7, zr);\n+      __ b(skip);\n+      __ bind(not_null);\n+\n+      \/\/ Check if we are returning an non-null inline type and load its fields into registers\n+      __ test_oop_is_not_inline_type(r0, rscratch2, skip, \/* can_be_null= *\/ false);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -713,1 +713,0 @@\n-    \/\/ Check if we are returning an non-null inline type and load its fields into registers\n@@ -715,1 +714,15 @@\n-    test_oop_is_not_inline_type(r0, rscratch2, skip);\n+    Label not_null;\n+    cbnz(r0, not_null);\n+    \/\/ Returned value is null, zero all return registers because they may belong to oop fields\n+    mov(j_rarg1, zr);\n+    mov(j_rarg2, zr);\n+    mov(j_rarg3, zr);\n+    mov(j_rarg4, zr);\n+    mov(j_rarg5, zr);\n+    mov(j_rarg6, zr);\n+    mov(j_rarg7, zr);\n+    b(skip);\n+    bind(not_null);\n+\n+    \/\/ Check if we are returning an non-null inline type and load its fields into registers\n+    test_oop_is_not_inline_type(r0, rscratch2, skip, \/* can_be_null= *\/ false);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2274,1 +2274,1 @@\n-void MacroAssembler::test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type) {\n+void MacroAssembler::test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type, bool can_be_null) {\n@@ -2276,1 +2276,3 @@\n-  cbz(object, not_inline_type);\n+  if (can_be_null) {\n+    cbz(object, not_inline_type);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -663,1 +663,1 @@\n-  void test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type);\n+  void test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type, bool can_be_null = true);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3173,1 +3173,26 @@\n-  __ cbz(r0, skip);\n+  Label not_null;\n+  __ cbnz(r0, not_null);\n+\n+  \/\/ Return value is null. Zero oop registers to make the GC happy.\n+  j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_METADATA) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    if (bt == T_OBJECT || bt == T_ARRAY) {\n+      VMRegPair pair = regs->at(j);\n+      VMReg r_1 = pair.first();\n+      __ mov(r_1->as_Register(), zr);\n+    }\n+    j++;\n+  }\n+  __ b(skip);\n+  __ bind(not_null);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -489,1 +489,14 @@\n-      __ test_oop_is_not_inline_type(rax, rscratch1, skip);\n+      Label not_null;\n+      __ testptr(rax, rax);\n+      __ jcc(Assembler::notZero, not_null);\n+      \/\/ Returned value is null, zero all return registers because they may belong to oop fields\n+      __ xorq(j_rarg1, j_rarg1);\n+      __ xorq(j_rarg2, j_rarg2);\n+      __ xorq(j_rarg3, j_rarg3);\n+      __ xorq(j_rarg4, j_rarg4);\n+      __ xorq(j_rarg5, j_rarg5);\n+      __ jmp(skip);\n+      __ bind(not_null);\n+\n+      \/\/ Check if we are returning an non-null inline type and load its fields into registers\n+      __ test_oop_is_not_inline_type(rax, rscratch1, skip, \/* can_be_null= *\/ false);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -989,1 +989,0 @@\n-    \/\/ Check if we are returning an non-null inline type and load its fields into registers\n@@ -991,1 +990,14 @@\n-    test_oop_is_not_inline_type(rax, rscratch1, skip);\n+    Label not_null;\n+    testptr(rax, rax);\n+    jcc(Assembler::notZero, not_null);\n+    \/\/ Returned value is null, zero all return registers because they may belong to oop fields\n+    xorq(j_rarg1, j_rarg1);\n+    xorq(j_rarg2, j_rarg2);\n+    xorq(j_rarg3, j_rarg3);\n+    xorq(j_rarg4, j_rarg4);\n+    xorq(j_rarg5, j_rarg5);\n+    jmp(skip);\n+    bind(not_null);\n+\n+    \/\/ Check if we are returning an non-null inline type and load its fields into registers\n+    test_oop_is_not_inline_type(rax, rscratch1, skip, \/* can_be_null= *\/ false);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2369,3 +2369,5 @@\n-void MacroAssembler::test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type) {\n-  testptr(object, object);\n-  jcc(Assembler::zero, not_inline_type);\n+void MacroAssembler::test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type, bool can_be_null) {\n+  if (can_be_null) {\n+    testptr(object, object);\n+    jcc(Assembler::zero, not_inline_type);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  void test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type);\n+  void test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type, bool can_be_null = true);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3973,0 +3973,1 @@\n+  Label not_null;\n@@ -3974,1 +3975,25 @@\n-  __ jcc(Assembler::zero, skip);\n+  __ jcc(Assembler::notZero, not_null);\n+\n+  \/\/ Return value is null. Zero oop registers to make the GC happy.\n+  j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_METADATA) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    if (bt == T_OBJECT || bt == T_ARRAY) {\n+      VMRegPair pair = regs->at(j);\n+      VMReg r_1 = pair.first();\n+      __ xorq(r_1->as_Register(), r_1->as_Register());\n+    }\n+    j++;\n+  }\n+  __ jmp(skip);\n+  __ bind(not_null);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -544,4 +544,3 @@\n-      oop v = *(oop*)loc;\n-      assert(v == nullptr || oopDesc::is_oop(v), \"not an oop?\");\n-      assert(Universe::heap()->is_in_or_null(v), \"must be heap pointer\");\n-      handles.push(Handle(thread, v));\n+      oop o = *(oop*)loc;\n+      assert(oopDesc::is_oop_or_null(o), \"Bad oop value: \" PTR_FORMAT, p2i(o));\n+      handles.push(Handle(thread, o));\n@@ -570,1 +569,2 @@\n-  for (int i = 0, k = 0; i < sig_vk->length(); i++) {\n+  int k = 0;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n@@ -587,0 +587,1 @@\n+  assert(k == handles.length(), \"missed a handle?\");\n@@ -669,2 +670,4 @@\n-\/\/ Check the return register for an InlineKlass oop\n-InlineKlass* InlineKlass::returned_inline_klass(const RegisterMap& map) {\n+\/\/ Check if we return an inline type in scalarized form, i.e. check if either\n+\/\/ - The return value is a tagged InlineKlass pointer, or\n+\/\/ - The return value is an inline type oop that is also returned in scalarized form\n+InlineKlass* InlineKlass::returned_inline_klass(const RegisterMap& map, bool* return_oop) {\n@@ -684,0 +687,4 @@\n+    if (return_oop != nullptr) {\n+      \/\/ Not returning an oop\n+      *return_oop = false;\n+    }\n@@ -687,2 +694,10 @@\n-  assert(oopDesc::is_oop_or_null(cast_to_oop(ptr), true),\n-         \"Bad oop return: \" PTR_FORMAT, ptr);\n+  oop o = cast_to_oop(ptr);\n+  assert(oopDesc::is_oop_or_null(o, true), \"Bad oop return: \" PTR_FORMAT, ptr);\n+  if (return_oop != nullptr && o != nullptr) {\n+    \/\/ Check if inline type is also returned in scalarized form\n+    assert(o->is_inline_type(), \"Invalid return value\");\n+    InlineKlass* vk = InlineKlass::cast(o->klass());\n+    if (vk->can_be_returned_as_fields()) {\n+      return vk;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-  static InlineKlass* returned_inline_klass(const RegisterMap& reg_map);\n+  static InlineKlass* returned_inline_klass(const RegisterMap& reg_map, bool* return_oop = nullptr);\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -793,2 +793,1 @@\n-    if (return_oop && InlineTypeReturnedAsFields &&\n-        (method->result_type() == T_OBJECT)) {\n+    if (method->has_scalarized_return()) {\n@@ -796,1 +795,2 @@\n-      vk = InlineKlass::returned_inline_klass(map);\n+      assert(return_oop, \"must be\");\n+      vk = InlineKlass::returned_inline_klass(map, &return_oop);\n@@ -803,1 +803,0 @@\n-        return_oop = false;\n@@ -827,1 +826,1 @@\n-      assert(return_values.length() == 1, \"only one return value\");\n+      assert(vk != nullptr || return_values.length() == 1, \"only one return value\");\n@@ -829,1 +828,3 @@\n-    } else if (vk != nullptr) {\n+    }\n+    \/\/ restore oops in scalarized fields\n+    if (vk != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test that oop fields in scalarized returns are properly handled.\n+ * @library \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @requires vm.simpleArch == \"x64\"\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention Interpreted\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:+StressCallingConvention\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention Interpreted\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+StressCallingConvention\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:+StressCallingConvention\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention C2\n+ **\/\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestOopsInReturnConvention {\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    static final int COMP_LEVEL_FULL_OPTIMIZATION = 4; \/\/ C2 or JVMCI\n+\n+    \/\/ Large value class with oops\n+    static value class LargeValueWithOops {\n+        Object x1;\n+        Object x2;\n+        Object x3;\n+        Object x4;\n+        Object x5;\n+\n+        public LargeValueWithOops(Object obj) {\n+            this.x1 = obj;\n+            this.x2 = obj;\n+            this.x3 = obj;\n+            this.x4 = obj;\n+            this.x5 = obj;\n+        }\n+\n+        public static void verify(LargeValueWithOops val, Object obj, boolean useNull) {\n+            if (useNull) {\n+                Asserts.assertEQ(val, null);\n+            } else {\n+                Asserts.assertEQ(val.x1, obj);\n+                Asserts.assertEQ(val.x2, obj);\n+                Asserts.assertEQ(val.x3, obj);\n+                Asserts.assertEQ(val.x4, obj);\n+                Asserts.assertEQ(val.x5, obj);\n+            }\n+        }\n+    }\n+\n+    \/\/ Pass some unused args to make sure that the (return) registers are trashed\n+    public static LargeValueWithOops callee(int unused1, int unused2, int unused3, int unused4, int unused5, LargeValueWithOops val) {\n+        return val;\n+    }\n+\n+    public static void caller(LargeValueWithOops val, Object obj, boolean useNull) {\n+        \/\/ Below call will return a LargeValueWithOops in scalarized form.\n+        \/\/ If it's null, the x1 - x5 oop fields need to be zeroed to make the GC happy.\n+        val = callee(1, 2, 3, 4, 5, val);\n+        LargeValueWithOops.verify(val, obj, useNull);\n+    }\n+\n+    static class GarbageProducerThread extends Thread {\n+        public void run() {\n+            for (;;) {\n+                \/\/ Produce some garbage and then let the GC do its work\n+                Object[] arrays = new Object[1024];\n+                for (int i = 0; i < arrays.length; i++) {\n+                    arrays[i] = new int[1024];\n+                }\n+                System.gc();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args[0].equals(\"Interpreted\") || args[0].equals(\"C1\")) {\n+            \/\/ Prevent callee method from being C2 compiled to ensure it's interpreted or C1 compiled\n+            Method m = TestOopsInReturnConvention.class.getDeclaredMethod(\"callee\", int.class, int.class, int.class, int.class, int.class, LargeValueWithOops.class);\n+            WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false);\n+        }\n+\n+        \/\/ Start another thread that does some allocations and calls System.gc() to trigger frequent GCs\n+        Thread garbage_producer = new GarbageProducerThread();\n+        garbage_producer.setDaemon(true);\n+        garbage_producer.start();\n+\n+        \/\/ Trigger compilation\n+        for (int i = 0; i < 500_000; i++) {\n+            boolean useNull = (i % 2) == 0;\n+            LargeValueWithOops val = useNull ? null : new LargeValueWithOops(i);\n+            caller(val, i, useNull);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOopsInReturnConvention.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}