{"files":[{"patch":"@@ -1247,1 +1247,1 @@\n-    if (UseCompressedOops && (CompressedOops::ptrs_base() != nullptr)) {\n+    if (UseCompressedOops && (CompressedOops::base() != nullptr)) {\n@@ -2615,1 +2615,2 @@\n-      is_valid_sve_arith_imm_pattern(n, m)) {\n+      is_valid_sve_arith_imm_pattern(n, m) ||\n+      is_encode_and_store_pattern(n, m)) {\n@@ -6436,1 +6437,1 @@\n-  predicate(!needs_acquiring_load(n));\n+  predicate(!needs_acquiring_load(n) && n->as_Load()->barrier_data() == 0);\n@@ -6865,1 +6866,1 @@\n-  predicate(!needs_releasing_store(n));\n+  predicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\n@@ -6878,1 +6879,1 @@\n-  predicate(!needs_releasing_store(n));\n+  predicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\n@@ -7112,0 +7113,1 @@\n+  predicate(n->as_Load()->barrier_data() == 0);\n@@ -7279,0 +7281,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -7291,0 +7294,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -8102,0 +8106,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -8216,1 +8221,1 @@\n-  predicate(needs_acquiring_load_exclusive(n));\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -8321,0 +8326,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -8430,1 +8436,1 @@\n-  predicate(needs_acquiring_load_exclusive(n));\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -8542,0 +8548,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -8661,1 +8668,1 @@\n-  predicate(needs_acquiring_load_exclusive(n));\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n@@ -8722,0 +8729,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -8765,1 +8773,1 @@\n-  predicate(needs_acquiring_load_exclusive(n));\n+  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+  Register owner_addr = tmpReg;\n@@ -185,0 +186,1 @@\n+  Label unlocked;\n@@ -235,0 +237,12 @@\n+\n+  \/\/ Compute owner address.\n+  lea(owner_addr, Address(tmp, ObjectMonitor::owner_offset()));\n+\n+  \/\/ Set owner to null.\n+  \/\/ Release to satisfy the JMM\n+  stlr(zr, owner_addr);\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  \/\/ StoreLoad achieves this.\n+  membar(StoreLoad);\n+\n+  \/\/ Check if the entry lists are empty.\n@@ -236,7 +250,21 @@\n-  ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n-  orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n-  cmp(rscratch1, zr); \/\/ Sets flags for result\n-  cbnz(rscratch1, cont);\n-  \/\/ need a release store here\n-  lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n-  stlr(zr, tmp); \/\/ set unowned\n+  ldr(tmpReg, Address(tmp, ObjectMonitor::cxq_offset()));\n+  orr(rscratch1, rscratch1, tmpReg);\n+  cmp(rscratch1, zr);\n+  br(Assembler::EQ, cont);     \/\/ If so we are done.\n+\n+  \/\/ Check if there is a successor.\n+  ldr(rscratch1, Address(tmp, ObjectMonitor::succ_offset()));\n+  cmp(rscratch1, zr);\n+  br(Assembler::NE, unlocked); \/\/ If so we are done.\n+\n+  \/\/ Save the monitor pointer in the current thread, so we can try to\n+  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n+  str(tmp, Address(rthread, JavaThread::unlocked_inflated_monitor_offset()));\n+\n+  cmp(zr, rthread); \/\/ Set Flag to NE => slow path\n+  b(cont);\n+\n+  bind(unlocked);\n+  cmp(zr, zr); \/\/ Set Flag to EQ => fast path\n+\n+  \/\/ Intentional fall-through\n@@ -529,1 +557,0 @@\n-    Label release;\n@@ -535,0 +562,7 @@\n+    \/\/ Set owner to null.\n+    \/\/ Release to satisfy the JMM\n+    stlr(zr, t2_owner_addr);\n+    \/\/ We need a full fence after clearing owner to avoid stranding.\n+    \/\/ StoreLoad achieves this.\n+    membar(StoreLoad);\n+\n@@ -540,1 +574,1 @@\n-    br(Assembler::EQ, release);\n+    br(Assembler::EQ, unlocked);  \/\/ If so we are done.\n@@ -542,5 +576,4 @@\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    str(rthread, Address(t2_owner_addr));\n-    b(slow_path);\n+    \/\/ Check if there is a successor.\n+    ldr(rscratch1, Address(t1_monitor, ObjectMonitor::succ_offset()));\n+    cmp(rscratch1, zr);\n+    br(Assembler::NE, unlocked);  \/\/ If so we are done.\n@@ -548,4 +581,6 @@\n-    bind(release);\n-    \/\/ Set owner to null.\n-    \/\/ Release to satisfy the JMM\n-    stlr(zr, t2_owner_addr);\n+    \/\/ Save the monitor pointer in the current thread, so we can try to\n+    \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n+    str(t1_monitor, Address(rthread, JavaThread::unlocked_inflated_monitor_offset()));\n+\n+    cmp(zr, rthread); \/\/ Set Flag to NE => slow path\n+    b(slow_path);\n@@ -556,0 +591,1 @@\n+  cmp(zr, zr); \/\/ Set Flags to EQ => fast path\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":54,"deletions":18,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -41,1 +41,4 @@\n-#endif\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -98,0 +101,48 @@\n+static void generate_queue_test_and_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n+                                              const Register thread, const Register value, const Register temp1, const Register temp2) {\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ ldr(temp1, Address(thread, in_bytes(index_offset)));   \/\/ temp1 := *(index address)\n+  __ cbz(temp1, runtime);                                   \/\/ jump to runtime if index == 0 (full buffer)\n+  \/\/ The buffer is not full, store value into it.\n+  __ sub(temp1, temp1, wordSize);                           \/\/ temp1 := next index\n+  __ str(temp1, Address(thread, in_bytes(index_offset)));   \/\/ *(index address) := next index\n+  __ ldr(temp2, Address(thread, in_bytes(buffer_offset)));  \/\/ temp2 := buffer address\n+  __ str(value, Address(temp2, temp1));                     \/\/ *(buffer address + next index) := value\n+}\n+\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread,\n+                                           const Register tmp1) {\n+  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n+  \/\/ Is marking active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ ldrw(tmp1, in_progress);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ ldrb(tmp1, in_progress);\n+  }\n+}\n+\n+static void generate_pre_barrier_slow_path(MacroAssembler* masm,\n+                                           const Register obj,\n+                                           const Register pre_val,\n+                                           const Register thread,\n+                                           const Register tmp1,\n+                                           const Register tmp2,\n+                                           Label& done,\n+                                           Label& runtime) {\n+  \/\/ Do we need to load the previous value?\n+  if (obj != noreg) {\n+    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n+  }\n+  \/\/ Is the previous value null?\n+  __ cbz(pre_val, done);\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                                    G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, pre_val, tmp1, tmp2);\n+  __ b(done);\n+}\n+\n@@ -118,11 +169,2 @@\n-  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n-  Address index(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));\n-\n-  \/\/ Is marking active?\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ ldrw(tmp1, in_progress);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ ldrb(tmp1, in_progress);\n-  }\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is not active (*(mark queue active address) == 0), jump to done\n@@ -130,25 +172,1 @@\n-\n-  \/\/ Do we need to load the previous value?\n-  if (obj != noreg) {\n-    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n-  }\n-\n-  \/\/ Is the previous value null?\n-  __ cbz(pre_val, done);\n-\n-  \/\/ Can we store original value in the thread's buffer?\n-  \/\/ Is index == 0?\n-  \/\/ (The index field is typed as size_t.)\n-\n-  __ ldr(tmp1, index);                      \/\/ tmp := *index_adr\n-  __ cbz(tmp1, runtime);                    \/\/ tmp == 0?\n-                                        \/\/ If yes, goto runtime\n-\n-  __ sub(tmp1, tmp1, wordSize);             \/\/ tmp := tmp - wordSize\n-  __ str(tmp1, index);                      \/\/ *index_adr := tmp\n-  __ ldr(tmp2, buffer);\n-  __ add(tmp1, tmp1, tmp2);                 \/\/ tmp := tmp + *buffer_adr\n-\n-  \/\/ Record the previous value\n-  __ str(pre_val, Address(tmp1, 0));\n-  __ b(done);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, done, runtime);\n@@ -210,0 +228,44 @@\n+static void generate_post_barrier_fast_path(MacroAssembler* masm,\n+                                            const Register store_addr,\n+                                            const Register new_val,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            bool new_val_may_be_null) {\n+  \/\/ Does store cross heap regions?\n+  __ eor(tmp1, store_addr, new_val);                     \/\/ tmp1 := store address ^ new value\n+  __ lsr(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);   \/\/ tmp1 := ((store address ^ new value) >> LogOfHRGrainBytes)\n+  __ cbz(tmp1, done);\n+  \/\/ Crosses regions, storing null?\n+  if (new_val_may_be_null) {\n+    __ cbz(new_val, done);\n+  }\n+  \/\/ Storing region crossing non-null, is card young?\n+  __ lsr(tmp1, store_addr, CardTable::card_shift());     \/\/ tmp1 := card address relative to card table base\n+  __ load_byte_map_base(tmp2);                           \/\/ tmp2 := card table base address\n+  __ add(tmp1, tmp1, tmp2);                              \/\/ tmp1 := card address\n+  __ ldrb(tmp2, Address(tmp1));                          \/\/ tmp2 := card\n+  __ cmpw(tmp2, (int)G1CardTable::g1_young_card_val());  \/\/ tmp2 := card == young_card_val?\n+}\n+\n+static void generate_post_barrier_slow_path(MacroAssembler* masm,\n+                                            const Register thread,\n+                                            const Register tmp1,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            Label& runtime) {\n+  __ membar(Assembler::StoreLoad);  \/\/ StoreLoad membar\n+  __ ldrb(tmp2, Address(tmp1));     \/\/ tmp2 := card\n+  __ cbzw(tmp2, done);\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n+  \/\/ Dirty card and log.\n+  STATIC_ASSERT(CardTable::dirty_card_val() == 0);\n+  __ strb(zr, Address(tmp1));       \/\/ *(card address) := dirty_card_val\n+  generate_queue_test_and_insertion(masm,\n+                                    G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                                    G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                                    runtime,\n+                                    thread, tmp1, tmp2, rscratch1);\n+  __ b(done);\n+}\n+\n@@ -222,7 +284,0 @@\n-  Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));\n-\n-  BarrierSet* bs = BarrierSet::barrier_set();\n-  CardTableBarrierSet* ctbs = barrier_set_cast<CardTableBarrierSet>(bs);\n-  CardTable* ct = ctbs->card_table();\n-\n@@ -232,23 +287,2 @@\n-  \/\/ Does store cross heap regions?\n-\n-  __ eor(tmp1, store_addr, new_val);\n-  __ lsr(tmp1, tmp1, G1HeapRegion::LogOfHRGrainBytes);\n-  __ cbz(tmp1, done);\n-\n-  \/\/ crosses regions, storing null?\n-\n-  __ cbz(new_val, done);\n-\n-  \/\/ storing region crossing non-null, is card already dirty?\n-\n-  assert_different_registers(store_addr, thread, tmp1, tmp2, rscratch1);\n-\n-  const Register card_addr = tmp1;\n-\n-  __ lsr(card_addr, store_addr, CardTable::card_shift());\n-\n-  \/\/ get the address of the card\n-  __ load_byte_map_base(tmp2);\n-  __ add(card_addr, card_addr, tmp2);\n-  __ ldrb(tmp2, Address(card_addr));\n-  __ cmpw(tmp2, (int)G1CardTable::g1_young_card_val());\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, done, true \/* new_val_may_be_null *\/);\n+  \/\/ If card is young, jump to done\n@@ -256,21 +290,1 @@\n-\n-  assert((int)CardTable::dirty_card_val() == 0, \"must be 0\");\n-\n-  __ membar(Assembler::StoreLoad);\n-\n-  __ ldrb(tmp2, Address(card_addr));\n-  __ cbzw(tmp2, done);\n-\n-  \/\/ storing a region crossing, non-null oop, card is clean.\n-  \/\/ dirty card and log.\n-\n-  __ strb(zr, Address(card_addr));\n-\n-  __ ldr(rscratch1, queue_index);\n-  __ cbz(rscratch1, runtime);\n-  __ sub(rscratch1, rscratch1, wordSize);\n-  __ str(rscratch1, queue_index);\n-\n-  __ ldr(tmp2, buffer);\n-  __ str(card_addr, Address(tmp2, rscratch1));\n-  __ b(done);\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, done, runtime);\n@@ -297,1 +311,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), tmp1, thread);\n@@ -304,0 +318,92 @@\n+#if defined(COMPILER2)\n+\n+static void generate_c2_barrier_runtime_call(MacroAssembler* masm, G1BarrierStubC2* stub, const Register arg, const address runtime_path) {\n+  SaveLiveRegisters save_registers(masm, stub);\n+  if (c_rarg0 != arg) {\n+    __ mov(c_rarg0, arg);\n+  }\n+  __ mov(c_rarg1, rthread);\n+  __ mov(rscratch1, runtime_path);\n+  __ blr(rscratch1);\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                                                    Register obj,\n+                                                    Register pre_val,\n+                                                    Register thread,\n+                                                    Register tmp1,\n+                                                    Register tmp2,\n+                                                    G1PreBarrierStubC2* stub) {\n+  assert(thread == rthread, \"must be\");\n+  assert_different_registers(obj, pre_val, tmp1, tmp2);\n+  assert(pre_val != noreg && tmp1 != noreg && tmp2 != noreg, \"expecting a register\");\n+\n+  stub->initialize_registers(obj, pre_val, thread, tmp1, tmp2);\n+\n+  generate_pre_barrier_fast_path(masm, thread, tmp1);\n+  \/\/ If marking is active (*(mark queue active address) != 0), jump to stub (slow path)\n+  __ cbnzw(tmp1, *stub->entry());\n+\n+  __ bind(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                                         G1PreBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register obj = stub->obj();\n+  Register pre_val = stub->pre_val();\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1();\n+  Register tmp2 = stub->tmp2();\n+\n+  __ bind(*stub->entry());\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp1, tmp2, *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, pre_val, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry));\n+  __ b(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                                     Register store_addr,\n+                                                     Register new_val,\n+                                                     Register thread,\n+                                                     Register tmp1,\n+                                                     Register tmp2,\n+                                                     G1PostBarrierStubC2* stub) {\n+  assert(thread == rthread, \"must be\");\n+  assert_different_registers(store_addr, new_val, thread, tmp1, tmp2,\n+                             rscratch1);\n+  assert(store_addr != noreg && new_val != noreg && tmp1 != noreg\n+         && tmp2 != noreg, \"expecting a register\");\n+\n+  stub->initialize_registers(thread, tmp1, tmp2);\n+\n+  bool new_val_may_be_null = (stub->barrier_data() & G1C2BarrierPostNotNull) == 0;\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp1, tmp2, *stub->continuation(), new_val_may_be_null);\n+  \/\/ If card is not young, jump to stub (slow path)\n+  __ br(Assembler::NE, *stub->entry());\n+\n+  __ bind(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                                          G1PostBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register thread = stub->thread();\n+  Register tmp1 = stub->tmp1(); \/\/ tmp1 holds the card address.\n+  Register tmp2 = stub->tmp2();\n+  assert(stub->tmp3() == noreg, \"not needed in this platform\");\n+\n+  __ bind(*stub->entry());\n+  generate_post_barrier_slow_path(masm, thread, tmp1, tmp2, *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, tmp1, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry));\n+  __ b(*stub->continuation());\n+}\n+\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":195,"deletions":89,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -3127,1 +3127,1 @@\n-    cmpptr(rheapbase, ExternalAddress(CompressedOops::ptrs_base_addr()));\n+    cmpptr(rheapbase, ExternalAddress(CompressedOops::base_addr()));\n@@ -3293,1 +3293,1 @@\n-      mov(rheapbase, CompressedOops::ptrs_base());\n+      mov(rheapbase, CompressedOops::base());\n@@ -3295,1 +3295,1 @@\n-      lea(rheapbase, ExternalAddress(CompressedOops::ptrs_base_addr()));\n+      lea(rheapbase, ExternalAddress(CompressedOops::base_addr()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -2515,1 +2516,1 @@\n-  if (EnableJVMCI && UseJVMCICompiler) {\n+  if (UseJVMCICompiler) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3442,2 +3442,0 @@\n-    __ andw(rscratch3, r2, r4);\n-    __ bicw(rscratch4, r3, r4);\n@@ -3446,1 +3444,0 @@\n-    __ orrw(rscratch3, rscratch3, rscratch4);\n@@ -3449,2 +3446,5 @@\n-    __ addw(rscratch3, rscratch3, rscratch4);\n-    __ rorw(rscratch2, rscratch3, 32 - s);\n+    __ bicw(rscratch2, r3, r4);\n+    __ andw(rscratch3, r2, r4);\n+    __ addw(rscratch2, rscratch2, rscratch4);\n+    __ addw(rscratch2, rscratch2, rscratch3);\n+    __ rorw(rscratch2, rscratch2, 32 - s);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -73,6 +73,0 @@\n-\/\/-----------------------------------------------------------------------------\n-\n-extern \"C\" void entry(CodeBuffer*);\n-\n-\/\/-----------------------------------------------------------------------------\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -971,1 +971,1 @@\n-      lightweight_lock(object, header, tmp, slow_case);\n+      lightweight_lock(monitor, object, header, tmp, slow_case);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-    lightweight_lock(object, header, tmp, slow_case);\n+    lightweight_lock(monitor, object, header, tmp, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -835,1 +835,5 @@\n-      x->id() == vmIntrinsics::_dlog10) {\n+      x->id() == vmIntrinsics::_dlog10\n+#ifdef _LP64\n+      || x->id() == vmIntrinsics::_dtanh\n+#endif\n+      ) {\n@@ -1017,1 +1021,1 @@\n-      __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc->args());\n+        __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc->args());\n@@ -1022,0 +1026,6 @@\n+    case vmIntrinsics::_dtanh:\n+       assert(StubRoutines::dtanh() != nullptr, \"tanh intrinsic not found\");\n+       if (StubRoutines::dtanh() != nullptr) {\n+        __ call_runtime_leaf(StubRoutines::dtanh(), getThreadTemp(), result_reg, cc->args());\n+      }\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -491,16 +491,1 @@\n-#ifndef _LP64\n-  \/\/ Note that we could employ various encoding schemes to reduce\n-  \/\/ the number of loads below (currently 4) to just 2 or 3.\n-  \/\/ Refer to the comments in synchronizer.cpp.\n-  \/\/ In practice the chain of fetches doesn't seem to impact performance, however.\n-  xorptr(boxReg, boxReg);\n-  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  jccb  (Assembler::notZero, DONE_LABEL);\n-  movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-  jccb  (Assembler::notZero, DONE_LABEL);\n-  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n-  jmpb  (DONE_LABEL);\n-#else \/\/ _LP64\n-  \/\/ It's inflated\n-  Label CheckSucc, LNotRecursive, LSuccess, LGoSlowPath;\n+  Label LSuccess, LNotRecursive;\n@@ -512,1 +497,1 @@\n-  decq(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+  decrement(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n@@ -516,4 +501,3 @@\n-  movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-  jccb  (Assembler::notZero, CheckSucc);\n-  \/\/ Without cast to int32_t this style of movptr will destroy r10 which is typically obj.\n+\n+  \/\/ Set owner to null.\n+  \/\/ Release to satisfy the JMM\n@@ -521,1 +505,3 @@\n-  jmpb  (DONE_LABEL);\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  \/\/ StoreLoad achieves this.\n+  membar(StoreLoad);\n@@ -523,2 +509,4 @@\n-  \/\/ Try to avoid passing control into the slow_path ...\n-  bind  (CheckSucc);\n+  \/\/ Check if the entry lists are empty.\n+  movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+  jccb(Assembler::zero, LSuccess);    \/\/ If so we are done.\n@@ -526,4 +514,1 @@\n-  \/\/ The following optional optimization can be elided if necessary\n-  \/\/ Effectively: if (succ == null) goto slow path\n-  \/\/ The code reduces the window for a race, however,\n-  \/\/ and thus benefits performance.\n+  \/\/ Check if there is a successor.\n@@ -531,5 +516,1 @@\n-  jccb  (Assembler::zero, LGoSlowPath);\n-\n-  xorptr(boxReg, boxReg);\n-  \/\/ Without cast to int32_t this style of movptr will destroy r10 which is typically obj.\n-  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+  jccb(Assembler::notZero, LSuccess); \/\/ If so we are done.\n@@ -537,8 +518,9 @@\n-  \/\/ Memory barrier\/fence\n-  \/\/ Dekker pivot point -- fulcrum : ST Owner; MEMBAR; LD Succ\n-  \/\/ Instead of MFENCE we use a dummy locked add of 0 to the top-of-stack.\n-  \/\/ This is faster on Nehalem and AMD Shanghai\/Barcelona.\n-  \/\/ See https:\/\/blogs.oracle.com\/dave\/entry\/instruction_selection_for_volatile_fences\n-  \/\/ We might also restructure (ST Owner=0;barrier;LD _Succ) to\n-  \/\/ (mov box,0; xchgq box, &m->Owner; LD _succ) .\n-  lock(); addl(Address(rsp, 0), 0);\n+  \/\/ Save the monitor pointer in the current thread, so we can try to\n+  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n+  andptr(tmpReg, ~(int32_t)markWord::monitor_value);\n+#ifndef _LP64\n+  get_thread(boxReg);\n+  movptr(Address(boxReg, JavaThread::unlocked_inflated_monitor_offset()), tmpReg);\n+#else \/\/ _LP64\n+  movptr(Address(r15_thread, JavaThread::unlocked_inflated_monitor_offset()), tmpReg);\n+#endif\n@@ -546,26 +528,0 @@\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n-  jccb  (Assembler::notZero, LSuccess);\n-\n-  \/\/ Rare inopportune interleaving - race.\n-  \/\/ The successor vanished in the small window above.\n-  \/\/ The lock is contended -- (cxq|EntryList) != null -- and there's no apparent successor.\n-  \/\/ We need to ensure progress and succession.\n-  \/\/ Try to reacquire the lock.\n-  \/\/ If that fails then the new owner is responsible for succession and this\n-  \/\/ thread needs to take no further action and can exit via the fast path (success).\n-  \/\/ If the re-acquire succeeds then pass control into the slow path.\n-  \/\/ As implemented, this latter mode is horrible because we generated more\n-  \/\/ coherence traffic on the lock *and* artificially extended the critical section\n-  \/\/ length while by virtue of passing control into the slow path.\n-\n-  \/\/ box is really RAX -- the following CMPXCHG depends on that binding\n-  \/\/ cmpxchg R,[M] is equivalent to rax = CAS(M,rax,R)\n-  lock();\n-  cmpxchgptr(r15_thread, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-  \/\/ There's no successor so we tried to regrab the lock.\n-  \/\/ If that didn't work, then another thread grabbed the\n-  \/\/ lock so we're done (and exit was a success).\n-  jccb  (Assembler::notEqual, LSuccess);\n-  \/\/ Intentional fall-through into slow path\n-\n-  bind  (LGoSlowPath);\n@@ -579,1 +535,0 @@\n-#endif\n@@ -776,4 +731,1 @@\n-  Label unlocked;\n-\n-  \/\/ Assume success.\n-  decrement(Address(thread, JavaThread::held_monitor_count_offset()));\n+  Label unlocked, slow_path;\n@@ -795,2 +747,0 @@\n-  Label& check_successor = stub == nullptr ? dummy : stub->check_successor();\n-  Label& slow_path = stub == nullptr ? dummy : stub->slow_path();\n@@ -871,0 +821,1 @@\n+    const Address succ_address{monitor, ObjectMonitor::succ_offset() - monitor_tag};\n@@ -878,1 +829,8 @@\n-    jccb(Assembler::notEqual, recursive);\n+    jccb(Assembler::notZero, recursive);\n+\n+    \/\/ Set owner to null.\n+    \/\/ Release to satisfy the JMM\n+    movptr(owner_address, NULL_WORD);\n+    \/\/ We need a full fence after clearing owner to avoid stranding.\n+    \/\/ StoreLoad achieves this.\n+    membar(StoreLoad);\n@@ -883,1 +841,1 @@\n-    jcc(Assembler::notZero, check_successor);\n+    jccb(Assembler::zero, unlocked);    \/\/ If so we are done.\n@@ -885,3 +843,13 @@\n-    \/\/ Release lock.\n-    movptr(owner_address, NULL_WORD);\n-    jmpb(unlocked);\n+    \/\/ Check if there is a successor.\n+    cmpptr(succ_address, NULL_WORD);\n+    jccb(Assembler::notZero, unlocked); \/\/ If so we are done.\n+\n+    \/\/ Save the monitor pointer in the current thread, so we can try to\n+    \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n+    if (!UseObjectMonitorTable) {\n+      andptr(monitor, ~(int32_t)markWord::monitor_value);\n+    }\n+    movptr(Address(thread, JavaThread::unlocked_inflated_monitor_offset()), monitor);\n+\n+    testl(monitor, monitor);            \/\/ Fast Unlock ZF = 0\n+    jmpb(slow_path);\n@@ -892,1 +860,0 @@\n-    xorl(t, t);\n@@ -896,3 +863,2 @@\n-  if (stub != nullptr) {\n-    bind(stub->unlocked_continuation());\n-  }\n+  decrement(Address(thread, JavaThread::held_monitor_count_offset()));\n+  xorl(t, t); \/\/ Fast Unlock ZF = 1\n@@ -907,0 +873,1 @@\n+  bind(slow_path);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":50,"deletions":83,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -41,1 +41,4 @@\n-#endif\n+#endif \/\/ COMPILER1\n+#ifdef COMPILER2\n+#include \"gc\/g1\/c2\/g1BarrierSetC2.hpp\"\n+#endif \/\/ COMPILER2\n@@ -163,0 +166,50 @@\n+static void generate_queue_insertion(MacroAssembler* masm, ByteSize index_offset, ByteSize buffer_offset, Label& runtime,\n+                                     const Register thread, const Register value, const Register temp) {\n+  \/\/ This code assumes that buffer index is pointer sized.\n+  STATIC_ASSERT(in_bytes(SATBMarkQueue::byte_width_of_index()) == sizeof(intptr_t));\n+  \/\/ Can we store a value in the given thread's buffer?\n+  \/\/ (The index field is typed as size_t.)\n+  __ movptr(temp, Address(thread, in_bytes(index_offset)));   \/\/ temp := *(index address)\n+  __ testptr(temp, temp);                                     \/\/ index == 0?\n+  __ jcc(Assembler::zero, runtime);                           \/\/ jump to runtime if index == 0 (full buffer)\n+  \/\/ The buffer is not full, store value into it.\n+  __ subptr(temp, wordSize);                                  \/\/ temp := next index\n+  __ movptr(Address(thread, in_bytes(index_offset)), temp);   \/\/ *(index address) := next index\n+  __ addptr(temp, Address(thread, in_bytes(buffer_offset)));  \/\/ temp := buffer address + next index\n+  __ movptr(Address(temp, 0), value);                         \/\/ *(buffer address + next index) := value\n+}\n+\n+static void generate_pre_barrier_fast_path(MacroAssembler* masm,\n+                                           const Register thread) {\n+  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n+  \/\/ Is marking active?\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    __ cmpl(in_progress, 0);\n+  } else {\n+    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n+    __ cmpb(in_progress, 0);\n+  }\n+}\n+\n+static void generate_pre_barrier_slow_path(MacroAssembler* masm,\n+                                           const Register obj,\n+                                           const Register pre_val,\n+                                           const Register thread,\n+                                           const Register tmp,\n+                                           Label& done,\n+                                           Label& runtime) {\n+  \/\/ Do we need to load the previous value?\n+  if (obj != noreg) {\n+    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n+  }\n+  \/\/ Is the previous value null?\n+  __ cmpptr(pre_val, NULL_WORD);\n+  __ jcc(Assembler::equal, done);\n+  generate_queue_insertion(masm,\n+                           G1ThreadLocalData::satb_mark_queue_index_offset(),\n+                           G1ThreadLocalData::satb_mark_queue_buffer_offset(),\n+                           runtime,\n+                           thread, pre_val, tmp);\n+  __ jmp(done);\n+}\n+\n@@ -188,20 +241,2 @@\n-  Address in_progress(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()));\n-  Address index(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset()));\n-\n-  \/\/ Is marking active?\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ cmpl(in_progress, 0);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ cmpb(in_progress, 0);\n-  }\n-  __ jcc(Assembler::equal, done);\n-\n-  \/\/ Do we need to load the previous value?\n-  if (obj != noreg) {\n-    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n-  }\n-\n-  \/\/ Is the previous value null?\n-  __ cmpptr(pre_val, NULL_WORD);\n+  generate_pre_barrier_fast_path(masm, thread);\n+  \/\/ If marking is not active (*(mark queue active address) == 0), jump to done\n@@ -209,15 +244,1 @@\n-\n-  \/\/ Can we store original value in the thread's buffer?\n-  \/\/ Is index == 0?\n-  \/\/ (The index field is typed as size_t.)\n-  __ movptr(tmp, index);                   \/\/ tmp := *index_adr\n-  __ cmpptr(tmp, 0);                       \/\/ tmp == 0?\n-  __ jcc(Assembler::equal, runtime);       \/\/ If yes, goto runtime\n-\n-  __ subptr(tmp, wordSize);                \/\/ tmp := tmp - wordSize\n-  __ movptr(index, tmp);                   \/\/ *index_adr := tmp\n-  __ addptr(tmp, buffer);                  \/\/ tmp := tmp + *buffer_adr\n-\n-  \/\/ Record the previous value\n-  __ movptr(Address(tmp, 0), pre_val);\n-  __ jmp(done);\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, done, runtime);\n@@ -295,0 +316,48 @@\n+static void generate_post_barrier_fast_path(MacroAssembler* masm,\n+                                            const Register store_addr,\n+                                            const Register new_val,\n+                                            const Register tmp,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            bool new_val_may_be_null) {\n+  CardTableBarrierSet* ct = barrier_set_cast<CardTableBarrierSet>(BarrierSet::barrier_set());\n+  \/\/ Does store cross heap regions?\n+  __ movptr(tmp, store_addr);                                    \/\/ tmp := store address\n+  __ xorptr(tmp, new_val);                                       \/\/ tmp := store address ^ new value\n+  __ shrptr(tmp, G1HeapRegion::LogOfHRGrainBytes);               \/\/ ((store address ^ new value) >> LogOfHRGrainBytes) == 0?\n+  __ jcc(Assembler::equal, done);\n+  \/\/ Crosses regions, storing null?\n+  if (new_val_may_be_null) {\n+    __ cmpptr(new_val, NULL_WORD);                               \/\/ new value == null?\n+    __ jcc(Assembler::equal, done);\n+  }\n+  \/\/ Storing region crossing non-null, is card young?\n+  __ movptr(tmp, store_addr);                                    \/\/ tmp := store address\n+  __ shrptr(tmp, CardTable::card_shift());                       \/\/ tmp := card address relative to card table base\n+  \/\/ Do not use ExternalAddress to load 'byte_map_base', since 'byte_map_base' is NOT\n+  \/\/ a valid address and therefore is not properly handled by the relocation code.\n+  __ movptr(tmp2, (intptr_t)ct->card_table()->byte_map_base());  \/\/ tmp2 := card table base address\n+  __ addptr(tmp, tmp2);                                          \/\/ tmp := card address\n+  __ cmpb(Address(tmp, 0), G1CardTable::g1_young_card_val());    \/\/ *(card address) == young_card_val?\n+}\n+\n+static void generate_post_barrier_slow_path(MacroAssembler* masm,\n+                                            const Register thread,\n+                                            const Register tmp,\n+                                            const Register tmp2,\n+                                            Label& done,\n+                                            Label& runtime) {\n+  __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));  \/\/ StoreLoad membar\n+  __ cmpb(Address(tmp, 0), G1CardTable::dirty_card_val());       \/\/ *(card address) == dirty_card_val?\n+  __ jcc(Assembler::equal, done);\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n+  \/\/ Dirty card and log.\n+  __ movb(Address(tmp, 0), G1CardTable::dirty_card_val());       \/\/ *(card address) := dirty_card_val\n+  generate_queue_insertion(masm,\n+                           G1ThreadLocalData::dirty_card_queue_index_offset(),\n+                           G1ThreadLocalData::dirty_card_queue_buffer_offset(),\n+                           runtime,\n+                           thread, tmp, tmp2);\n+  __ jmp(done);\n+}\n+\n@@ -305,6 +374,0 @@\n-  Address queue_index(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset()));\n-  Address buffer(thread, in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset()));\n-\n-  CardTableBarrierSet* ct =\n-    barrier_set_cast<CardTableBarrierSet>(BarrierSet::barrier_set());\n-\n@@ -314,5 +377,2 @@\n-  \/\/ Does store cross heap regions?\n-\n-  __ movptr(tmp, store_addr);\n-  __ xorptr(tmp, new_val);\n-  __ shrptr(tmp, G1HeapRegion::LogOfHRGrainBytes);\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp, tmp2, done, true \/* new_val_may_be_null *\/);\n+  \/\/ If card is young, jump to done\n@@ -320,42 +380,1 @@\n-\n-  \/\/ crosses regions, storing null?\n-\n-  __ cmpptr(new_val, NULL_WORD);\n-  __ jcc(Assembler::equal, done);\n-\n-  \/\/ storing region crossing non-null, is card already dirty?\n-\n-  const Register card_addr = tmp;\n-  const Register cardtable = tmp2;\n-\n-  __ movptr(card_addr, store_addr);\n-  __ shrptr(card_addr, CardTable::card_shift());\n-  \/\/ Do not use ExternalAddress to load 'byte_map_base', since 'byte_map_base' is NOT\n-  \/\/ a valid address and therefore is not properly handled by the relocation code.\n-  __ movptr(cardtable, (intptr_t)ct->card_table()->byte_map_base());\n-  __ addptr(card_addr, cardtable);\n-\n-  __ cmpb(Address(card_addr, 0), G1CardTable::g1_young_card_val());\n-  __ jcc(Assembler::equal, done);\n-\n-  __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));\n-  __ cmpb(Address(card_addr, 0), G1CardTable::dirty_card_val());\n-  __ jcc(Assembler::equal, done);\n-\n-\n-  \/\/ storing a region crossing, non-null oop, card is clean.\n-  \/\/ dirty card and log.\n-\n-  __ movb(Address(card_addr, 0), G1CardTable::dirty_card_val());\n-\n-  \/\/ The code below assumes that buffer index is pointer sized.\n-  STATIC_ASSERT(in_bytes(G1DirtyCardQueue::byte_width_of_index()) == sizeof(intptr_t));\n-\n-  __ movptr(tmp2, queue_index);\n-  __ testptr(tmp2, tmp2);\n-  __ jcc(Assembler::zero, runtime);\n-  __ subptr(tmp2, wordSize);\n-  __ movptr(queue_index, tmp2);\n-  __ addptr(tmp2, buffer);\n-  __ movptr(Address(tmp2, 0), card_addr);\n-  __ jmp(done);\n+  generate_post_barrier_slow_path(masm, thread, tmp, tmp2, done, runtime);\n@@ -378,7 +397,1 @@\n-#ifdef _LP64\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, r15_thread);\n-#else\n-  __ push(thread);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), card_addr, thread);\n-  __ pop(thread);\n-#endif\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), tmp, thread);\n@@ -401,0 +414,101 @@\n+#if defined(COMPILER2)\n+\n+static void generate_c2_barrier_runtime_call(MacroAssembler* masm, G1BarrierStubC2* stub, const Register arg, const address runtime_path) {\n+#ifdef _LP64\n+  SaveLiveRegisters save_registers(masm, stub);\n+  if (c_rarg0 != arg) {\n+    __ mov(c_rarg0, arg);\n+  }\n+  __ mov(c_rarg1, r15_thread);\n+  \/\/ rax is a caller-saved, non-argument-passing register, so it does not\n+  \/\/ interfere with c_rarg0 or c_rarg1. If it contained any live value before\n+  \/\/ entering this stub, it is saved at this point, and restored after the\n+  \/\/ call. If it did not contain any live value, it is free to be used. In\n+  \/\/ either case, it is safe to use it here as a call scratch register.\n+  __ call(RuntimeAddress(runtime_path), rax);\n+#else\n+  Unimplemented();\n+#endif \/\/ _LP64\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                                                    Register obj,\n+                                                    Register pre_val,\n+                                                    Register thread,\n+                                                    Register tmp,\n+                                                    G1PreBarrierStubC2* stub) {\n+#ifdef _LP64\n+  assert(thread == r15_thread, \"must be\");\n+#endif \/\/ _LP64\n+  assert(pre_val != noreg, \"check this code\");\n+  if (obj != noreg) {\n+    assert_different_registers(obj, pre_val, tmp);\n+  }\n+\n+  stub->initialize_registers(obj, pre_val, thread, tmp);\n+\n+  generate_pre_barrier_fast_path(masm, thread);\n+  \/\/ If marking is active (*(mark queue active address) != 0), jump to stub (slow path)\n+  __ jcc(Assembler::notEqual, *stub->entry());\n+\n+  __ bind(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                                         G1PreBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register obj = stub->obj();\n+  Register pre_val = stub->pre_val();\n+  Register thread = stub->thread();\n+  Register tmp = stub->tmp1();\n+  assert(stub->tmp2() == noreg, \"not needed in this platform\");\n+\n+  __ bind(*stub->entry());\n+  generate_pre_barrier_slow_path(masm, obj, pre_val, thread, tmp, *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, pre_val, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry));\n+  __ jmp(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                                     Register store_addr,\n+                                                     Register new_val,\n+                                                     Register thread,\n+                                                     Register tmp,\n+                                                     Register tmp2,\n+                                                     G1PostBarrierStubC2* stub) {\n+#ifdef _LP64\n+  assert(thread == r15_thread, \"must be\");\n+#endif \/\/ _LP64\n+\n+  stub->initialize_registers(thread, tmp, tmp2);\n+\n+  bool new_val_may_be_null = (stub->barrier_data() & G1C2BarrierPostNotNull) == 0;\n+  generate_post_barrier_fast_path(masm, store_addr, new_val, tmp, tmp2, *stub->continuation(), new_val_may_be_null);\n+  \/\/ If card is not young, jump to stub (slow path)\n+  __ jcc(Assembler::notEqual, *stub->entry());\n+\n+  __ bind(*stub->continuation());\n+}\n+\n+void G1BarrierSetAssembler::generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                                          G1PostBarrierStubC2* stub) const {\n+  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);\n+  Label runtime;\n+  Register thread = stub->thread();\n+  Register tmp = stub->tmp1(); \/\/ tmp holds the card address.\n+  Register tmp2 = stub->tmp2();\n+  assert(stub->tmp3() == noreg, \"not needed in this platform\");\n+\n+  __ bind(*stub->entry());\n+  generate_post_barrier_slow_path(masm, thread, tmp, tmp2, *stub->continuation(), runtime);\n+\n+  __ bind(runtime);\n+  generate_c2_barrier_runtime_call(masm, stub, tmp, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry));\n+  __ jmp(*stub->continuation());\n+}\n+\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":210,"deletions":96,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+class G1BarrierStubC2;\n+class G1PreBarrierStubC2;\n+class G1PostBarrierStubC2;\n@@ -68,0 +71,20 @@\n+\n+#ifdef COMPILER2\n+  void g1_write_barrier_pre_c2(MacroAssembler* masm,\n+                               Register obj,\n+                               Register pre_val,\n+                               Register thread,\n+                               Register tmp,\n+                               G1PreBarrierStubC2* c2_stub);\n+  void generate_c2_pre_barrier_stub(MacroAssembler* masm,\n+                                    G1PreBarrierStubC2* stub) const;\n+  void g1_write_barrier_post_c2(MacroAssembler* masm,\n+                                Register store_addr,\n+                                Register new_val,\n+                                Register thread,\n+                                Register tmp,\n+                                Register tmp2,\n+                                G1PostBarrierStubC2* c2_stub);\n+  void generate_c2_post_barrier_stub(MacroAssembler* masm,\n+                                     G1PostBarrierStubC2* stub) const;\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -6139,1 +6139,1 @@\n-    ExternalAddress src2(CompressedOops::ptrs_base_addr());\n+    ExternalAddress src2(CompressedOops::base_addr());\n@@ -6430,1 +6430,1 @@\n-        mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());\n+        mov64(r12_heapbase, (int64_t)CompressedOops::base());\n@@ -6433,1 +6433,1 @@\n-      movptr(r12_heapbase, ExternalAddress(CompressedOops::ptrs_base_addr()));\n+      movptr(r12_heapbase, ExternalAddress(CompressedOops::base_addr()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2951,1 +2951,1 @@\n-  if (EnableJVMCI && UseJVMCICompiler) {\n+  if (UseJVMCICompiler) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3592,0 +3592,3 @@\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dtanh)) {\n+      StubRoutines::_dtanh = generate_libmTanh(); \/\/ from stubGenerator_x86_64_tanh.cpp\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -379,5 +379,16 @@\n-  void generateHtbl_48_block_zmm(Register htbl, Register avx512_subkeyHtbl, Register rscratch);\n-  void ghash16_encrypt16_parallel(Register key, Register subkeyHtbl, XMMRegister ctr_blockx,\n-                                  XMMRegister aad_hashx, Register in, Register out, Register data, Register pos, bool reduction,\n-                                  XMMRegister addmask, bool no_ghash_input, Register rounds, Register ghash_pos,\n-                                  bool final_reduction, int index, XMMRegister counter_inc_mask);\n+  void ghash16_encrypt_parallel16_avx512(Register in, Register out, Register ct, Register pos, Register avx512_subkeyHtbl,\n+                                         Register CTR_CHECK, Register NROUNDS, Register key, XMMRegister CTR, XMMRegister GHASH,\n+                                         XMMRegister ADDBE_4x4, XMMRegister ADDBE_1234, XMMRegister ADD_1234, XMMRegister SHUF_MASK,\n+                                         bool hk_broadcast, bool is_hash_start, bool do_hash_reduction, bool do_hash_hxor,\n+                                         bool no_ghash_in, int ghashin_offset, int aesout_offset, int hashkey_offset);\n+  void generateHtbl_32_blocks_avx512(Register htbl, Register avx512_htbl);\n+  void initial_blocks_16_avx512(Register in, Register out, Register ct, Register pos, Register key, Register avx512_subkeyHtbl,\n+                                Register CTR_CHECK, Register rounds, XMMRegister CTR, XMMRegister GHASH,  XMMRegister ADDBE_4x4,\n+                                XMMRegister ADDBE_1234, XMMRegister ADD_1234, XMMRegister SHUF_MASK, int stack_offset);\n+  void gcm_enc_dec_last_avx512(Register len, Register in, Register pos, XMMRegister HASH, XMMRegister SHUFM, Register subkeyHtbl,\n+                               int ghashin_offset, int hashkey_offset, bool start_ghash, bool do_reduction);\n+  void ghash16_avx512(bool start_ghash, bool do_reduction, bool uload_shuffle, bool hk_broadcast, bool do_hxor,\n+                      Register in, Register pos, Register subkeyHtbl, XMMRegister HASH, XMMRegister SHUFM, int in_offset,\n+                      int in_disp, int displacement, int hashkey_offset);\n+  void aesgcm_avx512(Register in, Register len, Register ct, Register out, Register key,\n+                     Register state, Register subkeyHtbl, Register avx512_subkeyHtbl, Register counter);\n@@ -549,0 +560,1 @@\n+  address generate_libmTanh();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2460,0 +2460,4 @@\n+  if (is_encode_and_store_pattern(n, m)) {\n+    mstack.push(m, Visit);\n+    return true;\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4369,0 +4369,1 @@\n+   predicate(n->as_Load()->barrier_data() == 0);\n@@ -5154,0 +5155,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -5178,1 +5180,1 @@\n-  predicate(CompressedOops::base() == nullptr);\n+  predicate(CompressedOops::base() == nullptr && n->as_Store()->barrier_data() == 0);\n@@ -5191,0 +5193,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -7203,0 +7206,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -7290,0 +7294,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -7511,0 +7516,1 @@\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -11913,0 +11919,1 @@\n+  predicate(n->in(2)->as_Load()->barrier_data() == 0);\n@@ -11934,0 +11941,1 @@\n+  predicate(n->in(2)->as_Load()->barrier_data() == 0);\n@@ -11974,1 +11982,2 @@\n-  predicate(CompressedOops::base() != nullptr);\n+  predicate(CompressedOops::base() != nullptr &&\n+            n->in(1)->as_Load()->barrier_data() == 0);\n@@ -11987,1 +11996,2 @@\n-  predicate(CompressedOops::base() == nullptr);\n+  predicate(CompressedOops::base() == nullptr &&\n+            n->in(1)->as_Load()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4361,1 +4361,1 @@\n-    \"VectorRearrange\",\"VectorLoadShuffle\", \"VectorLoadConst\",\n+    \"VectorRearrange\", \"VectorLoadShuffle\", \"VectorLoadConst\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3615,0 +3615,1 @@\n+  case vmIntrinsics::_dtanh         : \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -1140,1 +1141,1 @@\n-  virtual const char * name() const PRODUCT_RETURN0;\n+  virtual const char * name() const PRODUCT_RETURN_NULL;\n@@ -1427,1 +1428,1 @@\n-  virtual const char * name() const PRODUCT_RETURN0;\n+  virtual const char * name() const PRODUCT_RETURN_NULL;\n@@ -2143,0 +2144,1 @@\n+    bool callee_is_private = _profiled_callee->is_loaded() && _profiled_callee->is_private();\n@@ -2144,1 +2146,1 @@\n-    bool call_is_virtual = (bc == Bytecodes::_invokevirtual && !_profiled_callee->can_be_statically_bound()) || bc == Bytecodes::_invokeinterface;\n+    bool call_is_virtual = (bc == Bytecodes::_invokevirtual && !callee_is_private) || bc == Bytecodes::_invokeinterface;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3456,0 +3456,1 @@\n+  case vmIntrinsics::_dtanh:          \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -360,0 +360,1 @@\n+  FUNCTION_CASE(entry, StubRoutines::dtanh());\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-    guarantee(UseG1GC, \"implementation limitation\");\n@@ -227,0 +226,1 @@\n+  int root_index = 0;\n@@ -239,1 +239,0 @@\n-    int root_index = 0;\n@@ -249,0 +248,2 @@\n+  assert(root_index == roots->length(), \"Post-condition: All roots are handled\");\n+\n@@ -252,0 +253,5 @@\n+\/\/ The goal is to sort the objects in increasing order of:\n+\/\/ - objects that have only oop pointers\n+\/\/ - objects that have both native and oop pointers\n+\/\/ - objects that have only native pointers\n+\/\/ - objects that have no pointers\n@@ -256,1 +262,1 @@\n-  if (!has_oop_ptr) {\n+  if (has_oop_ptr) {\n@@ -271,5 +277,0 @@\n-\/\/ The goal is to sort the objects in increasing order of:\n-\/\/ - objects that have no pointers\n-\/\/ - objects that have only native pointers\n-\/\/ - objects that have both native and oop pointers\n-\/\/ - objects that have only oop pointers\n@@ -455,3 +456,0 @@\n-  assert(UseG1GC, \"must be\");\n-  address heap_end = (address)G1CollectedHeap::heap()->reserved().end();\n-  log_info(cds, heap)(\"Heap end = %p\", heap_end);\n@@ -462,2 +460,9 @@\n-\n-    _requested_bottom = align_down(heap_end - heap_region_byte_size, G1HeapRegion::GrainBytes);\n+    if (UseG1GC) {\n+      address heap_end = (address)G1CollectedHeap::heap()->reserved().end();\n+      log_info(cds, heap)(\"Heap end = %p\", heap_end);\n+      _requested_bottom = align_down(heap_end - heap_region_byte_size, G1HeapRegion::GrainBytes);\n+      _requested_bottom = align_down(_requested_bottom, MIN_GC_REGION_ALIGNMENT);\n+      assert(is_aligned(_requested_bottom, G1HeapRegion::GrainBytes), \"sanity\");\n+    } else {\n+      _requested_bottom = align_up(CompressedOops::begin(), MIN_GC_REGION_ALIGNMENT);\n+    }\n@@ -471,1 +476,1 @@\n-    _requested_bottom = (address)NOCOOPS_REQUESTED_BASE;\n+    _requested_bottom = align_up((address)NOCOOPS_REQUESTED_BASE, MIN_GC_REGION_ALIGNMENT);\n@@ -474,1 +479,1 @@\n-  assert(is_aligned(_requested_bottom, G1HeapRegion::GrainBytes), \"sanity\");\n+  assert(is_aligned(_requested_bottom, MIN_GC_REGION_ALIGNMENT), \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-  if (Arguments::is_internal_module_property(key)) {\n+  if (Arguments::is_internal_module_property(key) && !Arguments::is_module_path_property(key)) {\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -511,1 +511,3 @@\n-  InstanceKlass* k = UnregisteredClasses::load_class(class_name, _source, CHECK_NULL);\n+  ResourceMark rm;\n+  char * source_path = os::strdup_check_oom(ClassLoader::uri_to_path(_source));\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path, CHECK_NULL);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -652,1 +652,1 @@\n-  const char* file = ClassLoader::skip_uri_protocol(location->as_C_string());\n+  const char* file = ClassLoader::uri_to_path(location->as_C_string());\n@@ -852,1 +852,1 @@\n-      return true;\n+      return false;\n@@ -857,1 +857,1 @@\n-  return false;\n+  return true;\n@@ -881,1 +881,1 @@\n-  bool mismatch = false;\n+  bool match = true;\n@@ -894,1 +894,1 @@\n-        mismatch = true;\n+        match = false;\n@@ -911,1 +911,1 @@\n-      mismatch = check_paths(1, num, rp_array, 0, 0);\n+      match = check_paths(1, num, rp_array, 0, 0);\n@@ -916,1 +916,1 @@\n-      mismatch = true;\n+      match = false;\n@@ -920,1 +920,1 @@\n-  if (mismatch) {\n+  if (!match) {\n@@ -931,1 +931,1 @@\n-  bool mismatch = false;\n+  bool match = false;\n@@ -960,2 +960,2 @@\n-    mismatch = check_paths(j, shared_app_paths_len, rp_array, 0, 0);\n-    if (mismatch) {\n+    match = check_paths(j, shared_app_paths_len, rp_array, 0, 0);\n+    if (!match) {\n@@ -972,1 +972,1 @@\n-        mismatch = check_paths(j, shared_app_paths_len, rp_array,\n+        match = check_paths(j, shared_app_paths_len, rp_array,\n@@ -975,1 +975,1 @@\n-      if (mismatch) {\n+      if (!match) {\n@@ -997,0 +997,11 @@\n+void FileMapInfo::extract_module_paths(const char* runtime_path, GrowableArray<const char*>* module_paths) {\n+  GrowableArray<const char*>* path_array = create_path_array(runtime_path);\n+  int num_paths = path_array->length();\n+  for (int i = 0; i < num_paths; i++) {\n+    const char* name = path_array->at(i);\n+    ClassLoaderExt::extract_jar_files_from_path(name, module_paths);\n+  }\n+  \/\/ module paths are stored in sorted order in the CDS archive.\n+  module_paths->sort(ClassLoaderExt::compare_module_path_by_name);\n+}\n+\n@@ -998,3 +1009,7 @@\n-  const char* rp = Arguments::get_property(\"jdk.module.path\");\n-  int num_paths = CDSConfig::num_archives(rp);\n-  if (num_paths != header()->num_module_paths()) {\n+  const char* runtime_path = Arguments::get_property(\"jdk.module.path\");\n+  int archived_num_module_paths = header()->num_module_paths();\n+  if (runtime_path == nullptr && archived_num_module_paths == 0) {\n+    return true;\n+  }\n+  if ((runtime_path == nullptr && archived_num_module_paths > 0) ||\n+      (runtime_path != nullptr && archived_num_module_paths == 0)) {\n@@ -1004,2 +1019,7 @@\n-  GrowableArray<const char*>* rp_array = create_path_array(rp);\n-  return check_paths(header()->app_module_paths_start_index(), num_paths, rp_array, 0, 0);\n+  GrowableArray<const char*>* module_paths = new GrowableArray<const char*>(3);\n+  extract_module_paths(runtime_path, module_paths);\n+  int num_paths = module_paths->length();\n+  if (num_paths != archived_num_module_paths) {\n+    return false;\n+  }\n+  return check_paths(header()->app_module_paths_start_index(), num_paths, module_paths, 0, 0);\n@@ -1015,0 +1035,10 @@\n+\n+  bool matched_module_paths = true;\n+  if (CDSConfig::is_dumping_dynamic_archive() || header()->has_full_module_graph()) {\n+    matched_module_paths = check_module_paths();\n+  }\n+  if (header()->has_full_module_graph() && !matched_module_paths) {\n+    CDSConfig::stop_using_optimized_module_handling();\n+    log_info(cds)(\"optimized module handling: disabled because of mismatched module paths\");\n+  }\n+\n@@ -1030,1 +1060,1 @@\n-      if (!check_module_paths()) {\n+      if (!matched_module_paths) {\n@@ -1656,5 +1686,6 @@\n-\/\/ The start of the archived heap has many primitive arrays (String\n-\/\/ bodies) that are not marked by the oop\/ptr maps. So we must have\n-\/\/ lots of leading zeros.\n-size_t FileMapInfo::remove_bitmap_leading_zeros(CHeapBitMap* map) {\n-  size_t old_zeros = map->find_first_set_bit(0);\n+\/\/ The sorting code groups the objects with non-null oop\/ptrs together.\n+\/\/ Relevant bitmaps then have lots of leading and trailing zeros, which\n+\/\/ we do not have to store.\n+size_t FileMapInfo::remove_bitmap_zeros(CHeapBitMap* map) {\n+  BitMap::idx_t first_set = map->find_first_set_bit(0);\n+  BitMap::idx_t last_set  = map->find_last_set_bit(0);\n@@ -1664,1 +1695,1 @@\n-  map->truncate(old_zeros, map->size());\n+  map->truncate(first_set, last_set + 1);\n@@ -1666,4 +1697,2 @@\n-  DEBUG_ONLY(\n-    size_t new_zeros = map->find_first_set_bit(0);\n-    assert(new_zeros == 0, \"Should have removed leading zeros\");\n-  )\n+  assert(map->at(0), \"First bit should be set\");\n+  assert(map->at(map->size() - 1), \"Last bit should be set\");\n@@ -1671,1 +1700,2 @@\n-  return old_zeros;\n+\n+  return first_set;\n@@ -1676,4 +1706,4 @@\n-  size_t removed_rw_zeros = remove_bitmap_leading_zeros(rw_ptrmap);\n-  size_t removed_ro_zeros = remove_bitmap_leading_zeros(ro_ptrmap);\n-  header()->set_rw_ptrmap_start_pos(removed_rw_zeros);\n-  header()->set_ro_ptrmap_start_pos(removed_ro_zeros);\n+  size_t removed_rw_leading_zeros = remove_bitmap_zeros(rw_ptrmap);\n+  size_t removed_ro_leading_zeros = remove_bitmap_zeros(ro_ptrmap);\n+  header()->set_rw_ptrmap_start_pos(removed_rw_leading_zeros);\n+  header()->set_ro_ptrmap_start_pos(removed_ro_leading_zeros);\n@@ -1683,6 +1713,5 @@\n-    \/\/ Remove leading zeros\n-    size_t removed_oop_zeros = remove_bitmap_leading_zeros(heap_info->oopmap());\n-    size_t removed_ptr_zeros = remove_bitmap_leading_zeros(heap_info->ptrmap());\n-\n-    header()->set_heap_oopmap_start_pos(removed_oop_zeros);\n-    header()->set_heap_ptrmap_start_pos(removed_ptr_zeros);\n+    \/\/ Remove leading and trailing zeros\n+    size_t removed_oop_leading_zeros = remove_bitmap_zeros(heap_info->oopmap());\n+    size_t removed_ptr_leading_zeros = remove_bitmap_zeros(heap_info->ptrmap());\n+    header()->set_heap_oopmap_start_pos(removed_oop_leading_zeros);\n+    header()->set_heap_ptrmap_start_pos(removed_ptr_leading_zeros);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":69,"deletions":40,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+  bool has_full_module_graph()             const { return _has_full_module_graph; }\n@@ -485,1 +486,1 @@\n-  size_t remove_bitmap_leading_zeros(CHeapBitMap* map);\n+  size_t remove_bitmap_zeros(CHeapBitMap* map);\n@@ -594,0 +595,1 @@\n+  void  extract_module_paths(const char* runtime_path, GrowableArray<const char*>* module_paths);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"classfile\/classLoaderExt.hpp\"\n@@ -58,0 +59,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -137,2 +139,1 @@\n-int HeapShared::_root_segment_max_size_shift;\n-int HeapShared::_root_segment_max_size_mask;\n+int HeapShared::_root_segment_max_size_elems;\n@@ -245,0 +246,16 @@\n+void HeapShared::get_segment_indexes(int idx, int& seg_idx, int& int_idx) {\n+  assert(_root_segment_max_size_elems > 0, \"sanity\");\n+\n+  \/\/ Try to avoid divisions for the common case.\n+  if (idx < _root_segment_max_size_elems) {\n+    seg_idx = 0;\n+    int_idx = idx;\n+  } else {\n+    seg_idx = idx \/ _root_segment_max_size_elems;\n+    int_idx = idx % _root_segment_max_size_elems;\n+  }\n+\n+  assert(idx == seg_idx * _root_segment_max_size_elems + int_idx,\n+         \"sanity: %d index maps to %d segment and %d internal\", idx, seg_idx, int_idx);\n+}\n+\n@@ -247,2 +264,0 @@\n-  assert(_root_segment_max_size_shift > 0, \"sanity\");\n-  assert(_root_segment_max_size_mask  > 0, \"sanity\");\n@@ -252,2 +267,2 @@\n-  int seg_idx = index >> _root_segment_max_size_shift;\n-  int int_idx = index &  _root_segment_max_size_mask;\n+  int seg_idx, int_idx;\n+  get_segment_indexes(index, seg_idx, int_idx);\n@@ -265,4 +280,2 @@\n-    assert(_root_segment_max_size_shift > 0, \"sanity\");\n-    assert(_root_segment_max_size_mask  > 0, \"sanity\");\n-    int seg_idx = index >> _root_segment_max_size_shift;\n-    int int_idx = index &  _root_segment_max_size_mask;\n+    int seg_idx, int_idx;\n+    get_segment_indexes(index, seg_idx, int_idx);\n@@ -474,5 +487,7 @@\n-    log_info(cds)(\"Heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n-                   UseCompressedOops ? p2i(CompressedOops::begin()) :\n-                                       p2i((address)G1CollectedHeap::heap()->reserved().start()),\n-                   UseCompressedOops ? p2i(CompressedOops::end()) :\n-                                       p2i((address)G1CollectedHeap::heap()->reserved().end()));\n+    if (UseCompressedOops || UseG1GC) {\n+      log_info(cds)(\"Heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+                    UseCompressedOops ? p2i(CompressedOops::begin()) :\n+                                        p2i((address)G1CollectedHeap::heap()->reserved().start()),\n+                    UseCompressedOops ? p2i(CompressedOops::end()) :\n+                                        p2i((address)G1CollectedHeap::heap()->reserved().end()));\n+    }\n@@ -786,4 +801,2 @@\n-void HeapShared::init_root_segment_sizes(int max_size) {\n-  assert(is_power_of_2(max_size), \"must be\");\n-  _root_segment_max_size_shift = log2i_exact(max_size);\n-  _root_segment_max_size_mask = max_size - 1;\n+void HeapShared::init_root_segment_sizes(int max_size_elems) {\n+  _root_segment_max_size_elems = max_size_elems;\n@@ -876,0 +889,11 @@\n+  if (k->name()->equals(\"jdk\/internal\/module\/ArchivedModuleGraph\") &&\n+      !CDSConfig::is_using_optimized_module_handling() &&\n+      \/\/ archive was created with --module-path\n+      ClassLoaderExt::num_module_paths() > 0) {\n+    \/\/ ArchivedModuleGraph was created with a --module-path that's different than the runtime --module-path.\n+    \/\/ Thus, it might contain references to modules that do not exist at runtime. We cannot use it.\n+    log_info(cds, heap)(\"Skip initializing ArchivedModuleGraph subgraph: is_using_optimized_module_handling=%s num_module_paths=%d\",\n+                        BOOL_TO_STR(CDSConfig::is_using_optimized_module_handling()), ClassLoaderExt::num_module_paths());\n+    return;\n+  }\n+\n@@ -1124,0 +1148,7 @@\n+    if (log_is_enabled(Trace, cds, heap)) {\n+      WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n+      if (walker != nullptr) {\n+        LogStream ls(Log(cds, heap)::trace());\n+        CDSHeapVerifier::trace_to_root(&ls, walker->referencing_obj());\n+      }\n+    }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":50,"deletions":19,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -305,0 +306,1 @@\n+        ClassLoaderExt::init_num_module_paths(info->header()->num_module_paths());\n@@ -796,0 +798,3 @@\n+  } else {\n+    log_info(cds)(\"Not dumping heap, reset CDSConfig::_is_using_optimized_module_handling\");\n+    CDSConfig::stop_using_optimized_module_handling();\n@@ -799,0 +804,10 @@\n+  \/\/ Dummy call to load classes used at CDS runtime\n+  JavaValue result(T_OBJECT);\n+  Handle path_string = java_lang_String::create_from_str(\"dummy.jar\", CHECK);\n+  JavaCalls::call_static(&result,\n+                         vmClasses::jdk_internal_loader_ClassLoaders_klass(),\n+                         vmSymbols::toFileURL_name(),\n+                         vmSymbols::toFileURL_signature(),\n+                         path_string,\n+                         CHECK);\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1625,1 +1625,4 @@\n-  dump_compile_data(out);\n+\n+  if (this->task() != nullptr) {\n+    dump_compile_data(out);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1158,2 +1158,3 @@\n-      assert(count <= 2, \"change this if more element-value pairs are added to the @Deprecated annotation\");\n-      \/\/ @Deprecated can specify forRemoval=true\n+      \/\/ @Deprecated can specify forRemoval=true, which we need\n+      \/\/ to record for JFR to use. If the annotation is not well-formed\n+      \/\/ then we may not be able to determine that.\n@@ -1161,1 +1162,3 @@\n-      for (int i = 0; i < count; ++i) {\n+      \/\/ There are only 2 members in @Deprecated.\n+      int n_members = MIN2(count, 2);\n+      for (int i = 0; i < n_members; ++i) {\n@@ -1165,2 +1168,3 @@\n-        if (member == vmSymbols::since()) {\n-          assert(*((address)offset) == s_tag_val, \"invariant\");\n+        if (member == vmSymbols::since() &&\n+            (*((address)offset) == s_tag_val)) {\n+          \/\/ Found `since` first so skip over it\n@@ -1168,3 +1172,2 @@\n-          continue;\n-        if (member == vmSymbols::for_removal()) {\n-          assert(*((address)offset) == b_tag_val, \"invariant\");\n+        else if (member == vmSymbols::for_removal() &&\n+                 (*((address)offset) == b_tag_val)) {\n@@ -1173,1 +1176,4 @@\n-          if (cp->int_at(boolean_value_index) == 1) {\n+          \/\/ No guarantee the entry is valid so check it refers to an int in the CP.\n+          if (cp->is_within_bounds(boolean_value_index) &&\n+              cp->tag_at(boolean_value_index).is_int() &&\n+              cp->int_at(boolean_value_index) == 1) {\n@@ -1177,0 +1183,5 @@\n+          break; \/\/ no need to check further\n+        }\n+        else {\n+          \/\/ This @Deprecated annotation is malformed so we don't try to\n+          \/\/ determine whether forRemoval is set.\n@@ -1179,2 +1190,1 @@\n-\n-      continue;\n+      continue; \/\/ proceed to next annotation\n@@ -1202,2 +1212,11 @@\n-        if (cp->symbol_at(group_index)->utf8_length() == 0) {\n-          group_index = 0; \/\/ default contended group\n+        \/\/ No guarantee the group_index is valid so check it refers to a\n+        \/\/ symbol in the CP.\n+        if (cp->is_within_bounds(group_index) &&\n+            cp->tag_at(group_index).is_utf8()) {\n+          \/\/ Seems valid, so check for empty string and reset\n+          if (cp->symbol_at(group_index)->utf8_length() == 0) {\n+            group_index = 0; \/\/ default contended group\n+          }\n+        } else {\n+          \/\/ Not valid so use the default\n+          group_index = 0;\n@@ -1207,0 +1226,1 @@\n+      continue; \/\/ proceed to next annotation\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":33,"deletions":13,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -84,0 +84,3 @@\n+#include <stdlib.h>\n+#include <ctype.h>\n+\n@@ -582,0 +585,2 @@\n+    \/\/ ClassLoaderExt::process_module_table() filters out non-jar entries before calling this function.\n+    assert(new_entry->is_jar_file(), \"module path entry %s is not a jar file\", new_entry->name());\n@@ -1231,1 +1236,1 @@\n-char* ClassLoader::skip_uri_protocol(char* source) {\n+static const char* skip_uri_protocol(const char* source) {\n@@ -1250,0 +1255,41 @@\n+static char decode_percent_encoded(const char *str, size_t& index) {\n+  if (str[index] == '%'\n+      && isxdigit(str[index + 1])\n+      && isxdigit(str[index + 2])) {\n+    char hex[3];\n+    hex[0] = str[index + 1];\n+    hex[1] = str[index + 2];\n+    hex[2] = '\\0';\n+    index += 2;\n+    return (char) strtol(hex, NULL, 16);\n+  }\n+  return str[index];\n+}\n+\n+char* ClassLoader::uri_to_path(const char* uri) {\n+  const size_t len = strlen(uri) + 1;\n+  char* path = NEW_RESOURCE_ARRAY(char, len);\n+\n+  uri = skip_uri_protocol(uri);\n+\n+  if (strncmp(uri, \"\/\/\", 2) == 0) {\n+    \/\/ Skip the empty \"authority\" part\n+    uri += 2;\n+  }\n+\n+#ifdef _WINDOWS\n+  if (uri[0] == '\/') {\n+    \/\/ Absolute path name on Windows does not begin with a slash\n+    uri += 1;\n+  }\n+#endif\n+\n+  size_t path_index = 0;\n+  for (size_t i = 0; i < strlen(uri); ++i) {\n+    char decoded = decode_percent_encoded(uri, i);\n+    path[path_index++] = decoded;\n+  }\n+  path[path_index] = '\\0';\n+  return path;\n+}\n+\n@@ -1287,1 +1333,1 @@\n-    char* path = skip_uri_protocol(src);\n+    const char* path = ClassLoader::uri_to_path(src);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3076,0 +3076,1 @@\n+    \/\/ Note: Static initializers can be here. Record them as plain methods.\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1075,1 +1075,1 @@\n-                                                    class_loader, protection_domain, is_superclass, CHECK_0);\n+                                                    class_loader, protection_domain, is_superclass, CHECK_false);\n@@ -1094,4 +1094,7 @@\n-  if (ik->super() != nullptr &&\n-      !check_shared_class_super_type(ik, InstanceKlass::cast(ik->super()),\n-                                     class_loader, protection_domain, true, THREAD)) {\n-    return false;\n+  if (ik->super() != nullptr) {\n+    bool check_super = check_shared_class_super_type(ik, InstanceKlass::cast(ik->super()),\n+                                                     class_loader, protection_domain, true,\n+                                                     CHECK_false);\n+    if (!check_super) {\n+      return false;\n+    }\n@@ -1103,1 +1106,3 @@\n-    if (!check_shared_class_super_type(ik, interfaces->at(index), class_loader, protection_domain, false, THREAD)) {\n+    bool check_interface = check_shared_class_super_type(ik, interfaces->at(index), class_loader, protection_domain, false,\n+                                                         CHECK_false);\n+    if (!check_interface) {\n@@ -1155,0 +1160,1 @@\n+    ik->set_shared_loading_failed();\n@@ -1158,1 +1164,3 @@\n-  if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {\n+  bool check = check_shared_class_super_types(ik, class_loader, protection_domain, CHECK_NULL);\n+  if (!check) {\n+    ik->set_shared_loading_failed();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -299,7 +299,0 @@\n-protected:\n-  static InstanceKlass* _well_known_klasses[];\n-\n-private:\n-  \/\/ table of box klasses (int_klass, etc.)\n-  static InstanceKlass* _box_klasses[T_VOID+1];\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+  case vmIntrinsics::_dtanh:\n@@ -144,0 +145,1 @@\n+  case vmIntrinsics::_dtanh:\n@@ -292,0 +294,1 @@\n+  case vmIntrinsics::_dtanh:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  do_name(round_name, \"round\")                                                                                          \\\n+  do_name(round_name, \"round\")  do_name(tanh_name,\"tanh\")                                                               \\\n@@ -164,0 +164,1 @@\n+  do_intrinsic(_dtanh,                    java_lang_Math,         tanh_name,   double_double_signature,          F_S)   \\\n@@ -1025,0 +1026,9 @@\n+  do_intrinsic(_VectorWrapShuffleIndexes, jdk_internal_vm_vector_VectorSupport, vector_wrap_shuffle_indexes_name,                              \\\n+                                                                                                         vector_wrap_shuffle_indexes_sig, F_S) \\\n+   do_signature(vector_wrap_shuffle_indexes_sig, \"(Ljava\/lang\/Class;\"                                                                          \\\n+                                                  \"Ljava\/lang\/Class;\"                                                                          \\\n+                                                  \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\"                                       \\\n+                                                  \"ILjdk\/internal\/vm\/vector\/VectorSupport$WrapShuffleIndexesOperation;)\"                       \\\n+                                                  \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\")                                      \\\n+   do_name(vector_wrap_shuffle_indexes_name, \"wrapShuffleIndexes\")                                                                             \\\n+                                                                                                                                               \\\n@@ -1146,0 +1156,12 @@\n+  do_intrinsic(_VectorSelectFrom, jdk_internal_vm_vector_VectorSupport, vector_select_from_name, vector_select_from_sig, F_S)                  \\\n+   do_signature(vector_select_from_sig, \"(Ljava\/lang\/Class;\"                                                                                   \\\n+                                        \"Ljava\/lang\/Class;\"                                                                                     \\\n+                                        \"Ljava\/lang\/Class;\"                                                                                     \\\n+                                        \"I\"                                                                                                     \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                         \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                         \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;\"                                                     \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSelectFromOp;)\"                                            \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                        \\\n+   do_name(vector_select_from_name, \"selectFromOp\")                                                                                              \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+    assert(call_info->resolved_method() != nullptr, \"virtual or interface method must be found\");\n@@ -241,0 +242,1 @@\n+    assert(call_info->resolved_method() != nullptr, \"virtual or interface method must be found\");\n@@ -257,0 +259,1 @@\n+  assert(call_info->selected_method() != nullptr, \"virtual or interface method must be found\");\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"code\/vmreg.inline.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"gc\/g1\/g1BarrierSetAssembler.hpp\"\n@@ -34,0 +36,1 @@\n+#include \"opto\/block.hpp\"\n@@ -38,0 +41,1 @@\n+#include \"opto\/machnode.hpp\"\n@@ -39,0 +43,4 @@\n+#include \"opto\/memnode.hpp\"\n+#include \"opto\/node.hpp\"\n+#include \"opto\/output.hpp\"\n+#include \"opto\/regalloc.hpp\"\n@@ -40,0 +48,1 @@\n+#include \"opto\/runtime.hpp\"\n@@ -41,0 +50,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -43,27 +53,0 @@\n-const TypeFunc *G1BarrierSetC2::write_ref_field_pre_entry_Type() {\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; \/\/ original field value\n-  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; \/\/ thread\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n-\n-  \/\/ create result type (range)\n-  fields = TypeTuple::fields(0);\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);\n-\n-  return TypeFunc::make(domain, range);\n-}\n-\n-const TypeFunc *G1BarrierSetC2::write_ref_field_post_entry_Type() {\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL;  \/\/ Card addr\n-  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL;  \/\/ thread\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n-\n-  \/\/ create result type (range)\n-  fields = TypeTuple::fields(0);\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);\n-\n-  return TypeFunc::make(domain, range);\n-}\n-\n-#define __ ideal.\n@@ -87,2 +70,0 @@\n- *\n- * Returns true if the pre-barrier can be removed\n@@ -100,1 +81,1 @@\n-    return false; \/\/ cannot unalias unless there are precise offsets\n+    return false; \/\/ Cannot unalias unless there are precise offsets.\n@@ -102,2 +83,1 @@\n-\n-    return false; \/\/ No allocation found\n+    return false; \/\/ No allocation found.\n@@ -108,2 +88,1 @@\n-\n-  Node* mem = kit->memory(adr_idx); \/\/ start searching here...\n+  Node* mem = kit->memory(adr_idx); \/\/ Start searching here.\n@@ -112,2 +91,0 @@\n-\n-\n@@ -120,1 +97,1 @@\n-        break; \/\/ inscrutable pointer\n+        break; \/\/ Inscrutable pointer.\n@@ -122,2 +99,1 @@\n-\n-      \/\/ Break we have found a store with same base and offset as ours so break\n+        \/\/ We have found a store with same base and offset as ours.\n@@ -127,1 +103,0 @@\n-\n@@ -139,1 +114,1 @@\n-          continue; \/\/ advance through independent store memory\n+          continue; \/\/ Advance through independent store memory.\n@@ -142,1 +117,0 @@\n-\n@@ -147,1 +121,1 @@\n-        \/\/ Success:  The bases are provably independent.\n+        \/\/ Success: the bases are provably independent.\n@@ -149,1 +123,1 @@\n-        continue; \/\/ advance through independent store memory\n+        continue; \/\/ Advance through independent store memory.\n@@ -152,1 +126,0 @@\n-\n@@ -160,1 +133,1 @@\n-        \/\/ has been moved up and directly write a reference\n+        \/\/ has been moved up and directly write a reference.\n@@ -169,1 +142,0 @@\n-\n@@ -174,1 +146,0 @@\n-\n@@ -178,104 +149,2 @@\n-\/\/ G1 pre\/post barriers\n-void G1BarrierSetC2::pre_barrier(GraphKit* kit,\n-                                 bool do_load,\n-                                 Node* ctl,\n-                                 Node* obj,\n-                                 Node* adr,\n-                                 uint alias_idx,\n-                                 Node* val,\n-                                 const TypeOopPtr* val_type,\n-                                 Node* pre_val,\n-                                 BasicType bt) const {\n-  \/\/ Some sanity checks\n-  \/\/ Note: val is unused in this routine.\n-\n-  if (do_load) {\n-    \/\/ We need to generate the load of the previous value\n-    assert(obj != nullptr, \"must have a base\");\n-    assert(adr != nullptr, \"where are loading from?\");\n-    assert(pre_val == nullptr, \"loaded already?\");\n-    assert(val_type != nullptr, \"need a type\");\n-\n-    if (use_ReduceInitialCardMarks()\n-        && g1_can_remove_pre_barrier(kit, &kit->gvn(), adr, bt, alias_idx)) {\n-      return;\n-    }\n-\n-  } else {\n-    \/\/ In this case both val_type and alias_idx are unused.\n-    assert(pre_val != nullptr, \"must be loaded already\");\n-    \/\/ Nothing to be done if pre_val is null.\n-    if (pre_val->bottom_type() == TypePtr::NULL_PTR) return;\n-    assert(pre_val->bottom_type()->basic_type() == T_OBJECT, \"or we shouldn't be here\");\n-  }\n-  assert(bt == T_OBJECT, \"or we shouldn't be here\");\n-\n-  IdealKit ideal(kit, true);\n-\n-  Node* tls = __ thread(); \/\/ ThreadLocalStorage\n-\n-  Node* no_base = __ top();\n-  Node* zero  = __ ConI(0);\n-  Node* zeroX = __ ConX(0);\n-\n-  float likely  = PROB_LIKELY(0.999);\n-  float unlikely  = PROB_UNLIKELY(0.999);\n-\n-  BasicType active_type = in_bytes(SATBMarkQueue::byte_width_of_active()) == 4 ? T_INT : T_BYTE;\n-  assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 4 || in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"flag width\");\n-\n-  \/\/ Offsets into the thread\n-  const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-  const int index_offset   = in_bytes(G1ThreadLocalData::satb_mark_queue_index_offset());\n-  const int buffer_offset  = in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset());\n-\n-  \/\/ Now the actual pointers into the thread\n-  Node* marking_adr = __ AddP(no_base, tls, __ ConX(marking_offset));\n-  Node* buffer_adr  = __ AddP(no_base, tls, __ ConX(buffer_offset));\n-  Node* index_adr   = __ AddP(no_base, tls, __ ConX(index_offset));\n-\n-  \/\/ Now some of the values\n-  Node* marking = __ load(__ ctrl(), marking_adr, TypeInt::INT, active_type, Compile::AliasIdxRaw);\n-\n-  \/\/ if (!marking)\n-  __ if_then(marking, BoolTest::ne, zero, unlikely); {\n-    BasicType index_bt = TypeX_X->basic_type();\n-    assert(sizeof(size_t) == type2aelembytes(index_bt), \"Loading G1 SATBMarkQueue::_index with wrong size.\");\n-    Node* index   = __ load(__ ctrl(), index_adr, TypeX_X, index_bt, Compile::AliasIdxRaw);\n-\n-    if (do_load) {\n-      \/\/ load original value\n-      pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx, false, MemNode::unordered, LoadNode::Pinned);\n-    }\n-\n-    \/\/ if (pre_val != nullptr)\n-    __ if_then(pre_val, BoolTest::ne, kit->null()); {\n-      Node* buffer  = __ load(__ ctrl(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);\n-\n-      \/\/ is the queue for this thread full?\n-      __ if_then(index, BoolTest::ne, zeroX, likely); {\n-\n-        \/\/ decrement the index\n-        Node* next_index = kit->gvn().transform(new SubXNode(index, __ ConX(sizeof(intptr_t))));\n-\n-        \/\/ Now get the buffer location we will log the previous value into and store it\n-        Node *log_addr = __ AddP(no_base, buffer, next_index);\n-        __ store(__ ctrl(), log_addr, pre_val, T_OBJECT, Compile::AliasIdxRaw, MemNode::unordered);\n-        \/\/ update the index\n-        __ store(__ ctrl(), index_adr, next_index, index_bt, Compile::AliasIdxRaw, MemNode::unordered);\n-\n-      } __ else_(); {\n-\n-        \/\/ logging buffer is full, call the runtime\n-        const TypeFunc *tf = write_ref_field_pre_entry_Type();\n-        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_pre_entry), \"write_ref_field_pre_entry\", pre_val, tls);\n-      } __ end_if();  \/\/ (!index)\n-    } __ end_if();  \/\/ (pre_val != nullptr)\n-  } __ end_if();  \/\/ (!marking)\n-\n-  \/\/ Final sync IdealKit and GraphKit.\n-  kit->final_sync(ideal);\n-}\n-\n- * G1 similar to any GC with a Young Generation requires a way to keep track of\n- * references from Old Generation to Young Generation to make sure all live\n+ * G1, similar to any GC with a Young Generation, requires a way to keep track\n+ * of references from Old Generation to Young Generation to make sure all live\n@@ -285,3 +154,3 @@\n- * as part of mixed collections. References are tracked in remembered sets and\n- * is continuously updated as reference are written to with the help of the\n- * post-barrier.\n+ * as part of mixed collections. References are tracked in remembered sets,\n+ * which are continuously updated as references are written to with the help of\n+ * the post-barrier.\n@@ -289,4 +158,4 @@\n- * To reduce the number of updates to the remembered set the post-barrier\n- * filters updates to fields in objects located in the Young Generation,\n- * the same region as the reference, when the null is being written or\n- * if the card is already marked as dirty by an earlier write.\n+ * To reduce the number of updates to the remembered set, the post-barrier\n+ * filters out updates to fields in objects located in the Young Generation, the\n+ * same region as the reference, when null is being written, or if the card is\n+ * already marked as dirty by an earlier write.\n@@ -295,7 +164,4 @@\n- * post-barrier completely if it is possible during compile time to prove\n- * the object is newly allocated and that no safepoint exists between the\n- * allocation and the store.\n- *\n- * In the case of slow allocation the allocation code must handle the barrier\n- * as part of the allocation in the case the allocated object is not located\n- * in the nursery; this would happen for humongous objects.\n+ * post-barrier completely, if it is possible during compile time to prove the\n+ * object is newly allocated and that no safepoint exists between the allocation\n+ * and the store. This can be seen as a compile-time version of the\n+ * above-mentioned Young Generation filter.\n@@ -303,1 +169,3 @@\n- * Returns true if the post barrier can be removed\n+ * In the case of a slow allocation, the allocation code must handle the barrier\n+ * as part of the allocation if the allocated object is not located in the\n+ * nursery; this would happen for humongous objects.\n@@ -306,1 +174,1 @@\n-                                                PhaseValues* phase, Node* store,\n+                                                PhaseValues* phase, Node* store_ctrl,\n@@ -313,1 +181,1 @@\n-    return false; \/\/ cannot unalias unless there are precise offsets\n+    return false; \/\/ Cannot unalias unless there are precise offsets.\n@@ -315,2 +183,1 @@\n-\n-     return false; \/\/ No allocation found\n+    return false; \/\/ No allocation found.\n@@ -320,2 +187,1 @@\n-  \/\/ Start search from Store node\n-  Node* mem = store->in(MemNode::Control);\n+  Node* mem = store_ctrl;   \/\/ Start search from Store node.\n@@ -323,1 +189,0 @@\n-\n@@ -326,1 +191,0 @@\n-\n@@ -336,33 +200,14 @@\n-\/\/\n-\/\/ Update the card table and add card address to the queue\n-\/\/\n-void G1BarrierSetC2::g1_mark_card(GraphKit* kit,\n-                                  IdealKit& ideal,\n-                                  Node* card_adr,\n-                                  Node* oop_store,\n-                                  uint oop_alias_idx,\n-                                  Node* index,\n-                                  Node* index_adr,\n-                                  Node* buffer,\n-                                  const TypeFunc* tf) const {\n-  Node* zero  = __ ConI(0);\n-  Node* zeroX = __ ConX(0);\n-  Node* no_base = __ top();\n-  BasicType card_bt = T_BYTE;\n-  \/\/ Smash zero into card. MUST BE ORDERED WRT TO STORE\n-  __ storeCM(__ ctrl(), card_adr, zero, oop_store, oop_alias_idx, card_bt, Compile::AliasIdxRaw);\n-\n-  \/\/  Now do the queue work\n-  __ if_then(index, BoolTest::ne, zeroX); {\n-\n-    Node* next_index = kit->gvn().transform(new SubXNode(index, __ ConX(sizeof(intptr_t))));\n-    Node* log_addr = __ AddP(no_base, buffer, next_index);\n-\n-    \/\/ Order, see storeCM.\n-    __ store(__ ctrl(), log_addr, card_adr, T_ADDRESS, Compile::AliasIdxRaw, MemNode::unordered);\n-    __ store(__ ctrl(), index_adr, next_index, TypeX_X->basic_type(), Compile::AliasIdxRaw, MemNode::unordered);\n-\n-  } __ else_(); {\n-    __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry), \"write_ref_field_post_entry\", card_adr, __ thread());\n-  } __ end_if();\n-\n+Node* G1BarrierSetC2::load_at_resolved(C2Access& access, const Type* val_type) const {\n+  DecoratorSet decorators = access.decorators();\n+  bool on_weak = (decorators & ON_WEAK_OOP_REF) != 0;\n+  bool on_phantom = (decorators & ON_PHANTOM_OOP_REF) != 0;\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n+  \/\/ If we are reading the value of the referent field of a Reference object, we\n+  \/\/ need to record the referent in an SATB log buffer using the pre-barrier\n+  \/\/ mechanism. Also we need to add a memory barrier to prevent commoning reads\n+  \/\/ from this field across safepoints, since GC can change its value.\n+  bool need_read_barrier = ((on_weak || on_phantom) && !no_keepalive);\n+  if (access.is_oop() && need_read_barrier) {\n+    access.set_barrier_data(G1C2BarrierPre);\n+  }\n+  return CardTableBarrierSetC2::load_at_resolved(access, val_type);\n@@ -371,10 +216,12 @@\n-void G1BarrierSetC2::post_barrier(GraphKit* kit,\n-                                  Node* ctl,\n-                                  Node* oop_store,\n-                                  Node* obj,\n-                                  Node* adr,\n-                                  uint alias_idx,\n-                                  Node* val,\n-                                  BasicType bt,\n-                                  bool use_precise) const {\n-  \/\/ If we are writing a null then we need no post barrier\n+void G1BarrierSetC2::eliminate_gc_barrier(PhaseIterGVN* igvn, Node* node) const {\n+  eliminate_gc_barrier_data(node);\n+}\n+void G1BarrierSetC2::eliminate_gc_barrier_data(Node* node) const {\n+  if (node->is_LoadStore()) {\n+    LoadStoreNode* loadstore = node->as_LoadStore();\n+    loadstore->set_barrier_data(0);\n+  } else if (node->is_Mem()) {\n+    MemNode* mem = node->as_Mem();\n+    mem->set_barrier_data(0);\n+  }\n+}\n@@ -382,5 +229,3 @@\n-  if (val != nullptr && val->is_Con() && val->bottom_type() == TypePtr::NULL_PTR) {\n-    \/\/ Must be null\n-    const Type* t = val->bottom_type();\n-    assert(t == Type::TOP || t == TypePtr::NULL_PTR, \"must be null\");\n-    \/\/ No post barrier if writing null\n+static void refine_barrier_by_new_val_type(const Node* n) {\n+  if (n->Opcode() != Op_StoreP &&\n+      n->Opcode() != Op_StoreN) {\n@@ -389,7 +234,11 @@\n-\n-  if (use_ReduceInitialCardMarks() && obj == kit->just_allocated_object(kit->control())) {\n-    \/\/ We can skip marks on a freshly-allocated object in Eden.\n-    \/\/ Keep this code in sync with CardTableBarrierSet::on_slowpath_allocation_exit.\n-    \/\/ That routine informs GC to take appropriate compensating steps,\n-    \/\/ upon a slow-path allocation, so as to make this card-mark\n-    \/\/ elision safe.\n+  MemNode* store = n->as_Mem();\n+  const Node* newval = n->in(MemNode::ValueIn);\n+  assert(newval != nullptr, \"\");\n+  const Type* newval_bottom = newval->bottom_type();\n+  TypePtr::PTR newval_type = newval_bottom->make_ptr()->ptr();\n+  uint8_t barrier_data = store->barrier_data();\n+  if (!newval_bottom->isa_oopptr() &&\n+      !newval_bottom->isa_narrowoop() &&\n+      newval_type != TypePtr::Null) {\n+    \/\/ newval is neither an OOP nor null, so there is no barrier to refine.\n+    assert(barrier_data == 0, \"non-OOP stores should have no barrier data\");\n@@ -398,3 +247,2 @@\n-\n-  if (use_ReduceInitialCardMarks()\n-      && g1_can_remove_post_barrier(kit, &kit->gvn(), oop_store, adr)) {\n+  if (barrier_data == 0) {\n+    \/\/ No barrier to refine.\n@@ -403,4 +251,10 @@\n-\n-  if (!use_precise) {\n-    \/\/ All card marks for a (non-array) instance are in one place:\n-    adr = obj;\n+  if (newval_type == TypePtr::Null) {\n+    \/\/ Simply elide post-barrier if writing null.\n+    barrier_data &= ~G1C2BarrierPost;\n+    barrier_data &= ~G1C2BarrierPostNotNull;\n+  } else if (((barrier_data & G1C2BarrierPost) != 0) &&\n+             newval_type == TypePtr::NotNull) {\n+    \/\/ If the post-barrier has not been elided yet (e.g. due to newval being\n+    \/\/ freshly allocated), mark it as not-null (simplifies barrier tests and\n+    \/\/ compressed OOPs logic).\n+    barrier_data |= G1C2BarrierPostNotNull;\n@@ -408,88 +262,2 @@\n-  \/\/ (Else it's an array (or unknown), and we want more precise card marks.)\n-  assert(adr != nullptr, \"\");\n-\n-  IdealKit ideal(kit, true);\n-\n-  Node* tls = __ thread(); \/\/ ThreadLocalStorage\n-\n-  Node* no_base = __ top();\n-  float likely = PROB_LIKELY_MAG(3);\n-  float unlikely = PROB_UNLIKELY_MAG(3);\n-  Node* young_card = __ ConI((jint)G1CardTable::g1_young_card_val());\n-  Node* dirty_card = __ ConI((jint)G1CardTable::dirty_card_val());\n-  Node* zeroX = __ ConX(0);\n-\n-  const TypeFunc *tf = write_ref_field_post_entry_Type();\n-\n-  \/\/ Offsets into the thread\n-  const int index_offset  = in_bytes(G1ThreadLocalData::dirty_card_queue_index_offset());\n-  const int buffer_offset = in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset());\n-\n-  \/\/ Pointers into the thread\n-\n-  Node* buffer_adr = __ AddP(no_base, tls, __ ConX(buffer_offset));\n-  Node* index_adr =  __ AddP(no_base, tls, __ ConX(index_offset));\n-\n-  \/\/ Now some values\n-  \/\/ Use ctrl to avoid hoisting these values past a safepoint, which could\n-  \/\/ potentially reset these fields in the JavaThread.\n-  Node* index  = __ load(__ ctrl(), index_adr, TypeX_X, TypeX_X->basic_type(), Compile::AliasIdxRaw);\n-  Node* buffer = __ load(__ ctrl(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);\n-\n-  \/\/ Convert the store obj pointer to an int prior to doing math on it\n-  \/\/ Must use ctrl to prevent \"integerized oop\" existing across safepoint\n-  Node* cast =  __ CastPX(__ ctrl(), adr);\n-\n-  \/\/ Divide pointer by card size\n-  Node* card_offset = __ URShiftX( cast, __ ConI(CardTable::card_shift()) );\n-\n-  \/\/ Combine card table base and card offset\n-  Node* card_adr = __ AddP(no_base, byte_map_base_node(kit), card_offset );\n-\n-  \/\/ If we know the value being stored does it cross regions?\n-\n-  if (val != nullptr) {\n-    \/\/ Does the store cause us to cross regions?\n-\n-    \/\/ Should be able to do an unsigned compare of region_size instead of\n-    \/\/ and extra shift. Do we have an unsigned compare??\n-    \/\/ Node* region_size = __ ConI(1 << G1HeapRegion::LogOfHRGrainBytes);\n-    Node* xor_res =  __ URShiftX ( __ XorX( cast,  __ CastPX(__ ctrl(), val)), __ ConI(checked_cast<jint>(G1HeapRegion::LogOfHRGrainBytes)));\n-\n-    \/\/ if (xor_res == 0) same region so skip\n-    __ if_then(xor_res, BoolTest::ne, zeroX, likely); {\n-\n-      \/\/ No barrier if we are storing a null.\n-      __ if_then(val, BoolTest::ne, kit->null(), likely); {\n-\n-        \/\/ Ok must mark the card if not already dirty\n-\n-        \/\/ load the original value of the card\n-        Node* card_val = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);\n-\n-        __ if_then(card_val, BoolTest::ne, young_card, unlikely); {\n-          kit->sync_kit(ideal);\n-          kit->insert_mem_bar(Op_MemBarVolatile, oop_store);\n-          __ sync_kit(kit);\n-\n-          Node* card_val_reload = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);\n-          __ if_then(card_val_reload, BoolTest::ne, dirty_card); {\n-            g1_mark_card(kit, ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);\n-          } __ end_if();\n-        } __ end_if();\n-      } __ end_if();\n-    } __ end_if();\n-  } else {\n-    \/\/ The Object.clone() intrinsic uses this path if !ReduceInitialCardMarks.\n-    \/\/ We don't need a barrier here if the destination is a newly allocated object\n-    \/\/ in Eden. Otherwise, GC verification breaks because we assume that cards in Eden\n-    \/\/ are set to 'g1_young_gen' (see G1CardTable::verify_g1_young_region()).\n-    assert(!use_ReduceInitialCardMarks(), \"can only happen with card marking\");\n-    Node* card_val = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);\n-    __ if_then(card_val, BoolTest::ne, young_card); {\n-      g1_mark_card(kit, ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);\n-    } __ end_if();\n-  }\n-\n-  \/\/ Final sync IdealKit and GraphKit.\n-  kit->final_sync(ideal);\n+  store->set_barrier_data(barrier_data);\n+  return;\n@@ -498,26 +266,11 @@\n-\/\/ Helper that guards and inserts a pre-barrier.\n-void G1BarrierSetC2::insert_pre_barrier(GraphKit* kit, Node* base_oop, Node* offset,\n-                                        Node* pre_val, bool need_mem_bar) const {\n-  \/\/ We could be accessing the referent field of a reference object. If so, when G1\n-  \/\/ is enabled, we need to log the value in the referent field in an SATB buffer.\n-  \/\/ This routine performs some compile time filters and generates suitable\n-  \/\/ runtime filters that guard the pre-barrier code.\n-  \/\/ Also add memory barrier for non volatile load from the referent field\n-  \/\/ to prevent commoning of loads across safepoint.\n-\n-  \/\/ Some compile time checks.\n-\n-  \/\/ If offset is a constant, is it java_lang_ref_Reference::_reference_offset?\n-  const TypeX* otype = offset->find_intptr_t_type();\n-  if (otype != nullptr && otype->is_con() &&\n-      otype->get_con() != java_lang_ref_Reference::referent_offset()) {\n-    \/\/ Constant offset but not the reference_offset so just return\n-    return;\n-  }\n-\n-  \/\/ We only need to generate the runtime guards for instances.\n-  const TypeOopPtr* btype = base_oop->bottom_type()->isa_oopptr();\n-  if (btype != nullptr) {\n-    if (btype->isa_aryptr()) {\n-      \/\/ Array type so nothing to do\n-      return;\n+\/\/ Refine (not really expand) G1 barriers by looking at the new value type\n+\/\/ (whether it is necessarily null or necessarily non-null).\n+bool G1BarrierSetC2::expand_barriers(Compile* C, PhaseIterGVN& igvn) const {\n+  ResourceMark rm;\n+  VectorSet visited;\n+  Node_List worklist;\n+  worklist.push(C->root());\n+  while (worklist.size() > 0) {\n+    Node* n = worklist.pop();\n+    if (visited.test_set(n->_idx)) {\n+      continue;\n@@ -525,10 +278,5 @@\n-\n-    const TypeInstPtr* itype = btype->isa_instptr();\n-    if (itype != nullptr) {\n-      \/\/ Can the klass of base_oop be statically determined to be\n-      \/\/ _not_ a sub-class of Reference and _not_ Object?\n-      ciKlass* klass = itype->instance_klass();\n-      if (klass->is_loaded() &&\n-          !klass->is_subtype_of(kit->env()->Reference_klass()) &&\n-          !kit->env()->Object_klass()->is_subtype_of(klass)) {\n-        return;\n+    refine_barrier_by_new_val_type(n);\n+    for (uint j = 0; j < n->req(); j++) {\n+      Node* in = n->in(j);\n+      if (in != nullptr) {\n+        worklist.push(in);\n@@ -538,0 +286,2 @@\n+  return false;\n+}\n@@ -539,6 +289,5 @@\n-  \/\/ The compile time filters did not reject base_oop\/offset so\n-  \/\/ we need to generate the following runtime filters\n-  \/\/\n-  \/\/ if (offset == java_lang_ref_Reference::_reference_offset) {\n-  \/\/   if (instance_of(base, java.lang.ref.Reference)) {\n-  \/\/     pre_barrier(_, pre_val, ...);\n+uint G1BarrierSetC2::estimated_barrier_size(const Node* node) const {\n+  \/\/ These Ideal node counts are extracted from the pre-matching Ideal graph\n+  \/\/ generated when compiling the following method with early barrier expansion:\n+  \/\/   static void write(MyObject obj1, Object o) {\n+  \/\/     obj1.o1 = o;\n@@ -546,42 +295,10 @@\n-  \/\/ }\n-\n-  float likely   = PROB_LIKELY(  0.999);\n-  float unlikely = PROB_UNLIKELY(0.999);\n-\n-  IdealKit ideal(kit);\n-\n-  Node* referent_off = __ ConX(java_lang_ref_Reference::referent_offset());\n-\n-  __ if_then(offset, BoolTest::eq, referent_off, unlikely); {\n-      \/\/ Update graphKit memory and control from IdealKit.\n-      kit->sync_kit(ideal);\n-\n-      Node* ref_klass_con = kit->makecon(TypeKlassPtr::make(kit->env()->Reference_klass()));\n-      Node* is_instof = kit->gen_instanceof(base_oop, ref_klass_con);\n-\n-      \/\/ Update IdealKit memory and control from graphKit.\n-      __ sync_kit(kit);\n-\n-      Node* one = __ ConI(1);\n-      \/\/ is_instof == 0 if base_oop == nullptr\n-      __ if_then(is_instof, BoolTest::eq, one, unlikely); {\n-\n-        \/\/ Update graphKit from IdeakKit.\n-        kit->sync_kit(ideal);\n-\n-        \/\/ Use the pre-barrier to record the value in the referent field\n-        pre_barrier(kit, false \/* do_load *\/,\n-                    __ ctrl(),\n-                    nullptr \/* obj *\/, nullptr \/* adr *\/, max_juint \/* alias_idx *\/, nullptr \/* val *\/, nullptr \/* val_type *\/,\n-                    pre_val \/* pre_val *\/,\n-                    T_OBJECT);\n-        if (need_mem_bar) {\n-          \/\/ Add memory barrier to prevent commoning reads from this field\n-          \/\/ across safepoint since GC can change its value.\n-          kit->insert_mem_bar(Op_MemBarCPUOrder);\n-        }\n-        \/\/ Update IdealKit from graphKit.\n-        __ sync_kit(kit);\n-\n-      } __ end_if(); \/\/ _ref_type != ref_none\n-  } __ end_if(); \/\/ offset == referent_offset\n+  uint8_t barrier_data = MemNode::barrier_data(node);\n+  uint nodes = 0;\n+  if ((barrier_data & G1C2BarrierPre) != 0) {\n+    nodes += 50;\n+  }\n+  if ((barrier_data & G1C2BarrierPost) != 0) {\n+    nodes += 60;\n+  }\n+  return nodes;\n+}\n@@ -589,2 +306,7 @@\n-  \/\/ Final sync IdealKit and GraphKit.\n-  kit->final_sync(ideal);\n+bool G1BarrierSetC2::can_initialize_object(const StoreNode* store) const {\n+  assert(store->Opcode() == Op_StoreP || store->Opcode() == Op_StoreN, \"OOP store expected\");\n+  \/\/ It is OK to move the store across the object initialization boundary only\n+  \/\/ if it does not have any barrier, or if it has barriers that can be safely\n+  \/\/ elided (because of the compensation steps taken on the allocation slow path\n+  \/\/ when ReduceInitialCardMarks is enabled).\n+  return (MemNode::barrier_data(store) == 0) || use_ReduceInitialCardMarks();\n@@ -593,1 +315,7 @@\n-#undef __\n+void G1BarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {\n+  if (ac->is_clone_inst() && !use_ReduceInitialCardMarks()) {\n+    clone_in_runtime(phase, ac, G1BarrierSetRuntime::clone_addr(), \"G1BarrierSetRuntime::clone\");\n+    return;\n+  }\n+  BarrierSetC2::clone_at_expansion(phase, ac);\n+}\n@@ -595,1 +323,1 @@\n-Node* G1BarrierSetC2::load_at_resolved(C2Access& access, const Type* val_type) const {\n+Node* G1BarrierSetC2::store_at_resolved(C2Access& access, C2AccessValue& val) const {\n@@ -597,6 +325,1 @@\n-  Node* adr = access.addr().node();\n-  Node* obj = access.base();\n-\n-  bool anonymous = (decorators & C2_UNSAFE_ACCESS) != 0;\n-  bool mismatched = (decorators & C2_MISMATCHED) != 0;\n-  bool unknown = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+  bool anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n@@ -604,19 +327,12 @@\n-  bool in_native = (decorators & IN_NATIVE) != 0;\n-  bool on_weak = (decorators & ON_WEAK_OOP_REF) != 0;\n-  bool on_phantom = (decorators & ON_PHANTOM_OOP_REF) != 0;\n-  bool is_unordered = (decorators & MO_UNORDERED) != 0;\n-  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n-  bool is_mixed = !in_heap && !in_native;\n-  bool need_cpu_mem_bar = !is_unordered || mismatched || is_mixed;\n-\n-  Node* top = Compile::current()->top();\n-  Node* offset = adr->is_AddP() ? adr->in(AddPNode::Offset) : top;\n-\n-  \/\/ If we are reading the value of the referent field of a Reference\n-  \/\/ object (either by using Unsafe directly or through reflection)\n-  \/\/ then, if G1 is enabled, we need to record the referent in an\n-  \/\/ SATB log buffer using the pre-barrier mechanism.\n-  \/\/ Also we need to add memory barrier to prevent commoning reads\n-  \/\/ from this field across safepoint since GC can change its value.\n-  bool need_read_barrier = (((on_weak || on_phantom) && !no_keepalive) ||\n-                            (in_heap && unknown && offset != top && obj != top));\n+  bool tightly_coupled_alloc = (decorators & C2_TIGHTLY_COUPLED_ALLOC) != 0;\n+  bool need_store_barrier = !(tightly_coupled_alloc && use_ReduceInitialCardMarks()) && (in_heap || anonymous);\n+  if (access.is_oop() && need_store_barrier) {\n+    access.set_barrier_data(get_store_barrier(access));\n+    if (tightly_coupled_alloc) {\n+      assert(!use_ReduceInitialCardMarks(),\n+             \"post-barriers are only needed for tightly-coupled initialization stores when ReduceInitialCardMarks is disabled\");\n+      access.set_barrier_data(access.barrier_data() ^ G1C2BarrierPre);\n+    }\n+  }\n+  return BarrierSetC2::store_at_resolved(access, val);\n+}\n@@ -624,2 +340,5 @@\n-  if (!access.is_oop() || !need_read_barrier) {\n-    return CardTableBarrierSetC2::load_at_resolved(access, val_type);\n+Node* G1BarrierSetC2::atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                     Node* new_val, const Type* value_type) const {\n+  GraphKit* kit = access.kit();\n+  if (!access.is_oop()) {\n+    return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n@@ -627,0 +346,3 @@\n+  access.set_barrier_data(G1C2BarrierPre | G1C2BarrierPost);\n+  return BarrierSetC2::atomic_cmpxchg_val_at_resolved(access, expected_val, new_val, value_type);\n+}\n@@ -628,1 +350,9 @@\n-  assert(access.is_parse_access(), \"entry not supported at optimization time\");\n+Node* G1BarrierSetC2::atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                      Node* new_val, const Type* value_type) const {\n+  GraphKit* kit = access.kit();\n+  if (!access.is_oop()) {\n+    return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n+  }\n+  access.set_barrier_data(G1C2BarrierPre | G1C2BarrierPost);\n+  return BarrierSetC2::atomic_cmpxchg_bool_at_resolved(access, expected_val, new_val, value_type);\n+}\n@@ -630,3 +360,8 @@\n-  C2ParseAccess& parse_access = static_cast<C2ParseAccess&>(access);\n-  GraphKit* kit = parse_access.kit();\n-  Node* load;\n+Node* G1BarrierSetC2::atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const {\n+  GraphKit* kit = access.kit();\n+  if (!access.is_oop()) {\n+    return BarrierSetC2::atomic_xchg_at_resolved(access, new_val, value_type);\n+  }\n+  access.set_barrier_data(G1C2BarrierPre | G1C2BarrierPost);\n+  return BarrierSetC2::atomic_xchg_at_resolved(access, new_val, value_type);\n+}\n@@ -634,10 +369,3 @@\n-  Node* control =  kit->control();\n-  const TypePtr* adr_type = access.addr().type();\n-  MemNode::MemOrd mo = access.mem_node_mo();\n-  bool requires_atomic_access = (decorators & MO_UNORDERED) == 0;\n-  bool unaligned = (decorators & C2_UNALIGNED) != 0;\n-  bool unsafe = (decorators & C2_UNSAFE_ACCESS) != 0;\n-  \/\/ Pinned control dependency is the strictest. So it's ok to substitute it for any other.\n-  load = kit->make_load(control, adr, val_type, access.type(), adr_type, mo,\n-      LoadNode::Pinned, requires_atomic_access, unaligned, mismatched, unsafe,\n-      access.barrier_data());\n+class G1BarrierSetC2State : public BarrierSetC2State {\n+private:\n+  GrowableArray<G1BarrierStubC2*>* _stubs;\n@@ -645,0 +373,4 @@\n+public:\n+  G1BarrierSetC2State(Arena* arena)\n+    : BarrierSetC2State(arena),\n+      _stubs(new (arena) GrowableArray<G1BarrierStubC2*>(arena, 8,  0, nullptr)) {}\n@@ -646,13 +378,2 @@\n-  if (on_weak || on_phantom) {\n-    \/\/ Use the pre-barrier to record the value in the referent field\n-    pre_barrier(kit, false \/* do_load *\/,\n-                kit->control(),\n-                nullptr \/* obj *\/, nullptr \/* adr *\/, max_juint \/* alias_idx *\/, nullptr \/* val *\/, nullptr \/* val_type *\/,\n-                load \/* pre_val *\/, T_OBJECT);\n-    \/\/ Add memory barrier to prevent commoning reads from this field\n-    \/\/ across safepoint since GC can change its value.\n-    kit->insert_mem_bar(Op_MemBarCPUOrder);\n-  } else if (unknown) {\n-    \/\/ We do not require a mem bar inside pre_barrier if need_mem_bar\n-    \/\/ is set: the barriers would be emitted by us.\n-    insert_pre_barrier(kit, obj, offset, load, !need_cpu_mem_bar);\n+  GrowableArray<G1BarrierStubC2*>* stubs() {\n+    return _stubs;\n@@ -661,6 +382,3 @@\n-  return load;\n-}\n-\n-bool G1BarrierSetC2::is_gc_barrier_node(Node* node) const {\n-  if (CardTableBarrierSetC2::is_gc_barrier_node(node)) {\n-    return true;\n+  bool needs_liveness_data(const MachNode* mach) const {\n+    return G1PreBarrierStubC2::needs_barrier(mach) ||\n+           G1PostBarrierStubC2::needs_barrier(mach);\n@@ -668,5 +386,2 @@\n-  if (node->Opcode() != Op_CallLeaf) {\n-    return false;\n-  }\n-  CallLeafNode *call = node->as_CallLeaf();\n-  if (call->_name == nullptr) {\n+\n+  bool needs_livein_data() const {\n@@ -675,0 +390,1 @@\n+};\n@@ -676,1 +392,2 @@\n-  return strcmp(call->_name, \"write_ref_field_pre_entry\") == 0 || strcmp(call->_name, \"write_ref_field_post_entry\") == 0;\n+static G1BarrierSetC2State* barrier_set_state() {\n+  return reinterpret_cast<G1BarrierSetC2State*>(Compile::current()->barrier_set_state());\n@@ -679,3 +396,1 @@\n-bool G1BarrierSetC2::is_g1_pre_val_load(Node* n) {\n-  if (n->is_Load() && n->as_Load()->has_pinned_control_dependency()) {\n-    \/\/ Make sure the only users of it are: CmpP, StoreP, and a call to write_ref_field_pre_entry\n+G1BarrierStubC2::G1BarrierStubC2(const MachNode* node) : BarrierStubC2(node) {}\n@@ -683,4 +398,1 @@\n-    \/\/ Skip possible decode\n-    if (n->outcnt() == 1 && n->unique_out()->is_DecodeN()) {\n-      n = n->unique_out();\n-    }\n+G1PreBarrierStubC2::G1PreBarrierStubC2(const MachNode* node) : G1BarrierStubC2(node) {}\n@@ -688,17 +400,8 @@\n-    if (n->outcnt() == 3) {\n-      int found = 0;\n-      for (SimpleDUIterator iter(n); iter.has_next(); iter.next()) {\n-        Node* use = iter.get();\n-        if (use->is_Cmp() || use->is_Store()) {\n-          ++found;\n-        } else if (use->is_CallLeaf()) {\n-          CallLeafNode* call = use->as_CallLeaf();\n-          if (strcmp(call->_name, \"write_ref_field_pre_entry\") == 0) {\n-            ++found;\n-          }\n-        }\n-      }\n-      if (found == 3) {\n-        return true;\n-      }\n-    }\n+bool G1PreBarrierStubC2::needs_barrier(const MachNode* node) {\n+  return (node->barrier_data() & G1C2BarrierPre) != 0;\n+}\n+\n+G1PreBarrierStubC2* G1PreBarrierStubC2::create(const MachNode* node) {\n+  G1PreBarrierStubC2* const stub = new (Compile::current()->comp_arena()) G1PreBarrierStubC2(node);\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    barrier_set_state()->stubs()->append(stub);\n@@ -706,1 +409,1 @@\n-  return false;\n+  return stub;\n@@ -709,2 +412,6 @@\n-bool G1BarrierSetC2::is_gc_pre_barrier_node(Node *node) const {\n-  return is_g1_pre_val_load(node);\n+void G1PreBarrierStubC2::initialize_registers(Register obj, Register pre_val, Register thread, Register tmp1, Register tmp2) {\n+  _obj = obj;\n+  _pre_val = pre_val;\n+  _thread = thread;\n+  _tmp1 = tmp1;\n+  _tmp2 = tmp2;\n@@ -713,9 +420,3 @@\n-void G1BarrierSetC2::eliminate_gc_barrier(PhaseIterGVN* igvn, Node* node) const {\n-  if (is_g1_pre_val_load(node)) {\n-    igvn->replace_node(node, igvn->zerocon(node->as_Load()->bottom_type()->basic_type()));\n-  } else {\n-    assert(node->Opcode() == Op_CastP2X, \"ConvP2XNode required\");\n-    assert(node->outcnt() <= 2, \"expects 1 or 2 users: Xor and URShift nodes\");\n-    \/\/ It could be only one user, URShift node, in Object.clone() intrinsic\n-    \/\/ but the new allocation is passed to arraycopy stub and it could not\n-    \/\/ be scalar replaced. So we don't check the case.\n+Register G1PreBarrierStubC2::obj() const {\n+  return _obj;\n+}\n@@ -723,3 +424,3 @@\n-    \/\/ An other case of only one user (Xor) is when the value check for null\n-    \/\/ in G1 post barrier is folded after CCP so the code which used URShift\n-    \/\/ is removed.\n+Register G1PreBarrierStubC2::pre_val() const {\n+  return _pre_val;\n+}\n@@ -727,4 +428,7 @@\n-    \/\/ Take Region node before eliminating post barrier since it also\n-    \/\/ eliminates CastP2X node when it has only one user.\n-    Node* this_region = node->in(0);\n-    assert(this_region != nullptr, \"\");\n+Register G1PreBarrierStubC2::thread() const {\n+  return _thread;\n+}\n+\n+Register G1PreBarrierStubC2::tmp1() const {\n+  return _tmp1;\n+}\n@@ -732,1 +436,3 @@\n-    \/\/ Remove G1 post barrier.\n+Register G1PreBarrierStubC2::tmp2() const {\n+  return _tmp2;\n+}\n@@ -734,11 +440,4 @@\n-    \/\/ Search for CastP2X->Xor->URShift->Cmp path which\n-    \/\/ checks if the store done to a different from the value's region.\n-    \/\/ And replace Cmp with #0 (false) to collapse G1 post barrier.\n-    Node* xorx = node->find_out_with(Op_XorX);\n-    if (xorx != nullptr) {\n-      Node* shift = xorx->unique_out();\n-      Node* cmpx = shift->unique_out();\n-      assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n-          cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n-          \"missing region check in G1 post barrier\");\n-      igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n+void G1PreBarrierStubC2::emit_code(MacroAssembler& masm) {\n+  G1BarrierSetAssembler* bs = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  bs->generate_c2_pre_barrier_stub(&masm, this);\n+}\n@@ -746,1 +445,1 @@\n-      \/\/ Remove G1 pre barrier.\n+G1PostBarrierStubC2::G1PostBarrierStubC2(const MachNode* node) : G1BarrierStubC2(node) {}\n@@ -748,46 +447,2 @@\n-      \/\/ Search \"if (marking != 0)\" check and set it to \"false\".\n-      \/\/ There is no G1 pre barrier if previous stored value is null\n-      \/\/ (for example, after initialization).\n-      if (this_region->is_Region() && this_region->req() == 3) {\n-        for (int i = 1; i < 3; ++i) {\n-          if (this_region->in(i)->is_IfFalse() &&\n-              this_region->in(i)->in(0)->is_If() &&\n-              this_region->in(i)->in(0)->in(1)->is_Bool()) {\n-            Node* bol = this_region->in(i)->in(0)->in(1);\n-            cmpx = bol->in(1);\n-            if (bol->as_Bool()->_test._test == BoolTest::ne &&\n-                cmpx->is_Cmp() && cmpx->in(2) == igvn->intcon(0) &&\n-                cmpx->in(1)->is_Load()) {\n-              Node* adr = cmpx->in(1)->as_Load()->in(MemNode::Address);\n-              const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-              if (adr->is_AddP() && adr->in(AddPNode::Base) == igvn->C->top() &&\n-                  adr->in(AddPNode::Address)->Opcode() == Op_ThreadLocal &&\n-                  adr->in(AddPNode::Offset) == igvn->MakeConX(marking_offset)) {\n-                igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n-              }\n-            }\n-          }\n-        }\n-      }\n-    } else {\n-      assert(!use_ReduceInitialCardMarks(), \"can only happen with card marking\");\n-      \/\/ This is a G1 post barrier emitted by the Object.clone() intrinsic.\n-      \/\/ Search for the CastP2X->URShiftX->AddP->LoadB->Cmp path which checks if the card\n-      \/\/ is marked as young_gen and replace the Cmp with 0 (false) to collapse the barrier.\n-      Node* shift = node->find_out_with(Op_URShiftX);\n-      assert(shift != nullptr, \"missing G1 post barrier\");\n-      Node* addp = shift->unique_out();\n-      Node* load = addp->find_out_with(Op_LoadB);\n-      assert(load != nullptr, \"missing G1 post barrier\");\n-      Node* cmpx = load->unique_out();\n-      assert(cmpx->is_Cmp() && cmpx->unique_out()->is_Bool() &&\n-          cmpx->unique_out()->as_Bool()->_test._test == BoolTest::ne,\n-          \"missing card value check in G1 post barrier\");\n-      igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n-      \/\/ There is no G1 pre barrier in this case\n-    }\n-    \/\/ Now CastP2X can be removed since it is used only on dead path\n-    \/\/ which currently still alive until igvn optimize it.\n-    assert(node->outcnt() == 0 || node->unique_out()->Opcode() == Op_URShiftX, \"\");\n-    igvn->replace_node(node, igvn->C->top());\n-  }\n+bool G1PostBarrierStubC2::needs_barrier(const MachNode* node) {\n+  return (node->barrier_data() & G1C2BarrierPost) != 0;\n@@ -796,31 +451,4 @@\n-Node* G1BarrierSetC2::step_over_gc_barrier(Node* c) const {\n-  if (!use_ReduceInitialCardMarks() &&\n-      c != nullptr && c->is_Region() && c->req() == 3) {\n-    for (uint i = 1; i < c->req(); i++) {\n-      if (c->in(i) != nullptr && c->in(i)->is_Region() &&\n-          c->in(i)->req() == 3) {\n-        Node* r = c->in(i);\n-        for (uint j = 1; j < r->req(); j++) {\n-          if (r->in(j) != nullptr && r->in(j)->is_Proj() &&\n-              r->in(j)->in(0) != nullptr &&\n-              r->in(j)->in(0)->Opcode() == Op_CallLeaf &&\n-              r->in(j)->in(0)->as_Call()->entry_point() == CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_field_post_entry)) {\n-            Node* call = r->in(j)->in(0);\n-            c = c->in(i == 1 ? 2 : 1);\n-            if (c != nullptr && c->Opcode() != Op_Parm) {\n-              c = c->in(0);\n-              if (c != nullptr) {\n-                c = c->in(0);\n-                assert(call->in(0) == nullptr ||\n-                       call->in(0)->in(0) == nullptr ||\n-                       call->in(0)->in(0)->in(0) == nullptr ||\n-                       call->in(0)->in(0)->in(0)->in(0) == nullptr ||\n-                       call->in(0)->in(0)->in(0)->in(0)->in(0) == nullptr ||\n-                       c == call->in(0)->in(0)->in(0)->in(0)->in(0), \"bad barrier shape\");\n-                return c;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n+G1PostBarrierStubC2* G1PostBarrierStubC2::create(const MachNode* node) {\n+  G1PostBarrierStubC2* const stub = new (Compile::current()->comp_arena()) G1PostBarrierStubC2(node);\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    barrier_set_state()->stubs()->append(stub);\n@@ -828,1 +456,1 @@\n-  return c;\n+  return stub;\n@@ -831,12 +459,6 @@\n-#ifdef ASSERT\n-bool G1BarrierSetC2::has_cas_in_use_chain(Node *n) const {\n-  Unique_Node_List visited;\n-  Node_List worklist;\n-  worklist.push(n);\n-  while (worklist.size() > 0) {\n-    Node* x = worklist.pop();\n-    if (visited.member(x)) {\n-      continue;\n-    } else {\n-      visited.push(x);\n-    }\n+void G1PostBarrierStubC2::initialize_registers(Register thread, Register tmp1, Register tmp2, Register tmp3) {\n+  _thread = thread;\n+  _tmp1 = tmp1;\n+  _tmp2 = tmp2;\n+  _tmp3 = tmp3;\n+}\n@@ -844,16 +466,2 @@\n-    if (x->is_LoadStore()) {\n-      int op = x->Opcode();\n-      if (op == Op_CompareAndExchangeP || op == Op_CompareAndExchangeN ||\n-          op == Op_CompareAndSwapP     || op == Op_CompareAndSwapN     ||\n-          op == Op_WeakCompareAndSwapP || op == Op_WeakCompareAndSwapN) {\n-        return true;\n-      }\n-    }\n-    if (!x->is_CFG()) {\n-      for (SimpleDUIterator iter(x); iter.has_next(); iter.next()) {\n-        Node* use = iter.get();\n-        worklist.push(use);\n-      }\n-    }\n-  }\n-  return false;\n+Register G1PostBarrierStubC2::thread() const {\n+  return _thread;\n@@ -862,7 +470,3 @@\n-void G1BarrierSetC2::verify_pre_load(Node* marking_if, Unique_Node_List& loads \/*output*\/) const {\n-  assert(loads.size() == 0, \"Loads list should be empty\");\n-  Node* pre_val_if = marking_if->find_out_with(Op_IfTrue)->find_out_with(Op_If);\n-  if (pre_val_if != nullptr) {\n-    Unique_Node_List visited;\n-    Node_List worklist;\n-    Node* pre_val = pre_val_if->in(1)->in(1)->in(1);\n+Register G1PostBarrierStubC2::tmp1() const {\n+  return _tmp1;\n+}\n@@ -870,8 +474,3 @@\n-    worklist.push(pre_val);\n-    while (worklist.size() > 0) {\n-      Node* x = worklist.pop();\n-      if (visited.member(x)) {\n-        continue;\n-      } else {\n-        visited.push(x);\n-      }\n+Register G1PostBarrierStubC2::tmp2() const {\n+  return _tmp2;\n+}\n@@ -879,4 +478,3 @@\n-      if (has_cas_in_use_chain(x)) {\n-        loads.clear();\n-        return;\n-      }\n+Register G1PostBarrierStubC2::tmp3() const {\n+  return _tmp3;\n+}\n@@ -884,21 +482,3 @@\n-      if (x->is_Con()) {\n-        continue;\n-      }\n-      if (x->is_EncodeP() || x->is_DecodeN()) {\n-        worklist.push(x->in(1));\n-        continue;\n-      }\n-      if (x->is_Load() || x->is_LoadStore()) {\n-        assert(x->in(0) != nullptr, \"Pre-val load has to have a control\");\n-        loads.push(x);\n-        continue;\n-      }\n-      if (x->is_Phi()) {\n-        for (uint i = 1; i < x->req(); i++) {\n-          worklist.push(x->in(i));\n-        }\n-        continue;\n-      }\n-      assert(false, \"Pre-val anomaly\");\n-    }\n-  }\n+void G1PostBarrierStubC2::emit_code(MacroAssembler& masm) {\n+  G1BarrierSetAssembler* bs = static_cast<G1BarrierSetAssembler*>(BarrierSet::barrier_set()->barrier_set_assembler());\n+  bs->generate_c2_post_barrier_stub(&masm, this);\n@@ -907,4 +487,3 @@\n-void G1BarrierSetC2::verify_no_safepoints(Compile* compile, Node* marking_check_if, const Unique_Node_List& loads) const {\n-  if (loads.size() == 0) {\n-    return;\n-  }\n+void* G1BarrierSetC2::create_barrier_state(Arena* comp_arena) const {\n+  return new (comp_arena) G1BarrierSetC2State(comp_arena);\n+}\n@@ -912,7 +491,4 @@\n-  if (loads.size() == 1) { \/\/ Handle the typical situation when there a single pre-value load\n-                           \/\/ that is dominated by the marking_check_if, that's true when the\n-                           \/\/ barrier itself does the pre-val load.\n-    Node *pre_val = loads.at(0);\n-    if (pre_val->in(0)->in(0) == marking_check_if) { \/\/ IfTrue->If\n-      return;\n-    }\n+int G1BarrierSetC2::get_store_barrier(C2Access& access) const {\n+  if (!access.is_parse_access()) {\n+    \/\/ Only support for eliding barriers at parse time for now.\n+    return G1C2BarrierPre | G1C2BarrierPost;\n@@ -920,6 +496,25 @@\n-\n-  \/\/ All other cases are when pre-value loads dominate the marking check.\n-  Unique_Node_List controls;\n-  for (uint i = 0; i < loads.size(); i++) {\n-    Node *c = loads.at(i)->in(0);\n-    controls.push(c);\n+  GraphKit* kit = (static_cast<C2ParseAccess&>(access)).kit();\n+  Node* ctl = kit->control();\n+  Node* adr = access.addr().node();\n+  uint adr_idx = kit->C->get_alias_index(access.addr().type());\n+  assert(adr_idx != Compile::AliasIdxTop, \"use other store_to_memory factory\");\n+\n+  bool can_remove_pre_barrier = g1_can_remove_pre_barrier(kit, &kit->gvn(), adr, access.type(), adr_idx);\n+\n+  \/\/ We can skip marks on a freshly-allocated object in Eden. Keep this code in\n+  \/\/ sync with CardTableBarrierSet::on_slowpath_allocation_exit. That routine\n+  \/\/ informs GC to take appropriate compensating steps, upon a slow-path\n+  \/\/ allocation, so as to make this card-mark elision safe.\n+  \/\/ The post-barrier can also be removed if null is written. This case is\n+  \/\/ handled by G1BarrierSetC2::expand_barriers, which runs at the end of C2's\n+  \/\/ platform-independent optimizations to exploit stronger type information.\n+  bool can_remove_post_barrier = use_ReduceInitialCardMarks() &&\n+    ((access.base() == kit->just_allocated_object(ctl)) ||\n+     g1_can_remove_post_barrier(kit, &kit->gvn(), ctl, adr));\n+\n+  int barriers = 0;\n+  if (!can_remove_pre_barrier) {\n+    barriers |= G1C2BarrierPre;\n+  }\n+  if (!can_remove_post_barrier) {\n+    barriers |= G1C2BarrierPost;\n@@ -928,4 +523,2 @@\n-  Unique_Node_List visited;\n-  Unique_Node_List safepoints;\n-  Node_List worklist;\n-  uint found = 0;\n+  return barriers;\n+}\n@@ -933,9 +526,3 @@\n-  worklist.push(marking_check_if);\n-  while (worklist.size() > 0 && found < controls.size()) {\n-    Node* x = worklist.pop();\n-    if (x == nullptr || x == compile->top()) continue;\n-    if (visited.member(x)) {\n-      continue;\n-    } else {\n-      visited.push(x);\n-    }\n+void G1BarrierSetC2::late_barrier_analysis() const {\n+  compute_liveness_at_stubs();\n+}\n@@ -943,13 +530,8 @@\n-    if (controls.member(x)) {\n-      found++;\n-    }\n-    if (x->is_Region()) {\n-      for (uint i = 1; i < x->req(); i++) {\n-        worklist.push(x->in(i));\n-      }\n-    } else {\n-      if (!x->is_SafePoint()) {\n-        worklist.push(x->in(0));\n-      } else {\n-        safepoints.push(x);\n-      }\n+void G1BarrierSetC2::emit_stubs(CodeBuffer& cb) const {\n+  MacroAssembler masm(&cb);\n+  GrowableArray<G1BarrierStubC2*>* const stubs = barrier_set_state()->stubs();\n+  for (int i = 0; i < stubs->length(); i++) {\n+    \/\/ Make sure there is enough space in the code buffer\n+    if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == nullptr) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n@@ -957,0 +539,1 @@\n+    stubs->at(i)->emit_code(masm);\n@@ -958,1 +541,1 @@\n-  assert(found == controls.size(), \"Pre-barrier structure anomaly or possible safepoint\");\n+  masm.flush();\n@@ -961,3 +544,4 @@\n-void G1BarrierSetC2::verify_gc_barriers(Compile* compile, CompilePhase phase) const {\n-  if (phase != BarrierSetC2::BeforeCodeGen) {\n-    return;\n+#ifndef PRODUCT\n+void G1BarrierSetC2::dump_barrier_data(const MachNode* mach, outputStream* st) const {\n+  if ((mach->barrier_data() & G1C2BarrierPre) != 0) {\n+    st->print(\"pre \");\n@@ -965,59 +549,2 @@\n-  \/\/ Verify G1 pre-barriers\n-  const int marking_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset());\n-\n-  Unique_Node_List visited;\n-  Node_List worklist;\n-  \/\/ We're going to walk control flow backwards starting from the Root\n-  worklist.push(compile->root());\n-  while (worklist.size() > 0) {\n-    Node* x = worklist.pop();\n-    if (x == nullptr || x == compile->top()) continue;\n-    if (visited.member(x)) {\n-      continue;\n-    } else {\n-      visited.push(x);\n-    }\n-\n-    if (x->is_Region()) {\n-      for (uint i = 1; i < x->req(); i++) {\n-        worklist.push(x->in(i));\n-      }\n-    } else {\n-      worklist.push(x->in(0));\n-      \/\/ We are looking for the pattern:\n-      \/\/                            \/->ThreadLocal\n-      \/\/ If->Bool->CmpI->LoadB->AddP->ConL(marking_offset)\n-      \/\/              \\->ConI(0)\n-      \/\/ We want to verify that the If and the LoadB have the same control\n-      \/\/ See GraphKit::g1_write_barrier_pre()\n-      if (x->is_If()) {\n-        IfNode *iff = x->as_If();\n-        if (iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp()) {\n-          CmpNode *cmp = iff->in(1)->in(1)->as_Cmp();\n-          if (cmp->Opcode() == Op_CmpI && cmp->in(2)->is_Con() && cmp->in(2)->bottom_type()->is_int()->get_con() == 0\n-              && cmp->in(1)->is_Load()) {\n-            LoadNode* load = cmp->in(1)->as_Load();\n-            if (load->Opcode() == Op_LoadB && load->in(2)->is_AddP() && load->in(2)->in(2)->Opcode() == Op_ThreadLocal\n-                && load->in(2)->in(3)->is_Con()\n-                && load->in(2)->in(3)->bottom_type()->is_intptr_t()->get_con() == marking_offset) {\n-\n-              Node* if_ctrl = iff->in(0);\n-              Node* load_ctrl = load->in(0);\n-\n-              if (if_ctrl != load_ctrl) {\n-                \/\/ Skip possible CProj->NeverBranch in infinite loops\n-                if ((if_ctrl->is_Proj() && if_ctrl->Opcode() == Op_CProj)\n-                    && if_ctrl->in(0)->is_NeverBranch()) {\n-                  if_ctrl = if_ctrl->in(0)->in(0);\n-                }\n-              }\n-              assert(load_ctrl != nullptr && if_ctrl == load_ctrl, \"controls must match\");\n-\n-              Unique_Node_List loads;\n-              verify_pre_load(iff, loads);\n-              verify_no_safepoints(compile, iff, loads);\n-            }\n-          }\n-        }\n-      }\n-    }\n+  if ((mach->barrier_data() & G1C2BarrierPost) != 0) {\n+    st->print(\"post \");\n@@ -1025,28 +552,2 @@\n-}\n-#endif\n-\n-bool G1BarrierSetC2::escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const {\n-  if (opcode == Op_StoreP) {\n-    Node* adr = n->in(MemNode::Address);\n-    const Type* adr_type = gvn->type(adr);\n-    \/\/ Pointer stores in G1 barriers looks like unsafe access.\n-    \/\/ Ignore such stores to be able scalar replace non-escaping\n-    \/\/ allocations.\n-    if (adr_type->isa_rawptr() && adr->is_AddP()) {\n-      Node* base = conn_graph->get_addp_base(adr);\n-      if (base->Opcode() == Op_LoadP &&\n-          base->in(MemNode::Address)->is_AddP()) {\n-        adr = base->in(MemNode::Address);\n-        Node* tls = conn_graph->get_addp_base(adr);\n-        if (tls->Opcode() == Op_ThreadLocal) {\n-          int offs = (int) gvn->find_intptr_t_con(adr->in(AddPNode::Offset), Type::OffsetBot);\n-          const int buf_offset = in_bytes(G1ThreadLocalData::satb_mark_queue_buffer_offset());\n-          if (offs == buf_offset) {\n-            return true; \/\/ G1 pre barrier previous oop value store.\n-          }\n-          if (offs == in_bytes(G1ThreadLocalData::dirty_card_queue_buffer_offset())) {\n-            return true; \/\/ G1 post barrier card address store.\n-          }\n-        }\n-      }\n-    }\n+  if ((mach->barrier_data() & G1C2BarrierPostNotNull) != 0) {\n+    st->print(\"notnull \");\n@@ -1054,1 +555,1 @@\n-  return false;\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":317,"deletions":816,"binary":false,"changes":1133,"status":"modified"},{"patch":"@@ -34,1 +34,40 @@\n-class G1BarrierSetC2: public CardTableBarrierSetC2 {\n+const int G1C2BarrierPre         = 1;\n+const int G1C2BarrierPost        = 2;\n+const int G1C2BarrierPostNotNull = 4;\n+\n+class G1BarrierStubC2 : public BarrierStubC2 {\n+public:\n+  G1BarrierStubC2(const MachNode* node);\n+  virtual void emit_code(MacroAssembler& masm) = 0;\n+};\n+\n+class G1PreBarrierStubC2 : public G1BarrierStubC2 {\n+private:\n+  Register _obj;\n+  Register _pre_val;\n+  Register _thread;\n+  Register _tmp1;\n+  Register _tmp2;\n+\n+protected:\n+  G1PreBarrierStubC2(const MachNode* node);\n+\n+public:\n+  static bool needs_barrier(const MachNode* node);\n+  static G1PreBarrierStubC2* create(const MachNode* node);\n+  void initialize_registers(Register obj, Register pre_val, Register thread, Register tmp1 = noreg, Register tmp2 = noreg);\n+  Register obj() const;\n+  Register pre_val() const;\n+  Register thread() const;\n+  Register tmp1() const;\n+  Register tmp2() const;\n+  virtual void emit_code(MacroAssembler& masm);\n+};\n+\n+class G1PostBarrierStubC2 : public G1BarrierStubC2 {\n+private:\n+  Register _thread;\n+  Register _tmp1;\n+  Register _tmp2;\n+  Register _tmp3;\n+\n@@ -36,20 +75,1 @@\n-  virtual void pre_barrier(GraphKit* kit,\n-                           bool do_load,\n-                           Node* ctl,\n-                           Node* obj,\n-                           Node* adr,\n-                           uint adr_idx,\n-                           Node* val,\n-                           const TypeOopPtr* val_type,\n-                           Node* pre_val,\n-                           BasicType bt) const;\n-\n-  virtual void post_barrier(GraphKit* kit,\n-                            Node* ctl,\n-                            Node* store,\n-                            Node* obj,\n-                            Node* adr,\n-                            uint adr_idx,\n-                            Node* val,\n-                            BasicType bt,\n-                            bool use_precise) const;\n+  G1PostBarrierStubC2(const MachNode* node);\n@@ -57,0 +77,13 @@\n+public:\n+  static bool needs_barrier(const MachNode* node);\n+  static G1PostBarrierStubC2* create(const MachNode* node);\n+  void initialize_registers(Register thread, Register tmp1 = noreg, Register tmp2 = noreg, Register tmp3 = noreg);\n+  Register thread() const;\n+  Register tmp1() const;\n+  Register tmp2() const;\n+  Register tmp3() const;\n+  virtual void emit_code(MacroAssembler& masm);\n+};\n+\n+class G1BarrierSetC2: public CardTableBarrierSetC2 {\n+protected:\n@@ -67,17 +100,1 @@\n-  void g1_mark_card(GraphKit* kit,\n-                    IdealKit& ideal,\n-                    Node* card_adr,\n-                    Node* oop_store,\n-                    uint oop_alias_idx,\n-                    Node* index,\n-                    Node* index_adr,\n-                    Node* buffer,\n-                    const TypeFunc* tf) const;\n-\n-  \/\/ Helper for unsafe accesses, that may or may not be on the referent field.\n-  \/\/ Generates the guards that check whether the result of\n-  \/\/ Unsafe.getReference should be recorded in an SATB log buffer.\n-  void insert_pre_barrier(GraphKit* kit, Node* base_oop, Node* offset, Node* pre_val, bool need_mem_bar) const;\n-\n-  static const TypeFunc* write_ref_field_pre_entry_Type();\n-  static const TypeFunc* write_ref_field_post_entry_Type();\n+  int get_store_barrier(C2Access& access) const;\n@@ -86,0 +103,6 @@\n+  virtual Node* store_at_resolved(C2Access& access, C2AccessValue& val) const;\n+  virtual Node* atomic_cmpxchg_val_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                               Node* new_val, const Type* value_type) const;\n+  virtual Node* atomic_cmpxchg_bool_at_resolved(C2AtomicParseAccess& access, Node* expected_val,\n+                                                Node* new_val, const Type* value_type) const;\n+  virtual Node* atomic_xchg_at_resolved(C2AtomicParseAccess& access, Node* new_val, const Type* value_type) const;\n@@ -87,9 +110,0 @@\n-#ifdef ASSERT\n-  bool has_cas_in_use_chain(Node* x) const;\n-  void verify_pre_load(Node* marking_check_if, Unique_Node_List& loads \/*output*\/) const;\n-  void verify_no_safepoints(Compile* compile, Node* marking_load, const Unique_Node_List& loads) const;\n-#endif\n-\n-  static bool is_g1_pre_val_load(Node* n);\n-  virtual bool is_gc_pre_barrier_node(Node* node) const;\n-  virtual bool is_gc_barrier_node(Node* node) const;\n@@ -97,4 +111,12 @@\n-  virtual Node* step_over_gc_barrier(Node* c) const;\n-\n-#ifdef ASSERT\n-  virtual void verify_gc_barriers(Compile* compile, CompilePhase phase) const;\n+  virtual void eliminate_gc_barrier_data(Node* node) const;\n+  virtual bool expand_barriers(Compile* C, PhaseIterGVN& igvn) const;\n+  virtual uint estimated_barrier_size(const Node* node) const;\n+  virtual bool can_initialize_object(const StoreNode* store) const;\n+  virtual void clone_at_expansion(PhaseMacroExpand* phase,\n+                                  ArrayCopyNode* ac) const;\n+  virtual void* create_barrier_state(Arena* comp_arena) const;\n+  virtual void emit_stubs(CodeBuffer& cb) const;\n+  virtual void late_barrier_analysis() const;\n+\n+#ifndef PRODUCT\n+  virtual void dump_barrier_data(const MachNode* mach, outputStream* st) const;\n@@ -103,2 +125,0 @@\n-\n-  virtual bool escape_add_to_con_graph(ConnectionGraph* conn_graph, PhaseGVN* gvn, Unique_Node_List* delayed_worklist, Node* n, uint opcode) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.hpp","additions":73,"deletions":53,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -116,0 +116,4 @@\n+uint8_t BarrierStubC2::barrier_data() const {\n+  return _node->barrier_data();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -261,0 +261,2 @@\n+  \/\/ High-level, GC-specific barrier flags.\n+  uint8_t barrier_data() const;\n@@ -347,0 +349,2 @@\n+  \/\/ Whether the given store can be used to initialize a newly allocated object.\n+  virtual bool can_initialize_object(const StoreNode* store) const { return true; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,25 +128,0 @@\n-void CardTableBarrierSetC2::clone(GraphKit* kit, Node* src, Node* dst, Node* size, bool is_array) const {\n-  BarrierSetC2::clone(kit, src, dst, size, is_array);\n-  const TypePtr* raw_adr_type = TypeRawPtr::BOTTOM;\n-\n-  \/\/ If necessary, emit some card marks afterwards.  (Non-arrays only.)\n-  bool card_mark = !is_array && !use_ReduceInitialCardMarks();\n-  if (card_mark) {\n-    assert(!is_array, \"\");\n-    \/\/ Put in store barrier for any and all oops we are sticking\n-    \/\/ into this object.  (We could avoid this if we could prove\n-    \/\/ that the object type contains no oop fields at all.)\n-    Node* no_particular_value = nullptr;\n-    Node* no_particular_field = nullptr;\n-    int raw_adr_idx = Compile::AliasIdxRaw;\n-    post_barrier(kit, kit->control(),\n-                 kit->memory(raw_adr_type),\n-                 dst,\n-                 no_particular_field,\n-                 raw_adr_idx,\n-                 no_particular_value,\n-                 T_OBJECT,\n-                 false);\n-  }\n-}\n-\n@@ -157,4 +132,0 @@\n-bool CardTableBarrierSetC2::is_gc_barrier_node(Node* node) const {\n-  return ModRefBarrierSetC2::is_gc_barrier_node(node) || node->Opcode() == Op_StoreCM;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-  virtual void clone(GraphKit* kit, Node* src, Node* dst, Node* size, bool is_array) const;\n-  virtual bool is_gc_barrier_node(Node* node) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -252,2 +252,3 @@\n-        const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type();\n-        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), \"shenandoah_wb_pre\", pre_val, tls);\n+        const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_Type();\n+        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), \"shenandoah_wb_pre\",\n+                          pre_val, tls);\n@@ -271,1 +272,6 @@\n-         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry);\n+         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre);\n+}\n+\n+bool ShenandoahBarrierSetC2::is_shenandoah_clone_call(Node* call) {\n+  return call->is_CallLeaf() &&\n+         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::clone_barrier);\n@@ -431,1 +437,1 @@\n-const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type() {\n+const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_Type() {\n@@ -444,1 +450,1 @@\n-const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {\n+const TypeFunc* ShenandoahBarrierSetC2::clone_barrier_Type() {\n@@ -456,1 +462,1 @@\n-const TypeFunc* ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type() {\n+const TypeFunc* ShenandoahBarrierSetC2::load_reference_barrier_Type() {\n@@ -678,13 +684,4 @@\n-\/\/ Support for GC barriers emitted during parsing\n-  if (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) return true;\n-  if (node->Opcode() != Op_CallLeaf && node->Opcode() != Op_CallLeafNoFP) {\n-    return false;\n-  }\n-  CallLeafNode *call = node->as_CallLeaf();\n-  if (call->_name == nullptr) {\n-    return false;\n-  }\n-\n-  return strcmp(call->_name, \"shenandoah_clone_barrier\") == 0 ||\n-         strcmp(call->_name, \"shenandoah_cas_obj\") == 0 ||\n-         strcmp(call->_name, \"shenandoah_wb_pre\") == 0;\n+  return (node->Opcode() == Op_ShenandoahLoadReferenceBarrier) ||\n+         is_shenandoah_lrb_call(node) ||\n+         is_shenandoah_wb_pre_call(node) ||\n+         is_shenandoah_clone_call(node);\n@@ -805,5 +802,5 @@\n-                    ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type(),\n-                    CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier),\n-                    \"shenandoah_clone\",\n-                    TypeRawPtr::BOTTOM,\n-                    src_base);\n+                                       ShenandoahBarrierSetC2::clone_barrier_Type(),\n+                                       CAST_FROM_FN_PTR(address, ShenandoahRuntime::clone_barrier),\n+                                       \"shenandoah_clone\",\n+                                       TypeRawPtr::BOTTOM,\n+                                       src_base);\n@@ -984,1 +981,1 @@\n-    uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain_sig()->cnt();\n+    uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_Type()->domain_sig()->cnt();\n@@ -1070,1 +1067,1 @@\n-        uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()->domain_sig()->cnt();\n+        uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_Type()->domain_sig()->cnt();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+  static bool is_shenandoah_clone_call(Node* call);\n@@ -95,3 +96,3 @@\n-  static const TypeFunc* write_ref_field_pre_entry_Type();\n-  static const TypeFunc* shenandoah_clone_barrier_Type();\n-  static const TypeFunc* shenandoah_load_reference_barrier_Type();\n+  static const TypeFunc* write_ref_field_pre_Type();\n+  static const TypeFunc* clone_barrier_Type();\n+  static const TypeFunc* load_reference_barrier_Type();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -417,1 +417,1 @@\n-        \"shenandoah_clone_barrier\",\n+        \"shenandoah_clone\",\n@@ -997,1 +997,1 @@\n-  Node* call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type(), calladdr, name, TypeRawPtr::BOTTOM);\n+  Node* call = new CallLeafNode(ShenandoahBarrierSetC2::load_reference_barrier_Type(), calladdr, name, TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-template<typename K, typename V, size_t _table_size>\n+template<typename K, typename V, size_t TableSize>\n@@ -58,1 +58,1 @@\n-  static const size_t _table_mask = _table_size - 1;\n+  static const size_t TableMask = TableSize - 1;\n@@ -61,1 +61,1 @@\n-  ZArenaHashtableEntry* _table[_table_size];\n+  ZArenaHashtableEntry* _table[TableSize];\n@@ -87,1 +87,1 @@\n-      while (_current_entry == nullptr && ++_current_index < _table_size) {\n+      while (_current_entry == nullptr && ++_current_index < TableSize) {\n@@ -103,2 +103,2 @@\n-    entry->_next = _table[key & _table_mask];\n-    _table[key & _table_mask] = entry;\n+    entry->_next = _table[key & TableMask];\n+    _table[key & TableMask] = entry;\n@@ -108,1 +108,1 @@\n-    for (ZArenaHashtableEntry* e = _table[key & _table_mask]; e != nullptr; e = e->_next) {\n+    for (ZArenaHashtableEntry* e = _table[key & TableMask]; e != nullptr; e = e->_next) {\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  static const BarrierSet::Name value = BarrierSet::ZBarrierSet;\n+  static const BarrierSet::Name Value = BarrierSet::ZBarrierSet;\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  assert(itable_index == resolved_method()->itable_index(), \"\");\n+  assert(itable_index == resolved_method->itable_index(), \"\");\n@@ -1547,1 +1547,1 @@\n-  if (!is_abstract_interpretation && !resolved_method()->is_private()) {\n+  if (!is_abstract_interpretation && !resolved_method->is_private()) {\n@@ -1596,1 +1596,1 @@\n-    int itable_index = resolved_method()->itable_index();\n+    int itable_index = resolved_method->itable_index();\n@@ -1603,2 +1603,2 @@\n-    assert(resolved_method()->is_private() ||\n-           (resolved_method()->is_final() && resolved_method->method_holder() == vmClasses::Object_klass()),\n+    assert(resolved_method->is_private() ||\n+           (resolved_method->is_final() && resolved_method->method_holder() == vmClasses::Object_klass()),\n@@ -1606,1 +1606,1 @@\n-    assert(resolved_method()->can_be_statically_bound(), \"Should only have non-virtual invokeinterface for statically bound methods!\");\n+    assert(resolved_method->can_be_statically_bound(), \"Should only have non-virtual invokeinterface for statically bound methods!\");\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-  BasicType    result_type() const               { return selected_method()->result_type(); }\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -249,0 +249,1 @@\n+  nonstatic_field(JavaThread,                  _unlocked_inflated_monitor,                    ObjectMonitor*)                        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -784,1 +785,1 @@\n-  const char* printable_name_at(int cp_index) PRODUCT_RETURN0;\n+  const char* printable_name_at(int cp_index) PRODUCT_RETURN_NULL;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -608,0 +608,1 @@\n+      assert(!old_method->is_deleted(), \"cannot delete these methods\");\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2981,0 +2981,7 @@\n+\n+  if (ik->is_scratch_class()) {\n+    assert(ik->dependencies().is_empty(), \"dependencies should be empty for scratch classes\");\n+    return;\n+  }\n+  assert(ik->is_loaded(), \"class should be loaded \" PTR_FORMAT, p2i(ik));\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -238,0 +238,7 @@\n+    if (def->is_MachTemp()) {\n+      assert(!def->bottom_type()->isa_oop_ptr(),\n+             \"ADLC only assigns OOP types to MachTemp defs corresponding to xRegN operands\");\n+      \/\/ Exclude MachTemp definitions even if they are typed as oops.\n+      continue;\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+  product(bool, StressUnstableIfTraps, false, DIAGNOSTIC,                   \\\n+          \"Randomly take unstable if traps\")                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -614,0 +614,1 @@\n+  case vmIntrinsics::_dtanh:\n@@ -820,0 +821,1 @@\n+  case vmIntrinsics::_VectorWrapShuffleIndexes:\n@@ -830,0 +832,1 @@\n+  case vmIntrinsics::_VectorSelectFrom:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -360,1 +360,0 @@\n-  ProjNode* uncommon_trap_proj(CallStaticJavaNode*& call) const;\n@@ -455,0 +454,1 @@\n+  ProjNode* uncommon_trap_proj(CallStaticJavaNode*& call, Deoptimization::DeoptReason reason = Deoptimization::Reason_none) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -737,0 +737,5 @@\n+  if (StressLCM || StressGCM || StressIGVN || StressCCP ||\n+      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps) {\n+    initialize_stress_seed(directive);\n+  }\n+\n@@ -859,5 +864,0 @@\n-  if (StressLCM || StressGCM || StressIGVN || StressCCP ||\n-      StressIncrementalInlining || StressMacroExpansion) {\n-    initialize_stress_seed(directive);\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -843,1 +843,1 @@\n-ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*& call) const {\n+ProjNode* IfNode::uncommon_trap_proj(CallStaticJavaNode*& call, Deoptimization::DeoptReason reason) const {\n@@ -845,1 +845,1 @@\n-    call = proj_out(i)->is_uncommon_trap_proj();\n+    call = proj_out(i)->is_uncommon_trap_proj(reason);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,0 +164,8 @@\n+    if (mach->barrier_data() != 0) {\n+      \/\/ Using memory accesses with barriers to perform implicit null checks is\n+      \/\/ not supported. These operations might expand into multiple assembly\n+      \/\/ instructions during code emission, including new memory accesses (e.g.\n+      \/\/ in G1's pre-barrier), which would invalidate the implicit null\n+      \/\/ exception table.\n+      continue;\n+    }\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+  case vmIntrinsics::_dtanh:\n@@ -726,0 +727,2 @@\n+  case vmIntrinsics::_VectorWrapShuffleIndexes:\n+    return inline_vector_wrap_shuffle_indexes();\n@@ -746,0 +749,2 @@\n+  case vmIntrinsics::_VectorSelectFrom:\n+    return inline_vector_select_from();\n@@ -1889,0 +1894,3 @@\n+  case vmIntrinsics::_dtanh:\n+    return StubRoutines::dtanh() != nullptr ?\n+      runtime_math(OptoRuntime::Math_D_D_Type(), StubRoutines::dtanh(), \"dtanh\") : false;\n@@ -2054,1 +2062,1 @@\n-  } else if (base_type == TypePtr::NULL_PTR) {\n+  } else if (_gvn.type(base->uncast()) == TypePtr::NULL_PTR) {\n@@ -2433,0 +2441,1 @@\n+  assert(!stopped(), \"Inlining of unsafe access failed: address construction stopped unexpectedly\");\n@@ -2434,1 +2443,1 @@\n-  if (_gvn.type(base)->isa_ptr() == TypePtr::NULL_PTR) {\n+  if (_gvn.type(base->uncast())->isa_ptr() == TypePtr::NULL_PTR) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -381,0 +381,1 @@\n+  bool inline_vector_wrap_shuffle_indexes();\n@@ -391,0 +392,1 @@\n+  bool inline_vector_select_from();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1638,0 +1638,8 @@\n+    if (!shared && Matcher::is_encode_and_store_pattern(n, m)) {\n+      \/\/ Make it possible to match \"encode and store\" patterns with non-shared\n+      \/\/ encode operations that are pinned to a control node (e.g. by CastPP\n+      \/\/ node removal in final graph reshaping). The matched instruction cannot\n+      \/\/ float above the encode's control node because it is pinned to the\n+      \/\/ store's control node.\n+      return false;\n+    }\n@@ -2884,0 +2892,12 @@\n+bool Matcher::is_encode_and_store_pattern(const Node* n, const Node* m) {\n+  if (n == nullptr ||\n+      m == nullptr ||\n+      n->Opcode() != Op_StoreN ||\n+      !m->is_EncodeP() ||\n+      n->as_Store()->barrier_data() == 0) {\n+    return false;\n+  }\n+  assert(m == n->in(MemNode::ValueIn), \"m should be input to n\");\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -390,0 +390,2 @@\n+  static bool is_encode_and_store_pattern(const Node* n, const Node* m);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4724,0 +4724,5 @@\n+  BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+  if ((st->Opcode() == Op_StoreP || st->Opcode() == Op_StoreN) &&\n+      !bs->can_initialize_object(st)) {\n+    return FAIL;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -127,5 +127,1 @@\n-#ifdef ASSERT\n-    return _adr_type;\n-#else\n-    return 0;\n-#endif\n+    return DEBUG_ONLY(_adr_type) NOT_DEBUG(nullptr);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2093,0 +2093,2 @@\n+      assert(n->in(1)->as_Mach()->barrier_data() == 0,\n+             \"Implicit null checks on memory accesses with barriers are not yet supported\");\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -631,0 +631,5 @@\n+  \/\/ Stress unstable if traps\n+  void stress_trap(IfNode* orig_iff, Node* counter, Node* incr_store);\n+  \/\/ Increment counter used by StressUnstableIfTraps\n+  void increment_trap_stress_counter(Node*& counter, Node*& incr_store);\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1751,0 +1751,10 @@\n+\/\/ Used by StressUnstableIfTraps\n+static volatile int _trap_stress_counter = 0;\n+\n+void Parse::increment_trap_stress_counter(Node*& counter, Node*& incr_store) {\n+  Node* counter_addr = makecon(TypeRawPtr::make((address)&_trap_stress_counter));\n+  counter = make_load(control(), counter_addr, TypeInt::INT, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+  counter = _gvn.transform(new AddINode(counter, intcon(1)));\n+  incr_store = store_to_memory(control(), counter_addr, counter, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+}\n+\n@@ -1755,0 +1765,7 @@\n+  Node* counter = nullptr;\n+  Node* incr_store = nullptr;\n+  bool do_stress_trap = StressUnstableIfTraps && ((C->random() % 2) == 0);\n+  if (do_stress_trap) {\n+    increment_trap_stress_counter(counter, incr_store);\n+  }\n+\n@@ -1819,0 +1836,4 @@\n+\n+  if (do_stress_trap) {\n+    stress_trap(iff, counter, incr_store);\n+  }\n@@ -1848,0 +1869,7 @@\n+  Node* counter = nullptr;\n+  Node* incr_store = nullptr;\n+  bool do_stress_trap = StressUnstableIfTraps && ((C->random() % 2) == 0);\n+  if (do_stress_trap) {\n+    increment_trap_stress_counter(counter, incr_store);\n+  }\n+\n@@ -1938,0 +1966,4 @@\n+\n+  if (do_stress_trap) {\n+    stress_trap(iff, counter, incr_store);\n+  }\n@@ -2344,0 +2376,41 @@\n+\/\/ Force unstable if traps to be taken randomly to trigger intermittent bugs such as incorrect debug information.\n+\/\/ Add another if before the unstable if that checks a \"random\" condition at runtime (a simple shared counter) and\n+\/\/ then either takes the trap or executes the original, unstable if.\n+void Parse::stress_trap(IfNode* orig_iff, Node* counter, Node* incr_store) {\n+  \/\/ Search for an unstable if trap\n+  CallStaticJavaNode* trap = nullptr;\n+  assert(orig_iff->Opcode() == Op_If && orig_iff->outcnt() == 2, \"malformed if\");\n+  ProjNode* trap_proj = orig_iff->uncommon_trap_proj(trap, Deoptimization::Reason_unstable_if);\n+  if (trap == nullptr || !trap->jvms()->should_reexecute()) {\n+    \/\/ No suitable trap found. Remove unused counter load and increment.\n+    C->gvn_replace_by(incr_store, incr_store->in(MemNode::Memory));\n+    return;\n+  }\n+\n+  \/\/ Remove trap from optimization list since we add another path to the trap.\n+  bool success = C->remove_unstable_if_trap(trap, true);\n+  assert(success, \"Trap already modified\");\n+\n+  \/\/ Add a check before the original if that will trap with a certain frequency and execute the original if otherwise\n+  int freq_log = (C->random() % 31) + 1; \/\/ Random logarithmic frequency in [1, 31]\n+  Node* mask = intcon(right_n_bits(freq_log));\n+  counter = _gvn.transform(new AndINode(counter, mask));\n+  Node* cmp = _gvn.transform(new CmpINode(counter, intcon(0)));\n+  Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::mask::eq));\n+  IfNode* iff = _gvn.transform(new IfNode(orig_iff->in(0), bol, orig_iff->_prob, orig_iff->_fcnt))->as_If();\n+  Node* if_true = _gvn.transform(new IfTrueNode(iff));\n+  Node* if_false = _gvn.transform(new IfFalseNode(iff));\n+  assert(!if_true->is_top() && !if_false->is_top(), \"trap always \/ never taken\");\n+\n+  \/\/ Trap\n+  assert(trap_proj->outcnt() == 1, \"some other nodes are dependent on the trap projection\");\n+\n+  Node* trap_region = new RegionNode(3);\n+  trap_region->set_req(1, trap_proj);\n+  trap_region->set_req(2, if_true);\n+  trap->set_req(0, _gvn.transform(trap_region));\n+\n+  \/\/ Don't trap, execute original if\n+  orig_iff->set_req(0, if_false);\n+}\n+\n@@ -2345,0 +2418,4 @@\n+  \/\/ Randomly skip emitting an uncommon trap\n+  if (StressUnstableIfTraps && ((C->random() % 2) == 0)) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -3375,2 +3375,2 @@\n-TypeInterfaces::TypeInterfaces()\n-        : Type(Interfaces), _list(Compile::current()->type_arena(), 0, 0, nullptr),\n+TypeInterfaces::TypeInterfaces(ciInstanceKlass** interfaces_base, int nb_interfaces)\n+        : Type(Interfaces), _interfaces(interfaces_base, nb_interfaces),\n@@ -3378,9 +3378,1 @@\n-  DEBUG_ONLY(_initialized = true);\n-}\n-\n-TypeInterfaces::TypeInterfaces(GrowableArray<ciInstanceKlass*>* interfaces)\n-        : Type(Interfaces), _list(Compile::current()->type_arena(), interfaces->length(), 0, nullptr),\n-          _hash(0), _exact_klass(nullptr) {\n-  for (int i = 0; i < interfaces->length(); i++) {\n-    add(interfaces->at(i));\n-  }\n+  _interfaces.sort(compare);\n@@ -3391,1 +3383,14 @@\n-  TypeInterfaces* result = (interfaces == nullptr) ? new TypeInterfaces() : new TypeInterfaces(interfaces);\n+  \/\/ hashcons() can only delete the last thing that was allocated: to\n+  \/\/ make sure all memory for the newly created TypeInterfaces can be\n+  \/\/ freed if an identical one exists, allocate space for the array of\n+  \/\/ interfaces right after the TypeInterfaces object so that they\n+  \/\/ form a contiguous piece of memory.\n+  int nb_interfaces = interfaces == nullptr ? 0 : interfaces->length();\n+  size_t total_size = sizeof(TypeInterfaces) + nb_interfaces * sizeof(ciInstanceKlass*);\n+\n+  void* allocated_mem = operator new(total_size);\n+  ciInstanceKlass** interfaces_base = (ciInstanceKlass**)((char*)allocated_mem + sizeof(TypeInterfaces));\n+  for (int i = 0; i < nb_interfaces; ++i) {\n+    interfaces_base[i] = interfaces->at(i);\n+  }\n+  TypeInterfaces* result = ::new (allocated_mem) TypeInterfaces(interfaces_base, nb_interfaces);\n@@ -3410,4 +3415,2 @@\n-void TypeInterfaces::add(ciInstanceKlass* interface) {\n-  assert(interface->is_interface(), \"for interfaces only\");\n-  _list.insert_sorted<compare>(interface);\n-  verify();\n+int TypeInterfaces::compare(ciInstanceKlass** k1, ciInstanceKlass** k2) {\n+  return compare(*k1, *k2);\n@@ -3418,1 +3421,1 @@\n-  if (_list.length() != other->_list.length()) {\n+  if (_interfaces.length() != other->_interfaces.length()) {\n@@ -3421,3 +3424,3 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* k1 = _list.at(i);\n-    ciKlass* k2 = other->_list.at(i);\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    ciKlass* k1 = _interfaces.at(i);\n+    ciKlass* k2 = other->_interfaces.at(i);\n@@ -3434,1 +3437,1 @@\n-  if (_list.length() != interfaces->length()) {\n+  if (_interfaces.length() != interfaces->length()) {\n@@ -3439,1 +3442,1 @@\n-    _list.find_sorted<ciInstanceKlass*, compare>(interfaces->at(i), found);\n+    _interfaces.find_sorted<ciInstanceKlass*, compare>(interfaces->at(i), found);\n@@ -3459,2 +3462,2 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* k = _list.at(i);\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    ciKlass* k = _interfaces.at(i);\n@@ -3471,1 +3474,1 @@\n-  if (_list.length() == 0) {\n+  if (_interfaces.length() == 0) {\n@@ -3477,1 +3480,1 @@\n-  interfaces.appendAll(&_list);\n+  interfaces.appendAll(&_interfaces);\n@@ -3492,3 +3495,3 @@\n-  for (int i = 1; i < _list.length(); i++) {\n-    ciInstanceKlass* k1 = _list.at(i-1);\n-    ciInstanceKlass* k2 = _list.at(i);\n+  for (int i = 1; i < _interfaces.length(); i++) {\n+    ciInstanceKlass* k1 = _interfaces.at(i-1);\n+    ciInstanceKlass* k2 = _interfaces.at(i);\n@@ -3505,5 +3508,5 @@\n-  while (i < _list.length() || j < other->_list.length()) {\n-    while (i < _list.length() &&\n-           (j >= other->_list.length() ||\n-            compare(_list.at(i), other->_list.at(j)) < 0)) {\n-      result_list.push(_list.at(i));\n+  while (i < _interfaces.length() || j < other->_interfaces.length()) {\n+    while (i < _interfaces.length() &&\n+           (j >= other->_interfaces.length() ||\n+            compare(_interfaces.at(i), other->_interfaces.at(j)) < 0)) {\n+      result_list.push(_interfaces.at(i));\n@@ -3512,4 +3515,4 @@\n-    while (j < other->_list.length() &&\n-           (i >= _list.length() ||\n-            compare(other->_list.at(j), _list.at(i)) < 0)) {\n-      result_list.push(other->_list.at(j));\n+    while (j < other->_interfaces.length() &&\n+           (i >= _interfaces.length() ||\n+            compare(other->_interfaces.at(j), _interfaces.at(i)) < 0)) {\n+      result_list.push(other->_interfaces.at(j));\n@@ -3518,4 +3521,4 @@\n-    if (i < _list.length() &&\n-        j < other->_list.length() &&\n-        _list.at(i) == other->_list.at(j)) {\n-      result_list.push(_list.at(i));\n+    if (i < _interfaces.length() &&\n+        j < other->_interfaces.length() &&\n+        _interfaces.at(i) == other->_interfaces.at(j)) {\n+      result_list.push(_interfaces.at(i));\n@@ -3529,2 +3532,2 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    assert(result->_list.contains(_list.at(i)), \"missing\");\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    assert(result->_interfaces.contains(_interfaces.at(i)), \"missing\");\n@@ -3532,2 +3535,2 @@\n-  for (int i = 0; i < other->_list.length(); i++) {\n-    assert(result->_list.contains(other->_list.at(i)), \"missing\");\n+  for (int i = 0; i < other->_interfaces.length(); i++) {\n+    assert(result->_interfaces.contains(other->_interfaces.at(i)), \"missing\");\n@@ -3535,2 +3538,2 @@\n-  for (int i = 0; i < result->_list.length(); i++) {\n-    assert(_list.contains(result->_list.at(i)) || other->_list.contains(result->_list.at(i)), \"missing\");\n+  for (int i = 0; i < result->_interfaces.length(); i++) {\n+    assert(_interfaces.contains(result->_interfaces.at(i)) || other->_interfaces.contains(result->_interfaces.at(i)), \"missing\");\n@@ -3546,4 +3549,4 @@\n-  while (i < _list.length() || j < other->_list.length()) {\n-    while (i < _list.length() &&\n-           (j >= other->_list.length() ||\n-            compare(_list.at(i), other->_list.at(j)) < 0)) {\n+  while (i < _interfaces.length() || j < other->_interfaces.length()) {\n+    while (i < _interfaces.length() &&\n+           (j >= other->_interfaces.length() ||\n+            compare(_interfaces.at(i), other->_interfaces.at(j)) < 0)) {\n@@ -3552,3 +3555,3 @@\n-    while (j < other->_list.length() &&\n-           (i >= _list.length() ||\n-            compare(other->_list.at(j), _list.at(i)) < 0)) {\n+    while (j < other->_interfaces.length() &&\n+           (i >= _interfaces.length() ||\n+            compare(other->_interfaces.at(j), _interfaces.at(i)) < 0)) {\n@@ -3557,4 +3560,4 @@\n-    if (i < _list.length() &&\n-        j < other->_list.length() &&\n-        _list.at(i) == other->_list.at(j)) {\n-      result_list.push(_list.at(i));\n+    if (i < _interfaces.length() &&\n+        j < other->_interfaces.length() &&\n+        _interfaces.at(i) == other->_interfaces.at(j)) {\n+      result_list.push(_interfaces.at(i));\n@@ -3568,2 +3571,2 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    assert(!other->_list.contains(_list.at(i)) || result->_list.contains(_list.at(i)), \"missing\");\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    assert(!other->_interfaces.contains(_interfaces.at(i)) || result->_interfaces.contains(_interfaces.at(i)), \"missing\");\n@@ -3571,2 +3574,2 @@\n-  for (int i = 0; i < other->_list.length(); i++) {\n-    assert(!_list.contains(other->_list.at(i)) || result->_list.contains(other->_list.at(i)), \"missing\");\n+  for (int i = 0; i < other->_interfaces.length(); i++) {\n+    assert(!_interfaces.contains(other->_interfaces.at(i)) || result->_interfaces.contains(other->_interfaces.at(i)), \"missing\");\n@@ -3574,2 +3577,2 @@\n-  for (int i = 0; i < result->_list.length(); i++) {\n-    assert(_list.contains(result->_list.at(i)) && other->_list.contains(result->_list.at(i)), \"missing\");\n+  for (int i = 0; i < result->_interfaces.length(); i++) {\n+    assert(_interfaces.contains(result->_interfaces.at(i)) && other->_interfaces.contains(result->_interfaces.at(i)), \"missing\");\n@@ -3588,1 +3591,1 @@\n-  if (_list.length() == 0) {\n+  if (_interfaces.length() == 0) {\n@@ -3593,2 +3596,2 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciInstanceKlass* interface = _list.at(i);\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    ciInstanceKlass* interface = _interfaces.at(i);\n@@ -3605,2 +3608,2 @@\n-  for (int i = 0; i < _list.length(); i++) {\n-    ciKlass* interface = _list.at(i);\n+  for (int i = 0; i < _interfaces.length(); i++) {\n+    ciKlass* interface = _interfaces.at(i);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":73,"deletions":70,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -916,1 +916,1 @@\n-  GrowableArray<ciInstanceKlass*> _list;\n+  GrowableArrayFromArray<ciInstanceKlass*> _interfaces;\n@@ -923,1 +923,0 @@\n-  void add(ciInstanceKlass* interface);\n@@ -927,2 +926,2 @@\n-  TypeInterfaces();\n-  TypeInterfaces(GrowableArray<ciInstanceKlass*>* interfaces);\n+\n+  TypeInterfaces(ciInstanceKlass** interfaces_base, int nb_interfaces);\n@@ -943,1 +942,1 @@\n-  bool empty() const { return _list.length() == 0; }\n+  bool empty() const { return _interfaces.length() == 0; }\n@@ -949,0 +948,1 @@\n+  static int compare(ciInstanceKlass** k1, ciInstanceKlass** k2);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -453,0 +453,2 @@\n+    \/\/ Note: Static initializers can theoretically be here, if JNI users manage\n+    \/\/ to get their jmethodID. Record them as plain methods.\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1903,11 +1903,0 @@\n-static bool select_method(const methodHandle& method, bool want_constructor) {\n-  bool is_ctor = (method->is_object_constructor());\n-  if (want_constructor) {\n-    return is_ctor;\n-  } else {\n-    return (!is_ctor &&\n-            !method->is_class_initializer() &&\n-            !method->is_overpass());\n-  }\n-}\n-\n@@ -1946,0 +1935,1 @@\n+  \/\/ Select methods matching the criteria.\n@@ -1947,6 +1937,11 @@\n-    methodHandle method(THREAD, methods->at(i));\n-    if (select_method(method, want_constructor)) {\n-      if (!publicOnly || method->is_public()) {\n-        idnums->push(method->method_idnum());\n-        ++num_methods;\n-      }\n+    Method* method = methods->at(i);\n+    if (want_constructor && !method->is_object_constructor()) {\n+      continue;\n+    }\n+    if (!want_constructor &&\n+        (method->is_object_constructor() || method->is_class_initializer() ||\n+         method->is_overpass())) {\n+      continue;\n+    }\n+    if (publicOnly && !method->is_public()) {\n+      continue;\n@@ -1954,0 +1949,2 @@\n+    idnums->push(method->method_idnum());\n+    ++num_methods;\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -318,0 +318,1 @@\n+      assert(!m->is_class_initializer(), \"Cannot be static initializer\");\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -340,0 +340,5 @@\n+\/\/ Return true if the key matches the --module-path property name (\"jdk.module.path\").\n+bool Arguments::is_module_path_property(const char* key) {\n+  return (strcmp(key, MODULE_PROPERTY_PREFIX PATH) == 0);\n+}\n+\n@@ -1820,21 +1825,0 @@\n-  if (AMD64_ONLY(false &&) AARCH64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypePassFieldsAsArgs)) {\n-    FLAG_SET_CMDLINE(InlineTypePassFieldsAsArgs, false);\n-    warning(\"InlineTypePassFieldsAsArgs is not supported on this platform\");\n-  }\n-\n-  if (AMD64_ONLY(false &&) AARCH64_ONLY(false &&) !FLAG_IS_DEFAULT(InlineTypeReturnedAsFields)) {\n-    FLAG_SET_CMDLINE(InlineTypeReturnedAsFields, false);\n-    warning(\"InlineTypeReturnedAsFields is not supported on this platform\");\n-  }\n-\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64) && !defined(S390)\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    FLAG_SET_CMDLINE(LockingMode, LM_LEGACY);\n-    warning(\"New lightweight locking not supported on this platform\");\n-  }\n-  if (UseObjectMonitorTable) {\n-    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n-    warning(\"UseObjectMonitorTable not supported on this platform\");\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -465,0 +465,1 @@\n+  static bool is_module_path_property(const char* key);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -477,1 +477,1 @@\n-  bool const jvmci_enabled = JVMCI_ONLY(UseJVMCICompiler) NOT_JVMCI(false);\n+  bool const jvmci_enabled = JVMCI_ONLY(EnableJVMCI) NOT_JVMCI(false);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -292,3 +292,0 @@\n-  product(size_t, InlineCacheBufferSize, 10*K, EXPERIMENTAL,                \\\n-          \"InlineCacheBuffer size\")                                         \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -491,0 +491,1 @@\n+  _unlocked_inflated_monitor(nullptr),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -468,0 +468,1 @@\n+  ObjectMonitor* _unlocked_inflated_monitor;\n@@ -619,0 +620,6 @@\n+  \/\/ Support for SharedRuntime::monitor_exit_helper()\n+  ObjectMonitor* unlocked_inflated_monitor() const { return _unlocked_inflated_monitor; }\n+  void clear_unlocked_inflated_monitor() {\n+    _unlocked_inflated_monitor = nullptr;\n+  }\n+\n@@ -836,0 +843,1 @@\n+  static ByteSize unlocked_inflated_monitor_offset() { return byte_offset_of(JavaThread, _unlocked_inflated_monitor); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -773,1 +773,1 @@\n-  \/\/ Allow sun.reflect.ConstantPool to refer to <clinit> methods as java.lang.reflect.Methods.\n+  \/\/ Allow jdk.internal.reflect.ConstantPool to refer to <clinit> methods as java.lang.reflect.Methods.\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -659,1 +659,1 @@\n-  if (EnableJVMCI && UseJVMCICompiler) {\n+  if (EnableJVMCI) {\n@@ -2060,0 +2060,20 @@\n+\n+  \/\/ Check if C2_MacroAssembler::fast_unlock() or\n+  \/\/ C2_MacroAssembler::fast_unlock_lightweight() unlocked an inflated\n+  \/\/ monitor before going slow path.  Since there is no safepoint\n+  \/\/ polling when calling into the VM, we can be sure that the monitor\n+  \/\/ hasn't been deallocated.\n+  ObjectMonitor* m = current->unlocked_inflated_monitor();\n+  if (m != nullptr) {\n+    assert(m->owner_raw() != current, \"must be\");\n+    current->clear_unlocked_inflated_monitor();\n+\n+    \/\/ We need to reacquire the lock before we can call ObjectSynchronizer::exit().\n+    if (!m->try_enter(current, \/*check_for_recursion*\/ false)) {\n+      \/\/ Some other thread acquired the lock (or the monitor was\n+      \/\/ deflated). Either way we are done.\n+      current->dec_held_monitor_count();\n+      return;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+address StubRoutines::_dtanh = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -284,0 +284,1 @@\n+  static address _dtanh;\n@@ -478,0 +479,1 @@\n+  static address dtanh()               { return _dtanh; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-  template(ICBufferFull)                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,6 +63,0 @@\n-\/\/ empty vm op, when forcing a safepoint due to inline cache buffers being full\n-class VM_ICBufferFull: public VM_EmptyOperation {\n- public:\n-  VMOp_Type type() const { return VMOp_ICBufferFull; }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -378,3 +378,3 @@\n-     static_field(CompressedOops,              _narrow_oop._base,                             address)                               \\\n-     static_field(CompressedOops,              _narrow_oop._shift,                            int)                                   \\\n-     static_field(CompressedOops,              _narrow_oop._use_implicit_null_checks,         bool)                                  \\\n+     static_field(CompressedOops,              _base,                                         address)                               \\\n+     static_field(CompressedOops,              _shift,                                        int)                                   \\\n+     static_field(CompressedOops,              _use_implicit_null_checks,                     bool)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2016,0 +2016,32 @@\n+\/\/ Support class used to generate HPROF_LOAD_CLASS records\n+\n+class LoadedClassDumper : public LockedClassesDo {\n+ private:\n+  AbstractDumpWriter* _writer;\n+  GrowableArray<Klass*>* _klass_map;\n+  u4 _class_serial_num;\n+  AbstractDumpWriter* writer() const { return _writer; }\n+  void add_class_serial_number(Klass* k, int serial_num) {\n+    _klass_map->at_put_grow(serial_num, k);\n+  }\n+ public:\n+  LoadedClassDumper(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map)\n+    : _writer(writer), _klass_map(klass_map), _class_serial_num(0) {}\n+\n+  void do_klass(Klass* k) {\n+    \/\/ len of HPROF_LOAD_CLASS record\n+    u4 remaining = 2 * oopSize + 2 * sizeof(u4);\n+    DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);\n+    \/\/ class serial number is just a number\n+    writer()->write_u4(++_class_serial_num);\n+    \/\/ class ID\n+    writer()->write_classID(k);\n+    \/\/ add the Klass* and class serial number pair\n+    add_class_serial_number(k, _class_serial_num);\n+    writer()->write_u4(STACK_TRACE_ID);\n+    \/\/ class name ID\n+    Symbol* name = k->name();\n+    writer()->write_symbolID(name);\n+  }\n+};\n+\n@@ -2700,3 +2732,1 @@\n-  static VM_HeapDumper*   _global_dumper;\n-  static DumpWriter*      _global_writer;\n-  DumpWriter*             _local_writer;\n+  DumpWriter*             _writer;\n@@ -2732,14 +2762,1 @@\n-  \/\/ accessors and setters\n-  static VM_HeapDumper* dumper()         {  assert(_global_dumper != nullptr, \"Error\"); return _global_dumper; }\n-  static DumpWriter* writer()            {  assert(_global_writer != nullptr, \"Error\"); return _global_writer; }\n-\n-  void set_global_dumper() {\n-    assert(_global_dumper == nullptr, \"Error\");\n-    _global_dumper = this;\n-  }\n-  void set_global_writer() {\n-    assert(_global_writer == nullptr, \"Error\");\n-    _global_writer = _local_writer;\n-  }\n-  void clear_global_dumper() { _global_dumper = nullptr; }\n-  void clear_global_writer() { _global_writer = nullptr; }\n+  DumpWriter* writer() const { return _writer; }\n@@ -2749,3 +2766,0 @@\n-  \/\/ writes a HPROF_LOAD_CLASS record to global writer\n-  static void do_load_class(Klass* k);\n-\n@@ -2755,4 +2769,0 @@\n-  void add_class_serial_number(Klass* k, int serial_num) {\n-    _klass_map->at_put_grow(serial_num, k);\n-  }\n-\n@@ -2773,1 +2783,1 @@\n-    _local_writer = writer;\n+    _writer = writer;\n@@ -2829,3 +2839,0 @@\n-VM_HeapDumper* VM_HeapDumper::_global_dumper = nullptr;\n-DumpWriter*    VM_HeapDumper::_global_writer = nullptr;\n-\n@@ -2845,25 +2852,0 @@\n-\/\/ writes a HPROF_LOAD_CLASS record for the class\n-void VM_HeapDumper::do_load_class(Klass* k) {\n-  static u4 class_serial_num = 0;\n-\n-  \/\/ len of HPROF_LOAD_CLASS record\n-  u4 remaining = 2*oopSize + 2*sizeof(u4);\n-\n-  DumperSupport::write_header(writer(), HPROF_LOAD_CLASS, remaining);\n-\n-  \/\/ class serial number is just a number\n-  writer()->write_u4(++class_serial_num);\n-\n-  \/\/ class ID\n-  writer()->write_classID(k);\n-\n-  \/\/ add the Klass* and class serial number pair\n-  dumper()->add_class_serial_number(k, class_serial_num);\n-\n-  writer()->write_u4(STACK_TRACE_ID);\n-\n-  \/\/ class name ID\n-  Symbol* name = k->name();\n-  writer()->write_symbolID(name);\n-}\n-\n@@ -2946,5 +2928,0 @@\n-  \/\/ At this point we should be the only dumper active, so\n-  \/\/ the following should be safe.\n-  set_global_dumper();\n-  set_global_writer();\n-\n@@ -2962,4 +2939,0 @@\n-\n-  \/\/ Now we clear the global variables, so that a future dumper can run.\n-  clear_global_dumper();\n-  clear_global_writer();\n@@ -3003,2 +2976,2 @@\n-      LockedClassesDo locked_load_classes(&do_load_class);\n-      ClassLoaderDataGraph::classes_do(&locked_load_classes);\n+      LoadedClassDumper loaded_class_dumper(writer(), _klass_map);\n+      ClassLoaderDataGraph::classes_do(&loaded_class_dumper);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":37,"deletions":64,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,4 +36,4 @@\n- * The Boolean class wraps a value of the primitive type\n- * {@code boolean} in an object. An object of type\n- * {@code Boolean} contains a single field whose type is\n- * {@code boolean}.\n+ * The {@code Boolean} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code boolean}. An object of type {@code Boolean} contains a\n+ * single field whose type is {@code boolean}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Boolean.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,4 +42,4 @@\n- *\n- * The {@code Byte} class wraps a value of primitive type {@code byte}\n- * in an object.  An object of type {@code Byte} contains a single\n- * field whose type is {@code byte}.\n+ * The {@code Byte} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code byte}. An object of type {@code Byte} contains a\n+ * single field whose type is {@code byte}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,6 +47,6 @@\n- * The {@code Character} class wraps a value of the primitive\n- * type {@code char} in an object. An object of class\n- * {@code Character} contains a single field whose type is\n- * {@code char}.\n- * <p>\n- * In addition, this class provides a large number of static methods for\n+ * The {@code Character} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code char}. An object of type {@code Character} contains a\n+ * single field whose type is {@code char}.\n+ *\n+ * <p>In addition, this class provides a large number of static methods for\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -144,1 +144,2 @@\n- * class or interface (or for {@code void}) using a <i>class literal<\/i>.\n+ * class or interface (or for {@code void}) using a <dfn>class literal<\/dfn>\n+ * (JLS {@jls 15.8.2}).\n@@ -148,1 +149,1 @@\n- * System.out.println(\"The name of class Foo is: \"+Foo.class.getName());\n+ * System.out.println(\"The name of class Foo is: \" + Foo.class.getName()); \/\/ @highlight substring=\"Foo.class\"\n@@ -154,1 +155,1 @@\n- * is situated in a <em>nest<\/em>. A <a id=\"nest\">nest<\/a> is a set of\n+ * is situated in a <dfn>{@index \"nest\"}<\/dfn>. A <a id=\"nest\">nest<\/a> is a set of\n@@ -157,1 +158,2 @@\n- * The classes and interfaces are known as <em>nestmates<\/em>.\n+ * The classes and interfaces are known as <dfn>{@index \"nestmates\"}<\/dfn>\n+ * (JVMS {@jvms 4.7.29}).\n@@ -159,1 +161,1 @@\n- * <em>nest host<\/em>, and enumerates the other nestmates which\n+ * <dfn>nest host<\/dfn> (JVMS {@jvms 4.7.28}), and enumerates the other nestmates which\n@@ -171,1 +173,1 @@\n- * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() <em>hidden<\/em>}\n+ * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() <dfn>hidden<\/dfn>}\n@@ -220,1 +222,0 @@\n- * @jls 15.8.2 Class Literals\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,4 +40,4 @@\n- * The {@code Double} class wraps a value of the primitive type\n- * {@code double} in an object. An object of type\n- * {@code Double} contains a single field whose type is\n- * {@code double}.\n+ * The {@code Double} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code double}. An object of type {@code Double} contains a\n+ * single field whose type is {@code double}.\n@@ -152,1 +152,1 @@\n- * <dt><a id=fpNumericalEq><i>numerical equality<\/i><\/a> ({@code ==}\n+ * <dt><a id=fpNumericalEq><\/a><dfn>{@index \"numerical equality\"}<\/dfn> ({@code ==}\n@@ -162,1 +162,1 @@\n- * <dt><i>bit-wise equivalence<\/i>:<\/dt>\n+ * <dt><dfn>{@index \"bit-wise equivalence\"}<\/dfn>:<\/dt>\n@@ -172,1 +172,1 @@\n- * <dt><i><a id=repEquivalence>representation equivalence<\/a><\/i>:<\/dt>\n+ * <dt><dfn><a id=repEquivalence><\/a>{@index \"representation equivalence\"}<\/dfn>:<\/dt>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,4 +40,4 @@\n- * The {@code Float} class wraps a value of primitive type\n- * {@code float} in an object. An object of type\n- * {@code Float} contains a single field whose type is\n- * {@code float}.\n+ * The {@code Float} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code float}. An object of type {@code Float} contains a\n+ * single field whose type is {@code float}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,3 +49,4 @@\n- * The {@code Integer} class wraps a value of the primitive type\n- * {@code int} in an object. An object of type {@code Integer}\n- * contains a single field whose type is {@code int}.\n+ * The {@code Integer} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code int}. An object of type {@code Integer} contains a\n+ * single field whose type is {@code int}.\n@@ -67,2 +68,3 @@\n- * based on material from Henry S. Warren, Jr.'s <i>Hacker's\n- * Delight<\/i>, (Addison Wesley, 2002).\n+ * based on material from Henry S. Warren, Jr.'s <cite>Hacker's\n+ * Delight<\/cite>, (Addison Wesley, 2002) and <cite>Hacker's\n+ * Delight, Second Edition<\/cite>, (Pearson Education, 2013).\n@@ -1742,1 +1744,1 @@\n-     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, Second Edition, section 7.7)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,3 @@\n- * The {@code Long} class wraps a value of the primitive type {@code\n- * long} in an object. An object of type {@code Long} contains a\n+ * The {@code Long} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code long}. An object of type {@code Long} contains a\n@@ -67,2 +68,3 @@\n- * based on material from Henry S. Warren, Jr.'s <i>Hacker's\n- * Delight<\/i>, (Addison Wesley, 2002).\n+ * based on material from Henry S. Warren, Jr.'s <cite>Hacker's\n+ * Delight<\/cite>, (Addison Wesley, 2002) and <cite>Hacker's\n+ * Delight, Second Edition<\/cite>, (Pearson Education, 2013).\n@@ -1755,1 +1757,1 @@\n-     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, Second Edition, section 7.7)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-     * The {@code equals} method implements an equivalence relation\n+     * The {@code equals} method implements an <dfn>{@index \"equivalence relation\"}<\/dfn>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,3 @@\n- * The {@code Short} class wraps a value of primitive type {@code\n- * short} in an object.  An object of type {@code Short} contains a\n+ * The {@code Short} class is the {@linkplain\n+ * java.lang##wrapperClass wrapper class} for values of the primitive\n+ * type {@code short}. An object of type {@code Short} contains a\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -515,607 +515,1 @@\n-    \/** The integer value used to encode the NOP instruction. *\/\n-    int NOP             = 0;\n-\n-    \/** The integer value used to encode the ACONST_NULL instruction. *\/\n-    int ACONST_NULL     = 1;\n-\n-    \/** The integer value used to encode the ICONST_M1 instruction. *\/\n-    int ICONST_M1       = 2;\n-\n-    \/** The integer value used to encode the ICONST_0 instruction. *\/\n-    int ICONST_0        = 3;\n-\n-    \/** The integer value used to encode the ICONST_1 instruction. *\/\n-    int ICONST_1        = 4;\n-\n-    \/** The integer value used to encode the ICONST_2 instruction. *\/\n-    int ICONST_2        = 5;\n-\n-    \/** The integer value used to encode the ICONST_3 instruction. *\/\n-    int ICONST_3        = 6;\n-\n-    \/** The integer value used to encode the ICONST_4 instruction. *\/\n-    int ICONST_4        = 7;\n-\n-    \/** The integer value used to encode the ICONST_5 instruction. *\/\n-    int ICONST_5        = 8;\n-\n-    \/** The integer value used to encode the LCONST_0 instruction. *\/\n-    int LCONST_0        = 9;\n-\n-    \/** The integer value used to encode the LCONST_1 instruction. *\/\n-    int LCONST_1        = 10;\n-\n-    \/** The integer value used to encode the FCONST_0 instruction. *\/\n-    int FCONST_0        = 11;\n-\n-    \/** The integer value used to encode the FCONST_1 instruction. *\/\n-    int FCONST_1        = 12;\n-\n-    \/** The integer value used to encode the FCONST_2 instruction. *\/\n-    int FCONST_2        = 13;\n-\n-    \/** The integer value used to encode the DCONST_0 instruction. *\/\n-    int DCONST_0        = 14;\n-\n-    \/** The integer value used to encode the DCONST_1 instruction. *\/\n-    int DCONST_1        = 15;\n-\n-    \/** The integer value used to encode the BIPUSH instruction. *\/\n-    int BIPUSH          = 16;\n-\n-    \/** The integer value used to encode the SIPUSH instruction. *\/\n-    int SIPUSH          = 17;\n-\n-    \/** The integer value used to encode the LDC instruction. *\/\n-    int LDC             = 18;\n-\n-    \/** The integer value used to encode the LDC_W instruction. *\/\n-    int LDC_W           = 19;\n-\n-    \/** The integer value used to encode the LDC2_W instruction. *\/\n-    int LDC2_W          = 20;\n-\n-    \/** The integer value used to encode the ILOAD instruction. *\/\n-    int ILOAD           = 21;\n-\n-    \/** The integer value used to encode the LLOAD instruction. *\/\n-    int LLOAD           = 22;\n-\n-    \/** The integer value used to encode the FLOAD instruction. *\/\n-    int FLOAD           = 23;\n-\n-    \/** The integer value used to encode the DLOAD instruction. *\/\n-    int DLOAD           = 24;\n-\n-    \/** The integer value used to encode the ALOAD instruction. *\/\n-    int ALOAD           = 25;\n-\n-    \/** The integer value used to encode the ILOAD_0 instruction. *\/\n-    int ILOAD_0         = 26;\n-\n-    \/** The integer value used to encode the ILOAD_1 instruction. *\/\n-    int ILOAD_1         = 27;\n-\n-    \/** The integer value used to encode the ILOAD_2 instruction. *\/\n-    int ILOAD_2         = 28;\n-\n-    \/** The integer value used to encode the ILOAD_3 instruction. *\/\n-    int ILOAD_3         = 29;\n-\n-    \/** The integer value used to encode the LLOAD_0 instruction. *\/\n-    int LLOAD_0         = 30;\n-\n-    \/** The integer value used to encode the LLOAD_1 instruction. *\/\n-    int LLOAD_1         = 31;\n-\n-    \/** The integer value used to encode the LLOAD_2 instruction. *\/\n-    int LLOAD_2         = 32;\n-\n-    \/** The integer value used to encode the LLOAD_3 instruction. *\/\n-    int LLOAD_3         = 33;\n-\n-    \/** The integer value used to encode the FLOAD_0 instruction. *\/\n-    int FLOAD_0         = 34;\n-\n-    \/** The integer value used to encode the FLOAD_1 instruction. *\/\n-    int FLOAD_1         = 35;\n-\n-    \/** The integer value used to encode the FLOAD_2 instruction. *\/\n-    int FLOAD_2         = 36;\n-\n-    \/** The integer value used to encode the FLOAD_3 instruction. *\/\n-    int FLOAD_3         = 37;\n-\n-    \/** The integer value used to encode the DLOAD_0 instruction. *\/\n-    int DLOAD_0         = 38;\n-\n-    \/** The integer value used to encode the DLOAD_1 instruction. *\/\n-    int DLOAD_1         = 39;\n-\n-    \/** The integer value used to encode the DLOAD_2 instruction. *\/\n-    int DLOAD_2         = 40;\n-\n-    \/** The integer value used to encode the DLOAD_3 instruction. *\/\n-    int DLOAD_3         = 41;\n-\n-    \/** The integer value used to encode the ALOAD_0 instruction. *\/\n-    int ALOAD_0         = 42;\n-\n-    \/** The integer value used to encode the ALOAD_1 instruction. *\/\n-    int ALOAD_1         = 43;\n-\n-    \/** The integer value used to encode the ALOAD_2 instruction. *\/\n-    int ALOAD_2         = 44;\n-\n-    \/** The integer value used to encode the ALOAD_3 instruction. *\/\n-    int ALOAD_3         = 45;\n-\n-    \/** The integer value used to encode the IALOAD instruction. *\/\n-    int IALOAD          = 46;\n-\n-    \/** The integer value used to encode the LALOAD instruction. *\/\n-    int LALOAD          = 47;\n-\n-    \/** The integer value used to encode the FALOAD instruction. *\/\n-    int FALOAD          = 48;\n-\n-    \/** The integer value used to encode the DALOAD instruction. *\/\n-    int DALOAD          = 49;\n-\n-    \/** The integer value used to encode the AALOAD instruction. *\/\n-    int AALOAD          = 50;\n-\n-    \/** The integer value used to encode the BALOAD instruction. *\/\n-    int BALOAD          = 51;\n-\n-    \/** The integer value used to encode the CALOAD instruction. *\/\n-    int CALOAD          = 52;\n-\n-    \/** The integer value used to encode the SALOAD instruction. *\/\n-    int SALOAD          = 53;\n-\n-    \/** The integer value used to encode the ISTORE instruction. *\/\n-    int ISTORE          = 54;\n-\n-    \/** The integer value used to encode the LSTORE instruction. *\/\n-    int LSTORE          = 55;\n-\n-    \/** The integer value used to encode the FSTORE instruction. *\/\n-    int FSTORE          = 56;\n-\n-    \/** The integer value used to encode the DSTORE instruction. *\/\n-    int DSTORE          = 57;\n-\n-    \/** The integer value used to encode the ASTORE instruction. *\/\n-    int ASTORE          = 58;\n-\n-    \/** The integer value used to encode the ISTORE_0 instruction. *\/\n-    int ISTORE_0        = 59;\n-\n-    \/** The integer value used to encode the ISTORE_1 instruction. *\/\n-    int ISTORE_1        = 60;\n-\n-    \/** The integer value used to encode the ISTORE_2 instruction. *\/\n-    int ISTORE_2        = 61;\n-\n-    \/** The integer value used to encode the ISTORE_3 instruction. *\/\n-    int ISTORE_3        = 62;\n-\n-    \/** The integer value used to encode the LSTORE_0 instruction. *\/\n-    int LSTORE_0        = 63;\n-\n-    \/** The integer value used to encode the LSTORE_1 instruction. *\/\n-    int LSTORE_1        = 64;\n-\n-    \/** The integer value used to encode the LSTORE_2 instruction. *\/\n-    int LSTORE_2        = 65;\n-\n-    \/** The integer value used to encode the LSTORE_3 instruction. *\/\n-    int LSTORE_3        = 66;\n-\n-    \/** The integer value used to encode the FSTORE_0 instruction. *\/\n-    int FSTORE_0        = 67;\n-\n-    \/** The integer value used to encode the FSTORE_1 instruction. *\/\n-    int FSTORE_1        = 68;\n-\n-    \/** The integer value used to encode the FSTORE_2 instruction. *\/\n-    int FSTORE_2        = 69;\n-\n-    \/** The integer value used to encode the FSTORE_3 instruction. *\/\n-    int FSTORE_3        = 70;\n-\n-    \/** The integer value used to encode the DSTORE_0 instruction. *\/\n-    int DSTORE_0        = 71;\n-\n-    \/** The integer value used to encode the DSTORE_1 instruction. *\/\n-    int DSTORE_1        = 72;\n-\n-    \/** The integer value used to encode the DSTORE_2 instruction. *\/\n-    int DSTORE_2        = 73;\n-\n-    \/** The integer value used to encode the DSTORE_3 instruction. *\/\n-    int DSTORE_3        = 74;\n-\n-    \/** The integer value used to encode the ASTORE_0 instruction. *\/\n-    int ASTORE_0        = 75;\n-\n-    \/** The integer value used to encode the ASTORE_1 instruction. *\/\n-    int ASTORE_1        = 76;\n-\n-    \/** The integer value used to encode the ASTORE_2 instruction. *\/\n-    int ASTORE_2        = 77;\n-\n-    \/** The integer value used to encode the ASTORE_3 instruction. *\/\n-    int ASTORE_3        = 78;\n-\n-    \/** The integer value used to encode the IASTORE instruction. *\/\n-    int IASTORE         = 79;\n-\n-    \/** The integer value used to encode the LASTORE instruction. *\/\n-    int LASTORE         = 80;\n-\n-    \/** The integer value used to encode the FASTORE instruction. *\/\n-    int FASTORE         = 81;\n-\n-    \/** The integer value used to encode the DASTORE instruction. *\/\n-    int DASTORE         = 82;\n-\n-    \/** The integer value used to encode the AASTORE instruction. *\/\n-    int AASTORE         = 83;\n-\n-    \/** The integer value used to encode the BASTORE instruction. *\/\n-    int BASTORE         = 84;\n-\n-    \/** The integer value used to encode the CASTORE instruction. *\/\n-    int CASTORE         = 85;\n-\n-    \/** The integer value used to encode the SASTORE instruction. *\/\n-    int SASTORE         = 86;\n-\n-    \/** The integer value used to encode the POP instruction. *\/\n-    int POP             = 87;\n-\n-    \/** The integer value used to encode the POP2 instruction. *\/\n-    int POP2            = 88;\n-\n-    \/** The integer value used to encode the DUP instruction. *\/\n-    int DUP             = 89;\n-\n-    \/** The integer value used to encode the DUP_X1 instruction. *\/\n-    int DUP_X1          = 90;\n-\n-    \/** The integer value used to encode the DUP_X2 instruction. *\/\n-    int DUP_X2          = 91;\n-\n-    \/** The integer value used to encode the DUP2 instruction. *\/\n-    int DUP2            = 92;\n-\n-    \/** The integer value used to encode the DUP2_X1 instruction. *\/\n-    int DUP2_X1         = 93;\n-\n-    \/** The integer value used to encode the DUP2_X2 instruction. *\/\n-    int DUP2_X2         = 94;\n-\n-    \/** The integer value used to encode the SWAP instruction. *\/\n-    int SWAP            = 95;\n-\n-    \/** The integer value used to encode the IADD instruction. *\/\n-    int IADD            = 96;\n-\n-    \/** The integer value used to encode the LADD instruction. *\/\n-    int LADD            = 97;\n-\n-    \/** The integer value used to encode the FADD instruction. *\/\n-    int FADD            = 98;\n-\n-    \/** The integer value used to encode the DADD instruction. *\/\n-    int DADD            = 99;\n-\n-    \/** The integer value used to encode the ISUB instruction. *\/\n-    int ISUB            = 100;\n-\n-    \/** The integer value used to encode the LSUB instruction. *\/\n-    int LSUB            = 101;\n-\n-    \/** The integer value used to encode the FSUB instruction. *\/\n-    int FSUB            = 102;\n-\n-    \/** The integer value used to encode the DSUB instruction. *\/\n-    int DSUB            = 103;\n-\n-    \/** The integer value used to encode the IMUL instruction. *\/\n-    int IMUL            = 104;\n-\n-    \/** The integer value used to encode the LMUL instruction. *\/\n-    int LMUL            = 105;\n-\n-    \/** The integer value used to encode the FMUL instruction. *\/\n-    int FMUL            = 106;\n-\n-    \/** The integer value used to encode the DMUL instruction. *\/\n-    int DMUL            = 107;\n-\n-    \/** The integer value used to encode the IDIV instruction. *\/\n-    int IDIV            = 108;\n-\n-    \/** The integer value used to encode the LDIV instruction. *\/\n-    int LDIV            = 109;\n-\n-    \/** The integer value used to encode the FDIV instruction. *\/\n-    int FDIV            = 110;\n-\n-    \/** The integer value used to encode the DDIV instruction. *\/\n-    int DDIV            = 111;\n-\n-    \/** The integer value used to encode the IREM instruction. *\/\n-    int IREM            = 112;\n-\n-    \/** The integer value used to encode the LREM instruction. *\/\n-    int LREM            = 113;\n-\n-    \/** The integer value used to encode the FREM instruction. *\/\n-    int FREM            = 114;\n-\n-    \/** The integer value used to encode the DREM instruction. *\/\n-    int DREM            = 115;\n-\n-    \/** The integer value used to encode the INEG instruction. *\/\n-    int INEG            = 116;\n-\n-    \/** The integer value used to encode the LNEG instruction. *\/\n-    int LNEG            = 117;\n-\n-    \/** The integer value used to encode the FNEG instruction. *\/\n-    int FNEG            = 118;\n-\n-    \/** The integer value used to encode the DNEG instruction. *\/\n-    int DNEG            = 119;\n-\n-    \/** The integer value used to encode the ISHL instruction. *\/\n-    int ISHL            = 120;\n-\n-    \/** The integer value used to encode the LSHL instruction. *\/\n-    int LSHL            = 121;\n-\n-    \/** The integer value used to encode the ISHR instruction. *\/\n-    int ISHR            = 122;\n-\n-    \/** The integer value used to encode the LSHR instruction. *\/\n-    int LSHR            = 123;\n-\n-    \/** The integer value used to encode the IUSHR instruction. *\/\n-    int IUSHR           = 124;\n-\n-    \/** The integer value used to encode the LUSHR instruction. *\/\n-    int LUSHR           = 125;\n-\n-    \/** The integer value used to encode the IAND instruction. *\/\n-    int IAND            = 126;\n-\n-    \/** The integer value used to encode the LAND instruction. *\/\n-    int LAND            = 127;\n-\n-    \/** The integer value used to encode the IOR instruction. *\/\n-    int IOR             = 128;\n-\n-    \/** The integer value used to encode the LOR instruction. *\/\n-    int LOR             = 129;\n-\n-    \/** The integer value used to encode the IXOR instruction. *\/\n-    int IXOR            = 130;\n-\n-    \/** The integer value used to encode the LXOR instruction. *\/\n-    int LXOR            = 131;\n-\n-    \/** The integer value used to encode the IINC instruction. *\/\n-    int IINC            = 132;\n-\n-    \/** The integer value used to encode the I2L instruction. *\/\n-    int I2L             = 133;\n-\n-    \/** The integer value used to encode the I2F instruction. *\/\n-    int I2F             = 134;\n-\n-    \/** The integer value used to encode the I2D instruction. *\/\n-    int I2D             = 135;\n-\n-    \/** The integer value used to encode the L2I instruction. *\/\n-    int L2I             = 136;\n-\n-    \/** The integer value used to encode the L2F instruction. *\/\n-    int L2F             = 137;\n-\n-    \/** The integer value used to encode the L2D instruction. *\/\n-    int L2D             = 138;\n-\n-    \/** The integer value used to encode the F2I instruction. *\/\n-    int F2I             = 139;\n-\n-    \/** The integer value used to encode the F2L instruction. *\/\n-    int F2L             = 140;\n-\n-    \/** The integer value used to encode the F2D instruction. *\/\n-    int F2D             = 141;\n-\n-    \/** The integer value used to encode the D2I instruction. *\/\n-    int D2I             = 142;\n-\n-    \/** The integer value used to encode the D2L instruction. *\/\n-    int D2L             = 143;\n-\n-    \/** The integer value used to encode the D2F instruction. *\/\n-    int D2F             = 144;\n-\n-    \/** The integer value used to encode the I2B instruction. *\/\n-    int I2B             = 145;\n-\n-    \/** The integer value used to encode the I2C instruction. *\/\n-    int I2C             = 146;\n-\n-    \/** The integer value used to encode the I2S instruction. *\/\n-    int I2S             = 147;\n-\n-    \/** The integer value used to encode the LCMP instruction. *\/\n-    int LCMP            = 148;\n-\n-    \/** The integer value used to encode the FCMPL instruction. *\/\n-    int FCMPL           = 149;\n-\n-    \/** The integer value used to encode the FCMPG instruction. *\/\n-    int FCMPG           = 150;\n-\n-    \/** The integer value used to encode the DCMPL instruction. *\/\n-    int DCMPL           = 151;\n-\n-    \/** The integer value used to encode the DCMPG instruction. *\/\n-    int DCMPG           = 152;\n-\n-    \/** The integer value used to encode the IFEQ instruction. *\/\n-    int IFEQ            = 153;\n-\n-    \/** The integer value used to encode the IFNE instruction. *\/\n-    int IFNE            = 154;\n-\n-    \/** The integer value used to encode the IFLT instruction. *\/\n-    int IFLT            = 155;\n-\n-    \/** The integer value used to encode the IFGE instruction. *\/\n-    int IFGE            = 156;\n-\n-    \/** The integer value used to encode the IFGT instruction. *\/\n-    int IFGT            = 157;\n-\n-    \/** The integer value used to encode the IFLE instruction. *\/\n-    int IFLE            = 158;\n-\n-    \/** The integer value used to encode the IF_ICMPEQ instruction. *\/\n-    int IF_ICMPEQ       = 159;\n-\n-    \/** The integer value used to encode the IF_ICMPNE instruction. *\/\n-    int IF_ICMPNE       = 160;\n-\n-    \/** The integer value used to encode the IF_ICMPLT instruction. *\/\n-    int IF_ICMPLT       = 161;\n-\n-    \/** The integer value used to encode the IF_ICMPGE instruction. *\/\n-    int IF_ICMPGE       = 162;\n-\n-    \/** The integer value used to encode the IF_ICMPGT instruction. *\/\n-    int IF_ICMPGT       = 163;\n-\n-    \/** The integer value used to encode the IF_ICMPLE instruction. *\/\n-    int IF_ICMPLE       = 164;\n-\n-    \/** The integer value used to encode the IF_ACMPEQ instruction. *\/\n-    int IF_ACMPEQ       = 165;\n-\n-    \/** The integer value used to encode the IF_ACMPNE instruction. *\/\n-    int IF_ACMPNE       = 166;\n-\n-    \/** The integer value used to encode the GOTO instruction. *\/\n-    int GOTO            = 167;\n-\n-    \/** The integer value used to encode the JSR instruction. *\/\n-    int JSR             = 168;\n-\n-    \/** The integer value used to encode the RET instruction. *\/\n-    int RET             = 169;\n-\n-    \/** The integer value used to encode the TABLESWITCH instruction. *\/\n-    int TABLESWITCH     = 170;\n-\n-    \/** The integer value used to encode the LOOKUPSWITCH instruction. *\/\n-    int LOOKUPSWITCH    = 171;\n-\n-    \/** The integer value used to encode the IRETURN instruction. *\/\n-    int IRETURN         = 172;\n-\n-    \/** The integer value used to encode the LRETURN instruction. *\/\n-    int LRETURN         = 173;\n-\n-    \/** The integer value used to encode the FRETURN instruction. *\/\n-    int FRETURN         = 174;\n-\n-    \/** The integer value used to encode the DRETURN instruction. *\/\n-    int DRETURN         = 175;\n-\n-    \/** The integer value used to encode the ARETURN instruction. *\/\n-    int ARETURN         = 176;\n-\n-    \/** The integer value used to encode the RETURN instruction. *\/\n-    int RETURN          = 177;\n-\n-    \/** The integer value used to encode the GETSTATIC instruction. *\/\n-    int GETSTATIC       = 178;\n-\n-    \/** The integer value used to encode the PUTSTATIC instruction. *\/\n-    int PUTSTATIC       = 179;\n-\n-    \/** The integer value used to encode the GETFIELD instruction. *\/\n-    int GETFIELD        = 180;\n-\n-    \/** The integer value used to encode the PUTFIELD instruction. *\/\n-    int PUTFIELD        = 181;\n-\n-    \/** The integer value used to encode the INVOKEVIRTUAL instruction. *\/\n-    int INVOKEVIRTUAL   = 182;\n-\n-    \/** The integer value used to encode the INVOKESPECIAL instruction. *\/\n-    int INVOKESPECIAL   = 183;\n-\n-    \/** The integer value used to encode the INVOKESTATIC instruction. *\/\n-    int INVOKESTATIC    = 184;\n-\n-    \/** The integer value used to encode the INVOKEINTERFACE instruction. *\/\n-    int INVOKEINTERFACE = 185;\n-\n-    \/** The integer value used to encode the INVOKEDYNAMIC instruction. *\/\n-    int INVOKEDYNAMIC   = 186;\n-\n-    \/** The integer value used to encode the NEW instruction. *\/\n-    int NEW             = 187;\n-\n-    \/** The integer value used to encode the NEWARRAY instruction. *\/\n-    int NEWARRAY        = 188;\n-\n-    \/** The integer value used to encode the ANEWARRAY instruction. *\/\n-    int ANEWARRAY       = 189;\n-\n-    \/** The integer value used to encode the ARRAYLENGTH instruction. *\/\n-    int ARRAYLENGTH     = 190;\n-\n-    \/** The integer value used to encode the ATHROW instruction. *\/\n-    int ATHROW          = 191;\n-\n-    \/** The integer value used to encode the CHECKCAST instruction. *\/\n-    int CHECKCAST       = 192;\n-\n-    \/** The integer value used to encode the INSTANCEOF instruction. *\/\n-    int INSTANCEOF      = 193;\n-\n-    \/** The integer value used to encode the MONITORENTER instruction. *\/\n-    int MONITORENTER    = 194;\n-\n-    \/** The integer value used to encode the MONITOREXIT instruction. *\/\n-    int MONITOREXIT     = 195;\n-\n-    \/** The integer value used to encode the WIDE instruction. *\/\n-    int WIDE            = 196;\n-\n-    \/** The integer value used to encode the MULTIANEWARRAY instruction. *\/\n-    int MULTIANEWARRAY  = 197;\n-\n-    \/** The integer value used to encode the IFNULL instruction. *\/\n-    int IFNULL          = 198;\n-\n-    \/** The integer value used to encode the IFNONNULL instruction. *\/\n-    int IFNONNULL       = 199;\n-\n-    \/** The integer value used to encode the GOTO_W instruction. *\/\n-    int GOTO_W          = 200;\n-\n-    \/** The integer value used to encode the JSR_W instruction. *\/\n-    int JSR_W           = 201;\n-\n-    \/** The value of PUBLIC access and property modifier. *\/\n+    \/** The bit mask of PUBLIC access and property modifier. *\/\n@@ -1124,1 +518,1 @@\n-    \/** The value of PROTECTED access and property modifier. *\/\n+    \/** The bit mask of PROTECTED access and property modifier. *\/\n@@ -1127,1 +521,1 @@\n-    \/** The value of PRIVATE access and property modifier. *\/\n+    \/** The bit mask of PRIVATE access and property modifier. *\/\n@@ -1130,1 +524,1 @@\n-    \/** The value of INTERFACE access and property modifier. *\/\n+    \/** The bit mask of INTERFACE access and property modifier. *\/\n@@ -1133,1 +527,1 @@\n-    \/** The value of ENUM access and property modifier. *\/\n+    \/** The bit mask of ENUM access and property modifier. *\/\n@@ -1136,1 +530,1 @@\n-    \/** The value of ANNOTATION access and property modifier. *\/\n+    \/** The bit mask of ANNOTATION access and property modifier. *\/\n@@ -1139,1 +533,1 @@\n-    \/** The value of SUPER access and property modifier. *\/\n+    \/** The bit mask of SUPER access and property modifier. *\/\n@@ -1142,1 +536,1 @@\n-    \/** The value of IDENTITY access and property modifier. *\/\n+    \/** The bit mask of IDENTITY access and property modifier. *\/\n@@ -1145,1 +539,1 @@\n-    \/** The value of ABSTRACT access and property modifier. *\/\n+    \/** The bit mask of ABSTRACT access and property modifier. *\/\n@@ -1148,1 +542,1 @@\n-    \/** The value of VOLATILE access and property modifier. *\/\n+    \/** The bit mask of VOLATILE access and property modifier. *\/\n@@ -1151,1 +545,1 @@\n-    \/** The value of TRANSIENT access and property modifier. *\/\n+    \/** The bit mask of TRANSIENT access and property modifier. *\/\n@@ -1154,1 +548,1 @@\n-    \/** The value of SYNTHETIC access and property modifier. *\/\n+    \/** The bit mask of SYNTHETIC access and property modifier. *\/\n@@ -1157,1 +551,1 @@\n-    \/** The value of STATIC access and property modifier. *\/\n+    \/** The bit mask of STATIC access and property modifier. *\/\n@@ -1160,1 +554,1 @@\n-    \/** The value of FINAL access and property modifier. *\/\n+    \/** The bit mask of FINAL access and property modifier. *\/\n@@ -1163,1 +557,1 @@\n-    \/** The value of SYNCHRONIZED access and property modifier. *\/\n+    \/** The bit mask of SYNCHRONIZED access and property modifier. *\/\n@@ -1166,1 +560,1 @@\n-    \/** The value of BRIDGE access and property modifier. *\/\n+    \/** The bit mask of BRIDGE access and property modifier. *\/\n@@ -1169,1 +563,1 @@\n-    \/** The value of VARARGS access and property modifier. *\/\n+    \/** The bit mask of VARARGS access and property modifier. *\/\n@@ -1172,1 +566,1 @@\n-    \/** The value of NATIVE access and property modifier. *\/\n+    \/** The bit mask of NATIVE access and property modifier. *\/\n@@ -1175,1 +569,1 @@\n-    \/** The value of STRICT access and property modifier. *\/\n+    \/** The bit mask of STRICT access and property modifier. *\/\n@@ -1178,1 +572,1 @@\n-    \/** The value of MODULE access and property modifier. *\/\n+    \/** The bit mask of MODULE access and property modifier. *\/\n@@ -1181,1 +575,1 @@\n-    \/** The value of OPEN access and property modifier. *\/\n+    \/** The bit mask of OPEN access and property modifier. *\/\n@@ -1184,1 +578,1 @@\n-    \/** The value of MANDATED access and property modifier. *\/\n+    \/** The bit mask of MANDATED access and property modifier. *\/\n@@ -1187,1 +581,1 @@\n-    \/** The value of TRANSITIVE access and property modifier. *\/\n+    \/** The bit mask of TRANSITIVE access and property modifier. *\/\n@@ -1190,1 +584,1 @@\n-    \/** The value of STATIC_PHASE access and property modifier. *\/\n+    \/** The bit mask of STATIC_PHASE access and property modifier. *\/\n@@ -1193,222 +587,0 @@\n-    \/** The value of STATEMENT {@link CharacterRangeInfo} kind. *\/\n-    int CRT_STATEMENT       = 0x0001;\n-\n-    \/** The value of BLOCK {@link CharacterRangeInfo} kind. *\/\n-    int CRT_BLOCK           = 0x0002;\n-\n-    \/** The value of ASSIGNMENT {@link CharacterRangeInfo} kind. *\/\n-    int CRT_ASSIGNMENT      = 0x0004;\n-\n-    \/** The value of FLOW_CONTROLLER {@link CharacterRangeInfo} kind. *\/\n-    int CRT_FLOW_CONTROLLER = 0x0008;\n-\n-    \/** The value of FLOW_TARGET {@link CharacterRangeInfo} kind. *\/\n-    int CRT_FLOW_TARGET     = 0x0010;\n-\n-    \/** The value of INVOKE {@link CharacterRangeInfo} kind. *\/\n-    int CRT_INVOKE          = 0x0020;\n-\n-    \/** The value of CREATE {@link CharacterRangeInfo} kind. *\/\n-    int CRT_CREATE          = 0x0040;\n-\n-    \/** The value of BRANCH_TRUE {@link CharacterRangeInfo} kind. *\/\n-    int CRT_BRANCH_TRUE     = 0x0080;\n-\n-    \/** The value of BRANCH_FALSE {@link CharacterRangeInfo} kind. *\/\n-    int CRT_BRANCH_FALSE    = 0x0100;\n-\n-    \/** The value of constant pool tag CLASS. *\/\n-    int TAG_CLASS = 7;\n-\n-    \/** The value of constant pool tag CONSTANTDYNAMIC. *\/\n-    int TAG_CONSTANTDYNAMIC = 17;\n-\n-    \/** The value of constant pool tag DOUBLE. *\/\n-    int TAG_DOUBLE = 6;\n-\n-    \/** The value of constant pool tag FIELDREF. *\/\n-    int TAG_FIELDREF = 9;\n-\n-    \/** The value of constant pool tag FLOAT. *\/\n-    int TAG_FLOAT = 4;\n-\n-    \/** The value of constant pool tag INTEGER. *\/\n-    int TAG_INTEGER = 3;\n-\n-    \/** The value of constant pool tag INTERFACEMETHODREF. *\/\n-    int TAG_INTERFACEMETHODREF = 11;\n-\n-    \/** The value of constant pool tag INVOKEDYNAMIC. *\/\n-    int TAG_INVOKEDYNAMIC = 18;\n-\n-    \/** The value of constant pool tag LONG. *\/\n-    int TAG_LONG = 5;\n-\n-    \/** The value of constant pool tag METHODHANDLE. *\/\n-    int TAG_METHODHANDLE = 15;\n-\n-    \/** The value of constant pool tag METHODREF. *\/\n-    int TAG_METHODREF = 10;\n-\n-    \/** The value of constant pool tag METHODTYPE. *\/\n-    int TAG_METHODTYPE = 16;\n-\n-    \/** The value of constant pool tag MODULE. *\/\n-    int TAG_MODULE = 19;\n-\n-    \/** The value of constant pool tag NAMEANDTYPE. *\/\n-    int TAG_NAMEANDTYPE = 12;\n-\n-    \/** The value of constant pool tag PACKAGE. *\/\n-    int TAG_PACKAGE = 20;\n-\n-    \/** The value of constant pool tag STRING. *\/\n-    int TAG_STRING = 8;\n-\n-    \/** The value of constant pool tag UNICODE. *\/\n-    int TAG_UNICODE = 2;\n-\n-    \/** The value of constant pool tag UTF8. *\/\n-    int TAG_UTF8 = 1;\n-\n-    \/\/ annotation element values\n-\n-    \/** The value of annotation element value type AEV_BYTE. *\/\n-    int AEV_BYTE = 'B';\n-\n-    \/** The value of annotation element value type AEV_CHAR. *\/\n-    int AEV_CHAR = 'C';\n-\n-    \/** The value of annotation element value type AEV_DOUBLE. *\/\n-    int AEV_DOUBLE = 'D';\n-\n-    \/** The value of annotation element value type AEV_FLOAT. *\/\n-    int AEV_FLOAT = 'F';\n-\n-    \/** The value of annotation element value type AEV_INT. *\/\n-    int AEV_INT = 'I';\n-\n-    \/** The value of annotation element value type AEV_LONG. *\/\n-    int AEV_LONG = 'J';\n-\n-    \/** The value of annotation element value type AEV_SHORT. *\/\n-    int AEV_SHORT = 'S';\n-\n-    \/** The value of annotation element value type AEV_BOOLEAN. *\/\n-    int AEV_BOOLEAN = 'Z';\n-\n-    \/** The value of annotation element value type AEV_STRING. *\/\n-    int AEV_STRING = 's';\n-\n-    \/** The value of annotation element value type AEV_ENUM. *\/\n-    int AEV_ENUM = 'e';\n-\n-    \/** The value of annotation element value type AEV_CLASS. *\/\n-    int AEV_CLASS = 'c';\n-\n-    \/** The value of annotation element value type AEV_ANNOTATION. *\/\n-    int AEV_ANNOTATION = '@';\n-\n-    \/** The value of annotation element value type AEV_ARRAY. *\/\n-    int AEV_ARRAY = '[';\n-\n-    \/\/type annotations\n-\n-    \/** The value of type annotation target type CLASS_TYPE_PARAMETER. *\/\n-    int TAT_CLASS_TYPE_PARAMETER = 0x00;\n-\n-    \/** The value of type annotation target type METHOD_TYPE_PARAMETER. *\/\n-    int TAT_METHOD_TYPE_PARAMETER = 0x01;\n-\n-    \/** The value of type annotation target type CLASS_EXTENDS. *\/\n-    int TAT_CLASS_EXTENDS = 0x10;\n-\n-    \/** The value of type annotation target type CLASS_TYPE_PARAMETER_BOUND. *\/\n-    int TAT_CLASS_TYPE_PARAMETER_BOUND = 0x11;\n-\n-    \/** The value of type annotation target type METHOD_TYPE_PARAMETER_BOUND. *\/\n-    int TAT_METHOD_TYPE_PARAMETER_BOUND = 0x12;\n-\n-    \/** The value of type annotation target type FIELD. *\/\n-    int TAT_FIELD = 0x13;\n-\n-    \/** The value of type annotation target type METHOD_RETURN. *\/\n-    int TAT_METHOD_RETURN = 0x14;\n-\n-    \/** The value of type annotation target type METHOD_RECEIVER. *\/\n-    int TAT_METHOD_RECEIVER = 0x15;\n-\n-    \/** The value of type annotation target type METHOD_FORMAL_PARAMETER. *\/\n-    int TAT_METHOD_FORMAL_PARAMETER = 0x16;\n-\n-    \/** The value of type annotation target type THROWS. *\/\n-    int TAT_THROWS = 0x17;\n-\n-    \/** The value of type annotation target type LOCAL_VARIABLE. *\/\n-    int TAT_LOCAL_VARIABLE = 0x40;\n-\n-    \/** The value of type annotation target type RESOURCE_VARIABLE. *\/\n-    int TAT_RESOURCE_VARIABLE = 0x41;\n-\n-    \/** The value of type annotation target type EXCEPTION_PARAMETER. *\/\n-    int TAT_EXCEPTION_PARAMETER = 0x42;\n-\n-    \/** The value of type annotation target type INSTANCEOF. *\/\n-    int TAT_INSTANCEOF = 0x43;\n-\n-    \/** The value of type annotation target type NEW. *\/\n-    int TAT_NEW = 0x44;\n-\n-    \/** The value of type annotation target type CONSTRUCTOR_REFERENCE. *\/\n-    int TAT_CONSTRUCTOR_REFERENCE = 0x45;\n-\n-    \/** The value of type annotation target type METHOD_REFERENCE. *\/\n-    int TAT_METHOD_REFERENCE = 0x46;\n-\n-    \/** The value of type annotation target type CAST. *\/\n-    int TAT_CAST = 0x47;\n-\n-    \/** The value of type annotation target type CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT. *\/\n-    int TAT_CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT = 0x48;\n-\n-    \/** The value of type annotation target type METHOD_INVOCATION_TYPE_ARGUMENT. *\/\n-    int TAT_METHOD_INVOCATION_TYPE_ARGUMENT = 0x49;\n-\n-    \/** The value of type annotation target type CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT. *\/\n-    int TAT_CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT = 0x4A;\n-\n-    \/** The value of type annotation target type METHOD_REFERENCE_TYPE_ARGUMENT. *\/\n-    int TAT_METHOD_REFERENCE_TYPE_ARGUMENT = 0x4B;\n-\n-    \/\/stackmap verification types\n-\n-    \/** The value of verification type TOP. *\/\n-    int VT_TOP = 0;\n-\n-    \/** The value of verification type INTEGER. *\/\n-    int VT_INTEGER = 1;\n-\n-    \/** The value of verification type FLOAT. *\/\n-    int VT_FLOAT = 2;\n-\n-    \/** The value of verification type DOUBLE. *\/\n-    int VT_DOUBLE = 3;\n-\n-    \/** The value of verification type LONG. *\/\n-    int VT_LONG = 4;\n-\n-    \/** The value of verification type NULL. *\/\n-    int VT_NULL = 5;\n-\n-    \/** The value of verification type UNINITIALIZED_THIS. *\/\n-    int VT_UNINITIALIZED_THIS = 6;\n-\n-    \/** The value of verification type OBJECT. *\/\n-    int VT_OBJECT = 7;\n-\n-    \/** The value of verification type UNINITIALIZED. *\/\n-    int VT_UNINITIALIZED = 8;\n-\n-    \/** The value of default class access flags *\/\n-    int DEFAULT_CLASS_FLAGS = ACC_PUBLIC;\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":24,"deletions":852,"binary":false,"changes":876,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -43,0 +44,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -2245,8 +2247,12 @@\n-        static class ClassFile {\n-            final String name;  \/\/ internal name\n-            final int accessFlags;\n-            final byte[] bytes;\n-            ClassFile(String name, int accessFlags, byte[] bytes) {\n-                this.name = name;\n-                this.accessFlags = accessFlags;\n-                this.bytes = bytes;\n+        \/**\n+         * This method checks the class file version and the structure of `this_class`.\n+         * and checks if the bytes is a class or interface (ACC_MODULE flag not set)\n+         * that is in the named package.\n+         *\n+         * @throws IllegalArgumentException if ACC_MODULE flag is set in access flags\n+         * or the class is not in the given package name.\n+         *\/\n+        static String validateAndFindInternalName(byte[] bytes, String pkgName) {\n+            int magic = readInt(bytes, 0);\n+            if (magic != ClassFile.MAGIC_NUMBER) {\n+                throw new ClassFormatError(\"Incompatible magic value: \" + magic);\n@@ -2254,0 +2260,4 @@\n+            \/\/ We have to read major and minor this way as ClassFile API throws IAE\n+            \/\/ yet we want distinct ClassFormatError and UnsupportedClassVersionError\n+            int minor = readUnsignedShort(bytes, 4);\n+            int major = readUnsignedShort(bytes, 6);\n@@ -2255,2 +2265,2 @@\n-            static ClassFile newInstanceNoCheck(String name, byte[] bytes) {\n-                return new ClassFile(name, 0, bytes);\n+            if (!VM.isSupportedClassFileVersion(major, minor)) {\n+                throw new UnsupportedClassVersionError(\"Unsupported class file version \" + major + \".\" + minor);\n@@ -2259,18 +2269,17 @@\n-            \/**\n-             * This method checks the class file version and the structure of `this_class`.\n-             * and checks if the bytes is a class or interface (ACC_MODULE flag not set)\n-             * that is in the named package.\n-             *\n-             * @throws IllegalArgumentException if ACC_MODULE flag is set in access flags\n-             * or the class is not in the given package name.\n-             *\/\n-            static ClassFile newInstance(byte[] bytes, String pkgName) {\n-                var cf = readClassFile(bytes);\n-\n-                \/\/ check if it's in the named package\n-                int index = cf.name.lastIndexOf('\/');\n-                String pn = (index == -1) ? \"\" : cf.name.substring(0, index).replace('\/', '.');\n-                if (!pn.equals(pkgName)) {\n-                    throw newIllegalArgumentException(cf.name + \" not in same package as lookup class\");\n-                }\n-                return cf;\n+            String name;\n+            ClassDesc sym;\n+            int accessFlags;\n+            try {\n+                ClassModel cm = ClassFile.of().parse(bytes);\n+                var thisClass = cm.thisClass();\n+                name = thisClass.asInternalName();\n+                sym = thisClass.asSymbol();\n+                accessFlags = cm.flags().flagsMask();\n+            } catch (IllegalArgumentException e) {\n+                ClassFormatError cfe = new ClassFormatError();\n+                cfe.initCause(e);\n+                throw cfe;\n+            }\n+            \/\/ must be a class or interface\n+            if ((accessFlags & ACC_MODULE) != 0) {\n+                throw newIllegalArgumentException(\"Not a class or interface: ACC_MODULE flag is set\");\n@@ -2279,27 +2288,3 @@\n-            private static ClassFile readClassFile(byte[] bytes) {\n-                int magic = readInt(bytes, 0);\n-                if (magic != 0xCAFEBABE) {\n-                    throw new ClassFormatError(\"Incompatible magic value: \" + magic);\n-                }\n-                int minor = readUnsignedShort(bytes, 4);\n-                int major = readUnsignedShort(bytes, 6);\n-                if (!VM.isSupportedClassFileVersion(major, minor)) {\n-                    throw new UnsupportedClassVersionError(\"Unsupported class file version \" + major + \".\" + minor);\n-                }\n-\n-                String name;\n-                int accessFlags;\n-                try {\n-                    ClassModel cm = java.lang.classfile.ClassFile.of().parse(bytes);\n-                    name = cm.thisClass().asInternalName();\n-                    accessFlags = cm.flags().flagsMask();\n-                } catch (IllegalArgumentException e) {\n-                    ClassFormatError cfe = new ClassFormatError();\n-                    cfe.initCause(e);\n-                    throw cfe;\n-                }\n-                \/\/ must be a class or interface\n-                if ((accessFlags & ACC_MODULE) != 0) {\n-                    throw newIllegalArgumentException(\"Not a class or interface: ACC_MODULE flag is set\");\n-                }\n-                return new ClassFile(name, accessFlags, bytes);\n+            String pn = sym.packageName();\n+            if (!pn.equals(pkgName)) {\n+                throw newIllegalArgumentException(name + \" not in same package as lookup class\");\n@@ -2308,8 +2293,6 @@\n-            private static int readInt(byte[] bytes, int offset) {\n-                if ((offset+4) > bytes.length) {\n-                    throw new ClassFormatError(\"Invalid ClassFile structure\");\n-                }\n-                return ((bytes[offset] & 0xFF) << 24)\n-                        | ((bytes[offset + 1] & 0xFF) << 16)\n-                        | ((bytes[offset + 2] & 0xFF) << 8)\n-                        | (bytes[offset + 3] & 0xFF);\n+            return name;\n+        }\n+\n+        private static int readInt(byte[] bytes, int offset) {\n+            if ((offset + 4) > bytes.length) {\n+                throw new ClassFormatError(\"Invalid ClassFile structure\");\n@@ -2317,0 +2300,5 @@\n+            return ((bytes[offset] & 0xFF) << 24)\n+                    | ((bytes[offset + 1] & 0xFF) << 16)\n+                    | ((bytes[offset + 2] & 0xFF) << 8)\n+                    | (bytes[offset + 3] & 0xFF);\n+        }\n@@ -2318,5 +2306,3 @@\n-            private static int readUnsignedShort(byte[] bytes, int offset) {\n-                if ((offset+2) > bytes.length) {\n-                    throw new ClassFormatError(\"Invalid ClassFile structure\");\n-                }\n-                return ((bytes[offset] & 0xFF) << 8) | (bytes[offset + 1] & 0xFF);\n+        private static int readUnsignedShort(byte[] bytes, int offset) {\n+            if ((offset+2) > bytes.length) {\n+                throw new ClassFormatError(\"Invalid ClassFile structure\");\n@@ -2324,0 +2310,1 @@\n+            return ((bytes[offset] & 0xFF) << 8) | (bytes[offset + 1] & 0xFF);\n@@ -2337,2 +2324,2 @@\n-            ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());\n-            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, defaultDumper());\n+            var internalName = validateAndFindInternalName(bytes, lookupClass().getPackageName());\n+            return new ClassDefiner(this, internalName, bytes, STRONG_LOADER_LINK, defaultDumper());\n@@ -2345,1 +2332,1 @@\n-         * @param name    internal name\n+         * @param internalName internal name\n@@ -2350,1 +2337,1 @@\n-        ClassDefiner makeClassDefiner(String name, byte[] bytes, ClassFileDumper dumper) {\n+        ClassDefiner makeClassDefiner(String internalName, byte[] bytes, ClassFileDumper dumper) {\n@@ -2352,2 +2339,1 @@\n-            ClassFile cf = ClassFile.newInstanceNoCheck(name, bytes);\n-            return new ClassDefiner(this, cf, STRONG_LOADER_LINK, dumper);\n+            return new ClassDefiner(this, internalName, bytes, STRONG_LOADER_LINK, dumper);\n@@ -2371,2 +2357,2 @@\n-            ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());\n-            return makeHiddenClassDefiner(cf, false, dumper, 0);\n+            var internalName = validateAndFindInternalName(bytes, lookupClass().getPackageName());\n+            return makeHiddenClassDefiner(internalName, bytes, false, dumper, 0);\n@@ -2394,2 +2380,2 @@\n-            ClassFile cf = ClassFile.newInstance(bytes, lookupClass().getPackageName());\n-            return makeHiddenClassDefiner(cf, accessVmAnnotations, defaultDumper(), flags);\n+            var internalName = validateAndFindInternalName(bytes, lookupClass().getPackageName());\n+            return makeHiddenClassDefiner(internalName, bytes, accessVmAnnotations, defaultDumper(), flags);\n@@ -2402,1 +2388,1 @@\n-         * @param name    internal name that specifies the prefix of the hidden class\n+         * @param internalName internal name that specifies the prefix of the hidden class\n@@ -2407,1 +2393,1 @@\n-        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, ClassFileDumper dumper) {\n+        ClassDefiner makeHiddenClassDefiner(String internalName, byte[] bytes, ClassFileDumper dumper) {\n@@ -2410,1 +2396,1 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), false, dumper, 0);\n+            return makeHiddenClassDefiner(internalName, bytes, false, dumper, 0);\n@@ -2417,1 +2403,1 @@\n-         * @param name    internal name that specifies the prefix of the hidden class\n+         * @param internalName internal name that specifies the prefix of the hidden class\n@@ -2423,1 +2409,1 @@\n-        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, ClassFileDumper dumper, int flags) {\n+        ClassDefiner makeHiddenClassDefiner(String internalName, byte[] bytes, ClassFileDumper dumper, int flags) {\n@@ -2426,1 +2412,1 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), false, dumper, flags);\n+            return makeHiddenClassDefiner(internalName, bytes, false, dumper, flags);\n@@ -2433,1 +2419,2 @@\n-         * @param cf ClassFile\n+         * @param internalName internal name\n+         * @param bytes Class byte array\n@@ -2438,1 +2425,2 @@\n-        private ClassDefiner makeHiddenClassDefiner(ClassFile cf,\n+        private ClassDefiner makeHiddenClassDefiner(String internalName,\n+                                                    byte[] bytes,\n@@ -2449,1 +2437,1 @@\n-            return new ClassDefiner(this, cf, flags, dumper);\n+            return new ClassDefiner(this, internalName, bytes, flags, dumper);\n@@ -2452,18 +2440,3 @@\n-        static class ClassDefiner {\n-            private final Lookup lookup;\n-            private final String name;  \/\/ internal name\n-            private final byte[] bytes;\n-            private final int classFlags;\n-            private final ClassFileDumper dumper;\n-\n-            private ClassDefiner(Lookup lookup, ClassFile cf, int flags, ClassFileDumper dumper) {\n-                assert ((flags & HIDDEN_CLASS) != 0 || (flags & STRONG_LOADER_LINK) == STRONG_LOADER_LINK);\n-                this.lookup = lookup;\n-                this.bytes = cf.bytes;\n-                this.name = cf.name;\n-                this.classFlags = flags;\n-                this.dumper = dumper;\n-            }\n-\n-            String internalName() {\n-                return name;\n+        record ClassDefiner(Lookup lookup, String internalName, byte[] bytes, int classFlags, ClassFileDumper dumper) {\n+            ClassDefiner {\n+                assert ((classFlags & HIDDEN_CLASS) != 0 || (classFlags & STRONG_LOADER_LINK) == STRONG_LOADER_LINK);\n@@ -2498,1 +2471,1 @@\n-                            .defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);\n+                            .defineClass(loader, lookupClass, internalName, bytes, pd, initialize, classFlags, classData);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":79,"deletions":106,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -117,0 +117,4 @@\n+    private static final String OBJECT_HASH_CODE_SIG;\n+    private static final String OBJECT_EQUALS_SIG;\n+    private static final String OBJECT_TO_STRING_SIG;\n+\n@@ -120,0 +124,1 @@\n+            OBJECT_HASH_CODE_SIG = OBJECT_HASH_CODE_METHOD.toShortSignature();\n@@ -121,0 +126,1 @@\n+            OBJECT_EQUALS_SIG = OBJECT_EQUALS_METHOD.toShortSignature();\n@@ -122,0 +128,1 @@\n+            OBJECT_TO_STRING_SIG = OBJECT_TO_STRING_METHOD.toShortSignature();\n@@ -455,3 +462,3 @@\n-        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, \"m0\"));\n-        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, \"m1\"));\n-        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, \"m2\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, OBJECT_HASH_CODE_SIG, \"m0\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, OBJECT_EQUALS_SIG, \"m1\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, OBJECT_TO_STRING_SIG, \"m2\"));\n@@ -535,1 +542,1 @@\n-        sigmethods.add(new ProxyMethod(m, sig, m.getSharedParameterTypes(), returnType,\n+        sigmethods.add(new ProxyMethod(m, sig, returnType,\n@@ -626,1 +633,1 @@\n-                            cob.aload(cob.parameterSlot(0))\n+                            cob.aload(0)\n@@ -630,1 +637,1 @@\n-                               .aload(cob.parameterSlot(0))\n+                               .aload(0)\n@@ -638,1 +645,1 @@\n-                               .aload(cob.parameterSlot(0))\n+                               .aload(0)\n@@ -659,1 +666,0 @@\n-        private final Class<?>[] parameterTypes;\n@@ -665,1 +671,1 @@\n-        private ProxyMethod(Method method, String sig, Class<?>[] parameterTypes,\n+        private ProxyMethod(Method method, String sig,\n@@ -670,1 +676,0 @@\n-            this.parameterTypes = parameterTypes;\n@@ -679,0 +684,4 @@\n+        private Class<?>[] parameterTypes() {\n+            return method.getSharedParameterTypes();\n+        }\n+\n@@ -684,3 +693,2 @@\n-        private ProxyMethod(Method method, String methodFieldName) {\n-            this(method, method.toShortSignature(),\n-                 method.getSharedParameterTypes(), method.getReturnType(),\n+        private ProxyMethod(Method method, String sig, String methodFieldName) {\n+            this(method, sig, method.getReturnType(),\n@@ -694,1 +702,1 @@\n-            var desc = methodTypeDesc(returnType, parameterTypes);\n+            var desc = methodTypeDesc(returnType, parameterTypes());\n@@ -697,1 +705,0 @@\n-            var catchList = computeUniqueCatchList(exceptionTypes);\n@@ -701,0 +708,1 @@\n+                        var catchList = computeUniqueCatchList(exceptionTypes);\n@@ -705,0 +713,1 @@\n+                        Class<?>[] parameterTypes = parameterTypes();\n@@ -793,0 +802,1 @@\n+            Class<?>[] parameterTypes = parameterTypes();\n@@ -826,4 +836,8 @@\n-            cob.ldc(cl.getName())\n-               .iconst_0() \/\/ false\n-               .aload(0)\/\/ classLoader\n-               .invokestatic(classForName);\n+            if (cl == Object.class) {\n+                cob.ldc(objectCE);\n+            } else {\n+                cob.ldc(cl.getName())\n+                        .iconst_0() \/\/ false\n+                        .aload(0)\/\/ classLoader\n+                        .invokestatic(classForName);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":33,"deletions":19,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -662,1 +662,1 @@\n-                    cb.ldc(integerLabel);\n+                    cb.loadConstant(integerLabel);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import static java.lang.classfile.ClassFile.*;\n@@ -64,0 +63,1 @@\n+import static java.lang.classfile.constantpool.PoolEntry.*;\n@@ -539,1 +539,1 @@\n-                        case ITEM_DOUBLE -> {\n+                        case DOUBLE -> {\n@@ -543,1 +543,1 @@\n-                        case ITEM_FLOAT ->\n+                        case FLOAT ->\n@@ -545,1 +545,1 @@\n-                        case ITEM_INTEGER ->\n+                        case INTEGER ->\n@@ -547,1 +547,1 @@\n-                        case ITEM_LONG ->  {\n+                        case LONG ->  {\n@@ -551,3 +551,3 @@\n-                        case ITEM_NULL -> ret.accept(\"null\");\n-                        case ITEM_TOP -> ret.accept(\"?\");\n-                        case ITEM_UNINITIALIZED_THIS -> ret.accept(\"THIS\");\n+                        case NULL -> ret.accept(\"null\");\n+                        case TOP -> ret.accept(\"?\");\n+                        case UNINITIALIZED_THIS -> ret.accept(\"THIS\");\n@@ -606,6 +606,6 @@\n-                            case TAG_INTERFACEMETHODREF -> \"InterfaceMethodref\";\n-                            case TAG_NAMEANDTYPE -> \"NameAndType\";\n-                            case TAG_METHODHANDLE -> \"MethodHandle\";\n-                            case TAG_METHODTYPE -> \"MethodType\";\n-                            case TAG_CONSTANTDYNAMIC -> \"Dynamic\";\n-                            case TAG_INVOKEDYNAMIC -> \"InvokeDynamic\";\n+                            case TAG_INTERFACE_METHODREF -> \"InterfaceMethodref\";\n+                            case TAG_NAME_AND_TYPE -> \"NameAndType\";\n+                            case TAG_METHOD_HANDLE -> \"MethodHandle\";\n+                            case TAG_METHOD_TYPE -> \"MethodType\";\n+                            case TAG_DYNAMIC -> \"Dynamic\";\n+                            case TAG_INVOKE_DYNAMIC -> \"InvokeDynamic\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2379,0 +2379,6 @@\n+        \/**\n+         * A supertype_index value of 65535 specifies that the annotation appears on the superclass\n+         * in an extends clause of a class declaration, see JVMS 4.7.20.1\n+         *\/\n+        public static final int SUPERCLASS_INDEX = 65535;\n+\n@@ -2388,1 +2394,1 @@\n-            t.supertype_field = addTypeAnnotations(t.supertype_field, classExtends(65535));\n+            t.supertype_field = addTypeAnnotations(t.supertype_field, classExtends(SUPERCLASS_INDEX));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import static java.lang.classfile.instruction.CharacterRange.*;\n@@ -150,1 +151,1 @@\n-                    if ((e.flags() & CRT_STATEMENT) != 0)\n+                    if ((e.flags() & FLAG_STATEMENT) != 0)\n@@ -152,1 +153,1 @@\n-                    if ((e.flags() & CRT_BLOCK) != 0)\n+                    if ((e.flags() & FLAG_BLOCK) != 0)\n@@ -154,1 +155,1 @@\n-                    if ((e.flags() & CRT_ASSIGNMENT) != 0)\n+                    if ((e.flags() & FLAG_ASSIGNMENT) != 0)\n@@ -156,1 +157,1 @@\n-                    if ((e.flags() & CRT_FLOW_CONTROLLER) != 0)\n+                    if ((e.flags() & FLAG_FLOW_CONTROLLER) != 0)\n@@ -158,1 +159,1 @@\n-                    if ((e.flags() & CRT_FLOW_TARGET) != 0)\n+                    if ((e.flags() & FLAG_FLOW_TARGET) != 0)\n@@ -160,1 +161,1 @@\n-                    if ((e.flags() & CRT_INVOKE) != 0)\n+                    if ((e.flags() & FLAG_INVOKE) != 0)\n@@ -162,1 +163,1 @@\n-                    if ((e.flags() & CRT_CREATE) != 0)\n+                    if ((e.flags() & FLAG_CREATE) != 0)\n@@ -164,1 +165,1 @@\n-                    if ((e.flags() & CRT_BRANCH_TRUE) != 0)\n+                    if ((e.flags() & FLAG_BRANCH_TRUE) != 0)\n@@ -166,1 +167,1 @@\n-                    if ((e.flags() & CRT_BRANCH_FALSE) != 0)\n+                    if ((e.flags() & FLAG_BRANCH_FALSE) != 0)\n@@ -719,7 +720,7 @@\n-            case ITEM_TOP -> \"top\";\n-            case ITEM_INTEGER -> \"int\";\n-            case ITEM_FLOAT -> \"float\";\n-            case ITEM_LONG -> \"long\";\n-            case ITEM_DOUBLE -> \"double\";\n-            case ITEM_NULL -> \"null\";\n-            case ITEM_UNINITIALIZED_THIS -> \"this\";\n+            case TOP -> \"top\";\n+            case INTEGER -> \"int\";\n+            case FLOAT -> \"float\";\n+            case LONG -> \"long\";\n+            case DOUBLE -> \"double\";\n+            case NULL -> \"null\";\n+            case UNINITIALIZED_THIS -> \"this\";\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -746,1 +746,1 @@\n-            case ClassFile.TAG_INTEGER: {\n+            case PoolEntry.TAG_INTEGER: {\n@@ -760,1 +760,1 @@\n-            case ClassFile.TAG_STRING:\n+            case PoolEntry.TAG_STRING:\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                codeBuilder.ldc(index);\n+                codeBuilder.loadConstant(index);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,0 @@\n-runtime\/Thread\/TestAlwaysPreTouchStacks.java 8335167 macosx-aarch64\n@@ -157,0 +156,2 @@\n+serviceability\/dcmd\/vm\/SystemDumpMapTest.java 8340401 windows-all\n+serviceability\/dcmd\/vm\/SystemMapTest.java 8340401 windows-all\n@@ -224,0 +225,1 @@\n+vmTestbase\/gc\/memory\/Nio\/Nio.java 8340728 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -458,0 +458,1 @@\n+ -runtime\/cds\/appcds\/complexURI \\\n@@ -460,0 +461,2 @@\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndFMG.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java \\\n@@ -476,0 +479,1 @@\n+ -runtime\/cds\/appcds\/DumpRuntimeClassesTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -361,0 +361,5 @@\n+    public static final String CALL_OF = COMPOSITE_PREFIX + \"CALL_OF\" + POSTFIX;\n+    static {\n+        callOfNodes(CALL_OF, \"Call.*\");\n+    }\n+\n@@ -584,0 +589,86 @@\n+    public static final String G1_COMPARE_AND_EXCHANGE_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_COMPARE_AND_EXCHANGE_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1CompareAndExchangeN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_COMPARE_AND_EXCHANGE_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_COMPARE_AND_EXCHANGE_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_COMPARE_AND_EXCHANGE_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1CompareAndExchangeP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_COMPARE_AND_EXCHANGE_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_COMPARE_AND_SWAP_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_COMPARE_AND_SWAP_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1CompareAndSwapN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_COMPARE_AND_SWAP_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1CompareAndSwapP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_COMPARE_AND_SWAP_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_ENCODE_P_AND_STORE_N = PREFIX + \"G1_ENCODE_P_AND_STORE_N\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(G1_ENCODE_P_AND_STORE_N, \"g1EncodePAndStoreN\");\n+    }\n+\n+    public static final String G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1EncodePAndStoreN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_ENCODE_P_AND_STORE_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_GET_AND_SET_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_GET_AND_SET_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1GetAndSetN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_GET_AND_SET_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_GET_AND_SET_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_GET_AND_SET_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1GetAndSetP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_GET_AND_SET_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_LOAD_N = PREFIX + \"G1_LOAD_N\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(G1_LOAD_N, \"g1LoadN\");\n+    }\n+\n+    public static final String G1_LOAD_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_LOAD_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1LoadN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_LOAD_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_LOAD_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_LOAD_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1LoadP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_LOAD_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_STORE_N = PREFIX + \"G1_STORE_N\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(G1_STORE_N, \"g1StoreN\");\n+    }\n+\n+    public static final String G1_STORE_N_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_STORE_N_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1StoreN\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_STORE_N_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String G1_STORE_P = PREFIX + \"G1_STORE_P\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(G1_STORE_P, \"g1StoreP\");\n+    }\n+\n+    public static final String G1_STORE_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"G1_STORE_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"g1StoreP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(G1_STORE_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n@@ -860,0 +951,5 @@\n+    public static final String MACH_TEMP = PREFIX + \"MACH_TEMP\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(MACH_TEMP, \"MachTemp\");\n+    }\n+\n@@ -1156,0 +1252,6 @@\n+    public static final String OOPMAP_WITH = COMPOSITE_PREFIX + \"OOPMAP_WITH\" + POSTFIX;\n+    static {\n+        String regex = \"(#\\\\s*OopMap\\\\s*\\\\{.*\" + IS_REPLACED + \".*\\\\})\";\n+        optoOnly(OOPMAP_WITH, regex);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+java\/awt\/Frame\/InitialIconifiedTest.java 8203920 macosx-all,linux-all\n+java\/awt\/Frame\/ShapeNotSetSometimes\/ShapeNotSetSometimes.java 8341370 macosx-all\n@@ -139,0 +141,1 @@\n+java\/awt\/Focus\/FocusPolicyTest.java 7160904 linux-all\n@@ -521,0 +524,2 @@\n+com\/sun\/management\/DiagnosticCommandMBean\/DcmdMBeanPermissionsTest.java 8340401 windows-all\n+\n@@ -566,0 +571,2 @@\n+java\/nio\/Buffer\/LimitDirectMemory.java                          8340728 generic-all\n+\n@@ -570,1 +577,1 @@\n-java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java      8308807 aix-ppc64\n+java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java      8308807,8144003 aix-ppc64,macosx-all\n@@ -574,0 +581,3 @@\n+java\/nio\/channels\/DatagramChannel\/BasicMulticastTests.java      8144003 macosx-all\n+java\/nio\/channels\/DatagramChannel\/MulticastSendReceiveTests.java 8144003 macosx-all\n+java\/nio\/channels\/DatagramChannel\/Promiscuous.java              8144003 macosx-all\n@@ -804,0 +814,2 @@\n+java\/awt\/Focus\/InactiveFocusRace.java 8023263 linux-all\n+java\/awt\/List\/HandlingKeyEventIfMousePressedTest.java 6848358 macosx-all,windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -131,2 +131,1 @@\n-        \/\/ vm.libgraal.enabled is true if libgraal is used as JIT\n-        map.put(\"vm.libgraal.enabled\", this::isLibgraalEnabled);\n+        map.put(\"vm.libgraal.jit\", this::isLibgraalJIT);\n@@ -390,0 +389,1 @@\n+        vmOptFinalFlag(map, \"UseLargePages\");\n@@ -563,2 +563,2 @@\n-    protected String isLibgraalEnabled() {\n-        return \"\" + Compiler.isLibgraalEnabled();\n+    protected String isLibgraalJIT() {\n+        return \"\" + Compiler.isLibgraalJIT();\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}