{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1095,3 +1095,3 @@\n-        linux_ppc64le: \"gcc8.2.0-Fedora27+1.0\",\n-        linux_s390x: \"gcc8.2.0-Fedora27+1.0\",\n-        linux_riscv64: \"gcc11.3.0-Fedora_rawhide_68692+1.1\"\n+        linux_ppc64le: \"gcc13.2.0-Fedora_41+1.0\",\n+        linux_s390x: \"gcc13.2.0-Fedora_41+1.0\",\n+        linux_riscv64: \"gcc13.2.0-Fedora_41+1.0\"\n","filename":"make\/conf\/jib-profiles.js","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1270,0 +1270,10 @@\n+\n+  \/\/ Given a profile data offset, generate an Address which points to\n+  \/\/ the corresponding slot in mdo->data().\n+  \/\/ Clobbers rscratch2.\n+  auto slot_at = [=](ByteSize offset) -> Address {\n+    return __ form_address(rscratch2, mdo,\n+                           md->byte_offset_of_slot(data, offset),\n+                           LogBytesPerWord);\n+  };\n+\n@@ -1273,2 +1283,1 @@\n-    __ lea(rscratch2, Address(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));\n-    __ ldr(rscratch1, Address(rscratch2));\n+    __ ldr(rscratch1, slot_at(ReceiverTypeData::receiver_offset(i)));\n@@ -1277,2 +1286,2 @@\n-    Address data_addr(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));\n-    __ addptr(data_addr, DataLayout::counter_increment);\n+    __ addptr(slot_at(ReceiverTypeData::receiver_count_offset(i)),\n+              DataLayout::counter_increment);\n@@ -1286,3 +1295,1 @@\n-    __ lea(rscratch2,\n-           Address(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));\n-    Address recv_addr(rscratch2);\n+    Address recv_addr(slot_at(ReceiverTypeData::receiver_offset(i)));\n@@ -1293,2 +1300,1 @@\n-    __ lea(rscratch2, Address(mdo, md->byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))));\n-    __ str(rscratch1, Address(rscratch2));\n+    __ str(rscratch1, slot_at(ReceiverTypeData::receiver_count_offset(i)));\n@@ -1468,2 +1474,1 @@\n-                          md->byte_offset_of_slot(data, DataLayout::flags_offset()),\n-                          0);\n+                          md->byte_offset_of_slot(data, DataLayout::flags_offset()), 0);\n@@ -2751,3 +2756,5 @@\n-          Address recv_addr(mdo, md->byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));\n-          __ lea(rscratch2, recv_addr);\n-          __ str(rscratch1, Address(rscratch2));\n+          Address recv_addr =\n+            __ form_address(rscratch2, mdo,\n+                            md->byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)),\n+                            LogBytesPerWord);\n+          __ str(rscratch1, recv_addr);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1238,0 +1238,1 @@\n+  \/\/ Clobber: rscratch1, rscratch2\n@@ -1239,0 +1240,2 @@\n+\n+  \/\/ Clobber: rscratch1\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -448,0 +448,5 @@\n+  if (!FLAG_IS_DEFAULT(AOTMode)) {\n+    \/\/ Using any form of the new AOTMode switch enables enhanced optimizations.\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTClassLinking, true);\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -114,0 +115,6 @@\n+void ClassListParser::parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n+  UnregisteredClasses::initialize(CHECK);\n+  ClassListParser parser(classlist_path, parse_mode);\n+  parser.parse(THREAD);\n+}\n+\n@@ -390,0 +397,13 @@\n+objArrayOop ClassListParser::get_specified_interfaces(TRAPS) {\n+  const int n = _interfaces->length();\n+  if (n == 0) {\n+    return nullptr;\n+  } else {\n+    objArrayOop array = oopFactory::new_objArray(vmClasses::Class_klass(), n, CHECK_NULL);\n+    for (int i = 0; i < n; i++) {\n+      array->obj_at_put(i, lookup_class_by_id(_interfaces->at(i))->java_mirror());\n+    }\n+    return array;\n+  }\n+}\n+\n@@ -517,1 +537,11 @@\n-  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path, CHECK_NULL);\n+  InstanceKlass* specified_super = lookup_class_by_id(_super);\n+  Handle super_class(THREAD, specified_super->java_mirror());\n+  objArrayOop r = get_specified_interfaces(CHECK_NULL);\n+  objArrayHandle interfaces(THREAD, r);\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path,\n+                                                     super_class, interfaces, CHECK_NULL);\n+  if (k->java_super() != specified_super) {\n+    error(\"The specified super class %s (id %d) does not match actual super class %s\",\n+          specified_super->external_name(), _super,\n+          k->java_super()->external_name());\n+  }\n@@ -741,43 +771,0 @@\n-\n-InstanceKlass* ClassListParser::lookup_super_for_current_class(Symbol* super_name) {\n-  if (!is_loading_from_source()) {\n-    return nullptr;\n-  }\n-\n-  InstanceKlass* k = lookup_class_by_id(super());\n-  if (super_name != k->name()) {\n-    error(\"The specified super class %s (id %d) does not match actual super class %s\",\n-          k->name()->as_klass_external_name(), super(),\n-          super_name->as_klass_external_name());\n-  }\n-  return k;\n-}\n-\n-InstanceKlass* ClassListParser::lookup_interface_for_current_class(Symbol* interface_name) {\n-  if (!is_loading_from_source()) {\n-    return nullptr;\n-  }\n-\n-  const int n = _interfaces->length();\n-  if (n == 0) {\n-    error(\"Class %s implements the interface %s, but no interface has been specified in the input line\",\n-          _class_name, interface_name->as_klass_external_name());\n-    ShouldNotReachHere();\n-  }\n-\n-  int i;\n-  for (i=0; i<n; i++) {\n-    InstanceKlass* k = lookup_class_by_id(_interfaces->at(i));\n-    if (interface_name == k->name()) {\n-      return k;\n-    }\n-  }\n-\n-  \/\/ interface_name is not specified by the \"interfaces:\" keyword.\n-  print_specified_interfaces();\n-  error(\"The interface %s implemented by class %s does not match any of the specified interface IDs\",\n-        interface_name->as_klass_external_name(), _class_name);\n-  ShouldNotReachHere();\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":31,"deletions":44,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -219,5 +219,13 @@\n-static bool shared_base_too_high(char* specified_base, char* aligned_base, size_t cds_max) {\n-  if (specified_base != nullptr && aligned_base < specified_base) {\n-    \/\/ SharedBaseAddress is very high (e.g., 0xffffffffffffff00) so\n-    \/\/ align_up(SharedBaseAddress, MetaspaceShared::core_region_alignment()) has wrapped around.\n-    return true;\n+\/\/ If p is not aligned, move it up to the next address that's aligned with alignment.\n+\/\/ If this is not possible (because p is too high), return nullptr. Example:\n+\/\/     p = 0xffffffffffff0000, alignment= 0x10000    => return nullptr.\n+static char* align_up_or_null(char* p, size_t alignment) {\n+  assert(p != nullptr, \"sanity\");\n+  if (is_aligned(p, alignment)) {\n+    return p;\n+  }\n+\n+  char* down = align_down(p, alignment);\n+  if (max_uintx - uintx(down) < uintx(alignment)) {\n+    \/\/ Run out of address space to align up.\n+    return nullptr;\n@@ -225,0 +233,13 @@\n+\n+  char* aligned = align_up(p, alignment);\n+  assert(aligned >= p, \"sanity\");\n+  assert(aligned != nullptr, \"sanity\");\n+  return aligned;\n+}\n+\n+static bool shared_base_too_high(char* specified_base, char* aligned_base, size_t cds_max) {\n+  \/\/ Caller should have checked if align_up_or_null( returns nullptr (comparing specified_base\n+  \/\/ with nullptr is UB).\n+  assert(aligned_base != nullptr, \"sanity\");\n+  assert(aligned_base >= specified_base, \"sanity\");\n+\n@@ -226,1 +247,1 @@\n-    \/\/ The end of the archive will wrap around\n+    \/\/ Not enough address space to hold an archive of cds_max bytes from aligned_base.\n@@ -228,0 +249,2 @@\n+  } else {\n+    return false;\n@@ -229,2 +252,0 @@\n-\n-  return false;\n@@ -235,1 +256,1 @@\n-  char* aligned_base = align_up(specified_base, MetaspaceShared::core_region_alignment());\n+  size_t alignment = MetaspaceShared::core_region_alignment();\n@@ -237,1 +258,1 @@\n-    aligned_base = align_up(specified_base, Metaspace::reserve_alignment());\n+    alignment = MAX2(alignment, Metaspace::reserve_alignment());\n@@ -240,0 +261,7 @@\n+  if (SharedBaseAddress == 0) {\n+    \/\/ Special meaning of -XX:SharedBaseAddress=0 -> Always map archive at os-selected address.\n+    return specified_base;\n+  }\n+\n+  char* aligned_base = align_up_or_null(specified_base, alignment);\n+\n@@ -246,1 +274,3 @@\n-  if (shared_base_too_high(specified_base, aligned_base, cds_max)) {\n+  if (aligned_base == nullptr) {\n+    err = \"too high\";\n+  } else if (shared_base_too_high(specified_base, aligned_base, cds_max)) {\n@@ -254,0 +284,3 @@\n+  \/\/ Arguments::default_SharedBaseAddress() is hard-coded in cds_globals.hpp. It must be carefully\n+  \/\/ picked that (a) the align_up() below will always return a valid value; (b) none of\n+  \/\/ the following asserts will fail.\n@@ -259,1 +292,1 @@\n-  aligned_base = align_up(specified_base, MetaspaceShared::core_region_alignment());\n+  aligned_base = align_up(specified_base, alignment);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":45,"deletions":12,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -429,10 +429,0 @@\n-#if INCLUDE_CDS\n-  if (CDSConfig::is_dumping_static_archive()) {\n-    \/\/ Special processing for handling UNREGISTERED shared classes.\n-    InstanceKlass* k = SystemDictionaryShared::lookup_super_for_unregistered_class(class_name,\n-                           next_name, is_superclass);\n-    if (k) {\n-      return k;\n-    }\n-  }\n-#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,0 @@\n-  do_klass(URLClassLoader_klass,                        java_net_URLClassLoader                               ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -127,1 +127,0 @@\n-  template(java_net_URLClassLoader,                   \"java\/net\/URLClassLoader\")                  \\\n@@ -753,1 +752,0 @@\n-  template(url_array_classloader_void_signature,            \"([Ljava\/net\/URL;Ljava\/lang\/ClassLoader;)V\")          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -368,0 +368,1 @@\n+    bool found_waiter = false;\n@@ -369,2 +370,14 @@\n-      \/\/ Wake up thread that blocks on the compile task.\n-      current->lock()->notify();\n+      assert(current->waiting_for_completion_count() <= 1, \"more than one thread are waiting for task\");\n+      if (current->waiting_for_completion_count() > 0) {\n+        \/\/ If another thread waits for this task, we must wake them up\n+        \/\/ so they will stop waiting and free the task.\n+        current->lock()->notify();\n+        found_waiter = true;\n+      }\n+    }\n+    if (!found_waiter) {\n+      \/\/ If no one was waiting for this task, we need to free it ourselves. In this case, the task\n+      \/\/ is also certainly unlocked, because, again, there is no waiter.\n+      \/\/ Otherwise, by convention, it's the waiters responsibility to free the task.\n+      \/\/ Put the task back on the freelist.\n+      CompileTask::free(current);\n@@ -373,2 +386,0 @@\n-    \/\/ Put the task back on the freelist.\n-    CompileTask::free(current);\n@@ -776,14 +787,0 @@\n-\/\/ Stress testing. Dedicated threads revert optimizations based on escape analysis concurrently to\n-\/\/ the running java application.  Configured with vm options DeoptimizeObjectsALot*.\n-class DeoptimizeObjectsALotThread : public JavaThread {\n-\n-  static void deopt_objs_alot_thread_entry(JavaThread* thread, TRAPS);\n-  void deoptimize_objects_alot_loop_single();\n-  void deoptimize_objects_alot_loop_all();\n-\n-public:\n-  DeoptimizeObjectsALotThread() : JavaThread(&deopt_objs_alot_thread_entry) { }\n-\n-  bool is_hidden_from_external_view() const      { return true; }\n-};\n-\n@@ -1739,0 +1736,1 @@\n+    task->inc_waiting_for_completion();\n@@ -1742,0 +1740,1 @@\n+    task->dec_waiting_for_completion();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -46,2 +48,1 @@\n-ParCompactionManager::OopTaskQueueSet*      ParCompactionManager::_oop_task_queues = nullptr;\n-ParCompactionManager::ObjArrayTaskQueueSet* ParCompactionManager::_objarray_task_queues = nullptr;\n+ParCompactionManager::PSMarkTasksQueueSet*  ParCompactionManager::_marking_stacks = nullptr;\n@@ -49,0 +50,1 @@\n+PartialArrayStateManager* ParCompactionManager::_partial_array_state_manager = nullptr;\n@@ -58,2 +60,4 @@\n-                                           ReferenceProcessor* ref_processor)\n-  : _mark_and_push_closure(this, ref_processor) {\n+                                           ReferenceProcessor* ref_processor,\n+                                           uint parallel_gc_threads)\n+  :_partial_array_splitter(_partial_array_state_manager, parallel_gc_threads),\n+   _mark_and_push_closure(this, ref_processor) {\n@@ -82,2 +86,4 @@\n-  _oop_task_queues = new OopTaskQueueSet(parallel_gc_threads);\n-  _objarray_task_queues = new ObjArrayTaskQueueSet(parallel_gc_threads);\n+  assert(_partial_array_state_manager == nullptr, \"Attempt to initialize twice\");\n+  _partial_array_state_manager\n+    = new PartialArrayStateManager(parallel_gc_threads);\n+  _marking_stacks = new PSMarkTasksQueueSet(parallel_gc_threads);\n@@ -92,3 +98,3 @@\n-                                                 PSParallelCompact::ref_processor());\n-    oop_task_queues()->register_queue(i, _manager_array[i]->oop_stack());\n-    _objarray_task_queues->register_queue(i, &_manager_array[i]->_objarray_stack);\n+                                                 PSParallelCompact::ref_processor(),\n+                                                 parallel_gc_threads);\n+    marking_stacks()->register_queue(i, _manager_array[i]->marking_stack());\n@@ -101,1 +107,0 @@\n-\n@@ -118,10 +123,9 @@\n-inline void ParCompactionManager::publish_and_drain_oop_tasks() {\n-  oop obj;\n-  while (oop_stack()->pop_overflow(obj)) {\n-    if (!oop_stack()->try_push_to_taskqueue(obj)) {\n-      follow_contents(obj);\n-    }\n-  }\n-  while (oop_stack()->pop_local(obj)) {\n-    follow_contents(obj);\n-  }\n+void ParCompactionManager::push_objArray(oop obj) {\n+  assert(obj->is_objArray(), \"precondition\");\n+  _mark_and_push_closure.do_klass(obj->klass());\n+\n+  objArrayOop obj_array = objArrayOop(obj);\n+  size_t array_length = obj_array->length();\n+  size_t initial_chunk_size =\n+    _partial_array_splitter.start(&_marking_stack, obj_array, nullptr, array_length);\n+  follow_array(obj_array, 0, initial_chunk_size);\n@@ -130,7 +134,6 @@\n-bool ParCompactionManager::publish_or_pop_objarray_tasks(ObjArrayTask& task) {\n-  while (_objarray_stack.pop_overflow(task)) {\n-    if (!_objarray_stack.try_push_to_taskqueue(task)) {\n-      return true;\n-    }\n-  }\n-  return false;\n+void ParCompactionManager::process_array_chunk(PartialArrayState* state, bool stolen) {\n+  \/\/ Access before release by claim().\n+  oop obj = state->source();\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, &_marking_stack, stolen);\n+  follow_array(objArrayOop(obj), claim._start, claim._end);\n@@ -140,0 +143,1 @@\n+  ScannerTask task;\n@@ -143,7 +147,7 @@\n-    publish_and_drain_oop_tasks();\n-\n-    \/\/ Process ObjArrays one at a time to avoid marking stack bloat.\n-    ObjArrayTask task;\n-    if (publish_or_pop_objarray_tasks(task) ||\n-        _objarray_stack.pop_local(task)) {\n-      follow_array((objArrayOop)task.obj(), task.index());\n+    while (marking_stack()->pop_overflow(task)) {\n+      if (!marking_stack()->try_push_to_taskqueue(task)) {\n+        follow_contents(task, false);\n+      }\n+    }\n+    while (marking_stack()->pop_local(task)) {\n+      follow_contents(task, false);\n@@ -151,1 +155,1 @@\n-  } while (!marking_stacks_empty());\n+  } while (!marking_stack_empty());\n@@ -153,1 +157,1 @@\n-  assert(marking_stacks_empty(), \"Sanity\");\n+  assert(marking_stack_empty(), \"Sanity\");\n@@ -200,0 +204,21 @@\n+\n+#if TASKQUEUE_STATS\n+void ParCompactionManager::print_and_reset_taskqueue_stats() {\n+  marking_stacks()->print_and_reset_taskqueue_stats(\"Marking Stacks\");\n+\n+  auto get_pa_stats = [&](uint i) {\n+    return _manager_array[i]->partial_array_task_stats();\n+  };\n+  PartialArrayTaskStats::log_set(ParallelGCThreads, get_pa_stats,\n+                                 \"Partial Array Task Stats\");\n+  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().max_workers();\n+  for (uint i = 0; i < parallel_gc_threads; ++i) {\n+    get_pa_stats(i)->reset();\n+  }\n+}\n+\n+PartialArrayTaskStats* ParCompactionManager::partial_array_task_stats() {\n+  return _partial_array_splitter.stats();\n+}\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -204,1 +229,1 @@\n-    assert(_manager_array[i]->marking_stacks_empty(), \"Marking stack should be empty\");\n+    assert(_manager_array[i]->marking_stack_empty(), \"Marking stack should be empty\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":62,"deletions":37,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -252,0 +252,5 @@\n+  if (!rs.is_reserved()) {\n+    \/\/ Failed to reserve memory.\n+    return nullptr;\n+  }\n+\n@@ -258,4 +263,4 @@\n-  if (vspace != nullptr) {\n-    if (vspace->expand_by(_reserved_byte_size)) {\n-      return vspace;\n-    }\n+\n+  if (!vspace->expand_by(_reserved_byte_size)) {\n+    \/\/ Failed to commit memory.\n+\n@@ -263,0 +268,1 @@\n+\n@@ -264,4 +270,3 @@\n-    if (rs.is_reserved()) {\n-      MemoryReserver::release(rs);\n-      rs = {};\n-    }\n+    MemoryReserver::release(rs);\n+\n+    return nullptr;\n@@ -270,1 +275,1 @@\n-  return nullptr;\n+  return vspace;\n@@ -1213,6 +1218,3 @@\n-    oop obj = nullptr;\n-    ObjArrayTask task;\n-    if (ParCompactionManager::steal_objarray(worker_id,  task)) {\n-      cm->follow_array((objArrayOop)task.obj(), task.index());\n-    } else if (ParCompactionManager::steal(worker_id, obj)) {\n-      cm->follow_contents(obj);\n+    ScannerTask task;\n+    if (ParCompactionManager::steal(worker_id, task)) {\n+      cm->follow_contents(task, true);\n@@ -1234,1 +1236,1 @@\n-      _terminator(active_workers, ParCompactionManager::oop_task_queues()),\n+      _terminator(active_workers, ParCompactionManager::marking_stacks()),\n@@ -1272,1 +1274,1 @@\n-      _terminator(_max_workers, ParCompactionManager::oop_task_queues()) {}\n+      _terminator(_max_workers, ParCompactionManager::marking_stacks()) {}\n@@ -1382,2 +1384,1 @@\n-  ParCompactionManager::oop_task_queues()->print_and_reset_taskqueue_stats(\"Oop Queue\");\n-  ParCompactionManager::_objarray_task_queues->print_and_reset_taskqueue_stats(\"ObjArrayOop Queue\");\n+  ParCompactionManager::print_and_reset_taskqueue_stats();\n@@ -2484,1 +2485,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -561,1 +561,3 @@\n-    offset = base->bottom_type()->isa_oopptr()->offset();\n+    const TypeOopPtr* oopptr = base->bottom_type()->isa_oopptr();\n+    if (oopptr == nullptr) return nullptr;\n+    offset = oopptr->offset();\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -817,0 +817,6 @@\n+\n+        \/\/ Since this compilation didn't pass through the broker it wasn't logged yet.\n+        if (PrintCompilation) {\n+          ttyLocker ttyl;\n+          CompileTask::print(tty, nm, \"(hosted JVMCI compilation)\");\n+        }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -963,9 +963,5 @@\n-  if (rhs.is_reserved()) {\n-    assert(total_reserved == rhs.size(),    \"must be exactly of required size\");\n-    assert(is_aligned(rhs.base(),alignment),\"must be exactly of required alignment\");\n-\n-    assert(markWord::encode_pointer_as_mark(rhs.base()).decode_pointer() == rhs.base(),\n-           \"area must be distinguishable from marks for mark-sweep\");\n-    assert(markWord::encode_pointer_as_mark(&rhs.base()[rhs.size()]).decode_pointer() ==\n-           &rhs.base()[rhs.size()],\n-           \"area must be distinguishable from marks for mark-sweep\");\n+  if (!rhs.is_reserved()) {\n+    vm_exit_during_initialization(\n+      err_msg(\"Could not reserve enough space for %zu KB object heap\",\n+              total_reserved\/K));\n+  }\n@@ -973,1 +969,2 @@\n-    \/\/ We are good.\n+  assert(total_reserved == rhs.size(),    \"must be exactly of required size\");\n+  assert(is_aligned(rhs.base(),alignment),\"must be exactly of required alignment\");\n@@ -975,3 +972,5 @@\n-    if (AllocateHeapAt != nullptr) {\n-      log_info(gc,heap)(\"Successfully allocated Java heap at location %s\", AllocateHeapAt);\n-    }\n+  assert(markWord::encode_pointer_as_mark(rhs.base()).decode_pointer() == rhs.base(),\n+      \"area must be distinguishable from marks for mark-sweep\");\n+  assert(markWord::encode_pointer_as_mark(&rhs.base()[rhs.size()]).decode_pointer() ==\n+      &rhs.base()[rhs.size()],\n+      \"area must be distinguishable from marks for mark-sweep\");\n@@ -979,3 +978,1 @@\n-    if (UseCompressedOops) {\n-      CompressedOops::initialize(rhs);\n-    }\n+  \/\/ We are good.\n@@ -983,1 +980,3 @@\n-    Universe::calculate_verify_data((HeapWord*)rhs.base(), (HeapWord*)rhs.end());\n+  if (AllocateHeapAt != nullptr) {\n+    log_info(gc,heap)(\"Successfully allocated Java heap at location %s\", AllocateHeapAt);\n+  }\n@@ -985,1 +984,2 @@\n-    return rhs;\n+  if (UseCompressedOops) {\n+    CompressedOops::initialize(rhs);\n@@ -988,3 +988,1 @@\n-  vm_exit_during_initialization(\n-    err_msg(\"Could not reserve enough space for %zuKB object heap\",\n-            total_reserved\/K));\n+  Universe::calculate_verify_data((HeapWord*)rhs.base(), (HeapWord*)rhs.end());\n@@ -992,2 +990,1 @@\n-  \/\/ satisfy compiler\n-  ShouldNotReachHere();\n+  return rhs;\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -116,1 +116,2 @@\n-                               int caller_bci, bool& should_delay, ciCallProfile& profile) {\n+                               JVMState* caller_jvms, bool& should_delay, ciCallProfile& profile) {\n+  int caller_bci = caller_jvms->bci();\n@@ -146,3 +147,3 @@\n-    if (C->print_inlining() && Verbose) {\n-      CompileTask::print_inline_indent(inline_level());\n-      tty->print_cr(\"Inlined method with many throws (throws=%d):\", callee_method->interpreter_throwout_count());\n+    if (Verbose) {\n+      outputStream* stream = C->inline_printer()->record(callee_method, caller_jvms, InliningResult::SUCCESS);\n+      stream->print(\"Inlined method with many throws (throws=%d):\", callee_method->interpreter_throwout_count());\n@@ -171,5 +172,2 @@\n-      CompileTask::print_inline_indent(inline_level());\n-      tty->print_cr(\"Inlined frequent method (freq=%lf):\", freq);\n-      CompileTask::print_inline_indent(inline_level());\n-      callee_method->print();\n-      tty->cr();\n+      outputStream* stream = C->inline_printer()->record(callee_method, caller_jvms, InliningResult::SUCCESS);\n+      stream->print(\"Inlined frequent method (freq=%lf):\", freq);\n@@ -379,1 +377,1 @@\n-  if (!should_inline(callee_method, caller_method, caller_bci, should_delay, profile)) {\n+  if (!should_inline(callee_method, caller_method, jvms, should_delay, profile)) {\n@@ -537,2 +535,3 @@\n-void InlineTree::print_inlining(ciMethod* callee_method, int caller_bci,\n-                                ciMethod* caller_method, bool success) const {\n+void InlineTree::print_inlining(ciMethod* callee_method, JVMState* jvm, bool success) const {\n+  int caller_bci = jvm->bci();\n+  ciMethod* caller_method = jvm->method();\n@@ -548,11 +547,2 @@\n-  CompileTask::print_inlining_ul(callee_method, inline_level(),\n-                                 caller_bci, inlining_result_of(success), inline_msg);\n-  if (C->print_inlining()) {\n-    C->print_inlining(callee_method, inline_level(), caller_bci, inlining_result_of(success), inline_msg);\n-    guarantee(callee_method != nullptr, \"would crash in CompilerEvent::InlineEvent::post\");\n-    if (Verbose) {\n-      const InlineTree *top = this;\n-      while (top->caller_tree() != nullptr) { top = top->caller_tree(); }\n-      \/\/tty->print(\"  bcs: %d+%d  invoked: %d\", top->count_inline_bcs(), callee_method->code_size(), callee_method->interpreter_invocation_count());\n-    }\n-  }\n+  CompileTask::print_inlining_ul(callee_method, inline_level(), caller_bci, inlining_result_of(success), inline_msg);\n+  C->inline_printer()->record(callee_method, jvm, inlining_result_of(success), inline_msg);\n@@ -561,0 +551,1 @@\n+    guarantee(callee_method != nullptr, \"would crash in CompilerEvent::InlineEvent::post\");\n@@ -585,1 +576,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, false \/* !success *\/);\n+    print_inlining(callee_method, jvms, false \/* !success *\/);\n@@ -592,1 +583,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, false \/* !success *\/);\n+    print_inlining(callee_method, jvms, false \/* !success *\/);\n@@ -604,1 +595,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, true \/* success *\/);\n+    print_inlining(callee_method, jvms, true \/* success *\/);\n@@ -616,1 +607,1 @@\n-    print_inlining(callee_method, caller_bci, caller_method, false \/* !success *\/ );\n+    print_inlining(callee_method, jvms, false \/* !success *\/);\n@@ -637,2 +628,1 @@\n-      CompileTask::print_inline_indent(inline_level());\n-      tty->print_cr(\" \\\\-> discounting inline depth\");\n+      C->inline_printer()->record(callee_method, caller_jvms, InliningResult::SUCCESS, \" \\\\-> discounting inline depth\");\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":19,"deletions":29,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-  C->print_inlining_update(this);\n@@ -156,1 +155,0 @@\n-  kit.C->print_inlining_update(this);\n@@ -234,2 +232,0 @@\n-  kit.C->print_inlining_update(this);\n-\n@@ -372,9 +368,0 @@\n-  virtual void print_inlining_late(InliningResult result, const char* msg) {\n-    CallNode* call = call_node();\n-    Compile* C = Compile::current();\n-    C->print_inlining_assert_ready();\n-    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), result, msg);\n-    C->print_inlining_move_to(this);\n-    C->print_inlining_update_delayed(this);\n-  }\n-\n@@ -462,3 +449,3 @@\n-    if (!allow_inline && (C->print_inlining() || C->print_intrinsics())) {\n-      C->print_inlining(cg->method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late method handle call resolution\");\n+    if (!allow_inline) {\n+      C->inline_printer()->record(cg->method(), call_node()->jvms(), InliningResult::FAILURE,\n+                                  \"late method handle call resolution\");\n@@ -530,9 +517,0 @@\n-  virtual void print_inlining_late(InliningResult result, const char* msg) {\n-    CallNode* call = call_node();\n-    Compile* C = Compile::current();\n-    C->print_inlining_assert_ready();\n-    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), result, msg);\n-    C->print_inlining_move_to(this);\n-    C->print_inlining_update_delayed(this);\n-  }\n-\n@@ -562,4 +540,2 @@\n-    if (C->print_inlining() || C->print_intrinsics()) {\n-      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late call devirtualization failed (receiver may be null)\");\n-    }\n+    C->inline_printer()->record(method(), call_node()->jvms(), InliningResult::FAILURE,\n+                                \"late call devirtualization failed (receiver may be null)\");\n@@ -572,4 +548,2 @@\n-    if (C->print_inlining() || C->print_intrinsics()) {\n-      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late call devirtualization failed (interface call)\");\n-    }\n+    C->inline_printer()->record(method(), call_node()->jvms(), InliningResult::FAILURE,\n+                                \"late call devirtualization failed (interface call)\");\n@@ -588,3 +562,2 @@\n-    if (!allow_inline && (C->print_inlining() || C->print_intrinsics())) {\n-      C->print_inlining(cg->method(), jvms->depth()-1, call_node()->jvms()->bci(), InliningResult::FAILURE,\n-                        \"late call devirtualization\");\n+    if (!allow_inline) {\n+      C->inline_printer()->record(cg->method(), call_node()->jvms(), InliningResult::FAILURE, \"late call devirtualization\");\n@@ -740,4 +713,0 @@\n-    C->print_inlining_assert_ready();\n-\n-    C->print_inlining_move_to(this);\n-\n@@ -749,1 +718,0 @@\n-      C->print_inlining_update_delayed(this);\n@@ -752,3 +720,0 @@\n-    if (C->print_inlining() && (is_mh_late_inline() || is_virtual_late_inline())) {\n-      C->print_inlining_update_delayed(this);\n-    }\n@@ -789,0 +754,12 @@\n+    if (is_mh_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (method handle)\");\n+    } else if (is_string_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (string method)\");\n+    } else if (is_boxing_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (boxing method)\");\n+    } else if (is_vector_reboxing_late_inline()) {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded (vector reboxing method)\");\n+    } else {\n+      C->inline_printer()->record(method(), jvms, InliningResult::SUCCESS, \"late inline succeeded\");\n+    }\n+\n@@ -912,0 +889,2 @@\n+  virtual bool is_boxing_late_inline() const { return true; }\n+\n@@ -940,0 +919,2 @@\n+  virtual bool is_vector_reboxing_late_inline() const { return true; }\n+\n@@ -1005,1 +986,0 @@\n-  kit.C->print_inlining_update(this);\n@@ -1062,0 +1042,3 @@\n+  if (kit.failing()) {\n+    return nullptr;\n+  }\n@@ -1197,2 +1180,1 @@\n-            print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                   \"signatures mismatch\");\n+            print_inlining_failure(C, callee, jvms, \"signatures mismatch\");\n@@ -1211,2 +1193,1 @@\n-          print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                 \"receiver is always null\");\n+          print_inlining_failure(C, callee, jvms, \"receiver is always null\");\n@@ -1215,2 +1196,1 @@\n-        print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                               \"receiver not constant\");\n+        print_inlining_failure(C, callee, jvms, \"receiver not constant\");\n@@ -1218,2 +1198,1 @@\n-    }\n-    break;\n+  } break;\n@@ -1235,2 +1214,1 @@\n-          print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                 \"signatures mismatch\");\n+          print_inlining_failure(C, callee, jvms, \"signatures mismatch\");\n@@ -1251,2 +1229,1 @@\n-            print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                   \"argument types mismatch\");\n+            print_inlining_failure(C, callee, jvms, \"argument types mismatch\");\n@@ -1265,2 +1242,1 @@\n-              print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                                     \"argument types mismatch\");\n+              print_inlining_failure(C, callee, jvms, \"argument types mismatch\");\n@@ -1305,2 +1281,1 @@\n-        print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                               \"member_name not constant\");\n+        print_inlining_failure(C, callee, jvms, \"member_name not constant\");\n@@ -1308,2 +1283,1 @@\n-    }\n-    break;\n+  } break;\n@@ -1311,3 +1285,2 @@\n-    case vmIntrinsics::_linkToNative:\n-    print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),\n-                           \"native call\");\n+  case vmIntrinsics::_linkToNative:\n+    print_inlining_failure(C, callee, jvms, \"native call\");\n@@ -1413,0 +1386,3 @@\n+      if (kit.failing()) {\n+        return nullptr;\n+      }\n@@ -1558,1 +1534,0 @@\n-  kit.C->print_inlining_update(this);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":42,"deletions":67,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,2 @@\n+  virtual bool      is_boxing_late_inline() const  { return false; }\n+  virtual bool      is_vector_reboxing_late_inline() const  { return false; }\n@@ -175,8 +177,2 @@\n-  virtual void print_inlining_late(InliningResult result, const char* msg) { ShouldNotReachHere(); }\n-\n-  static void print_inlining(Compile* C, ciMethod* callee, int inline_level, int bci, const char* msg) {\n-    print_inlining_impl(C, callee, inline_level, bci, InliningResult::SUCCESS, msg);\n-  }\n-\n-  static void print_inlining_failure(Compile* C, ciMethod* callee, int inline_level, int bci, const char* msg) {\n-    print_inlining_impl(C, callee, inline_level, bci, InliningResult::FAILURE, msg);\n+  static void print_inlining_failure(Compile* C, ciMethod* callee, JVMState* jvms, const char* msg) {\n+    C->inline_printer()->record(callee, jvms, InliningResult::FAILURE, msg);\n@@ -189,8 +185,0 @@\n-\n-private:\n-  static void print_inlining_impl(Compile* C, ciMethod* callee, int inline_level, int bci,\n-                                  InliningResult result, const char* msg) {\n-    if (C->print_inlining()) {\n-      C->print_inlining(callee, inline_level, bci, result, msg);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -627,19 +627,19 @@\n-Compile::Compile( ciEnv* ci_env, ciMethod* target, int osr_bci,\n-                  Options options, DirectiveSet* directive)\n-                : Phase(Compiler),\n-                  _compile_id(ci_env->compile_id()),\n-                  _options(options),\n-                  _method(target),\n-                  _entry_bci(osr_bci),\n-                  _ilt(nullptr),\n-                  _stub_function(nullptr),\n-                  _stub_name(nullptr),\n-                  _stub_entry_point(nullptr),\n-                  _max_node_limit(MaxNodeLimit),\n-                  _post_loop_opts_phase(false),\n-                  _allow_macro_nodes(true),\n-                  _inlining_progress(false),\n-                  _inlining_incrementally(false),\n-                  _do_cleanup(false),\n-                  _has_reserved_stack_access(target->has_reserved_stack_access()),\n-                  _has_circular_inline_type(false),\n+Compile::Compile(ciEnv* ci_env, ciMethod* target, int osr_bci,\n+                 Options options, DirectiveSet* directive)\n+    : Phase(Compiler),\n+      _compile_id(ci_env->compile_id()),\n+      _options(options),\n+      _method(target),\n+      _entry_bci(osr_bci),\n+      _ilt(nullptr),\n+      _stub_function(nullptr),\n+      _stub_name(nullptr),\n+      _stub_entry_point(nullptr),\n+      _max_node_limit(MaxNodeLimit),\n+      _post_loop_opts_phase(false),\n+      _allow_macro_nodes(true),\n+      _inlining_progress(false),\n+      _inlining_incrementally(false),\n+      _do_cleanup(false),\n+      _has_reserved_stack_access(target->has_reserved_stack_access()),\n+      _has_circular_inline_type(false),\n@@ -647,2 +647,2 @@\n-                  _igv_idx(0),\n-                  _trace_opto_output(directive->TraceOptoOutputOption),\n+      _igv_idx(0),\n+      _trace_opto_output(directive->TraceOptoOutputOption),\n@@ -650,48 +650,45 @@\n-                  _has_method_handle_invokes(false),\n-                  _clinit_barrier_on_entry(false),\n-                  _stress_seed(0),\n-                  _comp_arena(mtCompiler),\n-                  _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n-                  _env(ci_env),\n-                  _directive(directive),\n-                  _log(ci_env->log()),\n-                  _first_failure_details(nullptr),\n-                  _intrinsics        (comp_arena(), 0, 0, nullptr),\n-                  _macro_nodes       (comp_arena(), 8, 0, nullptr),\n-                  _parse_predicates  (comp_arena(), 8, 0, nullptr),\n-                  _template_assertion_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n-                  _expensive_nodes   (comp_arena(), 8, 0, nullptr),\n-                  _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n-                  _inline_type_nodes (comp_arena(), 8, 0, nullptr),\n-                  _unstable_if_traps (comp_arena(), 8, 0, nullptr),\n-                  _coarsened_locks   (comp_arena(), 8, 0, nullptr),\n-                  _congraph(nullptr),\n-                  NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n-                  _unique(0),\n-                  _dead_node_count(0),\n-                  _dead_node_list(comp_arena()),\n-                  _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n-                  _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n-                  _node_arena(&_node_arena_one),\n-                  _mach_constant_base_node(nullptr),\n-                  _Compile_types(mtCompiler),\n-                  _initial_gvn(nullptr),\n-                  _igvn_worklist(nullptr),\n-                  _types(nullptr),\n-                  _node_hash(nullptr),\n-                  _late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _string_late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _boxing_late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _vector_reboxing_late_inlines(comp_arena(), 2, 0, nullptr),\n-                  _late_inlines_pos(0),\n-                  _number_of_mh_late_inlines(0),\n-                  _oom(false),\n-                  _print_inlining_stream(new (mtCompiler) stringStream()),\n-                  _print_inlining_list(nullptr),\n-                  _print_inlining_idx(0),\n-                  _print_inlining_output(nullptr),\n-                  _replay_inline_data(nullptr),\n-                  _java_calls(0),\n-                  _inner_loops(0),\n-                  _interpreter_frame_size(0),\n-                  _output(nullptr)\n+      _has_method_handle_invokes(false),\n+      _clinit_barrier_on_entry(false),\n+      _stress_seed(0),\n+      _comp_arena(mtCompiler),\n+      _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n+      _env(ci_env),\n+      _directive(directive),\n+      _log(ci_env->log()),\n+      _first_failure_details(nullptr),\n+      _intrinsics(comp_arena(), 0, 0, nullptr),\n+      _macro_nodes(comp_arena(), 8, 0, nullptr),\n+      _parse_predicates(comp_arena(), 8, 0, nullptr),\n+      _template_assertion_predicate_opaqs(comp_arena(), 8, 0, nullptr),\n+      _expensive_nodes(comp_arena(), 8, 0, nullptr),\n+      _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n+      _inline_type_nodes (comp_arena(), 8, 0, nullptr),\n+      _unstable_if_traps(comp_arena(), 8, 0, nullptr),\n+      _coarsened_locks(comp_arena(), 8, 0, nullptr),\n+      _congraph(nullptr),\n+      NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n+          _unique(0),\n+      _dead_node_count(0),\n+      _dead_node_list(comp_arena()),\n+      _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n+      _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n+      _node_arena(&_node_arena_one),\n+      _mach_constant_base_node(nullptr),\n+      _Compile_types(mtCompiler),\n+      _initial_gvn(nullptr),\n+      _igvn_worklist(nullptr),\n+      _types(nullptr),\n+      _node_hash(nullptr),\n+      _late_inlines(comp_arena(), 2, 0, nullptr),\n+      _string_late_inlines(comp_arena(), 2, 0, nullptr),\n+      _boxing_late_inlines(comp_arena(), 2, 0, nullptr),\n+      _vector_reboxing_late_inlines(comp_arena(), 2, 0, nullptr),\n+      _late_inlines_pos(0),\n+      _number_of_mh_late_inlines(0),\n+      _oom(false),\n+      _replay_inline_data(nullptr),\n+      _inline_printer(this),\n+      _java_calls(0),\n+      _inner_loops(0),\n+      _interpreter_frame_size(0),\n+      _output(nullptr)\n@@ -699,1 +696,2 @@\n-                  , _in_dump_cnt(0)\n+      ,\n+      _in_dump_cnt(0)\n@@ -762,1 +760,0 @@\n-  print_inlining_init();\n@@ -913,23 +910,23 @@\n-Compile::Compile( ciEnv* ci_env,\n-                  TypeFunc_generator generator,\n-                  address stub_function,\n-                  const char *stub_name,\n-                  int is_fancy_jump,\n-                  bool pass_tls,\n-                  bool return_pc,\n-                  DirectiveSet* directive)\n-  : Phase(Compiler),\n-    _compile_id(0),\n-    _options(Options::for_runtime_stub()),\n-    _method(nullptr),\n-    _entry_bci(InvocationEntryBci),\n-    _stub_function(stub_function),\n-    _stub_name(stub_name),\n-    _stub_entry_point(nullptr),\n-    _max_node_limit(MaxNodeLimit),\n-    _post_loop_opts_phase(false),\n-    _allow_macro_nodes(true),\n-    _inlining_progress(false),\n-    _inlining_incrementally(false),\n-    _has_reserved_stack_access(false),\n-    _has_circular_inline_type(false),\n+Compile::Compile(ciEnv* ci_env,\n+                 TypeFunc_generator generator,\n+                 address stub_function,\n+                 const char *stub_name,\n+                 int is_fancy_jump,\n+                 bool pass_tls,\n+                 bool return_pc,\n+                 DirectiveSet* directive)\n+    : Phase(Compiler),\n+      _compile_id(0),\n+      _options(Options::for_runtime_stub()),\n+      _method(nullptr),\n+      _entry_bci(InvocationEntryBci),\n+      _stub_function(stub_function),\n+      _stub_name(stub_name),\n+      _stub_entry_point(nullptr),\n+      _max_node_limit(MaxNodeLimit),\n+      _post_loop_opts_phase(false),\n+      _allow_macro_nodes(true),\n+      _inlining_progress(false),\n+      _inlining_incrementally(false),\n+      _has_reserved_stack_access(false),\n+      _has_circular_inline_type(false),\n@@ -937,2 +934,2 @@\n-    _igv_idx(0),\n-    _trace_opto_output(directive->TraceOptoOutputOption),\n+      _igv_idx(0),\n+      _trace_opto_output(directive->TraceOptoOutputOption),\n@@ -940,35 +937,32 @@\n-    _has_method_handle_invokes(false),\n-    _clinit_barrier_on_entry(false),\n-    _stress_seed(0),\n-    _comp_arena(mtCompiler),\n-    _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n-    _env(ci_env),\n-    _directive(directive),\n-    _log(ci_env->log()),\n-    _first_failure_details(nullptr),\n-    _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n-    _congraph(nullptr),\n-    NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n-    _unique(0),\n-    _dead_node_count(0),\n-    _dead_node_list(comp_arena()),\n-    _node_arena_one(mtCompiler),\n-    _node_arena_two(mtCompiler),\n-    _node_arena(&_node_arena_one),\n-    _mach_constant_base_node(nullptr),\n-    _Compile_types(mtCompiler),\n-    _initial_gvn(nullptr),\n-    _igvn_worklist(nullptr),\n-    _types(nullptr),\n-    _node_hash(nullptr),\n-    _number_of_mh_late_inlines(0),\n-    _oom(false),\n-    _print_inlining_stream(new (mtCompiler) stringStream()),\n-    _print_inlining_list(nullptr),\n-    _print_inlining_idx(0),\n-    _print_inlining_output(nullptr),\n-    _replay_inline_data(nullptr),\n-    _java_calls(0),\n-    _inner_loops(0),\n-    _interpreter_frame_size(0),\n-    _output(nullptr),\n+      _has_method_handle_invokes(false),\n+      _clinit_barrier_on_entry(false),\n+      _stress_seed(0),\n+      _comp_arena(mtCompiler),\n+      _barrier_set_state(BarrierSet::barrier_set()->barrier_set_c2()->create_barrier_state(comp_arena())),\n+      _env(ci_env),\n+      _directive(directive),\n+      _log(ci_env->log()),\n+      _first_failure_details(nullptr),\n+      _for_post_loop_igvn(comp_arena(), 8, 0, nullptr),\n+      _congraph(nullptr),\n+      NOT_PRODUCT(_igv_printer(nullptr) COMMA)\n+          _unique(0),\n+      _dead_node_count(0),\n+      _dead_node_list(comp_arena()),\n+      _node_arena_one(mtCompiler),\n+      _node_arena_two(mtCompiler),\n+      _node_arena(&_node_arena_one),\n+      _mach_constant_base_node(nullptr),\n+      _Compile_types(mtCompiler),\n+      _initial_gvn(nullptr),\n+      _igvn_worklist(nullptr),\n+      _types(nullptr),\n+      _node_hash(nullptr),\n+      _number_of_mh_late_inlines(0),\n+      _oom(false),\n+      _replay_inline_data(nullptr),\n+      _inline_printer(this),\n+      _java_calls(0),\n+      _inner_loops(0),\n+      _interpreter_frame_size(0),\n+      _output(nullptr),\n@@ -976,1 +970,1 @@\n-    _in_dump_cnt(0),\n+      _in_dump_cnt(0),\n@@ -978,1 +972,1 @@\n-    _allowed_reasons(0) {\n+      _allowed_reasons(0) {\n@@ -1019,1 +1013,0 @@\n-  delete _print_inlining_stream;\n@@ -2584,1 +2577,1 @@\n-              cg->print_inlining_late(InliningResult::FAILURE, msg);\n+              inline_printer()->record(cg->method(), cg->call_node()->jvms(), InliningResult::FAILURE, msg);\n@@ -2708,2 +2701,0 @@\n-  print_inlining_reinit();\n-\n@@ -2969,2 +2960,0 @@\n- process_print_inlining();\n-\n@@ -4938,119 +4927,1 @@\n-\/\/ The message about the current inlining is accumulated in\n-\/\/ _print_inlining_stream and transferred into the _print_inlining_list\n-\/\/ once we know whether inlining succeeds or not. For regular\n-\/\/ inlining, messages are appended to the buffer pointed by\n-\/\/ _print_inlining_idx in the _print_inlining_list. For late inlining,\n-\/\/ a new buffer is added after _print_inlining_idx in the list. This\n-\/\/ way we can update the inlining message for late inlining call site\n-\/\/ when the inlining is attempted again.\n-void Compile::print_inlining_init() {\n-  if (print_inlining() || print_intrinsics()) {\n-    \/\/ print_inlining_init is actually called several times.\n-    print_inlining_reset();\n-    _print_inlining_list = new (comp_arena())GrowableArray<PrintInliningBuffer*>(comp_arena(), 1, 1, new PrintInliningBuffer());\n-  }\n-}\n-\n-void Compile::print_inlining_reinit() {\n-  if (print_inlining() || print_intrinsics()) {\n-    print_inlining_reset();\n-  }\n-}\n-\n-void Compile::print_inlining_reset() {\n-  _print_inlining_stream->reset();\n-}\n-\n-void Compile::print_inlining_commit() {\n-  assert(print_inlining() || print_intrinsics(), \"PrintInlining off?\");\n-  \/\/ Transfer the message from _print_inlining_stream to the current\n-  \/\/ _print_inlining_list buffer and clear _print_inlining_stream.\n-  _print_inlining_list->at(_print_inlining_idx)->ss()->write(_print_inlining_stream->base(), _print_inlining_stream->size());\n-  print_inlining_reset();\n-}\n-\n-void Compile::print_inlining_push() {\n-  \/\/ Add new buffer to the _print_inlining_list at current position\n-  _print_inlining_idx++;\n-  _print_inlining_list->insert_before(_print_inlining_idx, new PrintInliningBuffer());\n-}\n-\n-Compile::PrintInliningBuffer* Compile::print_inlining_current() {\n-  return _print_inlining_list->at(_print_inlining_idx);\n-}\n-\n-void Compile::print_inlining_update(CallGenerator* cg) {\n-  if (print_inlining() || print_intrinsics()) {\n-    if (cg->is_late_inline()) {\n-      if (print_inlining_current()->cg() != cg &&\n-          (print_inlining_current()->cg() != nullptr ||\n-           print_inlining_current()->ss()->size() != 0)) {\n-        print_inlining_push();\n-      }\n-      print_inlining_commit();\n-      print_inlining_current()->set_cg(cg);\n-    } else {\n-      if (print_inlining_current()->cg() != nullptr) {\n-        print_inlining_push();\n-      }\n-      print_inlining_commit();\n-    }\n-  }\n-}\n-\n-void Compile::print_inlining_move_to(CallGenerator* cg) {\n-  \/\/ We resume inlining at a late inlining call site. Locate the\n-  \/\/ corresponding inlining buffer so that we can update it.\n-  if (print_inlining() || print_intrinsics()) {\n-    for (int i = 0; i < _print_inlining_list->length(); i++) {\n-      if (_print_inlining_list->at(i)->cg() == cg) {\n-        _print_inlining_idx = i;\n-        return;\n-      }\n-    }\n-    ShouldNotReachHere();\n-  }\n-}\n-\n-void Compile::print_inlining_update_delayed(CallGenerator* cg) {\n-  if (print_inlining() || print_intrinsics()) {\n-    assert(_print_inlining_stream->size() > 0, \"missing inlining msg\");\n-    assert(print_inlining_current()->cg() == cg, \"wrong entry\");\n-    \/\/ replace message with new message\n-    _print_inlining_list->at_put(_print_inlining_idx, new PrintInliningBuffer());\n-    print_inlining_commit();\n-    print_inlining_current()->set_cg(cg);\n-  }\n-}\n-\n-void Compile::print_inlining_assert_ready() {\n-  assert(!_print_inlining || _print_inlining_stream->size() == 0, \"losing data\");\n-}\n-\n-void Compile::process_print_inlining() {\n-  assert(_late_inlines.length() == 0, \"not drained yet\");\n-  if (print_inlining() || print_intrinsics()) {\n-    ResourceMark rm;\n-    stringStream ss;\n-    assert(_print_inlining_list != nullptr, \"process_print_inlining should be called only once.\");\n-    for (int i = 0; i < _print_inlining_list->length(); i++) {\n-      PrintInliningBuffer* pib = _print_inlining_list->at(i);\n-      ss.print(\"%s\", pib->ss()->freeze());\n-      delete pib;\n-      DEBUG_ONLY(_print_inlining_list->at_put(i, nullptr));\n-    }\n-    \/\/ Reset _print_inlining_list, it only contains destructed objects.\n-    \/\/ It is on the arena, so it will be freed when the arena is reset.\n-    _print_inlining_list = nullptr;\n-    \/\/ _print_inlining_stream won't be used anymore, either.\n-    print_inlining_reset();\n-    size_t end = ss.size();\n-    _print_inlining_output = NEW_ARENA_ARRAY(comp_arena(), char, end+1);\n-    strncpy(_print_inlining_output, ss.freeze(), end+1);\n-    _print_inlining_output[end] = 0;\n-  }\n-}\n-\n-  if (_print_inlining_output != nullptr) {\n-    tty->print_raw(_print_inlining_output);\n-  }\n+  inline_printer()->print_on(tty);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":129,"deletions":258,"binary":false,"changes":387,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"opto\/printinlining.hpp\"\n@@ -482,23 +483,0 @@\n-  \/\/ Inlining may not happen in parse order which would make\n-  \/\/ PrintInlining output confusing. Keep track of PrintInlining\n-  \/\/ pieces in order.\n-  class PrintInliningBuffer : public CHeapObj<mtCompiler> {\n-   private:\n-    CallGenerator* _cg;\n-    stringStream   _ss;\n-    static const size_t default_stream_buffer_size = 128;\n-\n-   public:\n-    PrintInliningBuffer()\n-      : _cg(nullptr), _ss(default_stream_buffer_size) {}\n-\n-    stringStream* ss()             { return &_ss; }\n-    CallGenerator* cg()            { return _cg; }\n-    void set_cg(CallGenerator* cg) { _cg = cg; }\n-  };\n-\n-  stringStream* _print_inlining_stream;\n-  GrowableArray<PrintInliningBuffer*>* _print_inlining_list;\n-  int _print_inlining_idx;\n-  char* _print_inlining_output;\n-\n@@ -516,6 +494,0 @@\n-  void print_inlining_init();\n-  void print_inlining_reinit();\n-  void print_inlining_commit();\n-  void print_inlining_push();\n-  PrintInliningBuffer* print_inlining_current();\n-\n@@ -527,1 +499,1 @@\n- public:\n+  InlinePrinter _inline_printer;\n@@ -529,0 +501,1 @@\n+public:\n@@ -531,16 +504,1 @@\n-  stringStream* print_inlining_stream() {\n-    assert(print_inlining() || print_intrinsics(), \"PrintInlining off?\");\n-    return _print_inlining_stream;\n-  }\n-\n-  void print_inlining_update(CallGenerator* cg);\n-  void print_inlining_update_delayed(CallGenerator* cg);\n-  void print_inlining_move_to(CallGenerator* cg);\n-  void print_inlining_assert_ready();\n-  void print_inlining_reset();\n-\n-  void print_inlining(ciMethod* method, int inline_level, int bci, InliningResult result, const char* msg = nullptr) {\n-    stringStream ss;\n-    CompileTask::print_inlining_inner(&ss, method, inline_level, bci, result, msg);\n-    print_inlining_stream()->print(\"%s\", ss.freeze());\n-  }\n+  InlinePrinter* inline_printer() { return &_inline_printer; }\n@@ -1129,1 +1087,0 @@\n-  void process_print_inlining();\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":4,"deletions":47,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -53,2 +53,5 @@\n-static void print_trace_type_profile(outputStream* out, int depth, ciKlass* prof_klass, int site_count, int receiver_count) {\n-  CompileTask::print_inline_indent(depth, out);\n+static void print_trace_type_profile(outputStream* out, int depth, ciKlass* prof_klass, int site_count, int receiver_count,\n+                                     bool with_deco) {\n+  if (with_deco) {\n+    CompileTask::print_inline_indent(depth, out);\n+  }\n@@ -57,1 +60,3 @@\n-  out->cr();\n+  if (with_deco) {\n+    out->cr();\n+  }\n@@ -60,2 +65,4 @@\n-static void trace_type_profile(Compile* C, ciMethod* method, int depth, int bci, ciMethod* prof_method,\n-                               ciKlass* prof_klass, int site_count, int receiver_count) {\n+static void trace_type_profile(Compile* C, ciMethod* method, JVMState* jvms,\n+                               ciMethod* prof_method, ciKlass* prof_klass, int site_count, int receiver_count) {\n+  int depth = jvms->depth() - 1;\n+  int bci = jvms->bci();\n@@ -63,1 +70,0 @@\n-    outputStream* out = tty;\n@@ -70,0 +76,1 @@\n+      print_trace_type_profile(tty, depth, prof_klass, site_count, receiver_count, true);\n@@ -71,1 +78,2 @@\n-      out = C->print_inlining_stream();\n+      auto stream = C->inline_printer()->record(method, jvms, InliningResult::SUCCESS);\n+      print_trace_type_profile(stream, depth, prof_klass, site_count, receiver_count, false);\n@@ -73,1 +81,0 @@\n-    print_trace_type_profile(out, depth, prof_klass, site_count, receiver_count);\n@@ -79,1 +86,1 @@\n-    print_trace_type_profile(&ls, depth, prof_klass, site_count, receiver_count);\n+    print_trace_type_profile(&ls, depth, prof_klass, site_count, receiver_count, true);\n@@ -298,1 +305,1 @@\n-              trace_type_profile(C, jvms->method(), jvms->depth() - 1, jvms->bci(), next_receiver_method, profile.receiver(1), site_count, profile.receiver_count(1));\n+              trace_type_profile(C, jvms->method(), jvms, next_receiver_method, profile.receiver(1), site_count, profile.receiver_count(1));\n@@ -305,1 +312,1 @@\n-              trace_type_profile(C, jvms->method(), jvms->depth() - 1, jvms->bci(), receiver_method, k, site_count, receiver_count);\n+              trace_type_profile(C, jvms->method(), jvms, receiver_method, k, site_count, receiver_count);\n@@ -308,1 +315,3 @@\n-              if (cg != nullptr)  return cg;\n+              if (cg != nullptr) {\n+                return cg;\n+              }\n@@ -375,3 +384,1 @@\n-    if (C->print_inlining()) {\n-      print_inlining(callee, jvms->depth() - 1, jvms->bci(), InliningResult::FAILURE, msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::FAILURE, msg);\n@@ -516,2 +523,0 @@\n-  C->print_inlining_assert_ready();\n-\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -996,0 +996,1 @@\n+  Node* one = _igvn->intcon(1);\n@@ -999,1 +1000,1 @@\n-  Node* res_phi  = _igvn->transform(PhiNode::make(ophi->in(0), zero, TypeInt::INT));\n+  Node* res_phi = PhiNode::make(ophi->in(0), zero, TypeInt::INT);\n@@ -1007,1 +1008,6 @@\n-      res_phi_input = _igvn->makecon(tcmp);\n+      if ((mask == BoolTest::mask::eq && tcmp == TypeInt::CC_EQ) ||\n+          (mask == BoolTest::mask::ne && tcmp == TypeInt::CC_GT)) {\n+        res_phi_input = one;\n+      } else {\n+        res_phi_input = zero;\n+      }\n@@ -1019,1 +1025,2 @@\n-  Node* new_cmp = _igvn->transform(new CmpINode(res_phi, zero));\n+  \/\/ This CMP always compares whether the output of \"res_phi\" is TRUE as far as the \"mask\".\n+  Node* new_cmp = _igvn->transform(new CmpINode(_igvn->transform(res_phi), (mask == BoolTest::mask::eq) ? one : zero));\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -123,3 +123,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::SUCCESS, inline_msg);\n@@ -135,1 +133,0 @@\n-    C->print_inlining_update(this);\n@@ -151,3 +148,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::FAILURE, msg);\n@@ -168,1 +163,0 @@\n-  C->print_inlining_update(this);\n@@ -194,3 +188,2 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n-    }\n+    C->inline_printer()->record(callee, jvms, InliningResult::SUCCESS, inline_msg);\n+\n@@ -212,3 +205,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining(kit.callee(), jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n-    }\n+    C->inline_printer()->record(kit.callee(), jvms, InliningResult::FAILURE, msg);\n@@ -224,3 +215,1 @@\n-    if (C->print_intrinsics() || C->print_inlining()) {\n-      C->print_inlining_stream()->print(\"%s\", msg);\n-    }\n+    C->inline_printer()->record(kit.callee(), jvms, InliningResult::FAILURE, msg);\n@@ -3978,0 +3967,14 @@\n+  \/\/ True branch, pin count over\/underflow.\n+  Node* pin_count_over_underflow = _gvn.transform(new IfTrueNode(iff_pin_count_over_underflow));\n+  {\n+    \/\/ Trap (but not deoptimize (Action_none)) and continue in the interpreter\n+    \/\/ which will throw IllegalStateException for pin count over\/underflow.\n+    \/\/ No memory changed so far - we can use memory create by reset_memory()\n+    \/\/ at the beginning of this intrinsic. No need to call reset_memory() again.\n+    PreserveJVMState pjvms(this);\n+    set_control(pin_count_over_underflow);\n+    uncommon_trap(Deoptimization::Reason_intrinsic,\n+                  Deoptimization::Action_none);\n+    assert(stopped(), \"invariant\");\n+  }\n+\n@@ -3989,14 +3992,1 @@\n-  Node* updated_pin_count_memory = store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, MemNode::unordered);\n-\n-  \/\/ True branch, pin count over\/underflow.\n-  Node* pin_count_over_underflow = _gvn.transform(new IfTrueNode(iff_pin_count_over_underflow));\n-  {\n-    \/\/ Trap (but not deoptimize (Action_none)) and continue in the interpreter\n-    \/\/ which will throw IllegalStateException for pin count over\/underflow.\n-    PreserveJVMState pjvms(this);\n-    set_control(pin_count_over_underflow);\n-    set_all_memory(input_memory_state);\n-    uncommon_trap_exact(Deoptimization::Reason_intrinsic,\n-                        Deoptimization::Action_none);\n-    assert(stopped(), \"invariant\");\n-  }\n+  store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, MemNode::unordered);\n@@ -4012,1 +4002,1 @@\n-  result_mem->init_req(_true_path, _gvn.transform(updated_pin_count_memory));\n+  result_mem->init_req(_true_path, _gvn.transform(reset_memory()));\n@@ -4530,1 +4520,6 @@\n-    *obj = _gvn.transform(new CastPPNode(is_array_ctrl, *obj, TypeAryPtr::BOTTOM));\n+    Node* cast = _gvn.transform(new CastPPNode(is_array_ctrl, *obj, TypeAryPtr::BOTTOM));\n+    \/\/ Check for top because in rare cases, the type system can determine that\n+    \/\/ the object can't be an array but the layout helper check is not folded.\n+    if (!cast->is_top()) {\n+      *obj = cast;\n+    }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":28,"deletions":33,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -111,0 +111,4 @@\n+      if (res->is_top()) {\n+        assert(false, \"Can't determine return value.\");\n+        C->record_method_not_compilable(\"Can't determine return value.\");\n+      }\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -551,4 +551,0 @@\n-\n-      C->print_inlining_assert_ready();\n-      C->print_inlining_move_to(cg);\n-      C->print_inlining_update(cloned_cg);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-                            int caller_bci,\n+                            JVMState* caller_jvms,\n@@ -90,2 +90,1 @@\n-  void        print_inlining(ciMethod* callee_method, int caller_bci,\n-                             ciMethod* caller_method, bool success) const;\n+  void print_inlining(ciMethod* callee_method, JVMState* jvm, bool success) const;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -308,2 +308,0 @@\n-  VirtualSpace vs;\n-  vs.initialize(rhs, 50 * granularity);\n@@ -312,1 +310,1 @@\n-  if (!( UseCompressedOops && rhs.base() != nullptr &&\n+  if (!( UseCompressedOops && rhs.is_reserved() &&\n@@ -326,0 +324,4 @@\n+\n+  VirtualSpace vs;\n+  vs.initialize(rhs, 50 * granularity);\n+\n@@ -335,0 +337,5 @@\n+  if (!rhs.is_reserved()) {\n+    tty->print_cr(\"Failed to initialize ReservedSpace. Can't proceed.\");\n+    return 3;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -812,6 +812,0 @@\n-#if INCLUDE_JVMCI\n-  if (force_JVMCI_initialization) {\n-    JVMCI::initialize_compiler(CHECK_JNI_ERR);\n-  }\n-#endif\n-\n@@ -832,0 +826,6 @@\n+#if INCLUDE_JVMCI\n+  if (force_JVMCI_initialization) {\n+    JVMCI::initialize_compiler(CHECK_JNI_ERR);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,0 +1268,2 @@\n+        DEBUG_ONLY(COMPILER2_OR_JVMCI_PRESENT(                            \\\n+          declare_type(DeoptimizeObjectsALotThread, JavaThread)))         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -449,1 +449,1 @@\n-            StringUTF16.getChars(i, size, buf);\n+            DecimalDigits.getCharsUTF16(i, size, buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -476,1 +476,1 @@\n-            StringLatin1.getChars(i, size, buf);\n+            DecimalDigits.getCharsLatin1(i, size, buf);\n@@ -480,1 +480,1 @@\n-            StringUTF16.getChars(i, size, buf);\n+            DecimalDigits.getCharsUTF16(i, size, buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2183,8 +2183,0 @@\n-            public int getCharsLatin1(long i, int index, byte[] buf) {\n-                return StringLatin1.getChars(i, index, buf);\n-            }\n-\n-            public int getCharsUTF16(long i, int index, byte[] buf) {\n-                return StringUTF16.getChars(i, index, buf);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,10 @@\n- * A marker interface for elements that can appear when traversing\n- * a {@link ClassModel} or be presented to a {@link ClassBuilder}.\n+ * Marker interface for a member element of a {@link ClassModel}.  Such an\n+ * element can appear when traversing a {@link ClassModel} unless otherwise\n+ * specified, be supplied to a {@link ClassBuilder}, and be processed by a\n+ * {@link ClassTransform}.\n+ * <p>\n+ * {@link AccessFlags}, and {@link ClassFileVersion} are member elements of a\n+ * class that appear exactly once during the traversal of a {@link ClassModel}.\n+ * {@link Superclass} and {@link Interfaces} may be absent or appear at most\n+ * once.  A {@link ClassBuilder} may provide an alternative superclass if it is\n+ * not defined but required.\n@@ -33,0 +41,4 @@\n+ * @see ClassFileElement##membership Membership Elements\n+ * @see MethodElement\n+ * @see FieldElement\n+ * @see CodeElement\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassElement.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.AttributeMapper.AttributeStability;\n@@ -29,0 +30,1 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -32,0 +34,2 @@\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.classfile.attribute.UnknownAttribute;\n@@ -36,0 +40,1 @@\n+import java.lang.classfile.instruction.CharacterRange;\n@@ -38,0 +43,3 @@\n+import java.lang.classfile.instruction.LineNumber;\n+import java.lang.classfile.instruction.LocalVariable;\n+import java.lang.classfile.instruction.LocalVariableType;\n@@ -40,0 +48,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -53,3 +62,3 @@\n- * Represents a context for parsing, transforming, and generating classfiles.\n- * A {@code ClassFile} has a set of options that condition how parsing and\n- * generation is done.\n+ * Provides ability to parse, transform, and generate {@code class} files.\n+ * A {@code ClassFile} is a context with a set of options that condition how\n+ * parsing and generation are done.\n@@ -63,1 +72,6 @@\n-     * {@return a context with default options}\n+     * {@return a context with default options}  Each subtype of {@link Option}\n+     * specifies its default.\n+     * <p>\n+     * The default {@link AttributeMapperOption} and {@link\n+     * ClassHierarchyResolverOption} may be unsuitable for some {@code class}\n+     * files and result in parsing or generation errors.\n@@ -70,1 +84,2 @@\n-     * {@return a new context with options altered from the default}\n+     * {@return a context with options altered from the default}  Equivalent to\n+     * {@link #of() ClassFile.of().withOptions(options)}.\n@@ -78,1 +93,1 @@\n-     * {@return a copy of the context with altered options}\n+     * {@return a context with altered options from this context}\n@@ -84,1 +99,1 @@\n-     * An option that affects the parsing and writing of classfiles.\n+     * An option that affects the parsing or writing of {@code class} files.\n@@ -86,0 +101,1 @@\n+     * @see java.lang.classfile##options Options\n@@ -93,2 +109,15 @@\n-     * Option describing attribute mappers for custom attributes.\n-     * Default is only to process standard attributes.\n+     * The option describing user-defined attributes for parsing {@code class}\n+     * files.  The default does not recognize any user-defined attribute.\n+     * <p>\n+     * An {@code AttributeMapperOption} contains a function that maps an\n+     * attribute name to a user attribute mapper. The function may return {@code\n+     * null} if it does not recognize an attribute name.  The returned mapper\n+     * must ensure its {@link AttributeMapper#name() name()} is equivalent to\n+     * the {@link Utf8Entry#stringValue() stringValue()} of the input {@link\n+     * Utf8Entry}.\n+     * <p>\n+     * The mapping function in this attribute has lower priority than mappers in\n+     * {@link Attributes}, so it is impossible to override built-in attributes\n+     * with this option.  If an attribute is not recognized by any mapper in\n+     * {@link Attributes} and is not assigned a mapper, or recognized, by this\n+     * option, that attribute will be modeled by an {@link UnknownAttribute}.\n@@ -96,0 +125,2 @@\n+     * @see AttributeMapper\n+     * @see CustomAttribute\n@@ -102,1 +133,2 @@\n-         * {@return an option describing attribute mappers for custom attributes}\n+         * {@return an option describing user-defined attributes for parsing}\n+         *\n@@ -117,2 +149,14 @@\n-     * Option describing the class hierarchy resolver to use when generating\n-     * stack maps.\n+     * The option describing the class hierarchy resolver to use when generating\n+     * stack maps or verifying classes.  The default is {@link\n+     * ClassHierarchyResolver#defaultResolver()}, which uses core reflection to\n+     * find a class with a given name in {@linkplain ClassLoader#getSystemClassLoader()\n+     * system class loader} and inspect it, and is insufficient if a class is\n+     * not present in the system class loader as in applications, or if loading\n+     * of system classes is not desired as in agents.\n+     * <p>\n+     * A {@code ClassHierarchyResolverOption} contains a {@link ClassHierarchyResolver}.\n+     * The resolver must be able to process all classes and interfaces, including\n+     * those appearing as the component types of array types, that appear in the\n+     * operand stack of the generated bytecode.  If the resolver fails on any\n+     * of the classes and interfaces with an {@link IllegalArgumentException},\n+     * the {@code class} file generation fails.\n@@ -120,0 +164,2 @@\n+     * @see ClassHierarchyResolver\n+     * @jvms 4.10.1.2 Verification Type System\n@@ -126,2 +172,2 @@\n-         * {@return an option describing the class hierarchy resolver to use when\n-         * generating stack maps}\n+         * {@return an option describing the class hierarchy resolver to use}\n+         *\n@@ -142,8 +188,16 @@\n-     * Option describing whether to preserve the original constant pool when\n-     * transforming a {@code class} file.  Reusing the constant pool enables\n-     * significant optimizations in processing time and minimizes differences\n-     * between the original and transformed {@code class} files, but may result\n-     * in a bigger transformed {@code class} file when many elements of the\n-     * original {@code class} file are dropped and many original constant\n-     * pool entries become unused.  Default is {@link #SHARED_POOL} to preserve\n-     * the original constant pool.\n+     * Option describing whether to extend from the original constant pool when\n+     * transforming a {@code class} file.  The default is {@link #SHARED_POOL}\n+     * to extend from the original constant pool.\n+     * <p>\n+     * This option affects all overloads of {@link #transformClass transformClass}.\n+     * Extending from the original constant pool keeps the indices into the\n+     * constant pool intact, which enables significant optimizations in processing\n+     * time and minimizes differences between the original and transformed {@code\n+     * class} files, but may result in a bigger transformed {@code class} file\n+     * when many elements of the original {@code class} file are dropped and\n+     * many original constant pool entries become unused.\n+     * <p>\n+     * An alternative to this option is to use {@link #build(ClassEntry,\n+     * ConstantPoolBuilder, Consumer)} directly.  It allows extension from\n+     * arbitrary constant pools, and may be useful if a built {@code class} file\n+     * reuses structures from multiple original {@code class} files.\n@@ -159,2 +213,2 @@\n-         * Preserves the original constant pool when transforming the {@code\n-         * class} file.\n+         * Extend the new constant pool from the original constant pool when\n+         * transforming the {@code class} file.\n@@ -197,3 +251,9 @@\n-     * Option describing whether to patch out unreachable code.\n-     * Default is {@code PATCH_DEAD_CODE} to automatically patch out unreachable\n-     * code with NOPs.\n+     * The option describing whether to patch out unreachable code for stack map\n+     * generation.  The default is {@link #PATCH_DEAD_CODE} to automatically\n+     * patch unreachable code and generate a valid stack map entry for the\n+     * patched code.\n+     * <p>\n+     * The stack map generation process may fail when it encounters unreachable\n+     * code and {@link #KEEP_DEAD_CODE} is set.  In such cases, users should\n+     * set {@link StackMapsOption#DROP_STACK_MAPS} and provide their own stack\n+     * maps that passes verification (JVMS {@jvms 4.10.1}).\n@@ -201,0 +261,2 @@\n+     * @see StackMapsOption\n+     * @jvms 4.10.1 Verification by Type Checking\n@@ -205,1 +267,5 @@\n-        \/** Patch unreachable code *\/\n+        \/**\n+         * Patch unreachable code with dummy code, and generate valid dummy\n+         * stack map entries.  This ensures the generated code can pass\n+         * verification (JVMS {@jvms 4.10.1}).\n+         *\/\n@@ -208,1 +274,6 @@\n-        \/** Keep the unreachable code *\/\n+        \/**\n+         * Keep the unreachable code for the accuracy of the generated {@code\n+         * class} file.  Users should set {@link StackMapsOption#DROP_STACK_MAPS}\n+         * to prevent stack map generation from running and provide their own\n+         * {@link StackMapTableAttribute} to a {@link CodeBuilder}.\n+         *\/\n@@ -213,7 +284,13 @@\n-     * Option describing whether to filter unresolved labels.\n-     * Default is {@code FAIL_ON_DEAD_LABELS} to throw IllegalArgumentException\n-     * when any {@link ExceptionCatch}, {@link LocalVariableInfo},\n-     * {@link LocalVariableTypeInfo}, or {@link CharacterRangeInfo}\n-     * reference to unresolved {@link Label} during bytecode serialization.\n-     * Setting this option to {@code DROP_DEAD_LABELS} filters the above\n-     * elements instead.\n+     * The option describing whether to filter {@linkplain\n+     * CodeBuilder#labelBinding(Label) unbound labels} and drop their\n+     * enclosing structures if possible.  The default is {@link\n+     * #FAIL_ON_DEAD_LABELS} to fail fast with an {@link IllegalArgumentException}\n+     * when a {@link PseudoInstruction} refers to an unbound label during\n+     * bytecode generation.\n+     * <p>\n+     * The affected {@link PseudoInstruction}s include {@link ExceptionCatch},\n+     * {@link LocalVariable}, {@link LocalVariableType}, and {@link\n+     * CharacterRange}.  Setting this option to {@link #DROP_DEAD_LABELS}\n+     * filters these pseudo-instructions from a {@link CodeBuilder} instead.\n+     * Note that instructions, such as {@link BranchInstruction}, with unbound\n+     * labels always fail-fast with an {@link IllegalArgumentException}.\n@@ -221,0 +298,1 @@\n+     * @see DebugElementsOption\n@@ -225,1 +303,5 @@\n-        \/** Fail on unresolved labels *\/\n+        \/**\n+         * Fail fast on {@linkplain CodeBuilder#labelBinding(Label) unbound\n+         * labels}.  This also ensures the accuracy of the generated {@code\n+         * class} files.\n+         *\/\n@@ -228,1 +310,6 @@\n-        \/** Filter unresolved labels *\/\n+        \/**\n+         * Filter {@link PseudoInstruction}s with {@linkplain\n+         * CodeBuilder#labelBinding(Label) unbound labels}.  Note that\n+         * instructions with unbound labels still cause an {@link\n+         * IllegalArgumentException}.\n+         *\/\n@@ -233,5 +320,9 @@\n-     * Option describing whether to process or discard debug elements.\n-     * Debug elements include the local variable table, local variable type\n-     * table, and character range table.  Discarding debug elements may\n-     * reduce the overhead of parsing or transforming classfiles.\n-     * Default is {@code PASS_DEBUG} to process debug elements.\n+     * The option describing whether to process or discard debug {@link\n+     * PseudoInstruction}s in the traversal of a {@link CodeModel} or a {@link\n+     * CodeBuilder}.  The default is {@link #PASS_DEBUG} to process debug\n+     * pseudo-instructions as all other {@link CodeElement}.\n+     * <p>\n+     * Debug pseudo-instructions include {@link LocalVariable}, {@link\n+     * LocalVariableType}, and {@link CharacterRange}.  Discarding debug\n+     * elements may reduce the overhead of parsing or transforming {@code class}\n+     * files and has no impact on the run-time behavior.\n@@ -239,0 +330,1 @@\n+     * @see LineNumbersOption\n@@ -243,1 +335,4 @@\n-        \/** Process debug elements *\/\n+        \/**\n+         * Process debug pseudo-instructions like other member elements of a\n+         * {@link CodeModel}.\n+         *\/\n@@ -246,1 +341,3 @@\n-        \/** Drop debug elements *\/\n+        \/**\n+         * Drop debug pseudo-instructions from traversal and builders.\n+         *\/\n@@ -251,1 +348,5 @@\n-     * Option describing whether to process or discard line numbers.\n+     * The option describing whether to process or discard {@link LineNumber}s\n+     * in the traversal of a {@link CodeModel} or a {@link CodeBuilder}.  The\n+     * default is {@link #PASS_LINE_NUMBERS} to process all line number entries\n+     * as all other {@link CodeElement}.\n+     * <p>\n@@ -253,2 +354,1 @@\n-     * classfiles.\n-     * Default is {@code PASS_LINE_NUMBERS} to process line numbers.\n+     * {@code class} files and has no impact on the run-time behavior.\n@@ -256,0 +356,1 @@\n+     * @see DebugElementsOption\n@@ -260,1 +361,4 @@\n-        \/** Process line numbers *\/\n+        \/**\n+         * Process {@link LineNumber} like other member elements of a {@link\n+         * CodeModel}.\n+         *\/\n@@ -263,1 +367,3 @@\n-        \/** Drop line numbers *\/\n+        \/**\n+         * Drop {@link LineNumber} from traversal and builders.\n+         *\/\n@@ -268,4 +374,3 @@\n-     * Option describing whether to automatically rewrite short jumps to\n-     * long when necessary.\n-     * Default is {@link #FIX_SHORT_JUMPS} to automatically rewrite jump\n-     * instructions.\n+     * The option describing whether to automatically rewrite short jumps to\n+     * equivalent instructions when necessary.  The default is {@link\n+     * #FIX_SHORT_JUMPS} to automatically rewrite.\n@@ -278,0 +383,5 @@\n+     * <p>\n+     * Disabling rewrite can ensure the physical accuracy of a generated {@code\n+     * class} file and avoid the overhead from a failed first attempt for\n+     * overflowing forward jumps in some cases, if the generated {@code class}\n+     * file is stable.\n@@ -297,1 +407,2 @@\n-         * class} file.\n+         * class} file and avoids the overhead from a failed first attempt for\n+         * overflowing forward jumps in some cases.\n@@ -303,5 +414,15 @@\n-     * Option describing whether to generate stackmaps.\n-     * Default is {@code STACK_MAPS_WHEN_REQUIRED} to generate stack\n-     * maps for {@link #JAVA_6_VERSION} or above, where specifically for\n-     * {@link #JAVA_6_VERSION} the stack maps may not be generated.\n-     * @jvms 4.10.1 Verification by Type Checking\n+     * The option describing whether to generate stack maps.  The default is\n+     * {@link #STACK_MAPS_WHEN_REQUIRED} to generate stack maps or reuse\n+     * existing ones if compatible.\n+     * <p>\n+     * The {@link StackMapTableAttribute} is a derived property from a {@link\n+     * CodeAttribute Code} attribute to allow a Java Virtual Machine to perform\n+     * verification in one pass.  Thus, it is not modeled as part of a {@link\n+     * CodeModel}, but computed on-demand instead via stack maps generation.\n+     * <p>\n+     * Stack map generation may fail with an {@link IllegalArgumentException} if\n+     * there is {@linkplain DeadCodeOption unreachable code} or legacy\n+     * {@linkplain DiscontinuedInstruction.JsrInstruction jump routine}\n+     * instructions.  When {@link #DROP_STACK_MAPS} option is used, users can\n+     * provide their own stack maps by supplying a {@link StackMapTableAttribute}\n+     * to a {@link CodeBuilder}.\n@@ -309,0 +430,3 @@\n+     * @see StackMapTableAttribute\n+     * @see DeadCodeOption\n+     * @jvms 4.10.1 Verification by Type Checking\n@@ -313,1 +437,11 @@\n-        \/** Generate stack maps when required *\/\n+        \/**\n+         * Generate stack maps or reuse existing ones if compatible.  Stack maps\n+         * are present on major versions {@value #JAVA_6_VERSION} or above.  For\n+         * these versions, {@link CodeBuilder} tries to reuse compatible stack\n+         * maps information if the code array and exception handlers are still\n+         * compatible after a transformation; otherwise, it runs stack map\n+         * generation.  However, it does not fail fast if the major version is\n+         * {@value #JAVA_6_VERSION}, which allows jump subroutine instructions\n+         * that are incompatible with stack maps to exist in the {@code code}\n+         * array.\n+         *\/\n@@ -316,1 +450,5 @@\n-        \/** Always generate stack maps *\/\n+        \/**\n+         * Forces running stack map generation.  This runs stack map generation\n+         * unconditionally and fails fast if the generation fails due to any\n+         * reason.\n+         *\/\n@@ -319,1 +457,11 @@\n-        \/** Drop stack maps from code *\/\n+        \/**\n+         * Do not run stack map generation.  Users must supply their own\n+         * {@link StackMapTableAttribute} to a {@link CodeBuilder} if the code\n+         * has branches or exception handlers; otherwise, the generated code\n+         * will fail verification (JVMS {@jvms 4.10.1}).\n+         * <p>\n+         * This option is required for user-supplied {@link StackMapTableAttribute}\n+         * to be respected.  Stack maps on an existing {@link CodeAttribute Code}\n+         * attribute can be reused as below with this option:\n+         * {@snippet lang=java file=\"PackageSnippets.java\" region=\"manual-reuse-stack-maps\"}\n+         *\/\n@@ -324,5 +472,14 @@\n-     * Option describing whether to process or discard unrecognized or problematic\n-     * original attributes when a class, record component, field, method or code is\n-     * transformed in its exploded form.\n-     * Default is {@code PASS_ALL_ATTRIBUTES} to process all original attributes.\n-     * @see AttributeMapper.AttributeStability\n+     * The option describing whether to retain or discard attributes that cannot\n+     * verify their correctness after a transformation.  The default is {@link\n+     * #PASS_ALL_ATTRIBUTES} to retain all attributes as-is.\n+     * <p>\n+     * Many attributes only depend on data managed by the Class-File API, such\n+     * as constant pool entries or labels into the {@code code} array.  If they\n+     * change, the Class-File API knows their updated values and can write a\n+     * correct version by expanding the structures and recomputing the updated\n+     * indexes, known as \"explosion\".  However, some attributes, such as type\n+     * annotations, depend on arbitrary data that may be modified during\n+     * transformations but the Class-File API does not track, such as index to\n+     * an entry in the {@linkplain ClassModel#interfaces() interfaces} of a\n+     * {@code ClassFile} structure.  As a result, the Class-File API cannot\n+     * verify the correctness of such information.\n@@ -330,0 +487,1 @@\n+     * @see AttributeStability\n@@ -334,1 +492,3 @@\n-        \/** Process all original attributes during transformation *\/\n+        \/**\n+         * Retain all original attributes during transformation.\n+         *\/\n@@ -337,1 +497,4 @@\n-        \/** Drop unknown attributes during transformation *\/\n+        \/**\n+         * Drop attributes with {@link AttributeStability#UNKNOWN} data\n+         * dependency during transformation.\n+         *\/\n@@ -340,1 +503,4 @@\n-        \/** Drop unknown and unstable original attributes during transformation *\/\n+        \/**\n+         * Drop attributes with {@link AttributeStability#UNSTABLE} or higher\n+         * data dependency during transformation.\n+         *\/\n@@ -345,2 +511,8 @@\n-     * Parse a classfile into a {@link ClassModel}.\n-     * @param bytes the bytes of the classfile\n+     * Parses a {@code class} file into a {@link ClassModel}.\n+     * <p>\n+     * Due to the on-demand nature of {@code class} file parsing, an {@link\n+     * IllegalArgumentException} may be thrown on any accessor method invocation\n+     * on the returned model or any structure returned by the accessors in the\n+     * structure hierarchy.\n+     *\n+     * @param bytes the bytes of the {@code class} file\n@@ -348,2 +520,3 @@\n-     * @throws IllegalArgumentException or its subclass if the classfile format is\n-     * not supported or an incompatibility prevents parsing of the classfile\n+     * @throws IllegalArgumentException if the {@code class} file is malformed\n+     *         or of a version {@linkplain #latestMajorVersion() not supported}\n+     *         by the current runtime\n@@ -354,2 +527,8 @@\n-     * Parse a classfile into a {@link ClassModel}.\n-     * @param path the path to the classfile\n+     * Parses a {@code class} into a {@link ClassModel}.\n+     * <p>\n+     * Due to the on-demand nature of {@code class} file parsing, an {@link\n+     * IllegalArgumentException} may be thrown on any accessor method invocation\n+     * on the returned model or any structure returned by the accessors in the\n+     * structure hierarchy.\n+     *\n+     * @param path the path to the {@code class} file\n@@ -357,3 +536,5 @@\n-     * @throws java.io.IOException if an I\/O error occurs\n-     * @throws IllegalArgumentException or its subclass if the classfile format is\n-     * not supported or an incompatibility prevents parsing of the classfile\n+     * @throws IOException if an I\/O error occurs\n+     * @throws IllegalArgumentException if the {@code class} file is malformed\n+     *         or of a version {@linkplain #latestMajorVersion() not supported}\n+     *         by the current runtime\n+     * @see #parse(byte[])\n@@ -366,1 +547,2 @@\n-     * Build a classfile into a byte array.\n+     * Builds a {@code class} file into a byte array.\n+     *\n@@ -369,2 +551,3 @@\n-     * @return the classfile bytes\n-     * @throws IllegalArgumentException if {@code thisClass} represents a primitive type\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if {@code thisClass} represents a\n+     *         primitive type or building encounters a failure\n@@ -379,2 +562,2 @@\n-     * Build a classfile into a byte array using the provided constant pool\n-     * builder.\n+     * Builds a {@code class} file into a byte array using the provided constant\n+     * pool builder.\n@@ -385,1 +568,2 @@\n-     * @return the classfile bytes\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if building encounters a failure\n@@ -392,1 +576,2 @@\n-     * Build a classfile into a file.\n+     * Builds a {@code class} file into a file in a file system.\n+     *\n@@ -396,1 +581,2 @@\n-     * @throws java.io.IOException if an I\/O error occurs\n+     * @throws IOException if an I\/O error occurs\n+     * @throws IllegalArgumentException if building encounters a failure\n@@ -405,2 +591,2 @@\n-     * Build a classfile into a file using the provided constant pool\n-     * builder.\n+     * Builds a {@code class} file into a file in a file system using the\n+     * provided constant pool builder.\n@@ -412,1 +598,2 @@\n-     * @throws java.io.IOException if an I\/O error occurs\n+     * @throws IOException if an I\/O error occurs\n+     * @throws IllegalArgumentException if building encounters a failure\n@@ -422,1 +609,2 @@\n-     * Build a module descriptor into a byte array.\n+     * Builds a module descriptor into a byte array.\n+     *\n@@ -424,1 +612,2 @@\n-     * @return the classfile bytes\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if building encounters a failure\n@@ -431,1 +620,2 @@\n-     * Build a module descriptor into a byte array.\n+     * Builds a module descriptor into a byte array.\n+     *\n@@ -434,1 +624,2 @@\n-     * @return the classfile bytes\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if building encounters a failure\n@@ -437,1 +628,1 @@\n-                                     Consumer<? super ClassBuilder> handler) {\n+                               Consumer<? super ClassBuilder> handler) {\n@@ -446,1 +637,2 @@\n-     * Build a module descriptor into a file.\n+     * Builds a module descriptor into a file in a file system.\n+     *\n@@ -449,1 +641,2 @@\n-     * @throws java.io.IOException if an I\/O error occurs\n+     * @throws IOException if an I\/O error occurs\n+     * @throws IllegalArgumentException if building encounters a failure\n@@ -457,1 +650,2 @@\n-     * Build a module descriptor into a file.\n+     * Builds a module descriptor into a file in a file system.\n+     *\n@@ -461,1 +655,2 @@\n-     * @throws java.io.IOException if an I\/O error occurs\n+     * @throws IOException if an I\/O error occurs\n+     * @throws IllegalArgumentException if building encounters a failure\n@@ -470,2 +665,2 @@\n-     * Transform one classfile into a new classfile with the aid of a\n-     * {@link ClassTransform}.  The transform will receive each element of\n+     * Transform one {@code class} file into a new {@code class} file according\n+     * to a {@link ClassTransform}.  The transform will receive each element of\n@@ -475,2 +670,1 @@\n-     *\n-     * @implNote\n+     * <p>\n@@ -479,2 +673,3 @@\n-     *     this.build(model.thisClass(), ConstantPoolBuilder.of(model),\n-     *                     clb -> clb.transform(model, transform));\n+     * ConstantPoolBuilder cpb = null; \/\/ @replace substring=null; replacement=...\n+     * this.build(model.thisClass(), cpb,\n+     *            clb -> clb.transform(model, transform));\n@@ -482,0 +677,8 @@\n+     * where {@code cpb} is determined by {@link ConstantPoolSharingOption}.\n+     *\n+     * @apiNote\n+     * This is named {@code transformClass} instead of {@code transform} for\n+     * consistency with {@link ClassBuilder#transformField}, {@link\n+     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n+     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n+     * more generic and powerful.\n@@ -486,0 +689,2 @@\n+     * @throws IllegalArgumentException if building encounters a failure\n+     * @see ConstantPoolSharingOption\n@@ -492,2 +697,2 @@\n-     * Transform one classfile into a new classfile with the aid of a\n-     * {@link ClassTransform}.  The transform will receive each element of\n+     * Transform one {@code class} file into a new {@code class} file according\n+     * to a {@link ClassTransform}.  The transform will receive each element of\n@@ -498,0 +703,7 @@\n+     * @apiNote\n+     * This is named {@code transformClass} instead of {@code transform} for\n+     * consistency with {@link ClassBuilder#transformField}, {@link\n+     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n+     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n+     * more generic and powerful.\n+     *\n@@ -502,0 +714,2 @@\n+     * @throws IllegalArgumentException if building encounters a failure\n+     * @see ConstantPoolSharingOption\n@@ -508,2 +722,2 @@\n-     * Transform one classfile into a new classfile with the aid of a\n-     * {@link ClassTransform}.  The transform will receive each element of\n+     * Transform one {@code class} file into a new {@code class} file according\n+     * to a {@link ClassTransform}.  The transform will receive each element of\n@@ -513,2 +727,1 @@\n-     *\n-     * @implNote\n+     * <p>\n@@ -517,2 +730,2 @@\n-     *     this.build(newClassName, ConstantPoolBuilder.of(model),\n-     *                     clb -> clb.transform(model, transform));\n+     * ConstantPoolBuilder cpb = null; \/\/ @replace substring=null; replacement=...\n+     * this.build(newClassName, cpb, clb -> clb.transform(model, transform));\n@@ -520,0 +733,8 @@\n+     * where {@code cpb} is determined by {@link ConstantPoolSharingOption}.\n+     *\n+     * @apiNote\n+     * This is named {@code transformClass} instead of {@code transform} for\n+     * consistency with {@link ClassBuilder#transformField}, {@link\n+     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n+     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n+     * more generic and powerful.\n@@ -525,0 +746,2 @@\n+     * @throws IllegalArgumentException if building encounters a failure\n+     * @see ConstantPoolSharingOption\n@@ -529,1 +752,2 @@\n-     * Verify a classfile.  Any verification errors found will be returned.\n+     * Verify a {@code class} file.  All verification errors found will be returned.\n+     *\n@@ -531,1 +755,1 @@\n-     * @return a list of verification errors, or an empty list if no errors are\n+     * @return a list of verification errors, or an empty list if no error is\n@@ -537,3 +761,4 @@\n-     * Verify a classfile.  Any verification errors found will be returned.\n-     * @param bytes the classfile bytes to verify\n-     * @return a list of verification errors, or an empty list if no errors are\n+     * Verify a {@code class} file.  All verification errors found will be returned.\n+     *\n+     * @param bytes the {@code class} file bytes to verify\n+     * @return a list of verification errors, or an empty list if no error is\n@@ -545,3 +770,4 @@\n-     * Verify a classfile.  Any verification errors found will be returned.\n-     * @param path the classfile path to verify\n-     * @return a list of verification errors, or an empty list if no errors are\n+     * Verify a {@code class} file.  All verification errors found will be returned.\n+     *\n+     * @param path the {@code class} file path to verify\n+     * @return a list of verification errors, or an empty list if no error is\n@@ -549,1 +775,1 @@\n-     * @throws java.io.IOException if an I\/O error occurs\n+     * @throws IOException if an I\/O error occurs\n@@ -555,1 +781,4 @@\n-    \/** 0xCAFEBABE *\/\n+    \/**\n+     * The magic number identifying the {@code class} file format,  {@value\n+     * \"0x%04x\" #MAGIC_NUMBER}.  It is a big-endian 4-byte value.\n+     *\/\n@@ -558,1 +787,1 @@\n-    \/** The bit mask of PUBLIC access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#PUBLIC} access and property modifier. *\/\n@@ -561,1 +790,1 @@\n-    \/** The bit mask of PROTECTED access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#PROTECTED} access and property modifier. *\/\n@@ -564,1 +793,1 @@\n-    \/** The bit mask of PRIVATE access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#PRIVATE} access and property modifier. *\/\n@@ -567,1 +796,1 @@\n-    \/** The bit mask of INTERFACE access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#INTERFACE} access and property modifier. *\/\n@@ -570,1 +799,1 @@\n-    \/** The bit mask of ENUM access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#ENUM} access and property modifier. *\/\n@@ -573,1 +802,1 @@\n-    \/** The bit mask of ANNOTATION access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#ANNOTATION} access and property modifier. *\/\n@@ -576,1 +805,1 @@\n-    \/** The bit mask of SUPER access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#SUPER} access and property modifier. *\/\n@@ -579,1 +808,1 @@\n-    \/** The bit mask of IDENTITY access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#IDENTITY} access and property modifier. *\/\n@@ -582,1 +811,1 @@\n-    \/** The bit mask of ABSTRACT access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#ABSTRACT} access and property modifier. *\/\n@@ -585,1 +814,1 @@\n-    \/** The bit mask of VOLATILE access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#VOLATILE} access and property modifier. *\/\n@@ -588,1 +817,1 @@\n-    \/** The bit mask of TRANSIENT access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#TRANSIENT} access and property modifier. *\/\n@@ -591,1 +820,1 @@\n-    \/** The bit mask of SYNTHETIC access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#SYNTHETIC} access and property modifier. *\/\n@@ -594,1 +823,1 @@\n-    \/** The bit mask of STATIC access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#STATIC} access and property modifier. *\/\n@@ -597,1 +826,1 @@\n-    \/** The bit mask of FINAL access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#FINAL} access and property modifier. *\/\n@@ -600,1 +829,1 @@\n-    \/** The bit mask of SYNCHRONIZED access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#SYNCHRONIZED} access and property modifier. *\/\n@@ -603,1 +832,1 @@\n-    \/** The bit mask of BRIDGE access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#BRIDGE} access and property modifier. *\/\n@@ -606,1 +835,1 @@\n-    \/** The bit mask of VARARGS access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#VARARGS} access and property modifier. *\/\n@@ -609,1 +838,1 @@\n-    \/** The bit mask of NATIVE access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#NATIVE} access and property modifier. *\/\n@@ -612,1 +841,1 @@\n-    \/** The bit mask of STRICT access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#STRICT} access and property modifier. *\/\n@@ -615,1 +844,1 @@\n-    \/** The bit mask of MODULE access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#MODULE} access and property modifier. *\/\n@@ -618,1 +847,1 @@\n-    \/** The bit mask of OPEN access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#OPEN} access and property modifier. *\/\n@@ -621,1 +850,1 @@\n-    \/** The bit mask of MANDATED access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#MANDATED} access and property modifier. *\/\n@@ -624,1 +853,1 @@\n-    \/** The bit mask of TRANSITIVE access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#TRANSITIVE} access and property modifier. *\/\n@@ -627,1 +856,1 @@\n-    \/** The bit mask of STATIC_PHASE access and property modifier. *\/\n+    \/** The bit mask of {@link AccessFlag#STATIC_PHASE} access and property modifier. *\/\n@@ -630,1 +859,6 @@\n-    \/** The class major version of JAVA_1. *\/\n+    \/**\n+     * The class major version of the initial version of Java, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_0\n+     * @see ClassFileFormatVersion#RELEASE_1\n+     *\/\n@@ -633,1 +867,5 @@\n-    \/** The class major version of JAVA_2. *\/\n+    \/**\n+     * The class major version introduced by Java 2 SE 1.2, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_2\n+     *\/\n@@ -636,1 +874,5 @@\n-    \/** The class major version of JAVA_3. *\/\n+    \/**\n+     * The class major version introduced by Java 2 SE 1.3, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_3\n+     *\/\n@@ -639,1 +881,5 @@\n-    \/** The class major version of JAVA_4. *\/\n+    \/**\n+     * The class major version introduced by Java 2 SE 1.4, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_4\n+     *\/\n@@ -642,1 +888,5 @@\n-    \/** The class major version of JAVA_5. *\/\n+    \/**\n+     * The class major version introduced by Java 2 SE 5.0, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_5\n+     *\/\n@@ -645,1 +895,5 @@\n-    \/** The class major version of JAVA_6. *\/\n+    \/**\n+     * The class major version introduced by Java SE 6, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_6\n+     *\/\n@@ -648,1 +902,5 @@\n-    \/** The class major version of JAVA_7. *\/\n+    \/**\n+     * The class major version introduced by Java SE 7, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_7\n+     *\/\n@@ -651,1 +909,5 @@\n-    \/** The class major version of JAVA_8. *\/\n+    \/**\n+     * The class major version introduced by Java SE 8, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_8\n+     *\/\n@@ -654,1 +916,5 @@\n-    \/** The class major version of JAVA_9. *\/\n+    \/**\n+     * The class major version introduced by Java SE 9, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_9\n+     *\/\n@@ -657,1 +923,5 @@\n-    \/** The class major version of JAVA_10. *\/\n+    \/**\n+     * The class major version introduced by Java SE 10, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_10\n+     *\/\n@@ -660,1 +930,5 @@\n-    \/** The class major version of JAVA_11. *\/\n+    \/**\n+     * The class major version introduced by Java SE 11, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_11\n+     *\/\n@@ -663,1 +937,5 @@\n-    \/** The class major version of JAVA_12. *\/\n+    \/**\n+     * The class major version introduced by Java SE 12, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_12\n+     *\/\n@@ -666,1 +944,5 @@\n-    \/** The class major version of JAVA_13. *\/\n+    \/**\n+     * The class major version introduced by Java SE 13, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_13\n+     *\/\n@@ -669,1 +951,5 @@\n-    \/** The class major version of JAVA_14. *\/\n+    \/**\n+     * The class major version introduced by Java SE 14, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_14\n+     *\/\n@@ -672,1 +958,5 @@\n-    \/** The class major version of JAVA_15. *\/\n+    \/**\n+     * The class major version introduced by Java SE 15, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_15\n+     *\/\n@@ -675,1 +965,5 @@\n-    \/** The class major version of JAVA_16. *\/\n+    \/**\n+     * The class major version introduced by Java SE 16, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_16\n+     *\/\n@@ -678,1 +972,5 @@\n-    \/** The class major version of JAVA_17. *\/\n+    \/**\n+     * The class major version introduced by Java SE 17, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_17\n+     *\/\n@@ -681,1 +979,5 @@\n-    \/** The class major version of JAVA_18. *\/\n+    \/**\n+     * The class major version introduced by Java SE 18, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_18\n+     *\/\n@@ -684,1 +986,5 @@\n-    \/** The class major version of JAVA_19. *\/\n+    \/**\n+     * The class major version introduced by Java SE 19, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_19\n+     *\/\n@@ -687,1 +993,5 @@\n-    \/** The class major version of JAVA_20. *\/\n+    \/**\n+     * The class major version introduced by Java SE 20, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_20\n+     *\/\n@@ -690,1 +1000,5 @@\n-    \/** The class major version of JAVA_21. *\/\n+    \/**\n+     * The class major version introduced by Java SE 21, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_21\n+     *\/\n@@ -693,1 +1007,5 @@\n-    \/** The class major version of JAVA_22. *\/\n+    \/**\n+     * The class major version introduced by Java SE 22, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_22\n+     *\/\n@@ -696,1 +1014,5 @@\n-    \/** The class major version of JAVA_23. *\/\n+    \/**\n+     * The class major version introduced by Java SE 23, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_23\n+     *\/\n@@ -699,1 +1021,5 @@\n-    \/** The class major version of JAVA_24. *\/\n+    \/**\n+     * The class major version introduced by Java SE 24, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_24\n+     *\/\n@@ -703,1 +1029,3 @@\n-     * The class major version of JAVA_25.\n+     * The class major version introduced by Java SE 25, {@value}.\n+     *\n+     * @see ClassFileFormatVersion#RELEASE_25\n@@ -709,2 +1037,2 @@\n-     * A minor version number indicating a class uses preview features\n-     * of a Java SE version since 12, for major versions {@value\n+     * A minor version number {@value} indicating a class uses preview features\n+     * of a Java SE release since 12, for major versions {@value\n@@ -716,1 +1044,1 @@\n-     * {@return the latest major Java version}\n+     * {@return the latest class major version supported by the current runtime}\n@@ -723,1 +1051,7 @@\n-     * {@return the latest minor Java version}\n+     * {@return the latest class minor version supported by the current runtime}\n+     *\n+     * @apiNote\n+     * This does not report the {@link #PREVIEW_MINOR_VERSION} when the current\n+     * runtime has preview feature enabled, as {@code class} files with a major\n+     * version other than {@link #latestMajorVersion()} and the preview minor\n+     * version are not supported.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":511,"deletions":177,"binary":false,"changes":688,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,5 @@\n- * The {@code java.lang.classfile} package contains classes for reading, writing, and\n- * modifying Java class files, as specified in Chapter {@jvms 4} of the\n- * <cite>Java Virtual Machine Specification<\/cite>.\n+ * The {@code java.lang.classfile} package contains API models for reading,\n+ * writing, and modifying Java class files, as specified in Chapter {@jvms 4} of\n+ * the <cite>Java Virtual Machine Specification<\/cite>.  This package, {@link\n+ * java.lang.classfile.attribute}, {@link java.lang.classfile.constantpool},\n+ * and {@link java.lang.classfile.instruction} form the Class-File API.\n@@ -33,3 +35,3 @@\n- * The main class for reading classfiles is {@link java.lang.classfile.ClassModel}; we\n- * convert bytes into a {@link java.lang.classfile.ClassModel} with {@link\n- * java.lang.classfile.ClassFile#parse(byte[])}:\n+ * The main class for reading classfiles is {@link ClassModel}; we\n+ * convert bytes into a {@link ClassModel} with {@link\n+ * ClassFile#parse(byte[])}:\n@@ -44,1 +46,1 @@\n- * A {@link java.lang.classfile.ClassModel} is an immutable description of a class\n+ * A {@link ClassModel} is an immutable description of a class\n@@ -46,5 +48,8 @@\n- * java.lang.classfile.ClassModel#thisClass()}, {@link java.lang.classfile.ClassModel#flags()}),\n- * as well as subordinate classfile entities ({@link java.lang.classfile.ClassModel#fields()},\n- * {@link java.lang.classfile.ClassModel#attributes()}). A {@link\n- * java.lang.classfile.ClassModel} is inflated lazily; most parts of the classfile are\n- * not parsed until they are actually needed.\n+ * ClassModel#thisClass()}, {@link ClassModel#flags()}),\n+ * as well as subordinate classfile entities ({@link ClassModel#fields()},\n+ * {@link ClassModel#attributes()}). A {@link\n+ * ClassModel} is inflated lazily; most parts of the classfile are\n+ * not parsed until they are actually needed.  Due to the laziness, these models\n+ * may not be thread safe.  Additionally, invocations to accessor methods on\n+ * models may lead to {@link IllegalArgumentException} due to malformed {@code\n+ * class} file format, as parsing happens lazily.\n@@ -55,1 +60,1 @@\n- * When we enumerate the methods, we get a {@link java.lang.classfile.MethodModel} for each method; like a\n+ * When we enumerate the methods, we get a {@link MethodModel} for each method; like a\n@@ -62,1 +67,1 @@\n- * Methods like {@link java.lang.classfile.ClassModel#methods} allows us to traverse the class structure\n+ * Methods like {@link ClassModel#methods} allows us to traverse the class structure\n@@ -66,1 +71,1 @@\n- * java.lang.classfile.ClassModel} also provides us with a view of the classfile as a\n+ * ClassModel} also provides us with a view of the classfile as a\n@@ -90,1 +95,1 @@\n- * the {@link java.lang.classfile.ClassModel#methods()} accessor) or as a linear\n+ * the {@link ClassModel#methods()} accessor) or as a linear\n@@ -92,3 +97,3 @@\n- * java.lang.classfile.FieldModel} is also an element of a class.) For each model type\n- * (e.g., {@link java.lang.classfile.MethodModel}), there is a corresponding element\n- * type ({@link java.lang.classfile.MethodElement}).  Models and elements are immutable\n+ * FieldModel} is also an element of a class.) For each model type\n+ * (e.g., {@link MethodModel}), there is a corresponding element\n+ * type ({@link MethodElement}).  Models and elements are immutable\n@@ -100,2 +105,2 @@\n- * pool<\/em>. {@link java.lang.classfile.ClassModel} provides a lazily-inflated,\n- * read-only view of the constant pool via {@link java.lang.classfile.ClassModel#constantPool()}.\n+ * pool<\/em>. {@link ClassModel} provides a lazily-inflated,\n+ * read-only view of the constant pool via {@link ClassModel#constantPool()}.\n@@ -103,2 +108,2 @@\n- * subtypes of {@link java.lang.classfile.constantpool.PoolEntry}, such as {@link\n- * java.lang.classfile.constantpool.ClassEntry} or {@link java.lang.classfile.constantpool.Utf8Entry}.\n+ * subtypes of {@link PoolEntry}, such as {@link\n+ * ClassEntry} or {@link Utf8Entry}.\n@@ -107,1 +112,1 @@\n- * above traversal example, the {@link java.lang.classfile.instruction.InvokeInstruction}\n+ * above traversal example, the {@link InvokeInstruction}\n@@ -115,3 +120,3 @@\n- * java.lang.classfile.attribute.SignatureAttribute} is a {@link\n- * java.lang.classfile.ClassElement}, {@link java.lang.classfile.MethodElement}, and {@link\n- * java.lang.classfile.FieldElement} since it can appear in all of those places, and is\n+ * SignatureAttribute} is a {@link\n+ * ClassElement}, {@link MethodElement}, and {@link\n+ * FieldElement} since it can appear in all of those places, and is\n@@ -128,1 +133,1 @@\n- * java.lang.classfile.CodeModel}.)\n+ * CodeModel}.)\n@@ -131,2 +136,2 @@\n- * java.lang.classfile.MethodElement}, is also a model in its own right ({@link\n- * java.lang.classfile.CodeModel}) due to its complex structure.\n+ * MethodElement}, is also a model in its own right ({@link\n+ * CodeModel}) due to its complex structure.\n@@ -137,4 +142,4 @@\n- * defined by the {@link java.lang.classfile.attribute.SignatureAttribute} class, and\n- * provides accessors for {@link java.lang.classfile.attribute.SignatureAttribute#signature()}\n- * as well as factories taking {@link java.lang.classfile.constantpool.Utf8Entry} or\n- * {@link java.lang.String}.\n+ * defined by the {@link SignatureAttribute} class, and\n+ * provides accessors for {@link SignatureAttribute#signature()}\n+ * as well as factories taking {@link Utf8Entry} or\n+ * {@link String}.\n@@ -144,1 +149,1 @@\n- * object form via an {@link java.lang.classfile.AttributeMapper}.  An {@code\n+ * object form via an {@link AttributeMapper}.  An {@code\n@@ -146,1 +151,1 @@\n- * {@link java.lang.classfile.AttributeMapper#readAttribute(AttributedElement,\n+ * {@link AttributeMapper#readAttribute(AttributedElement,\n@@ -149,2 +154,2 @@\n- * {@link java.lang.classfile.AttributeMapper#writeAttribute(java.lang.classfile.BufWriter,\n- * java.lang.classfile.Attribute)} method for mapping back to the classfile format.  It also\n+ * {@link AttributeMapper#writeAttribute(BufWriter,\n+ * Attribute)} method for mapping back to the classfile format.  It also\n@@ -155,1 +160,1 @@\n- * There are built-in attribute mappers (in {@link java.lang.classfile.Attributes}) for\n+ * There are built-in attribute mappers (in {@link Attributes}) for\n@@ -161,1 +166,1 @@\n- * java.lang.classfile.attribute.UnknownAttribute}, which provide access only to the\n+ * UnknownAttribute}, which provide access only to the\n@@ -166,1 +171,1 @@\n- * java.lang.classfile.ClassFile.AttributeMapperOption#of(java.util.function.Function)}}\n+ * ClassFile.AttributeMapperOption#of(Function)}}\n@@ -168,1 +173,1 @@\n- * java.lang.classfile.CustomAttribute}.\n+ * CustomAttribute}.\n@@ -170,1 +175,1 @@\n- * <h3>Options<\/h3>\n+ * <h3 id=\"options\">Options<\/h3>\n@@ -172,2 +177,2 @@\n- * {@link java.lang.classfile.ClassFile#of(java.lang.classfile.ClassFile.Option[])}\n- * accepts a list of options.  {@link java.lang.classfile.ClassFile.Option} is a base interface\n+ * {@link ClassFile#of(ClassFile.Option[])}\n+ * accepts a list of options.  {@link ClassFile.Option} is a base interface\n@@ -177,1 +182,1 @@\n- *   <li>{@link java.lang.classfile.ClassFile.AttributeMapperOption#of(java.util.function.Function)}\n+ *   <li>{@link ClassFile.AttributeMapperOption#of(Function)}\n@@ -179,1 +184,1 @@\n- *   <li>{@link java.lang.classfile.ClassFile.AttributesProcessingOption}\n+ *   <li>{@link ClassFile.AttributesProcessingOption}\n@@ -181,1 +186,1 @@\n- *   <li>{@link java.lang.classfile.ClassFile.ClassHierarchyResolverOption#of(java.lang.classfile.ClassHierarchyResolver)}\n+ *   <li>{@link ClassFile.ClassHierarchyResolverOption#of(ClassHierarchyResolver)}\n@@ -183,1 +188,1 @@\n- *   <li>{@link java.lang.classfile.ClassFile.ConstantPoolSharingOption}}\n+ *   <li>{@link ClassFile.ConstantPoolSharingOption}}\n@@ -185,1 +190,1 @@\n- *   <li>{@link java.lang.classfile.ClassFile.DeadCodeOption}}\n+ *   <li>{@link ClassFile.DeadCodeOption}}\n@@ -187,1 +192,1 @@\n- *   <li>{@link java.lang.classfile.ClassFile.DeadLabelsOption}}\n+ *   <li>{@link ClassFile.DeadLabelsOption}}\n@@ -189,1 +194,1 @@\n- *   <li>{@link java.lang.classfile.ClassFile.DebugElementsOption}\n+ *   <li>{@link ClassFile.DebugElementsOption}\n@@ -191,1 +196,1 @@\n- *   <li>{@link java.lang.classfile.ClassFile.LineNumbersOption}\n+ *   <li>{@link ClassFile.LineNumbersOption}\n@@ -193,1 +198,1 @@\n- *   <li>{@link java.lang.classfile.ClassFile.ShortJumpsOption}\n+ *   <li>{@link ClassFile.ShortJumpsOption}\n@@ -195,1 +200,1 @@\n- *   <li>{@link java.lang.classfile.ClassFile.StackMapsOption}\n+ *   <li>{@link ClassFile.StackMapsOption}\n@@ -199,0 +204,7 @@\n+ * {@link ClassFile.AttributeMapperOption} and {@link ClassFile.ClassHierarchyResolverOption}\n+ * are critical to the correctness of {@code class} file parsing and generation.\n+ * The attribute mapper is required to parse custom attributes.  A correct\n+ * resolver is required to generate {@code class} files that refer to classes\n+ * not available to the system class loader in its bytecode, or in corner cases,\n+ * when generation wishes to avoid loading system classes, such as in agents.\n+ * <p>\n@@ -210,2 +222,2 @@\n- * classes are built through {@link java.lang.classfile.ClassBuilder}, methods through\n- * {@link java.lang.classfile.MethodBuilder}, etc.\n+ * classes are built through {@link ClassBuilder}, methods through\n+ * {@link MethodBuilder}, etc.\n@@ -229,6 +241,6 @@\n- * java.lang.classfile.CodeBuilder#invokevirtual(java.lang.constant.ClassDesc,\n- * java.lang.String, java.lang.constant.MethodTypeDesc) CodeBuilder.invokevirtual}, {@link\n- * java.lang.classfile.CodeBuilder#invoke(java.lang.classfile.Opcode,\n- * java.lang.constant.ClassDesc, java.lang.String, java.lang.constant.MethodTypeDesc,\n- * boolean) CodeBuilder.invokeInstruction}, or {@link\n- * java.lang.classfile.CodeBuilder#with(java.lang.classfile.ClassFileElement)\n+ * CodeBuilder#invokevirtual(ClassDesc,\n+ * String, MethodTypeDesc) CodeBuilder.invokevirtual}, {@link\n+ * CodeBuilder#invoke(Opcode,\n+ * ClassDesc, String, MethodTypeDesc,\n+ * boolean) CodeBuilder.invoke}, or {@link\n+ * CodeBuilder#with(ClassFileElement)\n@@ -238,1 +250,1 @@\n- * the convenience method {@code CodeBuilder.invokeInstruction}, which in turn behaves\n+ * the convenience method {@code CodeBuilder.invoke}, which in turn behaves\n@@ -244,1 +256,1 @@\n- * java.lang.NullPointerException NullPointerException} to be thrown. Additionally,\n+ * NullPointerException} to be thrown. Additionally,\n@@ -250,2 +262,2 @@\n- * nominal descriptor abstractions from {@code java.lang.constant} such as {@link\n- * java.lang.constant.ClassDesc} and {@link java.lang.constant.MethodTypeDesc},\n+ * nominal descriptor abstractions from {@link java.lang.constant} such as {@link\n+ * ClassDesc} and {@link MethodTypeDesc},\n@@ -256,1 +268,1 @@\n- * method {@link java.lang.classfile.constantpool.ClassEntry#asSymbol} returns\n+ * method {@link ClassEntry#asSymbol} returns\n@@ -269,1 +281,2 @@\n- * the classfile building process.\n+ * the classfile building process.  These fatal exceptions are thrown as\n+ * {@link IllegalArgumentException}.\n@@ -275,1 +288,1 @@\n- * name to the {@link java.lang.constant.ClassDesc#of} method for validation\n+ * name to the {@link ClassDesc#of} method for validation\n@@ -293,1 +306,1 @@\n- * {@link java.lang.classfile.ClassFile#verify}.\n+ * {@link ClassFile#verify}.\n@@ -304,3 +317,3 @@\n- * get an existing {@link java.lang.classfile.ClassModel}, build a new classfile that\n- * provides a {@link java.lang.classfile.ClassBuilder}, iterate the elements of the\n- * original {@link java.lang.classfile.ClassModel}, and pass through all of them to\n+ * get an existing {@link ClassModel}, build a new classfile that\n+ * provides a {@link ClassBuilder}, iterate the elements of the\n+ * original {@link ClassModel}, and pass through all of them to\n@@ -338,1 +351,1 @@\n- * java.lang.classfile.CodeElement}:\n+ * CodeElement}:\n@@ -379,1 +392,1 @@\n- * java.lang.classfile.CodeTransform#andThen(java.lang.classfile.CodeTransform)}:\n+ * CodeTransform#andThen(CodeTransform)}:\n@@ -402,1 +415,1 @@\n- * with the {@link java.lang.classfile.ClassFile.ConstantPoolSharingOption} option.\n+ * with the {@link ClassFile.ConstantPoolSharingOption} option.\n@@ -432,2 +445,2 @@\n- * java.lang.classfile.CodeBuilder#invokevirtual(java.lang.constant.ClassDesc,\n- * java.lang.String, java.lang.constant.MethodTypeDesc)}).\n+ * CodeBuilder#invokevirtual(ClassDesc,\n+ * String, MethodTypeDesc)}).\n@@ -437,3 +450,3 @@\n- * java.lang.classfile.constantpool.ClassEntry}.) Factories and builders also\n- * accept nominal descriptors from {@code java.lang.constant} (e.g., {@link\n- * java.lang.constant.ClassDesc}.)\n+ * ClassEntry}.) Factories and builders also\n+ * accept nominal descriptors from {@link java.lang.constant} (e.g., {@link\n+ * ClassDesc}.)\n@@ -489,1 +502,1 @@\n- * {@link java.lang.classfile.CodeModel} (which models the {@code Code} attribute\n+ * {@link CodeModel} (which models the {@code Code} attribute\n@@ -506,1 +519,1 @@\n- * {@link java.lang.classfile.CodeModel} is unique in that its elements are <em>ordered<\/em>.\n+ * {@link CodeModel} is unique in that its elements are <em>ordered<\/em>.\n@@ -553,0 +566,10 @@\n+\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.lang.classfile.attribute.UnknownAttribute;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.function.Function;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":108,"deletions":85,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-public class MethodHandleProxies {\n+public final class MethodHandleProxies {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-public class MethodHandles {\n+public final class MethodHandles {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-public class Modifier {\n+public final class Modifier {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-public class ObjectMethods {\n+public final class ObjectMethods {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-public class SwitchBootstraps {\n+public final class SwitchBootstraps {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -475,4 +475,0 @@\n-    int getCharsLatin1(long i, int index, byte[] buf);\n-\n-    int getCharsUTF16(long i, int index, byte[] buf);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -418,0 +418,5 @@\n+    \/**\n+     * Flag to indicate type annotations have been queued for field initializers.\n+     *\/\n+    public static final long FIELD_INIT_TYPE_ANNOTATIONS_QUEUED = 1L<<53; \/\/ VarSymbols\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1806,0 +1806,1 @@\n+                                      final Env<AttrContext> enclosingEnv,\n@@ -1809,1 +1810,1 @@\n-            setData((Callable<Object>)() -> attr.attribLazyConstantValue(env, variable, type));\n+            setData((Callable<Object>)() -> attr.attribLazyConstantValue(env, enclosingEnv, variable, type));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -864,0 +864,1 @@\n+                                      Env<AttrContext> enclosingEnv,\n@@ -872,0 +873,1 @@\n+            doQueueScanTreeAndTypeAnnotateForVarInit(variable, enclosingEnv);\n@@ -1299,5 +1301,1 @@\n-            if (tree.init != null) {\n-                \/\/ Field initializer expression need to be entered.\n-                annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());\n-                annotate.flush();\n-            }\n+            doQueueScanTreeAndTypeAnnotateForVarInit(tree, env);\n@@ -1365,0 +1363,11 @@\n+    private void doQueueScanTreeAndTypeAnnotateForVarInit(JCVariableDecl tree, Env<AttrContext> env) {\n+        if (tree.init != null &&\n+            (tree.mods.flags & Flags.FIELD_INIT_TYPE_ANNOTATIONS_QUEUED) == 0 &&\n+            env.info.scope.owner.kind != MTH && env.info.scope.owner.kind != VAR) {\n+            tree.mods.flags |= Flags.FIELD_INIT_TYPE_ANNOTATIONS_QUEUED;\n+            \/\/ Field initializer expression need to be entered.\n+            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());\n+            annotate.flush();\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -306,1 +306,1 @@\n-                v.setLazyConstValue(initEnv, attr, tree);\n+                v.setLazyConstValue(initEnv(tree, initEnv), env, attr, tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,0 +151,1 @@\n+    public static final boolean PRINT_RULE_MATCHING_TIME = Boolean.getBoolean(\"PrintRuleMatchingTime\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+import static compiler.lib.ir_framework.shared.TestFrameworkSocket.PRINT_TIMES_TAG;\n+\n@@ -890,1 +892,1 @@\n-            System.out.println(System.lineSeparator() + System.lineSeparator() + \"Test execution times:\");\n+            TestFrameworkSocket.write(\"Test execution times:\", PRINT_TIMES_TAG, true);\n@@ -892,1 +894,2 @@\n-                System.out.format(\"%-10s%15d ns%n\", entry.getValue() + \":\", entry.getKey());\n+                TestFrameworkSocket.write(String.format(\"%-25s%15d ns%n\", entry.getValue() + \":\", entry.getKey()),\n+                        PRINT_TIMES_TAG, true);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        dumpShouldFail(\n+        dumpShouldPass(\n@@ -59,1 +59,2 @@\n-            \"Class CustomLoadee2 implements the interface CustomInterface2_ia, but no interface has been specified in the input line\");\n+            \"java.lang.NoClassDefFoundError: CustomInterface2_ia\",\n+            \"Cannot find CustomLoadee2\");\n@@ -70,1 +71,1 @@\n-            \"The interface CustomInterface2_ib implemented by class CustomLoadee2 does not match any of the specified interface IDs\");\n+            \"The number of interfaces (1) specified in class list does not match the class file (2)\");\n@@ -104,0 +105,10 @@\n+\n+        dumpShouldPass(\n+            \"TESTCASE E6: JAR file doesn't exist\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"java\/lang\/Object id: 1\",\n+                \"NoSuchClass id: 2 super: 1 source: no_such_file.jar\"\n+            ),\n+            \"Cannot find NoSuchClass\",\n+            \"java.io.IOException: No such file: no_such_file.jar\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatE.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -642,2 +642,0 @@\n-sun\/security\/provider\/PolicyFile\/GrantAllPermToExtWhenNoPolicy.java 8039280 generic-all\n-sun\/security\/provider\/PolicyParser\/PrincipalExpansionError.java 8039280 generic-all\n@@ -815,1 +813,1 @@\n-java\/awt\/print\/PrinterJob\/PrintTextTest.java 8148334 generic-all\n+java\/awt\/print\/PrinterJob\/PrintTextTest.java 8148334 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8142968 8299504\n@@ -30,1 +31,1 @@\n- * @run testng ConfigurationTest\n+ * @run junit ConfigurationTest\n@@ -49,0 +50,3 @@\n+import java.util.stream.Stream;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.module.ModuleTarget;\n@@ -53,5 +57,5 @@\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.module.ModuleTarget;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -59,2 +63,1 @@\n-@Test\n-public class ConfigurationTest {\n+class ConfigurationTest {\n@@ -75,1 +78,2 @@\n-    public void testBasic() {\n+    @Test\n+    void testBasic() {\n@@ -127,1 +131,2 @@\n-    public void testRequiresTransitive1() {\n+    @Test\n+    void testRequiresTransitive1() {\n@@ -179,1 +184,2 @@\n-    public void testRequiresTransitive2() {\n+    @Test\n+    void testRequiresTransitive2() {\n@@ -240,1 +246,2 @@\n-    public void testRequiresTransitive3() {\n+    @Test\n+    void testRequiresTransitive3() {\n@@ -302,1 +309,2 @@\n-    public void testRequiresTransitive4() {\n+    @Test\n+    void testRequiresTransitive4() {\n@@ -377,1 +385,2 @@\n-    public void testRequiresTransitive5() {\n+    @Test\n+    void testRequiresTransitive5() {\n@@ -454,1 +463,2 @@\n-    public void testRequiresStatic1() {\n+    @Test\n+    void testRequiresStatic1() {\n@@ -476,1 +486,2 @@\n-    public void testRequiresStatic2() {\n+    @Test\n+    void testRequiresStatic2() {\n@@ -501,1 +512,2 @@\n-    public void testRequiresStatic3() {\n+    @Test\n+    void testRequiresStatic3() {\n@@ -531,1 +543,2 @@\n-    public void testRequiresStatic4() {\n+    @Test\n+    void testRequiresStatic4() {\n@@ -572,1 +585,2 @@\n-    public void testRequiresStatic5() {\n+    @Test\n+    void testRequiresStatic5() {\n@@ -615,1 +629,2 @@\n-    public void testRequiresStatic6() {\n+    @Test\n+    void testRequiresStatic6() {\n@@ -652,1 +667,2 @@\n-    public void testRequiresStatic7() {\n+    @Test\n+    void testRequiresStatic7() {\n@@ -685,1 +701,2 @@\n-    public void testRequiresStatic8() {\n+    @Test\n+    void testRequiresStatic8() {\n@@ -724,2 +741,2 @@\n-    public void testServiceBinding1() {\n-\n+    @Test\n+    void testServiceBinding1() {\n@@ -764,2 +781,2 @@\n-    public void testServiceBinding2() {\n-\n+    @Test\n+    void testServiceBinding2() {\n@@ -818,2 +835,2 @@\n-    public void testServiceBindingWithConfigurations1() {\n-\n+    @Test\n+    void testServiceBindingWithConfigurations1() {\n@@ -864,2 +881,2 @@\n-    public void testServiceBindingWithConfigurations2() {\n-\n+    @Test\n+    void testServiceBindingWithConfigurations2() {\n@@ -932,2 +949,2 @@\n-    public void testServiceBindingWithConfigurations3() {\n-\n+    @Test\n+    void testServiceBindingWithConfigurations3() {\n@@ -954,1 +971,1 @@\n-        assertEquals(p.reference().descriptor(), provider_v1);\n+        assertEquals(provider_v1, p.reference().descriptor());\n@@ -982,1 +999,1 @@\n-        assertEquals(p.reference().descriptor(), provider_v2);\n+        assertEquals(provider_v2, p.reference().descriptor());\n@@ -997,1 +1014,1 @@\n-        assertEquals(p.reference().descriptor(), provider_v1);\n+        assertEquals(provider_v1, p.reference().descriptor());\n@@ -1006,2 +1023,2 @@\n-    public void testWithTwoFinders1() {\n-\n+    @Test\n+    void testWithTwoFinders1() {\n@@ -1032,2 +1049,2 @@\n-        assertEquals(m1.reference().descriptor(), descriptor1);\n-        assertEquals(m2.reference().descriptor(), descriptor2_v1);\n+        assertEquals(descriptor1, m1.reference().descriptor());\n+        assertEquals(descriptor2_v1, m2.reference().descriptor());\n@@ -1043,2 +1060,2 @@\n-    public void testWithTwoFinders2() {\n-\n+    @Test\n+    void testWithTwoFinders2() {\n@@ -1072,2 +1089,2 @@\n-        assertEquals(m1.reference().descriptor(), descriptor1);\n-        assertEquals(m2.reference().descriptor(), descriptor2_v1);\n+        assertEquals(descriptor1, m1.reference().descriptor());\n+        assertEquals(descriptor2_v1, m2.reference().descriptor());\n@@ -1081,2 +1098,2 @@\n-    public void testResolvedInParent1() {\n-\n+    @Test\n+    void testResolvedInParent1() {\n@@ -1103,2 +1120,2 @@\n-    public void testResolvedInParent2() {\n-\n+    @Test\n+    void testResolvedInParent2() {\n@@ -1144,2 +1161,2 @@\n-    public void testResolvedInMultipleParents1() {\n-\n+    @Test\n+    void testResolvedInMultipleParents1() {\n@@ -1149,1 +1166,1 @@\n-        assertEquals(cf1.parents(), List.of(Configuration.empty()));\n+        assertEquals(List.of(Configuration.empty()), cf1.parents());\n@@ -1157,1 +1174,1 @@\n-        assertEquals(cf2.parents(), List.of(Configuration.empty()));\n+        assertEquals(List.of(Configuration.empty()), cf2.parents());\n@@ -1173,1 +1190,1 @@\n-        assertEquals(cf3.parents(), List.of(cf1, cf2));\n+        assertEquals(List.of(cf1, cf2), cf3.parents());\n@@ -1181,1 +1198,1 @@\n-        assertEquals(m3.reads(), Set.of(m1, m2));\n+        assertEquals(Set.of(m1, m2), m3.reads());\n@@ -1195,1 +1212,2 @@\n-    public void testResolvedInMultipleParents2() {\n+    @Test\n+    void testResolvedInMultipleParents2() {\n@@ -1199,1 +1217,1 @@\n-        assertEquals(cf1.parents(), List.of(Configuration.empty()));\n+        assertEquals( List.of(Configuration.empty()), cf1.parents());\n@@ -1213,1 +1231,1 @@\n-        assertEquals(cf2.parents(), List.of(cf1));\n+        assertEquals(List.of(cf1), cf2.parents());\n@@ -1227,1 +1245,1 @@\n-        assertEquals(cf3.parents(), List.of(cf1));\n+        assertEquals(List.of(cf1), cf3.parents());\n@@ -1243,1 +1261,1 @@\n-        assertEquals(cf4.parents(), List.of(cf2, cf3));\n+        assertEquals(List.of(cf2, cf3), cf4.parents());\n@@ -1250,3 +1268,3 @@\n-        assertEquals(m2.reads(), Set.of(m1));\n-        assertEquals(m3.reads(), Set.of(m1));\n-        assertEquals(m4.reads(), Set.of(m1, m2, m3));\n+        assertEquals(Set.of(m1), m2.reads());\n+        assertEquals(Set.of(m1), m3.reads());\n+        assertEquals(Set.of(m1, m2, m3), m4.reads());\n@@ -1266,1 +1284,2 @@\n-    public void testResolvedInMultipleParents3() {\n+    @Test\n+    void testResolvedInMultipleParents3() {\n@@ -1272,1 +1291,1 @@\n-        assertEquals(cf1.parents(), List.of(Configuration.empty()));\n+        assertEquals(List.of(Configuration.empty()), cf1.parents());\n@@ -1280,1 +1299,1 @@\n-        assertEquals(cf2.parents(), List.of(Configuration.empty()));\n+        assertEquals(List.of(Configuration.empty()), cf2.parents());\n@@ -1289,1 +1308,1 @@\n-        assertEquals(cf3.parents(), List.of(Configuration.empty()));\n+        assertEquals(List.of(Configuration.empty()), cf3.parents());\n@@ -1302,1 +1321,1 @@\n-        assertEquals(cf4.parents(), List.of(cf1, cf2, cf3));\n+        assertEquals(List.of(cf1, cf2, cf3), cf4.parents());\n@@ -1335,1 +1354,1 @@\n-        assertEquals(m4.reads(), Set.of(m1_1, m2_2, m3_3));\n+        assertEquals(Set.of(m1_1, m2_2, m3_3), m4.reads());\n@@ -1343,1 +1362,2 @@\n-    public void testOverriding1() {\n+    @Test\n+    void testOverriding1() {\n@@ -1361,1 +1381,2 @@\n-    public void testOverriding2() {\n+    @Test\n+    void testOverriding2() {\n@@ -1400,2 +1421,2 @@\n-    public void testOverriding3() {\n-\n+    @Test\n+    void testOverriding3() {\n@@ -1454,3 +1475,3 @@\n-    @Test(expectedExceptions = { FindException.class })\n-    public void testRootNotFound() {\n-        resolve(ModuleFinder.of(), \"m1\");\n+    @Test\n+    void testRootNotFound() {\n+        assertThrows(FindException.class, () -> resolve(ModuleFinder.of(), \"m1\"));\n@@ -1463,2 +1484,2 @@\n-    @Test(expectedExceptions = { FindException.class })\n-    public void testDirectDependencyNotFound() {\n+    @Test\n+    void testDirectDependencyNotFound() {\n@@ -1467,1 +1488,1 @@\n-        resolve(finder, \"m1\");\n+        assertThrows(FindException.class, () -> resolve(finder, \"m1\"));\n@@ -1474,2 +1495,2 @@\n-    @Test(expectedExceptions = { FindException.class })\n-    public void testTransitiveDependencyNotFound() {\n+    @Test\n+    void testTransitiveDependencyNotFound() {\n@@ -1479,1 +1500,1 @@\n-        resolve(finder, \"m1\");\n+        assertThrows(FindException.class, () -> resolve(finder, \"m1\"));\n@@ -1486,2 +1507,2 @@\n-    @Test(expectedExceptions = { FindException.class })\n-    public void testServiceProviderDependencyNotFound() {\n+    @Test\n+    void testServiceProviderDependencyNotFound() {\n@@ -1505,1 +1526,1 @@\n-        Configuration cf = resolveAndBind(finder, \"m1\");\n+        assertThrows(FindException.class, () -> resolveAndBind(finder, \"m1\"));\n@@ -1512,2 +1533,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testSimpleCycle() {\n+    @Test\n+    void testSimpleCycle() {\n@@ -1517,3 +1538,2 @@\n-        ModuleFinder finder\n-            = ModuleUtils.finderOf(descriptor1, descriptor2, descriptor3);\n-        resolve(finder, \"m1\");\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2, descriptor3);\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m1\"));\n@@ -1525,3 +1545,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testCycleInProvider() {\n-\n+    @Test\n+    void testCycleInProvider() {\n@@ -1545,1 +1564,1 @@\n-        resolveAndBind(finder, \"m1\");\n+        assertThrows(ResolutionException.class, () -> resolveAndBind(finder, \"m1\"));\n@@ -1556,2 +1575,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testReadModuleWithSameNameAsSelf() {\n+    @Test\n+    void testReadModuleWithSameNameAsSelf() {\n@@ -1575,1 +1594,1 @@\n-        resolve(cf1, finder2, \"m1\");\n+        assertThrows(ResolutionException.class, () -> resolve(cf1, finder2, \"m1\"));\n@@ -1587,2 +1606,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testReadTwoModuleWithSameName() {\n+    @Test\n+    void testReadTwoModuleWithSameName() {\n@@ -1615,1 +1634,5 @@\n-        Configuration.resolve(finder3, List.of(cf1, cf2), ModuleFinder.of(), Set.of(\"m4\"));\n+        assertThrows(ResolutionException.class,\n+                     () -> Configuration.resolve(finder3,\n+                                                 List.of(cf1, cf2),\n+                                                 ModuleFinder.of(),\n+                                                 Set.of(\"m4\")));\n@@ -1622,3 +1645,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testPackageSuppliedByTwoOthers() {\n-\n+    @Test\n+    void testPackageSuppliedByTwoOthers() {\n@@ -1642,1 +1664,1 @@\n-        resolve(finder, \"m1\");\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m1\"));\n@@ -1650,3 +1672,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testPackageSuppliedBySelfAndOther() {\n-\n+    @Test\n+    void testPackageSuppliedBySelfAndOther() {\n@@ -1665,1 +1686,1 @@\n-        resolve(finder, \"m1\");\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m1\"));\n@@ -1673,1 +1694,2 @@\n-    public void testContainsPackageInSelfAndOther() {\n+    @Test\n+    void testContainsPackageInSelfAndOther() {\n@@ -1704,2 +1726,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testExportSamePackageAsBootLayer() {\n+    @Test\n+    void testExportSamePackageAsBootLayer() {\n@@ -1716,1 +1738,1 @@\n-        resolve(bootConfiguration, finder, \"m1\");\n+        assertThrows(ResolutionException.class, () -> resolve(bootConfiguration, finder, \"m1\"));\n@@ -1723,1 +1745,2 @@\n-    public void testContainsService1() {\n+    @Test\n+    void testContainsService1() {\n@@ -1741,2 +1764,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testContainsService2() {\n+    @Test\n+    void testContainsService2() {\n@@ -1755,1 +1778,1 @@\n-        resolve(finder, \"m2\");\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m2\"));\n@@ -1762,1 +1785,2 @@\n-    public void testContainsService3() {\n+    @Test\n+    void testContainsService3() {\n@@ -1780,2 +1804,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testContainsService4() {\n+    @Test\n+    void testContainsService4() {\n@@ -1794,1 +1818,1 @@\n-        resolve(finder, \"m2\");\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m2\"));\n@@ -1797,0 +1821,16 @@\n+    \/**\n+     * Test uses optional service.\n+     *\n+     *     module m1 { requires static m2; uses p.S; }\n+     *\/\n+    @Test\n+    void testUsesOptionalService1() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .requires(Set.of(Requires.Modifier.STATIC), \"m2\")\n+                .uses(\"p.S\")\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1);\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 1);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n+    }\n@@ -1799,1 +1839,27 @@\n-     * Test \"uses p.S\" where p is not exported to the module.\n+     * Test uses optional service.\n+     *\n+     *     module m1 { requires m2; uses p.S; }\n+     *     module m2 { requires static transitive m3; }\n+     *\/\n+    @Test\n+    void testUsesOptionalService2() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .requires(\"m2\")\n+                .uses(\"p.S\")\n+                .build();\n+        ModuleDescriptor descriptor2 = newBuilder(\"m2\")\n+                .requires(Set.of(Requires.Modifier.STATIC, Requires.Modifier.TRANSITIVE), \"m3\")\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2);\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 2);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n+        assertTrue(cf.findModule(\"m2\").isPresent());\n+    }\n+\n+    \/**\n+     * Test uses optional service.\n+     *\n+     *     module m1 { requires m2; uses p.S; }\n+     *     module m2 { requires transitive m3; }\n+     *     module m3 { requires static transitive m4; }\n@@ -1801,2 +1867,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testServiceTypePackageNotExported1() {\n+    @Test\n+    void testUsesOptionalService3() {\n@@ -1804,0 +1870,1 @@\n+                .requires(\"m2\")\n@@ -1806,0 +1873,13 @@\n+        ModuleDescriptor descriptor2 = newBuilder(\"m2\")\n+                .requires(Set.of(Requires.Modifier.TRANSITIVE), \"m3\")\n+                .build();\n+        ModuleDescriptor descriptor3 = newBuilder(\"m3\")\n+                .requires(Set.of(Requires.Modifier.STATIC, Requires.Modifier.TRANSITIVE), \"m4\")\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2, descriptor3);\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 3);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n+        assertTrue(cf.findModule(\"m2\").isPresent());\n+        assertTrue(cf.findModule(\"m3\").isPresent());\n+    }\n@@ -1807,0 +1887,11 @@\n+    \/**\n+     * Test provides optional service.\n+     *\n+     *     module m1 { requires static m2; provides p.S with q.P; }\n+     *\/\n+    @Test\n+    void testProvidesOptionalService1() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .requires(Set.of(Requires.Modifier.STATIC), \"m2\")\n+                .provides(\"p.S\", List.of(\"q.P\"))\n+                .build();\n@@ -1808,3 +1899,3 @@\n-\n-        \/\/ m1 does not read a module that exports p\n-        resolve(finder, \"m1\");\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 1);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n@@ -1813,0 +1904,21 @@\n+    \/**\n+     * Test provides optional service.\n+     *\n+     *     module m1 { requires m2; provides p.S with q.P; }\n+     *     module m2 { requires static transitive m3; }\n+     *\/\n+    @Test\n+    void testProvidesOptionalService2() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .requires(\"m2\")\n+                .provides(\"p.S\", List.of(\"q.P\"))\n+                .build();\n+        ModuleDescriptor descriptor2 = newBuilder(\"m2\")\n+                .requires(Set.of(Requires.Modifier.STATIC, Requires.Modifier.TRANSITIVE), \"m3\")\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2);\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 2);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n+        assertTrue(cf.findModule(\"m2\").isPresent());\n+    }\n@@ -1815,1 +1927,5 @@\n-     * Test \"provides p.S\" where p is not exported to the module.\n+     * Test provides optional service.\n+     *\n+     *     module m1 { requires m2; provides p.S with q.P; }\n+     *     module m2 { requires transitive m3; }\n+     *     module m3 { requires static transitive m4; }\n@@ -1817,2 +1933,2 @@\n-    @Test(expectedExceptions = { ResolutionException.class })\n-    public void testServiceTypePackageNotExported2() {\n+    @Test\n+    void testProvidesOptionalService3() {\n@@ -1820,1 +1936,5 @@\n-                .provides(\"p.S\", List.of(\"q.T\"))\n+                .requires(\"m2\")\n+                .provides(\"p.S\", List.of(\"q.P\"))\n+                .build();\n+        ModuleDescriptor descriptor2 = newBuilder(\"m2\")\n+                .requires(Set.of(Requires.Modifier.TRANSITIVE), \"m3\")\n@@ -1822,0 +1942,10 @@\n+        ModuleDescriptor descriptor3 = newBuilder(\"m3\")\n+                .requires(Set.of(Requires.Modifier.STATIC, Requires.Modifier.TRANSITIVE), \"m4\")\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2, descriptor3);\n+        Configuration cf = resolve(finder, \"m1\");\n+        assertTrue(cf.modules().size() == 3);\n+        assertTrue(cf.findModule(\"m1\").isPresent());\n+        assertTrue(cf.findModule(\"m2\").isPresent());\n+        assertTrue(cf.findModule(\"m3\").isPresent());\n+    }\n@@ -1823,0 +1953,8 @@\n+    \/**\n+     * Test \"uses p.S\" where p is not exported to the module.\n+     *\/\n+    @Test\n+    void testServiceTypePackageNotExported1() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .uses(\"p.S\")\n+                .build();\n@@ -1825,2 +1963,23 @@\n-        \/\/ m1 does not read a module that exports p\n-        resolve(finder, \"m1\");\n+        \/\/ m1 does not read a module that exports p to m1\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m1\"));\n+    }\n+\n+    \/**\n+     * Test \"uses p.S\" where p is not exported to the module.\n+     *\n+     *     module m1 { requires m2; uses p.S; }\n+     *     module m2 { contains p; }\n+     *\/\n+    @Test\n+    void testServiceTypePackageNotExported2() {\n+        ModuleDescriptor descriptor1 = newBuilder(\"m1\")\n+                .requires(\"m2\")\n+                .uses(\"p.S\")\n+                .build();\n+        ModuleDescriptor descriptor2 = newBuilder(\"m2\")\n+                .packages(Set.of(\"p\"))\n+                .build();\n+        ModuleFinder finder = ModuleUtils.finderOf(descriptor1, descriptor2);\n+\n+        \/\/ m1 does not read a module that exports p to m1\n+        assertThrows(ResolutionException.class, () -> resolve(finder, \"m1\"));\n@@ -1833,1 +1992,2 @@\n-    public void testEmptyConfiguration() {\n+    @Test\n+    void testEmptyConfiguration() {\n@@ -1842,25 +2002,0 @@\n-\n-    \/\/ platform specific modules\n-\n-    @DataProvider(name = \"platformmatch\")\n-    public Object[][] createPlatformMatches() {\n-        return new Object[][]{\n-\n-            { \"\",              \"\" },\n-            { \"linux-arm\",     \"\" },\n-            { \"linux-arm\",     \"linux-arm\" },\n-\n-        };\n-\n-    };\n-\n-    @DataProvider(name = \"platformmismatch\")\n-    public Object[][] createBad() {\n-        return new Object[][] {\n-\n-            { \"linux-x64\",        \"linux-arm\" },\n-            { \"linux-x64\",        \"windows-x64\" },\n-\n-        };\n-    }\n-\n@@ -1870,3 +2005,3 @@\n-    @Test(dataProvider = \"platformmatch\")\n-    public void testPlatformMatch(String s1, String s2) throws IOException {\n-\n+    @ParameterizedTest\n+    @CsvSource({\",\", \"linux-aarch64,\", \"linux-aarch64,linux-aarch64\"})\n+    void testPlatformMatch(String targetPlatform1, String targetPlatform2) throws IOException {\n@@ -1879,1 +2014,1 @@\n-        Path dir1 = writeModule(descriptor1, s1);\n+        Path dir1 = writeModule(descriptor1, targetPlatform1);\n@@ -1882,1 +2017,1 @@\n-        Path dir2 = writeModule(descriptor2, s2);\n+        Path dir2 = writeModule(descriptor2, targetPlatform2);\n@@ -1895,2 +2030,1 @@\n-     * Test attempting to create a configuration with modules for different\n-     * platforms.\n+     * Test attempting to create a configuration with modules for different platforms.\n@@ -1898,4 +2032,5 @@\n-    @Test(dataProvider = \"platformmismatch\",\n-          expectedExceptions = FindException.class )\n-    public void testPlatformMisMatch(String s1, String s2) throws IOException {\n-        testPlatformMatch(s1, s2);\n+    @ParameterizedTest\n+    @CsvSource({\"linux-x64,linux-aarch64\", \"linux-x64,windows-x64\"})\n+    void testPlatformMisMatch(String targetPlatform1, String targetPlatform2) throws IOException {\n+        assertThrows(FindException.class,\n+                () -> testPlatformMatch(targetPlatform1, targetPlatform2));\n@@ -1906,2 +2041,2 @@\n-    @Test(expectedExceptions = { IllegalArgumentException.class })\n-    public void testResolveRequiresWithNoParents() {\n+    @Test\n+    void testResolveRequiresWithNoParents() {\n@@ -1909,1 +2044,2 @@\n-        Configuration.resolve(empty, List.of(), empty, Set.of());\n+        assertThrows(IllegalArgumentException.class,\n+                () -> Configuration.resolve(empty, List.of(), empty, Set.of()));\n@@ -1912,2 +2048,2 @@\n-    @Test(expectedExceptions = { IllegalArgumentException.class })\n-    public void testResolveRequiresAndUsesWithNoParents() {\n+    @Test\n+    void testResolveRequiresAndUsesWithNoParents() {\n@@ -1915,1 +2051,2 @@\n-        Configuration.resolveAndBind(empty, List.of(), empty, Set.of());\n+        assertThrows(IllegalArgumentException.class,\n+                () -> Configuration.resolveAndBind(empty, List.of(), empty, Set.of()));\n@@ -1920,5 +2057,5 @@\n-    @Test(dataProvider = \"platformmatch\")\n-    public void testResolveRequiresWithCompatibleParents(String s1, String s2)\n-        throws IOException\n-    {\n-        ModuleDescriptor base =  ModuleDescriptor.newModule(\"java.base\").build();\n+    @ParameterizedTest\n+    @CsvSource({\",\", \"linux-aarch64,\", \"linux-aarch64,linux-aarch64\"})\n+    void testResolveRequiresWithCompatibleParents(String targetPlatform1,\n+                                                  String targetPlatform2) throws IOException {\n+        ModuleDescriptor base = ModuleDescriptor.newModule(\"java.base\").build();\n@@ -1928,1 +2065,1 @@\n-        Path dir1 = writeModule(descriptor1, s1);\n+        Path dir1 = writeModule(descriptor1, targetPlatform1);\n@@ -1931,1 +2068,1 @@\n-        Path dir2 = writeModule(descriptor2, s2);\n+        Path dir2 = writeModule(descriptor2, targetPlatform2);\n@@ -1947,6 +2084,6 @@\n-    @Test(dataProvider = \"platformmismatch\",\n-          expectedExceptions = IllegalArgumentException.class )\n-    public void testResolveRequiresWithConflictingParents(String s1, String s2)\n-        throws IOException\n-    {\n-        testResolveRequiresWithCompatibleParents(s1, s2);\n+    @ParameterizedTest\n+    @CsvSource({\"linux-x64,linux-aarch64\", \"linux-x64,windows-x64\"})\n+    void testResolveRequiresWithConflictingParents(String targetPlatform1,\n+                                                   String targetPlatform2) throws IOException {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> testResolveRequiresWithCompatibleParents(targetPlatform1, targetPlatform2));\n@@ -1958,6 +2095,4 @@\n-    \/\/ finder1, finder2, roots\n-\n-\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull1() {\n-        resolve((ModuleFinder)null, ModuleFinder.of());\n+    @Test\n+    void testResolveRequiresWithNull1() {\n+        assertThrows(NullPointerException.class,\n+                () -> resolve((ModuleFinder) null, ModuleFinder.of()));\n@@ -1966,3 +2101,4 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull2() {\n-        resolve(ModuleFinder.of(), (ModuleFinder)null);\n+    @Test\n+    void testResolveRequiresWithNull2() {\n+        assertThrows(NullPointerException.class,\n+                () -> resolve(ModuleFinder.of(), (ModuleFinder) null));\n@@ -1971,2 +2107,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull3() {\n+    @Test\n+    void testResolveRequiresWithNull3() {\n@@ -1974,1 +2110,2 @@\n-        Configuration.resolve(null, List.of(empty),  ModuleFinder.of(), Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolve(null, List.of(empty),  ModuleFinder.of(), Set.of()));\n@@ -1977,2 +2114,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull4() {\n+    @Test\n+    void testResolveRequiresWithNull4() {\n@@ -1980,1 +2117,2 @@\n-        Configuration.resolve(empty, null, empty, Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolve(empty, null, empty, Set.of()));\n@@ -1983,2 +2121,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull5() {\n+    @Test\n+    void testResolveRequiresWithNull5() {\n@@ -1986,1 +2124,2 @@\n-        Configuration.resolve(ModuleFinder.of(), List.of(cf), null, Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolve(ModuleFinder.of(), List.of(cf), null, Set.of()));\n@@ -1989,2 +2128,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresWithNull6() {\n+    @Test\n+    void testResolveRequiresWithNull6() {\n@@ -1993,1 +2132,2 @@\n-        Configuration.resolve(empty, List.of(cf), empty, null);\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolve(empty, List.of(cf), empty, null));\n@@ -1996,3 +2136,4 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull1() {\n-        resolveAndBind((ModuleFinder) null, ModuleFinder.of());\n+    @Test\n+    void testResolveRequiresAndUsesWithNull1() {\n+        assertThrows(NullPointerException.class,\n+                () -> resolveAndBind((ModuleFinder) null, ModuleFinder.of()));\n@@ -2001,3 +2142,4 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull2() {\n-        resolveAndBind(ModuleFinder.of(), (ModuleFinder) null);\n+    @Test\n+    void testResolveRequiresAndUsesWithNull2() {\n+        assertThrows(NullPointerException.class,\n+                () -> resolveAndBind(ModuleFinder.of(), (ModuleFinder) null));\n@@ -2006,2 +2148,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull3() {\n+    @Test\n+    void testResolveRequiresAndUsesWithNull3() {\n@@ -2009,1 +2151,2 @@\n-        Configuration.resolveAndBind(null, List.of(empty), ModuleFinder.of(), Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolveAndBind(null, List.of(empty), ModuleFinder.of(), Set.of()));\n@@ -2012,2 +2155,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull4() {\n+    @Test\n+    void testResolveRequiresAndUsesWithNull4() {\n@@ -2015,1 +2158,2 @@\n-        Configuration.resolveAndBind(empty, null, empty, Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolveAndBind(empty, null, empty, Set.of()));\n@@ -2018,2 +2162,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull5() {\n+    @Test\n+    void testResolveRequiresAndUsesWithNull5() {\n@@ -2021,1 +2165,2 @@\n-        Configuration.resolveAndBind(ModuleFinder.of(), List.of(cf), null, Set.of());\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolveAndBind(ModuleFinder.of(), List.of(cf), null, Set.of()));\n@@ -2024,2 +2169,2 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testResolveRequiresAndUsesWithNull6() {\n+    @Test\n+    void testResolveRequiresAndUsesWithNull6() {\n@@ -2028,1 +2173,2 @@\n-        Configuration.resolveAndBind(empty, List.of(cf), empty, null);\n+        assertThrows(NullPointerException.class,\n+                () -> Configuration.resolveAndBind(empty, List.of(cf), empty, null));\n@@ -2031,3 +2177,3 @@\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testFindModuleWithNull() {\n-        Configuration.empty().findModule(null);\n+    @Test\n+    void testFindModuleWithNull() {\n+        assertThrows(NullPointerException.class, () -> Configuration.empty().findModule(null));\n@@ -2038,20 +2184,6 @@\n-    @DataProvider(name = \"configurations\")\n-    public Object[][] configurations() {\n-        \/\/ empty, boot, and custom configurations\n-        return new Object[][] {\n-            { Configuration.empty(),              null },\n-            { ModuleLayer.boot().configuration(), null },\n-            { resolve(ModuleFinder.of()),         null },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"configurations\",\n-            expectedExceptions = { UnsupportedOperationException.class })\n-    public void testUnmodifiableParents1(Configuration cf, Object ignore) {\n-        cf.parents().add(Configuration.empty());\n-    }\n-\n-    @Test(dataProvider = \"configurations\",\n-            expectedExceptions = { UnsupportedOperationException.class })\n-    public void testUnmodifiableParents2(Configuration cf, Object ignore) {\n-        cf.parents().remove(Configuration.empty());\n+    static Stream<Configuration> configurations() {\n+        return Stream.of(\n+                Configuration.empty(),\n+                ModuleLayer.boot().configuration(),\n+                resolve(ModuleFinder.of())\n+        );\n@@ -2060,8 +2192,7 @@\n-    @Test(dataProvider = \"configurations\",\n-            expectedExceptions = { UnsupportedOperationException.class })\n-    public void testUnmodifiableModules1(Configuration cf, Object ignore) {\n-        ResolvedModule module = ModuleLayer.boot()\n-                .configuration()\n-                .findModule(\"java.base\")\n-                .orElseThrow();\n-        cf.modules().add(module);\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    void testUnmodifiableParents(Configuration cf) {\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> cf.parents().add(Configuration.empty()));\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> cf.parents().remove(Configuration.empty()));\n@@ -2070,3 +2201,3 @@\n-    @Test(dataProvider = \"configurations\",\n-            expectedExceptions = { UnsupportedOperationException.class })\n-    public void testUnmodifiableModules2(Configuration cf, Object ignore) {\n+    @ParameterizedTest\n+    @MethodSource(\"configurations\")\n+    void testUnmodifiableModules(Configuration cf) {\n@@ -2077,1 +2208,4 @@\n-        cf.modules().remove(module);\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> cf.modules().add(module));\n+        assertThrows(UnsupportedOperationException.class,\n+                () -> cf.modules().remove(module));\n@@ -2083,4 +2217,4 @@\n-    private Configuration resolve(Configuration parent,\n-                                  ModuleFinder before,\n-                                  ModuleFinder after,\n-                                  String... roots) {\n+    private static Configuration resolve(Configuration parent,\n+                                         ModuleFinder before,\n+                                         ModuleFinder after,\n+                                         String... roots) {\n@@ -2090,3 +2224,3 @@\n-    private Configuration resolve(Configuration parent,\n-                                  ModuleFinder before,\n-                                  String... roots) {\n+    private static Configuration resolve(Configuration parent,\n+                                         ModuleFinder before,\n+                                          String... roots) {\n@@ -2096,3 +2230,3 @@\n-    private Configuration resolve(ModuleFinder before,\n-                                  ModuleFinder after,\n-                                  String... roots) {\n+    private static Configuration resolve(ModuleFinder before,\n+                                         ModuleFinder after,\n+                                         String... roots) {\n@@ -2102,2 +2236,2 @@\n-    private Configuration resolve(ModuleFinder before,\n-                                  String... roots) {\n+    private static Configuration resolve(ModuleFinder before,\n+                                         String... roots) {\n@@ -2111,4 +2245,4 @@\n-    private Configuration resolveAndBind(Configuration parent,\n-                                         ModuleFinder before,\n-                                         ModuleFinder after,\n-                                         String... roots) {\n+    private static Configuration resolveAndBind(Configuration parent,\n+                                                ModuleFinder before,\n+                                                ModuleFinder after,\n+                                                String... roots) {\n@@ -2118,3 +2252,3 @@\n-    private Configuration resolveAndBind(Configuration parent,\n-                                         ModuleFinder before,\n-                                         String... roots) {\n+    private static Configuration resolveAndBind(Configuration parent,\n+                                                ModuleFinder before,\n+                                                String... roots) {\n@@ -2124,3 +2258,3 @@\n-    private Configuration resolveAndBind(ModuleFinder before,\n-                                         ModuleFinder after,\n-                                         String... roots) {\n+    private static Configuration resolveAndBind(ModuleFinder before,\n+                                                ModuleFinder after,\n+                                                String... roots) {\n@@ -2130,2 +2264,2 @@\n-    private Configuration resolveAndBind(ModuleFinder before,\n-                                         String... roots) {\n+    private static Configuration resolveAndBind(ModuleFinder before,\n+                                                String... roots) {\n@@ -2140,1 +2274,1 @@\n-    static Path writeModule(ModuleDescriptor descriptor, String targetPlatform)\n+    private static Path writeModule(ModuleDescriptor descriptor, String targetPlatform)\n","filename":"test\/jdk\/java\/lang\/module\/ConfigurationTest.java","additions":420,"deletions":286,"binary":false,"changes":706,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @key jfr\n+ * @requires vm.flagless\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestSyncOnValueBasedClassEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}