{"files":[{"patch":"@@ -100,0 +100,4 @@\n+ifneq ($(JLINK_USER_EXTRA_FLAGS), )\n+  JLINK_JDK_EXTRA_OPTS += $(JLINK_USER_EXTRA_FLAGS)\n+endif\n+\n","filename":"make\/Images.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -557,10 +557,0 @@\n-################################################################################\n-#\n-# Static build support.  When enabled will generate static\n-# libraries instead of shared libraries for all JDK libs.\n-#\n-AC_DEFUN_ONCE([JDKOPT_SETUP_STATIC_BUILD],\n-[\n-  UTIL_DEPRECATED_ARG_ENABLE(static-build)\n-])\n-\n@@ -633,0 +623,12 @@\n+\n+  ################################################################################\n+  #\n+  # Extra jlink options to be (optionally) passed to the JDK build\n+  #\n+  UTIL_ARG_WITH(NAME: extra-jlink-flags, TYPE: string,\n+      DEFAULT: [],\n+      DESC: [extra flags to be passed to jlink during the build],\n+      OPTIONAL: true)\n+\n+  JLINK_USER_EXTRA_FLAGS=\"$EXTRA_JLINK_FLAGS\"\n+  AC_SUBST(JLINK_USER_EXTRA_FLAGS)\n@@ -674,9 +676,0 @@\n-################################################################################\n-#\n-# Optionally disable man pages (deprecated)\n-#\n-AC_DEFUN([JDKOPT_ENABLE_DISABLE_MANPAGES],\n-[\n-  UTIL_DEPRECATED_ARG_ENABLE(manpages)\n-])\n-\n@@ -871,2 +864,0 @@\n-\n-  UTIL_DEPRECATED_ARG_ENABLE(reproducible-build)\n","filename":"make\/autoconf\/jdk-options.m4","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2574,0 +2574,58 @@\n+\/\/ VectorRearrange implementation for short\/int\/float\/long\/double types with NEON\n+\/\/ instructions. For VectorRearrange short\/int\/float, we use NEON tbl instruction.\n+\/\/ But since it supports bytes table only, we need to lookup 2\/4 bytes as a group.\n+\/\/ For VectorRearrange long\/double, we compare the shuffle input with iota indices,\n+\/\/ and use bsl to implement the operation.\n+void C2_MacroAssembler::neon_rearrange_hsd(FloatRegister dst, FloatRegister src,\n+                                           FloatRegister shuffle, FloatRegister tmp,\n+                                           BasicType bt, bool isQ) {\n+  assert_different_registers(dst, src, shuffle, tmp);\n+  SIMD_Arrangement size1 = isQ ? T16B : T8B;\n+  SIMD_Arrangement size2 = esize2arrangement((uint)type2aelembytes(bt), isQ);\n+\n+  \/\/ Here is an example that rearranges a NEON vector with 4 ints:\n+  \/\/ Rearrange V1 int[a0, a1, a2, a3] to V2 int[a2, a3, a0, a1]\n+  \/\/   1. We assume the shuffle input is Vi int[2, 3, 0, 1].\n+  \/\/   2. Multiply Vi int[2, 3, 0, 1] with constant int vector\n+  \/\/      [0x04040404, 0x04040404, 0x04040404, 0x04040404], and get\n+  \/\/      tbl base Vm int[0x08080808, 0x0c0c0c0c, 0x00000000, 0x04040404].\n+  \/\/   3. Add Vm with constant int[0x03020100, 0x03020100, 0x03020100, 0x03020100],\n+  \/\/      and get tbl index Vm int[0x0b0a0908, 0x0f0e0d0c, 0x03020100, 0x07060504]\n+  \/\/   4. Use Vm as index register, and use V1 as table register.\n+  \/\/      Then get V2 as the result by tbl NEON instructions.\n+  switch (bt) {\n+    case T_SHORT:\n+      mov(tmp, size1, 0x02);\n+      mulv(dst, size2, shuffle, tmp);\n+      mov(tmp, size2, 0x0100);\n+      addv(dst, size1, dst, tmp);\n+      tbl(dst, size1, src, 1, dst);\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      mov(tmp, size1, 0x04);\n+      mulv(dst, size2, shuffle, tmp);\n+      mov(tmp, size2, 0x03020100);\n+      addv(dst, size1, dst, tmp);\n+      tbl(dst, size1, src, 1, dst);\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      \/\/ Load the iota indices for Long type. The indices are ordered by\n+      \/\/ type B\/S\/I\/L\/F\/D, and the offset between two types is 16; Hence\n+      \/\/ the offset for L is 48.\n+      lea(rscratch1,\n+          ExternalAddress(StubRoutines::aarch64::vector_iota_indices() + 48));\n+      ldrq(tmp, rscratch1);\n+      \/\/ Check whether the input \"shuffle\" is the same with iota indices.\n+      \/\/ Return \"src\" if true, otherwise swap the two elements of \"src\".\n+      cm(EQ, dst, size2, shuffle, tmp);\n+      ext(tmp, size1, src, src, 8);\n+      bsl(dst, size1, src, tmp);\n+      break;\n+    default:\n+      assert(false, \"unsupported element type\");\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,0 +184,2 @@\n+  void neon_rearrange_hsd(FloatRegister dst, FloatRegister src, FloatRegister shuffle,\n+                          FloatRegister tmp, BasicType bt, bool isQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1523,1 +1523,5 @@\n-  return (offset < 0x80) ? 5 : 8; \/\/ REX\n+  if (ra_->get_encode(this) > 15) {\n+    return (offset < 0x80) ? 6 : 9; \/\/ REX2\n+  } else {\n+    return (offset < 0x80) ? 5 : 8; \/\/ REX\n+  }\n@@ -4405,1 +4409,1 @@\n-  ins_cost(125); \/\/ XXX\n+  ins_cost(125);\n@@ -4411,2 +4415,7 @@\n-    __ movl($dst$$Register, $mem$$Address);\n-    __ shrl($dst$$Register, markWord::klass_shift_at_offset);\n+    if (UseAPX) {\n+      __ eshrl($dst$$Register, $mem$$Address, markWord::klass_shift_at_offset, false);\n+    }\n+    else {\n+      __ movl($dst$$Register, $mem$$Address);\n+      __ shrl($dst$$Register, markWord::klass_shift_at_offset);\n+    }\n@@ -4414,1 +4423,1 @@\n-  ins_pipe(ialu_reg_mem); \/\/ XXX\n+  ins_pipe(ialu_reg_mem);\n@@ -6190,0 +6199,1 @@\n+  predicate(!UseAPX);\n@@ -6200,0 +6210,13 @@\n+instruct cmovI_reg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6215,0 +6238,1 @@\n+  predicate(!UseAPX);\n@@ -6225,0 +6249,12 @@\n+instruct cmovI_regU_ndd(rRegI dst, cmpOpU cop, rFlagsRegU cr, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6240,0 +6276,1 @@\n+  predicate(!UseAPX);\n@@ -6247,0 +6284,11 @@\n+instruct cmovI_regUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6248,1 +6296,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n@@ -6261,0 +6309,14 @@\n+instruct cmovI_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpl  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovnel $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovl(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6264,1 +6326,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n@@ -6277,0 +6339,16 @@\n+\/\/ We need this special handling for only eq \/ neq comparison since NaN == NaN is false,\n+\/\/ and parity flag bit is set if any of the operand is a NaN.\n+instruct cmovI_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src1, rRegI src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpl  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovnel $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovl(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6279,0 +6357,1 @@\n+  predicate(!UseAPX);\n@@ -6289,0 +6368,14 @@\n+\/\/ Conditional move\n+instruct cmovI_rReg_rReg_mem_ndd(rRegI dst, cmpOp cop, rFlagsReg cr, rRegI src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n+\n+  ins_cost(250);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n@@ -6292,0 +6385,1 @@\n+  predicate(!UseAPX);\n@@ -6303,0 +6397,1 @@\n+  predicate(!UseAPX);\n@@ -6310,0 +6405,25 @@\n+instruct cmovI_rReg_rReg_memU_ndd(rRegI dst, cmpOpU cop, rFlagsRegU cr, rRegI src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n+\n+  ins_cost(250);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+instruct cmovI_rReg_rReg_memUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, memory src2) \n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src1 (LoadI src2))));\n+  ins_cost(250);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n@@ -6313,0 +6433,1 @@\n+  predicate(!UseAPX);\n@@ -6323,0 +6444,14 @@\n+\/\/ Conditional move ndd\n+instruct cmovN_reg_ndd(rRegN dst, rRegN src1, rRegN src2, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, compressed ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6326,0 +6461,1 @@\n+  predicate(!UseAPX);\n@@ -6337,0 +6473,1 @@\n+  predicate(!UseAPX);\n@@ -6344,0 +6481,25 @@\n+\/\/ Conditional move ndd\n+instruct cmovN_regU_ndd(rRegN dst, cmpOpU cop, rFlagsRegU cr, rRegN src1, rRegN src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, compressed ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n+instruct cmovN_regUCF_ndd(rRegN dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegN src1, rRegN src2) %{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveN (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, compressed ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovl((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6377,0 +6539,1 @@\n+  predicate(!UseAPX);\n@@ -6387,0 +6550,14 @@\n+\/\/ Conditional move ndd\n+instruct cmovP_reg_ndd(rRegP dst, rRegP src1, rRegP src2, rFlagsReg cr, cmpOp cop)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6390,0 +6567,1 @@\n+  predicate(!UseAPX);\n@@ -6400,0 +6578,14 @@\n+\/\/ Conditional move ndd\n+instruct cmovP_regU_ndd(rRegP dst, cmpOpU cop, rFlagsRegU cr, rRegP src1, rRegP src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6408,0 +6600,10 @@\n+instruct cmovP_regUCF_ndd(rRegP dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegP src1, rRegP src2) %{\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, ptr ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6409,1 +6611,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n@@ -6422,0 +6624,14 @@\n+instruct cmovP_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src1, rRegP src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovneq $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovq(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6425,1 +6641,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n@@ -6438,0 +6654,14 @@\n+instruct cmovP_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src1, rRegP src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovneq $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovq(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6454,0 +6684,1 @@\n+  predicate(!UseAPX);\n@@ -6464,0 +6695,13 @@\n+instruct cmovL_reg_ndd(rRegL dst, cmpOp cop, rFlagsReg cr, rRegL src1, rRegL src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6466,0 +6710,1 @@\n+  predicate(!UseAPX);\n@@ -6476,0 +6721,13 @@\n+instruct cmovL_rReg_rReg_mem_ndd(rRegL dst, cmpOp cop, rFlagsReg cr, rRegL src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n@@ -6492,0 +6750,1 @@\n+  predicate(!UseAPX);\n@@ -6502,0 +6761,13 @@\n+instruct cmovL_regU_ndd(rRegL dst, cmpOpU cop, rFlagsRegU cr, rRegL src1, rRegL src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6517,0 +6789,1 @@\n+  predicate(!UseAPX);\n@@ -6524,0 +6797,12 @@\n+instruct cmovL_regUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, rRegL src2) \n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6525,1 +6810,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n@@ -6538,0 +6823,14 @@\n+instruct cmovL_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src1, rRegL src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovneq $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovq(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6541,1 +6840,1 @@\n-  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n@@ -6554,0 +6853,14 @@\n+instruct cmovL_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src1, rRegL src2) %{\n+  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n+            \"ecmovneq $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n+    __ ecmovq(Assembler::notEqual, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n+\n@@ -6556,0 +6869,1 @@\n+  predicate(!UseAPX);\n@@ -6567,0 +6881,1 @@\n+  predicate(!UseAPX);\n@@ -6574,0 +6889,25 @@\n+instruct cmovL_rReg_rReg_memU_ndd(rRegL dst, cmpOpU cop, rFlagsRegU cr, rRegL src1, memory src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n+\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n+instruct cmovL_rReg_rReg_memUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, memory src2) \n+%{\n+  predicate(UseAPX);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src1 (LoadL src2))));\n+  ins_cost(200);\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  ins_encode %{\n+    __ ecmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src1$$Register, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_cmov_mem);\n+%}\n+\n@@ -6667,0 +7007,1 @@\n+  predicate(!UseAPX);\n@@ -6677,0 +7018,14 @@\n+instruct addI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -6679,0 +7034,1 @@\n+  predicate(!UseAPX);\n@@ -6690,0 +7046,28 @@\n+instruct addI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct addI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n@@ -6692,0 +7076,1 @@\n+  predicate(!UseAPX);\n@@ -6704,0 +7089,30 @@\n+instruct addI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct addI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eaddl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eaddl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -6735,1 +7150,1 @@\n-  predicate(UseIncDec);\n+  predicate(!UseAPX && UseIncDec);\n@@ -6746,0 +7161,26 @@\n+instruct incI_rReg_ndd(rRegI dst, rRegI src, immI_1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI src val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eincl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct incI_rReg_mem_ndd(rRegI dst, memory src, immI_1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI (LoadI src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eincl($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -6763,1 +7204,1 @@\n-  predicate(UseIncDec);\n+  predicate(!UseAPX && UseIncDec);\n@@ -6774,0 +7215,26 @@\n+instruct decI_rReg_ndd(rRegI dst, rRegI src, immI_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI src val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ edecl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct decI_rReg_mem_ndd(rRegI dst, memory src, immI_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddI (LoadI src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ edecl($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -6842,0 +7309,1 @@\n+  predicate(!UseAPX);\n@@ -6853,0 +7321,14 @@\n+instruct addL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -6855,0 +7337,1 @@\n+  predicate(!UseAPX);\n@@ -6866,0 +7349,28 @@\n+instruct addL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n+instruct addL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe( ialu_reg );\n+%}\n+\n@@ -6868,0 +7379,1 @@\n+  predicate(!UseAPX);\n@@ -6880,0 +7392,30 @@\n+instruct addL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct addL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AddL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eaddq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eaddq($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -6910,1 +7452,1 @@\n-  predicate(UseIncDec);\n+  predicate(!UseAPX && UseIncDec);\n@@ -6921,0 +7463,26 @@\n+instruct incL_rReg_ndd(rRegI dst, rRegI src, immL1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL src val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eincq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct incL_rReg_mem_ndd(rRegI dst, memory src, immL1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL (LoadL src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"eincq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eincq($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -6938,1 +7506,1 @@\n-  predicate(UseIncDec);\n+  predicate(!UseAPX && UseIncDec);\n@@ -6949,0 +7517,26 @@\n+instruct decL_rReg_ndd(rRegL dst, rRegL src, immL_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL src val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ edecq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct decL_rReg_mem_ndd(rRegL dst, memory src, immL_M1 val, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && UseIncDec);\n+  match(Set dst (AddL (LoadL src) val));\n+  effect(KILL cr);\n+\n+  format %{ \"edecq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ edecq($dst$$Register, $src$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7584,0 +8178,1 @@\n+  predicate(!UseAPX);\n@@ -7595,0 +8190,42 @@\n+instruct subI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -7597,0 +8234,1 @@\n+  predicate(!UseAPX);\n@@ -7609,0 +8247,30 @@\n+instruct subI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct subI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ esubl($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -7625,0 +8293,1 @@\n+  predicate(!UseAPX);\n@@ -7636,0 +8305,42 @@\n+instruct subL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct subL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -7638,0 +8349,1 @@\n+  predicate(!UseAPX);\n@@ -7650,0 +8362,30 @@\n+instruct subL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct subL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n+  ins_cost(150);\n+  format %{ \"esubq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ esubq($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -7680,0 +8422,1 @@\n+  predicate(!UseAPX);\n@@ -7691,0 +8434,14 @@\n+instruct negI_rReg_ndd(rRegI dst, rRegI src, immI_0 zero, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubI zero src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ enegl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7693,0 +8450,1 @@\n+  predicate(!UseAPX);\n@@ -7704,0 +8462,14 @@\n+instruct negI_rReg_2_ndd(rRegI dst, rRegI src, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (NegI src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegl    $dst, $src\\t# int ndd\" %}\n+  ins_encode %{\n+    __ enegl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7719,0 +8491,1 @@\n+  predicate(!UseAPX);\n@@ -7730,0 +8503,14 @@\n+instruct negL_rReg_ndd(rRegL dst, rRegL src, immL0 zero, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (SubL zero src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ enegq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7732,0 +8519,1 @@\n+  predicate(!UseAPX);\n@@ -7743,0 +8531,14 @@\n+instruct negL_rReg_2_ndd(rRegL dst, rRegL src, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (NegL src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n+\n+  format %{ \"enegq    $dst, $src\\t# long ndd\" %}\n+  ins_encode %{\n+    __ enegq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -7762,0 +8564,1 @@\n+  predicate(!UseAPX);\n@@ -7773,0 +8576,14 @@\n+instruct mulI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulI src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eimull($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n@@ -7775,0 +8592,1 @@\n+  predicate(!UseAPX);\n@@ -7786,0 +8604,14 @@\n+instruct mulI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulI src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eimull($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n@@ -7788,0 +8620,1 @@\n+  predicate(!UseAPX);\n@@ -7799,0 +8632,14 @@\n+instruct mulI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulI src1 (LoadI src2)));\n+  effect(KILL cr);\n+\n+  ins_cost(350);\n+  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eimull($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n@@ -7801,0 +8648,1 @@\n+  predicate(!UseAPX);\n@@ -7812,0 +8660,14 @@\n+instruct mulI_rReg_mem_imm(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulI (LoadI src1) src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimull   $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eimull($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n@@ -7824,0 +8686,1 @@\n+  predicate(!UseAPX);\n@@ -7835,0 +8698,14 @@\n+instruct mulL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulL src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eimulq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n@@ -7837,0 +8714,1 @@\n+  predicate(!UseAPX);\n@@ -7848,0 +8726,14 @@\n+instruct mulL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulL src1 src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eimulq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n@@ -7850,0 +8742,1 @@\n+  predicate(!UseAPX);\n@@ -7861,0 +8754,14 @@\n+instruct mulL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulL src1 (LoadL src2)));\n+  effect(KILL cr);\n+\n+  ins_cost(350);\n+  format %{ \"eimulq   $dst, $src1, $src2 \\t# long\" %}\n+  ins_encode %{\n+    __ eimulq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n@@ -7863,0 +8770,1 @@\n+  predicate(!UseAPX);\n@@ -7867,1 +8775,15 @@\n-  format %{ \"imulq   $dst, $src, $imm\\t# long\" %}\n+  format %{ \"imulq   $dst, $src, $imm\\t# long\" %}\n+  ins_encode %{\n+    __ imulq($dst$$Register, $src$$Address, $imm$$constant);\n+  %}\n+  ins_pipe(ialu_reg_mem_alu0);\n+%}\n+\n+instruct mulL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MulL (LoadL src1) src2));\n+  effect(KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"eimulq   $dst, $src1, $src2\\t# long ndd\" %}\n@@ -7869,1 +8791,1 @@\n-    __ imulq($dst$$Register, $src$$Address, $imm$$constant);\n+    __ eimulq($dst$$Register, $src1$$Address, $src2$$constant, false);\n@@ -8109,0 +9031,1 @@\n+  predicate(!UseAPX);\n@@ -8119,0 +9042,14 @@\n+\/\/ Shift Left by one, two, three\n+instruct salI_rReg_immI2_ndd(rRegI dst, rRegI src, immI2 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esall    $dst, $src, $shift\\t# int(ndd)\" %}\n+  ins_encode %{\n+    __ esall($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8122,0 +9059,1 @@\n+  predicate(!UseAPX);\n@@ -8132,0 +9070,27 @@\n+\/\/ Shift Left by 8-bit immediate\n+instruct salI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esall    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esall($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct salI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftI (LoadI src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esall    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esall($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8200,0 +9165,1 @@\n+  predicate(!UseAPX);\n@@ -8210,0 +9176,27 @@\n+\/\/ Arithmetic Shift Right by 8-bit immediate\n+instruct sarI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarl    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esarl($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct sarI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftI (LoadI src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarl    $dst, $src, $shift\\t# int (ndd)\" %}\n+  ins_encode %{\n+    __ esarl($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n@@ -8278,0 +9271,1 @@\n+  predicate(!UseAPX);\n@@ -8288,0 +9282,27 @@\n+\/\/ Logical Shift Right by 8-bit immediate\n+instruct shrI_rReg_imm_ndd(rRegI dst, rRegI src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftI src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrl    $dst, $src, $shift\\t # int (ndd)\" %}\n+  ins_encode %{\n+    __ eshrl($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct shrI_rReg_mem_imm_ndd(rRegI dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftI (LoadI src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrl    $dst, $src, $shift\\t # int (ndd)\" %}\n+  ins_encode %{\n+    __ eshrl($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8357,0 +9378,1 @@\n+  predicate(!UseAPX);\n@@ -8367,0 +9389,14 @@\n+\/\/ Shift Left by one, two, three\n+instruct salL_rReg_immI2_ndd(rRegL dst, rRegL src, immI2 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esalq($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8370,0 +9406,1 @@\n+  predicate(!UseAPX);\n@@ -8380,0 +9417,27 @@\n+\/\/ Shift Left by 8-bit immediate\n+instruct salL_rReg_imm_ndd(rRegL dst, rRegL src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esalq($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct salL_rReg_mem_imm_ndd(rRegL dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (LShiftL (LoadL src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esalq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esalq($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8448,0 +9512,1 @@\n+  predicate(!UseAPX);\n@@ -8458,0 +9523,27 @@\n+\/\/ Arithmetic Shift Right by 8-bit immediate\n+instruct sarL_rReg_imm_ndd(rRegL dst, rRegL src, immI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esarq($dst$$Register, $src$$Register, (unsigned char)($shift$$constant & 0x3F), false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n+instruct sarL_rReg_mem_imm_ndd(rRegL dst, memory src, immI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (RShiftL (LoadL src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"esarq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ esarq($dst$$Register, $src$$Address, (unsigned char)($shift$$constant & 0x3F), false);\n+  %}\n+  ins_pipe(ialu_mem_imm);\n+%}\n+\n@@ -8526,0 +9618,1 @@\n+  predicate(!UseAPX);\n@@ -8536,0 +9629,27 @@\n+\/\/ Logical Shift Right by 8-bit immediate\n+instruct shrL_rReg_imm_ndd(rRegL dst, rRegL src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftL src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ eshrq($dst$$Register, $src$$Register, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct shrL_rReg_mem_imm_ndd(rRegL dst, memory src, immI8 shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (URShiftL (LoadL src) shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eshrq    $dst, $src, $shift\\t# long (ndd)\" %}\n+  ins_encode %{\n+    __ eshrq($dst$$Register, $src$$Address, $shift$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8644,1 +9764,1 @@\n-  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n@@ -8670,1 +9790,1 @@\n-  predicate(n->bottom_type()->basic_type() == T_INT);\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_INT);\n@@ -8680,0 +9800,14 @@\n+\/\/ Rotate Left by variable\n+instruct rolI_rReg_Var_ndd(rRegI dst, rRegI src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateLeft src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"eroll    $dst, $src, $shift\\t# rotate left (int ndd)\" %}\n+  ins_encode %{\n+    __ eroll($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -8696,1 +9830,1 @@\n-  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n+  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_INT);\n@@ -8720,1 +9854,1 @@\n-  predicate(n->bottom_type()->basic_type() == T_INT);\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_INT);\n@@ -8730,0 +9864,14 @@\n+\/\/ Rotate Right by variable\n+instruct rorI_rReg_Var_ndd(rRegI dst, rRegI src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_INT);\n+  match(Set dst (RotateRight src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"erorl    $dst, $src, $shift\\t# rotate right(int ndd)\" %}\n+  ins_encode %{\n+    __ erorl($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -8745,1 +9893,1 @@\n-  predicate(VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n+  predicate(!UseAPX && VM_Version::supports_bmi2() && n->bottom_type()->basic_type() == T_LONG);\n@@ -8771,1 +9919,1 @@\n-  predicate(n->bottom_type()->basic_type() == T_LONG);\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_LONG);\n@@ -8781,0 +9929,14 @@\n+\/\/ Rotate Left by variable\n+instruct rolL_rReg_Var_ndd(rRegL dst, rRegL src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateLeft src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"erolq    $dst, $src, $shift\\t# rotate left(long ndd)\" %}\n+  ins_encode %{\n+    __ erolq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -8821,1 +9983,1 @@\n-  predicate(n->bottom_type()->basic_type() == T_LONG);\n+  predicate(!UseAPX && n->bottom_type()->basic_type() == T_LONG);\n@@ -8831,0 +9993,14 @@\n+\/\/ Rotate Right by variable\n+instruct rorL_rReg_Var_ndd(rRegL dst, rRegL src, rcx_RegI shift, rFlagsReg cr)\n+%{\n+  predicate(UseAPX && n->bottom_type()->basic_type() == T_LONG);\n+  match(Set dst (RotateRight src shift));\n+  effect(KILL cr);\n+\n+  format %{ \"erorq    $dst, $src, $shift\\t# rotate right(long ndd)\" %}\n+  ins_encode %{\n+    __ erorq($dst$$Register, $src$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -8882,0 +10058,1 @@\n+  predicate(!UseAPX);\n@@ -8893,0 +10070,16 @@\n+\/\/ And Register with Register using New Data Destination (NDD)\n+instruct andI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -8959,0 +10152,1 @@\n+  predicate(!UseAPX);\n@@ -8970,0 +10164,28 @@\n+instruct andI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct andI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8973,0 +10195,1 @@\n+  predicate(!UseAPX);\n@@ -8985,0 +10208,15 @@\n+instruct andI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eandl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eandl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9157,0 +10395,1 @@\n+  predicate(!UseAPX);\n@@ -9168,0 +10407,15 @@\n+\/\/ Or Register with Register using New Data Destination (NDD)\n+instruct orI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -9171,1 +10425,44 @@\n-  match(Set dst (OrI dst src));\n+  predicate(!UseAPX);\n+  match(Set dst (OrI dst src));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"orl     $dst, $src\\t# int\" %}\n+  ins_encode %{\n+    __ orl($dst$$Register, $src$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orI_rReg_imm_rReg_ndd(rRegI dst, immI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorl     $dst, $src2, $src1\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src2$$Register, $src1$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI (LoadI src1) src2));\n@@ -9175,1 +10472,1 @@\n-  format %{ \"orl     $dst, $src\\t# int\" %}\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n@@ -9177,1 +10474,1 @@\n-    __ orl($dst$$Register, $src$$constant);\n+    __ eorl($dst$$Register, $src1$$Address, $src2$$constant, false);\n@@ -9185,0 +10482,1 @@\n+  predicate(!UseAPX);\n@@ -9197,0 +10495,15 @@\n+instruct orI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eorl     $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ eorl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9245,0 +10558,1 @@\n+  predicate(!UseAPX);\n@@ -9256,0 +10570,15 @@\n+\/\/ Xor Register with Register using New Data Destination (NDD)\n+instruct xorI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -9257,1 +10586,3 @@\n-instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{\n+instruct xorI_rReg_im1(rRegI dst, immI_M1 imm)\n+%{\n+  predicate(!UseAPX);\n@@ -9260,1 +10591,1 @@\n-  format %{ \"not    $dst\" %}\n+  format %{ \"notl    $dst\" %}\n@@ -9267,0 +10598,12 @@\n+instruct xorI_rReg_im1_ndd(rRegI dst, rRegI src, immI_M1 imm)\n+%{\n+  match(Set dst (XorI src imm));\n+  predicate(UseAPX);\n+\n+  format %{ \"enotl    $dst, $src\" %}\n+  ins_encode %{\n+     __ enotl($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9270,0 +10613,1 @@\n+  predicate(!UseAPX);\n@@ -9281,0 +10625,29 @@\n+instruct xorI_rReg_rReg_imm_ndd(rRegI dst, rRegI src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Xor Memory with Immediate\n+instruct xorI_rReg_mem_imm_ndd(rRegI dst, memory src1, immI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9284,0 +10657,1 @@\n+  predicate(!UseAPX);\n@@ -9296,0 +10670,30 @@\n+instruct xorI_rReg_rReg_mem_ndd(rRegI dst, rRegI src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI src1 (LoadI src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct xorI_rReg_mem_rReg_ndd(rRegI dst, memory src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorI (LoadI src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"exorl    $dst, $src1, $src2\\t# int ndd\" %}\n+  ins_encode %{\n+    __ exorl($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9347,0 +10751,1 @@\n+  predicate(!UseAPX);\n@@ -9358,0 +10763,16 @@\n+\/\/ And Register with Register using New Data Destination (NDD)\n+instruct andL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -9387,0 +10808,1 @@\n+  predicate(!UseAPX);\n@@ -9398,0 +10820,28 @@\n+instruct andL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct andL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9401,0 +10851,1 @@\n+  predicate(!UseAPX);\n@@ -9413,0 +10864,30 @@\n+instruct andL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct andL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (AndL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eandq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eandq($dst$$Register, $src1$$Address, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9588,0 +11069,1 @@\n+  predicate(!UseAPX);\n@@ -9599,0 +11081,16 @@\n+\/\/ Or Register with Register using New Data Destination (NDD)\n+instruct orL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -9612,0 +11110,11 @@\n+instruct orL_rReg_castP2X_ndd(rRegL dst, any_RegP src1, any_RegP src2, rFlagsReg cr) %{\n+  match(Set dst (OrL src1 (CastP2X src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -9616,0 +11125,1 @@\n+  predicate(!UseAPX);\n@@ -9627,0 +11137,43 @@\n+instruct orL_rReg_rReg_imm_ndd(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct orL_rReg_imm_rReg_ndd(rRegL dst, immL32 src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src2, $src1\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src2$$Register, $src1$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Or Memory with Immediate\n+instruct orL_rReg_mem_imm_ndd(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9630,0 +11183,1 @@\n+  predicate(!UseAPX);\n@@ -9642,0 +11196,15 @@\n+instruct orL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (OrL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"eorq     $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ eorq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -9693,0 +11262,1 @@\n+  predicate(!UseAPX);\n@@ -9704,0 +11274,15 @@\n+\/\/ Xor Register with Register using New Data Destination (NDD)\n+instruct xorL_rReg_ndd(rRegL dst, rRegL src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Register, $src2$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n@@ -9705,1 +11290,3 @@\n-instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{\n+instruct xorL_rReg_im1(rRegL dst, immL_M1 imm)\n+%{\n+  predicate(!UseAPX);\n@@ -9715,0 +11302,12 @@\n+instruct xorL_rReg_im1_ndd(rRegL dst,rRegL src, immL_M1 imm)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL src imm));\n+\n+  format %{ \"enotq   $dst, $src\" %}\n+  ins_encode %{\n+    __ enotq($dst$$Register, $src$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9718,0 +11317,1 @@\n+  predicate(!UseAPX);\n@@ -9729,0 +11329,29 @@\n+instruct xorL_rReg_rReg_imm(rRegL dst, rRegL src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL src1 src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Register, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Xor Memory with Immediate\n+instruct xorL_rReg_mem_imm(rRegL dst, memory src1, immL32 src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Address, $src2$$constant, false);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9732,0 +11361,1 @@\n+  predicate(!UseAPX);\n@@ -9744,0 +11374,30 @@\n+instruct xorL_rReg_rReg_mem_ndd(rRegL dst, rRegL src1, memory src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL src1 (LoadL src2)));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Register, $src2$$Address, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n+instruct xorL_rReg_mem_rReg_ndd(rRegL dst, memory src1, rRegL src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (XorL (LoadL src1) src2));\n+  effect(KILL cr);\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n+\n+  ins_cost(150);\n+  format %{ \"exorq    $dst, $src1, $src2\\t# long ndd\" %}\n+  ins_encode %{\n+    __ exorq($dst$$Register, $src1$$Address, $src1$$Register, false);\n+  %}\n+  ins_pipe(ialu_reg_mem);\n+%}\n+\n@@ -12270,0 +13930,1 @@\n+  predicate(!UseAPX);\n@@ -12279,0 +13940,11 @@\n+instruct cmovI_reg_g_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+\n+  format %{ \"ecmovlgt $dst, $src1, $src2\\t# min ndd\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::greater, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n@@ -12282,0 +13954,1 @@\n+  predicate(!UseAPX);\n@@ -12292,0 +13965,14 @@\n+instruct minI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MinI src1 src2));\n+  effect(DEF dst, USE src1, USE src2);\n+\n+  ins_cost(200);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_rReg(cr, src1, src2);\n+    cmovI_reg_g_ndd(dst, src1, src2, cr);\n+  %}\n+%}\n+\n@@ -12294,0 +13981,1 @@\n+  predicate(!UseAPX);\n@@ -12303,0 +13991,11 @@\n+instruct cmovI_reg_l_ndd(rRegI dst, rRegI src1, rRegI src2, rFlagsReg cr)\n+%{\n+  predicate(UseAPX);\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+\n+  format %{ \"ecmovllt $dst, $src1, $src2\\t# max ndd\" %}\n+  ins_encode %{\n+    __ ecmovl(Assembler::less, $dst$$Register, $src1$$Register, $src2$$Register);\n+  %}\n+  ins_pipe(pipe_cmov_reg);\n+%}\n@@ -12306,0 +14005,1 @@\n+  predicate(!UseAPX);\n@@ -12316,0 +14016,14 @@\n+instruct maxI_rReg_ndd(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(UseAPX);\n+  match(Set dst (MaxI src1 src2));\n+  effect(DEF dst, USE src1, USE src2);\n+\n+  ins_cost(200);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_rReg(cr, src1, src2);\n+    cmovI_reg_l_ndd(dst, src1, src2, cr);\n+  %}\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":1744,"deletions":30,"binary":false,"changes":1774,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -465,0 +465,2 @@\n+    _total_start     = nullptr;\n+    _total_size      = 0;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -242,2 +242,2 @@\n-                                                 must_gc_arguments);\n-  assert(blob != nullptr, \"blob must exist\");\n+                                                 must_gc_arguments,\n+                                                 false \/* alloc_fail_is_fatal *\/ );\n@@ -247,1 +247,1 @@\n-void Runtime1::generate_blob_for(BufferBlob* buffer_blob, C1StubId id) {\n+bool Runtime1::generate_blob_for(BufferBlob* buffer_blob, C1StubId id) {\n@@ -270,0 +270,1 @@\n+  return blob != nullptr;\n@@ -272,1 +273,1 @@\n-void Runtime1::initialize(BufferBlob* blob) {\n+bool Runtime1::initialize(BufferBlob* blob) {\n@@ -277,1 +278,5 @@\n-  for (int id = 0; id < limit; id++) generate_blob_for(blob, (C1StubId)id);\n+  for (int id = 0; id < limit; id++) {\n+    if (!generate_blob_for(blob, (C1StubId) id)) {\n+      return false;\n+    }\n+  }\n@@ -291,1 +296,1 @@\n-  bs->generate_c1_runtime_stubs(blob);\n+  return bs->generate_c1_runtime_stubs(blob);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  static void       generate_blob_for(BufferBlob* blob, C1StubId id);\n+  static bool       generate_blob_for(BufferBlob* blob, C1StubId id);\n@@ -151,1 +151,1 @@\n-  static void initialize(BufferBlob* blob);\n+  static bool initialize(BufferBlob* blob);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+         (is_dumping_method_handles()       ? IS_DUMPING_METHOD_HANDLES : 0) |\n@@ -676,0 +677,5 @@\n+\/\/ This is *Legacy* optimization for lambdas before JEP 483. May be removed in the future.\n+bool CDSConfig::is_dumping_lambdas_in_legacy_mode() {\n+  return !is_dumping_method_handles();\n+}\n+\n@@ -681,1 +687,0 @@\n-\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -74,3 +74,5 @@\n-  static const int IS_DUMPING_STATIC_ARCHIVE       = 1 << 1;\n-  static const int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 2;\n-  static const int IS_USING_ARCHIVE                = 1 << 3;\n+  static const int IS_DUMPING_METHOD_HANDLES       = 1 << 1;\n+  static const int IS_DUMPING_STATIC_ARCHIVE       = 1 << 2;\n+  static const int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 3;\n+  static const int IS_USING_ARCHIVE                = 1 << 4;\n+\n@@ -140,0 +142,3 @@\n+  \/\/ This is *Legacy* optimization for lambdas before JEP 483. May be removed in the future.\n+  static bool is_dumping_lambdas_in_legacy_mode()            NOT_CDS_RETURN_(false);\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -664,1 +665,1 @@\n-      if (!SystemDictionaryShared::is_supported_invokedynamic(&bootstrap_specifier)) {\n+      if (!LambdaProxyClassDictionary::is_supported_invokedynamic(&bootstrap_specifier)) {\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-GrowableArrayCHeap<OopHandle, mtClassShared>* HeapShared::_root_segments;\n+GrowableArrayCHeap<OopHandle, mtClassShared>* HeapShared::_root_segments = nullptr;\n@@ -228,4 +228,0 @@\n-  if (_pending_roots == nullptr) {\n-    _pending_roots = new GrowableArrayCHeap<oop, mtClassShared>(500);\n-  }\n-\n@@ -339,0 +335,6 @@\n+      } else if (java_lang_invoke_ResolvedMethodName::is_instance(obj)) {\n+        Method* m = java_lang_invoke_ResolvedMethodName::vmtarget(obj);\n+        if (m != nullptr) {\n+          InstanceKlass* method_holder = m->method_holder();\n+          AOTArtifactFinder::add_cached_class(method_holder);\n+        }\n@@ -405,0 +407,1 @@\n+  _pending_roots = new GrowableArrayCHeap<oop, mtClassShared>(500);\n@@ -568,1 +571,1 @@\n-  if (log_is_enabled(Info, cds, init)) {\n+  if (log_is_enabled(Debug, cds, init)) {\n@@ -784,0 +787,2 @@\n+      \/\/ -XX:AOTInitTestClass must be used carefully in regression tests to\n+      \/\/ include only classes that are safe to aot-initialize.\n@@ -785,1 +790,2 @@\n-             HeapShared::is_lambda_proxy_klass(ik),\n+             HeapShared::is_lambda_proxy_klass(ik) ||\n+             AOTClassInitializer::has_test_class(),\n@@ -830,0 +836,7 @@\n+#ifndef PRODUCT\n+  if (AOTClassInitializer::has_test_class()) {\n+    \/\/ The tests can cache arbitrary types of objects.\n+    return;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -45,0 +46,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -665,1 +667,4 @@\n-  SystemDictionaryShared::adjust_lambda_proxy_class_dictionary();\n+  if (CDSConfig::is_dumping_lambdas_in_legacy_mode()) {\n+    log_info(cds)(\"Adjust lambda proxy class dictionary\");\n+    LambdaProxyClassDictionary::adjust_dumptime_table();\n+  }\n@@ -741,0 +746,1 @@\n+  AOTClassInitializer::init_test_class(CHECK);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -407,3 +407,0 @@\n-      if (field_off > field_offset)\n-        break;\n-      \/\/ could do binary search or check bins, but probably not worth it\n@@ -460,1 +457,0 @@\n-\n@@ -558,2 +554,0 @@\n-  \/\/ Now sort them by offset, ascending.\n-  \/\/ (In principle, they could mix with superclass fields.)\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  GrowableArray<ciField*>* _nonstatic_fields;\n+  GrowableArray<ciField*>* _nonstatic_fields;  \/\/ ordered by JavaFieldStream\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5482,1 +5482,1 @@\n-    \/\/ These are supported by CDS only when CDSConfig::is_dumping_invokedynamic() is enabled.\n+    \/\/ These are supported by CDS only when CDSConfig::is_dumping_method_handles() is enabled.\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1078,32 +1078,0 @@\n-InstanceKlass* SystemDictionary::load_shared_lambda_proxy_class(InstanceKlass* ik,\n-                                                                Handle class_loader,\n-                                                                Handle protection_domain,\n-                                                                PackageEntry* pkg_entry,\n-                                                                TRAPS) {\n-  InstanceKlass* shared_nest_host = SystemDictionaryShared::get_shared_nest_host(ik);\n-  assert(shared_nest_host->is_shared(), \"nest host must be in CDS archive\");\n-  Symbol* cn = shared_nest_host->name();\n-  Klass *s = resolve_or_fail(cn, class_loader, true, CHECK_NULL);\n-  if (s != shared_nest_host) {\n-    \/\/ The dynamically resolved nest_host is not the same as the one we used during dump time,\n-    \/\/ so we cannot use ik.\n-    return nullptr;\n-  } else {\n-    assert(s->is_shared(), \"must be\");\n-  }\n-\n-  InstanceKlass* loaded_ik = load_shared_class(ik, class_loader, protection_domain, nullptr, pkg_entry, CHECK_NULL);\n-\n-  if (loaded_ik != nullptr) {\n-    assert(shared_nest_host->is_same_class_package(ik),\n-           \"lambda proxy class and its nest host must be in the same package\");\n-    \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n-    \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n-    assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n-    assert(shared_nest_host->class_loader_data() == class_loader_data(class_loader), \"mismatched class loader data\");\n-    ik->set_nest_host(shared_nest_host);\n-  }\n-\n-  return loaded_ik;\n-}\n-\n@@ -1117,0 +1085,1 @@\n+  assert(ik->is_shared(), \"sanity\");\n@@ -1167,1 +1136,1 @@\n-  if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {\n+  if (!ik->is_hidden()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":33,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+  friend class LambdaProxyClassDictionary;\n@@ -331,1 +332,1 @@\n-  \/\/ Used by SystemDictionaryShared\n+  \/\/ Used by SystemDictionaryShared and LambdaProxyClassDictionary\n@@ -336,5 +337,0 @@\n-  static InstanceKlass* load_shared_lambda_proxy_class(InstanceKlass* ik,\n-                                                       Handle class_loader,\n-                                                       Handle protection_domain,\n-                                                       PackageEntry* pkg_entry,\n-                                                       TRAPS);\n@@ -351,0 +347,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  _mutable_data(nullptr),\n+  _mutable_data(header_begin() + size), \/\/ default value is blob_end()\n@@ -156,0 +156,3 @@\n+  } else {\n+    \/\/ We need unique and valid not null address\n+    assert(_mutable_data = blob_end(), \"sanity\");\n@@ -165,1 +168,1 @@\n-  _mutable_data(nullptr),\n+  _mutable_data(header_begin() + size), \/\/ default value is blob_end()\n@@ -180,0 +183,1 @@\n+  assert(_mutable_data = blob_end(), \"sanity\");\n@@ -183,1 +187,2 @@\n-  if (_mutable_data != nullptr) {\n+  assert(_mutable_data != nullptr, \"should never be null\");\n+  if (_mutable_data != blob_end()) {\n@@ -185,1 +190,1 @@\n-    _mutable_data = nullptr;\n+    _mutable_data = blob_end(); \/\/ Valid not null address\n@@ -519,1 +524,1 @@\n-void* SingletonBlob::operator new(size_t s, unsigned size) throw() {\n+void* SingletonBlob::operator new(size_t s, unsigned size, bool alloc_fail_is_fatal) throw() {\n@@ -521,1 +526,1 @@\n-  if (!p) fatal(\"Initial size of CodeCache is too small\");\n+  if (alloc_fail_is_fatal && !p) fatal(\"Initial size of CodeCache is too small\");\n@@ -603,1 +608,1 @@\n-    blob = new (size) UncommonTrapBlob(cb, size, oop_maps, frame_size);\n+    blob = new (size, false) UncommonTrapBlob(cb, size, oop_maps, frame_size);\n@@ -635,1 +640,1 @@\n-    blob = new (size) ExceptionBlob(cb, size, oop_maps, frame_size);\n+    blob = new (size, false) ExceptionBlob(cb, size, oop_maps, frame_size);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -487,1 +487,1 @@\n-  void* operator new(size_t s, unsigned size) throw();\n+  void* operator new(size_t s, unsigned size, bool alloc_fail_is_fatal=true) throw();\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2343,1 +2343,0 @@\n-    DirectivesStack::release(directive);\n@@ -2377,1 +2376,1 @@\n-    if (PrintCompilation) {\n+    if (PrintCompilation || directive->PrintCompilationOption) {\n@@ -2385,0 +2384,2 @@\n+  DirectivesStack::release(directive);\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-  virtual void generate_c1_runtime_stubs(BufferBlob* buffer_blob) {}\n+  virtual bool generate_c1_runtime_stubs(BufferBlob* buffer_blob) { return true; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -224,0 +224,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_NeedsClassInitBarrierForCDS(JNIEnv* env, jclass cls);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2909,1 +2909,1 @@\n-  if (CDSConfig::is_dumping_invokedynamic() && HeapShared::is_lambda_proxy_klass(this)) {\n+  if (CDSConfig::is_dumping_method_handles() && HeapShared::is_lambda_proxy_klass(this)) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -733,0 +733,22 @@\n+\n+void AllocateNode::dump_spec(outputStream* st) const {\n+  st->print(\" \");\n+  if (tf() != nullptr) {\n+    tf()->dump_on(st);\n+  }\n+  if (_cnt != COUNT_UNKNOWN) {\n+    st->print(\" C=%f\", _cnt);\n+  }\n+  const Node* const klass_node = in(KlassNode);\n+  if (klass_node != nullptr) {\n+    const TypeKlassPtr* const klass_ptr = klass_node->bottom_type()->isa_klassptr();\n+\n+    if (klass_ptr != nullptr && klass_ptr->klass_is_exact()) {\n+      st->print(\" allocationKlass:\");\n+      klass_ptr->exact_klass()->print_name_on(st);\n+    }\n+  }\n+  if (jvms() != nullptr) {\n+    jvms()->dump_spec(st);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1107,0 +1107,2 @@\n+\n+  NOT_PRODUCT(virtual void dump_spec(outputStream* st) const;)\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-void Compile::disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist) {\n+void Compile::disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist, const Unique_Node_List* root_and_safepoints) {\n@@ -491,1 +491,1 @@\n-  debug_only(verify_graph_edges(true\/*check for no_dead_code*\/);)\n+  debug_only(verify_graph_edges(true \/*check for no_dead_code*\/, root_and_safepoints);)\n@@ -4743,1 +4743,1 @@\n-void Compile::verify_bidirectional_edges(Unique_Node_List &visited) {\n+void Compile::verify_bidirectional_edges(Unique_Node_List& visited, const Unique_Node_List* root_and_safepoints) const {\n@@ -4746,2 +4746,16 @@\n-  Node_List nstack(MAX2(stack_size, (uint)OptoNodeListSize));\n-  nstack.push(_root);\n+  Node_List nstack(MAX2(stack_size, (uint) OptoNodeListSize));\n+  if (root_and_safepoints != nullptr) {\n+    assert(root_and_safepoints->member(_root), \"root is not in root_and_safepoints\");\n+    for (uint i = 0, limit = root_and_safepoints->size(); i < limit; i++) {\n+      Node* root_or_safepoint = root_and_safepoints->at(i);\n+      \/\/ If the node is a safepoint, let's check if it still has a control input\n+      \/\/ Lack of control input signifies that this node was killed by CCP or\n+      \/\/ recursively by remove_globally_dead_node and it shouldn't be a starting\n+      \/\/ point.\n+      if (!root_or_safepoint->is_SafePoint() || root_or_safepoint->in(0) != nullptr) {\n+        nstack.push(root_or_safepoint);\n+      }\n+    }\n+  } else {\n+    nstack.push(_root);\n+  }\n@@ -4798,1 +4812,1 @@\n-void Compile::verify_graph_edges(bool no_dead_code) {\n+void Compile::verify_graph_edges(bool no_dead_code, const Unique_Node_List* root_and_safepoints) const {\n@@ -4803,1 +4817,1 @@\n-    verify_bidirectional_edges(visited);\n+    verify_bidirectional_edges(visited, root_and_safepoints);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1064,1 +1064,1 @@\n-  void              disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist);\n+  void disconnect_useless_nodes(Unique_Node_List& useful, Unique_Node_List& worklist, const Unique_Node_List* root_and_safepoints = nullptr);\n@@ -1271,5 +1271,19 @@\n-  \/\/ Walk the node list, verifying that there is a one-to-one\n-  \/\/ correspondence between Use-Def edges and Def-Use edges\n-  \/\/ The option no_dead_code enables stronger checks that the\n-  \/\/ graph is strongly connected from root in both directions.\n-  void verify_graph_edges(bool no_dead_code = false) PRODUCT_RETURN;\n+  \/\/ Walk the node list, verifying that there is a one-to-one correspondence\n+  \/\/ between Use-Def edges and Def-Use edges. The option no_dead_code enables\n+  \/\/ stronger checks that the graph is strongly connected from starting points\n+  \/\/ in both directions.\n+  \/\/ root_and_safepoints is used to give the starting points for the traversal.\n+  \/\/ If not supplied, only root is used. When this check is called after CCP,\n+  \/\/ we need to start traversal from Root and safepoints, just like CCP does its\n+  \/\/ own traversal (see PhaseCCP::transform for reasons).\n+  \/\/\n+  \/\/ To call this function, there are 2 ways to go:\n+  \/\/ - give root_and_safepoints to start traversal everywhere needed (like after CCP)\n+  \/\/ - if the whole graph is assumed to be reachable from Root's input,\n+  \/\/   root_and_safepoints is not needed (like in PhaseRemoveUseless).\n+  \/\/\n+  \/\/ Failure to specify root_and_safepoints in case the graph is not fully\n+  \/\/ reachable from Root's input make this check unsound (can miss inconsistencies)\n+  \/\/ and even incomplete (can make up non-existing problems) if no_dead_code is\n+  \/\/ true.\n+  void verify_graph_edges(bool no_dead_code = false, const Unique_Node_List* root_and_safepoints = nullptr) const PRODUCT_RETURN;\n@@ -1278,1 +1292,1 @@\n-  void verify_bidirectional_edges(Unique_Node_List &visited);\n+  void verify_bidirectional_edges(Unique_Node_List& visited, const Unique_Node_List* root_and_safepoints = nullptr) const;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3394,1 +3394,2 @@\n-  Node* notified_reset_memory = store_to_memory(control(), notified_offset, _gvn.intcon(0), T_BOOLEAN, MemNode::unordered);\n+  store_to_memory(control(), notified_offset, _gvn.intcon(0), T_BOOLEAN, MemNode::unordered);\n+  Node* notified_reset_memory = reset_memory();\n@@ -3412,6 +3413,4 @@\n-  Node* commit_memory;\n-#ifdef _LP64\n-  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_LONG, MemNode::release);\n-#else\n-  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_INT, MemNode::release);\n-#endif\n+  store_to_memory(control(), java_buffer_pos_offset, next_pos_X, LP64_ONLY(T_LONG) NOT_LP64(T_INT), MemNode::release);\n+\n+  Node* commit_memory = reset_memory();\n+  set_all_memory(commit_memory);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -474,1 +474,2 @@\n-  LoopNode* const _loop_head; \/\/ OuterStripMinedLoopNode if loop strip mined, else just the loop head.\n+  LoopNode* const _loop_head;\n+  LoopNode* const _outer_loop_head; \/\/ OuterStripMinedLoopNode if loop strip mined, else just the loop head.\n@@ -481,1 +482,2 @@\n-      : _loop_head(loop->_head->as_Loop()->skip_strip_mined()),\n+      : _loop_head(loop->_head->as_Loop()),\n+        _outer_loop_head(loop->_head->as_Loop()->skip_strip_mined()),\n@@ -508,1 +510,1 @@\n-    _phase->clone_loop(_loop, _old_new, _phase->dom_depth(_loop_head),\n+    _phase->clone_loop(_loop, _old_new, _phase->dom_depth(_outer_loop_head),\n@@ -513,3 +515,3 @@\n-  void fix_loop_entries(const LoopSelector& loop_selector) {\n-    _phase->replace_loop_entry(_loop_head, loop_selector.true_path_loop_proj());\n-    LoopNode* false_path_loop_strip_mined_head = old_to_new(_loop_head)->as_Loop();\n+  void fix_loop_entries(const LoopSelector& loop_selector) const {\n+    _phase->replace_loop_entry(_outer_loop_head, loop_selector.true_path_loop_proj());\n+    LoopNode* false_path_loop_strip_mined_head = old_to_new(_outer_loop_head)->as_Loop();\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -986,1 +986,1 @@\n-  void update_main_loop_assertion_predicates(CountedLoopNode* main_loop_head);\n+  void update_main_loop_assertion_predicates(CountedLoopNode* new_main_loop_head, int stride_con_before_unroll);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -857,1 +857,1 @@\n-    if (phi == nullptr || _igvn.type(phi) == Type::TOP) {\n+    if (phi == nullptr || _igvn.type(phi) == Type::TOP || !CMoveNode::supported(_igvn.type(phi))) {\n@@ -4667,1 +4667,1 @@\n-\/\/ Just before insert_pre_post_loops, we can multi-version the loop:\n+\/\/ Just before insert_pre_post_loops, we can multiversion the loop:\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3683,14 +3683,202 @@\n-\/\/ (StoreB ... (RShiftI _ (LShiftI _ valIn conIL ) conIR) )\n-\/\/ If (conIL == conIR && conIR <= num_bits)  this simplifies to\n-\/\/ (StoreB ... (valIn) )\n-Node *StoreNode::Ideal_sign_extended_input(PhaseGVN *phase, int num_bits) {\n-  Node *val = in(MemNode::ValueIn);\n-  if( val->Opcode() == Op_RShiftI ) {\n-    const TypeInt *t = phase->type( val->in(2) )->isa_int();\n-    if( t && t->is_con() && (t->get_con() <= num_bits) ) {\n-      Node *shl = val->in(1);\n-      if( shl->Opcode() == Op_LShiftI ) {\n-        const TypeInt *t2 = phase->type( shl->in(2) )->isa_int();\n-        if( t2 && t2->is_con() && (t2->get_con() == t->get_con()) ) {\n-          set_req_X(MemNode::ValueIn, shl->in(1), phase);\n-          return this;\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ v conIL) conIR))\n+\/\/ If (conIL == conIR && conIR <= num_rejected_bits) this simplifies to\n+\/\/ (StoreB ... (v))\n+\/\/ If (conIL > conIR) under some conditions, it can be simplified into\n+\/\/ (StoreB ... (LShiftI _ v (conIL - conIR)))\n+\/\/ This case happens when the value of the store was itself a left shift, that\n+\/\/ gets merged into the inner left shift of the sign-extension. For instance,\n+\/\/ if we have\n+\/\/ array_of_shorts[0] = (short)(v << 2)\n+\/\/ We get a structure such as:\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ (LShiftI _ v 2) 16) 16))\n+\/\/ that is simplified into\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ v 18) 16)).\n+\/\/ It is thus useful to handle cases where conIL > conIR. But this simplification\n+\/\/ does not always hold. Let's see in which cases it's valid.\n+\/\/\n+\/\/ Let's assume we have the following 32 bits integer v:\n+\/\/ +----------------------------------+\n+\/\/ |             v[0..31]             |\n+\/\/ +----------------------------------+\n+\/\/  31                               0\n+\/\/ that will be stuffed in 8 bits byte after a shift left and a shift right of\n+\/\/ potentially different magnitudes.\n+\/\/ We denote num_rejected_bits the number of bits of the discarded part. In this\n+\/\/ case, num_rejected_bits == 24.\n+\/\/\n+\/\/ Statement (proved further below in case analysis):\n+\/\/   Given:\n+\/\/   - 0 <= conIL < BitsPerJavaInteger   (no wrap in shift, enforced by maskShiftAmount)\n+\/\/   - 0 <= conIR < BitsPerJavaInteger   (no wrap in shift, enforced by maskShiftAmount)\n+\/\/   - conIL >= conIR\n+\/\/   - num_rejected_bits >= conIR\n+\/\/   Then this form:\n+\/\/      (RShiftI _ (LShiftI _ v conIL) conIR)\n+\/\/   can be replaced with this form:\n+\/\/      (LShiftI _ v (conIL-conIR))\n+\/\/\n+\/\/ Note: We only have to show that the non-rejected lowest bits (8 bits for byte)\n+\/\/       have to be correct, as the higher bits are rejected \/ truncated by the store.\n+\/\/\n+\/\/ The hypotheses\n+\/\/   0 <= conIL < BitsPerJavaInteger\n+\/\/   0 <= conIR < BitsPerJavaInteger\n+\/\/ are ensured by maskShiftAmount (called from ::Ideal of shift nodes). Indeed,\n+\/\/ (v << 31) << 2 must be simplified into 0, not into v << 33 (which is equivalent\n+\/\/ to v << 1).\n+\/\/\n+\/\/\n+\/\/ If you don't like case analysis, jump after the conclusion.\n+\/\/ ### Case 1 : conIL == conIR\n+\/\/ ###### Case 1.1: conIL == conIR == num_rejected_bits\n+\/\/ If we do the shift left then right by 24 bits, we get:\n+\/\/ after: v << 24\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..7] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     24 23                      0\n+\/\/ after: (v << 24) >> 24\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..7] |\n+\/\/ +------------------------+---------+\n+\/\/  31                     8 7        0\n+\/\/ The non-rejected bits (bits kept by the store, that is the 8 lower bits of the\n+\/\/ result) are the same before and after, so, indeed, simplifying is correct.\n+\n+\/\/ ###### Case 1.2: conIL == conIR < num_rejected_bits\n+\/\/ If we do the shift left then right by 22 bits, we get:\n+\/\/ after: v << 22\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..9] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     22 21                      0\n+\/\/ after: (v << 22) >> 22\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..9] |\n+\/\/ +------------------------+---------+\n+\/\/  31                    10 9        0\n+\/\/ The non-rejected bits are the 8 lower bits of v. The bits 8 and 9 of v are still\n+\/\/ present in (v << 22) >> 22 but will be dropped by the store. The simplification is\n+\/\/ still correct.\n+\n+\/\/ ###### But! Case 1.3: conIL == conIR > num_rejected_bits\n+\/\/ If we do the shift left then right by 26 bits, we get:\n+\/\/ after: v << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after: (v << 26) >> 26\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..5] |\n+\/\/ +------------------------+---------+\n+\/\/  31                     6 5        0\n+\/\/ The non-rejected bits are made of\n+\/\/ - 0-5 => the bits 0 to 5 of v\n+\/\/ - 6-7 => the sign bit of v[0..5] (that is v[5])\n+\/\/ Simplifying this as v is not correct.\n+\/\/ The condition conIR <= num_rejected_bits is indeed necessary in Case 1\n+\/\/\n+\/\/ ### Case 2: conIL > conIR\n+\/\/ ###### Case 2.1: num_rejected_bits == conIR\n+\/\/ We take conIL == 26 for this example.\n+\/\/ after: v << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after: (v << 26) >> 24\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..5] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31               8 7       2 1   0\n+\/\/ The non-rejected bits are the 8 lower ones of (v << conIL - conIR).\n+\/\/ The bits 6 and 7 of v have been thrown away after the shift left.\n+\/\/ The simplification is still correct.\n+\/\/\n+\/\/ ###### Case 2.2: num_rejected_bits > conIR.\n+\/\/ Let's say conIL == 26 and conIR == 22.\n+\/\/ after: v << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after: (v << 26) >> 22\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..5] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31              10 9       4 3   0\n+\/\/ The bits non-rejected by the store are exactly the 8 lower ones of (v << (conIL - conIR)):\n+\/\/ - 0-3 => 0\n+\/\/ - 4-7 => bits 0 to 3 of v\n+\/\/ The simplification is still correct.\n+\/\/ The bits 4 and 5 of v are still present in (v << (conIL - conIR)) but they don't\n+\/\/ matter as they are not in the 8 lower bits: they will be cut out by the store.\n+\/\/\n+\/\/ ###### But! Case 2.3: num_rejected_bits < conIR.\n+\/\/ Let's see that this case is not as easy to simplify.\n+\/\/ Let's say conIL == 28 and conIR == 26.\n+\/\/ after: v << 28\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..3] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     28 27                      0\n+\/\/ after: (v << 28) >> 26\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..3] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31               6 5       2 1   0\n+\/\/ The non-rejected bits are made of\n+\/\/ - 0-1 => 0\n+\/\/ - 2-5 => the bits 0 to 3 of v\n+\/\/ - 6-7 => the sign bit of v[0..3] (that is v[3])\n+\/\/ Simplifying this as (v << 2) is not correct.\n+\/\/ The condition conIR <= num_rejected_bits is indeed necessary in Case 2.\n+\/\/\n+\/\/ ### Conclusion:\n+\/\/ Our hypotheses are indeed sufficient:\n+\/\/   - 0 <= conIL < BitsPerJavaInteger\n+\/\/   - 0 <= conIR < BitsPerJavaInteger\n+\/\/   - conIL >= conIR\n+\/\/   - num_rejected_bits >= conIR\n+\/\/\n+\/\/ ### A rationale without case analysis:\n+\/\/ After the shift left, conIL upper  bits of v are discarded and conIL lower bit\n+\/\/ zeroes are added. After the shift right, conIR lower bits of the previous result\n+\/\/ are discarded. If conIL >= conIR, we discard only the zeroes we made up during\n+\/\/ the shift left, but if conIL < conIR, then we discard also lower bits of v. But\n+\/\/ the point of the simplification is to get an expression of the form\n+\/\/ (v << (conIL - conIR)). This expression discard only higher bits of v, thus the\n+\/\/ simplification is not correct if conIL < conIR.\n+\/\/\n+\/\/ Moreover, after the shift right, the higher bit of (v << conIL) is repeated on the\n+\/\/ conIR higher bits of ((v << conIL) >> conIR), it's the sign-extension. If\n+\/\/ conIR > num_rejected_bits, then at least one artificial copy of this sign bit will\n+\/\/ be in the window of the store. Thus ((v << conIL) >> conIR) is not equivalent to\n+\/\/ (v << (conIL-conIR)) if conIR > num_rejected_bits.\n+\/\/\n+\/\/ We do not treat the case conIL < conIR here since the point of this function is\n+\/\/ to skip sign-extensions (that is conIL == conIR == num_rejected_bits). The need\n+\/\/ of treating conIL > conIR comes from the cases where the sign-extended value is\n+\/\/ also left-shift expression. Computing the sign-extension of a right-shift expression\n+\/\/ doesn't yield a situation such as\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ v conIL) conIR))\n+\/\/ where conIL < conIR.\n+Node* StoreNode::Ideal_sign_extended_input(PhaseGVN* phase, int num_rejected_bits) {\n+  Node* shr = in(MemNode::ValueIn);\n+  if (shr->Opcode() == Op_RShiftI) {\n+    const TypeInt* conIR = phase->type(shr->in(2))->isa_int();\n+    if (conIR != nullptr && conIR->is_con() && conIR->get_con() >= 0 && conIR->get_con() < BitsPerJavaInteger && conIR->get_con() <= num_rejected_bits) {\n+      Node* shl = shr->in(1);\n+      if (shl->Opcode() == Op_LShiftI) {\n+        const TypeInt* conIL = phase->type(shl->in(2))->isa_int();\n+        if (conIL != nullptr && conIL->is_con() && conIL->get_con() >= 0 && conIL->get_con() < BitsPerJavaInteger) {\n+          if (conIL->get_con() == conIR->get_con()) {\n+            set_req_X(MemNode::ValueIn, shl->in(1), phase);\n+            return this;\n+          }\n+          if (conIL->get_con() > conIR->get_con()) {\n+            Node* new_shl = phase->transform(new LShiftINode(shl->in(1), phase->intcon(conIL->get_con() - conIR->get_con())));\n+            set_req_X(MemNode::ValueIn, new_shl, phase);\n+            return this;\n+          }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":202,"deletions":14,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -586,1 +586,1 @@\n-  Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);\n+  Node* Ideal_sign_extended_input(PhaseGVN* phase, int num_rejected_bits);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,0 +240,12 @@\n+MulNode* MulNode::make_and(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new AndINode(in1, in2);\n+    case T_LONG:\n+      return new AndLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return nullptr;\n+}\n+\n@@ -1005,1 +1017,1 @@\n-static int maskShiftAmount(PhaseGVN* phase, Node* shiftNode, int nBits) {\n+static int maskShiftAmount(PhaseGVN* phase, Node* shiftNode, uint nBits) {\n@@ -1026,0 +1038,37 @@\n+\/\/ Called with\n+\/\/    outer_shift = (_ << con0)\n+\/\/ We are looking for the pattern:\n+\/\/   outer_shift = ((X << con1) << con0)\n+\/\/   we denote inner_shift the nested expression (X << con1)\n+\/\/\n+\/\/ con0 and con1 are both in [0..nbits), as they are computed by maskShiftAmount.\n+\/\/\n+\/\/ There are 2 cases:\n+\/\/ if con0 + con1 >= nbits => 0\n+\/\/ if con0 + con1 < nbits => X << (con1 + con0)\n+static Node* collapse_nested_shift_left(PhaseGVN* phase, Node* outer_shift, int con0, BasicType bt) {\n+  assert(bt == T_LONG || bt == T_INT, \"Unexpected type\");\n+  int nbits = static_cast<int>(bits_per_java_integer(bt));\n+  Node* inner_shift = outer_shift->in(1);\n+  if (inner_shift->Opcode() != Op_LShift(bt)) {\n+    return nullptr;\n+  }\n+\n+  int con1 = maskShiftAmount(phase, inner_shift, nbits);\n+  if (con1 == 0) { \/\/ Either non-const, or actually 0 (up to mask) and then delegated to Identity()\n+    return nullptr;\n+  }\n+\n+  if (con0 + con1 >= nbits) {\n+    \/\/ While it might be tempting to use\n+    \/\/ phase->zerocon(bt);\n+    \/\/ it would be incorrect: zerocon caches nodes, while Ideal is only allowed\n+    \/\/ to return a new node, this or nullptr, but not an old (cached) node.\n+    return ConNode::make(TypeInteger::zero(bt));\n+  }\n+\n+  \/\/ con0 + con1 < nbits ==> actual shift happens now\n+  Node* con0_plus_con1 = phase->intcon(con0 + con1);\n+  return LShiftNode::make(inner_shift->in(1), con0_plus_con1, bt);\n+}\n+\n@@ -1039,0 +1088,3 @@\n+\/\/\n+\/\/ Also collapse nested left-shifts with constant rhs:\n+\/\/ (X << con1) << con2 ==> X << (con1 + con2)\n@@ -1151,0 +1203,7 @@\n+  \/\/ Performs:\n+  \/\/ (X << con1) << con2 ==> X << (con1 + con2)\n+  Node* doubleShift = collapse_nested_shift_left(phase, this, con, T_INT);\n+  if (doubleShift != nullptr) {\n+    return doubleShift;\n+  }\n+\n@@ -1215,0 +1274,3 @@\n+\/\/\n+\/\/ Also collapse nested left-shifts with constant rhs:\n+\/\/ (X << con1) << con2 ==> X << (con1 + con2)\n@@ -1327,0 +1389,7 @@\n+  \/\/ Performs:\n+  \/\/ (X << con1) << con2 ==> X << (con1 + con2)\n+  Node* doubleShift = collapse_nested_shift_left(phase, this, con, T_LONG);\n+  if (doubleShift != nullptr) {\n+    return doubleShift;\n+  }\n+\n@@ -1377,0 +1446,13 @@\n+RShiftNode* RShiftNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new RShiftINode(in1, in2);\n+    case T_LONG:\n+      return new RShiftLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return nullptr;\n+}\n+\n+\n@@ -1379,1 +1461,1 @@\n-Node* RShiftINode::Identity(PhaseGVN* phase) {\n+Node* RShiftNode::IdentityIL(PhaseGVN* phase, BasicType bt) {\n@@ -1382,2 +1464,2 @@\n-    if ((count & (BitsPerJavaInteger - 1)) == 0) {\n-      \/\/ Shift by a multiple of 32 does nothing\n+    if ((count & (bits_per_java_integer(bt) - 1)) == 0) {\n+      \/\/ Shift by a multiple of 32\/64 does nothing\n@@ -1387,1 +1469,1 @@\n-    if (in(1)->Opcode() == Op_LShiftI &&\n+    if (in(1)->Opcode() == Op_LShift(bt) &&\n@@ -1390,1 +1472,1 @@\n-      count &= BitsPerJavaInteger-1; \/\/ semantics of Java shifts\n+      count &= bits_per_java_integer(bt) - 1; \/\/ semantics of Java shifts\n@@ -1392,3 +1474,3 @@\n-      int lo = (-1 << (BitsPerJavaInteger - ((uint)count)-1)); \/\/ FFFF8000\n-      int hi = ~lo;               \/\/ 00007FFF\n-      const TypeInt* t11 = phase->type(in(1)->in(1))->isa_int();\n+      jlong lo = (CONST64(-1) << (bits_per_java_integer(bt) - ((uint)count)-1)); \/\/ FFFF8000\n+      jlong hi = ~lo;                                                            \/\/ 00007FFF\n+      const TypeInteger* t11 = phase->type(in(1)->in(1))->isa_integer(bt);\n@@ -1399,1 +1481,1 @@\n-      if (lo <= t11->_lo && t11->_hi <= hi) {\n+      if (lo <= t11->lo_as_long() && t11->hi_as_long() <= hi) {\n@@ -1407,2 +1489,5 @@\n-\/\/------------------------------Ideal------------------------------------------\n-Node *RShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* RShiftINode::Identity(PhaseGVN* phase) {\n+  return IdentityIL(phase, T_INT);\n+}\n+\n+Node* RShiftNode::IdealIL(PhaseGVN* phase, bool can_reshape, BasicType bt) {\n@@ -1410,4 +1495,5 @@\n-  const TypeInt *t1 = phase->type(in(1))->isa_int();\n-  if (!t1) return nullptr;        \/\/ Left input is an integer\n-  const TypeInt *t3;  \/\/ type of in(1).in(2)\n-  int shift = maskShiftAmount(phase, this, BitsPerJavaInteger);\n+  const TypeInteger* t1 = phase->type(in(1))->isa_integer(bt);\n+  if (t1 == nullptr) {\n+    return NodeSentinel;        \/\/ Left input is an integer\n+  }\n+  int shift = maskShiftAmount(phase, this, bits_per_java_integer(bt));\n@@ -1415,1 +1501,1 @@\n-    return nullptr;\n+    return NodeSentinel;\n@@ -1419,0 +1505,1 @@\n+  \/\/ and convert to (x >> 24) & (0xFF000000 >> 24) = x >> 24\n@@ -1420,6 +1507,7 @@\n-  const Node *mask = in(1);\n-  if( mask->Opcode() == Op_AndI &&\n-      (t3 = phase->type(mask->in(2))->isa_int()) &&\n-      t3->is_con() ) {\n-    Node *x = mask->in(1);\n-    jint maskbits = t3->get_con();\n+  const Node* and_node = in(1);\n+  if (and_node->Opcode() != Op_And(bt)) {\n+    return nullptr;\n+  }\n+  const TypeInteger* mask_t = phase->type(and_node->in(2))->isa_integer(bt);\n+  if (mask_t != nullptr && mask_t->is_con()) {\n+    jlong maskbits = mask_t->get_con_as_long(bt);\n@@ -1427,2 +1515,2 @@\n-    Node *shr_nomask = phase->transform( new RShiftINode(mask->in(1), in(2)) );\n-    return new AndINode(shr_nomask, phase->intcon( maskbits >> shift));\n+    Node* shr_nomask = phase->transform(RShiftNode::make(and_node->in(1), in(2), bt));\n+    return MulNode::make_and(shr_nomask, phase->integercon(maskbits >> shift, bt), bt);\n@@ -1430,0 +1518,13 @@\n+  return nullptr;\n+}\n+\n+Node* RShiftINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* progress = IdealIL(phase, can_reshape, T_INT);\n+  if (progress == NodeSentinel) {\n+    return nullptr;\n+  }\n+  if (progress != nullptr) {\n+    return progress;\n+  }\n+  int shift = maskShiftAmount(phase, this, BitsPerJavaInteger);\n+  assert(shift != 0, \"handled by IdealIL\");\n@@ -1433,1 +1534,3 @@\n-  if( shl->Opcode() != Op_LShiftI ) return nullptr;\n+  if (shl->Opcode() != Op_LShiftI) {\n+    return nullptr;\n+  }\n@@ -1435,3 +1538,5 @@\n-  if( shift == 16 &&\n-      (t3 = phase->type(shl->in(2))->isa_int()) &&\n-      t3->is_con(16) ) {\n+  const TypeInt* left_shift_t = phase->type(shl->in(2))->isa_int();\n+  if (left_shift_t == nullptr) {\n+    return nullptr;\n+  }\n+  if (shift == 16 && left_shift_t->is_con(16)) {\n@@ -1439,1 +1544,1 @@\n-    if( ld->Opcode() == Op_LoadS ) {\n+    if (ld->Opcode() == Op_LoadS) {\n@@ -1457,3 +1562,1 @@\n-  if( shift == 24 &&\n-      (t3 = phase->type(shl->in(2))->isa_int()) &&\n-      t3->is_con(24) ) {\n+  if (shift == 24 && left_shift_t->is_con(24)) {\n@@ -1472,5 +1575,3 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A RShiftINode shifts its input2 right by input1 amount.\n-const Type* RShiftINode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n+const Type* RShiftNode::ValueIL(PhaseGVN* phase, BasicType bt) const {\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n@@ -1478,2 +1579,6 @@\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  if (t1 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  if (t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -1482,1 +1587,3 @@\n-  if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;\n+  if (t1 == TypeInteger::zero(bt)) {\n+    return TypeInteger::zero(bt);\n+  }\n@@ -1484,1 +1591,3 @@\n-  if( t2 == TypeInt::ZERO ) return t1;\n+  if (t2 == TypeInt::ZERO) {\n+    return t1;\n+  }\n@@ -1487,2 +1596,3 @@\n-  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)\n-    return TypeInt::INT;\n+  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM) {\n+    return TypeInteger::bottom(bt);\n+  }\n@@ -1490,2 +1600,2 @@\n-  const TypeInt *r1 = t1->is_int(); \/\/ Handy access\n-  const TypeInt *r2 = t2->is_int(); \/\/ Handy access\n+  const TypeInteger* r1 = t1->isa_integer(bt);\n+  const TypeInt* r2 = t2->isa_int();\n@@ -1494,1 +1604,1 @@\n-  \/\/ For example, if the shift is 31, we just propagate sign bits.\n+  \/\/ For example, if the shift is 31\/63, we just propagate sign bits.\n@@ -1497,3 +1607,5 @@\n-    shift &= BitsPerJavaInteger-1;  \/\/ semantics of Java shifts\n-    \/\/ Shift by a multiple of 32 does nothing:\n-    if (shift == 0)  return t1;\n+    shift &= bits_per_java_integer(bt) - 1;  \/\/ semantics of Java shifts\n+    \/\/ Shift by a multiple of 32\/64 does nothing:\n+    if (shift == 0) {\n+      return t1;\n+    }\n@@ -1503,2 +1615,2 @@\n-    jint lo = (jint)r1->_lo >> (jint)shift;\n-    jint hi = (jint)r1->_hi >> (jint)shift;\n+    jlong lo = r1->lo_as_long() >> (jint)shift;\n+    jlong hi = r1->hi_as_long() >> (jint)shift;\n@@ -1506,1 +1618,8 @@\n-    const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n+#ifdef ASSERT\n+   if (bt == T_INT) {\n+     jint lo_verify = checked_cast<jint>(r1->lo_as_long()) >> (jint)shift;\n+     jint hi_verify = checked_cast<jint>(r1->hi_as_long()) >> (jint)shift;\n+     assert((checked_cast<jint>(lo) == lo_verify) && (checked_cast<jint>(hi) == hi_verify), \"inconsistent\");\n+   }\n+#endif\n+    const TypeInteger* ti = TypeInteger::make(lo, hi, MAX2(r1->_widen,r2->_widen), bt);\n@@ -1509,3 +1628,7 @@\n-    if (shift == BitsPerJavaInteger-1) {\n-      if (r1->_lo >= 0) assert(ti == TypeInt::ZERO,    \">>31 of + is  0\");\n-      if (r1->_hi <  0) assert(ti == TypeInt::MINUS_1, \">>31 of - is -1\");\n+    if (shift == bits_per_java_integer(bt) - 1) {\n+      if (r1->lo_as_long() >= 0) {\n+        assert(ti == TypeInteger::zero(bt),    \">>31\/63 of + is  0\");\n+      }\n+      if (r1->hi_as_long() <  0) {\n+        assert(ti == TypeInteger::minus_1(bt), \">>31\/63 of - is -1\");\n+      }\n@@ -1519,2 +1642,2 @@\n-    if (r1->_lo >= 0) {\n-      return TypeInt::make(0, r1->_hi, MAX2(r1->_widen, r2->_widen));\n+    if (r1->lo_as_long() >= 0) {\n+      return TypeInteger::make(0, r1->hi_as_long(), MAX2(r1->_widen, r2->_widen), bt);\n@@ -1524,2 +1647,2 @@\n-    if (r1->_hi <= -1) {\n-      return TypeInt::make(r1->_lo, -1, MAX2(r1->_widen, r2->_widen));\n+    if (r1->hi_as_long() <= -1) {\n+      return TypeInteger::make(r1->lo_as_long(), -1, MAX2(r1->_widen, r2->_widen), bt);\n@@ -1528,1 +1651,1 @@\n-    return TypeInt::INT;\n+    return TypeInteger::bottom(bt);\n@@ -1532,1 +1655,5 @@\n-  return TypeInt::make(r1->get_con() >> (r2->get_con() & 31));\n+  return TypeInteger::make(r1->get_con_as_long(bt) >> (r2->get_con() & (bits_per_java_integer(bt) - 1)), bt);\n+}\n+\n+const Type* RShiftINode::Value(PhaseGVN* phase) const {\n+  return ValueIL(phase, T_INT);\n@@ -1538,2 +1665,1 @@\n-  const TypeInt *ti = phase->type(in(2))->isa_int(); \/\/ Shift count is an int.\n-  return (ti && ti->is_con() && (ti->get_con() & (BitsPerJavaLong - 1)) == 0) ? in(1) : this;\n+  return IdentityIL(phase, T_LONG);\n@@ -1542,57 +1668,4 @@\n-\/\/------------------------------Value------------------------------------------\n-\/\/ A RShiftLNode shifts its input2 right by input1 amount.\n-const Type* RShiftLNode::Value(PhaseGVN* phase) const {\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Either input is TOP ==> the result is TOP\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ Left input is ZERO ==> the result is ZERO.\n-  if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;\n-  \/\/ Shift by zero does nothing\n-  if( t2 == TypeInt::ZERO ) return t1;\n-\n-  \/\/ Either input is BOTTOM ==> the result is BOTTOM\n-  if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)\n-    return TypeLong::LONG;\n-\n-  const TypeLong *r1 = t1->is_long(); \/\/ Handy access\n-  const TypeInt  *r2 = t2->is_int (); \/\/ Handy access\n-\n-  \/\/ If the shift is a constant, just shift the bounds of the type.\n-  \/\/ For example, if the shift is 63, we just propagate sign bits.\n-  if (!r1->is_con() && r2->is_con()) {\n-    uint shift = r2->get_con();\n-    shift &= (2*BitsPerJavaInteger)-1;  \/\/ semantics of Java shifts\n-    \/\/ Shift by a multiple of 64 does nothing:\n-    if (shift == 0)  return t1;\n-    \/\/ Calculate reasonably aggressive bounds for the result.\n-    \/\/ This is necessary if we are to correctly type things\n-    \/\/ like (x<<24>>24) == ((byte)x).\n-    jlong lo = (jlong)r1->_lo >> (jlong)shift;\n-    jlong hi = (jlong)r1->_hi >> (jlong)shift;\n-    assert(lo <= hi, \"must have valid bounds\");\n-    const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1->_widen,r2->_widen));\n-    #ifdef ASSERT\n-    \/\/ Make sure we get the sign-capture idiom correct.\n-    if (shift == (2*BitsPerJavaInteger)-1) {\n-      if (r1->_lo >= 0) assert(tl == TypeLong::ZERO,    \">>63 of + is 0\");\n-      if (r1->_hi < 0)  assert(tl == TypeLong::MINUS_1, \">>63 of - is -1\");\n-    }\n-    #endif\n-    return tl;\n-  }\n-\n-  if (!r1->is_con() || !r2->is_con()) {\n-    \/\/ If the left input is non-negative the result must also be non-negative, regardless of what the right input is.\n-    if (r1->_lo >= 0) {\n-      return TypeLong::make(0, r1->_hi, MAX2(r1->_widen, r2->_widen));\n-    }\n-\n-    \/\/ Conversely, if the left input is negative then the result must be negative.\n-    if (r1->_hi <= -1) {\n-      return TypeLong::make(r1->_lo, -1, MAX2(r1->_widen, r2->_widen));\n-    }\n-\n-    return TypeLong::LONG;\n+Node* RShiftLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  Node* progress = IdealIL(phase, can_reshape, T_LONG);\n+  if (progress == NodeSentinel) {\n+    return nullptr;\n@@ -1600,0 +1673,2 @@\n+  return progress;\n+}\n@@ -1601,1 +1676,2 @@\n-  return TypeLong::make(r1->get_con() >> (r2->get_con() & 63));\n+const Type* RShiftLNode::Value(PhaseGVN* phase) const {\n+  return ValueIL(phase, T_LONG);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":198,"deletions":122,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -1762,1 +1762,1 @@\n-  bool member( Node *n ) { return _in_worklist.test(n->_idx) != 0; }\n+  bool member(const Node* n) const { return _in_worklist.test(n->_idx) != 0; }\n@@ -2081,0 +2081,1 @@\n+Op_IL(And)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3587,0 +3587,1 @@\n+                                                      false,\n@@ -3588,2 +3589,6 @@\n-      assert(rs != nullptr && rs->is_runtime_stub(), \"sanity check\");\n-      C->set_stub_entry_point(rs->entry_point());\n+      if (rs == nullptr) {\n+        C->record_failure(\"CodeCache is full\");\n+      } else {\n+        assert(rs->is_runtime_stub(), \"sanity check\");\n+        C->set_stub_entry_point(rs->entry_point());\n+      }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1646,1 +1646,1 @@\n-  if( use_op == Op_LShiftI ) {\n+  if (use_op == Op_LShiftI || use_op == Op_LShiftL) {\n@@ -1649,1 +1649,1 @@\n-      if (u->Opcode() == Op_RShiftI)\n+      if (u->Opcode() == Op_RShiftI || u->Opcode() == Op_RShiftL)\n@@ -2176,1 +2176,1 @@\n-  C->disconnect_useless_nodes(useful, _worklist);\n+  C->disconnect_useless_nodes(useful, _worklist, &_root_and_safepoints);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -137,1 +137,3 @@\n-  generate_ ## name ## _blob();\n+  BLOB_FIELD_NAME(name) =                       \\\n+    generate_ ## name ## _blob();                  \\\n+  if (BLOB_FIELD_NAME(name) == nullptr) { return false; }\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -261,2 +261,2 @@\n-  static void generate_uncommon_trap_blob(void);\n-  static void generate_exception_blob();\n+  static UncommonTrapBlob* generate_uncommon_trap_blob(void);\n+  static ExceptionBlob* generate_exception_blob();\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -408,3 +408,4 @@\n-    TemplateAssertionExpression template_assertion_expression(opaque_node);\n-    Node* new_ctrl = template_assertion_predicate->in(0);\n-    OpaqueTemplateAssertionPredicateNode* cloned_opaque_node = template_assertion_expression.clone(new_ctrl, this);\n+    TemplateAssertionExpression template_assertion_expression(opaque_node, this);\n+    Node* new_control = template_assertion_predicate->in(0);\n+    OpaqueTemplateAssertionPredicateNode* cloned_opaque_node = template_assertion_expression.clone(new_control,\n+                                                                                                   opaque_node->loop_node());\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,3 +57,7 @@\n-  \/\/ Remove double negation\n-  const Type *zero = add_id();\n-  if( phase->type( in(1) )->higher_equal( zero ) &&\n+  const Type* zero = add_id();\n+\n+  \/\/ Remove double negation if it is not a floating point number since negation\n+  \/\/ is not the same as subtraction for floating point numbers\n+  \/\/ (cf. JLS  15.15.4). `0-(0-(-0.0))` must be equal to positive 0.0 according to\n+  \/\/ JLS  15.8.2, but would result in -0.0 if this folding would be applied.\n+  if (phase->type(in(1))->higher_equal(zero) &&\n@@ -61,1 +65,2 @@\n-      phase->type( in(2)->in(1) )->higher_equal( zero ) ) {\n+      phase->type(in(2)->in(1))->higher_equal(zero) &&\n+      !phase->type(in(2)->in(2))->is_floatingpoint()) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1774,0 +1774,4 @@\n+const TypeInteger* TypeInteger::make(jlong con, BasicType bt) {\n+  return make(con, con, WidenMin, bt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -638,0 +638,1 @@\n+  static const TypeInteger* make(jlong con, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"cds\/lambdaProxyClassDictionary.hpp\"\n@@ -3600,1 +3602,0 @@\n-  assert(k->is_klass(), \"just checking\");\n@@ -3613,1 +3614,1 @@\n-  if (!CDSConfig::is_dumping_archive()) {\n+  if (!CDSConfig::is_dumping_archive() || !CDSConfig::is_dumping_lambdas_in_legacy_mode()) {\n@@ -3647,2 +3648,2 @@\n-  SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, interface_method_name, factory_type,\n-                                                 interface_method_type, m, dynamic_method_type, THREAD);\n+  LambdaProxyClassDictionary::add_lambda_proxy_class(caller_ik, lambda_ik, interface_method_name, factory_type,\n+                                                     interface_method_type, m, dynamic_method_type, THREAD);\n@@ -3687,8 +3688,5 @@\n-  InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, interface_method_name, factory_type,\n-                                                                                   interface_method_type, m, dynamic_method_type);\n-  jclass jcls = nullptr;\n-  if (lambda_ik != nullptr) {\n-    InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, THREAD);\n-    jcls = loaded_lambda == nullptr ? nullptr : (jclass) JNIHandles::make_local(THREAD, loaded_lambda->java_mirror());\n-  }\n-  return jcls;\n+  InstanceKlass* loaded_lambda =\n+    LambdaProxyClassDictionary::load_shared_lambda_proxy_class(caller_ik, interface_method_name, factory_type,\n+                                                               interface_method_type, m, dynamic_method_type,\n+                                                               CHECK_(nullptr));\n+  return loaded_lambda == nullptr ? nullptr : (jclass) JNIHandles::make_local(THREAD, loaded_lambda->java_mirror());\n@@ -3765,0 +3763,23 @@\n+JVM_ENTRY(jboolean, JVM_NeedsClassInitBarrierForCDS(JNIEnv* env, jclass cls))\n+#if INCLUDE_CDS\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));\n+  if (!k->is_instance_klass()) {\n+    return false;\n+  } else {\n+    if (InstanceKlass::cast(k)->is_enum_subclass() ||\n+        AOTClassInitializer::can_archive_initialized_mirror(InstanceKlass::cast(k))) {\n+      \/\/ This class will be cached in AOT-initialized state. No need for init barriers.\n+      return false;\n+    } else {\n+      \/\/ If we cannot cache the class in AOT-initialized state, java.lang.invoke handles\n+      \/\/ must emit barriers to ensure class initialization during production run.\n+      ResourceMark rm(THREAD);\n+      log_debug(cds)(\"NeedsClassInitBarrierForCDS: %s\", k->external_name());\n+      return true;\n+    }\n+  }\n+#else\n+  return false;\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -943,1 +943,1 @@\n-      err = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true, nullptr);\n+      err = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true);\n@@ -950,1 +950,1 @@\n-  err = suspend_thread(self_tobj(), current, \/* single_suspend *\/ true, nullptr);\n+  err = suspend_thread(self_tobj(), current, \/* single_suspend *\/ true);\n@@ -991,1 +991,1 @@\n-      results[i] = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true, nullptr);\n+      results[i] = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true);\n@@ -998,1 +998,1 @@\n-    results[self_idx] = suspend_thread(self_tobj(), current, \/* single_suspend *\/ true, nullptr);\n+    results[self_idx] = suspend_thread(self_tobj(), current, \/* single_suspend *\/ true);\n@@ -1051,1 +1051,1 @@\n-        suspend_thread(vt_oop, java_thread, \/* single_suspend *\/ false, nullptr);\n+        suspend_thread(vt_oop, java_thread, \/* single_suspend *\/ false);\n@@ -1068,1 +1068,1 @@\n-    suspend_thread(self_tobj(), current, \/* single_suspend *\/ false, nullptr);\n+    suspend_thread(self_tobj(), current, \/* single_suspend *\/ false);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3896,1 +3896,2 @@\n-      LogConfiguration::configure_stdout(LogLevel::Off, false, LOG_TAGS(perf, class, link));\n+      LogConfiguration::disable_tags(false, LOG_TAGS(perf, class, link));\n+      assert(!log_is_enabled(Info, perf, class, link), \"sanity\");\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -391,2 +391,3 @@\n-        bool skip_internal = (compiled_method != nullptr) && !compiled_method->is_compiled_by_jvmci();\n-        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal, CHECK_AND_CLEAR_(true));\n+        guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n+        bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci, CHECK_AND_CLEAR_(true));\n@@ -403,2 +404,3 @@\n-        bool skip_internal = (compiled_method != nullptr) && !compiled_method->is_compiled_by_jvmci();\n-        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal, THREAD);\n+        guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n+        bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci, THREAD);\n@@ -1520,18 +1522,17 @@\n-\/\/ Restore fields of an eliminated instance object using the same field order\n-\/\/ returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)\n-static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal, int base_offset, GrowableArray<int>* null_marker_offsets, TRAPS) {\n-  GrowableArray<ReassignedField>* fields = new GrowableArray<ReassignedField>();\n-  InstanceKlass* ik = klass;\n-  while (ik != nullptr) {\n-    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n-      if (!fs.access_flags().is_static() && (!skip_internal || !fs.field_flags().is_injected())) {\n-        ReassignedField field;\n-        field._offset = fs.offset();\n-        field._type = Signature::basic_type(fs.signature());\n-        if (fs.is_flat()) {\n-          field._is_flat = true;\n-          field._is_null_free = fs.is_null_free_inline_type();\n-          \/\/ Resolve klass of flat inline type field\n-          field._klass = InlineKlass::cast(klass->get_inline_type_field_klass(fs.index()));\n-        }\n-        fields->append(field);\n+\n+\/\/ Gets the fields of `klass` that are eliminated by escape analysis and need to be reassigned\n+static GrowableArray<ReassignedField>* get_reassigned_fields(InstanceKlass* klass, GrowableArray<ReassignedField>* fields, bool is_jvmci) {\n+  InstanceKlass* super = klass->superklass();\n+  if (super != nullptr) {\n+    get_reassigned_fields(super, fields, is_jvmci);\n+  }\n+  for (AllFieldStream fs(klass); !fs.done(); fs.next()) {\n+    if (!fs.access_flags().is_static() && (is_jvmci || !fs.field_flags().is_injected())) {\n+      ReassignedField field;\n+      field._offset = fs.offset();\n+      field._type = Signature::basic_type(fs.signature());\n+      if (fs.is_flat()) {\n+        field._is_flat = true;\n+        field._is_null_free = fs.is_null_free_inline_type();\n+        \/\/ Resolve klass of flat inline type field\n+        field._klass = InlineKlass::cast(klass->get_inline_type_field_klass(fs.index()));\n@@ -1539,0 +1540,1 @@\n+      fields->append(field);\n@@ -1540,1 +1542,6 @@\n-    ik = ik->superklass();\n+  return fields;\n+}\n+\n+\/\/ Restore fields of an eliminated instance object employing the same field order used by the compiler.\n+static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci, int base_offset, GrowableArray<int>* null_marker_offsets, TRAPS) {\n+  GrowableArray<ReassignedField>* fields = get_reassigned_fields(klass, new GrowableArray<ReassignedField>(), is_jvmci);\n@@ -1542,0 +1549,1 @@\n+\n@@ -1548,0 +1556,1 @@\n+\n@@ -1558,1 +1567,1 @@\n-      svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, skip_internal, offset, null_marker_offsets, CHECK_0);\n+      svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, is_jvmci, offset, null_marker_offsets, CHECK_0);\n@@ -1653,1 +1662,1 @@\n-void Deoptimization::reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, bool skip_internal, TRAPS) {\n+void Deoptimization::reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, bool is_jvmci, TRAPS) {\n@@ -1662,1 +1671,1 @@\n-    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, skip_internal, offset, nullptr, CHECK);\n+    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, is_jvmci, offset, nullptr, CHECK);\n@@ -1667,1 +1676,1 @@\n-void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal, TRAPS) {\n+void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool is_jvmci, TRAPS) {\n@@ -1711,1 +1720,1 @@\n-      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal, 0, nullptr, CHECK);\n+      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci, 0, nullptr, CHECK);\n@@ -1714,1 +1723,1 @@\n-      reassign_flat_array_elements(fr, reg_map, sv, (flatArrayOop) obj(), vak, skip_internal, CHECK);\n+      reassign_flat_array_elements(fr, reg_map, sv, (flatArrayOop) obj(), vak, is_jvmci, CHECK);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":38,"deletions":29,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-#include \"runtime\/perfData.hpp\"\n@@ -396,1 +395,0 @@\n-      int free_count = 0;\n@@ -399,2 +397,0 @@\n-        ++free_count;\n-      OM_PERFDATA_OP(Notifications, inc(free_count));\n@@ -1647,3 +1643,0 @@\n-      \/\/ Hopefully the performance counters are allocated on distinct cache lines\n-      \/\/ to avoid false sharing on MP systems ...\n-      OM_PERFDATA_OP(Inflations, inc());\n@@ -1689,3 +1682,0 @@\n-    \/\/ Hopefully the performance counters are allocated on distinct\n-    \/\/ cache lines to avoid false sharing on MP systems ...\n-    OM_PERFDATA_OP(Inflations, inc());\n@@ -1919,3 +1909,0 @@\n-  OM_PERFDATA_OP(MonExtant, set_value(_in_use_list.count()));\n-  OM_PERFDATA_OP(Deflations, inc(deflated_count));\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -811,0 +811,8 @@\n+inline uint bits_per_java_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return BitsPerJavaInteger;\n+  }\n+  assert(bt == T_LONG, \"int or long only\");\n+  return BitsPerJavaLong;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n- * ClassFile.AttributeMapperOption#of(Function)}}\n+ * ClassFile.AttributeMapperOption#of(Function)}\n@@ -188,1 +188,1 @@\n- *   <li>{@link ClassFile.ConstantPoolSharingOption}}\n+ *   <li>{@link ClassFile.ConstantPoolSharingOption}\n@@ -190,1 +190,1 @@\n- *   <li>{@link ClassFile.DeadCodeOption}}\n+ *   <li>{@link ClassFile.DeadCodeOption}\n@@ -192,1 +192,1 @@\n- *   <li>{@link ClassFile.DeadLabelsOption}}\n+ *   <li>{@link ClassFile.DeadLabelsOption}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.CDS;\n@@ -370,1 +371,1 @@\n-            return false;\n+            return CDS.needsClassInitBarrier(cls);\n@@ -372,1 +373,1 @@\n-        return UNSAFE.shouldBeInitialized(cls);\n+        return UNSAFE.shouldBeInitialized(cls) || CDS.needsClassInitBarrier(cls);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.CDS;\n@@ -134,1 +135,1 @@\n-            return maybeAdapt(UNSAFE.shouldBeInitialized(decl)\n+            return maybeAdapt((UNSAFE.shouldBeInitialized(decl) || CDS.needsClassInitBarrier(decl))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -106,0 +106,2 @@\n+import jdk.internal.util.DateTimeHelper;\n+\n@@ -2159,1 +2161,1 @@\n-        formatTo(buf);\n+        DateTimeHelper.formatTo(buf, this);\n@@ -2163,27 +2165,0 @@\n-    \/**\n-     * Prints the toString result to the given buf, avoiding extra string allocations.\n-     * Requires extra capacity of 10 to avoid StringBuilder reallocation.\n-     *\/\n-    void formatTo(StringBuilder buf) {\n-        int yearValue = year;\n-        int monthValue = month;\n-        int dayValue = day;\n-        int absYear = Math.abs(yearValue);\n-        if (absYear < 1000) {\n-            if (yearValue < 0) {\n-                buf.append('-');\n-            }\n-            buf.repeat('0', absYear < 10 ? 3 : absYear < 100 ? 2 : 1);\n-            buf.append(absYear);\n-        } else {\n-            if (yearValue > 9999) {\n-                buf.append('+');\n-            }\n-            buf.append(yearValue);\n-        }\n-        buf.append(monthValue < 10 ? \"-0\" : \"-\")\n-           .append(monthValue)\n-           .append(dayValue < 10 ? \"-0\" : \"-\")\n-           .append(dayValue);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+import jdk.internal.util.DateTimeHelper;\n+\n@@ -1977,1 +1979,1 @@\n-        formatTo(buf);\n+        DateTimeHelper.formatTo(buf, this);\n@@ -1981,8 +1983,0 @@\n-    \/**\n-     * Prints the toString result to the given buf, avoiding extra string allocations.\n-     *\/\n-    void formatTo(StringBuilder buf) {\n-        date.formatTo(buf);\n-        buf.append('T');\n-        time.formatTo(buf);\n-    }\n@@ -2029,1 +2023,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-import jdk.internal.util.DecimalDigits;\n+import jdk.internal.util.DateTimeHelper;\n@@ -1643,1 +1643,1 @@\n-        formatTo(buf);\n+        DateTimeHelper.formatTo(buf, this);\n@@ -1647,32 +1647,0 @@\n-    \/**\n-     * Prints the toString result to the given buf, avoiding extra string allocations.\n-     * Requires extra capacity of 18 to avoid StringBuilder reallocation.\n-     *\/\n-    void formatTo(StringBuilder buf) {\n-        int hourValue = hour;\n-        int minuteValue = minute;\n-        int secondValue = second;\n-        int nanoValue = nano;\n-        buf.append(hourValue < 10 ? \"0\" : \"\").append(hourValue)\n-            .append(minuteValue < 10 ? \":0\" : \":\").append(minuteValue);\n-        if (secondValue > 0 || nanoValue > 0) {\n-            buf.append(secondValue < 10 ? \":0\" : \":\").append(secondValue);\n-            if (nanoValue > 0) {\n-                buf.append('.');\n-                int zeros = 9 - DecimalDigits.stringSize(nanoValue);\n-                if (zeros > 0) {\n-                    buf.repeat('0', zeros);\n-                }\n-                int digits;\n-                if (nanoValue % 1_000_000 == 0) {\n-                    digits = nanoValue \/ 1_000_000;\n-                } else if (nanoValue % 1000 == 0) {\n-                    digits = nanoValue \/ 1000;\n-                } else {\n-                    digits = nanoValue;\n-                }\n-                buf.append(digits);\n-            }\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalTime.java","additions":2,"deletions":34,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -96,0 +96,2 @@\n+import jdk.internal.util.DateTimeHelper;\n+\n@@ -1936,1 +1938,1 @@\n-        dateTime.formatTo(buf);\n+        DateTimeHelper.formatTo(buf, dateTime);\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,0 +95,2 @@\n+import jdk.internal.util.DateTimeHelper;\n+\n@@ -1411,1 +1413,1 @@\n-        time.formatTo(buf);\n+        DateTimeHelper.formatTo(buf, time);\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetTime.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+import jdk.internal.util.DateTimeHelper;\n+\n@@ -2233,1 +2235,1 @@\n-        dateTime.formatTo(buf);\n+        DateTimeHelper.formatTo(buf, dateTime);\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,1 @@\n+    private final boolean nullCheckOuterThis;\n@@ -138,0 +139,2 @@\n+        nullCheckOuterThis = options.getBoolean(\"nullCheckOuterThis\",\n+            target.nullCheckOuterThisByDefault());\n@@ -1807,1 +1810,4 @@\n-    \/** Return tree simulating the assignment {@code this.this$n = this$n}.\n+    \/**\n+     * Return tree simulating null checking outer this and\/or assigning. This is\n+     * called when a null check is required (nullCheckOuterThis), or a synthetic\n+     * field is generated (stores).\n@@ -1809,1 +1815,1 @@\n-    JCStatement initOuterThis(int pos, VarSymbol rhs) {\n+    JCStatement initOuterThis(int pos, VarSymbol rhs, boolean stores) {\n@@ -1811,2 +1817,1 @@\n-        VarSymbol lhs = outerThisStack.head;\n-        Assert.check(rhs.owner.owner == lhs.owner);\n+        Assert.check(nullCheckOuterThis || stores); \/\/ One of the flags must be true\n@@ -1814,3 +1819,8 @@\n-        return\n-            make.Exec(\n-                make.Assign(\n+        JCExpression expression = make.Ident(rhs);\n+        if (nullCheckOuterThis) {\n+            expression = attr.makeNullCheck(expression);\n+        }\n+        if (stores) {\n+            VarSymbol lhs = outerThisStack.head;\n+            Assert.check(rhs.owner.owner == lhs.owner);\n+            expression = make.Assign(\n@@ -1818,1 +1828,3 @@\n-                    make.Ident(rhs)).setType(lhs.erasure(types)));\n+                    expression).setType(lhs.erasure(types));\n+        }\n+        return make.Exec(expression);\n@@ -2225,3 +2237,10 @@\n-        if (currentClass.hasOuterInstance() && shouldEmitOuterThis(currentClass)) {\n-            tree.defs = tree.defs.prepend(otdef);\n-            enterSynthetic(tree.pos(), otdef.sym, currentClass.members());\n+        \/\/ otherwise prepend enclosing instance null check code if required\n+        emitOuter:\n+        if (currentClass.hasOuterInstance()) {\n+            boolean storesThis = shouldEmitOuterThis(currentClass);\n+            if (storesThis) {\n+                tree.defs = tree.defs.prepend(otdef);\n+                enterSynthetic(tree.pos(), otdef.sym, currentClass.members());\n+            } else if (!nullCheckOuterThis) {\n+                break emitOuter;\n+            }\n@@ -2233,1 +2252,1 @@\n-                        List<JCStatement> initializer = List.of(initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+                        List<JCStatement> initializer = List.of(initOuterThis(mdef.body.pos, mdef.params.head.sym, storesThis)) ;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -247,0 +247,7 @@\n+\n+    \/**\n+     * Should we emit a null check against incoming outer this argument by default?\n+     *\/\n+    public boolean nullCheckOuterThisByDefault() {\n+        return compareTo(JDK1_25) >= 0;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/VirtualObjectDebugInfoTest.java 8354366 generic-all\n@@ -73,2 +74,0 @@\n-compiler\/startup\/StartupOutput.java 8347406 generic-x64\n-\n@@ -85,0 +84,4 @@\n+compiler\/startup\/StartupOutput.java 8354404 generic-all\n+compiler\/types\/TestSubTypeCheckUniqueSubclass.java 8354408 generic-all\n+compiler\/valhalla\/inlinetypes\/TestAllocationMergeAndFolding.java 8354283 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+import java.util.ArrayList;\n@@ -75,0 +76,1 @@\n+import java.util.Collection;\n@@ -147,1 +149,1 @@\n-            Set<Field> reflectionFields = getInstanceFields(c, true);\n+            Set<Field> reflectionFields = Set.copyOf(getInstanceFields(c, true));\n@@ -878,1 +880,1 @@\n-    public static Set<Field> getInstanceFields(Class<?> c, boolean includeSuperclasses) {\n+    public static List<Field> getInstanceFields(Class<?> c, boolean includeSuperclasses) {\n@@ -880,1 +882,1 @@\n-            return Collections.emptySet();\n+            return List.of();\n@@ -882,1 +884,1 @@\n-        Set<Field> result = new HashSet<>();\n+        List<Field> result = new ArrayList<>();\n@@ -889,1 +891,3 @@\n-            result.addAll(getInstanceFields(c.getSuperclass(), true));\n+            List<Field> allFields = getInstanceFields(c.getSuperclass(), true);\n+            allFields.addAll(result);\n+            result = allFields;\n@@ -918,1 +922,1 @@\n-    public Field lookupField(Set<Field> fields, ResolvedJavaField key) {\n+    public Field lookupField(Collection<Field> fields, ResolvedJavaField key) {\n@@ -928,3 +932,0 @@\n-        if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Throwable.class)) && f.getName().equals(\"backtrace\")) {\n-            return true;\n-        }\n@@ -961,4 +962,12 @@\n-                Set<Field> expected = getInstanceFields(c, includeSuperclasses);\n-                ResolvedJavaField[] actual = type.getInstanceFields(includeSuperclasses);\n-                for (Field f : expected) {\n-                    assertNotNull(lookupField(actual, f));\n+                List<Field> reflectFields = getInstanceFields(c, includeSuperclasses);\n+                ResolvedJavaField[] fields = type.getInstanceFields(includeSuperclasses);\n+                int reflectFieldIndex = 0;\n+                for (int i = 0; i < fields.length; i++) {\n+                    ResolvedJavaField field = fields[i];\n+                    if (field.isInternal() || isHiddenFromReflection(field)) {\n+                        continue;\n+                    }\n+                    Field reflectField = reflectFields.get(reflectFieldIndex++);\n+                    ResolvedJavaField field2 = lookupField(fields, reflectField);\n+\n+                    assertEquals(\"ResolvedJavaType.getInstanceFields order differs from Class.getDeclaredFields\", field, field2);\n@@ -966,1 +975,1 @@\n-                for (ResolvedJavaField rf : actual) {\n+                for (ResolvedJavaField rf : fields) {\n@@ -968,1 +977,1 @@\n-                        assertEquals(rf.toString(), lookupField(expected, rf) != null, !rf.isInternal());\n+                        assertEquals(rf.toString(), lookupField(reflectFields, rf) != null, !rf.isInternal());\n@@ -973,2 +982,2 @@\n-                ResolvedJavaField[] actual2 = type.getInstanceFields(includeSuperclasses);\n-                assertArrayEquals(actual, actual2);\n+                ResolvedJavaField[] fields2 = type.getInstanceFields(includeSuperclasses);\n+                assertArrayEquals(fields, fields2);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -344,0 +344,30 @@\n+    public static final String REARRANGE_VB = VECTOR_PREFIX + \"REARRANGE_VB\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VB, \"VectorRearrange\", TYPE_BYTE);\n+    }\n+\n+    public static final String REARRANGE_VS = VECTOR_PREFIX + \"REARRANGE_VS\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VS, \"VectorRearrange\", TYPE_SHORT);\n+    }\n+\n+    public static final String REARRANGE_VI = VECTOR_PREFIX + \"REARRANGE_VI\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VI, \"VectorRearrange\", TYPE_INT);\n+    }\n+\n+    public static final String REARRANGE_VL = VECTOR_PREFIX + \"REARRANGE_VL\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VL, \"VectorRearrange\", TYPE_LONG);\n+    }\n+\n+    public static final String REARRANGE_VF = VECTOR_PREFIX + \"REARRANGE_VF\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VF, \"VectorRearrange\", TYPE_FLOAT);\n+    }\n+\n+    public static final String REARRANGE_VD = VECTOR_PREFIX + \"REARRANGE_VD\" + POSTFIX;\n+    static {\n+        vectorNode(REARRANGE_VD, \"VectorRearrange\", TYPE_DOUBLE);\n+    }\n+\n@@ -352,2 +382,2 @@\n-        String optoRegex = \"(.*precise .*\\\\R((.*(?i:mov|mv|xorl|nop|spill|pushq|popq).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: C2 Runtime new_instance\" + END;\n-        allocNodes(ALLOC, \"Allocate\", optoRegex);\n+        String regex = START + \"Allocate\\\\b\" + MID + END;\n+        macroNodes(ALLOC, regex);\n@@ -358,2 +388,2 @@\n-        String regex = \"(.*precise .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|mv|xorl|nop|spill|pushq|popq).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: C2 Runtime new_instance\" + END;\n-        optoOnly(ALLOC_OF, regex);\n+        String regex = START + \"Allocate\\\\b\" + MID + \"allocationKlass:.*\\\\b\" + IS_REPLACED + \"\\\\s.*\" + END;\n+        macroNodes(ALLOC_OF, regex);\n@@ -364,2 +394,2 @@\n-        String optoRegex = \"(.*precise \\\\[.*\\\\R((.*(?i:mov|mv|xor|nop|spill|pushq|popq).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: C2 Runtime new_array\" + END;\n-        allocNodes(ALLOC_ARRAY, \"AllocateArray\", optoRegex);\n+        String regex = START + \"AllocateArray\\\\b\" + MID + END;\n+        macroNodes(ALLOC_ARRAY,  regex);\n@@ -370,2 +400,21 @@\n-        String regex = \"(.*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|mv|xorl|nop|spill|pushq|popq).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: C2 Runtime new_array\" + END;\n-        optoOnly(ALLOC_ARRAY_OF, regex);\n+        \/\/ Assuming we are looking for an array of \"some\/package\/MyClass\". The printout is\n+        \/\/ [Lsome\/package\/MyClass;\n+        \/\/ or, with more dimensions\n+        \/\/ [[[Lsome\/package\/MyClass;\n+\n+        \/\/ Case where the searched string is a not fully qualified name (but maybe partially qualified):\n+        \/\/ package\/MyClass or MyClass\n+        \/\/ The \".*\\\\b\" will eat the \"some\/\" and \"some\/package\/\" resp.\n+        String partial_name_prefix = \".+\\\\b\";\n+\n+        \/\/ The thing after \"allocationKlass:\" (the name of the allocated class) is a sequence of:\n+        \/\/ - a non-empty sequence of \"[\"\n+        \/\/ - a single character (\"L\"),\n+        \/\/ - maybe a non-empty sequence of characters ending on a word boundary\n+        \/\/   this sequence is omitted if the given name is already fully qualified (exact match)\n+        \/\/   but will eat the package path prefix in the cases described above\n+        \/\/ - the name we are looking for\n+        \/\/ - the final \";\".\n+        String name_part = \"\\\\[+.(\" + partial_name_prefix + \")?\" + IS_REPLACED + \";\";\n+        String regex = START + \"AllocateArray\\\\b\" + MID + \"allocationKlass:\" + name_part + \".*\" + END;\n+        macroNodes(ALLOC_ARRAY_OF, regex);\n@@ -1829,1 +1878,1 @@\n-        beforeMatchingNameRegex(SUB, \"Sub(I|L|F|D)\");\n+        beforeMatchingNameRegex(SUB, \"Sub(I|L|F|D|HF)\");\n@@ -2012,0 +2061,15 @@\n+    public static final String VECTOR_BLEND_S = VECTOR_PREFIX + \"VECTOR_BLEND_S\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_BLEND_S, \"VectorBlend\", TYPE_SHORT);\n+    }\n+\n+    public static final String VECTOR_BLEND_I = VECTOR_PREFIX + \"VECTOR_BLEND_I\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_BLEND_I, \"VectorBlend\", TYPE_INT);\n+    }\n+\n+    public static final String VECTOR_BLEND_L = VECTOR_PREFIX + \"VECTOR_BLEND_L\" + POSTFIX;\n+    static {\n+        vectorNode(VECTOR_BLEND_L, \"VectorBlend\", TYPE_LONG);\n+    }\n+\n@@ -2573,1 +2637,2 @@\n-        macroNodes(MOD_F, \"ModF\");\n+        String regex = START + \"ModF\" + MID + END;\n+        macroNodes(MOD_F, regex);\n@@ -2578,1 +2643,2 @@\n-        macroNodes(MOD_D, \"ModD\");\n+        String regex = START + \"ModD\" + MID + END;\n+        macroNodes(MOD_D, regex);\n@@ -2616,10 +2682,0 @@\n-    private static void allocNodes(String irNode, String irNodeName, String optoRegex) {\n-        String idealIndependentRegex = START + irNodeName + \"\\\\b\" + MID + END;\n-        Map<PhaseInterval, String> intervalToRegexMap = new HashMap<>();\n-        intervalToRegexMap.put(new PhaseInterval(CompilePhase.BEFORE_REMOVEUSELESS, CompilePhase.PHASEIDEALLOOP_ITERATIONS),\n-                               idealIndependentRegex);\n-        intervalToRegexMap.put(new PhaseInterval(CompilePhase.PRINT_OPTO_ASSEMBLY), optoRegex);\n-        MultiPhaseRangeEntry entry = new MultiPhaseRangeEntry(CompilePhase.PRINT_OPTO_ASSEMBLY, intervalToRegexMap);\n-        IR_NODE_MAPPINGS.put(irNode, entry);\n-    }\n-\n@@ -2629,2 +2685,1 @@\n-    private static void macroNodes(String irNodePlaceholder, String irNodeRegex) {\n-        String regex = START + irNodeRegex + MID + END;\n+    private static void macroNodes(String irNodePlaceholder, String regex) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":78,"deletions":23,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+    private boolean isAllowNotCompilable = false;\n@@ -412,0 +413,13 @@\n+    \/**\n+     * In rare cases, methods may not be compilable because of a compilation bailout. By default, this leads to a\n+     * test failure. However, if such cases are expected in multiple methods in a test class, this flag can be set to\n+     * true, which allows any test to pass even if there is a compilation bailout. If only selected methods are prone\n+     * to bail out, it is preferred to use {@link Test#allowNotCompilable()} instead for more fine-grained control.\n+     * By setting this flag, any associated {@link IR} rule of a test is only executed if the test method was compiled,\n+     * and else it is ignored silently.\n+     *\/\n+    public TestFramework allowNotCompilable() {\n+        this.isAllowNotCompilable = true;\n+        return this;\n+    }\n+\n@@ -788,1 +802,1 @@\n-                                                        testClassesOnBootClassPath);\n+                                                        isAllowNotCompilable, testClassesOnBootClassPath);\n@@ -791,1 +805,1 @@\n-                TestClassParser testClassParser = new TestClassParser(testClass);\n+                TestClassParser testClassParser = new TestClassParser(testClass, isAllowNotCompilable);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    private static final boolean ALLOW_METHOD_NOT_COMPILABLE = Boolean.getBoolean(\"AllowNotCompilable\");\n@@ -586,0 +587,1 @@\n+        boolean allowNotCompilable = testAnno.allowNotCompilable() || ALLOW_METHOD_NOT_COMPILABLE;\n@@ -587,1 +589,1 @@\n-        DeclaredTest test = new DeclaredTest(m, argumentsProvider, compLevel, warmupIterations);\n+        DeclaredTest test = new DeclaredTest(m, argumentsProvider, compLevel, warmupIterations, allowNotCompilable);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -544,3 +544,2 @@\n-# First bug for AIX, second for Windows\n-com\/sun\/management\/OperatingSystemMXBean\/GetProcessCpuLoad.java 8030957,8351002 aix-all,windows-all\n-com\/sun\/management\/OperatingSystemMXBean\/GetSystemCpuLoad.java  8030957,8351002 aix-all,windows-all\n+com\/sun\/management\/OperatingSystemMXBean\/GetProcessCpuLoad.java 8030957 aix-all\n+com\/sun\/management\/OperatingSystemMXBean\/GetSystemCpuLoad.java  8030957 aix-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}